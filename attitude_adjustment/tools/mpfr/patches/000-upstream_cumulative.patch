diff -Naurd mpfr-3.0.0-a/PATCHES mpfr-3.0.0-b/PATCHES
--- mpfr-3.0.0-a/PATCHES	2010-06-23 11:02:49.000000000 +0000
+++ mpfr-3.0.0-b/PATCHES	2010-06-23 11:03:36.000000000 +0000
@@ -0,0 +1 @@
+mpfr_out_str
diff -Naurd mpfr-3.0.0-a/VERSION mpfr-3.0.0-b/VERSION
--- mpfr-3.0.0-a/VERSION	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/VERSION	2010-06-23 11:03:20.000000000 +0000
@@ -1 +1 @@
-3.0.0
+3.0.0-p1
diff -Naurd mpfr-3.0.0-a/mpfr.h mpfr-3.0.0-b/mpfr.h
--- mpfr-3.0.0-a/mpfr.h	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.h	2010-06-23 11:03:20.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 0
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.0.0"
+#define MPFR_VERSION_STRING "3.0.0-p1"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.0.0-a/mpfr.texi mpfr-3.0.0-b/mpfr.texi
--- mpfr-3.0.0-a/mpfr.texi	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.texi	2010-06-23 11:03:12.000000000 +0000
@@ -2050,7 +2050,7 @@
 are printed. If @var{base} is greater than 10, @samp{@@} will be used
 instead of @samp{e} as exponent delimiter.
 
-Return the number of bytes written, or if an error occurred, return 0.
+Return the number of characters written, or if an error occurred, return 0.
 @end deftypefun
 
 @deftypefun size_t mpfr_inp_str (mpfr_t @var{rop}, FILE *@var{stream}, int @var{base}, mpfr_rnd_t @var{rnd})
diff -Naurd mpfr-3.0.0-a/out_str.c mpfr-3.0.0-b/out_str.c
--- mpfr-3.0.0-a/out_str.c	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/out_str.c	2010-06-23 11:03:12.000000000 +0000
@@ -22,6 +22,16 @@
 
 #include "mpfr-impl.h"
 
+/* Warning! S should not contain "%". */
+#define OUT_STR_RET(S)                          \
+  do                                            \
+    {                                           \
+      int r;                                    \
+      r = fprintf (stream, (S));                \
+      return r < 0 ? 0 : r;                     \
+    }                                           \
+  while (0)
+
 size_t
 mpfr_out_str (FILE *stream, int base, size_t n_digits, mpfr_srcptr op,
               mpfr_rnd_t rnd_mode)
@@ -29,6 +39,7 @@
   char *s, *s0;
   size_t l;
   mpfr_exp_t e;
+  int err;
 
   MPFR_ASSERTN (base >= 2 && base <= 62);
 
@@ -36,37 +47,16 @@
   if (stream == NULL)
     stream = stdout;
 
-  if (MPFR_IS_NAN(op))
-    {
-      fprintf (stream, "@NaN@");
-      return 3;
-    }
-
-  if (MPFR_IS_INF(op))
-    {
-      if (MPFR_SIGN(op) > 0)
-        {
-          fprintf (stream, "@Inf@");
-          return 3;
-        }
-      else
-        {
-          fprintf (stream, "-@Inf@");
-          return 4;
-        }
-    }
-
-  if (MPFR_IS_ZERO(op))
+  if (MPFR_UNLIKELY (MPFR_IS_SINGULAR (op)))
     {
-      if (MPFR_SIGN(op) > 0)
-        {
-          fprintf(stream, "0");
-          return 1;
-        }
+      if (MPFR_IS_NAN (op))
+        OUT_STR_RET ("@NaN@");
+      else if (MPFR_IS_INF (op))
+        OUT_STR_RET (MPFR_IS_POS (op) ? "@Inf@" : "-@Inf@");
       else
         {
-          fprintf(stream, "-0");
-          return 2;
+          MPFR_ASSERTD (MPFR_IS_ZERO (op));
+          OUT_STR_RET (MPFR_IS_POS (op) ? "0" : "-0");
         }
     }
 
@@ -77,21 +67,31 @@
 
   l = strlen (s) + 1; /* size of allocated block returned by mpfr_get_str
                          - may be incorrect, as only an upper bound? */
-  if (*s == '-')
-    fputc (*s++, stream);
 
-  /* outputs mantissa */
-  fputc (*s++, stream); e--; /* leading digit */
-  fputc ((unsigned char) MPFR_DECIMAL_POINT, stream);
-  fputs (s, stream);         /* rest of mantissa */
+  /* outputs possible sign and significand */
+  err = (*s == '-' && fputc (*s++, stream) == EOF)
+    || fputc (*s++, stream) == EOF  /* leading digit */
+    || fputc ((unsigned char) MPFR_DECIMAL_POINT, stream) == EOF
+    || fputs (s, stream) == EOF;     /* trailing significand */
   (*__gmp_free_func) (s0, l);
+  if (MPFR_UNLIKELY (err))
+    return 0;
+
+  e--;  /* due to the leading digit */
 
   /* outputs exponent */
   if (e)
     {
+      int r;
+
       MPFR_ASSERTN(e >= LONG_MIN);
       MPFR_ASSERTN(e <= LONG_MAX);
-      l += fprintf (stream, (base <= 10 ? "e%ld" : "@%ld"), (long) e);
+
+      r = fprintf (stream, (base <= 10 ? "e%ld" : "@%ld"), (long) e);
+      if (MPFR_UNLIKELY (r < 0))
+        return 0;
+
+      l += r;
     }
 
   return l;
diff -Naurd mpfr-3.0.0-a/tests/tout_str.c mpfr-3.0.0-b/tests/tout_str.c
--- mpfr-3.0.0-a/tests/tout_str.c	2010-06-10 11:00:13.000000000 +0000
+++ mpfr-3.0.0-b/tests/tout_str.c	2010-06-23 11:03:12.000000000 +0000
@@ -46,22 +46,54 @@
 special (void)
 {
   mpfr_t x;
+  unsigned int n;
 
   mpfr_init (x);
 
   mpfr_set_nan (x);
-  mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  if (n != 5)
+    {
+      printf ("Error: mpfr_out_str (file, 10, 0, NaN, MPFR_RNDN) wrote %u "
+              "characters instead of 5.\n", n);
+      exit (1);
+    }
 
   mpfr_set_inf (x, 1);
-  mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  if (n != 5)
+    {
+      printf ("Error: mpfr_out_str (file, 10, 0, +Inf, MPFR_RNDN) wrote %u "
+               "characters instead of 5.\n", n);
+      exit (1);
+    }
 
   mpfr_set_inf (x, -1);
-  mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  if (n != 6)
+    {
+      printf ("Error: mpfr_out_str (file, 10, 0, -Inf, MPFR_RNDN) wrote %u "
+               "characters instead of 6.\n", n);
+      exit (1);
+    }
 
   mpfr_set_ui (x, 0, MPFR_RNDN);
-  mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  if (n != 1)
+    {
+      printf ("Error: mpfr_out_str (file, 10, 0, +0, MPFR_RNDN) wrote %u "
+               "characters instead of 1.\n", n);
+      exit (1);
+    }
+
   mpfr_neg (x, x, MPFR_RNDN);
-  mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  n = mpfr_out_str (fout, 10, 0, x, MPFR_RNDN);
+  if (n != 2)
+    {
+      printf ("Error: mpfr_out_str (file, 10, 0, -0, MPFR_RNDN) wrote %u "
+               "characters instead of 2.\n", n);
+      exit (1);
+    }
 
   mpfr_clear (x);
 }
diff -Naurd mpfr-3.0.0-a/version.c mpfr-3.0.0-b/version.c
--- mpfr-3.0.0-a/version.c	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/version.c	2010-06-23 11:03:20.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.0.0";
+  return "3.0.0-p1";
 }
diff -Naurd mpfr-3.0.0-a/Makefile.in mpfr-3.0.0-b/Makefile.in
--- mpfr-3.0.0-a/Makefile.in	2010-06-10 11:00:52.000000000 +0000
+++ mpfr-3.0.0-b/Makefile.in	2010-06-10 11:00:52.000000000 +0000
@@ -239,6 +239,7 @@
 distuninstallcheck_listfiles = find . -type f -print
 distcleancheck_listfiles = find . -type f -print
 ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
 AR = @AR@
 AS = @AS@
diff -Naurd mpfr-3.0.0-a/PATCHES mpfr-3.0.0-b/PATCHES
--- mpfr-3.0.0-a/PATCHES	2010-06-23 11:03:36.000000000 +0000
+++ mpfr-3.0.0-b/PATCHES	2010-06-25 13:23:13.000000000 +0000
@@ -0,0 +1 @@
+alloca
diff -Naurd mpfr-3.0.0-a/VERSION mpfr-3.0.0-b/VERSION
--- mpfr-3.0.0-a/VERSION	2010-06-23 11:03:20.000000000 +0000
+++ mpfr-3.0.0-b/VERSION	2010-06-25 13:23:13.000000000 +0000
@@ -1 +1 @@
-3.0.0-p1
+3.0.0-p2
diff -Naurd mpfr-3.0.0-a/acinclude.m4 mpfr-3.0.0-b/acinclude.m4
--- mpfr-3.0.0-a/acinclude.m4	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/acinclude.m4	2010-06-10 11:00:14.000000000 +0000
@@ -59,6 +59,9 @@
 dnl sys/fpu.h - MIPS specific
 AC_CHECK_HEADERS([sys/time.h sys/fpu.h])
 
+dnl Check how to get `alloca'
+AC_FUNC_ALLOCA
+
 dnl SIZE_MAX macro
 gl_SIZE_MAX
 
diff -Naurd mpfr-3.0.0-a/configure mpfr-3.0.0-b/configure
--- mpfr-3.0.0-a/configure	2010-06-10 11:00:51.000000000 +0000
+++ mpfr-3.0.0-b/configure	2010-06-25 13:23:05.000000000 +0000
@@ -783,6 +783,7 @@
 OBJDUMP
 DLLTOOL
 AS
+ALLOCA
 MPFR_LIBM
 ANSI2KNR
 U
@@ -5622,6 +5623,197 @@
 done
 
 
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for working alloca.h" >&5
+$as_echo_n "checking for working alloca.h... " >&6; }
+if test "${ac_cv_working_alloca_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+			  if (p) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_working_alloca_h=yes
+else
+  ac_cv_working_alloca_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_working_alloca_h" >&5
+$as_echo "$ac_cv_working_alloca_h" >&6; }
+if test $ac_cv_working_alloca_h = yes; then
+
+$as_echo "#define HAVE_ALLOCA_H 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for alloca" >&5
+$as_echo_n "checking for alloca... " >&6; }
+if test "${ac_cv_func_alloca_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  ifdef HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int
+main ()
+{
+char *p = (char *) alloca (1);
+				    if (p) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_func_alloca_works=yes
+else
+  ac_cv_func_alloca_works=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_alloca_works" >&5
+$as_echo "$ac_cv_func_alloca_works" >&6; }
+
+if test $ac_cv_func_alloca_works = yes; then
+
+$as_echo "#define HAVE_ALLOCA 1" >>confdefs.h
+
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
+
+ALLOCA=\${LIBOBJDIR}alloca.$ac_objext
+
+$as_echo "#define C_ALLOCA 1" >>confdefs.h
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether \`alloca.c' needs Cray hooks" >&5
+$as_echo_n "checking whether \`alloca.c' needs Cray hooks... " >&6; }
+if test "${ac_cv_os_cray+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#if defined CRAY && ! defined CRAY2
+webecray
+#else
+wenotbecray
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then :
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_os_cray" >&5
+$as_echo "$ac_cv_os_cray" >&6; }
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking stack direction for C alloca" >&5
+$as_echo_n "checking stack direction for C alloca... " >&6; }
+if test "${ac_cv_c_stack_direction+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then :
+  ac_cv_c_stack_direction=0
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_includes_default
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  return find_stack_direction () < 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_c_stack_direction=1
+else
+  ac_cv_c_stack_direction=-1
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_stack_direction" >&5
+$as_echo "$ac_cv_c_stack_direction" >&6; }
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+
 
   for ac_header in stdint.h
 do :
@@ -7564,13 +7756,13 @@
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:7567: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:7759: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:7570: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:7762: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:7573: output\"" >&5)
+  (eval echo "\"\$as_me:7765: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -8772,7 +8964,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 8775 "configure"' > conftest.$ac_ext
+  echo '#line 8967 "configure"' > conftest.$ac_ext
   if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -10032,11 +10224,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:10035: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:10227: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:10039: \$? = $ac_status" >&5
+   echo "$as_me:10231: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -10371,11 +10563,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:10374: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:10566: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:10378: \$? = $ac_status" >&5
+   echo "$as_me:10570: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -10476,11 +10668,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:10479: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:10671: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:10483: \$? = $ac_status" >&5
+   echo "$as_me:10675: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -10531,11 +10723,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:10534: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:10726: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:10538: \$? = $ac_status" >&5
+   echo "$as_me:10730: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -12915,7 +13107,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12918 "configure"
+#line 13110 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -13011,7 +13203,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 13014 "configure"
+#line 13206 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff -Naurd mpfr-3.0.0-a/mpfr.h mpfr-3.0.0-b/mpfr.h
--- mpfr-3.0.0-a/mpfr.h	2010-06-23 11:03:20.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.h	2010-06-25 13:23:13.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 0
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.0.0-p1"
+#define MPFR_VERSION_STRING "3.0.0-p2"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.0.0-a/tests/Makefile.in mpfr-3.0.0-b/tests/Makefile.in
--- mpfr-3.0.0-a/tests/Makefile.in	2010-06-10 11:00:52.000000000 +0000
+++ mpfr-3.0.0-b/tests/Makefile.in	2010-06-10 11:00:52.000000000 +0000
@@ -960,6 +960,7 @@
 red=; grn=; lgn=; blu=; std=
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
 AR = @AR@
 AS = @AS@
diff -Naurd mpfr-3.0.0-a/version.c mpfr-3.0.0-b/version.c
--- mpfr-3.0.0-a/version.c	2010-06-23 11:03:20.000000000 +0000
+++ mpfr-3.0.0-b/version.c	2010-06-25 13:23:13.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.0.0-p1";
+  return "3.0.0-p2";
 }
diff -Naurd mpfr-3.0.0-a/PATCHES mpfr-3.0.0-b/PATCHES
--- mpfr-3.0.0-a/PATCHES	2010-07-10 00:11:19.000000000 +0000
+++ mpfr-3.0.0-b/PATCHES	2010-07-10 00:12:50.000000000 +0000
@@ -0,0 +1 @@
+gamma_underflow
diff -Naurd mpfr-3.0.0-a/VERSION mpfr-3.0.0-b/VERSION
--- mpfr-3.0.0-a/VERSION	2010-06-25 13:23:13.000000000 +0000
+++ mpfr-3.0.0-b/VERSION	2010-07-10 00:11:53.000000000 +0000
@@ -1 +1 @@
-3.0.0-p2
+3.0.0-p3
diff -Naurd mpfr-3.0.0-a/gamma.c mpfr-3.0.0-b/gamma.c
--- mpfr-3.0.0-a/gamma.c	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/gamma.c	2010-07-10 00:11:46.000000000 +0000
@@ -274,7 +274,7 @@
       /* we want an upper bound for x * [log(2-x)-1].
          since x < 0, we need a lower bound on log(2-x) */
       mpfr_ui_sub (xp, 2, x, MPFR_RNDD);
-      mpfr_log (xp, xp, MPFR_RNDD);
+      mpfr_log2 (xp, xp, MPFR_RNDD);
       mpfr_sub_ui (xp, xp, 1, MPFR_RNDD);
       mpfr_mul (xp, xp, x, MPFR_RNDU);
 
@@ -303,8 +303,8 @@
         {
           mpfr_sub (tmp, tmp, tmp2, MPFR_RNDZ); /* low bnd on |sin(Pi*(2-x))| */
           mpfr_ui_div (tmp, 12, tmp, MPFR_RNDU); /* upper bound */
-          mpfr_log (tmp, tmp, MPFR_RNDU);
-          mpfr_add (tmp, tmp, xp, MPFR_RNDU);
+          mpfr_log2 (tmp, tmp, MPFR_RNDU);
+          mpfr_add (xp, tmp, xp, MPFR_RNDU);
           underflow = mpfr_cmp_si (xp, expo.saved_emin - 2) <= 0;
         }
 
diff -Naurd mpfr-3.0.0-a/mpfr.h mpfr-3.0.0-b/mpfr.h
--- mpfr-3.0.0-a/mpfr.h	2010-06-25 13:23:13.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.h	2010-07-10 00:11:53.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 0
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.0.0-p2"
+#define MPFR_VERSION_STRING "3.0.0-p3"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.0.0-a/tests/tgamma.c mpfr-3.0.0-b/tests/tgamma.c
--- mpfr-3.0.0-a/tests/tgamma.c	2010-06-10 11:00:13.000000000 +0000
+++ mpfr-3.0.0-b/tests/tgamma.c	2010-07-10 00:11:46.000000000 +0000
@@ -461,6 +461,20 @@
   mpfr_clear (x);
 }
 
+/* bug found by Stathis, only occurs on 32-bit machines */
+static void
+test20100709 (void)
+{
+  mpfr_t x;
+  int inex;
+
+  mpfr_init2 (x, 100);
+  mpfr_set_str (x, "-4.6308260837372266e+07", 10, MPFR_RNDN);
+  inex = mpfr_gamma (x, x, MPFR_RNDN);
+  MPFR_ASSERTN(MPFR_IS_ZERO(x) && MPFR_IS_NEG(x) && inex > 0);
+  mpfr_clear (x);
+}
+
 int
 main (int argc, char *argv[])
 {
@@ -471,6 +485,7 @@
   test_generic (2, 100, 2);
   gamma_integer ();
   test20071231 ();
+  test20100709 ();
 
   data_check ("data/gamma", mpfr_gamma, "mpfr_gamma");
 
diff -Naurd mpfr-3.0.0-a/version.c mpfr-3.0.0-b/version.c
--- mpfr-3.0.0-a/version.c	2010-06-25 13:23:13.000000000 +0000
+++ mpfr-3.0.0-b/version.c	2010-07-10 00:11:53.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.0.0-p2";
+  return "3.0.0-p3";
 }
diff -Naurd mpfr-3.0.0-a/PATCHES mpfr-3.0.0-b/PATCHES
--- mpfr-3.0.0-a/PATCHES	2010-09-07 08:44:01.000000000 +0000
+++ mpfr-3.0.0-b/PATCHES	2010-09-07 08:48:46.000000000 +0000
@@ -0,0 +1 @@
+mpfr_cmp/set_ui/si
diff -Naurd mpfr-3.0.0-a/VERSION mpfr-3.0.0-b/VERSION
--- mpfr-3.0.0-a/VERSION	2010-07-10 00:11:53.000000000 +0000
+++ mpfr-3.0.0-b/VERSION	2010-09-07 08:46:06.000000000 +0000
@@ -1 +1 @@
-3.0.0-p3
+3.0.0-p4
diff -Naurd mpfr-3.0.0-a/mpfr.h mpfr-3.0.0-b/mpfr.h
--- mpfr-3.0.0-a/mpfr.h	2010-07-10 00:11:53.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.h	2010-09-07 08:46:06.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 0
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.0.0-p3"
+#define MPFR_VERSION_STRING "3.0.0-p4"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
@@ -798,35 +798,45 @@
      anyway. Checking with other ICC versions is needed. Possibly detect
      whether warnings are produced or not with a configure test.
    + Remove C++ too, since it complains too much. */
+/* Added casts to improve robustness in case of undefined behavior and
+   compiler extensions based on UB (in particular -fwrapv). MPFR doesn't
+   use such extensions, but these macros will be used by 3rd-party code,
+   where such extensions may be required.
+   Moreover casts to unsigned long have been added to avoid warnings in
+   programs that use MPFR and are compiled with -Wconversion; such casts
+   are OK since if X is a constant expression, then (unsigned long) X is
+   also a constant expression, so that the optimizations still work. */
 #if defined (__GNUC__) && !defined(__ICC) && !defined(__cplusplus)
 #if (__GNUC__ >= 2)
 #undef mpfr_cmp_ui
-/* We use the fact that mpfr_sgn on NaN sets the erange flag and returns 0. */
-#define mpfr_cmp_ui(_f,_u)                 \
- (__builtin_constant_p (_u) && (_u) == 0 ? \
-   mpfr_sgn (_f) :                         \
-   mpfr_cmp_ui_2exp ((_f),(_u),0))
+/* We use the fact that mpfr_sgn on NaN sets the erange flag and returns 0.
+   But warning! mpfr_sgn is specified as a macro in the API, thus the macro
+   mustn't be used if side effects are possible, like here. */
+#define mpfr_cmp_ui(_f,_u)                                      \
+  (__builtin_constant_p (_u) && (unsigned long) (_u) == 0 ?     \
+   (mpfr_sgn) (_f) :                                            \
+   mpfr_cmp_ui_2exp ((_f), (unsigned long) (_u), 0))
 #undef mpfr_cmp_si
-#define mpfr_cmp_si(_f,_s)                 \
- (__builtin_constant_p (_s) && (_s) >= 0 ? \
-   mpfr_cmp_ui ((_f), (_s)) :              \
-   mpfr_cmp_si_2exp ((_f), (_s), 0))
+#define mpfr_cmp_si(_f,_s)                              \
+  (__builtin_constant_p (_s) && (long) (_s) >= 0 ?      \
+   mpfr_cmp_ui ((_f), (unsigned long) (long) (_s)) :    \
+   mpfr_cmp_si_2exp ((_f), (long) (_s), 0))
 #if __GNUC__ > 2 || __GNUC_MINOR__ >= 95
 #undef mpfr_set_ui
-#define mpfr_set_ui(_f,_u,_r)              \
- (__builtin_constant_p (_u) && (_u) == 0 ? \
-   __extension__ ({                        \
-     mpfr_ptr _p = (_f);                   \
-     _p->_mpfr_sign = 1;                   \
-     _p->_mpfr_exp = __MPFR_EXP_ZERO;      \
-     (void) (_r); 0; }) :                  \
-   mpfr_set_ui_2exp ((_f), (_u), 0, (_r)))
+#define mpfr_set_ui(_f,_u,_r)                                   \
+  (__builtin_constant_p (_u) && (unsigned long) (_u) == 0 ?     \
+   __extension__ ({                                             \
+       mpfr_ptr _p = (_f);                                      \
+       _p->_mpfr_sign = 1;                                      \
+       _p->_mpfr_exp = __MPFR_EXP_ZERO;                         \
+       (void) (_r); 0; }) :                                     \
+   mpfr_set_ui_2exp ((_f), (unsigned long) (_u), 0, (_r)))
 #endif
 #undef mpfr_set_si
-#define mpfr_set_si(_f,_s,_r)              \
- (__builtin_constant_p (_s) && (_s) >= 0 ? \
-   mpfr_set_ui ((_f), (_s), (_r)) :        \
-   mpfr_set_si_2exp ((_f), (_s), 0, (_r)))
+#define mpfr_set_si(_f,_s,_r)                                   \
+  (__builtin_constant_p (_s) && (long) (_s) >= 0 ?              \
+   mpfr_set_ui ((_f), (unsigned long) (long) (_s), (_r)) :      \
+   mpfr_set_si_2exp ((_f), (long) (_s), 0, (_r)))
 #endif
 #endif
 
diff -Naurd mpfr-3.0.0-a/tests/tcmp_ui.c mpfr-3.0.0-b/tests/tcmp_ui.c
--- mpfr-3.0.0-a/tests/tcmp_ui.c	2010-06-10 11:00:13.000000000 +0000
+++ mpfr-3.0.0-b/tests/tcmp_ui.c	2010-09-07 08:45:12.000000000 +0000
@@ -88,6 +88,126 @@
   mpfr_clear (x);
 }
 
+/* Since mpfr_cmp_ui and mpfr_cmp_si are also implemented by a macro
+   with __builtin_constant_p for GCC, check that side effects are
+   handled correctly. */
+static void
+check_macros (void)
+{
+  mpfr_t x;
+  int c;
+
+  mpfr_init2 (x, 32);
+
+  c = 0;
+  mpfr_set_ui (x, 17, MPFR_RNDN);
+  if (mpfr_cmp_ui (x, 17) != 0)
+    {
+      printf ("Error 1 on mpfr_cmp_ui(x,17) in check_macros\n");
+      exit (1);
+    }
+  if (mpfr_cmp_ui (x, (c++, 17)) != 0)
+    {
+      printf ("Error 2 on mpfr_cmp_ui(x,17) in check_macros\n");
+      exit (1);
+    }
+  if (c != 1)
+    {
+      printf ("Error 3 on mpfr_cmp_ui(x,17) in check_macros\n"
+              "(c = %d instead of 1)\n", c);
+      exit (1);
+    }
+  if (mpfr_cmp_si (x, 17) != 0)
+    {
+      printf ("Error 1 on mpfr_cmp_si(x,17) in check_macros\n");
+      exit (1);
+    }
+  if (mpfr_cmp_si (x, (c++, 17)) != 0)
+    {
+      printf ("Error 2 on mpfr_cmp_si(x,17) in check_macros\n");
+      exit (1);
+    }
+  if (c != 2)
+    {
+      printf ("Error 3 on mpfr_cmp_si(x,17) in check_macros\n"
+              "(c = %d instead of 2)\n", c);
+      exit (1);
+    }
+
+  c = 0;
+  mpfr_set_ui (x, 0, MPFR_RNDN);
+  if (mpfr_cmp_ui (x, 0) != 0)
+    {
+      printf ("Error 1 on mpfr_cmp_ui(x,0) in check_macros\n");
+      exit (1);
+    }
+  if (mpfr_cmp_ui (x, (c++, 0)) != 0)
+    {
+      printf ("Error 2 on mpfr_cmp_ui(x,0) in check_macros\n");
+      exit (1);
+    }
+  if (c != 1)
+    {
+      printf ("Error 3 on mpfr_cmp_ui(x,0) in check_macros\n"
+              "(c = %d instead of 1)\n", c);
+      exit (1);
+    }
+  if (mpfr_cmp_si (x, 0) != 0)
+    {
+      printf ("Error 1 on mpfr_cmp_si(x,0) in check_macros\n");
+      exit (1);
+    }
+  if (mpfr_cmp_si (x, (c++, 0)) != 0)
+    {
+      printf ("Error 2 on mpfr_cmp_si(x,0) in check_macros\n");
+      exit (1);
+    }
+  if (c != 2)
+    {
+      printf ("Error 3 on mpfr_cmp_si(x,0) in check_macros\n"
+              "(c = %d instead of 2)\n", c);
+      exit (1);
+    }
+
+  mpfr_clear (x);
+}
+
+/* Bug in r7114 */
+static void
+test_macros (void)
+{
+  mpfr_t x[3];
+  mpfr_ptr p;
+
+  mpfr_inits (x[0], x[1], x[2], (mpfr_ptr) 0);
+  mpfr_set_ui (x[0], 0, MPFR_RNDN);
+  p = x[0];
+  if (mpfr_cmp_ui (p++, 0) != 0)
+    {
+      printf ("Error in mpfr_cmp_ui macro: result should be 0.\n");
+      exit (1);
+    }
+  if (p != x[1])
+    {
+      printf ("Error in mpfr_cmp_ui macro: p - x[0] = %d (expecting 1)\n",
+              (int) (p - x[0]));
+      exit (1);
+    }
+  p = x[0];
+  if (mpfr_cmp_si (p++, 0) != 0)
+    {
+      printf ("Error in mpfr_cmp_si macro: result should be 0.\n");
+      exit (1);
+    }
+  if (p != x[1])
+    {
+      printf ("Error in mpfr_cmp_si macro: p - x[0] = %d (expecting 1)\n",
+              (int) (p - x[0]));
+      exit (1);
+    }
+  mpfr_clears (x[0], x[1], x[2], (mpfr_ptr) 0);
+}
+
 int
 main (void)
 {
@@ -216,6 +336,8 @@
   mpfr_clear (x);
 
   check_nan ();
+  check_macros ();
+  test_macros ();
 
   tests_end_mpfr ();
   return 0;
diff -Naurd mpfr-3.0.0-a/version.c mpfr-3.0.0-b/version.c
--- mpfr-3.0.0-a/version.c	2010-07-10 00:11:53.000000000 +0000
+++ mpfr-3.0.0-b/version.c	2010-09-07 08:46:06.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.0.0-p3";
+  return "3.0.0-p4";
 }
diff -Naurd mpfr-3.0.0-a/PATCHES mpfr-3.0.0-b/PATCHES
--- mpfr-3.0.0-a/PATCHES	2010-10-21 20:28:38.000000000 +0000
+++ mpfr-3.0.0-b/PATCHES	2010-10-21 20:28:38.000000000 +0000
@@ -0,0 +1 @@
+tcan_round
diff -Naurd mpfr-3.0.0-a/VERSION mpfr-3.0.0-b/VERSION
--- mpfr-3.0.0-a/VERSION	2010-09-07 08:46:06.000000000 +0000
+++ mpfr-3.0.0-b/VERSION	2010-10-21 20:28:38.000000000 +0000
@@ -1 +1 @@
-3.0.0-p4
+3.0.0-p5
diff -Naurd mpfr-3.0.0-a/mpfr.h mpfr-3.0.0-b/mpfr.h
--- mpfr-3.0.0-a/mpfr.h	2010-09-07 08:46:06.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.h	2010-10-21 20:28:38.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 0
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.0.0-p4"
+#define MPFR_VERSION_STRING "3.0.0-p5"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.0.0-a/tests/tcan_round.c mpfr-3.0.0-b/tests/tcan_round.c
--- mpfr-3.0.0-a/tests/tcan_round.c	2010-06-10 11:00:13.000000000 +0000
+++ mpfr-3.0.0-b/tests/tcan_round.c	2010-10-21 20:28:38.000000000 +0000
@@ -41,7 +41,7 @@
       /* avoid mpn_random which leaks memory */
       for (i = 0; i < n; i++)
         buf[i] = randlimb ();
-      p = (mpfr_prec_t) randlimb() % ((n-1) * GMP_NUMB_BITS) + MPFR_PREC_MIN;
+      p = randlimb() % ((n-1) * GMP_NUMB_BITS) + MPFR_PREC_MIN;
       err = p + randlimb () % GMP_NUMB_BITS;
       r1 = mpfr_round_p (buf, n, err, p);
       r2 = mpfr_can_round_raw (buf, n, MPFR_SIGN_POS, err,
diff -Naurd mpfr-3.0.0-a/version.c mpfr-3.0.0-b/version.c
--- mpfr-3.0.0-a/version.c	2010-09-07 08:46:06.000000000 +0000
+++ mpfr-3.0.0-b/version.c	2010-10-21 20:28:38.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.0.0-p4";
+  return "3.0.0-p5";
 }
diff -Naurd mpfr-3.0.0-a/PATCHES mpfr-3.0.0-b/PATCHES
--- mpfr-3.0.0-a/PATCHES	2010-10-21 20:59:32.000000000 +0000
+++ mpfr-3.0.0-b/PATCHES	2010-10-21 20:59:32.000000000 +0000
@@ -0,0 +1 @@
+mpfr_sub1
diff -Naurd mpfr-3.0.0-a/VERSION mpfr-3.0.0-b/VERSION
--- mpfr-3.0.0-a/VERSION	2010-10-21 20:28:38.000000000 +0000
+++ mpfr-3.0.0-b/VERSION	2010-10-21 20:59:32.000000000 +0000
@@ -1 +1 @@
-3.0.0-p5
+3.0.0-p6
diff -Naurd mpfr-3.0.0-a/mpfr.h mpfr-3.0.0-b/mpfr.h
--- mpfr-3.0.0-a/mpfr.h	2010-10-21 20:28:38.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.h	2010-10-21 20:59:32.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 0
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.0.0-p5"
+#define MPFR_VERSION_STRING "3.0.0-p6"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.0.0-a/sub1.c mpfr-3.0.0-b/sub1.c
--- mpfr-3.0.0-a/sub1.c	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/sub1.c	2010-10-21 20:59:32.000000000 +0000
@@ -37,7 +37,9 @@
   mp_size_t cancel2, an, bn, cn, cn0;
   mp_limb_t *ap, *bp, *cp;
   mp_limb_t carry, bb, cc, borrow = 0;
-  int inexact, shift_b, shift_c, is_exact = 1, down = 0, add_exp = 0;
+  int inexact, shift_b, shift_c, add_exp = 0;
+  int cmp_low = 0; /* used for rounding to nearest: 0 if low(b) = low(c),
+                      negative if low(b) < low(c), positive if low(b)>low(c) */
   int sh, k;
   MPFR_TMP_DECL(marker);
 
@@ -196,7 +198,8 @@
     }
 
 #ifdef DEBUG
-  printf ("shift_b=%d shift_c=%d diffexp=%lu\n", shift_b, shift_c,
+  printf ("rnd=%s shift_b=%d shift_c=%d diffexp=%lu\n",
+          mpfr_print_rnd_mode (rnd_mode), shift_b, shift_c,
           (unsigned long) diff_exp);
 #endif
 
@@ -307,17 +310,18 @@
     {
       if (MPFR_LIKELY(sh))
         {
-          is_exact = (carry == 0);
           /* can decide except when carry = 2^(sh-1) [middle]
              or carry = 0 [truncate, but cannot decide inexact flag] */
-          down = (carry < (MPFR_LIMB_ONE << (sh - 1)));
           if (carry > (MPFR_LIMB_ONE << (sh - 1)))
             goto add_one_ulp;
-          else if ((0 < carry) && down)
+          else if ((0 < carry) && (carry < (MPFR_LIMB_ONE << (sh - 1))))
             {
               inexact = -1; /* result if smaller than exact value */
               goto truncate;
             }
+          /* now carry = 2^(sh-1), in which case cmp_low=2,
+             or carry = 0, in which case cmp_low=0 */
+          cmp_low = (carry == 0) ? 0 : 2;
         }
     }
   else /* directed rounding: set rnd_mode to RNDZ iff toward zero */
@@ -344,12 +348,32 @@
   cn -= (long int) an + cancel2;
 
 #ifdef DEBUG
-  printf ("last %d bits from a are %lu, bn=%ld, cn=%ld\n",
+  printf ("last sh=%d bits from a are %lu, bn=%ld, cn=%ld\n",
           sh, (unsigned long) carry, (long) bn, (long) cn);
 #endif
 
+  /* for rounding to nearest, we couldn't conclude up to here in the following
+     cases:
+     1. sh = 0, then cmp_low=0: we can either truncate, subtract one ulp
+        or add one ulp: -1 ulp < low(b)-low(c) < 1 ulp
+     2. sh > 0 but the low sh bits from high(b)-high(c) equal 2^(sh-1):
+        -0.5 ulp <= -1/2^sh < low(b)-low(c)-0.5 < 1/2^sh <= 0.5 ulp
+        we can't decide the rounding, in that case cmp_low=2:
+        either we truncate and flag=-1, or we add one ulp and flag=1
+     3. the low sh>0 bits from high(b)-high(c) equal 0: we know we have to
+        truncate but we can't decide the ternary value, here cmp_low=0:
+        -0.5 ulp <= -1/2^sh < low(b)-low(c) < 1/2^sh <= 0.5 ulp
+        we always truncate and inexact can be any of -1,0,1
+  */
+
+  /* note: here cn might exceed cn0, in which case we consider a zero limb */
   for (k = 0; (bn > 0) || (cn > 0); k = 1)
     {
+      /* if cmp_low < 0, we know low(b) - low(c) < 0
+         if cmp_low > 0, we know low(b) - low(c) > 0
+            (more precisely if cmp_low = 2, low(b) - low(c) = 0.5 ulp so far)
+         if cmp_low = 0, so far low(b) - low(c) = 0 */
+
       /* get next limbs */
       bb = (bn > 0) ? bp[--bn] : 0;
       if ((cn > 0) && (cn-- <= cn0))
@@ -357,76 +381,115 @@
       else
         cc = 0;
 
-      /* down is set when low(b) < low(c) */
-      if (down == 0)
-        down = (bb < cc);
+      /* cmp_low compares low(b) and low(c) */
+      if (cmp_low == 0) /* case 1 or 3 */
+        cmp_low = (bb < cc) ? -2+k : (bb > cc) ? 1 : 0;
+
+      /* Case 1 for k=0 splits into 7 subcases:
+         1a: bb > cc + half
+         1b: bb = cc + half
+         1c: 0 < bb - cc < half
+         1d: bb = cc
+         1e: -half < bb - cc < 0
+         1f: bb - cc = -half
+         1g: bb - cc < -half
+
+         Case 2 splits into 3 subcases:
+         2a: bb > cc
+         2b: bb = cc
+         2c: bb < cc
+
+         Case 3 splits into 3 subcases:
+         3a: bb > cc
+         3b: bb = cc
+         3c: bb < cc
+      */
 
       /* the case rounding to nearest with sh=0 is special since one couldn't
          subtract above 1/2 ulp in the trailing limb of the result */
-      if ((rnd_mode == MPFR_RNDN) && sh == 0 && k == 0)
+      if (rnd_mode == MPFR_RNDN && sh == 0 && k == 0) /* case 1 for k=0 */
         {
           mp_limb_t half = MPFR_LIMB_HIGHBIT;
 
-          is_exact = (bb == cc);
-
           /* add one ulp if bb > cc + half
              truncate if cc - half < bb < cc + half
              sub one ulp if bb < cc - half
           */
 
-          if (down)
+          if (cmp_low < 0) /* bb < cc: -1 ulp < low(b) - low(c) < 0,
+                              cases 1e, 1f and 1g */
             {
               if (cc >= half)
                 cc -= half;
-              else
+              else /* since bb < cc < half, bb+half < 2*half */
                 bb += half;
+              /* now we have bb < cc + half:
+                 we have to subtract one ulp if bb < cc,
+                 and truncate if bb > cc */
             }
-          else /* bb >= cc */
+          else if (cmp_low >= 0) /* bb >= cc, cases 1a to 1d */
             {
               if (cc < half)
                 cc += half;
-              else
+              else /* since bb >= cc >= half, bb - half >= 0 */
                 bb -= half;
+              /* now we have bb > cc - half: we have to add one ulp if bb > cc,
+                 and truncate if bb < cc */
+              if (cmp_low > 0)
+                cmp_low = 2;
             }
         }
 
 #ifdef DEBUG
-      printf ("    bb=%lu cc=%lu down=%d is_exact=%d\n",
-              (unsigned long) bb, (unsigned long) cc, down, is_exact);
+      printf ("k=%u bb=%lu cc=%lu cmp_low=%d\n", k,
+              (unsigned long) bb, (unsigned long) cc, cmp_low);
 #endif
-      if (bb < cc)
+      if (cmp_low < 0) /* low(b) - low(c) < 0: either truncate or subtract
+                          one ulp */
         {
           if (rnd_mode == MPFR_RNDZ)
-            goto sub_one_ulp;
+            goto sub_one_ulp; /* set inexact=-1 */
           else if (rnd_mode != MPFR_RNDN) /* round away */
             {
               inexact = 1;
               goto truncate;
             }
-          else /* round to nearest: special case here since for sh=k=0
-                  bb = bb0 - MPFR_LIMB_HIGHBIT */
+          else /* round to nearest */
             {
-              if (is_exact && sh == 0)
-                {
-                  /* For k=0 we can't decide exactness since it may depend
-                     from low order bits.
-                     For k=1, the first low limbs matched: low(b)-low(c)<0. */
-                  if (k)
-                    {
-                      inexact = 1;
-                      goto truncate;
-                    }
-                }
-              else if (down && sh == 0)
-                goto sub_one_ulp;
-              else
-                {
-                  inexact = (is_exact) ? 1 : -1;
+              /* If cmp_low < 0 and bb > cc, then -0.5 ulp < low(b)-low(c) < 0,
+                 whatever the value of sh.
+                 If sh>0, then cmp_low < 0 implies that the initial neglected
+                 sh bits were 0 (otherwise cmp_low=2 initially), thus the
+                 weight of the new bits is less than 0.5 ulp too.
+                 If k > 0 (and sh=0) this means that either the first neglected
+                 limbs bb and cc were equal (thus cmp_low was 0 for k=0),
+                 or we had bb - cc = -0.5 ulp or 0.5 ulp.
+                 The last case is not possible here since we would have
+                 cmp_low > 0 which is sticky.
+                 In the first case (where we have cmp_low = -1), we truncate,
+                 whereas in the 2nd case we have cmp_low = -2 and we subtract
+                 one ulp.
+              */
+              if (bb > cc || sh > 0 || cmp_low == -1)
+                {  /* -0.5 ulp < low(b)-low(c) < 0,
+                      bb > cc corresponds to cases 1e and 1f1
+                      sh > 0 corresponds to cases 3c and 3b3
+                      cmp_low = -1 corresponds to case 1d3 (also 3b3) */
+                  inexact = 1;
                   goto truncate;
                 }
+              else if (bb < cc) /* here sh = 0 and low(b)-low(c) < -0.5 ulp,
+                                   this corresponds to cases 1g and 1f3 */
+                goto sub_one_ulp;
+              /* the only case where we can't conclude is sh=0 and bb=cc,
+                 i.e., we have low(b) - low(c) = -0.5 ulp (up to now), thus
+                 we don't know if we must truncate or subtract one ulp.
+                 Note: for sh=0 we can't have low(b) - low(c) = -0.5 ulp up to
+                 now, since low(b) - low(c) > 1/2^sh */
             }
         }
-      else if (bb > cc)
+      else if (cmp_low > 0) /* 0 < low(b) - low(c): either truncate or
+                               add one ulp */
         {
           if (rnd_mode == MPFR_RNDZ)
             {
@@ -437,34 +500,70 @@
             goto add_one_ulp;
           else /* round to nearest */
             {
-              if (is_exact)
+              if (bb > cc)
                 {
-                  inexact = -1;
-                  goto truncate;
+                  /* if sh=0, then bb>cc means that low(b)-low(c) > 0.5 ulp,
+                     and similarly when cmp_low=2 */
+                  if (cmp_low == 2) /* cases 1a, 1b1, 2a and 2b1 */
+                    goto add_one_ulp;
+                  /* sh > 0 and cmp_low > 0: this implies that the sh initial
+                     neglected bits were 0, and the remaining low(b)-low(c)>0,
+                     but its weight is less than 0.5 ulp */
+                  else /* 0 < low(b) - low(c) < 0.5 ulp, this corresponds to
+                          cases 3a, 1d1 and 3b1 */
+                    {
+                      inexact = -1;
+                      goto truncate;
+                    }
                 }
-              else if (down)
+              else if (bb < cc) /* 0 < low(b) - low(c) < 0.5 ulp, cases 1c,
+                                   1b3, 2b3 and 2c */
                 {
-                  inexact = 1;
+                  inexact = -1;
                   goto truncate;
                 }
-              else
-                goto add_one_ulp;
+              /* the only case where we can't conclude is bb=cc, i.e.,
+                 low(b) - low(c) = 0.5 ulp (up to now), thus we don't know
+                 if we must truncate or add one ulp. */
             }
         }
+      /* after k=0, we cannot conclude in the following cases, we split them
+         according to the values of bb and cc for k=1:
+         1b. sh=0 and cmp_low = 1 and bb-cc = half [around 0.5 ulp]
+             1b1. bb > cc: add one ulp, inex = 1
+             1b2: bb = cc: cannot conclude
+             1b3: bb < cc: truncate, inex = -1
+         1d. sh=0 and cmp_low = 0 and bb-cc = 0 [around 0]
+             1d1: bb > cc: truncate, inex = -1
+             1d2: bb = cc: cannot conclude
+             1d3: bb < cc: truncate, inex = +1
+         1f. sh=0 and cmp_low = -1 and bb-cc = -half [around -0.5 ulp]
+             1f1: bb > cc: truncate, inex = +1
+             1f2: bb = cc: cannot conclude
+             1f3: bb < cc: sub one ulp, inex = -1
+         2b. sh > 0 and cmp_low = 2 and bb=cc [around 0.5 ulp]
+             2b1. bb > cc: add one ulp, inex = 1
+             2b2: bb = cc: cannot conclude
+             2b3: bb < cc: truncate, inex = -1
+         3b. sh > 0 and cmp_low = 0 [around 0]
+             3b1. bb > cc: truncate, inex = -1
+             3b2: bb = cc: cannot conclude
+             3b3: bb < cc: truncate, inex = +1
+      */
     }
 
-  if ((rnd_mode == MPFR_RNDN) && !is_exact)
+  if ((rnd_mode == MPFR_RNDN) && cmp_low != 0)
     {
       /* even rounding rule */
       if ((ap[0] >> sh) & 1)
         {
-          if (down)
+          if (cmp_low < 0)
             goto sub_one_ulp;
           else
             goto add_one_ulp;
         }
       else
-        inexact = (down) ? 1 : -1;
+        inexact = (cmp_low > 0) ? -1 : 1;
     }
   else
     inexact = 0;
diff -Naurd mpfr-3.0.0-a/tests/tfma.c mpfr-3.0.0-b/tests/tfma.c
--- mpfr-3.0.0-a/tests/tfma.c	2010-06-10 11:00:13.000000000 +0000
+++ mpfr-3.0.0-b/tests/tfma.c	2010-10-21 20:59:32.000000000 +0000
@@ -337,6 +337,94 @@
   mpfr_clears (x, y, z, r, (mpfr_ptr) 0);
 }
 
+static void
+bug20101018 (void)
+{
+  mpfr_t x, y, z, t, u;
+  int i;
+
+  mpfr_init2 (x, 64);
+  mpfr_init2 (y, 64);
+  mpfr_init2 (z, 64);
+  mpfr_init2 (t, 64);
+  mpfr_init2 (u, 64);
+
+  mpfr_set_str (x, "0xf.fffffffffffffffp-14766", 16, MPFR_RNDN);
+  mpfr_set_str (y, "-0xf.fffffffffffffffp+317", 16, MPFR_RNDN);
+  mpfr_set_str (z, "0x8.3ffffffffffe3ffp-14443", 16, MPFR_RNDN);
+  mpfr_set_str (t, "0x8.7ffffffffffc7ffp-14444", 16, MPFR_RNDN);
+  i = mpfr_fma (u, x, y, z, MPFR_RNDN);
+  if (mpfr_cmp (u, t) != 0)
+    {
+      printf ("Wrong result in bug20101018 (a)\n");
+      printf ("Expected ");
+      mpfr_out_str (stdout, 16, 0, t, MPFR_RNDN);
+      printf ("\nGot      ");
+      mpfr_out_str (stdout, 16, 0, u, MPFR_RNDN);
+      printf ("\n");
+      exit (1);
+    }
+  if (i <= 0)
+    {
+      printf ("Wrong ternary value in bug20101018 (a)\n");
+      printf ("Expected > 0\n");
+      printf ("Got      %d\n", i);
+      exit (1);
+    }
+
+  mpfr_set_str (x, "-0xf.fffffffffffffffp-11420", 16, MPFR_RNDN);
+  mpfr_set_str (y, "0xf.fffffffffffffffp+9863", 16, MPFR_RNDN);
+  mpfr_set_str (z, "0x8.fffff80ffffffffp-1551", 16, MPFR_RNDN);
+  mpfr_set_str (t, "0x9.fffff01ffffffffp-1552", 16, MPFR_RNDN);
+  i = mpfr_fma (u, x, y, z, MPFR_RNDN);
+  if (mpfr_cmp (u, t) != 0)
+    {
+      printf ("Wrong result in bug20101018 (b)\n");
+      printf ("Expected ");
+      mpfr_out_str (stdout, 16, 0, t, MPFR_RNDN);
+      printf ("\nGot      ");
+      mpfr_out_str (stdout, 16, 0, u, MPFR_RNDN);
+      printf ("\n");
+      exit (1);
+    }
+  if (i <= 0)
+    {
+      printf ("Wrong ternary value in bug20101018 (b)\n");
+      printf ("Expected > 0\n");
+      printf ("Got      %d\n", i);
+      exit (1);
+    }
+
+  mpfr_set_str (x, "0xf.fffffffffffffffp-2125", 16, MPFR_RNDN);
+  mpfr_set_str (y, "-0xf.fffffffffffffffp-6000", 16, MPFR_RNDN);
+  mpfr_set_str (z, "0x8p-8119", 16, MPFR_RNDN);
+  mpfr_set_str (t, "0x8.000000000000001p-8120", 16, MPFR_RNDN);
+  i = mpfr_fma (u, x, y, z, MPFR_RNDN);
+  if (mpfr_cmp (u, t) != 0)
+    {
+      printf ("Wrong result in bug20101018 (c)\n");
+      printf ("Expected ");
+      mpfr_out_str (stdout, 16, 0, t, MPFR_RNDN);
+      printf ("\nGot      ");
+      mpfr_out_str (stdout, 16, 0, u, MPFR_RNDN);
+      printf ("\n");
+      exit (1);
+    }
+  if (i <= 0)
+    {
+      printf ("Wrong ternary value in bug20101018 (c)\n");
+      printf ("Expected > 0\n");
+      printf ("Got      %d\n", i);
+      exit (1);
+    }
+
+  mpfr_clear (x);
+  mpfr_clear (y);
+  mpfr_clear (z);
+  mpfr_clear (t);
+  mpfr_clear (u);
+}
+
 int
 main (int argc, char *argv[])
 {
@@ -345,6 +433,8 @@
 
   tests_start_mpfr ();
 
+  bug20101018 ();
+
   mpfr_init (x);
   mpfr_init (s);
   mpfr_init (y);
diff -Naurd mpfr-3.0.0-a/tests/tsub.c mpfr-3.0.0-b/tests/tsub.c
--- mpfr-3.0.0-a/tests/tsub.c	2010-06-10 11:00:13.000000000 +0000
+++ mpfr-3.0.0-b/tests/tsub.c	2010-10-21 20:59:32.000000000 +0000
@@ -201,6 +201,8 @@
   if (mpfr_cmp (z, x))
     {
       printf ("Error in mpfr_sub (2)\n");
+      printf ("Expected "); mpfr_print_binary (x); puts ("");
+      printf ("Got      "); mpfr_print_binary (z); puts ("");
       exit (1);
     }
   mpfr_set_str_binary (x, "1.1110111011110001110111011111111111101000011001011100101100101101");
@@ -478,6 +480,156 @@
   mpfr_clear (u);
 }
 
+/* Bug found by Jakub Jelinek
+ * http://bugzilla.redhat.com/643657
+ * https://gforge.inria.fr/tracker/index.php?func=detail&aid=11301
+ * The consequence can be either an assertion failure (i = 2 in the
+ * testcase below, in debug mode) or an incorrectly rounded value.
+ */
+static void
+bug20101017 (void)
+{
+  mpfr_t a, b, c;
+  int inex;
+  int i;
+
+  mpfr_init2 (a, GMP_NUMB_BITS * 2);
+  mpfr_init2 (b, GMP_NUMB_BITS);
+  mpfr_init2 (c, GMP_NUMB_BITS);
+
+  /* a = 2^(2N) + k.2^(2N-1) + 2^N and b = 1
+     with N = GMP_NUMB_BITS and k = 0 or 1.
+     c = a - b should round to the same value as a. */
+
+  for (i = 2; i <= 3; i++)
+    {
+      mpfr_set_ui_2exp (a, i, GMP_NUMB_BITS - 1, MPFR_RNDN);
+      mpfr_add_ui (a, a, 1, MPFR_RNDN);
+      mpfr_mul_2ui (a, a, GMP_NUMB_BITS, MPFR_RNDN);
+      mpfr_set_ui (b, 1, MPFR_RNDN);
+      inex = mpfr_sub (c, a, b, MPFR_RNDN);
+      mpfr_set (b, a, MPFR_RNDN);
+      if (! mpfr_equal_p (c, b))
+        {
+          printf ("Error in bug20101017 for i = %d.\n", i);
+          printf ("Expected ");
+          mpfr_out_str (stdout, 16, 0, b, MPFR_RNDN);
+          putchar ('\n');
+          printf ("Got      ");
+          mpfr_out_str (stdout, 16, 0, c, MPFR_RNDN);
+          putchar ('\n');
+          exit (1);
+        }
+      if (inex >= 0)
+        {
+          printf ("Error in bug20101017 for i = %d: bad inex value.\n", i);
+          printf ("Expected negative, got %d.\n", inex);
+          exit (1);
+        }
+    }
+
+  mpfr_set_prec (a, 64);
+  mpfr_set_prec (b, 129);
+  mpfr_set_prec (c, 2);
+  mpfr_set_str_binary (b, "0.100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001E65");
+  mpfr_set_str_binary (c, "0.10E1");
+  inex = mpfr_sub (a, b, c, MPFR_RNDN);
+  if (mpfr_cmp_ui_2exp (a, 1, 64) != 0 || inex >= 0)
+    {
+      printf ("Error in mpfr_sub for b-c for b=2^64+1+2^(-64), c=1\n");
+      printf ("Expected result 2^64 with inex < 0\n");
+      printf ("Got "); mpfr_print_binary (a);
+      printf (" with inex=%d\n", inex);
+      exit (1);
+    }
+
+  mpfr_clears (a, b, c, (mpfr_ptr) 0);
+}
+
+/* hard test of rounding */
+static void
+check_rounding (void)
+{
+  mpfr_t a, b, c, res;
+  mpfr_prec_t p;
+  long k, l;
+  int i;
+
+#define MAXKL (2 * GMP_NUMB_BITS)
+  for (p = MPFR_PREC_MIN; p <= GMP_NUMB_BITS; p++)
+    {
+      mpfr_init2 (a, p);
+      mpfr_init2 (res, p);
+      mpfr_init2 (b, p + 1 + MAXKL);
+      mpfr_init2 (c, MPFR_PREC_MIN);
+
+      /* b = 2^p + 1 + 2^(-k), c = 2^(-l) */
+      for (k = 0; k <= MAXKL; k++)
+        for (l = 0; l <= MAXKL; l++)
+          {
+            mpfr_set_ui_2exp (b, 1, p, MPFR_RNDN);
+            mpfr_add_ui (b, b, 1, MPFR_RNDN);
+            mpfr_mul_2ui (b, b, k, MPFR_RNDN);
+            mpfr_add_ui (b, b, 1, MPFR_RNDN);
+            mpfr_div_2ui (b, b, k, MPFR_RNDN);
+            mpfr_set_ui_2exp (c, 1, -l, MPFR_RNDN);
+            i = mpfr_sub (a, b, c, MPFR_RNDN);
+            /* b - c = 2^p + 1 + 2^(-k) - 2^(-l), should be rounded to
+               2^p for l <= k, and 2^p+2 for l < k */
+            if (l <= k)
+              {
+                if (mpfr_cmp_ui_2exp (a, 1, p) != 0)
+                  {
+                    printf ("Wrong result in check_rounding\n");
+                    printf ("p=%lu k=%ld l=%ld\n", p, k, l);
+                    printf ("b="); mpfr_print_binary (b); puts ("");
+                    printf ("c="); mpfr_print_binary (c); puts ("");
+                    printf ("Expected 2^%lu\n", p);
+                    printf ("Got      "); mpfr_print_binary (a); puts ("");
+                    exit (1);
+                  }
+                if (i >= 0)
+                  {
+                    printf ("Wrong ternary value in check_rounding\n");
+                    printf ("p=%lu k=%ld l=%ld\n", p, k, l);
+                    printf ("b="); mpfr_print_binary (b); puts ("");
+                    printf ("c="); mpfr_print_binary (c); puts ("");
+                    printf ("a="); mpfr_print_binary (a); puts ("");
+                    printf ("Expected < 0, got %d\n", i);
+                    exit (1);
+                  }
+              }
+            else /* l < k */
+              {
+                mpfr_set_ui_2exp (res, 1, p, MPFR_RNDN);
+                mpfr_add_ui (res, res, 2, MPFR_RNDN);
+                if (mpfr_cmp (a, res) != 0)
+                  {
+                    printf ("Wrong result in check_rounding\n");
+                    printf ("b="); mpfr_print_binary (b); puts ("");
+                    printf ("c="); mpfr_print_binary (c); puts ("");
+                    printf ("Expected "); mpfr_print_binary (res); puts ("");
+                    printf ("Got      "); mpfr_print_binary (a); puts ("");
+                    exit (1);
+                  }
+                if (i <= 0)
+                  {
+                    printf ("Wrong ternary value in check_rounding\n");
+                    printf ("b="); mpfr_print_binary (b); puts ("");
+                    printf ("c="); mpfr_print_binary (c); puts ("");
+                    printf ("Expected > 0, got %d\n", i);
+                    exit (1);
+                  }
+              }
+          }
+
+      mpfr_clear (a);
+      mpfr_clear (res);
+      mpfr_clear (b);
+      mpfr_clear (c);
+    }
+}
+
 #define TEST_FUNCTION test_sub
 #define TWO_ARGS
 #define RAND_FUNCTION(x) mpfr_random2(x, MPFR_LIMB_SIZE (x), randlimb () % 100, RANDS)
@@ -491,6 +643,8 @@
 
   tests_start_mpfr ();
 
+  bug20101017 ();
+  check_rounding ();
   check_diverse ();
   check_inexact ();
   bug_ddefour ();
diff -Naurd mpfr-3.0.0-a/version.c mpfr-3.0.0-b/version.c
--- mpfr-3.0.0-a/version.c	2010-10-21 20:28:38.000000000 +0000
+++ mpfr-3.0.0-b/version.c	2010-10-21 20:59:32.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.0.0-p5";
+  return "3.0.0-p6";
 }
diff -Naurd mpfr-3.0.0-a/PATCHES mpfr-3.0.0-b/PATCHES
--- mpfr-3.0.0-a/PATCHES	2010-10-21 21:18:26.000000000 +0000
+++ mpfr-3.0.0-b/PATCHES	2010-10-21 21:18:26.000000000 +0000
@@ -0,0 +1 @@
+mpfr_set_ld
diff -Naurd mpfr-3.0.0-a/VERSION mpfr-3.0.0-b/VERSION
--- mpfr-3.0.0-a/VERSION	2010-10-21 20:59:32.000000000 +0000
+++ mpfr-3.0.0-b/VERSION	2010-10-21 21:18:26.000000000 +0000
@@ -1 +1 @@
-3.0.0-p6
+3.0.0-p7
diff -Naurd mpfr-3.0.0-a/mpfr.h mpfr-3.0.0-b/mpfr.h
--- mpfr-3.0.0-a/mpfr.h	2010-10-21 20:59:32.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.h	2010-10-21 21:18:26.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 0
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.0.0-p6"
+#define MPFR_VERSION_STRING "3.0.0-p7"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.0.0-a/set_ld.c mpfr-3.0.0-b/set_ld.c
--- mpfr-3.0.0-a/set_ld.c	2010-06-10 11:00:14.000000000 +0000
+++ mpfr-3.0.0-b/set_ld.c	2010-10-21 21:18:26.000000000 +0000
@@ -102,21 +102,25 @@
             {
               x /= div13; /* exact */
               shift_exp += 8192;
+              mpfr_div_2si (t, t, 8192, MPFR_RNDZ);
             }
           if (ABS (x) >= div12)
             {
               x /= div12; /* exact */
               shift_exp += 4096;
+              mpfr_div_2si (t, t, 4096, MPFR_RNDZ);
             }
           if (ABS (x) >= div11)
             {
               x /= div11; /* exact */
               shift_exp += 2048;
+              mpfr_div_2si (t, t, 2048, MPFR_RNDZ);
             }
           if (ABS (x) >= div10)
             {
               x /= div10; /* exact */
               shift_exp += 1024;
+              mpfr_div_2si (t, t, 1024, MPFR_RNDZ);
             }
           /* warning: we may have DBL_MAX=2^1024*(1-2^(-53)) < x < 2^1024,
              therefore we have one extra exponent reduction step */
@@ -124,9 +128,10 @@
             {
               x /= div9; /* exact */
               shift_exp += 512;
+              mpfr_div_2si (t, t, 512, MPFR_RNDZ);
             }
         } /* Check overflow of double */
-      else
+      else /* no overflow on double */
         {
           long double div9, div10, div11;
 
@@ -149,29 +154,34 @@
                 {
                   x /= div13; /* exact */
                   shift_exp -= 8192;
+                  mpfr_mul_2si (t, t, 8192, MPFR_RNDZ);
                 }
               if (ABS (x) <= div12)
                 {
                   x /= div12; /* exact */
                   shift_exp -= 4096;
+                  mpfr_mul_2si (t, t, 4096, MPFR_RNDZ);
                 }
               if (ABS (x) <= div11)
                 {
                   x /= div11; /* exact */
                   shift_exp -= 2048;
+                  mpfr_mul_2si (t, t, 2048, MPFR_RNDZ);
                 }
               if (ABS (x) <= div10)
                 {
                   x /= div10; /* exact */
                   shift_exp -= 1024;
+                  mpfr_mul_2si (t, t, 1024, MPFR_RNDZ);
                 }
               if (ABS(x) <= div9)
                 {
                   x /= div9;  /* exact */
                   shift_exp -= 512;
+                  mpfr_mul_2si (t, t, 512, MPFR_RNDZ);
                 }
             }
-          else
+          else /* no underflow */
             {
               inexact = mpfr_set_d (u, (double) x, MPFR_RNDZ);
               MPFR_ASSERTD (inexact == 0);
diff -Naurd mpfr-3.0.0-a/tests/tset_ld.c mpfr-3.0.0-b/tests/tset_ld.c
--- mpfr-3.0.0-a/tests/tset_ld.c	2010-06-10 11:00:13.000000000 +0000
+++ mpfr-3.0.0-b/tests/tset_ld.c	2010-10-21 21:18:26.000000000 +0000
@@ -147,12 +147,39 @@
 test_fixed_bugs (void)
 {
   mpfr_t x;
-  long double d;
+  long double l, m;
 
   /* bug found by Steve Kargl (2009-03-14) */
   mpfr_init2 (x, 64);
   mpfr_set_ui_2exp (x, 1, -16447, MPFR_RNDN);
-  d = mpfr_get_ld (x, MPFR_RNDN);  /* an assertion failed in init2.c:50 */
+  mpfr_get_ld (x, MPFR_RNDN);  /* an assertion failed in init2.c:50 */
+
+  /* bug reported by Jakub Jelinek (2010-10-17)
+     https://gforge.inria.fr/tracker/?func=detail&aid=11300 */
+  mpfr_set_prec (x, MPFR_LDBL_MANT_DIG);
+  /* l = 0x1.23456789abcdef0123456789abcdp-914L; */
+  l = 8.215640181713713164092636634579e-276;
+  mpfr_set_ld (x, l, MPFR_RNDN);
+  m = mpfr_get_ld (x, MPFR_RNDN);
+  if (m != l)
+    {
+      printf ("Error in get_ld o set_ld for l=%Le\n", l);
+      printf ("Got m=%Le instead of l\n", m);
+      exit (1);
+    }
+
+  /* another similar test which failed with extended double precision and the
+     generic code for mpfr_set_ld */
+  /* l = 0x1.23456789abcdef0123456789abcdp-968L; */
+  l = 4.560596445887084662336528403703e-292;
+  mpfr_set_ld (x, l, MPFR_RNDN);
+  m = mpfr_get_ld (x, MPFR_RNDN);
+  if (m != l)
+    {
+      printf ("Error in get_ld o set_ld for l=%Le\n", l);
+      printf ("Got m=%Le instead of l\n", m);
+      exit (1);
+    }
 
   mpfr_clear (x);
 }
diff -Naurd mpfr-3.0.0-a/version.c mpfr-3.0.0-b/version.c
--- mpfr-3.0.0-a/version.c	2010-10-21 20:59:32.000000000 +0000
+++ mpfr-3.0.0-b/version.c	2010-10-21 21:18:26.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.0.0-p6";
+  return "3.0.0-p7";
 }
diff -Naurd mpfr-3.0.0-a/PATCHES mpfr-3.0.0-b/PATCHES
--- mpfr-3.0.0-a/PATCHES	2010-11-09 15:15:07.000000000 +0000
+++ mpfr-3.0.0-b/PATCHES	2010-11-09 15:15:07.000000000 +0000
@@ -0,0 +1 @@
+macros
diff -Naurd mpfr-3.0.0-a/VERSION mpfr-3.0.0-b/VERSION
--- mpfr-3.0.0-a/VERSION	2010-10-21 21:18:26.000000000 +0000
+++ mpfr-3.0.0-b/VERSION	2010-11-09 15:15:07.000000000 +0000
@@ -1 +1 @@
-3.0.0-p7
+3.0.0-p8
diff -Naurd mpfr-3.0.0-a/mpfr.h mpfr-3.0.0-b/mpfr.h
--- mpfr-3.0.0-a/mpfr.h	2010-10-21 21:18:26.000000000 +0000
+++ mpfr-3.0.0-b/mpfr.h	2010-11-09 15:15:07.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 0
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.0.0-p7"
+#define MPFR_VERSION_STRING "3.0.0-p8"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
@@ -67,6 +67,16 @@
 # define _MPFR_H_HAVE_INTMAX_T 1
 #endif
 
+/* Avoid some problems with macro expansion if the user defines macros
+   with the same name as keywords. By convention, identifiers and macro
+   names starting with mpfr_ are reserved by MPFR. */
+typedef void            mpfr_void;
+typedef int             mpfr_int;
+typedef unsigned int    mpfr_uint;
+typedef long            mpfr_long;
+typedef unsigned long   mpfr_ulong;
+typedef size_t          mpfr_size_t;
+
 /* Definition of rounding modes (DON'T USE MPFR_RNDNA!).
    Warning! Changing the contents of this enum should be seen as an
    interface change since the old and the new types are not compatible
@@ -136,7 +146,7 @@
 typedef mp_exp_t     mpfr_exp_t;
 
 /* Definition of the standard exponent limits */
-#define MPFR_EMAX_DEFAULT ((mpfr_exp_t) (((unsigned long) 1 << 30) - 1))
+#define MPFR_EMAX_DEFAULT ((mpfr_exp_t) (((mpfr_ulong) 1 << 30) - 1))
 #define MPFR_EMIN_DEFAULT (-(MPFR_EMAX_DEFAULT))
 
 /* Definition of the main structure */
@@ -725,13 +735,13 @@
    unexpected results with future compilers and aggressive optimisations.
    Why not working only with signed types, using INT_MIN and LONG_MIN? */
 #if __GMP_MP_SIZE_T_INT
-#define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(unsigned int)0)>>1))+2))
-#define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(unsigned int)0)>>1))+1))
-#define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(unsigned int)0)>>1))+3))
+#define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+2))
+#define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+1))
+#define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+3))
 #else
-#define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(unsigned long)0)>>1))+2))
-#define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(unsigned long)0)>>1))+1))
-#define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(unsigned long)0)>>1))+3))
+#define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+2))
+#define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+1))
+#define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+3))
 #endif
 
 /* Define MPFR_USE_EXTENSION to avoid "gcc -pedantic" warnings. */
@@ -760,9 +770,9 @@
 #define mpfr_inf_p(_x)      ((_x)->_mpfr_exp == __MPFR_EXP_INF)
 #define mpfr_zero_p(_x)     ((_x)->_mpfr_exp == __MPFR_EXP_ZERO)
 #define mpfr_regular_p(_x)  ((_x)->_mpfr_exp >  __MPFR_EXP_INF)
-#define mpfr_sgn(_x)                                          \
-  ((_x)->_mpfr_exp < __MPFR_EXP_INF ?                         \
-   (mpfr_nan_p (_x) ? mpfr_set_erangeflag () : (void) 0), 0 : \
+#define mpfr_sgn(_x)                                               \
+  ((_x)->_mpfr_exp < __MPFR_EXP_INF ?                              \
+   (mpfr_nan_p (_x) ? mpfr_set_erangeflag () : (mpfr_void) 0), 0 : \
    MPFR_SIGN (_x))
 
 /* Prevent them from using as lvalues */
@@ -805,7 +815,19 @@
    Moreover casts to unsigned long have been added to avoid warnings in
    programs that use MPFR and are compiled with -Wconversion; such casts
    are OK since if X is a constant expression, then (unsigned long) X is
-   also a constant expression, so that the optimizations still work. */
+   also a constant expression, so that the optimizations still work. The
+   warnings are probably related to the following two bugs:
+     http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4210
+     http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38470 (possibly a variant)
+   and the casts could be removed once these bugs are fixed.
+   Casts shouldn't be used on the generic calls (to the ..._2exp functions),
+   where implicit conversions are performed. Indeed, having at least one
+   implicit conversion in the macro allows the compiler to emit diagnostics
+   when normally expected, for instance in the following call:
+     mpfr_set_ui (x, "foo", MPFR_RNDN);
+   If this is not possible (for future macros), one of the tricks described
+   on http://groups.google.com/group/comp.std.c/msg/e92abd24bf9eaf7b could
+   be used. */
 #if defined (__GNUC__) && !defined(__ICC) && !defined(__cplusplus)
 #if (__GNUC__ >= 2)
 #undef mpfr_cmp_ui
@@ -813,45 +835,45 @@
    But warning! mpfr_sgn is specified as a macro in the API, thus the macro
    mustn't be used if side effects are possible, like here. */
 #define mpfr_cmp_ui(_f,_u)                                      \
-  (__builtin_constant_p (_u) && (unsigned long) (_u) == 0 ?     \
+  (__builtin_constant_p (_u) && (mpfr_ulong) (_u) == 0 ?        \
    (mpfr_sgn) (_f) :                                            \
-   mpfr_cmp_ui_2exp ((_f), (unsigned long) (_u), 0))
+   mpfr_cmp_ui_2exp ((_f), (_u), 0))
 #undef mpfr_cmp_si
-#define mpfr_cmp_si(_f,_s)                              \
-  (__builtin_constant_p (_s) && (long) (_s) >= 0 ?      \
-   mpfr_cmp_ui ((_f), (unsigned long) (long) (_s)) :    \
-   mpfr_cmp_si_2exp ((_f), (long) (_s), 0))
+#define mpfr_cmp_si(_f,_s)                                      \
+  (__builtin_constant_p (_s) && (mpfr_long) (_s) >= 0 ?         \
+   mpfr_cmp_ui ((_f), (mpfr_ulong) (mpfr_long) (_s)) :          \
+   mpfr_cmp_si_2exp ((_f), (_s), 0))
 #if __GNUC__ > 2 || __GNUC_MINOR__ >= 95
 #undef mpfr_set_ui
 #define mpfr_set_ui(_f,_u,_r)                                   \
-  (__builtin_constant_p (_u) && (unsigned long) (_u) == 0 ?     \
+  (__builtin_constant_p (_u) && (mpfr_ulong) (_u) == 0 ?        \
    __extension__ ({                                             \
        mpfr_ptr _p = (_f);                                      \
        _p->_mpfr_sign = 1;                                      \
        _p->_mpfr_exp = __MPFR_EXP_ZERO;                         \
-       (void) (_r); 0; }) :                                     \
-   mpfr_set_ui_2exp ((_f), (unsigned long) (_u), 0, (_r)))
+       (mpfr_void) (_r); 0; }) :                                \
+   mpfr_set_ui_2exp ((_f), (_u), 0, (_r)))
 #endif
 #undef mpfr_set_si
 #define mpfr_set_si(_f,_s,_r)                                   \
-  (__builtin_constant_p (_s) && (long) (_s) >= 0 ?              \
-   mpfr_set_ui ((_f), (unsigned long) (long) (_s), (_r)) :      \
-   mpfr_set_si_2exp ((_f), (long) (_s), 0, (_r)))
+  (__builtin_constant_p (_s) && (mpfr_long) (_s) >= 0 ?         \
+   mpfr_set_ui ((_f), (mpfr_ulong) (mpfr_long) (_s), (_r)) :    \
+   mpfr_set_si_2exp ((_f), (_s), 0, (_r)))
 #endif
 #endif
 
 /* Macro version of mpfr_stack interface for fast access */
-#define mpfr_custom_get_size(p) ((size_t)                            \
+#define mpfr_custom_get_size(p) ((mpfr_size_t)                          \
        (((p)+GMP_NUMB_BITS-1)/GMP_NUMB_BITS*sizeof (mp_limb_t)))
 #define mpfr_custom_init(m,p) do {} while (0)
-#define mpfr_custom_get_significand(x) ((void*)((x)->_mpfr_d))
+#define mpfr_custom_get_significand(x) ((mpfr_void*)((x)->_mpfr_d))
 #define mpfr_custom_get_exp(x) ((x)->_mpfr_exp)
 #define mpfr_custom_move(x,m) do { ((x)->_mpfr_d = (mp_limb_t*)(m)); } while (0)
 #define mpfr_custom_init_set(x,k,e,p,m) do {                   \
   mpfr_ptr _x = (x);                                           \
   mpfr_exp_t _e;                                               \
   mpfr_kind_t _t;                                              \
-  int _s, _k;                                                  \
+  mpfr_int _s, _k;                                             \
   _k = (k);                                                    \
   if (_k >= 0)  {                                              \
     _t = (mpfr_kind_t) _k;                                     \
@@ -868,11 +890,13 @@
   _x->_mpfr_exp  = _e;                                         \
   _x->_mpfr_d    = (mp_limb_t*) (m);                           \
  } while (0)
-#define mpfr_custom_get_kind(x)                                              \
-  ( (x)->_mpfr_exp >  __MPFR_EXP_INF ? (int)MPFR_REGULAR_KIND*MPFR_SIGN (x) \
-  : (x)->_mpfr_exp == __MPFR_EXP_INF ? (int)MPFR_INF_KIND*MPFR_SIGN (x)     \
-  : (x)->_mpfr_exp == __MPFR_EXP_NAN ? (int)MPFR_NAN_KIND                   \
-  : (int) MPFR_ZERO_KIND * MPFR_SIGN (x) )
+#define mpfr_custom_get_kind(x)                                         \
+  ( (x)->_mpfr_exp >  __MPFR_EXP_INF ?                                  \
+    (mpfr_int) MPFR_REGULAR_KIND * MPFR_SIGN (x)                        \
+  : (x)->_mpfr_exp == __MPFR_EXP_INF ?                                  \
+    (mpfr_int) MPFR_INF_KIND * MPFR_SIGN (x)                            \
+  : (x)->_mpfr_exp == __MPFR_EXP_NAN ? (mpfr_int) MPFR_NAN_KIND         \
+  : (mpfr_int) MPFR_ZERO_KIND * MPFR_SIGN (x) )
 
 
 #endif /* MPFR_USE_NO_MACRO */
diff -Naurd mpfr-3.0.0-a/version.c mpfr-3.0.0-b/version.c
--- mpfr-3.0.0-a/version.c	2010-10-21 21:18:26.000000000 +0000
+++ mpfr-3.0.0-b/version.c	2010-11-09 15:15:07.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.0.0-p7";
+  return "3.0.0-p8";
 }
