From 7c955dbf26ac09f1e4900f8e817aa8101cabcc09 Mon Sep 17 00:00:00 2001
From: Matthew Fatheree <Matthew.Fatheree@belkin.com>
Date: Mon, 12 May 2014 22:54:59 +0700
Subject: [PATCH 12/31] mamba mvebu: implement jffs2reset and switch2jffs

Mamba use the syscfg partition formatted in ubifs type as the overlay
partition to store the router configuration. jffs2reset is implemented
to support the factory reset feature with help to flush all files on the
ubifs partition. switch2jffs is implemented to support switching from
ramfs to overlay ubifs.

The system.lua file is overrided from luci, it change the condition
check for syscfg partition instead of rootfs_data. The default IP
address after reset is 192.168.200.1

Signed-off-by: Matthew Fatheree <Matthew.Fatheree@belkin.com>
---
 .../lib/firstboot/10_determine_ubifs_part          |   25 ++
 .../firstboot/31_is_rootfs_mounted_ubifs_syscfg    |   45 +++
 target/linux/armadaxp/base-files/sbin/firstboot    |   71 ++++
 .../usr/lib/lua/luci/controller/admin/system.lua   |  393 ++++++++++++++++++++
 4 files changed, 534 insertions(+)
 create mode 100644 target/linux/armadaxp/base-files/lib/firstboot/10_determine_ubifs_part
 create mode 100644 target/linux/armadaxp/base-files/lib/firstboot/31_is_rootfs_mounted_ubifs_syscfg
 create mode 100755 target/linux/armadaxp/base-files/sbin/firstboot
 create mode 100644 target/linux/armadaxp/base-files/usr/lib/lua/luci/controller/admin/system.lua

diff --git a/target/linux/armadaxp/base-files/lib/firstboot/10_determine_ubifs_part b/target/linux/armadaxp/base-files/lib/firstboot/10_determine_ubifs_part
new file mode 100644
index 0000000..de19dae
--- /dev/null
+++ b/target/linux/armadaxp/base-files/lib/firstboot/10_determine_ubifs_part
@@ -0,0 +1,25 @@
+#!/bin/sh
+# override functions and find ubifs partition
+
+set_mtd_part() {
+    partname="syscfg"
+    mtdpart="$(find_mtd_part $partname)"
+}
+
+set_rom_part() {
+    rom=$(awk '/jffs2 ro/ {print $2}' /proc/mounts)
+}
+
+set_jffs_part() {
+	jffs=$(awk '/ubifs/ {print $2}' /proc/mounts | tail -n 1)
+}
+
+determine_rom_part() {
+    check_skip || {
+	set_rom_part
+	if [ -z "$rom" ]; then
+	    echo "You do not have a read-only jffs2 partition; aborting"
+	    exit 1
+	fi
+    }
+}
diff --git a/target/linux/armadaxp/base-files/lib/firstboot/31_is_rootfs_mounted_ubifs_syscfg b/target/linux/armadaxp/base-files/lib/firstboot/31_is_rootfs_mounted_ubifs_syscfg
new file mode 100644
index 0000000..0275478
--- /dev/null
+++ b/target/linux/armadaxp/base-files/lib/firstboot/31_is_rootfs_mounted_ubifs_syscfg
@@ -0,0 +1,45 @@
+#!/bin/sh
+
+# Copyright (C) 2006-2010 OpenWrt.org
+# Copyright (C) 2010 Vertical Communications
+SYSCFG_UBIFS_MNT=/tmp/syscfg
+
+skip_if_rootfs_mounted() {
+	mtdpart_idx="$(echo $mtdpart | tr -d "/dev/mtdblock")"
+	overlay_mountpoint=/overlay
+	recover_ubifs=0
+
+	[ ! -e /dev/ubi0 ] && ubiattach -m $mtdpart_idx /dev/ubi_ctrl || recover_ubifs=1
+	if [ $recover_ubifs -eq 0 ]
+	then
+		ubi0_nod_id=`cat /sys/class/ubi/ubi0/dev | tr -s ":" " "`
+		[ ! -e /dev/ubi0 ] && mknod /dev/ubi0 c ${ubi0_nod_id}
+		if [ ! -e /sys/class/ubi/ubi0_0/dev ]
+		then
+			# no volume
+			recover_ubifs=1
+		else
+			# check for "syscfg" volume
+			ubi0_0_nod_id=`cat /sys/class/ubi/ubi0_0/dev | tr -s ":" " "`
+			[ ! -e /dev/ubi0_0 ] && mknod /dev/ubi0_0 c ${ubi0_0_nod_id}
+			{ ubinfo /dev/ubi0_0 | grep Name  | grep -qs "syscfg" ; } || \
+			recover_ubifs=1
+		fi
+	fi
+	if [ $recover_ubifs -eq 1 ]
+	then
+		echo "ubifs syscfg partition is damaged"
+		echo "try to recover by formatting $mtdpart..."
+		[ -e /dev/ubi0 ] && ubidetach -m $mtdpart_idx
+		ubiformat -y -q /dev/mtd$mtdpart_idx
+		ubiattach -m $mtdpart_idx /dev/ubi_ctrl
+		ubi0_nod_id=`cat /sys/class/ubi/ubi0/dev | tr -s ":" " "`
+		[ ! -e /dev/ubi0 ] && mknod /dev/ubi0 c ${ubi0_nod_id}
+		ubimkvol /dev/ubi0 -n 0 -N syscfg -t dynamic --maxavsize
+	fi
+	# finally mount the ubifs
+	[ ! -e $SYSCFG_UBIFS_MNT ] && mkdir -p $SYSCFG_UBIFS_MNT
+	mount -t ubifs -o noatime ubi0:syscfg $SYSCFG_UBIFS_MNT || return 1
+	[ ! -d $SYSCFG_UBIFS_MNT/openwrt_overlay ] && mkdir -p $SYSCFG_UBIFS_MNT/openwrt_overlay
+	mount -o bind $SYSCFG_UBIFS_MNT/openwrt_overlay $overlay_mountpoint
+}
diff --git a/target/linux/armadaxp/base-files/sbin/firstboot b/target/linux/armadaxp/base-files/sbin/firstboot
new file mode 100755
index 0000000..295b4d3
--- /dev/null
+++ b/target/linux/armadaxp/base-files/sbin/firstboot
@@ -0,0 +1,71 @@
+#!/bin/sh
+
+switch2jffs_hook=
+jffs2reset_hook=
+no_fo_hook=
+
+. /lib/functions/boot.sh
+
+firstboot_skip_next=false
+SYSCFG_UBIFS_MNT=/tmp/syscfg
+
+for fb_source_file in /lib/firstboot/*; do
+    . $fb_source_file
+done
+
+set_mtd_part
+set_rom_part
+set_jffs_part
+
+# invoked as an executable
+if [ "${0##*/}" = "firstboot" ]; then
+    if [ "$1" = "switch2jffs" ]; then
+	boot_run_hook switch2jffs
+    elif [ -n "$jffs" ]; then
+	reset_has_fo=true
+	echo "firstboot has already been run"
+	echo "jffs2 partition is mounted, only resetting files"
+	boot_run_hook jffs2reset
+    else
+		echo "recover ubifs_syscfg"
+		ubifs_recover_done=false
+		mtdpart_idx="$(echo $mtdpart | tr -d "/dev/mtdblock")"
+		[ -e /dev/ubi0 ] && ubidetach -m $mtdpart_idx
+		ubiattach -m $mtdpart_idx /dev/ubi_ctrl
+		if [ $? -eq 0 ]
+		then
+			{ ubinfo /dev/ubi0_0 | grep Name  | grep -qs syscfg ; } && {
+				tmp_mnt_point=/tmp/syscfg
+				mkdir -p $tmp_mnt_point 
+				mount -t ubifs ubi0:syscfg $tmp_mnt_point 
+				echo "recover ubifs by removing overlay files..."
+				if [ ! -d $tmp_mnt_point/openwrt_overlay ]
+				then
+					mkdir -p $tmp_mnt_point/openwrt_overlay
+				else
+					rm -rf $tmp_mnt_point/openwrt_overlay/*
+				fi
+				umount $tmp_mnt_point
+				rm -rf $tmp_mnt_point
+				ubifs_recover_done=true
+			}
+		fi
+		if [ "$ubifs_recover_done" = "false" ]
+		then
+			echo "recover ubifs by formatting $mtdpart..."
+			[ -e /dev/ubi0 ] && ubidetach -m $mtdpart_idx
+			ubiformat -y -q /dev/mtd$mtdpart_idx
+			ubiattach -m $mtdpart_idx /dev/ubi_ctrl
+			ubimkvol /dev/ubi0 -n 0 -N syscfg -t dynamic --maxavsize
+		fi
+		# mount pivot
+		[ -e /dev/ubi0 ] && ubidetach -m $mtdpart_idx
+		ubiattach -m $mtdpart_idx /dev/ubi_ctrl
+		mkdir -p ${SYSCFG_UBIFS_MNT}
+		mount -t ubifs -o noatime ubi0:syscfg $SYSCFG_UBIFS_MNT
+		[ ! -d $SYSCFG_UBIFS_MNT/openwrt_overlay ] && mkdir -p $SYSCFG_UBIFS_MNT/openwrt_overlay
+		mount -o bind $SYSCFG_UBIFS_MNT/openwrt_overlay /overlay
+		fopivot /overlay /rom 1
+    fi
+fi
+
diff --git a/target/linux/armadaxp/base-files/usr/lib/lua/luci/controller/admin/system.lua b/target/linux/armadaxp/base-files/usr/lib/lua/luci/controller/admin/system.lua
new file mode 100644
index 0000000..7154e41
--- /dev/null
+++ b/target/linux/armadaxp/base-files/usr/lib/lua/luci/controller/admin/system.lua
@@ -0,0 +1,393 @@
+--[[
+LuCI - Lua Configuration Interface
+
+Copyright 2008 Steven Barth <steven@midlink.org>
+Copyright 2008-2011 Jo-Philipp Wich <xm@subsignal.org>
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+$Id$
+]]--
+
+module("luci.controller.admin.system", package.seeall)
+
+function index()
+	entry({"admin", "system"}, alias("admin", "system", "system"), _("System"), 30).index = true
+	entry({"admin", "system", "system"}, cbi("admin_system/system"), _("System"), 1)
+	entry({"admin", "system", "clock_status"}, call("action_clock_status"))
+
+	entry({"admin", "system", "admin"}, cbi("admin_system/admin"), _("Administration"), 2)
+
+	if nixio.fs.access("/bin/opkg") then
+		entry({"admin", "system", "packages"}, call("action_packages"), _("Software"), 10)
+		entry({"admin", "system", "packages", "ipkg"}, form("admin_system/ipkg"))
+	end
+
+	entry({"admin", "system", "startup"}, form("admin_system/startup"), _("Startup"), 45)
+	entry({"admin", "system", "crontab"}, form("admin_system/crontab"), _("Scheduled Tasks"), 46)
+
+	if nixio.fs.access("/etc/config/fstab") then
+		entry({"admin", "system", "fstab"}, cbi("admin_system/fstab"), _("Mount Points"), 50)
+		entry({"admin", "system", "fstab", "mount"}, cbi("admin_system/fstab/mount"), nil).leaf = true
+		entry({"admin", "system", "fstab", "swap"},  cbi("admin_system/fstab/swap"),  nil).leaf = true
+	end
+
+	if nixio.fs.access("/sys/class/leds") then
+		entry({"admin", "system", "leds"}, cbi("admin_system/leds"), _("<abbr title=\"Light Emitting Diode\">LED</abbr> Configuration"), 60)
+	end
+
+	entry({"admin", "system", "flashops"}, call("action_flashops"), _("Backup / Flash Firmware"), 70)
+	entry({"admin", "system", "flashops", "backupfiles"}, form("admin_system/backupfiles"))
+
+	entry({"admin", "system", "reboot"}, call("action_reboot"), _("Reboot"), 90)
+end
+
+function action_clock_status()
+	local set = tonumber(luci.http.formvalue("set"))
+	if set ~= nil and set > 0 then
+		local date = os.date("*t", set)
+		if date then
+			luci.sys.call("date -s '%04d-%02d-%02d %02d:%02d:%02d'" %{
+				date.year, date.month, date.day, date.hour, date.min, date.sec
+			})
+		end
+	end
+
+	luci.http.prepare_content("application/json")
+	luci.http.write_json({ timestring = os.date("%c") })
+end
+
+function action_packages()
+	local ipkg = require("luci.model.ipkg")
+	local submit = luci.http.formvalue("submit")
+	local changes = false
+	local install = { }
+	local remove  = { }
+	local stdout  = { "" }
+	local stderr  = { "" }
+	local out, err
+
+	-- Display
+	local display = luci.http.formvalue("display") or "installed"
+
+	-- Letter
+	local letter = string.byte(luci.http.formvalue("letter") or "A", 1)
+	letter = (letter == 35 or (letter >= 65 and letter <= 90)) and letter or 65
+
+	-- Search query
+	local query = luci.http.formvalue("query")
+	query = (query ~= '') and query or nil
+
+
+	-- Packets to be installed
+	local ninst = submit and luci.http.formvalue("install")
+	local uinst = nil
+
+	-- Install from URL
+	local url = luci.http.formvalue("url")
+	if url and url ~= '' and submit then
+		uinst = url
+	end
+
+	-- Do install
+	if ninst then
+		install[ninst], out, err = ipkg.install(ninst)
+		stdout[#stdout+1] = out
+		stderr[#stderr+1] = err
+		changes = true
+	end
+
+	if uinst then
+		local pkg
+		for pkg in luci.util.imatch(uinst) do
+			install[uinst], out, err = ipkg.install(pkg)
+			stdout[#stdout+1] = out
+			stderr[#stderr+1] = err
+			changes = true
+		end
+	end
+
+	-- Remove packets
+	local rem = submit and luci.http.formvalue("remove")
+	if rem then
+		remove[rem], out, err = ipkg.remove(rem)
+		stdout[#stdout+1] = out
+		stderr[#stderr+1] = err
+		changes = true
+	end
+
+
+	-- Update all packets
+	local update = luci.http.formvalue("update")
+	if update then
+		update, out, err = ipkg.update()
+		stdout[#stdout+1] = out
+		stderr[#stderr+1] = err
+	end
+
+
+	-- Upgrade all packets
+	local upgrade = luci.http.formvalue("upgrade")
+	if upgrade then
+		upgrade, out, err = ipkg.upgrade()
+		stdout[#stdout+1] = out
+		stderr[#stderr+1] = err
+	end
+
+
+	-- List state
+	local no_lists = true
+	local old_lists = false
+	local tmp = nixio.fs.dir("/var/opkg-lists/")
+	if tmp then
+		for tmp in tmp do
+			no_lists = false
+			tmp = nixio.fs.stat("/var/opkg-lists/"..tmp)
+			if tmp and tmp.mtime < (os.time() - (24 * 60 * 60)) then
+				old_lists = true
+				break
+			end
+		end
+	end
+
+
+	luci.template.render("admin_system/packages", {
+		display   = display,
+		letter    = letter,
+		query     = query,
+		install   = install,
+		remove    = remove,
+		update    = update,
+		upgrade   = upgrade,
+		no_lists  = no_lists,
+		old_lists = old_lists,
+		stdout    = table.concat(stdout, ""),
+		stderr    = table.concat(stderr, "")
+	})
+
+	-- Remove index cache
+	if changes then
+		nixio.fs.unlink("/tmp/luci-indexcache")
+	end
+end
+
+function action_flashops()
+	local sys = require "luci.sys"
+	local fs  = require "luci.fs"
+
+	local upgrade_avail = nixio.fs.access("/lib/upgrade/platform.sh")
+	local reset_avail   = os.execute([[grep '"syscfg"' /proc/mtd >/dev/null 2>&1]]) == 0
+
+	local restore_cmd = "tar -xzC/ >/dev/null 2>&1"
+	local backup_cmd  = "sysupgrade --create-backup - 2>/dev/null"
+	local image_tmp   = "/tmp/firmware.img"
+
+	local function image_supported()
+		-- XXX: yay...
+		return ( 0 == os.execute(
+			". /lib/functions.sh; " ..
+			"include /lib/upgrade; " ..
+			"platform_check_image %q >/dev/null"
+				% image_tmp
+		) )
+	end
+
+	local function image_checksum()
+		return (luci.sys.exec("md5sum %q" % image_tmp):match("^([^%s]+)"))
+	end
+
+	local function storage_size()
+		local size = 0
+		if nixio.fs.access("/proc/mtd") then
+			for l in io.lines("/proc/mtd") do
+				local d, s, e, n = l:match('^([^%s]+)%s+([^%s]+)%s+([^%s]+)%s+"([^%s]+)"')
+				if n == "linux" or n == "firmware" then
+					size = tonumber(s, 16)
+					break
+				end
+			end
+		elseif nixio.fs.access("/proc/partitions") then
+			for l in io.lines("/proc/partitions") do
+				local x, y, b, n = l:match('^%s*(%d+)%s+(%d+)%s+([^%s]+)%s+([^%s]+)')
+				if b and n and not n:match('[0-9]') then
+					size = tonumber(b) * 1024
+					break
+				end
+			end
+		end
+		return size
+	end
+
+
+	local fp
+	luci.http.setfilehandler(
+		function(meta, chunk, eof)
+			if not fp then
+				if meta and meta.name == "image" then
+					fp = io.open(image_tmp, "w")
+				else
+					fp = io.popen(restore_cmd, "w")
+				end
+			end
+			if chunk then
+				fp:write(chunk)
+			end
+			if eof then
+				fp:close()
+			end
+		end
+	)
+
+	if luci.http.formvalue("backup") then
+		--
+		-- Assemble file list, generate backup
+		--
+		local reader = ltn12_popen(backup_cmd)
+		luci.http.header('Content-Disposition', 'attachment; filename="backup-%s-%s.tar.gz"' % {
+			luci.sys.hostname(), os.date("%Y-%m-%d")})
+		luci.http.prepare_content("application/x-targz")
+		luci.ltn12.pump.all(reader, luci.http.write)
+	elseif luci.http.formvalue("restore") then
+		--
+		-- Unpack received .tar.gz
+		--
+		local upload = luci.http.formvalue("archive")
+		if upload and #upload > 0 then
+			luci.template.render("admin_system/applyreboot")
+			luci.sys.reboot()
+		end
+	elseif luci.http.formvalue("image") or luci.http.formvalue("step") then
+		--
+		-- Initiate firmware flash
+		--
+		local step = tonumber(luci.http.formvalue("step") or 1)
+		if step == 1 then
+			if image_supported() then
+				luci.template.render("admin_system/upgrade", {
+					checksum = image_checksum(),
+					storage  = storage_size(),
+					size     = nixio.fs.stat(image_tmp).size,
+					keep     = (not not luci.http.formvalue("keep"))
+				})
+			else
+				nixio.fs.unlink(image_tmp)
+				luci.template.render("admin_system/flashops", {
+					reset_avail   = reset_avail,
+					upgrade_avail = upgrade_avail,
+					image_invalid = true
+				})
+			end
+		--
+		-- Start sysupgrade flash
+		--
+		elseif step == 2 then
+			local keep = (luci.http.formvalue("keep") == "1") and "" or "-n"
+			luci.template.render("admin_system/applyreboot", {
+				title = luci.i18n.translate("Flashing..."),
+				msg   = luci.i18n.translate("The system is flashing now.<br /> DO NOT POWER OFF THE DEVICE!<br /> Wait a few minutes until you try to reconnect. It might be necessary to renew the address of your computer to reach the device again, depending on your settings."),
+				addr  = (#keep > 0) and "192.168.200.1" or nil
+			})
+			fork_exec("killall dropbear uhttpd; sleep 1; /sbin/sysupgrade %s %q" %{ keep, image_tmp })
+		end
+	elseif reset_avail and luci.http.formvalue("reset") then
+		--
+		-- Reset system
+		--
+		luci.template.render("admin_system/applyreboot", {
+			title = luci.i18n.translate("Erasing..."),
+			msg   = luci.i18n.translate("The system is erasing the configuration partition now and will reboot itself when finished."),
+			addr  = "192.168.200.1"
+		})
+		fork_exec("killall dropbear uhttpd; sleep 1; /sbin/jffs2reset -y ; reboot")
+	else
+		--
+		-- Overview
+		--
+		luci.template.render("admin_system/flashops", {
+			reset_avail   = reset_avail,
+			upgrade_avail = upgrade_avail
+		})
+	end
+end
+
+function action_passwd()
+	local p1 = luci.http.formvalue("pwd1")
+	local p2 = luci.http.formvalue("pwd2")
+	local stat = nil
+
+	if p1 or p2 then
+		if p1 == p2 then
+			stat = luci.sys.user.setpasswd("root", p1)
+		else
+			stat = 10
+		end
+	end
+
+	luci.template.render("admin_system/passwd", {stat=stat})
+end
+
+function action_reboot()
+	local reboot = luci.http.formvalue("reboot")
+	luci.template.render("admin_system/reboot", {reboot=reboot})
+	if reboot then
+		luci.sys.reboot()
+	end
+end
+
+function fork_exec(command)
+	local pid = nixio.fork()
+	if pid > 0 then
+		return
+	elseif pid == 0 then
+		-- change to root dir
+		nixio.chdir("/")
+
+		-- patch stdin, out, err to /dev/null
+		local null = nixio.open("/dev/null", "w+")
+		if null then
+			nixio.dup(null, nixio.stderr)
+			nixio.dup(null, nixio.stdout)
+			nixio.dup(null, nixio.stdin)
+			if null:fileno() > 2 then
+				null:close()
+			end
+		end
+
+		-- replace with target command
+		nixio.exec("/bin/sh", "-c", command)
+	end
+end
+
+function ltn12_popen(command)
+
+	local fdi, fdo = nixio.pipe()
+	local pid = nixio.fork()
+
+	if pid > 0 then
+		fdo:close()
+		local close
+		return function()
+			local buffer = fdi:read(2048)
+			local wpid, stat = nixio.waitpid(pid, "nohang")
+			if not close and wpid and stat == "exited" then
+				close = true
+			end
+
+			if buffer and #buffer > 0 then
+				return buffer
+			elseif close then
+				fdi:close()
+				return nil
+			end
+		end
+	elseif pid == 0 then
+		nixio.dup(fdo, nixio.stdout)
+		fdi:close()
+		fdo:close()
+		nixio.exec("/bin/sh", "-c", command)
+	end
+end
-- 
1.7.9.5

