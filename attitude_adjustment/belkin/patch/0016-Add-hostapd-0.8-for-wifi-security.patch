From 229818eab2b015c28b1f35954253b1c5760d952d Mon Sep 17 00:00:00 2001
From: Matthew Fatheree <Matthew.Fatheree@belkin.com>
Date: Wed, 14 May 2014 00:05:05 +0700
Subject: [PATCH 16/31] Add hostapd 0.8 for wifi security

Signed-off-by: Matthew Fatheree <Matthew.Fatheree@belkin.com>
---
 package/hostapd/Makefile                           |   25 +-
 package/hostapd/files/hostapd-full.config          |   84 +-
 package/hostapd/files/hostapd.sh                   |   57 +-
 package/hostapd/files/wps-hotplug.sh               |   10 +-
 .../marvell/wlan/driver/linux/ap8xLnxIoctl.h       |  229 ++
 package/hostapd/patches/001-hostapd_mrvl.patch     | 2824 ++++++++++++++++++++
 package/hostapd/patches/002-hostapd-wps_led.patch  |  162 ++
 .../patches/300-nl80211_multicall_fixes.patch      |   60 -
 .../hostapd/patches/310-multicall_bridge_fix.patch |   45 -
 .../hostapd/patches/320-madwifi_key_fixes.patch    |   34 -
 package/hostapd/patches/400-noscan.patch           |   32 -
 package/hostapd/patches/410-multicall.patch        |  246 --
 package/hostapd/patches/420-timestamp_check.patch  |   12 -
 .../hostapd/patches/430-rescan_immediately.patch   |   11 -
 package/hostapd/patches/440-optional_rfkill.patch  |  261 --
 .../hostapd/patches/450-reload_freq_change.patch   |   27 -
 .../patches/451-nl80211_del_beacon_bss.patch       |   63 -
 .../hostapd/patches/452-ctrl_iface_reload.patch    |   98 -
 package/hostapd/patches/453-ap_sta_support.patch   |  223 --
 .../patches/460-disable_ctrl_iface_mib.patch       |  168 --
 .../patches/470-wpa_ie_cap_workaround.patch        |   56 -
 .../patches/480-terminate_on_setup_failure.patch   |   81 -
 .../patches/500-random_pool_add_kernel.patch       |  177 --
 .../hostapd/patches/510-bring_down_interface.patch |   19 -
 .../hostapd/patches/520-fix_wps_pin_crash.patch    |   12 -
 .../patches/530-wps_single_auth_enc_type.patch     |   25 -
 .../hostapd/patches/540-dynamic_20_40_mhz.patch    |  206 --
 .../hostapd/patches/550-limit_debug_messages.patch |  213 --
 .../hostapd/patches/560-indicate-features.patch    |   82 -
 .../hostapd/patches/570-genl_connect_debug.patch   |   11 -
 .../hostapd/patches/590-hostapd_cli_ifdef.patch    |   50 -
 ...ant-add-new-config-params-to-be-used-with.patch |  209 --
 ...80211-use-new-parameters-during-ibss-join.patch |   59 -
 .../patches/604-wpa_s-support-htmode-param.patch   |  156 --
 .../hostapd/patches/610-max_num_sta_probe.patch    |   13 -
 package/hostapd/patches/620-scan_wait.patch        |   65 -
 package/hostapd/patches/630-bool_fix.patch         |   14 -
 37 files changed, 3302 insertions(+), 2817 deletions(-)
 mode change 100644 => 100755 package/hostapd/files/hostapd.sh
 mode change 100644 => 100755 package/hostapd/files/wps-hotplug.sh
 create mode 100644 package/hostapd/marvell/wlan/driver/linux/ap8xLnxIoctl.h
 create mode 100644 package/hostapd/patches/001-hostapd_mrvl.patch
 create mode 100644 package/hostapd/patches/002-hostapd-wps_led.patch
 delete mode 100644 package/hostapd/patches/300-nl80211_multicall_fixes.patch
 delete mode 100644 package/hostapd/patches/310-multicall_bridge_fix.patch
 delete mode 100644 package/hostapd/patches/320-madwifi_key_fixes.patch
 delete mode 100644 package/hostapd/patches/400-noscan.patch
 delete mode 100644 package/hostapd/patches/410-multicall.patch
 delete mode 100644 package/hostapd/patches/420-timestamp_check.patch
 delete mode 100644 package/hostapd/patches/430-rescan_immediately.patch
 delete mode 100644 package/hostapd/patches/440-optional_rfkill.patch
 delete mode 100644 package/hostapd/patches/450-reload_freq_change.patch
 delete mode 100644 package/hostapd/patches/451-nl80211_del_beacon_bss.patch
 delete mode 100644 package/hostapd/patches/452-ctrl_iface_reload.patch
 delete mode 100644 package/hostapd/patches/453-ap_sta_support.patch
 delete mode 100644 package/hostapd/patches/460-disable_ctrl_iface_mib.patch
 delete mode 100644 package/hostapd/patches/470-wpa_ie_cap_workaround.patch
 delete mode 100644 package/hostapd/patches/480-terminate_on_setup_failure.patch
 delete mode 100644 package/hostapd/patches/500-random_pool_add_kernel.patch
 delete mode 100644 package/hostapd/patches/510-bring_down_interface.patch
 delete mode 100644 package/hostapd/patches/520-fix_wps_pin_crash.patch
 delete mode 100644 package/hostapd/patches/530-wps_single_auth_enc_type.patch
 delete mode 100644 package/hostapd/patches/540-dynamic_20_40_mhz.patch
 delete mode 100644 package/hostapd/patches/550-limit_debug_messages.patch
 delete mode 100644 package/hostapd/patches/560-indicate-features.patch
 delete mode 100644 package/hostapd/patches/570-genl_connect_debug.patch
 delete mode 100644 package/hostapd/patches/590-hostapd_cli_ifdef.patch
 delete mode 100644 package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch
 delete mode 100644 package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch
 delete mode 100644 package/hostapd/patches/604-wpa_s-support-htmode-param.patch
 delete mode 100644 package/hostapd/patches/610-max_num_sta_probe.patch
 delete mode 100644 package/hostapd/patches/620-scan_wait.patch
 delete mode 100644 package/hostapd/patches/630-bool_fix.patch

diff --git a/package/hostapd/Makefile b/package/hostapd/Makefile
index 485a8fa..dbdab92 100644
--- a/package/hostapd/Makefile
+++ b/package/hostapd/Makefile
@@ -8,16 +8,21 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=hostapd
-PKG_VERSION:=20130405
+#PKG_VERSION:=20130405
+PKG_VERSION:=0.8-snapshot
+#hostapd-0.8-snapshot.tar.gz
 PKG_RELEASE:=1
-PKG_REV:=f2f66ad7e805218468aa041985dccaf8719c296e
+#PKG_REV:=f2f66ad7e805218468aa041985dccaf8719c296e
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
 
-PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
-PKG_SOURCE_URL:=git://w1.fi/srv/git/hostap.git
+#PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
+#PKG_SOURCE_URL:=git://w1.fi/srv/git/hostap.git
+PKG_SOURCE_URL:=http://hostap.epitest.fi/releases/snapshots/
 PKG_SOURCE_SUBDIR:=$(PKG_NAME)-$(PKG_VERSION)
 PKG_SOURCE_VERSION:=$(PKG_REV)
-PKG_SOURCE_PROTO:=git
-PKG_MIRROR_MD5SUM:=5dff9bc3b8fbd9ef8a66273d5adee5a3
+#PKG_SOURCE_PROTO:=git
+#PKG_MIRROR_MD5SUM:=5dff9bc3b8fbd9ef8a66273d5adee5a3
+PKG_MIRROR_MD5SUM:=31ce79e921d4b1a4dc7d0a65d155852c
 
 PKG_MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
 
@@ -202,7 +207,7 @@ ifneq ($(wildcard $(PKG_BUILD_DIR)/.config_*),$(subst .configured_,.config_,$(ST
   define Build/Configure/rebuild
 	$(FIND) $(PKG_BUILD_DIR) -name \*.o -or -name \*.a | $(XARGS) rm -f
 	rm -f $(PKG_BUILD_DIR)/hostapd/hostapd
-	rm -f $(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant
+#	rm -f $(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant
 	rm -f $(PKG_BUILD_DIR)/.config_*
 	touch $(subst .configured_,.config_,$(STAMP_CONFIGURED))
   endef
@@ -211,14 +216,14 @@ endif
 define Build/Configure
 	$(Build/Configure/rebuild)
 	$(CP) ./files/hostapd-$(LOCAL_VARIANT).config $(PKG_BUILD_DIR)/hostapd/.config
-	$(CP) ./files/wpa_supplicant-$(LOCAL_VARIANT).config $(PKG_BUILD_DIR)/wpa_supplicant/.config
+#	$(CP) ./files/wpa_supplicant-$(LOCAL_VARIANT).config $(PKG_BUILD_DIR)/wpa_supplicant/.config
 endef
 
 TARGET_CPPFLAGS := \
 	-I$(STAGING_DIR)/usr/include/libnl-tiny \
 	-I$(PKG_BUILD_DIR)/src/crypto \
 	$(TARGET_CPPFLAGS) \
-	-I$(CURDIR)/madwifi \
+	-I$(CURDIR)/marvell/wlan \
 	-DCONFIG_LIBNL20 \
 	-D_GNU_SOURCE \
 	$(if $(CONFIG_WPA_MSG_MIN_PRIORITY),-DCONFIG_MSG_MIN_PRIORITY=$(CONFIG_WPA_MSG_MIN_PRIORITY))
@@ -306,6 +311,8 @@ ifneq ($(LOCAL_TYPE),supplicant)
 	$(INSTALL_DIR) $(1)/usr/sbin $(1)/etc/hotplug.d/button
 	$(INSTALL_BIN) $(PKG_BUILD_DIR)/hostapd/hostapd_cli $(1)/usr/sbin/
 	$(INSTALL_DATA) ./files/wps-hotplug.sh $(1)/etc/hotplug.d/button/50-wps
+	$(INSTALL_DIR) $(1)/lib/wifi/
+	$(INSTALL_BIN) ./files/wps-hotplug.sh $(1)/lib/wifi/wps-hotplug.sh
 	$(if $(CONFIG_PROCD_INIT),
 		$(INSTALL_DIR) $(1)/etc/rc.button/
 		$(INSTALL_BIN) ./files/wps-hotplug.sh $(1)/etc/rc.button/wps,
diff --git a/package/hostapd/files/hostapd-full.config b/package/hostapd/files/hostapd-full.config
index d558736..013c932 100644
--- a/package/hostapd/files/hostapd-full.config
+++ b/package/hostapd/files/hostapd-full.config
@@ -10,20 +10,17 @@
 # to override previous values of the variables.
 
 # Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
+#CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for wired authenticator
-CONFIG_DRIVER_WIRED=y
+#CONFIG_DRIVER_WIRED=y
 
 # Driver interface for madwifi driver
-CONFIG_DRIVER_MADWIFI=y
+#CONFIG_DRIVER_MADWIFI=y
 #CFLAGS += -I../../madwifi # change to the madwifi source directory
 
-# Driver interface for Prism54 driver
-#CONFIG_DRIVER_PRISM54=y
-
 # Driver interface for drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
+#CONFIG_DRIVER_NL80211=y
 # driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
 # shipped with your distribution yet. If that is the case, you need to build
 # newer libnl version and point the hostapd build to use it.
@@ -35,12 +32,24 @@ CONFIG_DRIVER_NL80211=y
 #CONFIG_DRIVER_BSD=y
 #CFLAGS += -I/usr/local/include
 #LIBS += -L/usr/local/lib
+#LIBS_p += -L/usr/local/lib
+#LIBS_c += -L/usr/local/lib
 
 # Driver interface for no driver (e.g., RADIUS server only)
 #CONFIG_DRIVER_NONE=y
 
+# Driver interface for marvell driver
+CONFIG_DRIVER_MARVELL=y
+CFLAGS += -DMRVL_WSC -DGENERIC_GETIE -DMRVL_WPS2
+# change to reflect local setup; directory for marvell src
+CFLAGS += -I../../../wlan-v5/
+CONFIG_TLS=internal
+CONFIG_INTERNAL_LIBTOMMATH=y
+#LIBS += -ldl -L../../openssl-0.9.8a/
+#CFLAGS += -I../../openssl-0.9.8a/include
+
 # IEEE 802.11F/IAPP
-CONFIG_IAPP=y
+#CONFIG_IAPP=y
 
 # WPA2/IEEE 802.11i RSN pre-authentication
 CONFIG_RSN_PREAUTH=y
@@ -55,25 +64,25 @@ CONFIG_PEERKEY=y
 #CONFIG_IEEE80211W=y
 
 # Integrated EAP server
-CONFIG_EAP=y
+#CONFIG_EAP=y
 
 # EAP-MD5 for the integrated EAP server
-CONFIG_EAP_MD5=y
+#CONFIG_EAP_MD5=y
 
 # EAP-TLS for the integrated EAP server
-CONFIG_EAP_TLS=y
+#CONFIG_EAP_TLS=y
 
 # EAP-MSCHAPv2 for the integrated EAP server
-CONFIG_EAP_MSCHAPV2=y
+#CONFIG_EAP_MSCHAPV2=y
 
 # EAP-PEAP for the integrated EAP server
-CONFIG_EAP_PEAP=y
+#CONFIG_EAP_PEAP=y
 
 # EAP-GTC for the integrated EAP server
-CONFIG_EAP_GTC=y
+#CONFIG_EAP_GTC=y
 
 # EAP-TTLS for the integrated EAP server
-CONFIG_EAP_TTLS=y
+#CONFIG_EAP_TTLS=y
 
 # EAP-SIM for the integrated EAP server
 #CONFIG_EAP_SIM=y
@@ -107,9 +116,12 @@ CONFIG_EAP_TTLS=y
 #CONFIG_EAP_FAST=y
 
 # Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
+CONFIG_WPS=y
+# Enable WSC 2.0 support
+CONFIG_WPS2=y
 # Enable UPnP support for external WPS Registrars
-#CONFIG_WPS_UPNP=y
+CONFIG_WPS_UPNP=y
+CONFIG_WPS_TESTING=y
 
 # EAP-IKEv2
 #CONFIG_EAP_IKEV2=y
@@ -119,7 +131,7 @@ CONFIG_EAP_TTLS=y
 
 # PKCS#12 (PFX) support (used to read private key and certificate file from
 # a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
+#CONFIG_PKCS12=y
 
 # RADIUS authentication server. This provides access to the integrated EAP
 # server from external hosts using RADIUS.
@@ -129,14 +141,14 @@ CONFIG_PKCS12=y
 CONFIG_IPV6=y
 
 # IEEE Std 802.11r-2008 (Fast BSS Transition)
-CONFIG_IEEE80211R=y
+#CONFIG_IEEE80211R=y
 
 # Use the hostapd's IEEE 802.11 authentication (ACL), but without
 # the IEEE 802.11 Management capability (e.g., madwifi or FreeBSD/net80211)
 #CONFIG_DRIVER_RADIUS_ACL=y
 
 # IEEE 802.11n (High Throughput) support
-CONFIG_IEEE80211N=y
+#CONFIG_IEEE80211N=y
 
 # Remove debugging code that is printing out debug messages to stdout.
 # This can be used to reduce the size of the hostapd considerably if debugging
@@ -152,13 +164,25 @@ CONFIG_IEEE80211N=y
 # Remove support for VLANs
 #CONFIG_NO_VLAN=y
 
-CONFIG_TLS=internal
-CONFIG_INTERNAL_LIBTOMMATH=y
-CONFIG_INTERNAL_AES=y
-NEED_AES_DEC=y
-
-CONFIG_NO_DUMP_STATE=y
-
-CONFIG_WPS=y
-CONFIG_FULL_DYNAMIC_VLAN=y
-
+# Remove support for dumping state into a file on SIGUSR1 signal
+# This can be used to reduce binary size at the cost of disabling a debugging
+# option.
+#CONFIG_NO_DUMP_STATE=y
+
+# Enable tracing code for developer debugging
+# This tracks use of memory allocations and other registrations and reports
+# incorrect use with a backtrace of call (or allocation) location.
+#CONFIG_WPA_TRACE=y
+# For BSD, comment out these.
+#LIBS += -lexecinfo
+#LIBS_p += -lexecinfo
+#LIBS_c += -lexecinfo
+
+# Use libbfd to get more details for developer debugging
+# This enables use of libbfd to get more detailed symbols for the backtraces
+# generated by CONFIG_WPA_TRACE=y.
+#CONFIG_WPA_TRACE_BFD=y
+# For BSD, comment out these.
+#LIBS += -lbfd -liberty -lz
+#LIBS_p += -lbfd -liberty -lz
+#LIBS_c += -lbfd -liberty -lz
diff --git a/package/hostapd/files/hostapd.sh b/package/hostapd/files/hostapd.sh
old mode 100644
new mode 100755
index 00c6a09..12ddc79
--- a/package/hostapd/files/hostapd.sh
+++ b/package/hostapd/files/hostapd.sh
@@ -9,30 +9,16 @@ hostapd_set_bss_options() {
 	config_get wpa_pair_rekey   "$vif" wpa_pair_rekey   # 300
 	config_get wpa_master_rekey "$vif" wpa_master_rekey # 640
 	config_get_bool ap_isolate "$vif" isolate 0
-	config_get_bool disassoc_low_ack "$vif" disassoc_low_ack 1
-	config_get max_num_sta "$vif" max_num_sta 0
-	config_get max_inactivity "$vif" max_inactivity 0
-	config_get_bool preamble "$vif" short_preamble 1
 
 	config_get device "$vif" device
 	config_get hwmode "$device" hwmode
 	config_get phy "$device" phy
 
-	append "$var" "ctrl_interface=/var/run/hostapd-$phy" "$N"
+	append "$var" "ctrl_interface=/var/run/hostapd-"$device"" "$N"
 
 	if [ "$ap_isolate" -gt 0 ]; then
 		append "$var" "ap_isolate=$ap_isolate" "$N"
 	fi
-	if [ "$max_num_sta" -gt 0 ]; then
-		append "$var" "max_num_sta=$max_num_sta" "$N"
-	fi
-	if [ "$max_inactivity" -gt 0 ]; then
-		append "$var" "ap_max_inactivity=$max_inactivity" "$N"
-	fi
-	append "$var" "disassoc_low_ack=$disassoc_low_ack" "$N"
-	if [ "$preamble" -gt 0 ]; then
-		append "$var" "preamble=$preamble" "$N"
-	fi
 
 	# Examples:
 	# psk-mixed/tkip 	=> WPA1+2 PSK, TKIP
@@ -98,9 +84,6 @@ hostapd_set_bss_options() {
 			config_get auth_secret "$vif" auth_secret
 			[ -z "$auth_secret" ] && config_get auth_secret "$vif" key
 			append "$var" "auth_server_shared_secret=$auth_secret" "$N"
-			config_get_bool auth_cache "$vif" auth_cache 0
-			[ "$auth_cache" -gt 0 ] || append "$var" "disable_pmksa_caching=1" "$N"
-			[ "$auth_cache" -gt 0 ] || append "$var" "okc=0" "$N"
 			config_get acct_server "$vif" acct_server
 			[ -n "$acct_server" ] && append "$var" "acct_server_addr=$acct_server" "$N"
 			config_get acct_port "$vif" acct_port
@@ -171,8 +154,9 @@ hostapd_set_bss_options() {
 
 	[ -n "$wps_possible" -a -n "$config_methods" ] && {
 		config_get device_type "$vif" wps_device_type "6-0050F204-1"
-		config_get device_name "$vif" wps_device_name "OpenWrt AP"
-		config_get manufacturer "$vif" wps_manufacturer "openwrt.org"
+		config_get device_name "$vif" wps_device_name "Belkin OpenWrt"
+		config_get manufacturer "$vif" wps_manufacturer "belkin.com"
+		config_get ap_pin "$vif" ap_pin "12345670"
 
 		append "$var" "eap_server=1" "$N"
 		append "$var" "wps_state=2" "$N"
@@ -181,6 +165,8 @@ hostapd_set_bss_options() {
 		append "$var" "device_name=$device_name" "$N"
 		append "$var" "manufacturer=$manufacturer" "$N"
 		append "$var" "config_methods=$config_methods" "$N"
+		append "$var" "wpa_key_mgmt=WPA-PSK" "$N"
+		append "$var" "ap_pin=$ap_pin" "$N"
 	}
 
 	append "$var" "ssid=$ssid" "$N"
@@ -191,7 +177,7 @@ hostapd_set_bss_options() {
 	if [ "$wpa" -ge "2" ]
 	then
 		# RSN -> allow preauthentication
-		config_get_bool rsn_preauth "$vif" rsn_preauth "$auth_cache"
+		config_get rsn_preauth "$vif" rsn_preauth
 		if [ -n "$bridge" -a "$rsn_preauth" = 1 ]
 		then
 			append "$var" "rsn_preauth=1" "$N"
@@ -214,27 +200,6 @@ hostapd_set_bss_options() {
 			;;
 		esac
 	fi
-
-	config_get macfilter "$vif" macfilter
-	macfile="/var/run/hostapd-$ifname.maclist"
-	[ -e "$macfile" ] && rm -f "$macfile"
-
-	case "$macfilter" in
-		allow)
-			append "$var" "macaddr_acl=1" "$N"
-			append "$var" "accept_mac_file=$macfile" "$N"
-			;;
-		deny)
-			append "$var" "macaddr_acl=0" "$N"
-			append "$var" "deny_mac_file=$macfile" "$N"
-			;;
-	esac
-	config_get maclist "$vif" maclist
-	[ -n "$maclist" ] && {
-		for mac in $maclist; do
-			echo "$mac" >> $macfile
-		done
-	}
 }
 
 hostapd_set_log_options() {
@@ -280,12 +245,16 @@ hostapd_setup_vif() {
 	config_get channel "$device" channel
 	config_get hwmode "$device" hwmode
 
+	echo ""
+	echo " ===== hostapd_setup_vif vif $vif, ifname $ifname, device $device, channel $channel, hwmode $hwmode"
+	echo ""
+
 	hostapd_set_log_options hostapd_cfg "$device"
 	hostapd_set_bss_options hostapd_cfg "$vif"
 
 	case "$hwmode" in
-		*bg|*gdt|*gst|*fh) hwmode=g;;
-		*adt|*ast) hwmode=a;;
+		*b|*g|*bg|*n|*gn|*bgn|*NG) hwmode=g;;
+		*a|*an|*NA|*ac) hwmode=a;;
 	esac
 	[ "$channel" = auto ] && channel=
 	[ -n "$channel" -a -z "$hwmode" ] && wifi_fixup_hwmode "$device"
diff --git a/package/hostapd/files/wps-hotplug.sh b/package/hostapd/files/wps-hotplug.sh
old mode 100644
new mode 100755
index ffd3cf9..c913d5b
--- a/package/hostapd/files/wps-hotplug.sh
+++ b/package/hostapd/files/wps-hotplug.sh
@@ -1,8 +1,6 @@
 #!/bin/sh
 
-if [ "$ACTION" = "pressed" -a "$BUTTON" = "wps" ]; then
-	for dir in /var/run/hostapd-*; do
-		[ -d "$dir" ] || continue
-		hostapd_cli -p "$dir" wps_pbc
-	done
-fi
+for dir in /var/run/hostapd-*; do
+	[ -d "$dir" ] || continue
+	hostapd_cli -p "$dir" wps_pbc
+done
diff --git a/package/hostapd/marvell/wlan/driver/linux/ap8xLnxIoctl.h b/package/hostapd/marvell/wlan/driver/linux/ap8xLnxIoctl.h
new file mode 100644
index 0000000..beca9e3
--- /dev/null
+++ b/package/hostapd/marvell/wlan/driver/linux/ap8xLnxIoctl.h
@@ -0,0 +1,229 @@
+/*
+*                Copyright 2005, Marvell Semiconductor, Inc.
+* This code contains confidential information of Marvell Semiconductor, Inc.
+* No rights are granted herein under any patent, mask work right or copyright
+* of Marvell or any third party.
+* Marvell reserves the right at its sole discretion to request that this code
+* be immediately returned to Marvell. This code is provided "as is".
+* Marvell makes no warranties, express, implied or otherwise, regarding its
+* accuracy, completeness or performance.
+*/
+#ifndef	AP8X_IOCTL_H_
+#define	AP8X_IOCTL_H_
+
+#include <linux/version.h>
+#include <linux/wireless.h>
+
+#define	WL_IOCTL_WL_PARAM			(SIOCIWFIRSTPRIV + 0)
+#define	WL_IOCTL_WL_GET_PARAM		(SIOCIWFIRSTPRIV + 1)
+#define	WL_IOCTL_BSS_START			(SIOCIWFIRSTPRIV + 2)
+#define	WL_IOCTL_GET_VERSION			(SIOCIWFIRSTPRIV + 3)
+#define	WL_IOCTL_SET_TXRATE			(SIOCIWFIRSTPRIV + 4)
+#define	WL_IOCTL_GET_TXRATE			(SIOCIWFIRSTPRIV + 5)
+#define	WL_IOCTL_SET_CIPHERSUITE		(SIOCIWFIRSTPRIV + 6)
+#define	WL_IOCTL_GET_CIPHERSUITE		(SIOCIWFIRSTPRIV + 7)
+#define	WL_IOCTL_SET_PASSPHRASE		(SIOCIWFIRSTPRIV + 8)
+#define	WL_IOCTL_GET_PASSPHRASE		(SIOCIWFIRSTPRIV + 9)
+#define	WL_IOCTL_SET_FILTERMAC		(SIOCIWFIRSTPRIV + 10)
+#define	WL_IOCTL_GET_FILTERMAC		(SIOCIWFIRSTPRIV + 11)
+#define	WL_IOCTL_SET_BSSID				(SIOCIWFIRSTPRIV + 12)
+#define	WL_IOCTL_GET_BSSID				(SIOCIWFIRSTPRIV + 13)
+#define	WL_IOCTL_SET_TXPOWER			(SIOCIWFIRSTPRIV + 14)
+#define	WL_IOCTL_GET_TXPOWER			(SIOCIWFIRSTPRIV + 15)
+#define	WL_IOCTL_SET_WMMEDCAAP		(SIOCIWFIRSTPRIV + 16)
+#define	WL_IOCTL_GET_WMMEDCAAP		(SIOCIWFIRSTPRIV + 17)
+#define	WL_IOCTL_SET_WMMEDCASTA		(SIOCIWFIRSTPRIV + 18)
+#define	WL_IOCTL_GET_WMMEDCASTA		(SIOCIWFIRSTPRIV + 19)
+#define WL_IOCTL_SETCMD					(SIOCIWFIRSTPRIV + 20)
+#define WL_IOCTL_GETCMD					(SIOCIWFIRSTPRIV + 25)
+#define	WL_IOCTL_GET_STALISTEXT		(SIOCIWFIRSTPRIV + 21)
+#define   WL_IOCTL_SET_APPIE			(SIOCIWFIRSTPRIV + 22)
+#ifdef GENERIC_GETIE
+#define   WL_IOCTL_GET_IE			(SIOCIWFIRSTPRIV + 23)
+#define   WL_IOCTL_GET_SCAN_BSSPROFILE			(SIOCIWFIRSTPRIV + 31)
+#else
+#define   WL_IOCTL_GET_RSNIE			(SIOCIWFIRSTPRIV + 23)
+#define   WL_IOCTL_GET_WSCIE			(SIOCIWFIRSTPRIV + 31)
+#endif
+#define   WL_IOCTL_SET_CLIENT			(SIOCIWFIRSTPRIV + 24)
+#define WL_IOCTL_SET_WDS_PORT       		(SIOCIWFIRSTPRIV + 26)
+#define WL_IOCTL_GET_WDS_PORT       (SIOCIWFIRSTPRIV + 27)
+#define   WL_IOCTL_GET_STASCAN			(SIOCIWFIRSTPRIV + 29)
+#define WL_IOCTL_SET_WAPI			(SIOCIWFIRSTPRIV + 30)
+
+
+enum
+{
+	WL_PARAM_AUTHTYPE = 1, 
+	WL_PARAM_BAND = 2,
+	WL_PARAM_REGIONCODE = 3,
+	WL_PARAM_HIDESSID = 4,
+	WL_PARAM_PREAMBLE = 5,
+	WL_PARAM_GPROTECT = 6,
+	WL_PARAM_BEACON = 7,
+	WL_PARAM_DTIM = 8,
+	WL_PARAM_FIXRATE = 9,
+	WL_PARAM_ANTENNA = 10,
+	WL_PARAM_WPAWPA2MODE = 11,
+	WL_PARAM_AUTHSUITE = 12,
+	WL_PARAM_GROUPREKEYTIME = 13,
+	WL_PARAM_WMM = 14,
+	WL_PARAM_WMMACKPOLICY = 15,
+	WL_PARAM_FILTER = 16,
+	WL_PARAM_INTRABSS = 17,
+	WL_PARAM_AMSDU = 18,
+	WL_PARAM_HTBANDWIDTH = 19,
+	WL_PARAM_GUARDINTERVAL = 20,
+	WL_PARAM_EXTSUBCH = 21,
+	WL_PARAM_HTPROTECT = 22,
+	WL_PARAM_GETFWSTAT=23,
+	WL_PARAM_AGINGTIME=24,
+	WL_PARAM_ANTENNATX2 = 25,
+	WL_PARAM_AUTOCHANNEL = 26,
+	WL_PARAM_AMPDUFACTOR = 27,
+	WL_PARAM_AMPDUDENSITY = 28,
+	WL_PARAM_CARDDEVINFO = 29,
+	WL_PARAM_INTEROP = 30,
+	WL_PARAM_OPTLEVEL = 31,
+	WL_PARAM_REGIONPWR = 32,
+	WL_PARAM_ADAPTMODE = 33,
+	WL_PARAM_SETKEYS = 34,
+	WL_PARAM_DELKEYS = 35,
+	WL_PARAM_MLME_REQ = 36,
+	WL_PARAM_COUNTERMEASURES = 37,
+	WL_PARAM_CSADAPTMODE = 38,
+	WL_PARAM_DELWEPKEY = 39,
+	WL_PARAM_WDSMODE = 40,
+	WL_PARAM_STRICTWEPSHARE = 41,
+	WL_PARAM_11H_CSA_CHAN = 42,
+	WL_PARAM_11H_CSA_COUNT = 43,
+	WL_PARAM_11H_CSA_MODE = 44,
+	WL_PARAM_11H_CSA_START = 45,
+	WL_PARAM_SPECTRUM_MGMT = 46,
+	WL_PARAM_POWER_CONSTRAINT = 47,
+	WL_PARAM_11H_DFS_MODE = 48,
+	WL_PARAM_11D_MODE = 49,
+	WL_PARAM_TXPWRFRACTION = 50,
+	WL_PARAM_DISABLEASSOC = 51,
+	WL_PARAM_PSHT_MANAGEMENTACT = 52,
+	/* CLIENT_SUPPORT*/
+	WL_PARAM_STAMODE = 53,
+	WL_PARAM_STASCAN = 54,
+	WL_PARAM_AMPDU_TX = 55,
+	WL_PARAM_11HCACTIMEOUT = 56,
+	WL_PARAM_11hNOPTIMEOUT = 57,
+	WL_PARAM_11hDFSMODE = 58,
+	WL_PARAM_MCASTPRXY = 59,
+	WL_PARAM_11H_STA_MODE = 60,
+	WL_PARAM_RSSI = 61,
+	WL_PARAM_INTOLERANT = 62,
+	WL_PARAM_TXQLIMIT = 63,
+	WL_PARAM_RXINTLIMIT = 64,
+	WL_PARAM_LINKSTATUS = 65,
+	WL_PARAM_ANTENNATX = 66,
+	WL_PARAM_RXPATHOPT = 67,
+	WL_PARAM_HTGF = 68,
+	WL_PARAM_HTSTBC = 69,
+	WL_PARAM_3X3RATE = 70,
+	WL_PARAM_AMSDU_FLUSHTIME = 71,
+	WL_PARAM_AMSDU_MAXSIZE = 72,
+	WL_PARAM_AMSDU_ALLOWSIZE = 73,
+	WL_PARAM_AMSDU_PKTCNT = 74,
+    WL_PARAM_CDD = 75,
+	WL_PARAM_WAPIMODE = 76,
+};
+
+#define WL_KEY_XMIT	        0x01	/* key used for xmit */
+#define WL_KEY_RECV	        0x02	/* key used for recv */
+#define WL_KEY_GROUP	    0x04	/* key used for WPA group operation */
+#define WL_KEY_DEFAULT	    0x80	/* default xmit key */
+#define WL_KEYIX_NONE       ((u_int16_t) - 1)
+
+#define WL_CIPHER_NONE      0x00
+#define WL_CIPHER_WEP40     0x01
+#define WL_CIPHER_TKIP      0x02
+#define WL_CIPHER_WRAP      0x03
+#define WL_CIPHER_CCMP      0x04
+#define WL_CIPHER_WEP104    0x05
+
+#ifdef GENERIC_GETIE
+struct wlreq_ie {
+	u_int8_t	macAddr[6];
+    u_int8_t    IEtype;
+    u_int8_t    IELen;
+	u_int8_t	IE[64];
+};
+#else
+struct wlreq_rsnie {
+	u_int8_t	macAddr[6];
+	u_int8_t	rsnIE[64];
+};
+#endif
+
+#ifdef MRVL_WSC
+struct wlreq_wscie {
+	u_int8_t	macAddr[6];
+	u_int8_t	wscIE[280];
+};
+#endif
+
+struct wlreq_key {
+	u_int8_t ik_type;		/* key/cipher type */
+	u_int8_t ik_pad;
+	u_int16_t ik_keyix;		/* key index */
+	u_int8_t ik_keylen;		/* key length in bytes */
+	u_int8_t ik_flags;
+	u_int8_t ik_macaddr[6];
+	u_int64_t ik_keyrsc;		/* key receive sequence counter */
+	u_int64_t ik_keytsc;		/* key transmit sequence counter */
+	u_int8_t ik_keydata[16+8+8];
+};
+
+struct wlreq_del_key {
+	u_int8_t idk_keyix;		/* key index */
+	u_int8_t idk_macaddr[6];
+};
+
+#define	WL_MLME_ASSOC		1	/* associate station */
+#define	WL_MLME_DISASSOC		2	/* disassociate station */
+#define	WL_MLME_DEAUTH		3	/* deauthenticate station */
+#define	WL_MLME_AUTHORIZE	4	/* authorize station */
+#define	WL_MLME_UNAUTHORIZE	5	/* unauthorize station */
+#define WL_MLME_CLEAR_STATS	6	/* clear station statistic */
+
+struct wlreq_mlme {
+	u_int8_t im_op;			/* operation to perform */
+	u_int8_t im_ssid_len;		/* length of optional ssid */
+	u_int16_t im_reason;		/* 802.11 reason code */
+	u_int8_t im_macaddr[6];
+	u_int8_t im_ssid[32];
+};
+
+#ifdef MRVL_WSC
+#define WL_APPIE_FRAMETYPE_BEACON           1
+#define WL_APPIE_FRAMETYPE_PROBE_RESP       2
+
+struct wlreq_set_appie {
+	u_int32_t    appFrmType;
+	u_int32_t   appBufLen;
+	u_int8_t    appBuf[504]; /*total size of 512 bytes */
+}__attribute__ ((packed));
+
+#endif //MRVL_WSC
+
+#ifdef MRVL_WAPI
+/* come from wapid, 1 and 2 is useed as beacon/probe-resp */
+#define P80211_PACKET_WAPIFLAG          0
+#define P80211_PACKET_SETKEY   			3
+
+#define KEY_LEN 			16  	
+/* from wapid */
+struct wlreq_wapi_key {
+	u_int8_t ik_macaddr[6];	       /* sta mac, all "ff" for mcastkey */
+	u_int8_t ik_flags;		       /* always = 1 */
+	u_int8_t ik_keyid;		       /* key index */
+	u_int8_t ik_keydata[KEY_LEN*2];/* mcastkey: 32 byte key; ucastkey: uek (16 byte) + uck (16 byte) */
+};
+#endif
+
+#endif /* AP8X_IOCTL_H_ */
diff --git a/package/hostapd/patches/001-hostapd_mrvl.patch b/package/hostapd/patches/001-hostapd_mrvl.patch
new file mode 100644
index 0000000..0d1d0a3
--- /dev/null
+++ b/package/hostapd/patches/001-hostapd_mrvl.patch
@@ -0,0 +1,2824 @@
+diff -Naur hostapd-0.8-snapshot/hostapd/.config hostapd-0.8.x-mrvl/hostapd/.config
+--- hostapd-0.8-snapshot/hostapd/.config	1970-01-01 07:00:00.000000000 +0700
++++ hostapd-0.8.x-mrvl/hostapd/.config	2012-05-11 15:58:02.000000000 +0700
+@@ -0,0 +1,186 @@
++# Example hostapd build time configuration
++#
++# This file lists the configuration options that are used when building the
++# hostapd binary. All lines starting with # are ignored. Configuration option
++# lines must be commented out complete, if they are not to be included, i.e.,
++# just setting VARIABLE=n is not disabling that variable.
++#
++# This file is included in Makefile, so variables like CFLAGS and LIBS can also
++# be modified from here. In most cass, these lines should use += in order not
++# to override previous values of the variables.
++
++# Driver interface for Host AP driver
++#CONFIG_DRIVER_HOSTAP=y
++
++# Driver interface for wired authenticator
++#CONFIG_DRIVER_WIRED=y
++
++# Driver interface for madwifi driver
++#CONFIG_DRIVER_MADWIFI=y
++#CFLAGS += -I../../madwifi # change to the madwifi source directory
++
++# Driver interface for drivers using the nl80211 kernel interface
++#CONFIG_DRIVER_NL80211=y
++# driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
++# shipped with your distribution yet. If that is the case, you need to build
++# newer libnl version and point the hostapd build to use it.
++#LIBNL=/usr/src/libnl
++#CFLAGS += -I$(LIBNL)/include
++#LIBS += -L$(LIBNL)/lib
++
++# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
++#CONFIG_DRIVER_BSD=y
++#CFLAGS += -I/usr/local/include
++#LIBS += -L/usr/local/lib
++#LIBS_p += -L/usr/local/lib
++#LIBS_c += -L/usr/local/lib
++
++# Driver interface for no driver (e.g., RADIUS server only)
++#CONFIG_DRIVER_NONE=y
++
++# Driver interface for marvell driver
++CONFIG_DRIVER_MARVELL=y
++CFLAGS += -DMRVL_WSC -DGENERIC_GETIE -DMRVL_WPS2
++# change to reflect local setup; directory for marvell src
++CFLAGS += -I../../../wlan-v5/
++LIBS += -ldl -L../../openssl-0.9.8a/
++CFLAGS += -I../../openssl-0.9.8a/include
++
++# IEEE 802.11F/IAPP
++#CONFIG_IAPP=y
++
++# WPA2/IEEE 802.11i RSN pre-authentication
++CONFIG_RSN_PREAUTH=y
++
++# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
++CONFIG_PEERKEY=y
++
++# IEEE 802.11w (management frame protection)
++# This version is an experimental implementation based on IEEE 802.11w/D1.0
++# draft and is subject to change since the standard has not yet been finalized.
++# Driver support is also needed for IEEE 802.11w.
++#CONFIG_IEEE80211W=y
++
++# Integrated EAP server
++CONFIG_EAP=y
++
++# EAP-MD5 for the integrated EAP server
++CONFIG_EAP_MD5=y
++
++# EAP-TLS for the integrated EAP server
++#CONFIG_EAP_TLS=y
++
++# EAP-MSCHAPv2 for the integrated EAP server
++#CONFIG_EAP_MSCHAPV2=y
++
++# EAP-PEAP for the integrated EAP server
++#CONFIG_EAP_PEAP=y
++
++# EAP-GTC for the integrated EAP server
++#CONFIG_EAP_GTC=y
++
++# EAP-TTLS for the integrated EAP server
++#CONFIG_EAP_TTLS=y
++
++# EAP-SIM for the integrated EAP server
++#CONFIG_EAP_SIM=y
++
++# EAP-AKA for the integrated EAP server
++#CONFIG_EAP_AKA=y
++
++# EAP-AKA' for the integrated EAP server
++# This requires CONFIG_EAP_AKA to be enabled, too.
++#CONFIG_EAP_AKA_PRIME=y
++
++# EAP-PAX for the integrated EAP server
++#CONFIG_EAP_PAX=y
++
++# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
++#CONFIG_EAP_PSK=y
++
++# EAP-SAKE for the integrated EAP server
++#CONFIG_EAP_SAKE=y
++
++# EAP-GPSK for the integrated EAP server
++#CONFIG_EAP_GPSK=y
++# Include support for optional SHA256 cipher suite in EAP-GPSK
++#CONFIG_EAP_GPSK_SHA256=y
++
++# EAP-FAST for the integrated EAP server
++# Note: Default OpenSSL package does not include support for all the
++# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
++# the OpenSSL library must be patched (openssl-0.9.9-session-ticket.patch)
++# to add the needed functions.
++#CONFIG_EAP_FAST=y
++
++# Wi-Fi Protected Setup (WPS)
++CONFIG_WPS=y
++# Enable WSC 2.0 support
++CONFIG_WPS2=y
++# Enable UPnP support for external WPS Registrars
++CONFIG_WPS_UPNP=y
++CONFIG_WPS_TESTING=y
++
++# EAP-IKEv2
++#CONFIG_EAP_IKEV2=y
++
++# Trusted Network Connect (EAP-TNC)
++#CONFIG_EAP_TNC=y
++
++# PKCS#12 (PFX) support (used to read private key and certificate file from
++# a file that usually has extension .p12 or .pfx)
++#CONFIG_PKCS12=y
++
++# RADIUS authentication server. This provides access to the integrated EAP
++# server from external hosts using RADIUS.
++#CONFIG_RADIUS_SERVER=y
++
++# Build IPv6 support for RADIUS operations
++CONFIG_IPV6=y
++
++# IEEE Std 802.11r-2008 (Fast BSS Transition)
++#CONFIG_IEEE80211R=y
++
++# Use the hostapd's IEEE 802.11 authentication (ACL), but without
++# the IEEE 802.11 Management capability (e.g., madwifi or FreeBSD/net80211)
++#CONFIG_DRIVER_RADIUS_ACL=y
++
++# IEEE 802.11n (High Throughput) support
++#CONFIG_IEEE80211N=y
++
++# Remove debugging code that is printing out debug messages to stdout.
++# This can be used to reduce the size of the hostapd considerably if debugging
++# code is not needed.
++#CONFIG_NO_STDOUT_DEBUG=y
++
++# Remove support for RADIUS accounting
++#CONFIG_NO_ACCOUNTING=y
++
++# Remove support for RADIUS
++#CONFIG_NO_RADIUS=y
++
++# Remove support for VLANs
++#CONFIG_NO_VLAN=y
++
++# Remove support for dumping state into a file on SIGUSR1 signal
++# This can be used to reduce binary size at the cost of disabling a debugging
++# option.
++#CONFIG_NO_DUMP_STATE=y
++
++# Enable tracing code for developer debugging
++# This tracks use of memory allocations and other registrations and reports
++# incorrect use with a backtrace of call (or allocation) location.
++#CONFIG_WPA_TRACE=y
++# For BSD, comment out these.
++#LIBS += -lexecinfo
++#LIBS_p += -lexecinfo
++#LIBS_c += -lexecinfo
++
++# Use libbfd to get more details for developer debugging
++# This enables use of libbfd to get more detailed symbols for the backtraces
++# generated by CONFIG_WPA_TRACE=y.
++#CONFIG_WPA_TRACE_BFD=y
++# For BSD, comment out these.
++#LIBS += -lbfd -liberty -lz
++#LIBS_p += -lbfd -liberty -lz
++#LIBS_c += -lbfd -liberty -lz
+diff -Naur hostapd-0.8-snapshot/hostapd/Makefile hostapd-0.8.x-mrvl/hostapd/Makefile
+--- hostapd-0.8-snapshot/hostapd/Makefile	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/hostapd/Makefile	2012-05-11 15:58:02.000000000 +0700
+@@ -1,3 +1,6 @@
++CROSS_COMPILE = /opt/SDK-2.1-LE/tools/gcc/bin/arm-none-linux-gnueabi-
++CC=$(CROSS_COMPILE)gcc
++
+ ifndef CC
+ CC=gcc
+ endif
+diff -Naur hostapd-0.8-snapshot/src/ap/drv_callbacks.c hostapd-0.8.x-mrvl/src/ap/drv_callbacks.c
+--- hostapd-0.8-snapshot/src/ap/drv_callbacks.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/ap/drv_callbacks.c	2012-05-11 15:58:02.000000000 +0700
+@@ -195,6 +195,19 @@
+ {
+ 	struct sta_info *sta;
+ 
++	if (addr == NULL) {
++		/*
++		 * This could potentially happen with unexpected event from the
++		 * driver wrapper. This was seen at least in one case where the
++		 * driver ended up reporting a station mode event while hostapd
++		 * was running, so better make sure we stop processing such an
++		 * event here.
++		 */
++		wpa_printf(MSG_DEBUG, "hostapd_notif_disassoc: Skip event "
++			   "with no address");
++		return;
++	}
++
+ 	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
+ 		       HOSTAPD_LEVEL_INFO, "disassociated");
+ 
+diff -Naur hostapd-0.8-snapshot/src/ap/hostapd.c hostapd-0.8.x-mrvl/src/ap/hostapd.c
+--- hostapd-0.8-snapshot/src/ap/hostapd.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/ap/hostapd.c	2012-05-11 15:58:02.000000000 +0700
+@@ -475,7 +475,7 @@
+ static int hostapd_setup_bss(struct hostapd_data *hapd, int first)
+ {
+ 	struct hostapd_bss_config *conf = hapd->conf;
+-	u8 ssid[HOSTAPD_MAX_SSID_LEN + 1];
++	u8 ssid[HOSTAPD_MAX_SSID_LEN + 2];
+ 	int ssid_len, set_ssid;
+ 	char force_ifname[IFNAMSIZ];
+ 	u8 if_addr[ETH_ALEN];
+@@ -619,6 +619,9 @@
+ 
+ 	ieee802_11_set_beacon(hapd);
+ 
++	if (hapd->driver && hapd->driver->set_operstate)
++		hapd->driver->set_operstate(hapd->drv_priv, 1);
++
+ 	return 0;
+ }
+ 
+diff -Naur hostapd-0.8-snapshot/src/ap/hostapd.h hostapd-0.8.x-mrvl/src/ap/hostapd.h
+--- hostapd-0.8-snapshot/src/ap/hostapd.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/ap/hostapd.h	2012-05-11 15:58:02.000000000 +0700
+@@ -168,6 +168,7 @@
+ 	struct wpabuf *wps_probe_resp_ie;
+ #ifdef CONFIG_WPS
+ 	unsigned int ap_pin_failures;
++	unsigned int ap_pin_failures_consecutive;
+ 	struct upnp_wps_device_sm *wps_upnp;
+ 	unsigned int ap_pin_lockout_time;
+ #endif /* CONFIG_WPS */
+diff -Naur hostapd-0.8-snapshot/src/ap/wps_hostapd.c hostapd-0.8.x-mrvl/src/ap/wps_hostapd.c
+--- hostapd-0.8-snapshot/src/ap/wps_hostapd.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/ap/wps_hostapd.c	2012-05-11 15:58:02.000000000 +0700
+@@ -475,6 +475,8 @@
+ 
+ 	if (hapd->conf->ap_setup_locked)
+ 		return;
++	if (hapd->ap_pin_failures_consecutive >= 10)
++		return;
+ 
+ 	wpa_printf(MSG_DEBUG, "WPS: Re-enable AP PIN");
+ 	wpa_msg(hapd->msg_ctx, MSG_INFO, WPS_EVENT_AP_SETUP_UNLOCKED);
+@@ -496,8 +498,10 @@
+ 	 * force attacks.
+ 	 */
+ 	hapd->ap_pin_failures++;
+-	wpa_printf(MSG_DEBUG, "WPS: AP PIN authentication failure number %u",
+-		   hapd->ap_pin_failures);
++	hapd->ap_pin_failures_consecutive++;
++	wpa_printf(MSG_DEBUG, "WPS: AP PIN authentication failure number %u "
++		   "(%u consecutive)",
++		   hapd->ap_pin_failures, hapd->ap_pin_failures_consecutive);
+ 	if (hapd->ap_pin_failures < 3)
+ 		return 0;
+ 
+@@ -506,7 +510,15 @@
+ 
+ 	wps_registrar_update_ie(hapd->wps->registrar);
+ 
+-	if (!hapd->conf->ap_setup_locked) {
++	if (!hapd->conf->ap_setup_locked &&
++	    hapd->ap_pin_failures_consecutive >= 10) {
++		/*
++		 * In indefinite lockdown - disable automatic AP PIN
++		 * reenablement.
++		 */
++		eloop_cancel_timeout(hostapd_wps_reenable_ap_pin, hapd, NULL);
++		wpa_printf(MSG_DEBUG, "WPS: AP PIN disabled indefinitely");
++	} else if (!hapd->conf->ap_setup_locked) {
+ 		if (hapd->ap_pin_lockout_time == 0)
+ 			hapd->ap_pin_lockout_time = 60;
+ 		else if (hapd->ap_pin_lockout_time < 365 * 24 * 60 * 60 &&
+@@ -532,12 +544,49 @@
+ }
+ 
+ 
++static int wps_ap_pin_success(struct hostapd_data *hapd, void *ctx)
++{
++	if (hapd->conf->ap_pin == NULL || hapd->wps == NULL)
++		return 0;
++
++	if (hapd->ap_pin_failures_consecutive == 0)
++		return 0;
++
++	wpa_printf(MSG_DEBUG, "WPS: Clear consecutive AP PIN failure counter "
++		   "- total validation failures %u (%u consecutive)",
++		   hapd->ap_pin_failures, hapd->ap_pin_failures_consecutive);
++	hapd->ap_pin_failures_consecutive = 0;
++
++	return 0;
++}
++
++
++static void hostapd_wps_ap_pin_success(struct hostapd_data *hapd)
++{
++	hostapd_wps_for_each(hapd, wps_ap_pin_success, NULL);
++}
++
++
++static const char * wps_event_fail_reason[NUM_WPS_EI_VALUES] = {
++	"No Error", /* WPS_EI_NO_ERROR */
++	"TKIP Only Prohibited", /* WPS_EI_SECURITY_TKIP_ONLY_PROHIBITED */
++	"WEP Prohibited" /* WPS_EI_SECURITY_WEP_PROHIBITED */
++};
++
+ static void hostapd_wps_event_fail(struct hostapd_data *hapd,
+ 				   struct wps_event_fail *fail)
+ {
+-	wpa_msg(hapd->msg_ctx, MSG_INFO,
+-		WPS_EVENT_FAIL "msg=%d config_error=%d",
+-		fail->msg, fail->config_error);
++	if (fail->error_indication > 0 &&
++	    fail->error_indication < NUM_WPS_EI_VALUES) {
++		wpa_msg(hapd->msg_ctx, MSG_INFO,
++			WPS_EVENT_FAIL "msg=%d config_error=%d reason=%d (%s)",
++			fail->msg, fail->config_error, fail->error_indication,
++			wps_event_fail_reason[fail->error_indication]);
++	} else {
++		wpa_msg(hapd->msg_ctx, MSG_INFO,
++			WPS_EVENT_FAIL "msg=%d config_error=%d",
++			fail->msg, fail->config_error);
++	}
+ }
+ 
+ 
+@@ -548,18 +597,22 @@
+ 
+ 	switch (event) {
+ 	case WPS_EV_M2D:
++		wpa_msg(hapd->msg_ctx, MSG_INFO, WPS_EVENT_M2D);
+ 		break;
+ 	case WPS_EV_FAIL:
+ 		hostapd_wps_event_fail(hapd, &data->fail);
+ 		break;
+ 	case WPS_EV_SUCCESS:
++		wpa_msg(hapd->msg_ctx, MSG_INFO, WPS_EVENT_SUCCESS);
+ 		break;
+ 	case WPS_EV_PWD_AUTH_FAIL:
+ 		hostapd_pwd_auth_fail(hapd, &data->pwd_auth_fail);
+ 		break;
+ 	case WPS_EV_PBC_OVERLAP:
++		wpa_msg(hapd->msg_ctx, MSG_INFO, WPS_EVENT_OVERLAP);
+ 		break;
+ 	case WPS_EV_PBC_TIMEOUT:
++		wpa_msg(hapd->msg_ctx, MSG_INFO, WPS_EVENT_TIMEOUT);
+ 		break;
+ 	case WPS_EV_ER_AP_ADD:
+ 		break;
+@@ -571,6 +624,11 @@
+ 		break;
+ 	case WPS_EV_ER_AP_SETTINGS:
+ 		break;
++	case WPS_EV_ER_SET_SELECTED_REGISTRAR:
++		break;
++	case WPS_EV_AP_PIN_SUCCESS:
++		hostapd_wps_ap_pin_success(hapd);
++		break;
+ 	}
+ 	if (hapd->wps_event_cb)
+ 		hapd->wps_event_cb(hapd->wps_event_cb_ctx, event, data);
+@@ -1095,6 +1153,7 @@
+ 	 */
+ 
+ 	sta = ap_get_sta(hapd, mac_addr);
++
+ #ifndef CONFIG_WPS_STRICT
+ 	if (!sta) {
+ 		/*
+@@ -1125,6 +1184,11 @@
+ 	p->next = hapd->wps->upnp_msgs;
+ 	hapd->wps->upnp_msgs = p;
+ 
++	if (sta->eapol_sm == NULL) {
++		/* if sta-eapol_sm is NULL, using sta->eapol_sm->eap will cause hostapd "Segmentation fault" */
++		return -1;
++	}
++
+ 	return eapol_auth_eap_pending_cb(sta->eapol_sm, sta->eapol_sm->eap);
+ }
+ 
+@@ -1144,18 +1208,12 @@
+ 	if (hapd->conf->ap_pin)
+ 		ctx->ap_pin = os_strdup(hapd->conf->ap_pin);
+ 
+-	hapd->wps_upnp = upnp_wps_device_init(ctx, wps, hapd);
+-	if (hapd->wps_upnp == NULL) {
+-		os_free(ctx);
++	hapd->wps_upnp = upnp_wps_device_init(ctx, wps, hapd,
++					      hapd->conf->upnp_iface);
++	if (hapd->wps_upnp == NULL)
+ 		return -1;
+-	}
+-	wps->wps_upnp = hapd->wps_upnp;
+ 
+-	if (upnp_wps_device_start(hapd->wps_upnp, hapd->conf->upnp_iface)) {
+-		upnp_wps_device_deinit(hapd->wps_upnp);
+-		hapd->wps_upnp = NULL;
+-		return -1;
+-	}
++	wps->wps_upnp = hapd->wps_upnp;
+ 
+ 	return 0;
+ }
+@@ -1163,7 +1221,7 @@
+ 
+ static void hostapd_wps_upnp_deinit(struct hostapd_data *hapd)
+ {
+-	upnp_wps_device_deinit(hapd->wps_upnp);
++	upnp_wps_device_deinit(hapd->wps_upnp, hapd);
+ }
+ 
+ #endif /* CONFIG_WPS_UPNP */
+@@ -1190,6 +1248,7 @@
+ {
+ 	wpa_printf(MSG_DEBUG, "WPS: Enabling AP PIN (timeout=%d)", timeout);
+ 	hapd->ap_pin_failures = 0;
++	hapd->ap_pin_failures_consecutive = 0;
+ 	hapd->conf->ap_setup_locked = 0;
+ 	if (hapd->wps->ap_setup_locked) {
+ 		wpa_msg(hapd->msg_ctx, MSG_INFO, WPS_EVENT_AP_SETUP_UNLOCKED);
+diff -Naur hostapd-0.8-snapshot/src/common/wpa_ctrl.h hostapd-0.8.x-mrvl/src/common/wpa_ctrl.h
+--- hostapd-0.8-snapshot/src/common/wpa_ctrl.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/common/wpa_ctrl.h	2012-05-11 15:58:02.000000000 +0700
+@@ -89,6 +89,7 @@
+ #define WPS_EVENT_ER_ENROLLEE_ADD "WPS-ER-ENROLLEE-ADD "
+ #define WPS_EVENT_ER_ENROLLEE_REMOVE "WPS-ER-ENROLLEE-REMOVE "
+ #define WPS_EVENT_ER_AP_SETTINGS "WPS-ER-AP-SETTINGS "
++#define WPS_EVENT_ER_SET_SEL_REG "WPS-ER-AP-SET-SEL-REG "
+ 
+ /** P2P device found */
+ #define P2P_EVENT_DEVICE_FOUND "P2P-DEVICE-FOUND "
+diff -Naur hostapd-0.8-snapshot/src/drivers/driver.h hostapd-0.8.x-mrvl/src/drivers/driver.h
+--- hostapd-0.8-snapshot/src/drivers/driver.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/drivers/driver.h	2012-05-11 15:58:02.000000000 +0700
+@@ -2212,7 +2212,21 @@
+ 	 * e.g., because of a regulatory domain change triggered by scan
+ 	 * results including an AP advertising a country code.
+ 	 */
+-	EVENT_CHANNEL_LIST_CHANGED
++	EVENT_CHANNEL_LIST_CHANGED,
++
++	/**
++	 * EVENT_INTERFACE_UNAVAILABLE - Notify that interface is unavailable
++	 *
++	 * This event is used to indicate that the driver cannot maintain this
++	 * interface in its operation mode anymore. The most likely use for
++	 * this is to indicate that AP mode operation is not available due to
++	 * operating channel would need to be changed to a DFS channel when
++	 * the driver does not support radar detection and another virtual
++	 * interfaces caused the operating channel to change. Other similar
++	 * resource conflicts could also trigger this for station mode
++	 * interfaces.
++	 */
++	EVENT_INTERFACE_UNAVAILABLE
+ };
+ 
+ 
+diff -Naur hostapd-0.8-snapshot/src/drivers/driver_marvell.c hostapd-0.8.x-mrvl/src/drivers/driver_marvell.c
+--- hostapd-0.8-snapshot/src/drivers/driver_marvell.c	1970-01-01 07:00:00.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/drivers/driver_marvell.c	2012-05-11 15:58:02.000000000 +0700
+@@ -0,0 +1,1082 @@
++/*
++ * Host AP - driver interface with MARVELL driver
++ * Copyright (c) 2004, Sam Leffler <sam@errno.com>
++ * Copyright (c) 2010-2011, Marvell Semiconductor- added support for Marvell driver glue logics.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * Alternatively, this software may be distributed under the terms of BSD
++ * license.
++ *
++ * See README and COPYING for more details.
++ */
++#include "includes.h"
++#include <sys/ioctl.h>
++
++#include <netpacket/packet.h>
++
++#include "common.h"
++#include "driver.h"
++#include "driver_wext.h"
++#include "eloop.h"
++#include "priv_netlink.h"
++#include "l2_packet/l2_packet.h"
++#include "common/ieee802_11_defs.h"
++#include "netlink.h"
++#include "linux_ioctl.h"
++#include "wireless_copy.h"
++
++#include "ap/hostapd.h"
++#include "ap/ap_config.h"
++
++#include <driver/linux/ap8xLnxIoctl.h>
++
++#define	IEEE80211_ADDR_LEN	6
++
++struct marvell_driver_data {
++	struct hostapd_data *hapd;		/* back pointer */
++	char	iface[IFNAMSIZ + 1];
++	int     ifindex;
++	struct l2_packet_data *sock_xmit;	/* raw packet xmit socket */
++	struct l2_packet_data *sock_recv;	/* raw packet recv socket */
++	int	ioctl_sock;			/* socket for ioctl() use */
++	struct netlink_data *netlink;
++	int	we_version;
++	u8	acct_mac[ETH_ALEN];
++	struct hostap_sta_driver_data acct_data;
++	struct l2_packet_data *sock_raw; /* raw 802.11 management frames */
++};
++
++static int marvell_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr, int reason_code);
++
++static int
++set80211priv(struct marvell_driver_data *drv, int op, void *data, int len)
++{
++	struct iwreq iwr;
++
++	memset(&iwr, 0, sizeof(iwr));
++	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
++	if (len < IFNAMSIZ) {
++		/*
++		 * Argument data fits inline; put it there.
++		 */
++		memcpy(iwr.u.name, data, len);
++	} else {
++		/*
++		 * Argument data too big for inline transfer; setup a
++		 * parameter block instead; the kernel will transfer
++		 * the data for the driver.
++		 */
++		iwr.u.data.pointer = data;
++		iwr.u.data.length = len;
++	}
++
++	if (ioctl(drv->ioctl_sock, op, &iwr) < 0) {
++		return -1;
++	}
++
++	return 0;
++}
++
++static int
++get80211priv(struct marvell_driver_data *drv, int op, void *data, int len)
++{
++	struct iwreq iwr;
++
++	memset(&iwr, 0, sizeof(iwr));
++	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
++	if (len < IFNAMSIZ) {
++		/*
++		 * Argument data fits inline; put it there.
++		 */
++		memcpy(iwr.u.name, data, len);
++	} else {
++		/*
++		 * Argument data too big for inline transfer; setup a
++		 * parameter block instead; the kernel will transfer
++		 * the data for the driver.
++		 */
++		iwr.u.data.pointer = data;
++		iwr.u.data.length = len;
++	}
++
++	if (ioctl(drv->ioctl_sock, op, &iwr) < 0) {
++		return -1;
++	}
++
++	if (len < IFNAMSIZ)
++		memcpy(data, iwr.u.name, len);
++	return iwr.u.data.length;
++}
++
++static int
++set80211param(struct marvell_driver_data *drv, int op, int arg, Boolean commit)
++{
++	struct iwreq iwr;
++
++	memset(&iwr, 0, sizeof(iwr));
++	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
++	iwr.u.mode = op;
++	memcpy(iwr.u.name+sizeof(__u32), &arg, sizeof(arg));
++
++	if (ioctl(drv->ioctl_sock, WL_IOCTL_WL_PARAM, &iwr) < 0) {
++		perror("ioctl[WL_IOCTL_WL_PARAM]");
++		return -1;
++	}
++
++    if (commit) {
++    	memset(&iwr, 0, sizeof(iwr));
++    	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
++        if (ioctl(drv->ioctl_sock, SIOCSIWCOMMIT, &iwr) < 0) {
++    		printf("ioctl[SIOCSIWCOMMIT]");
++    		return -1;
++    	}
++    }
++	return 0;
++}
++
++static const char *
++ether_sprintf(const u8 *addr)
++{
++	static char buf[sizeof(MACSTR)];
++
++	if (addr != NULL)
++		snprintf(buf, sizeof(buf), MACSTR, MAC2STR(addr));
++	else
++		snprintf(buf, sizeof(buf), MACSTR, 0,0,0,0,0,0);
++	return buf;
++}
++
++
++/*
++ * Configure WPA parameters.
++ */
++static int
++marvell_configure_wpa(struct marvell_driver_data *drv, struct wpa_bss_params *params)
++{
++	u8 wpawpa2mode;
++	char ciphersuite[16];
++
++	/* In WPS mode, set the WPAWPA2MODE to 0x13 (extended mixed mode)
++	* with the exception of WPA2PSK-TKIP. For WPA2PSK-TKIP set the
++	* the WPAWPA2MODE as 0x12 (extended WPA2PSK mode).
++	*/
++	if (drv->hapd->conf->wps_state)
++	{
++		// Set wpawpa2mode if WPA2PSK-TKIP
++    	if ((params->wpa & WPA_PROTO_RSN) &&
++        	!(params->wpa & WPA_PROTO_WPA) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_PSK) &&
++       		((params->wpa_pairwise & WPA_CIPHER_CCMP) ||
++       		(params->wpa_pairwise & WPA_CIPHER_TKIP)))
++		{
++    		wpawpa2mode = 0x12;
++		}
++		// Set wpawpa2mode if WPAPSK-TKIP
++		else if (!(params->wpa & WPA_PROTO_RSN) &&
++        	(params->wpa & WPA_PROTO_WPA) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_PSK) &&
++       		((params->wpa_pairwise & WPA_CIPHER_CCMP) ||
++       		(params->wpa_pairwise & WPA_CIPHER_TKIP)))
++		{
++    		wpawpa2mode = 0x11;
++		}
++		else
++		{
++    		wpawpa2mode = 0x13; // WSC custom mixed mode
++		}
++
++		if (set80211param(drv, WL_PARAM_WPAWPA2MODE, wpawpa2mode,TRUE)) {
++            wpa_printf(MSG_DEBUG,"%s: WPS Extended mode %x setting failed", __func__,wpawpa2mode);
++			return -1;
++		}
++
++		// Set ciphersuite if WPA2PSK-TKIP
++    	if ((params->wpa & WPA_PROTO_RSN) &&
++        	!(params->wpa & WPA_PROTO_WPA) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_PSK) &&
++       		!(params->wpa_pairwise & WPA_CIPHER_CCMP) &&
++       		(params->wpa_pairwise & WPA_CIPHER_TKIP))
++		{
++        	strcpy(ciphersuite, "wpa2 tkip");
++    	
++			/* Set ciphersuite and commit */
++			if (set80211priv(drv, WL_IOCTL_SET_CIPHERSUITE, 
++					&ciphersuite, sizeof(ciphersuite))) 
++			{
++                wpa_printf(MSG_DEBUG,"%s: Cipher Suite %s setting failed", __func__,ciphersuite);
++				return -1;
++			}
++		}
++		// Set ciphersuite if WPAPSK-AES
++    	else if (!(params->wpa & WPA_PROTO_RSN) &&
++        	(params->wpa & WPA_PROTO_WPA) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_PSK) &&
++       		(params->wpa_pairwise & WPA_CIPHER_CCMP) &&
++       		!(params->wpa_pairwise & WPA_CIPHER_TKIP))
++		{
++        	strcpy(ciphersuite, "wpa aes-ccmp");
++    	
++			/* Set ciphersuite and commit */
++			if (set80211priv(drv, WL_IOCTL_SET_CIPHERSUITE, 
++					&ciphersuite, sizeof(ciphersuite))) 
++			{
++                wpa_printf(MSG_DEBUG,"%s: WPS Cipher Suite %s setting failed", __func__,ciphersuite);
++				return -1;
++			}
++		}
++	}
++	else
++	{
++    	if ((params->wpa & WPA_PROTO_WPA) &&
++        	!(params->wpa & WPA_PROTO_RSN) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_PSK))
++        	wpawpa2mode = 0x81;
++    	else if ((params->wpa & WPA_PROTO_RSN) &&
++        	!(params->wpa & WPA_PROTO_WPA) &&
++        	((params->wpa_key_mgmt & WPA_KEY_MGMT_PSK) ||
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_FT_PSK)))
++        	wpawpa2mode = 0x82;
++    	else if ((params->wpa & WPA_PROTO_RSN) &&
++        	(params->wpa & WPA_PROTO_WPA) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_PSK))
++        	wpawpa2mode = 0x83;
++    	else if ((params->wpa & WPA_PROTO_WPA) &&
++        	!(params->wpa & WPA_PROTO_RSN) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X))      
++        	wpawpa2mode = 0x84;
++    	else if ((params->wpa & WPA_PROTO_RSN) &&
++        	!(params->wpa & WPA_PROTO_WPA) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X))
++        	wpawpa2mode = 0x85;
++    	else if ((params->wpa & WPA_PROTO_RSN) &&
++        	(params->wpa & WPA_PROTO_WPA) &&
++        	(params->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X))
++        	wpawpa2mode = 0x86;
++    	else
++        	wpawpa2mode = 0;
++        
++		if (set80211param(drv, WL_PARAM_WPAWPA2MODE, wpawpa2mode,TRUE))
++        {
++            wpa_printf(MSG_DEBUG,"%s: Mode %x setting failed", __func__,wpawpa2mode);
++			return -1;
++		}
++	}
++
++   	if ((params->wpa & WPA_PROTO_WPA) &&
++       	(params->wpa_pairwise & WPA_CIPHER_TKIP))
++       	strcpy(ciphersuite, "wpa tkip");        
++   	else if ((params->wpa & WPA_PROTO_RSN) &&
++       	(params->wpa_pairwise & WPA_CIPHER_CCMP))
++       	strcpy(ciphersuite, "wpa2 aes-ccmp");
++   	else if ((params->wpa & WPA_PROTO_RSN) &&
++       	(params->wpa_pairwise & WPA_CIPHER_TKIP))
++       	strcpy(ciphersuite, "wpa2 tkip");        
++   	else if ((params->wpa & WPA_PROTO_WPA) &&
++       	(params->wpa_pairwise & WPA_CIPHER_CCMP))
++       	strcpy(ciphersuite, "wpa aes-ccmp");
++    	
++	if (set80211priv(drv, WL_IOCTL_SET_CIPHERSUITE, &ciphersuite, sizeof(ciphersuite))) {
++        wpa_printf(MSG_DEBUG,"%s: Cipher Suite %s setting failed", __func__,ciphersuite);
++		return -1;
++	}
++
++    wpa_printf(MSG_DEBUG,"%s:configured mode=%x cipher suite=%s", __func__,wpawpa2mode,ciphersuite);
++    
++	return 0;
++}
++
++static int
++marvell_set_ieee8021x(void *priv, struct wpa_bss_params *params)
++{
++	struct marvell_driver_data *drv = priv;
++    
++	wpa_printf(MSG_DEBUG,"%s: enabled=%d", __func__, params->enabled);
++
++	if (!params->enabled) {
++		if (drv->hapd->conf->wps_state)
++			return set80211param(priv, WL_PARAM_WPAWPA2MODE, 0x10, TRUE);
++		else
++			return set80211param(priv, WL_PARAM_WPAWPA2MODE, 0, TRUE);
++	}
++
++    if (!params->wpa && !params->ieee802_1x) {
++		hostapd_logger(drv->hapd, NULL, HOSTAPD_MODULE_DRIVER,
++			HOSTAPD_LEVEL_WARNING, "No 802.1X or WPA enabled!");
++		return -1;
++	}
++
++    if (params->wpa && marvell_configure_wpa(drv, params) != 0) {
++		hostapd_logger(drv->hapd, NULL, HOSTAPD_MODULE_DRIVER,
++			HOSTAPD_LEVEL_WARNING, "Error configuring WPA state!");
++		return -1;
++	}
++
++    if (drv->hapd->conf->wps_state && !params->wpa)
++	{
++		/* WPS Extended Open mode setting - WPAWPA2MODE - 0x10 */
++   		if( set80211param(drv, WL_PARAM_WPAWPA2MODE, 0x10,TRUE) )
++		{
++            wpa_printf(MSG_DEBUG,"%s: WPS Extended Open mode setting failed\n", __func__);
++    		return -1;
++		}
++	}
++
++    return 0;
++}
++
++
++static int
++marvell_del_key(void *priv, const u8 *addr, int key_idx)
++{
++	struct marvell_driver_data *drv = priv;
++	struct wlreq_del_key wk;
++	int ret;
++
++	wpa_printf(MSG_DEBUG,"%s: addr=%s key_idx=%d",
++		__func__, ether_sprintf(addr), key_idx);
++
++	memset(&wk, 0, sizeof(wk));
++	if (addr != NULL) {
++		memcpy(wk.idk_macaddr, addr, IEEE80211_ADDR_LEN);
++		wk.idk_keyix = (u8) WL_KEYIX_NONE;
++	} else {
++		wk.idk_keyix = key_idx;
++	}
++	ret = set80211param(drv, WL_PARAM_DELKEYS, (int)&wk,FALSE);
++	if (ret < 0) {
++		wpa_printf(MSG_DEBUG, "%s: Failed to delete key (addr %s"
++			   " key_idx %d)", __func__, ether_sprintf(addr),
++			   key_idx);
++	}
++
++	return ret;
++}
++
++static int
++marvell_set_key(const char *ifname,void *priv, enum wpa_alg alg,
++	     const u8 *addr, int key_idx, int set_tx, const u8 *seq,
++	     size_t seq_len, const u8 *key, size_t key_len)
++{
++	struct marvell_driver_data *drv = priv;
++	struct wlreq_key wk;
++	u_int8_t cipher;
++	int ret;
++
++	if (alg == WPA_ALG_NONE)
++		return marvell_del_key(priv, addr, key_idx);
++
++	wpa_printf(MSG_DEBUG,
++		"%s: alg=%d addr=%s key_idx=%d\n",
++		__func__, alg, ether_sprintf(addr), key_idx);
++
++	switch (alg) {
++	case WPA_ALG_WEP:
++		cipher = WL_CIPHER_WEP104;
++		break;
++	case WPA_ALG_TKIP:
++		cipher = WL_CIPHER_TKIP;
++		break;
++	case WPA_ALG_CCMP:
++		cipher = WL_CIPHER_CCMP;
++		break;
++	default:
++		printf("%s: unknown/unsupported algorithm %d\n",
++			__func__, alg);
++		return -1;
++	}
++
++	if (key_len > sizeof(wk.ik_keydata)) {
++		printf("%s: key length %lu too big\n", __func__,
++		       (unsigned long) key_len);
++		return -3;
++	}
++
++	memset(&wk, 0, sizeof(wk));
++	wk.ik_type = cipher;
++	wk.ik_flags = WL_KEY_RECV | WL_KEY_XMIT;
++	if (addr == NULL) {
++		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
++		wk.ik_keyix = key_idx;
++		wk.ik_flags |= WL_KEY_DEFAULT;
++	} else {
++		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
++		wk.ik_keyix = WL_KEYIX_NONE;
++	}
++	wk.ik_keylen = key_len;
++	memcpy(wk.ik_keydata, key, key_len);
++    
++	ret = set80211param(drv, WL_PARAM_SETKEYS, (int)&wk,FALSE);
++	if (ret < 0) {
++		wpa_printf(MSG_DEBUG, "%s: Failed to set key (addr %s"
++			   " key_idx %d alg '%d' key_len %lu txkey %d)",
++			   __func__, ether_sprintf(wk.ik_macaddr), key_idx,
++			   alg, (unsigned long) key_len, set_tx);
++	}
++
++	return ret;
++}
++
++static int 
++marvell_flush(void *priv)
++{
++	u8 allsta[IEEE80211_ADDR_LEN];
++	memset(allsta, 0xff, IEEE80211_ADDR_LEN);
++	return marvell_sta_deauth(priv, NULL, allsta, 3); /*IEEEtypes_REASON_DEAUTH_LEAVING*/
++}
++
++
++static int
++marvell_read_sta_driver_data(void *priv, struct hostap_sta_driver_data *data,
++				const u8 *addr)
++{
++	return 0;
++}
++
++
++static int
++marvell_set_opt_ie(void *priv, const u8 *ie, size_t ie_len)
++{
++	/*
++	 * Do nothing; we setup parameters at startup that define the
++	 * contents of the beacon information element.
++	 */
++	return 0;
++}
++
++static int
++marvell_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr, int reason_code)
++{
++	struct marvell_driver_data *drv = priv;
++	struct wlreq_mlme mlme;
++
++	wpa_printf(MSG_DEBUG,
++		"%s: addr=%s reason_code=%d\n",
++		__func__, ether_sprintf(addr), reason_code);
++
++	mlme.im_op = WL_MLME_DEAUTH;
++	mlme.im_reason = reason_code;
++	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
++
++    return set80211param(drv, WL_PARAM_MLME_REQ, (int)&mlme,FALSE);
++}
++
++static void marvell_raw_receive(void *ctx, const u8 *src_addr, const u8 *buf,
++				size_t len)
++{
++	struct marvell_driver_data *drv = ctx;
++	const struct ieee80211_mgmt *mgmt;
++	u16 fc;
++	union wpa_event_data event;
++
++	/* Send Probe Request information to WPS processing */
++	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.probe_req))
++		return;
++	mgmt = (const struct ieee80211_mgmt *) buf;
++
++	fc = le_to_host16(mgmt->frame_control);
++	if (WLAN_FC_GET_TYPE(fc) != WLAN_FC_TYPE_MGMT ||
++	    WLAN_FC_GET_STYPE(fc) != WLAN_FC_STYPE_PROBE_REQ)
++		return;
++
++	os_memset(&event, 0, sizeof(event));
++	event.rx_probe_req.sa = mgmt->sa;
++	event.rx_probe_req.ie = mgmt->u.probe_req.variable;
++	event.rx_probe_req.ie_len =
++		len - (IEEE80211_HDRLEN + sizeof(mgmt->u.probe_req));
++	wpa_supplicant_event(drv->hapd, EVENT_RX_PROBE_REQ, &event);
++}
++
++static int
++marvell_set_wsc_ie(void *priv, const u8 *iebuf, int iebuflen, u32 frametype)
++{
++	u8 buf[512];
++	struct wlreq_set_appie * app_ie;
++
++	wpa_printf(MSG_DEBUG, "%s buflen = %d", __func__, iebuflen);
++
++	app_ie = (struct wlreq_set_appie *)buf;
++	app_ie->appFrmType = frametype;
++	app_ie->appBufLen = iebuflen;
++
++    if (iebuf != NULL)
++    	memcpy(&(app_ie->appBuf[0]), iebuf , iebuflen );
++    else
++    {
++        memset(&(app_ie->appBuf[0]),0x00, 8);
++        app_ie->appBufLen = 8;
++    }
++
++	return set80211priv(priv, WL_IOCTL_SET_APPIE, app_ie,
++			8 + app_ie->appBufLen);
++
++}
++
++static int
++marvell_set_ap_wps_ie(void *priv, const struct wpabuf *beacon,
++		      const struct wpabuf *proberesp,const struct wpabuf *assocresp)
++{
++	if (marvell_set_wsc_ie(priv, beacon ? wpabuf_head(beacon) : NULL,
++			       beacon ? wpabuf_len(beacon) : 0,
++			       WL_APPIE_FRAMETYPE_BEACON))
++		return -1;
++    
++	return marvell_set_wsc_ie(priv,
++				  proberesp ? wpabuf_head(proberesp) : NULL,
++				  proberesp ? wpabuf_len(proberesp): 0,
++				  WL_APPIE_FRAMETYPE_PROBE_RESP);
++}
++
++
++static int
++marvell_new_sta(struct marvell_driver_data *drv, u8 addr[IEEE80211_ADDR_LEN])
++{
++	struct wlreq_ie ie;
++	struct hostapd_data *hapd = drv->hapd;
++
++	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
++		HOSTAPD_LEVEL_INFO, "associated");
++
++    /* Get RSN IE */
++	memset(&ie, 0, sizeof(ie));
++	memcpy(ie.macAddr, addr, 6);
++    ie.IEtype = WLAN_EID_RSN;
++
++	if (get80211priv(drv, WL_IOCTL_GET_IE, &ie, sizeof(ie))<0) {
++       	wpa_printf(MSG_DEBUG,"%s: IOCTL Get IE failed\n", __func__);
++		return -1;		
++	}
++
++	if (ie.IELen == 0) {
++     	wpa_printf(MSG_DEBUG,"%s: STA addr %s RSN IE Length is zero\n", __func__, ether_sprintf(addr));
++	}
++
++	drv_event_assoc(hapd, addr, ie.IE, ie.IELen);
++
++	if (memcmp(addr, drv->acct_mac, ETH_ALEN) == 0) {
++		/* Cached accounting data is not valid anymore. */
++		memset(drv->acct_mac, 0, ETH_ALEN);
++		memset(&drv->acct_data, 0, sizeof(drv->acct_data));
++	}
++
++	return 0;
++}
++
++static void
++marvell_wireless_event_wireless_custom(struct marvell_driver_data *drv,
++				       char *custom)
++{
++//	wpa_printf(MSG_DEBUG, "Custom wireless event: '%s'", custom);
++
++	if (strncmp(custom, "MLME-MICHAELMICFAILURE.indication", 33) == 0) {
++		char *pos;
++		u8 addr[ETH_ALEN];
++		pos = strstr(custom, "addr=");
++		if (pos == NULL) {
++			wpa_printf(MSG_DEBUG,
++				      "MLME-MICHAELMICFAILURE.indication "
++				      "without sender address ignored");
++			return;
++		}
++		pos += 5;
++		if (hwaddr_aton(pos, addr) == 0) {
++			union wpa_event_data data;
++			os_memset(&data, 0, sizeof(data));
++			data.michael_mic_failure.unicast = 1;
++			data.michael_mic_failure.src = NULL;
++			wpa_supplicant_event(drv->hapd,
++					     EVENT_MICHAEL_MIC_FAILURE, &data);
++		} else {
++			wpa_printf(MSG_DEBUG,
++				      "MLME-MICHAELMICFAILURE.indication "
++				      "with invalid MAC address");
++		}
++	}
++    else if (strncmp(custom, "STA-TRAFFIC-STAT", 16) == 0)
++    {
++		char *key, *value;
++		u32 val;
++		key = custom;
++		while ((key = strchr(key, '\n')) != NULL) {
++			key++;
++			value = strchr(key, '=');
++			if (value == NULL)
++				continue;
++			*value++ = '\0';
++			val = strtoul(value, NULL, 10);
++			if (strcmp(key, "mac") == 0)
++				hwaddr_aton(value, drv->acct_mac);
++			else if (strcmp(key, "rx_packets") == 0)
++				drv->acct_data.rx_packets = val;
++			else if (strcmp(key, "tx_packets") == 0)
++				drv->acct_data.tx_packets = val;
++			else if (strcmp(key, "rx_bytes") == 0)
++				drv->acct_data.rx_bytes = val;
++			else if (strcmp(key, "tx_bytes") == 0)
++				drv->acct_data.tx_bytes = val;
++			key = value;
++		}
++	}
++#ifdef MRVL_WPS2
++    else if (strncmp(custom, "mlme-probe_request", strlen("mlme-probe_request")) == 0)
++#else
++    else if (strncmp(custom, "mlme-probe_request", 18) == 0)
++#endif
++    {
++#define MLME_FRAME_TAG_SIZE  20 
++#ifdef MRVL_WPS2
++		s16 len = WPA_GET_LE16(custom + strlen("mlme-probe_request"));
++#else
++		s16 len = *(custom + 18);
++#endif
++		if (len < 0) {
++			wpa_printf(MSG_DEBUG, "mlme-probe_request "
++				   "length %d", len);
++			return;
++		}
++        
++		marvell_raw_receive(drv, NULL, (u8 *) custom + MLME_FRAME_TAG_SIZE, len);
++	}
++    else if (strstr(custom, "Unexpected event - External recovery recommended: ") != NULL)
++    {
++        printf("received recovery event rebooting\n");
++        system("reboot");
++    }
++}
++
++static void
++marvell_wireless_event_wireless(struct marvell_driver_data *drv,
++					    char *data, int len)
++{
++	struct iw_event iwe_buf, *iwe = &iwe_buf;
++	char *pos, *end, *custom, *buf;
++
++	pos = data;
++	end = data + len;
++
++	while (pos + IW_EV_LCP_LEN <= end) {
++		/* Event data may be unaligned, so make a local, aligned copy
++		 * before processing. */
++		memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
++//		wpa_printf(MSG_MSGDUMP, "Wireless event: cmd=0x%x len=%d", iwe->cmd, iwe->len);
++		if (iwe->len <= IW_EV_LCP_LEN)
++			return;
++
++		custom = pos + IW_EV_POINT_LEN;
++		if (drv->we_version > 18 &&
++		    (iwe->cmd == IWEVMICHAELMICFAILURE ||
++		     iwe->cmd == IWEVASSOCREQIE ||
++		     iwe->cmd == IWEVCUSTOM)) {
++			/* WE-19 removed the pointer from struct iw_point */
++			char *dpos = (char *) &iwe_buf.u.data.length;
++			int dlen = dpos - (char *) &iwe_buf;
++			memcpy(dpos, pos + IW_EV_LCP_LEN,
++			       sizeof(struct iw_event) - dlen);
++		} else {
++			memcpy(&iwe_buf, pos, sizeof(struct iw_event));
++			custom += IW_EV_POINT_OFF;
++		}
++
++		switch (iwe->cmd) {
++		case IWEVEXPIRED:
++			drv_event_disassoc(drv->hapd,
++					   (u8 *) iwe->u.addr.sa_data);
++			break;
++		case IWEVREGISTERED:
++			/* First reset the station state so that if the station did not
++			* send explicit deauth, it will still be ok.
++			*/
++			drv_event_disassoc(drv->hapd, (u8 *) iwe->u.addr.sa_data);
++			marvell_new_sta(drv, (u8 *) iwe->u.addr.sa_data);
++			break;
++		case IWEVCUSTOM:
++			if (custom + iwe->u.data.length > end)
++				return;
++			buf = malloc(iwe->u.data.length + 1);
++			if (buf == NULL)
++				return;		/* XXX */
++			memcpy(buf, custom, iwe->u.data.length);
++			buf[iwe->u.data.length] = '\0';
++			marvell_wireless_event_wireless_custom(drv, buf);
++			free(buf);
++			break;
++		}
++
++		pos += iwe->len;
++	}
++}
++static void
++marvell_wireless_event_rtm_newlink(void *ctx,
++				   struct ifinfomsg *ifi, u8 *buf, size_t len)
++{
++	struct marvell_driver_data *drv = ctx;
++	int attrlen, rta_len;
++	struct rtattr *attr;
++
++	if (ifi->ifi_index != drv->ifindex)
++		return;
++
++	attrlen = len;
++	attr = (struct rtattr *) buf;
++
++	rta_len = RTA_ALIGN(sizeof(struct rtattr));
++	while (RTA_OK(attr, attrlen)) {
++		if (attr->rta_type == IFLA_WIRELESS) {
++			marvell_wireless_event_wireless(
++				drv, ((char *) attr) + rta_len,
++				attr->rta_len - rta_len);
++		}
++		attr = RTA_NEXT(attr, attrlen);
++	}
++}
++
++static int
++marvell_get_we_version(struct marvell_driver_data *drv)
++{
++	struct iw_range *range;
++	struct iwreq iwr;
++	int minlen;
++	size_t buflen;
++
++	drv->we_version = 0;
++
++	/*
++	 * Use larger buffer than struct iw_range in order to allow the
++	 * structure to grow in the future.
++	 */
++	buflen = sizeof(struct iw_range) + 500;
++	range = os_zalloc(buflen);
++	if (range == NULL)
++		return -1;
++
++	memset(&iwr, 0, sizeof(iwr));
++	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
++	iwr.u.data.pointer = (caddr_t) range;
++	iwr.u.data.length = buflen;
++
++	minlen = ((char *) &range->enc_capa) - (char *) range +
++		sizeof(range->enc_capa);
++
++	if (ioctl(drv->ioctl_sock, SIOCGIWRANGE, &iwr) < 0) {
++		perror("ioctl[SIOCGIWRANGE]");
++		free(range);
++		return -1;
++	} else if (iwr.u.data.length >= minlen &&
++		   range->we_version_compiled >= 18) {
++		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: WE(compiled)=%d "
++			   "WE(source)=%d enc_capa=0x%x",
++			   range->we_version_compiled,
++			   range->we_version_source,
++			   range->enc_capa);
++		drv->we_version = range->we_version_compiled;
++	}
++
++	free(range);
++	return 0;
++}
++
++
++static int
++marvell_wireless_event_init(struct marvell_driver_data *drv)
++{
++	struct netlink_config *cfg;
++
++	marvell_get_we_version(drv);
++
++	cfg = os_zalloc(sizeof(*cfg));
++	if (cfg == NULL)
++		return -1;
++	cfg->ctx = drv;
++	cfg->newlink_cb = marvell_wireless_event_rtm_newlink;
++	drv->netlink = netlink_init(cfg);
++	if (drv->netlink == NULL) {
++		os_free(cfg);
++		return -1;
++	}
++
++	return 0;
++}
++
++static int
++marvell_send_ether(void *priv, const u8 *dst, const u8 *src, u16 proto, const u8 *data, size_t data_len)
++{
++	struct marvell_driver_data *drv = priv;
++	unsigned char buf[3000];
++	unsigned char *bp = buf;
++	struct l2_ethhdr *eth;
++	size_t len;
++	int status;
++
++	/*
++	 * Prepend the Ethernet header.  If the caller left us
++	 * space at the front we could just insert it but since
++	 * we don't know we copy to a local buffer.  Given the frequency
++	 * and size of frames this probably doesn't matter.
++	 */
++	len = data_len + sizeof(struct l2_ethhdr);
++	if (len > sizeof(buf)) {
++		bp = malloc(len);
++		if (bp == NULL) {
++			printf("EAPOL frame discarded, cannot malloc temp "
++			       "buffer of size %lu!\n", (unsigned long) len);
++			return -1;
++		}
++	}
++	eth = (struct l2_ethhdr *) bp;
++	memcpy(eth->h_dest, dst, ETH_ALEN);
++	memcpy(eth->h_source, src, ETH_ALEN);
++	eth->h_proto = htons(proto);
++	memcpy(eth+1, data, data_len);
++
++	wpa_hexdump(MSG_MSGDUMP, "TX Ether", bp, len);
++
++	status = l2_packet_send(drv->sock_xmit, dst, proto, bp, len);
++
++	if (bp != buf)
++		free(bp);
++	return status;
++}
++
++static int
++marvell_send_eapol(void *priv, const u8 *addr, const u8 *data, size_t data_len,
++           int encrypt, const u8 *own_addr)
++{
++	struct marvell_driver_data *drv = priv;
++	unsigned char buf[3000];
++	unsigned char *bp = buf;
++	struct l2_ethhdr *eth;
++	size_t len;
++	int status;
++
++	/*
++	 * Prepend the Ethernet header.  If the caller left us
++	 * space at the front we could just insert it but since
++	 * we don't know we copy to a local buffer.  Given the frequency
++	 * and size of frames this probably doesn't matter.
++	 */
++	len = data_len + sizeof(struct l2_ethhdr);
++	if (len > sizeof(buf)) {
++		bp = malloc(len);
++		if (bp == NULL) {
++			printf("EAPOL frame discarded, cannot malloc temp "
++			       "buffer of size %lu!\n", (unsigned long) len);
++			return -1;
++		}
++	}
++	eth = (struct l2_ethhdr *) bp;
++	memcpy(eth->h_dest, addr, ETH_ALEN);
++	memcpy(eth->h_source, own_addr, ETH_ALEN);
++	eth->h_proto = host_to_be16(ETH_P_EAPOL);
++	memcpy(eth+1, data, data_len);
++
++	wpa_hexdump(MSG_MSGDUMP, "TX EAPOL", bp, len);
++
++	status = l2_packet_send(drv->sock_xmit, addr, ETH_P_EAPOL, bp, len);
++
++	if (bp != buf)
++		free(bp);
++	return status;
++}
++
++static void
++handle_read(void *ctx, const u8 *src_addr, const u8 *buf, size_t len)
++{
++	struct marvell_driver_data *drv = ctx;
++	drv_event_eapol_rx(drv->hapd, src_addr, buf + sizeof(struct l2_ethhdr),
++			   len - sizeof(struct l2_ethhdr));
++}
++
++
++static void *
++marvell_init(struct hostapd_data *hapd, struct wpa_init_params *params)
++{
++	struct marvell_driver_data *drv;
++	struct ifreq ifr;
++	char brname[IFNAMSIZ];
++
++	drv = os_zalloc(sizeof(struct marvell_driver_data));
++	if (drv == NULL) {
++		printf("Could not allocate memory for marvell driver data\n");
++		return NULL;
++	}
++
++	drv->hapd = hapd;
++	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
++	if (drv->ioctl_sock < 0) {
++		perror("socket[PF_INET,SOCK_DGRAM]");
++		goto bad;
++	}
++	memcpy(drv->iface, params->ifname, sizeof(drv->iface));
++
++	memset(&ifr, 0, sizeof(ifr));
++	os_strlcpy(ifr.ifr_name, drv->iface, sizeof(ifr.ifr_name));
++	if (ioctl(drv->ioctl_sock, SIOCGIFINDEX, &ifr) != 0) {
++		perror("ioctl(SIOCGIFINDEX)");
++		goto bad;
++	}
++	drv->ifindex = ifr.ifr_ifindex;
++
++	drv->sock_xmit = l2_packet_init(drv->iface, NULL, ETH_P_EAPOL,
++					handle_read, drv, 1);
++	if (drv->sock_xmit == NULL)
++		goto bad;
++
++	if (l2_packet_get_own_addr(drv->sock_xmit, params->own_addr))
++		goto bad;
++
++	if (params->bridge[0]) {
++		wpa_printf(MSG_DEBUG, "Configure bridge %s for EAPOL traffic.",
++			   params->bridge[0]);
++		drv->sock_recv = l2_packet_init(params->bridge[0], NULL,
++						ETH_P_EAPOL, handle_read, drv,
++						1);
++		if (drv->sock_recv == NULL)
++			goto bad;
++	} else if (linux_br_get(brname, drv->iface) == 0) {
++		wpa_printf(MSG_DEBUG, "Interface in bridge %s; configure for "
++			   "EAPOL receive", brname);
++		drv->sock_recv = l2_packet_init(brname, NULL, ETH_P_EAPOL,
++						handle_read, drv, 1);
++		if (drv->sock_recv == NULL)
++			goto bad;
++        } else
++		    drv->sock_recv = drv->sock_xmit;
++
++	if (marvell_wireless_event_init(drv))
++		goto bad;
++            
++	/* for wps with open security and ieee8021x=0 mode */
++	if (drv->hapd->conf->wps_state && !drv->hapd->conf->wpa)
++	{
++   		if ( set80211param(drv, WL_PARAM_WPAWPA2MODE, 0x10, TRUE) )
++		{
++			wpa_printf(MSG_DEBUG,"%s: WPS Extended Open mode setting failed\n", __func__);
++			return NULL;
++		}
++	}
++
++	return drv;
++bad:
++	if (drv->sock_xmit != NULL)
++		l2_packet_deinit(drv->sock_xmit);
++	if (drv->ioctl_sock >= 0)
++		close(drv->ioctl_sock);
++	if (drv != NULL)
++		free(drv);
++	return NULL;
++}
++
++
++static void
++marvell_deinit(void* priv)
++{
++	struct marvell_driver_data *drv = priv;
++
++	netlink_deinit(drv->netlink);
++	(void) linux_set_iface_flags(drv->ioctl_sock, drv->iface, 0);
++	if (drv->ioctl_sock >= 0)
++		close(drv->ioctl_sock);
++	if (drv->sock_recv != NULL && drv->sock_recv != drv->sock_xmit)
++		l2_packet_deinit(drv->sock_recv);
++	if (drv->sock_xmit != NULL)
++		l2_packet_deinit(drv->sock_xmit);
++	if (drv->sock_raw)
++		l2_packet_deinit(drv->sock_raw);
++	free(drv);
++
++}
++
++static int
++marvell_set_ssid(void *priv, const u8 *buf, int len)
++{
++	struct marvell_driver_data *drv = priv;
++	struct iwreq iwr;
++
++	memset(&iwr, 0, sizeof(iwr));
++	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
++	iwr.u.essid.flags = 1; /* SSID active */
++	iwr.u.essid.pointer = (caddr_t) buf;
++	iwr.u.essid.length = len + 1;
++
++	if (ioctl(drv->ioctl_sock, SIOCSIWESSID, &iwr) < 0) {
++		perror("ioctl[SIOCSIWESSID]");
++		printf("len=%d\n", len);
++		return -1;
++	}
++	if (drv->hapd->conf->wps_state )
++	{
++    	if (ioctl(drv->ioctl_sock, SIOCSIWCOMMIT, &iwr) < 0) {
++        	printf("ioctl[SIOCSIWCOMMIT]");
++        	return -1;
++    	}
++	}
++	return 0;
++}
++
++static int
++marvell_get_ssid(void *priv, u8 *buf, int len)
++{
++	struct marvell_driver_data *drv = priv;
++	struct iwreq iwr;
++	int ret = 0;
++
++	memset(&iwr, 0, sizeof(iwr));
++	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
++	iwr.u.essid.pointer = (caddr_t) buf;
++	iwr.u.essid.length = len;
++
++	if (ioctl(drv->ioctl_sock, SIOCGIWESSID, &iwr) < 0) {
++		perror("ioctl[SIOCGIWESSID]");
++		ret = -1;
++	} else
++		ret = iwr.u.essid.length;// -1; /*remove the '\0' */
++
++	return ret;
++}
++
++static int
++marvell_set_countermeasures(void *priv, int enabled)
++{
++	struct marvell_driver_data *drv = priv;
++	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __FUNCTION__, enabled);
++
++	return set80211param(drv, WL_PARAM_COUNTERMEASURES, enabled,FALSE);
++}
++
++static int
++marvell_commit (void *priv)
++{
++	struct marvell_driver_data *drv = priv;
++	struct iwreq iwr;
++
++	memset(&iwr, 0, sizeof(iwr));
++	strncpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
++
++    if (ioctl(drv->ioctl_sock, SIOCSIWCOMMIT, &iwr) < 0) {
++		printf("ioctl[SIOCSIWCOMMIT]");
++		return -1;
++	}
++
++	return 0;
++}
++
++const struct wpa_driver_ops wpa_driver_marvell_ops = {
++	.name			        = "marvell",
++	.hapd_init			    = marvell_init,
++	.deinit			        = marvell_deinit,
++	.set_ieee8021x		    = marvell_set_ieee8021x,
++	.set_key		        = marvell_set_key,
++	.flush			        = marvell_flush,
++	.set_generic_elem	    = marvell_set_opt_ie,
++	.read_sta_data		    = marvell_read_sta_driver_data,
++	.hapd_send_eapol	    = marvell_send_eapol,
++	.sta_deauth		        = marvell_sta_deauth,
++	.hapd_set_ssid		    = marvell_set_ssid,
++	.hapd_get_ssid		    = marvell_get_ssid,
++	.set_countermeasures    = marvell_set_countermeasures,
++    .send_ether             = marvell_send_ether,
++	.set_ap_wps_ie		    = marvell_set_ap_wps_ie,
++	.commit                 = marvell_commit,
++};
+diff -Naur hostapd-0.8-snapshot/src/drivers/drivers.c hostapd-0.8.x-mrvl/src/drivers/drivers.c
+--- hostapd-0.8-snapshot/src/drivers/drivers.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/drivers/drivers.c	2012-05-11 15:58:02.000000000 +0700
+@@ -74,7 +74,9 @@
+ #ifdef CONFIG_DRIVER_NONE
+ extern struct wpa_driver_ops wpa_driver_none_ops; /* driver_none.c */
+ #endif /* CONFIG_DRIVER_NONE */
+-
++#ifdef CONFIG_DRIVER_MARVELL
++extern struct wpa_driver_ops wpa_driver_marvell_ops; /* driver_marvell.c */
++#endif /* CONFIG_DRIVER_MARVELL */
+ 
+ struct wpa_driver_ops *wpa_drivers[] =
+ {
+@@ -135,5 +137,8 @@
+ #ifdef CONFIG_DRIVER_NONE
+ 	&wpa_driver_none_ops,
+ #endif /* CONFIG_DRIVER_NONE */
++#ifdef CONFIG_DRIVER_MARVELL
++	&wpa_driver_marvell_ops,
++#endif /* CONFIG_DRIVER_NONE */
+ 	NULL
+ };
+diff -Naur hostapd-0.8-snapshot/src/drivers/drivers.mak hostapd-0.8.x-mrvl/src/drivers/drivers.mak
+--- hostapd-0.8-snapshot/src/drivers/drivers.mak	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/drivers/drivers.mak	2012-05-11 15:58:02.000000000 +0700
+@@ -71,6 +71,15 @@
+ NEED_LINUX_IOCTL=y
+ endif
+ 
++ifdef CONFIG_DRIVER_MARVELL
++DRV_AP_CFLAGS += -DCONFIG_DRIVER_MARVELL
++DRV_AP_OBJS += ../src/drivers/driver_marvell.o
++CONFIG_L2_PACKET=linux
++NEED_NETLINK=y
++NEED_LINUX_IOCTL=y
++endif
++
++
+ ##### PURE CLIENT DRIVERS
+ 
+ ifdef CONFIG_DRIVER_WEXT
+diff -Naur hostapd-0.8-snapshot/src/p2p/p2p_group.c hostapd-0.8.x-mrvl/src/p2p/p2p_group.c
+--- hostapd-0.8-snapshot/src/p2p/p2p_group.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/p2p/p2p_group.c	2012-05-11 15:58:02.000000000 +0700
+@@ -72,6 +72,7 @@
+ 	group->group_formation = 1;
+ 	group->beacon_update = 1;
+ 	p2p_group_update_ies(group);
++	group->cfg->idle_update(group->cfg->cb_ctx, 1);
+ 
+ 	return group;
+ }
+@@ -338,6 +339,8 @@
+ 	if (group->num_members == group->cfg->max_clients)
+ 		group->beacon_update = 1;
+ 	p2p_group_update_ies(group);
++	if (group->num_members == 1)
++		group->cfg->idle_update(group->cfg->cb_ctx, 0);
+ 
+ 	return 0;
+ }
+@@ -396,6 +399,8 @@
+ 		if (group->num_members == group->cfg->max_clients - 1)
+ 			group->beacon_update = 1;
+ 		p2p_group_update_ies(group);
++		if (group->num_members == 0)
++			group->cfg->idle_update(group->cfg->cb_ctx, 1);
+ 	}
+ }
+ 
+diff -Naur hostapd-0.8-snapshot/src/p2p/p2p.h hostapd-0.8.x-mrvl/src/p2p/p2p.h
+--- hostapd-0.8-snapshot/src/p2p/p2p.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/p2p/p2p.h	2012-05-11 15:58:02.000000000 +0700
+@@ -1049,6 +1049,13 @@
+ 	 */
+ 	void (*ie_update)(void *ctx, struct wpabuf *beacon_ies,
+ 			  struct wpabuf *proberesp_ies);
++
++	/**
++	 * idle_update - Notification of changes in group idle state
++	 * @ctx: Callback context from cb_ctx
++	 * @idle: Whether the group is idle (no associated stations)
++	 */
++	void (*idle_update)(void *ctx, int idle);
+ };
+ 
+ /**
+diff -Naur hostapd-0.8-snapshot/src/p2p/p2p_parse.c hostapd-0.8.x-mrvl/src/p2p/p2p_parse.c
+--- hostapd-0.8-snapshot/src/p2p/p2p_parse.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/p2p/p2p_parse.c	2012-05-11 15:58:02.000000000 +0700
+@@ -166,7 +166,8 @@
+ 		for (i = 0; i < nlen; i++) {
+ 			if (msg->device_name[i] == '\0')
+ 				break;
+-			if (msg->device_name[i] < 32)
++			if (msg->device_name[i] > 0 &&
++			    msg->device_name[i] < 32)
+ 				msg->device_name[i] = '_';
+ 		}
+ 		wpa_printf(MSG_DEBUG, "P2P: * Device Info: addr " MACSTR
+@@ -563,7 +564,7 @@
+ 		name[cli->dev_name_len] = '\0';
+ 		count = (int) cli->dev_name_len - 1;
+ 		while (count >= 0) {
+-			if (name[count] < 32)
++			if (name[count] > 0 && name[count] < 32)
+ 				name[count] = '_';
+ 			count--;
+ 		}
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_attr_build.c hostapd-0.8.x-mrvl/src/wps/wps_attr_build.c
+--- hostapd-0.8-snapshot/src/wps/wps_attr_build.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_attr_build.c	2012-05-11 15:58:02.000000000 +0700
+@@ -254,20 +254,28 @@
+ 
+ int wps_build_auth_type_flags(struct wps_data *wps, struct wpabuf *msg)
+ {
++	u16 auth_types = WPS_AUTH_TYPES;
++#ifdef CONFIG_WPS2
++	auth_types &= ~WPS_AUTH_SHARED;
++#endif /* CONFIG_WPS2 */
+ 	wpa_printf(MSG_DEBUG, "WPS:  * Authentication Type Flags");
+ 	wpabuf_put_be16(msg, ATTR_AUTH_TYPE_FLAGS);
+ 	wpabuf_put_be16(msg, 2);
+-	wpabuf_put_be16(msg, WPS_AUTH_TYPES);
++	wpabuf_put_be16(msg, auth_types);
+ 	return 0;
+ }
+ 
+ 
+ int wps_build_encr_type_flags(struct wps_data *wps, struct wpabuf *msg)
+ {
++	u16 encr_types = WPS_ENCR_TYPES;
++#ifdef CONFIG_WPS2
++	encr_types &= ~WPS_ENCR_WEP;
++#endif /* CONFIG_WPS2 */
+ 	wpa_printf(MSG_DEBUG, "WPS:  * Encryption Type Flags");
+ 	wpabuf_put_be16(msg, ATTR_ENCR_TYPE_FLAGS);
+ 	wpabuf_put_be16(msg, 2);
+-	wpabuf_put_be16(msg, WPS_ENCR_TYPES);
++	wpabuf_put_be16(msg, encr_types);
+ 	return 0;
+ }
+ 
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_defs.h hostapd-0.8.x-mrvl/src/wps/wps_defs.h
+--- hostapd-0.8-snapshot/src/wps/wps_defs.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_defs.h	2012-05-11 15:58:02.000000000 +0700
+@@ -224,6 +224,14 @@
+ 	WPS_CFG_DEV_PASSWORD_AUTH_FAILURE = 18
+ };
+ 
++/* Vendor specific Error Indication for WPS event messages */
++enum wps_error_indication {
++	WPS_EI_NO_ERROR,
++	WPS_EI_SECURITY_TKIP_ONLY_PROHIBITED,
++	WPS_EI_SECURITY_WEP_PROHIBITED,
++	NUM_WPS_EI_VALUES
++};
++
+ /* RF Bands */
+ #define WPS_RF_24GHZ 0x01
+ #define WPS_RF_50GHZ 0x02
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_enrollee.c hostapd-0.8.x-mrvl/src/wps/wps_enrollee.c
+--- hostapd-0.8-snapshot/src/wps/wps_enrollee.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_enrollee.c	2012-05-11 15:58:02.000000000 +0700
+@@ -225,7 +225,7 @@
+ 
+ static int wps_build_cred_ssid(struct wps_data *wps, struct wpabuf *msg)
+ {
+-	wpa_printf(MSG_DEBUG, "WPS:  * SSID");
++	wpa_printf(MSG_DEBUG, "WPS:  * SSID (##<%s>)", wps->wps->ssid);
+ 	wpabuf_put_be16(msg, ATTR_SSID);
+ 	wpabuf_put_be16(msg, wps->wps->ssid_len);
+ 	wpabuf_put_data(msg, wps->wps->ssid, wps->wps->ssid_len);
+@@ -235,20 +235,40 @@
+ 
+ static int wps_build_cred_auth_type(struct wps_data *wps, struct wpabuf *msg)
+ {
+-	wpa_printf(MSG_DEBUG, "WPS:  * Authentication Type");
++	wpa_printf(MSG_DEBUG, "WPS:  * Authentication Type (##<0x%x>)", wps->wps->auth_types);
+ 	wpabuf_put_be16(msg, ATTR_AUTH_TYPE);
+ 	wpabuf_put_be16(msg, 2);
++#if 1 // For backwards compatibility (version 1.0) Win7 Certification
++	if (wps->wps->auth_types == (WPS_AUTH_WPA2PSK | WPS_AUTH_WPAPSK)) // 0x22
++	{
++		wpabuf_put_be16(msg, WPS_AUTH_WPA2PSK);
++		wpa_printf(MSG_DEBUG, "WPS:  * Authentication Type (<0x%x> - actual)", WPS_AUTH_WPA2PSK);
++	}
++	else
++		wpabuf_put_be16(msg, wps->wps->auth_types);
++#else
+ 	wpabuf_put_be16(msg, wps->wps->auth_types);
++#endif
+ 	return 0;
+ }
+ 
+ 
+ static int wps_build_cred_encr_type(struct wps_data *wps, struct wpabuf *msg)
+ {
+-	wpa_printf(MSG_DEBUG, "WPS:  * Encryption Type");
++	wpa_printf(MSG_DEBUG, "WPS:  * Encryption Type (##<0x%x>)", wps->wps->encr_types);
+ 	wpabuf_put_be16(msg, ATTR_ENCR_TYPE);
+ 	wpabuf_put_be16(msg, 2);
++#if 1 //For backwards compatibility (version 1.0) Win7 Certification
++	if (wps->wps->encr_types == (WPS_ENCR_AES | WPS_ENCR_TKIP)) // 0x0c
++	{
++		wpabuf_put_be16(msg, WPS_ENCR_AES);
++		wpa_printf(MSG_DEBUG, "WPS:  * Encryption Type (<0x%x> - actual)", WPS_ENCR_AES);
++	}
++	else
++	wpabuf_put_be16(msg, wps->wps->encr_types);
++#else
+ 	wpabuf_put_be16(msg, wps->wps->encr_types);
++#endif
+ 	return 0;
+ }
+ 
+@@ -813,6 +833,17 @@
+ 	}
+ #endif /* CONFIG_WPS2 */
+ 
++#ifdef MRVL_WPS2
++        if ((cred.encr_type & (WPS_ENCR_TKIP | WPS_ENCR_AES)) ==
++            WPS_ENCR_TKIP ||
++            (cred.auth_type & (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK)) ==
++            WPS_AUTH_WPAPSK) {
++                wpa_printf(MSG_INFO, "WPS-STRICT: Invalid WSC 2.0 "
++                           "AP Settings: WPA-Personal/TKIP only");
++                return -1;
++        }
++
++#else
+ #ifdef CONFIG_WPS_STRICT
+ 	if (wps2) {
+ 		if ((cred.encr_type & (WPS_ENCR_TKIP | WPS_ENCR_AES)) ==
+@@ -825,6 +856,7 @@
+ 		}
+ 	}
+ #endif /* CONFIG_WPS_STRICT */
++#endif /* WSC2_PF3_WAR */
+ 
+ #ifdef CONFIG_WPS2
+ 	if ((cred.encr_type & (WPS_ENCR_TKIP | WPS_ENCR_AES)) == WPS_ENCR_TKIP)
+@@ -1051,6 +1083,10 @@
+ 	}
+ 	wpabuf_free(decrypted);
+ 
++	if (wps->wps->ap)
++		wps->wps->event_cb(wps->wps->cb_ctx, WPS_EV_AP_PIN_SUCCESS,
++				   NULL);
++
+ 	wps->state = SEND_M7;
+ 	return WPS_CONTINUE;
+ }
+@@ -1132,7 +1168,8 @@
+ 
+ 	if (attr.msg_type == NULL) {
+ 		wpa_printf(MSG_DEBUG, "WPS: No Message Type attribute");
+-		return WPS_FAILURE;
++		wps->state = SEND_WSC_NACK;
++		return WPS_CONTINUE;
+ 	}
+ 
+ 	switch (*attr.msg_type) {
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_er.c hostapd-0.8.x-mrvl/src/wps/wps_er.c
+--- hostapd-0.8-snapshot/src/wps/wps_er.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_er.c	2012-05-11 15:58:02.000000000 +0700
+@@ -62,11 +62,15 @@
+ }
+ 
+ 
+-static struct wps_er_sta * wps_er_sta_get(struct wps_er_ap *ap, const u8 *addr)
++static struct wps_er_sta * wps_er_sta_get(struct wps_er_ap *ap, const u8 *addr,
++					  const u8 *uuid)
+ {
+ 	struct wps_er_sta *sta;
+ 	dl_list_for_each(sta, &ap->sta, struct wps_er_sta, list) {
+-		if (os_memcmp(sta->addr, addr, ETH_ALEN) == 0)
++		if ((addr == NULL ||
++		     os_memcmp(sta->addr, addr, ETH_ALEN) == 0) &&
++		    (uuid == NULL ||
++		     os_memcmp(uuid, sta->uuid, WPS_UUID_LEN) == 0))
+ 			return sta;
+ 	}
+ 	return NULL;
+@@ -275,6 +279,64 @@
+ 	wps_er_ap_unsubscribed(ap->er, ap);
+ }
+ 
++
++static struct wps_er_ap_settings * wps_er_ap_get_settings(struct wps_er *er,
++							  const u8 *uuid)
++{
++	struct wps_er_ap_settings *s;
++	dl_list_for_each(s, &er->ap_settings, struct wps_er_ap_settings, list)
++		if (os_memcmp(uuid, s->uuid, WPS_UUID_LEN) == 0)
++			return s;
++	return NULL;
++}
++
++
++int wps_er_ap_cache_settings(struct wps_er *er, struct in_addr *addr)
++{
++	struct wps_er_ap *ap;
++	struct wps_er_ap_settings *settings;
++
++	ap = wps_er_ap_get(er, addr, NULL);
++	if (ap == NULL || ap->ap_settings == NULL)
++		return -1;
++
++	settings = wps_er_ap_get_settings(er, ap->uuid);
++	if (!settings) {
++		settings = os_zalloc(sizeof(*settings));
++		if (settings == NULL)
++			return -1;
++		os_memcpy(settings->uuid, ap->uuid, WPS_UUID_LEN);
++		dl_list_add(&er->ap_settings, &settings->list);
++	}
++	os_memcpy(&settings->ap_settings, ap->ap_settings,
++		  sizeof(struct wps_credential));
++
++	return 0;
++}
++
++
++static int wps_er_ap_use_cached_settings(struct wps_er *er,
++					 struct wps_er_ap *ap)
++{
++	struct wps_er_ap_settings *s;
++
++	if (ap->ap_settings)
++		return 0;
++
++	s = wps_er_ap_get_settings(ap->er, ap->uuid);
++	if (!s)
++		return -1;
++
++	ap->ap_settings = os_malloc(sizeof(*ap->ap_settings));
++	if (ap->ap_settings == NULL)
++		return -1;
++
++	os_memcpy(ap->ap_settings, &s->ap_settings, sizeof(*ap->ap_settings));
++	wpa_printf(MSG_DEBUG, "WPS ER: Use cached AP settings");
++	return 0;
++}
++
++
+ static void wps_er_ap_remove_entry(struct wps_er *er, struct wps_er_ap *ap)
+ {
+ 	wpa_printf(MSG_DEBUG, "WPS ER: Removing AP entry for %s (%s)",
+@@ -352,6 +414,7 @@
+ 		wpa_printf(MSG_DEBUG, "WPS ER: Subscribed to events");
+ 		ap->subscribed = 1;
+ 		wps_er_get_sid(ap, http_client_get_hdr_line(c, "SID"));
++		wps_er_ap_use_cached_settings(ap->er, ap);
+ 		wps_er_ap_event(ap->er->wps, ap, WPS_EV_ER_AP_ADD);
+ 		break;
+ 	case HTTP_CLIENT_FAILED:
+@@ -583,8 +646,12 @@
+ static void wps_er_ap_remove_all(struct wps_er *er)
+ {
+ 	struct wps_er_ap *prev, *ap;
++	struct wps_er_ap_settings *prev_s, *s;
+ 	dl_list_for_each_safe(ap, prev, &er->ap, struct wps_er_ap, list)
+ 		wps_er_ap_remove_entry(er, ap);
++	dl_list_for_each_safe(s, prev_s, &er->ap_settings,
++			      struct wps_er_ap_settings, list)
++		os_free(s);
+ }
+ 
+ 
+@@ -649,7 +716,7 @@
+ 					       struct wps_parse_attr *attr,
+ 					       int probe_req)
+ {
+-	struct wps_er_sta *sta = wps_er_sta_get(ap, addr);
++	struct wps_er_sta *sta = wps_er_sta_get(ap, addr, NULL);
+ 	int new_sta = 0;
+ 	int m1;
+ 
+@@ -1162,6 +1229,7 @@
+ 		return NULL;
+ 	dl_list_init(&er->ap);
+ 	dl_list_init(&er->ap_unsubscribing);
++	dl_list_init(&er->ap_settings);
+ 
+ 	er->multicast_sd = -1;
+ 	er->ssdp_sd = -1;
+@@ -1269,19 +1337,30 @@
+ 				       enum http_client_event event)
+ {
+ 	struct wps_er_ap *ap = ctx;
++	union wps_event_data data;
++
++	os_memset(&data, 0, sizeof(data));
+ 
+ 	switch (event) {
+ 	case HTTP_CLIENT_OK:
+ 		wpa_printf(MSG_DEBUG, "WPS ER: SetSelectedRegistrar OK");
++		data.set_sel_reg.state = WPS_ER_SET_SEL_REG_DONE;
++		data.set_sel_reg.uuid = ap->uuid;
+ 		break;
+ 	case HTTP_CLIENT_FAILED:
+ 	case HTTP_CLIENT_INVALID_REPLY:
+ 	case HTTP_CLIENT_TIMEOUT:
+ 		wpa_printf(MSG_DEBUG, "WPS ER: SetSelectedRegistrar failed");
++		data.set_sel_reg.state = WPS_ER_SET_SEL_REG_FAILED;
++		data.set_sel_reg.uuid = ap->uuid;
+ 		break;
+ 	}
+ 	http_client_free(ap->http);
+ 	ap->http = NULL;
++
++	if (data.set_sel_reg.uuid)
++		ap->er->wps->event_cb(ap->er->wps->cb_ctx,
++				      WPS_EV_ER_SET_SELECTED_REGISTRAR, &data);
+ }
+ 
+ 
+@@ -1376,7 +1455,9 @@
+ 	struct wps_er_ap *ap;
+ 	struct wps_registrar *reg = er->wps->registrar;
+ 	const u8 *auth_macs;
++	u8 bcast[ETH_ALEN];
+ 	size_t count;
++	union wps_event_data data;
+ 
+ 	if (er->skip_set_sel_reg) {
+ 		wpa_printf(MSG_DEBUG, "WPS ER: Skip SetSelectedRegistrar");
+@@ -1388,6 +1469,13 @@
+ 		return;
+ 
+ 	auth_macs = wps_authorized_macs(reg, &count);
++#ifdef CONFIG_WPS2
++	if (count == 0) {
++		os_memset(bcast, 0xff, ETH_ALEN);
++		auth_macs = bcast;
++		count = 1;
++	}
++#endif /* CONFIG_WPS2 */
+ 
+ 	if (wps_build_version(msg) ||
+ 	    wps_er_build_selected_registrar(msg, sel_reg) ||
+@@ -1399,8 +1487,22 @@
+ 		return;
+ 	}
+ 
+-	dl_list_for_each(ap, &er->ap, struct wps_er_ap, list)
++	os_memset(&data, 0, sizeof(data));
++	data.set_sel_reg.sel_reg = sel_reg;
++	data.set_sel_reg.dev_passwd_id = dev_passwd_id;
++	data.set_sel_reg.sel_reg_config_methods = sel_reg_config_methods;
++	data.set_sel_reg.state = WPS_ER_SET_SEL_REG_START;
++
++	dl_list_for_each(ap, &er->ap, struct wps_er_ap, list) {
++		if (er->set_sel_reg_uuid_filter &&
++		    os_memcmp(ap->uuid, er->set_sel_reg_uuid_filter,
++			      WPS_UUID_LEN) != 0)
++			continue;
++		data.set_sel_reg.uuid = ap->uuid;
++		er->wps->event_cb(er->wps->cb_ctx,
++				  WPS_EV_ER_SET_SELECTED_REGISTRAR, &data);
+ 		wps_er_send_set_sel_reg(ap, msg);
++	}
+ 
+ 	wpabuf_free(msg);
+ }
+@@ -1408,22 +1510,41 @@
+ 
+ int wps_er_pbc(struct wps_er *er, const u8 *uuid)
+ {
++	int res;
++	struct wps_er_ap *ap;
++
+ 	if (er == NULL || er->wps == NULL)
+ 		return -1;
+ 
+ 	if (wps_registrar_pbc_overlap(er->wps->registrar, NULL, NULL)) {
+ 		wpa_printf(MSG_DEBUG, "WPS ER: PBC overlap - do not start PBC "
+ 			   "mode");
+-		return -1;
++		return -2;
+ 	}
+ 
+-	/*
+-	 * TODO: Should enable PBC mode only in a single AP based on which AP
+-	 * the Enrollee (uuid) is using. Now, we may end up enabling multiple
+-	 * APs in PBC mode which could result in session overlap at the
+-	 * Enrollee.
+-	 */
+-	if (wps_registrar_button_pushed(er->wps->registrar))
++	ap = wps_er_ap_get(er, NULL, uuid);
++	if (ap == NULL) {
++		struct wps_er_sta *sta = NULL;
++		dl_list_for_each(ap, &er->ap, struct wps_er_ap, list) {
++			sta = wps_er_sta_get(ap, NULL, uuid);
++			if (sta) {
++				uuid = ap->uuid;
++				break;
++			}
++		}
++		if (sta == NULL)
++			return -3; /* Unknown UUID */
++	}
++
++	if (ap->ap_settings == NULL) {
++		wpa_printf(MSG_DEBUG, "WPS ER: AP settings not known");
++		return -4;
++	}
++
++	er->set_sel_reg_uuid_filter = uuid;
++	res = wps_registrar_button_pushed(er->wps->registrar);
++	er->set_sel_reg_uuid_filter = NULL;
++	if (res)
+ 		return -1;
+ 
+ 	return 0;
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_er.h hostapd-0.8.x-mrvl/src/wps/wps_er.h
+--- hostapd-0.8-snapshot/src/wps/wps_er.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_er.h	2012-05-11 15:58:02.000000000 +0700
+@@ -73,6 +73,12 @@
+ 	void (*m1_handler)(struct wps_er_ap *ap, struct wpabuf *m1);
+ };
+ 
++struct wps_er_ap_settings {
++	struct dl_list list;
++	u8 uuid[WPS_UUID_LEN];
++	struct wps_credential ap_settings;
++};
++
+ struct wps_er {
+ 	struct wps_context *wps;
+ 	char ifname[17];
+@@ -83,6 +89,7 @@
+ 	int ssdp_sd;
+ 	struct dl_list ap;
+ 	struct dl_list ap_unsubscribing;
++	struct dl_list ap_settings;
+ 	struct http_server *http_srv;
+ 	int http_port;
+ 	unsigned int next_ap_id;
+@@ -92,6 +99,7 @@
+ 	void *deinit_done_ctx;
+ 	struct in_addr filter_addr;
+ 	int skip_set_sel_reg;
++	const u8 *set_sel_reg_uuid_filter;
+ };
+ 
+ 
+@@ -99,6 +107,7 @@
+ void wps_er_ap_add(struct wps_er *er, const u8 *uuid, struct in_addr *addr,
+ 		   const char *location, int max_age);
+ void wps_er_ap_remove(struct wps_er *er, struct in_addr *addr);
++int wps_er_ap_cache_settings(struct wps_er *er, struct in_addr *addr);
+ 
+ /* wps_er_ssdp.c */
+ int wps_er_ssdp_init(struct wps_er *er);
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_er_ssdp.c hostapd-0.8.x-mrvl/src/wps/wps_er_ssdp.c
+--- hostapd-0.8-snapshot/src/wps/wps_er_ssdp.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_er_ssdp.c	2012-05-11 15:58:02.000000000 +0700
+@@ -113,6 +113,7 @@
+ 		return; /* Not WPS advertisement/reply */
+ 
+ 	if (byebye) {
++		wps_er_ap_cache_settings(er, &addr.sin_addr);
+ 		wps_er_ap_remove(er, &addr.sin_addr);
+ 		return;
+ 	}
+diff -Naur hostapd-0.8-snapshot/src/wps/wps.h hostapd-0.8.x-mrvl/src/wps/wps.h
+--- hostapd-0.8-snapshot/src/wps/wps.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps.h	2012-05-11 15:58:02.000000000 +0700
+@@ -417,7 +417,17 @@
+ 	/**
+ 	 * WPS_EV_ER_AP_SETTINGS - ER: AP Settings learned
+ 	 */
+-	WPS_EV_ER_AP_SETTINGS
++	WPS_EV_ER_AP_SETTINGS,
++
++	/**
++	 * WPS_EV_ER_SET_SELECTED_REGISTRAR - ER: SetSelectedRegistrar event
++	 */
++	WPS_EV_ER_SET_SELECTED_REGISTRAR,
++
++	/**
++	 * WPS_EV_AP_PIN_SUCCESS - External Registrar used correct AP PIN
++	 */
++	WPS_EV_AP_PIN_SUCCESS
+ };
+ 
+ /**
+@@ -451,6 +461,7 @@
+ 	struct wps_event_fail {
+ 		int msg;
+ 		u16 config_error;
++		u16 error_indication;
+ 	} fail;
+ 
+ 	struct wps_event_pwd_auth_fail {
+@@ -492,6 +503,18 @@
+ 		const u8 *uuid;
+ 		const struct wps_credential *cred;
+ 	} ap_settings;
++
++	struct wps_event_er_set_selected_registrar {
++		const u8 *uuid;
++		int sel_reg;
++		u16 dev_passwd_id;
++		u16 sel_reg_config_methods;
++		enum {
++			WPS_ER_SET_SEL_REG_START,
++			WPS_ER_SET_SEL_REG_DONE,
++			WPS_ER_SET_SEL_REG_FAILED
++		} state;
++	} set_sel_reg;
+ };
+ 
+ /**
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_registrar.c hostapd-0.8.x-mrvl/src/wps/wps_registrar.c
+--- hostapd-0.8-snapshot/src/wps/wps_registrar.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_registrar.c	2012-05-11 15:58:02.000000000 +0700
+@@ -439,7 +439,7 @@
+ 		return 0;
+ 	if (reg->sel_reg_dev_password_id_override >= 0)
+ 		id = reg->sel_reg_dev_password_id_override;
+-	if (id != DEV_PW_PUSHBUTTON || !reg->dualband)
++	if (id != DEV_PW_PUSHBUTTON)
+ 		return 0;
+ 	return wps_build_uuid_e(msg, reg->wps->uuid);
+ }
+@@ -1087,7 +1087,7 @@
+ 	    wps_build_sel_reg_dev_password_id(reg, beacon) ||
+ 	    wps_build_sel_reg_config_methods(reg, beacon) ||
+ 	    wps_build_sel_pbc_reg_uuid_e(reg, beacon) ||
+-	    (reg->dualband && wps_build_rf_bands(&reg->wps->dev, beacon)) ||
++	    wps_build_rf_bands(&reg->wps->dev, beacon) ||
+ 	    wps_build_wfa_ext(beacon, 0, auth_macs, count)) {
+ 		wpabuf_free(beacon);
+ 		wpabuf_free(probe);
+@@ -2605,7 +2605,8 @@
+ 
+ 	if (attr.msg_type == NULL) {
+ 		wpa_printf(MSG_DEBUG, "WPS: No Message Type attribute");
+-		return WPS_FAILURE;
++		wps->state = SEND_WSC_NACK;
++		return WPS_CONTINUE;
+ 	}
+ 
+ 	if (*attr.msg_type != WPS_M1 &&
+@@ -2881,8 +2882,13 @@
+ 		os_memset(&cred, 0, sizeof(cred));
+ 		os_memcpy(cred.ssid, wps->wps->ssid, wps->wps->ssid_len);
+ 		cred.ssid_len = wps->wps->ssid_len;
++#ifdef MRVL_WPS2
++		cred.auth_type = wps->cred.auth_type;
++		cred.encr_type = wps->cred.encr_type;
++#else
+ 		cred.auth_type = WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK;
+ 		cred.encr_type = WPS_ENCR_TKIP | WPS_ENCR_AES;
++#endif
+ 		os_memcpy(cred.key, wps->new_psk, wps->new_psk_len);
+ 		cred.key_len = wps->new_psk_len;
+ 
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_upnp_ap.c hostapd-0.8.x-mrvl/src/wps/wps_upnp_ap.c
+--- hostapd-0.8-snapshot/src/wps/wps_upnp_ap.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_upnp_ap.c	2012-05-11 15:58:02.000000000 +0700
+@@ -25,9 +25,10 @@
+ static void upnp_er_set_selected_timeout(void *eloop_ctx, void *timeout_ctx)
+ {
+ 	struct subscription *s = eloop_ctx;
++	struct wps_registrar *reg = timeout_ctx;
+ 	wpa_printf(MSG_DEBUG, "WPS: SetSelectedRegistrar from ER timed out");
+ 	s->selected_registrar = 0;
+-	wps_registrar_selected_registrar_changed(s->reg);
++	wps_registrar_selected_registrar_changed(reg);
+ }
+ 
+ 
+@@ -46,7 +47,7 @@
+ 		return -1;
+ 
+ 	s->reg = reg;
+-	eloop_cancel_timeout(upnp_er_set_selected_timeout, s, NULL);
++	eloop_cancel_timeout(upnp_er_set_selected_timeout, s, reg);
+ 
+ 	os_memset(s->authorized_macs, 0, sizeof(s->authorized_macs));
+ 	if (attr.selected_registrar == NULL || *attr.selected_registrar == 0) {
+@@ -73,7 +74,7 @@
+ #endif /* CONFIG_WPS2 */
+ 		}
+ 		eloop_register_timeout(WPS_PBC_WALK_TIME, 0,
+-				       upnp_er_set_selected_timeout, s, NULL);
++				       upnp_er_set_selected_timeout, s, reg);
+ 	}
+ 
+ 	wps_registrar_selected_registrar_changed(reg);
+@@ -82,10 +83,11 @@
+ }
+ 
+ 
+-void upnp_er_remove_notification(struct subscription *s)
+-{
++void upnp_er_remove_notification(struct wps_registrar *reg,
++                                struct subscription *s){
+ 	s->selected_registrar = 0;
+-	eloop_cancel_timeout(upnp_er_set_selected_timeout, s, NULL);
+-	if (s->reg)
+-		wps_registrar_selected_registrar_changed(s->reg);
++
++	eloop_cancel_timeout(upnp_er_set_selected_timeout, s, reg);
++	if (reg)
++		wps_registrar_selected_registrar_changed(reg);
+ }
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_upnp.c hostapd-0.8.x-mrvl/src/wps/wps_upnp.c
+--- hostapd-0.8-snapshot/src/wps/wps_upnp.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_upnp.c	2012-05-11 15:58:02.000000000 +0700
+@@ -212,6 +212,10 @@
+ /* Maximum number of Probe Request events per second */
+ #define MAX_EVENTS_PER_SEC 5
+ 
++
++static struct upnp_wps_device_sm *shared_upnp_device = NULL;
++
++
+ /* Write the current date/time per RFC */
+ void format_date(struct wpabuf *buf)
+ {
+@@ -546,10 +550,13 @@
+  */
+ void subscription_destroy(struct subscription *s)
+ {
++	struct upnp_wps_device_interface *iface;
+ 	wpa_printf(MSG_DEBUG, "WPS UPnP: Destroy subscription %p", s);
+ 	subscr_addr_free_all(s);
+ 	event_delete_all(s);
+-	upnp_er_remove_notification(s);
++
++	dl_list_for_each(iface, &s->sm->interfaces,	struct upnp_wps_device_interface, list)
++	upnp_er_remove_notification(iface->wps->registrar, s);	
+ 	os_free(s);
+ }
+ 
+@@ -965,7 +972,7 @@
+  * upnp_wps_device_stop - Stop WPS UPnP operations on an interface
+  * @sm: WPS UPnP state machine from upnp_wps_device_init()
+  */
+-void upnp_wps_device_stop(struct upnp_wps_device_sm *sm)
++static void upnp_wps_device_stop(struct upnp_wps_device_sm *sm)
+ {
+ 	if (!sm || !sm->started)
+ 		return;
+@@ -997,7 +1004,7 @@
+  * @net_if: Selected network interface name
+  * Returns: 0 on success, -1 on failure
+  */
+-int upnp_wps_device_start(struct upnp_wps_device_sm *sm, char *net_if)
++static int upnp_wps_device_start(struct upnp_wps_device_sm *sm, char *net_if)
+ {
+ 	if (!sm || !net_if)
+ 		return -1;
+@@ -1052,24 +1059,56 @@
+ }
+ 
+ 
++static struct upnp_wps_device_interface *
++upnp_wps_get_iface(struct upnp_wps_device_sm *sm, void *priv)
++{
++	struct upnp_wps_device_interface *iface;
++	dl_list_for_each(iface, &sm->interfaces,
++			 struct upnp_wps_device_interface, list) {
++		if (iface->priv == priv)
++			return iface;
++	}
++	return NULL;
++}
++
++
+ /**
+  * upnp_wps_device_deinit - Deinitialize WPS UPnP
+  * @sm: WPS UPnP state machine from upnp_wps_device_init()
++ * @priv: External context data that was used in upnp_wps_device_init() call
+  */
+-void upnp_wps_device_deinit(struct upnp_wps_device_sm *sm)
++void upnp_wps_device_deinit(struct upnp_wps_device_sm *sm, void *priv)
+ {
++	struct upnp_wps_device_interface *iface;
++
+ 	if (!sm)
+ 		return;
+ 
+-	upnp_wps_device_stop(sm);
++	iface = upnp_wps_get_iface(sm, priv);
++	if (iface == NULL) {
++		wpa_printf(MSG_ERROR, "WPS UPnP: Could not find the interface "
++			   "instance to deinit");
++		return;
++	}
++	wpa_printf(MSG_DEBUG, "WPS UPnP: Deinit interface instance %p", iface);
++	if (dl_list_len(&sm->interfaces) == 1) {
++		wpa_printf(MSG_DEBUG, "WPS UPnP: Deinitializing last instance "
++			   "- free global device instance");
++		upnp_wps_device_stop(sm);
++	}
++	dl_list_del(&iface->list);
+ 
+-	if (sm->peer.wps)
+-		wps_deinit(sm->peer.wps);
+-	os_free(sm->root_dir);
+-	os_free(sm->desc_url);
+-	os_free(sm->ctx->ap_pin);
+-	os_free(sm->ctx);
+-	os_free(sm);
++	if (iface->peer.wps)
++		wps_deinit(iface->peer.wps);
++	os_free(iface->ctx->ap_pin);
++	os_free(iface->ctx);
++
++	if (dl_list_empty(&sm->interfaces)) {
++		os_free(sm->root_dir);
++		os_free(sm->desc_url);
++		os_free(sm);
++		shared_upnp_device = NULL;
++	}
+ }
+ 
+ 
+@@ -1078,25 +1117,59 @@
+  * @ctx: callback table; we must eventually free it
+  * @wps: Pointer to longterm WPS context
+  * @priv: External context data that will be used in callbacks
++ * @net_if: Selected network interface name
+  * Returns: WPS UPnP state or %NULL on failure
+  */
+ struct upnp_wps_device_sm *
+ upnp_wps_device_init(struct upnp_wps_device_ctx *ctx, struct wps_context *wps,
+-		     void *priv)
++		     void *priv, char *net_if)
+ {
+ 	struct upnp_wps_device_sm *sm;
++	struct upnp_wps_device_interface *iface;
++	int start = 0;
++
++	iface = os_zalloc(sizeof(*iface));
++	if (iface == NULL) {
++		os_free(ctx->ap_pin);
++		os_free(ctx);
++		return NULL;
++	}
++	wpa_printf(MSG_DEBUG, "WPS UPnP: Init interface instance %p", iface);
+ 
+-	sm = os_zalloc(sizeof(*sm));
+-	if (!sm) {
+-		wpa_printf(MSG_ERROR, "WPS UPnP: upnp_wps_device_init failed");
++	iface->ctx = ctx;
++	iface->wps = wps;
++	iface->priv = priv;
++
++	if (shared_upnp_device) {
++		wpa_printf(MSG_DEBUG, "WPS UPnP: Share existing device "
++			   "context");
++		sm = shared_upnp_device;
++	} else {
++		wpa_printf(MSG_DEBUG, "WPS UPnP: Initialize device context");
++		sm = os_zalloc(sizeof(*sm));
++		if (!sm) {
++			wpa_printf(MSG_ERROR, "WPS UPnP: upnp_wps_device_init "
++				   "failed");
++			os_free(iface);
++			os_free(ctx->ap_pin);
++			os_free(ctx);
++			return NULL;
++		}
++		shared_upnp_device = sm;
++
++		dl_list_init(&sm->msearch_replies);
++		dl_list_init(&sm->subscriptions);
++		dl_list_init(&sm->interfaces);
++		start = 1;
++	}
++
++	dl_list_add(&sm->interfaces, &iface->list);
++
++	if (start && upnp_wps_device_start(sm, net_if)) {
++		upnp_wps_device_deinit(sm, priv);
+ 		return NULL;
+ 	}
+ 
+-	sm->ctx = ctx;
+-	sm->wps = wps;
+-	sm->priv = priv;
+-	dl_list_init(&sm->msearch_replies);
+-	dl_list_init(&sm->subscriptions);
+ 
+ 	return sm;
+ }
+@@ -1115,16 +1188,20 @@
+ 
+ int upnp_wps_set_ap_pin(struct upnp_wps_device_sm *sm, const char *ap_pin)
+ {
++	struct upnp_wps_device_interface *iface;
+ 	if (sm == NULL)
+ 		return 0;
+ 
+-	os_free(sm->ctx->ap_pin);
+-	if (ap_pin) {
+-		sm->ctx->ap_pin = os_strdup(ap_pin);
+-		if (sm->ctx->ap_pin == NULL)
+-			return -1;
+-	} else
+-		sm->ctx->ap_pin = NULL;
++	dl_list_for_each(iface, &sm->interfaces,
++			 struct upnp_wps_device_interface, list) {
++		os_free(iface->ctx->ap_pin);
++		if (ap_pin) {
++			iface->ctx->ap_pin = os_strdup(ap_pin);
++			if (iface->ctx->ap_pin == NULL)
++				return -1;
++		} else
++			iface->ctx->ap_pin = NULL;
++	}
+ 
+ 	return 0;
+ }
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_upnp.h hostapd-0.8.x-mrvl/src/wps/wps_upnp.h
+--- hostapd-0.8-snapshot/src/wps/wps_upnp.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_upnp.h	2012-05-11 15:58:02.000000000 +0700
+@@ -35,11 +35,8 @@
+ 
+ struct upnp_wps_device_sm *
+ upnp_wps_device_init(struct upnp_wps_device_ctx *ctx, struct wps_context *wps,
+-		     void *priv);
+-void upnp_wps_device_deinit(struct upnp_wps_device_sm *sm);
+-
+-int upnp_wps_device_start(struct upnp_wps_device_sm *sm, char *net_if);
+-void upnp_wps_device_stop(struct upnp_wps_device_sm *sm);
++		     void *priv, char *net_if);
++void upnp_wps_device_deinit(struct upnp_wps_device_sm *sm, void *priv);
+ 
+ int upnp_wps_device_send_wlan_event(struct upnp_wps_device_sm *sm,
+ 				    const u8 from_mac_addr[ETH_ALEN],
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_upnp_i.h hostapd-0.8.x-mrvl/src/wps/wps_upnp_i.h
+--- hostapd-0.8-snapshot/src/wps/wps_upnp_i.h	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_upnp_i.h	2012-05-11 15:58:02.000000000 +0700
+@@ -103,16 +103,26 @@
+ };
+ 
+ 
++struct upnp_wps_device_interface {
++	struct dl_list list;
++	struct upnp_wps_device_ctx *ctx; /* callback table */
++	struct wps_context *wps;
++	void *priv;
++
++	/* FIX: maintain separate structures for each UPnP peer */
++	struct upnp_wps_peer peer;
++};
++
+ /*
+- * Our instance data corresponding to one WiFi network interface
+- * (multiple might share the same wired network interface!).
++ * Our instance data corresponding to the AP device. Note that there may be
++ * multiple wireless interfaces sharing the same UPnP device instance. Each
++ * such interface is stored in the list of struct upnp_wps_device_interface
++ * instances.
+  *
+  * This is known as an opaque struct declaration to users of the WPS UPnP code.
+  */
+ struct upnp_wps_device_sm {
+-	struct upnp_wps_device_ctx *ctx; /* callback table */
+-	struct wps_context *wps;
+-	void *priv;
++	struct dl_list interfaces; /* struct upnp_wps_device_interface */
+ 	char *root_dir;
+ 	char *desc_url;
+ 	int started; /* nonzero if we are active */
+@@ -136,9 +146,6 @@
+ 	enum upnp_wps_wlanevent_type wlanevent_type;
+ 	os_time_t last_event_sec;
+ 	unsigned int num_events_in_sec;
+-
+-	/* FIX: maintain separate structures for each UPnP peer */
+-	struct upnp_wps_peer peer;
+ };
+ 
+ /* wps_upnp.c */
+@@ -181,6 +188,6 @@
+ int upnp_er_set_selected_registrar(struct wps_registrar *reg,
+ 				   struct subscription *s,
+ 				   const struct wpabuf *msg);
+-void upnp_er_remove_notification(struct subscription *s);
+-
++void upnp_er_remove_notification(struct wps_registrar *reg,
++								struct subscription *s);
+ #endif /* WPS_UPNP_I_H */
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_upnp_ssdp.c hostapd-0.8.x-mrvl/src/wps/wps_upnp_ssdp.c
+--- hostapd-0.8-snapshot/src/wps/wps_upnp_ssdp.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_upnp_ssdp.c	2012-05-11 15:58:02.000000000 +0700
+@@ -136,9 +136,12 @@
+ 	struct wpabuf *msg;
+ 	char *NTString = "";
+ 	char uuid_string[80];
++	struct upnp_wps_device_interface *iface;
+ 
+ 	*islast = 0;
+-	uuid_bin2str(sm->wps->uuid, uuid_string, sizeof(uuid_string));
++	iface = dl_list_first(&sm->interfaces,
++			      struct upnp_wps_device_interface, list);
++	uuid_bin2str(iface->wps->uuid, uuid_string, sizeof(uuid_string));
+ 	msg = wpabuf_alloc(800); /* more than big enough */
+ 	if (msg == NULL)
+ 		goto fail;
+@@ -588,8 +591,13 @@
+ 			}
+ 			if (str_starts(data, "uuid:")) {
+ 				char uuid_string[80];
++				struct upnp_wps_device_interface *iface;
++				iface = dl_list_first(
++					&sm->interfaces,
++					struct upnp_wps_device_interface,
++					list);
+ 				data += os_strlen("uuid:");
+-				uuid_bin2str(sm->wps->uuid, uuid_string,
++				uuid_bin2str(iface->wps->uuid, uuid_string,
+ 					     sizeof(uuid_string));
+ 				if (str_starts(data, uuid_string))
+ 					st_match = 1;
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_upnp_web.c hostapd-0.8.x-mrvl/src/wps/wps_upnp_web.c
+--- hostapd-0.8-snapshot/src/wps/wps_upnp_web.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8.x-mrvl/src/wps/wps_upnp_web.c	2012-05-11 15:58:02.000000000 +0700
+@@ -184,6 +184,10 @@
+ {
+ 	const char *s;
+ 	char uuid_string[80];
++	struct upnp_wps_device_interface *iface;
++
++	iface = dl_list_first(&sm->interfaces,
++			      struct upnp_wps_device_interface, list);
+ 
+ 	wpabuf_put_str(buf, wps_device_xml_prefix);
+ 
+@@ -191,38 +195,38 @@
+ 	 * Add required fields with default values if not configured. Add
+ 	 * optional and recommended fields only if configured.
+ 	 */
+-	s = sm->wps->friendly_name;
++	s = iface->wps->friendly_name;
+ 	s = ((s && *s) ? s : "WPS Access Point");
+ 	xml_add_tagged_data(buf, "friendlyName", s);
+ 
+-	s = sm->wps->dev.manufacturer;
++	s = iface->wps->dev.manufacturer;
+ 	s = ((s && *s) ? s : "");
+ 	xml_add_tagged_data(buf, "manufacturer", s);
+ 
+-	if (sm->wps->manufacturer_url)
++	if (iface->wps->manufacturer_url)
+ 		xml_add_tagged_data(buf, "manufacturerURL",
+-				    sm->wps->manufacturer_url);
++				    iface->wps->manufacturer_url);
+ 
+-	if (sm->wps->model_description)
++	if (iface->wps->model_description)
+ 		xml_add_tagged_data(buf, "modelDescription",
+-				    sm->wps->model_description);
++				    iface->wps->model_description);
+ 
+-	s = sm->wps->dev.model_name;
++	s = iface->wps->dev.model_name;
+ 	s = ((s && *s) ? s : "");
+ 	xml_add_tagged_data(buf, "modelName", s);
+ 
+-	if (sm->wps->dev.model_number)
++	if (iface->wps->dev.model_number)
+ 		xml_add_tagged_data(buf, "modelNumber",
+-				    sm->wps->dev.model_number);
++				    iface->wps->dev.model_number);
+ 
+-	if (sm->wps->model_url)
+-		xml_add_tagged_data(buf, "modelURL", sm->wps->model_url);
++	if (iface->wps->model_url)
++		xml_add_tagged_data(buf, "modelURL", iface->wps->model_url);
+ 
+-	if (sm->wps->dev.serial_number)
++	if (iface->wps->dev.serial_number)
+ 		xml_add_tagged_data(buf, "serialNumber",
+-				    sm->wps->dev.serial_number);
++				    iface->wps->dev.serial_number);
+ 
+-	uuid_bin2str(sm->wps->uuid, uuid_string, sizeof(uuid_string));
++	uuid_bin2str(iface->wps->uuid, uuid_string, sizeof(uuid_string));
+ 	s = uuid_string;
+ 	/* Need "uuid:" prefix, thus we can't use xml_add_tagged_data()
+ 	 * easily...
+@@ -231,8 +235,8 @@
+ 	xml_data_encode(buf, s, os_strlen(s));
+ 	wpabuf_put_str(buf, "</UDN>\n");
+ 
+-	if (sm->wps->upc)
+-		xml_add_tagged_data(buf, "UPC", sm->wps->upc);
++	if (iface->wps->upc)
++		xml_add_tagged_data(buf, "UPC", iface->wps->upc);
+ 
+ 	wpabuf_put_str(buf, wps_device_xml_postfix);
+ }
+@@ -311,6 +315,10 @@
+ 	size_t extra_len = 0;
+ 	int body_length;
+ 	char len_buf[10];
++	struct upnp_wps_device_interface *iface;
++
++	iface = dl_list_first(&sm->interfaces,
++			      struct upnp_wps_device_interface, list);
+ 
+ 	/*
+ 	 * It is not required that filenames be case insensitive but it is
+@@ -322,16 +330,16 @@
+ 		wpa_printf(MSG_DEBUG, "WPS UPnP: HTTP GET for device XML");
+ 		req = GET_DEVICE_XML_FILE;
+ 		extra_len = 3000;
+-		if (sm->wps->friendly_name)
+-			extra_len += os_strlen(sm->wps->friendly_name);
+-		if (sm->wps->manufacturer_url)
+-			extra_len += os_strlen(sm->wps->manufacturer_url);
+-		if (sm->wps->model_description)
+-			extra_len += os_strlen(sm->wps->model_description);
+-		if (sm->wps->model_url)
+-			extra_len += os_strlen(sm->wps->model_url);
+-		if (sm->wps->upc)
+-			extra_len += os_strlen(sm->wps->upc);
++		if (iface->wps->friendly_name)
++			extra_len += os_strlen(iface->wps->friendly_name);
++		if (iface->wps->manufacturer_url)
++			extra_len += os_strlen(iface->wps->manufacturer_url);
++		if (iface->wps->model_description)
++			extra_len += os_strlen(iface->wps->model_description);
++		if (iface->wps->model_url)
++			extra_len += os_strlen(iface->wps->model_url);
++		if (iface->wps->upc)
++			extra_len += os_strlen(iface->wps->upc);
+ 	} else if (!os_strcasecmp(filename, UPNP_WPS_SCPD_XML_FILE)) {
+ 		wpa_printf(MSG_DEBUG, "WPS UPnP: HTTP GET for SCPD XML");
+ 		req = GET_SCPD_XML_FILE;
+@@ -408,11 +416,16 @@
+ {
+ 	static const char *name = "NewDeviceInfo";
+ 	struct wps_config cfg;
+-	struct upnp_wps_peer *peer = &sm->peer;
++	struct upnp_wps_device_interface *iface;
++	struct upnp_wps_peer *peer;
++
++	iface = dl_list_first(&sm->interfaces,
++			      struct upnp_wps_device_interface, list);
++	peer = &iface->peer;
+ 
+ 	wpa_printf(MSG_DEBUG, "WPS UPnP: GetDeviceInfo");
+ 
+-	if (sm->ctx->ap_pin == NULL)
++	if (iface->ctx->ap_pin == NULL)
+ 		return HTTP_INTERNAL_SERVER_ERROR;
+ 
+ 	/*
+@@ -427,9 +440,9 @@
+ 		wps_deinit(peer->wps);
+ 
+ 	os_memset(&cfg, 0, sizeof(cfg));
+-	cfg.wps = sm->wps;
+-	cfg.pin = (u8 *) sm->ctx->ap_pin;
+-	cfg.pin_len = os_strlen(sm->ctx->ap_pin);
++	cfg.wps = iface->wps;
++	cfg.pin = (u8 *) iface->ctx->ap_pin;
++	cfg.pin_len = os_strlen(iface->ctx->ap_pin);
+ 	peer->wps = wps_init(&cfg);
+ 	if (peer->wps) {
+ 		enum wsc_op_code op_code;
+@@ -458,6 +471,10 @@
+ 	enum http_reply_code ret;
+ 	enum wps_process_res res;
+ 	enum wsc_op_code op_code;
++	struct upnp_wps_device_interface *iface;
++
++	iface = dl_list_first(&sm->interfaces,
++			      struct upnp_wps_device_interface, list);
+ 
+ 	/*
+ 	 * PutMessage is used by external UPnP-based Registrar to perform WPS
+@@ -468,11 +485,11 @@
+ 	msg = xml_get_base64_item(data, "NewInMessage", &ret);
+ 	if (msg == NULL)
+ 		return ret;
+-	res = wps_process_msg(sm->peer.wps, WSC_UPnP, msg);
++	res = wps_process_msg(iface->peer.wps, WSC_UPnP, msg);
+ 	if (res == WPS_FAILURE)
+ 		*reply = NULL;
+ 	else
+-		*reply = wps_get_msg(sm->peer.wps, &op_code);
++		*reply = wps_get_msg(iface->peer.wps, &op_code);
+ 	wpabuf_free(msg);
+ 	if (*reply == NULL)
+ 		return HTTP_INTERNAL_SERVER_ERROR;
+@@ -491,6 +508,8 @@
+ 	int ev_type;
+ 	int type;
+ 	char *val;
++	struct upnp_wps_device_interface *iface;
++	int ok = 0;
+ 
+ 	/*
+ 	 * External UPnP-based Registrar is passing us a message to be proxied
+@@ -559,9 +578,16 @@
+ 		wpa_printf(MSG_DEBUG, "WPS UPnP: Message Type %d", type);
+ 	} else
+ 		type = -1;
+-	if (!sm->ctx->rx_req_put_wlan_response ||
+-	    sm->ctx->rx_req_put_wlan_response(sm->priv, ev_type, macaddr, msg,
+-					      type)) {
++	dl_list_for_each(iface, &sm->interfaces,
++			 struct upnp_wps_device_interface, list) {
++		if (iface->ctx->rx_req_put_wlan_response &&
++		    iface->ctx->rx_req_put_wlan_response(iface->priv, ev_type,
++							 macaddr, msg, type)
++		    == 0)
++			ok = 1;
++	}
++
++	if (!ok) {
+ 		wpa_printf(MSG_INFO, "WPS UPnP: Fail: sm->ctx->"
+ 			   "rx_req_put_wlan_response");
+ 		wpabuf_free(msg);
+@@ -606,6 +632,8 @@
+ 	struct wpabuf *msg;
+ 	enum http_reply_code ret;
+ 	struct subscription *s;
++	struct upnp_wps_device_interface *iface;
++	int err = 0;
+ 
+ 	wpa_printf(MSG_DEBUG, "WPS UPnP: SetSelectedRegistrar");
+ 	s = find_er(sm, cli);
+@@ -617,11 +645,15 @@
+ 	msg = xml_get_base64_item(data, "NewMessage", &ret);
+ 	if (msg == NULL)
+ 		return ret;
+-	if (upnp_er_set_selected_registrar(sm->wps->registrar, s, msg)) {
+-		wpabuf_free(msg);
+-		return HTTP_INTERNAL_SERVER_ERROR;
++	dl_list_for_each(iface, &sm->interfaces,
++			 struct upnp_wps_device_interface, list) {
++		if (upnp_er_set_selected_registrar(iface->wps->registrar, s,
++						   msg))
++			err = 1;
+ 	}
+ 	wpabuf_free(msg);
++	if (err)
++		return HTTP_INTERNAL_SERVER_ERROR;
+ 	*replyname = NULL;
+ 	*reply = NULL;
+ 	return HTTP_OK;
diff --git a/package/hostapd/patches/002-hostapd-wps_led.patch b/package/hostapd/patches/002-hostapd-wps_led.patch
new file mode 100644
index 0000000..aaac514
--- /dev/null
+++ b/package/hostapd/patches/002-hostapd-wps_led.patch
@@ -0,0 +1,162 @@
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_common.c hostapd-0.8-wps/src/wps/wps_common.c
+--- hostapd-0.8-snapshot/src/wps/wps_common.c	2010-10-21 20:49:41.000000000 +0700
++++ hostapd-0.8-wps/src/wps/wps_common.c	2014-01-14 12:24:06.768857973 +0700
+@@ -23,7 +23,6 @@
+ #include "wps_i.h"
+ #include "wps_dev_attr.h"
+ 
+-
+ void wps_kdf(const u8 *key, const u8 *label_prefix, size_t label_prefix_len,
+ 	     const char *label, u8 *res, size_t res_len)
+ {
+@@ -653,3 +652,98 @@
+ 
+ 	return methods;
+ }
++
++/*Function to write WPS LED value to proc entry */
++
++const char *led_mode[] = {"none","solid","heartbeat","heartbeat"};
++
++void write_wps_white_led_value(int value)
++{
++        FILE *fp;
++	int ret;
++
++	if ((value == WPS_LED_OFF) || (value == WPS_LED_SOLID_WHITE))
++		fp = fopen("/sys/class/leds/tlc59116\:wps_white/brightness","w");
++	else
++        	fp = fopen("/sys/class/leds/tlc59116\:wps_white/trigger","w");
++
++        if (fp != NULL)
++        {
++                /*
++                * Program the led in the simple led proc entry
++                */
++		switch (value)
++		{
++			case WPS_LED_OFF:
++				ret = fprintf(fp, "%d",0);
++				break;
++			case WPS_LED_SOLID_WHITE:
++				ret = fprintf(fp, "%d",255);
++				break;
++			default:
++				ret = fprintf(fp, "%s",led_mode[value]);
++				break;
++		}
++                if (ret < 0)
++                        wpa_printf(MSG_DEBUG, "%s: error with fputc \n", __func__);
++
++                fclose(fp);
++        }
++        else
++                wpa_printf(MSG_DEBUG, "%s: unable to open /sys/class/leds/tlc59116\:wps_white/trigger \n", __func__);
++}
++
++void write_wps_amber_led_value(int value)
++{
++	FILE *fp; 
++	int ret = 0;
++	if (value == WPS_LED_BLK_AMBER)
++		fp = fopen("/sys/class/leds/tlc59116\:wps_amber/trigger","w");
++	else
++		fp = fopen("/sys/class/leds/tlc59116\:wps_amber/brightness","w");
++
++	if (fp != NULL)
++	{
++		/*   
++		* Program the led in the simple led proc entry
++		*/
++		if (value == WPS_LED_BLK_AMBER)
++			ret = fprintf(fp, "%s",led_mode[value]);
++		else
++			ret = fprintf(fp, "%d",0);
++
++		if (ret < 0) 
++			wpa_printf(MSG_DEBUG, "%s: error with fputc \n", __func__);
++
++		fclose(fp);
++	}
++	else
++		wpa_printf(MSG_DEBUG, "%s: unable to open /sys/class/leds/tlc59116\:wps_amber/trigger \n", __func__);
++}
++
++void wps_led_control(int value)
++{
++        switch (value)
++        {
++                case WPS_LED_OFF:
++                        write_wps_white_led_value(WPS_LED_OFF);
++			write_wps_amber_led_value(WPS_LED_OFF);
++                        break;
++                case WPS_LED_SOLID_WHITE:
++			write_wps_amber_led_value(WPS_LED_OFF);
++                        write_wps_white_led_value(WPS_LED_SOLID_WHITE);
++                        break;
++                case WPS_LED_BLK_WHITE:
++			write_wps_amber_led_value(WPS_LED_OFF);
++                        write_wps_white_led_value(WPS_LED_BLK_WHITE);
++                        break;
++                case WPS_LED_BLK_AMBER:
++			write_wps_white_led_value(WPS_LED_OFF);
++                        write_wps_amber_led_value(WPS_LED_BLK_AMBER);
++                        break;
++                default:
++                        write_wps_white_led_value(WPS_LED_OFF);
++                        write_wps_amber_led_value(WPS_LED_OFF);
++                        break;
++        }
++}
+diff -Naur hostapd-0.8-snapshot/src/wps/wps.h hostapd-0.8-wps/src/wps/wps.h
+--- hostapd-0.8-snapshot/src/wps/wps.h	2014-01-14 21:18:57.052677971 +0700
++++ hostapd-0.8-wps/src/wps/wps.h	2014-01-14 11:28:57.992876533 +0700
+@@ -17,6 +17,12 @@
+ 
+ #include "wps_defs.h"
+ 
++#define WPS_LED_OFF 0
++#define WPS_LED_SOLID_WHITE 1
++#define WPS_LED_BLK_WHITE 2
++#define WPS_LED_BLK_AMBER 3
++
++
+ /**
+  * enum wsc_op_code - EAP-WSC OP-Code values
+  */
+diff -Naur hostapd-0.8-snapshot/src/wps/wps_registrar.c hostapd-0.8-wps/src/wps/wps_registrar.c
+--- hostapd-0.8-snapshot/src/wps/wps_registrar.c	2014-01-14 21:18:57.052677971 +0700
++++ hostapd-0.8-wps/src/wps/wps_registrar.c	2014-01-14 17:05:32.276763258 +0700
+@@ -852,6 +852,8 @@
+ 	wpa_printf(MSG_DEBUG, "WPS: PBC timed out - disable PBC mode");
+ 	wps_pbc_timeout_event(reg->wps);
+ 	wps_registrar_stop_pbc(reg);
++	//wps_led_control(WPS_LED_BLK_AMBER);
++	wps_led_control(WPS_LED_OFF);
+ }
+ 
+ 
+@@ -866,6 +868,7 @@
+  */
+ int wps_registrar_button_pushed(struct wps_registrar *reg)
+ {
++	printf("wps_registrar_button_pushed\n");
+ 	if (wps_registrar_pbc_overlap(reg, NULL, NULL)) {
+ 		wpa_printf(MSG_DEBUG, "WPS: PBC overlap - do not start PBC "
+ 			   "mode");
+@@ -877,6 +880,7 @@
+ 	reg->selected_registrar = 1;
+ 	reg->pbc = 1;
+ 	wps_registrar_selected_registrar_changed(reg);
++	wps_led_control(WPS_LED_BLK_WHITE);
+ 
+ 	eloop_cancel_timeout(wps_registrar_set_selected_timeout, reg, NULL);
+ 	eloop_cancel_timeout(wps_registrar_pbc_timeout, reg, NULL);
+@@ -1720,6 +1724,7 @@
+ 	wpabuf_free(plain);
+ 
+ 	wps->state = RECV_DONE;
++	wps_led_control(WPS_LED_SOLID_WHITE);
+ 	return msg;
+ }
+ 
diff --git a/package/hostapd/patches/300-nl80211_multicall_fixes.patch b/package/hostapd/patches/300-nl80211_multicall_fixes.patch
deleted file mode 100644
index be68ed1..0000000
--- a/package/hostapd/patches/300-nl80211_multicall_fixes.patch
+++ /dev/null
@@ -1,60 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -3290,6 +3290,7 @@ static void * wpa_driver_nl80211_init(vo
- 	drv->monitor_sock = -1;
- 	drv->eapol_tx_sock = -1;
- 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
-+	drv->nlmode = NL80211_IFTYPE_STATION;
- 
- 	if (wpa_driver_nl80211_init_nl(drv)) {
- 		os_free(drv);
-@@ -3607,17 +3608,12 @@ static void wpa_driver_nl80211_send_rfki
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
- 
--
- static int
--wpa_driver_nl80211_finish_drv_init(struct wpa_driver_nl80211_data *drv)
-+wpa_driver_nl80211_finish_drv_init_sta(struct wpa_driver_nl80211_data *drv,
-+				       int *send_rfkill_event)
- {
- 	struct i802_bss *bss = &drv->first_bss;
--	int send_rfkill_event = 0;
- 
--	drv->ifindex = if_nametoindex(bss->ifname);
--	drv->first_bss.ifindex = drv->ifindex;
--
--#ifndef HOSTAPD
- 	/*
- 	 * Make sure the interface starts up in station mode unless this is a
- 	 * dynamically added interface (e.g., P2P) that was already configured
-@@ -3636,7 +3632,7 @@ wpa_driver_nl80211_finish_drv_init(struc
- 				   "interface '%s' due to rfkill",
- 				   bss->ifname);
- 			drv->if_disabled = 1;
--			send_rfkill_event = 1;
-+			*send_rfkill_event = 1;
- 		} else {
- 			wpa_printf(MSG_ERROR, "nl80211: Could not set "
- 				   "interface '%s' UP", bss->ifname);
-@@ -3646,7 +3642,19 @@ wpa_driver_nl80211_finish_drv_init(struc
- 
- 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex,
- 			       1, IF_OPER_DORMANT);
--#endif /* HOSTAPD */
-+}
-+
-+static int
-+wpa_driver_nl80211_finish_drv_init(struct wpa_driver_nl80211_data *drv)
-+{
-+	struct i802_bss *bss = &drv->first_bss;
-+	int send_rfkill_event = 0;
-+
-+	drv->ifindex = if_nametoindex(bss->ifname);
-+	drv->first_bss.ifindex = drv->ifindex;
-+
-+	if (drv->nlmode == NL80211_IFTYPE_STATION)
-+		wpa_driver_nl80211_finish_drv_init_sta(drv, &send_rfkill_event);
- 
- 	if (wpa_driver_nl80211_capa(drv))
- 		return -1;
diff --git a/package/hostapd/patches/310-multicall_bridge_fix.patch b/package/hostapd/patches/310-multicall_bridge_fix.patch
deleted file mode 100644
index a80c041..0000000
--- a/package/hostapd/patches/310-multicall_bridge_fix.patch
+++ /dev/null
@@ -1,45 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -899,6 +899,10 @@ static void wpa_driver_nl80211_event_rtm
- 		return;
- 	}
- 
-+	if (ifi->ifi_family == AF_BRIDGE &&
-+	    drv->nlmode != NL80211_IFTYPE_AP)
-+		return;
-+
- 	wpa_printf(MSG_DEBUG, "RTM_NEWLINK: operstate=%d ifi_flags=0x%x "
- 		   "(%s%s%s%s)",
- 		   drv->operstate, ifi->ifi_flags,
-@@ -1006,6 +1010,10 @@ static void wpa_driver_nl80211_event_rtm
- 	attrlen = len;
- 	attr = (struct rtattr *) buf;
- 
-+	if (ifi->ifi_family == AF_BRIDGE &&
-+	    drv->nlmode != NL80211_IFTYPE_AP)
-+		return;
-+
- 	rta_len = RTA_ALIGN(sizeof(struct rtattr));
- 	while (RTA_OK(attr, attrlen)) {
- 		if (attr->rta_type == IFLA_IFNAME) {
-@@ -3292,6 +3300,11 @@ static void * wpa_driver_nl80211_init(vo
- 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
- 	drv->nlmode = NL80211_IFTYPE_STATION;
- 
-+#ifdef HOSTAPD
-+	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
-+	drv->if_indices = drv->default_if_indices;
-+#endif
-+
- 	if (wpa_driver_nl80211_init_nl(drv)) {
- 		os_free(drv);
- 		return NULL;
-@@ -8296,8 +8309,6 @@ static void *i802_init(struct hostapd_da
- 		br_ifindex = 0;
- 	}
- 
--	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
--	drv->if_indices = drv->default_if_indices;
- 	for (i = 0; i < params->num_bridge; i++) {
- 		if (params->bridge[i]) {
- 			ifindex = if_nametoindex(params->bridge[i]);
diff --git a/package/hostapd/patches/320-madwifi_key_fixes.patch b/package/hostapd/patches/320-madwifi_key_fixes.patch
deleted file mode 100644
index 45a7ac6..0000000
--- a/package/hostapd/patches/320-madwifi_key_fixes.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/src/drivers/driver_madwifi.c
-+++ b/src/drivers/driver_madwifi.c
-@@ -453,7 +453,9 @@ wpa_driver_madwifi_set_key(const char *i
- 
- 	memset(&wk, 0, sizeof(wk));
- 	wk.ik_type = cipher;
--	wk.ik_flags = IEEE80211_KEY_RECV | IEEE80211_KEY_XMIT;
-+	wk.ik_flags = IEEE80211_KEY_RECV;
-+	if (set_tx)
-+		wk.ik_flags |= IEEE80211_KEY_XMIT;
- 	if (addr == NULL || is_broadcast_ether_addr(addr)) {
- 		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
- 		wk.ik_keyix = key_idx;
-@@ -465,6 +467,20 @@ wpa_driver_madwifi_set_key(const char *i
- 	wk.ik_keylen = key_len;
- 	memcpy(wk.ik_keydata, key, key_len);
- 
-+#ifdef WORDS_BIGENDIAN
-+#define WPA_KEY_RSC_LEN 8
-+	{
-+		size_t i;
-+		u8 tmp[WPA_KEY_RSC_LEN];
-+		os_memset(tmp, 0, sizeof(tmp));
-+		for (i = 0; i < seq_len; i++)
-+			tmp[WPA_KEY_RSC_LEN - i - 1] = seq[i];
-+		os_memcpy(&wk.ik_keyrsc, tmp, WPA_KEY_RSC_LEN);
-+	}
-+#else /* WORDS_BIGENDIAN */
-+	os_memcpy(&wk.ik_keyrsc, seq, seq_len);
-+#endif /* WORDS_BIGENDIAN */
-+
- 	ret = set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk));
- 	if (ret < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: Failed to set key (addr %s"
diff --git a/package/hostapd/patches/400-noscan.patch b/package/hostapd/patches/400-noscan.patch
deleted file mode 100644
index 18a218c..0000000
--- a/package/hostapd/patches/400-noscan.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2464,6 +2464,8 @@ static int hostapd_config_fill(struct ho
- 			}
- #endif /* CONFIG_IEEE80211W */
- #ifdef CONFIG_IEEE80211N
-+		} else if (os_strcmp(buf, "noscan") == 0) {
-+			conf->noscan = atoi(pos);
- 		} else if (os_strcmp(buf, "ieee80211n") == 0) {
- 			conf->ieee80211n = atoi(pos);
- 		} else if (os_strcmp(buf, "ht_capab") == 0) {
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -511,6 +511,7 @@ struct hostapd_config {
- 
- 	int ht_op_mode_fixed;
- 	u16 ht_capab;
-+	int noscan;
- 	int ieee80211n;
- 	int secondary_channel;
- 	int require_ht;
---- a/src/ap/hw_features.c
-+++ b/src/ap/hw_features.c
-@@ -494,7 +494,7 @@ static int ieee80211n_check_40mhz(struct
- {
- 	struct wpa_driver_scan_params params;
- 
--	if (!iface->conf->secondary_channel)
-+	if (!iface->conf->secondary_channel || iface->conf->noscan)
- 		return 0; /* HT40 not used */
- 
- 	wpa_printf(MSG_DEBUG, "Scan for neighboring BSSes prior to enabling "
diff --git a/package/hostapd/patches/410-multicall.patch b/package/hostapd/patches/410-multicall.patch
deleted file mode 100644
index 723f5f6..0000000
--- a/package/hostapd/patches/410-multicall.patch
+++ /dev/null
@@ -1,246 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -14,6 +14,7 @@ CFLAGS += -I../src/utils
- # CFLAGS += -DUSE_KERNEL_HEADERS -I/usr/src/linux/include
- 
- -include .config
-+-include $(if $(MULTICALL), ../wpa_supplicant/.config)
- 
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
-@@ -192,10 +193,14 @@ ifdef CONFIG_IEEE80211AC
- CFLAGS += -DCONFIG_IEEE80211AC
- endif
- 
-+ifndef MULTICALL
-+CFLAGS += -DNO_SUPPLICANT
-+endif
-+
- include ../src/drivers/drivers.mak
--OBJS += $(DRV_AP_OBJS)
--CFLAGS += $(DRV_AP_CFLAGS)
--LDFLAGS += $(DRV_AP_LDFLAGS)
-+OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
-+CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
-+LDFLAGS += $(DRV_AP_LDFLAGS) $(if $(MULTICALL),$(DRV_WPA_LDFLAGS))
- LIBS += $(DRV_AP_LIBS)
- 
- ifdef CONFIG_L2_PACKET
-@@ -860,6 +865,12 @@ install: all
- 
- BCHECK=../src/drivers/build.hostapd
- 
-+hostapd_multi.a: $(BCHECK) $(OBJS)
-+	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ hostapd_multi.o $(OBJS)
-+
- hostapd: $(BCHECK) $(OBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
- 	@$(E) "  LD " $@
-@@ -898,6 +909,12 @@ HOBJS += ../src/crypto/aes-internal.o
- HOBJS += ../src/crypto/aes-internal-enc.o
- endif
- 
-+dump_cflags:
-+	@echo -n $(CFLAGS) " "
-+
-+dump_ldflags:
-+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
-+
- nt_password_hash: $(NOBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
- 	@$(E) "  LD " $@
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -14,6 +14,7 @@ CFLAGS += -I../src
- CFLAGS += -I../src/utils
- 
- -include .config
-+-include $(if $(MULTICALL),../hostapd/.config)
- 
- BINALL=wpa_supplicant wpa_cli
- 
-@@ -708,6 +709,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
- CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
- LIBS += -ldl -rdynamic
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_common/eap_common.o
-+  endif
- endif
- 
- ifdef CONFIG_AP
-@@ -716,9 +721,11 @@ NEED_EAP_COMMON=y
- NEED_RSN_AUTHENTICATOR=y
- CFLAGS += -DCONFIG_AP
- OBJS += ap.o
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
- CFLAGS += -DCONFIG_NO_ACCOUNTING
- CFLAGS += -DCONFIG_NO_VLAN
-+endif
- OBJS += ../src/ap/hostapd.o
- OBJS += ../src/ap/wpa_auth_glue.o
- OBJS += ../src/ap/utils.o
-@@ -773,10 +780,18 @@ endif
- ifdef CONFIG_HS20
- OBJS += ../src/ap/hs20.o
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_server/eap_server.o
-+    OBJS += ../src/eap_server/eap_server_identity.o
-+    OBJS += ../src/eap_server/eap_server_methods.o
-+  endif
- endif
- 
- ifdef NEED_RSN_AUTHENTICATOR
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
-+endif
- NEED_AES_WRAP=y
- OBJS += ../src/ap/wpa_auth.o
- OBJS += ../src/ap/wpa_auth_ie.o
-@@ -1525,6 +1540,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
- 
- $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
- 
-+wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
-+	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
-+
- wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
- 	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
- 	@$(E) "  LD " $@
-@@ -1595,6 +1616,12 @@ eap_ikev2.so: ../src/eap_peer/eap_ikev2.
- %@.service: %.service.arg.in
- 	sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
- 
-+dump_cflags:
-+	@echo -n $(CFLAGS) " "
-+
-+dump_ldflags:
-+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
-+
- wpa_supplicant.exe: wpa_supplicant
- 	mv -f $< $@
- wpa_cli.exe: wpa_cli
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -3750,8 +3750,8 @@ union wpa_event_data {
-  * Driver wrapper code should call this function whenever an event is received
-  * from the driver.
-  */
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data);
-+extern void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+				    union wpa_event_data *data);
- 
- 
- /*
---- a/src/ap/drv_callbacks.c
-+++ b/src/ap/drv_callbacks.c
-@@ -714,8 +714,8 @@ static void hostapd_event_eapol_rx(struc
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+		       union wpa_event_data *data)
- {
- 	struct hostapd_data *hapd = ctx;
- #ifndef CONFIG_NO_STDOUT_DEBUG
---- a/wpa_supplicant/wpa_priv.c
-+++ b/wpa_supplicant/wpa_priv.c
-@@ -819,8 +819,8 @@ static void wpa_priv_send_ft_response(st
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+static void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data)
- {
- 	struct wpa_priv_interface *iface = ctx;
- 
-@@ -962,6 +962,7 @@ int main(int argc, char *argv[])
- 	if (os_program_init())
- 		return -1;
- 
-+	wpa_supplicant_event = supplicant_event;
- 	wpa_priv_fd_workaround();
- 
- 	for (;;) {
---- a/wpa_supplicant/events.c
-+++ b/wpa_supplicant/events.c
-@@ -2354,8 +2354,8 @@ static void wpa_supplicant_event_unprot_
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void supplicant_event(void *ctx, enum wpa_event_type event,
-+		      union wpa_event_data *data)
- {
- 	struct wpa_supplicant *wpa_s = ctx;
- 	u16 reason_code = 0;
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -3050,6 +3050,9 @@ static void wpa_supplicant_deinit_iface(
- 	}
- }
- 
-+extern void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
-+
- 
- /**
-  * wpa_supplicant_add_iface - Add a new network interface
-@@ -3244,6 +3247,7 @@ struct wpa_global * wpa_supplicant_init(
- 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
- #endif /* CONFIG_NO_WPA_MSG */
- 
-+	wpa_supplicant_event = supplicant_event;
- 	wpa_debug_open_file(params->wpa_debug_file_path);
- 	if (params->wpa_debug_syslog)
- 		wpa_debug_open_syslog();
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -554,6 +554,9 @@ static int hostapd_get_ctrl_iface_group(
- 	return 0;
- }
- 
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+                       union wpa_event_data *data);
-+
- 
- int main(int argc, char *argv[])
- {
-@@ -579,6 +582,7 @@ int main(int argc, char *argv[])
- 	interfaces.global_iface_name = NULL;
- 	interfaces.global_ctrl_sock = -1;
- 
-+	wpa_supplicant_event = hostapd_wpa_event;
- 	for (;;) {
- 		c = getopt(argc, argv, "Bde:f:hKP:tvg:G:");
- 		if (c < 0)
---- a/src/drivers/drivers.c
-+++ b/src/drivers/drivers.c
-@@ -7,7 +7,11 @@
-  */
- 
- #include "includes.h"
-+#include "common.h"
-+#include "driver.h"
- 
-+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
- 
- #ifdef CONFIG_DRIVER_WEXT
- extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
diff --git a/package/hostapd/patches/420-timestamp_check.patch b/package/hostapd/patches/420-timestamp_check.patch
deleted file mode 100644
index b2d4a05..0000000
--- a/package/hostapd/patches/420-timestamp_check.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/src/tls/x509v3.c
-+++ b/src/tls/x509v3.c
-@@ -1848,6 +1848,9 @@ int x509_certificate_chain_validate(stru
- 		if (chain_trusted)
- 			continue;
- 
-+#ifdef NO_TIMESTAMP_CHECK
-+		disable_time_checks = 1;
-+#endif
- 		if (!disable_time_checks &&
- 		    ((unsigned long) now.sec <
- 		     (unsigned long) cert->not_before ||
diff --git a/package/hostapd/patches/430-rescan_immediately.patch b/package/hostapd/patches/430-rescan_immediately.patch
deleted file mode 100644
index 9d5fd32..0000000
--- a/package/hostapd/patches/430-rescan_immediately.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2443,7 +2443,7 @@ static struct wpa_supplicant * wpa_suppl
- 	if (wpa_s == NULL)
- 		return NULL;
- 	wpa_s->scan_req = INITIAL_SCAN_REQ;
--	wpa_s->scan_interval = 5;
-+	wpa_s->scan_interval = 1;
- 	wpa_s->new_connection = 1;
- 	wpa_s->parent = wpa_s;
- 	wpa_s->sched_scanning = 0;
diff --git a/package/hostapd/patches/440-optional_rfkill.patch b/package/hostapd/patches/440-optional_rfkill.patch
deleted file mode 100644
index 8a006df..0000000
--- a/package/hostapd/patches/440-optional_rfkill.patch
+++ /dev/null
@@ -1,261 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -218,7 +218,9 @@ struct wpa_driver_nl80211_data {
- 	int if_removed;
- 	int if_disabled;
- 	int ignore_if_down_event;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_data *rfkill;
-+#endif
- 	struct wpa_driver_capa capa;
- 	u8 *extended_capa, *extended_capa_mask;
- 	unsigned int extended_capa_len;
-@@ -3128,7 +3130,7 @@ static int wpa_driver_nl80211_init_nl(st
- 	return 0;
- }
- 
--
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_nl80211_rfkill_blocked(void *ctx)
- {
- 	wpa_printf(MSG_DEBUG, "nl80211: RFKILL blocked");
-@@ -3151,6 +3153,7 @@ static void wpa_driver_nl80211_rfkill_un
- 	}
- 	/* rtnetlink ifup handler will report interface as enabled */
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static void nl80211_get_phy_name(struct wpa_driver_nl80211_data *drv)
-@@ -3279,7 +3282,9 @@ static void * wpa_driver_nl80211_init(vo
- 				      void *global_priv)
- {
- 	struct wpa_driver_nl80211_data *drv;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_config *rcfg;
-+#endif
- 	struct i802_bss *bss;
- 
- 	if (global_priv == NULL)
-@@ -3315,6 +3320,7 @@ static void * wpa_driver_nl80211_init(vo
- 
- 	nl80211_get_phy_name(drv);
- 
-+#ifdef CONFIG_RFKILL
- 	rcfg = os_zalloc(sizeof(*rcfg));
- 	if (rcfg == NULL)
- 		goto failed;
-@@ -3327,6 +3333,7 @@ static void * wpa_driver_nl80211_init(vo
- 		wpa_printf(MSG_DEBUG, "nl80211: RFKILL status not available");
- 		os_free(rcfg);
- 	}
-+#endif /* CONFIG_RFKILL */
- 
- 	if (wpa_driver_nl80211_finish_drv_init(drv))
- 		goto failed;
-@@ -3616,10 +3623,12 @@ static void nl80211_mgmt_unsubscribe(str
- }
- 
- 
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_nl80211_send_rfkill(void *eloop_ctx, void *timeout_ctx)
- {
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
-+#endif /* CONFIG_RFKILL */
- 
- static int
- wpa_driver_nl80211_finish_drv_init_sta(struct wpa_driver_nl80211_data *drv,
-@@ -3640,13 +3649,16 @@ wpa_driver_nl80211_finish_drv_init_sta(s
- 	}
- 
- 	if (linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
-+#ifdef CONFIG_RFKILL
- 		if (rfkill_is_blocked(drv->rfkill)) {
- 			wpa_printf(MSG_DEBUG, "nl80211: Could not yet enable "
- 				   "interface '%s' due to rfkill",
- 				   bss->ifname);
- 			drv->if_disabled = 1;
- 			*send_rfkill_event = 1;
--		} else {
-+		} else
-+#endif
-+		{
- 			wpa_printf(MSG_ERROR, "nl80211: Could not set "
- 				   "interface '%s' UP", bss->ifname);
- 			return -1;
-@@ -3677,8 +3689,10 @@ wpa_driver_nl80211_finish_drv_init(struc
- 		return -1;
- 
- 	if (send_rfkill_event) {
-+#ifdef CONFIG_RFKILL
- 		eloop_register_timeout(0, 0, wpa_driver_nl80211_send_rfkill,
- 				       drv, drv->ctx);
-+#endif
- 	}
- 
- 	return 0;
-@@ -3764,7 +3778,9 @@ static void wpa_driver_nl80211_deinit(st
- 
- 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex, 0,
- 			       IF_OPER_UP);
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 
- 	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
- 
---- a/src/drivers/driver_wext.c
-+++ b/src/drivers/driver_wext.c
-@@ -742,7 +742,7 @@ static void wpa_driver_wext_event_rtm_de
- 	}
- }
- 
--
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_wext_rfkill_blocked(void *ctx)
- {
- 	wpa_printf(MSG_DEBUG, "WEXT: RFKILL blocked");
-@@ -764,7 +764,7 @@ static void wpa_driver_wext_rfkill_unblo
- 	}
- 	/* rtnetlink ifup handler will report interface as enabled */
- }
--
-+#endif /* CONFIG_RFKILL */
- 
- static void wext_get_phy_name(struct wpa_driver_wext_data *drv)
- {
-@@ -810,7 +810,9 @@ void * wpa_driver_wext_init(void *ctx, c
- {
- 	struct wpa_driver_wext_data *drv;
- 	struct netlink_config *cfg;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_config *rcfg;
-+#endif
- 	char path[128];
- 	struct stat buf;
- 
-@@ -845,6 +847,7 @@ void * wpa_driver_wext_init(void *ctx, c
- 		goto err2;
- 	}
- 
-+#ifdef CONFIG_RFKILL
- 	rcfg = os_zalloc(sizeof(*rcfg));
- 	if (rcfg == NULL)
- 		goto err3;
-@@ -857,6 +860,7 @@ void * wpa_driver_wext_init(void *ctx, c
- 		wpa_printf(MSG_DEBUG, "WEXT: RFKILL status not available");
- 		os_free(rcfg);
- 	}
-+#endif /* CONFIG_RFKILL */
- 
- 	drv->mlme_sock = -1;
- 
-@@ -874,7 +878,9 @@ void * wpa_driver_wext_init(void *ctx, c
- 	return drv;
- 
- err3:
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 	netlink_deinit(drv->netlink);
- err2:
- 	close(drv->ioctl_sock);
-@@ -884,10 +890,12 @@ err1:
- }
- 
- 
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_wext_send_rfkill(void *eloop_ctx, void *timeout_ctx)
- {
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv)
-@@ -895,13 +903,16 @@ static int wpa_driver_wext_finish_drv_in
- 	int send_rfkill_event = 0;
- 
- 	if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1) < 0) {
-+#ifdef CONFIG_RFKILL
- 		if (rfkill_is_blocked(drv->rfkill)) {
- 			wpa_printf(MSG_DEBUG, "WEXT: Could not yet enable "
- 				   "interface '%s' due to rfkill",
- 				   drv->ifname);
- 			drv->if_disabled = 1;
- 			send_rfkill_event = 1;
--		} else {
-+		} else
-+#endif
-+		{
- 			wpa_printf(MSG_ERROR, "WEXT: Could not set "
- 				   "interface '%s' UP", drv->ifname);
- 			return -1;
-@@ -949,8 +960,10 @@ static int wpa_driver_wext_finish_drv_in
- 			       1, IF_OPER_DORMANT);
- 
- 	if (send_rfkill_event) {
-+#ifdef CONFIG_RFKILL
- 		eloop_register_timeout(0, 0, wpa_driver_wext_send_rfkill,
- 				       drv, drv->ctx);
-+#endif
- 	}
- 
- 	return 0;
-@@ -980,7 +993,9 @@ void wpa_driver_wext_deinit(void *priv)
- 
- 	netlink_send_oper_ifla(drv->netlink, drv->ifindex, 0, IF_OPER_UP);
- 	netlink_deinit(drv->netlink);
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 
- 	if (drv->mlme_sock >= 0)
- 		eloop_unregister_read_sock(drv->mlme_sock);
---- a/src/drivers/drivers.mak
-+++ b/src/drivers/drivers.mak
-@@ -25,7 +25,6 @@ NEED_SME=y
- NEED_AP_MLME=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- 
- ifdef CONFIG_LIBNL32
-   DRV_LIBS += -lnl-3
-@@ -109,7 +108,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
- CONFIG_WIRELESS_EXTENSION=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- endif
- 
- ifdef CONFIG_DRIVER_NDIS
-@@ -135,7 +133,6 @@ endif
- ifdef CONFIG_WIRELESS_EXTENSION
- DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
- DRV_WPA_OBJS += ../src/drivers/driver_wext.o
--NEED_RFKILL=y
- endif
- 
- ifdef NEED_NETLINK
-@@ -148,6 +145,7 @@ endif
- 
- ifdef NEED_RFKILL
- DRV_OBJS += ../src/drivers/rfkill.o
-+DRV_WPA_CFLAGS += -DCONFIG_RFKILL
- endif
- 
- ifdef CONFIG_VLAN_NETLINK
---- a/src/drivers/driver_wext.h
-+++ b/src/drivers/driver_wext.h
-@@ -22,7 +22,9 @@ struct wpa_driver_wext_data {
- 	int ifindex2;
- 	int if_removed;
- 	int if_disabled;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_data *rfkill;
-+#endif
- 	u8 *assoc_req_ies;
- 	size_t assoc_req_ies_len;
- 	u8 *assoc_resp_ies;
diff --git a/package/hostapd/patches/450-reload_freq_change.patch b/package/hostapd/patches/450-reload_freq_change.patch
deleted file mode 100644
index ffa757e..0000000
--- a/package/hostapd/patches/450-reload_freq_change.patch
+++ /dev/null
@@ -1,27 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -156,6 +156,24 @@ int hostapd_reload_config(struct hostapd
- 	oldconf = hapd->iconf;
- 	iface->conf = newconf;
- 
-+	hostapd_select_hw_mode(iface);
-+	iface->freq = hostapd_hw_get_freq(hapd, newconf->channel);
-+
-+	if (hostapd_set_freq(hapd, newconf->hw_mode, iface->freq,
-+			     newconf->channel,
-+			     newconf->ieee80211n,
-+			     newconf->ieee80211ac,
-+			     newconf->secondary_channel,
-+			     newconf->vht_oper_chwidth,
-+			     newconf->vht_oper_centr_freq_seg0_idx,
-+			     newconf->vht_oper_centr_freq_seg1_idx)) {
-+		wpa_printf(MSG_ERROR, "Could not set channel for "
-+			   "kernel driver");
-+	}
-+
-+	if (iface->current_mode)
-+		hostapd_prepare_rates(iface, iface->current_mode);
-+
- 	for (j = 0; j < iface->num_bss; j++) {
- 		hapd = iface->bss[j];
- 		hapd->iconf = newconf;
diff --git a/package/hostapd/patches/451-nl80211_del_beacon_bss.patch b/package/hostapd/patches/451-nl80211_del_beacon_bss.patch
deleted file mode 100644
index fdff9e7..0000000
--- a/package/hostapd/patches/451-nl80211_del_beacon_bss.patch
+++ /dev/null
@@ -1,63 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -3699,16 +3699,18 @@ wpa_driver_nl80211_finish_drv_init(struc
- }
- 
- 
--static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
-+static int wpa_driver_nl80211_del_bss_beacon(struct i802_bss *bss)
- {
-+	struct wpa_driver_nl80211_data *drv = bss->drv;
- 	struct nl_msg *msg;
- 
-+	bss->beacon_set = 0;
- 	msg = nlmsg_alloc();
- 	if (!msg)
- 		return -ENOMEM;
- 
- 	nl80211_cmd(drv, msg, 0, NL80211_CMD_DEL_BEACON);
--	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
-+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
- 
- 	return send_and_recv_msgs(drv, msg, NULL, NULL);
-  nla_put_failure:
-@@ -3716,6 +3718,21 @@ static int wpa_driver_nl80211_del_beacon
- 	return -ENOBUFS;
- }
- 
-+static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
-+{
-+	struct i802_bss *bss;
-+
-+	for (bss = &drv->first_bss; bss; bss = bss->next)
-+		wpa_driver_nl80211_del_bss_beacon(bss);
-+
-+	return 0;
-+}
-+
-+static int wpa_driver_nl80211_stop_ap(void *priv)
-+{
-+	struct i802_bss *bss = priv;
-+	return wpa_driver_nl80211_del_beacon(bss->drv);
-+}
- 
- /**
-  * wpa_driver_nl80211_deinit - Deinitialize nl80211 driver interface
-@@ -9855,4 +9872,5 @@ const struct wpa_driver_ops wpa_driver_n
- 	.tdls_oper = nl80211_tdls_oper,
- #endif /* CONFIG_TDLS */
- 	.update_ft_ies = wpa_driver_nl80211_update_ft_ies,
-+	.stop_ap = wpa_driver_nl80211_stop_ap,
- };
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -2095,6 +2095,9 @@ struct wpa_driver_ops {
- 	 */
- 	int (*probe_req_report)(void *priv, int report);
- 
-+
-+	int (*stop_ap)(void *priv);
-+
- 	/**
- 	 * deinit_ap - Deinitialize AP mode
- 	 * @priv: Private driver interface data
diff --git a/package/hostapd/patches/452-ctrl_iface_reload.patch b/package/hostapd/patches/452-ctrl_iface_reload.patch
deleted file mode 100644
index 85e871f..0000000
--- a/package/hostapd/patches/452-ctrl_iface_reload.patch
+++ /dev/null
@@ -1,98 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -33,6 +33,7 @@
- #include "wps/wps.h"
- #include "config_file.h"
- #include "ctrl_iface.h"
-+#include "config_file.h"
- 
- 
- struct wpa_ctrl_dst {
-@@ -43,6 +44,7 @@ struct wpa_ctrl_dst {
- 	int errors;
- };
- 
-+static char *reload_opts = NULL;
- 
- static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
- 				    const char *buf, size_t len);
-@@ -152,6 +154,68 @@ static int hostapd_ctrl_iface_new_sta(st
- 	return 0;
- }
- 
-+static int hostapd_ctrl_iface_set_down(struct hostapd_data *hapd)
-+{
-+	if (hapd->driver->stop_ap)
-+		hapd->driver->stop_ap(hapd->drv_priv);
-+	return 0;
-+}
-+
-+static char *get_option(char *opt, char *str)
-+{
-+	int len = strlen(str);
-+
-+	if (!strncmp(opt, str, len))
-+		return opt + len;
-+	else
-+		return NULL;
-+}
-+
-+static struct hostapd_config *hostapd_ctrl_iface_config_read(const char *fname)
-+{
-+	struct hostapd_config *conf;
-+	char *opt, *val;
-+
-+	conf = hostapd_config_read(fname);
-+	if (!conf)
-+		return NULL;
-+
-+	for (opt = strtok(reload_opts, " ");
-+	     opt;
-+		 opt = strtok(NULL, " ")) {
-+
-+		if ((val = get_option(opt, "channel=")))
-+			conf->channel = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab=")))
-+			conf->ht_capab = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab_mask=")))
-+			conf->ht_capab &= atoi(val);
-+		else if ((val = get_option(opt, "sec_chan=")))
-+			conf->secondary_channel = atoi(val);
-+		else if ((val = get_option(opt, "hw_mode=")))
-+			conf->hw_mode = atoi(val);
-+		else if ((val = get_option(opt, "ieee80211n=")))
-+			conf->ieee80211n = atoi(val);
-+		else
-+			break;
-+	}
-+
-+	return conf;
-+}
-+
-+static int hostapd_ctrl_iface_update(struct hostapd_data *hapd, char *txt)
-+{
-+	struct hostapd_config * (*config_read_cb)(const char *config_fname);
-+	struct hostapd_iface *iface = hapd->iface;
-+
-+	config_read_cb = iface->interfaces->config_read_cb;
-+	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
-+	reload_opts = txt;
-+
-+	hostapd_reload_config(iface);
-+
-+	iface->interfaces->config_read_cb = config_read_cb;
-+}
- 
- #ifdef CONFIG_IEEE80211W
- #ifdef NEED_AP_MLME
-@@ -902,6 +966,10 @@ static void hostapd_ctrl_iface_receive(i
- 				reply_len += res;
- 		}
- #endif /* CONFIG_NO_RADIUS */
-+	} else if (os_strcmp(buf, "DOWN") == 0) {
-+		hostapd_ctrl_iface_set_down(hapd);
-+	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
-+		hostapd_ctrl_iface_update(hapd, buf + 7);
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
- 							 reply_size);
diff --git a/package/hostapd/patches/453-ap_sta_support.patch b/package/hostapd/patches/453-ap_sta_support.patch
deleted file mode 100644
index a3dff04..0000000
--- a/package/hostapd/patches/453-ap_sta_support.patch
+++ /dev/null
@@ -1,223 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant_i.h
-+++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -96,6 +96,8 @@ struct wpa_interface {
- 	 * receiving of EAPOL frames from an additional interface.
- 	 */
- 	const char *bridge_ifname;
-+
-+	const char *hostapd_ctrl;
- };
- 
- /**
-@@ -306,6 +308,8 @@ struct wpa_supplicant {
- #endif /* CONFIG_CTRL_IFACE_DBUS_NEW */
- 	char bridge_ifname[16];
- 
-+	struct wpa_ctrl *hostapd;
-+
- 	char *confname;
- 	struct wpa_config *conf;
- 	int countermeasures;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -13,6 +13,10 @@ PKG_CONFIG ?= pkg-config
- CFLAGS += -I../src
- CFLAGS += -I../src/utils
- 
-+ifdef MULTICALL
-+CFLAGS += -DMULTICALL
-+endif
-+
- -include .config
- -include $(if $(MULTICALL),../hostapd/.config)
- 
-@@ -76,6 +80,10 @@ OBJS_c = wpa_cli.o ../src/common/wpa_ctr
- OBJS_c += ../src/utils/wpa_debug.o
- OBJS_c += ../src/utils/common.o
- 
-+ifdef MULTICALL
-+OBJS += ../src/common/wpa_ctrl.o
-+endif
-+
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
- CONFIG_OS=win32
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -107,6 +107,55 @@ extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
- extern struct wpa_driver_ops *wpa_drivers[];
- 
-+#ifdef MULTICALL
-+static int hostapd_stop(struct wpa_supplicant *wpa_s)
-+{
-+	const char *cmd = "DOWN";
-+	char buf[256];
-+	int len = sizeof(buf);
-+
-+	if (wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL) < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to stop hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+
-+static int hostapd_reload(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
-+{
-+	char *cmd = NULL;
-+	char buf[256];
-+	int len = sizeof(buf);
-+	int channel, hw_mode;
-+	int ret;
-+
-+	if (!bss)
-+		return;
-+
-+	if (bss->freq < 4000) {
-+		hw_mode = HOSTAPD_MODE_IEEE80211G;
-+		channel = (bss->freq - 2407) / 5;
-+	} else {
-+		hw_mode = HOSTAPD_MODE_IEEE80211A;
-+		channel = (bss->freq - 5000) / 5;
-+	}
-+
-+	if (asprintf(&cmd, "UPDATE channel=%d sec_chan=0 hw_mode=%d ieee80211n=%d",
-+		     channel, hw_mode, !!bss->ht_capab) < 0) {
-+		return -1;
-+	}
-+
-+	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
-+	free(cmd);
-+
-+	if (ret < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to reload hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+#endif
-+
- /* Configure default/group WEP keys for static WEP */
- int wpa_set_wep_keys(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid)
- {
-@@ -667,8 +716,16 @@ void wpa_supplicant_set_state(struct wpa
- #endif /* CONFIG_P2P */
- 
- 		sme_sched_obss_scan(wpa_s, 1);
-+#ifdef MULTICALL
-+		if (wpa_s->hostapd)
-+			hostapd_reload(wpa_s, wpa_s->current_bss);
-+#endif
- 	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
- 		   state == WPA_ASSOCIATED) {
-+#ifdef MULTICALL
-+		if (wpa_s->hostapd)
-+			hostapd_stop(wpa_s);
-+#endif
- 		wpa_s->new_connection = 1;
- 		wpa_drv_set_operstate(wpa_s, 0);
- #ifndef IEEE8021X_EAPOL
-@@ -2853,6 +2910,21 @@ static int wpa_supplicant_init_iface(str
- 		os_strlcpy(wpa_s->bridge_ifname, iface->bridge_ifname,
- 			   sizeof(wpa_s->bridge_ifname));
- 	}
-+#ifdef MULTICALL
-+	if (iface->hostapd_ctrl) {
-+		char *cmd = "DOWN";
-+		char buf[256];
-+		int len = sizeof(buf);
-+
-+		wpa_s->hostapd = wpa_ctrl_open(iface->hostapd_ctrl);
-+		if (!wpa_s->hostapd) {
-+			wpa_printf(MSG_ERROR, "\nFailed to connect to hostapd\n");
-+			return -1;
-+		}
-+		if (hostapd_stop(wpa_s) < 0)
-+			return -1;
-+	}
-+#endif
- 
- 	/* RSNA Supplicant Key Management - INITIALIZE */
- 	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
---- a/wpa_supplicant/bss.c
-+++ b/wpa_supplicant/bss.c
-@@ -11,6 +11,7 @@
- #include "utils/common.h"
- #include "utils/eloop.h"
- #include "common/ieee802_11_defs.h"
-+#include "common/ieee802_11_common.h"
- #include "drivers/driver.h"
- #include "wpa_supplicant_i.h"
- #include "config.h"
-@@ -245,6 +246,9 @@ static void calculate_update_time(const 
- static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src,
- 			     struct os_time *fetch_time)
- {
-+	struct ieee80211_ht_capabilities *capab;
-+	struct ieee802_11_elems elems;
-+
- 	dst->flags = src->flags;
- 	os_memcpy(dst->bssid, src->bssid, ETH_ALEN);
- 	dst->freq = src->freq;
-@@ -255,6 +259,12 @@ static void wpa_bss_copy_res(struct wpa_
- 	dst->level = src->level;
- 	dst->tsf = src->tsf;
- 
-+	memset(&elems, 0, sizeof(elems));
-+	ieee802_11_parse_elems((u8 *) (src + 1), src->ie_len, &elems, 0);
-+	capab = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
-+	if (capab)
-+		dst->ht_capab = le_to_host16(capab->ht_capabilities_info);
-+
- 	calculate_update_time(fetch_time, src->age, &dst->last_update);
- }
- 
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -25,7 +25,7 @@ static void usage(void)
- 	       "usage:\n"
- 	       "  wpa_supplicant [-BddhKLqqstuvW] [-P<pid file>] "
- 	       "[-g<global ctrl>] \\\n"
--	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] "
-+	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] [-H<hostapd path>]"
- 	       "[-p<driver_param>] \\\n"
- 	       "        [-b<br_ifname>] [-f<debug file>] [-e<entropy file>] "
- 	       "\\\n"
-@@ -67,6 +67,7 @@ static void usage(void)
- #endif /* CONFIG_DEBUG_LINUX_TRACING */
- 	printf("  -t = include timestamp in debug messages\n"
- 	       "  -h = show this help text\n"
-+		   "  -H = connect to a hostapd instance to manage state changes\n"
- 	       "  -L = show license (BSD)\n"
- 	       "  -o = override driver parameter for new interfaces\n"
- 	       "  -O = override ctrl_interface parameter for new interfaces\n"
-@@ -155,7 +156,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:hi:KLNo:O:p:P:qsTtuvW");
-+			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuvW");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -199,6 +200,9 @@ int main(int argc, char *argv[])
- 			usage();
- 			exitcode = 0;
- 			goto out;
-+		case 'H':
-+			iface->hostapd_ctrl = optarg;
-+			break;
- 		case 'i':
- 			iface->ifname = optarg;
- 			break;
---- a/wpa_supplicant/bss.h
-+++ b/wpa_supplicant/bss.h
-@@ -69,6 +69,8 @@ struct wpa_bss {
- 	u8 ssid[32];
- 	/** Length of SSID */
- 	size_t ssid_len;
-+	/** HT caapbilities */
-+	u16 ht_capab;
- 	/** Frequency of the channel in MHz (e.g., 2412 = channel 1) */
- 	int freq;
- 	/** Beacon interval in TUs (host byte order) */
diff --git a/package/hostapd/patches/460-disable_ctrl_iface_mib.patch b/package/hostapd/patches/460-disable_ctrl_iface_mib.patch
deleted file mode 100644
index a51ade8..0000000
--- a/package/hostapd/patches/460-disable_ctrl_iface_mib.patch
+++ /dev/null
@@ -1,168 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -136,6 +136,9 @@ endif
- ifdef CONFIG_NO_CTRL_IFACE
- CFLAGS += -DCONFIG_NO_CTRL_IFACE
- else
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ctrl_iface.o
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -937,6 +937,7 @@ static void hostapd_ctrl_iface_receive(i
- 	} else if (os_strncmp(buf, "RELOG", 5) == 0) {
- 		if (wpa_debug_reopen_file() < 0)
- 			reply_len = -1;
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -966,10 +967,12 @@ static void hostapd_ctrl_iface_receive(i
- 				reply_len += res;
- 		}
- #endif /* CONFIG_NO_RADIUS */
-+#endif
- 	} else if (os_strcmp(buf, "DOWN") == 0) {
- 		hostapd_ctrl_iface_set_down(hapd);
- 	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
- 		hostapd_ctrl_iface_update(hapd, buf + 7);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
- 							 reply_size);
-@@ -979,6 +982,7 @@ static void hostapd_ctrl_iface_receive(i
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
- 							reply_size);
-+#endif
- 	} else if (os_strcmp(buf, "ATTACH") == 0) {
- 		if (hostapd_ctrl_iface_attach(hapd, &from, fromlen))
- 			reply_len = -1;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -758,6 +758,9 @@ ifdef CONFIG_WNM
- OBJS += ../src/ap/wnm_ap.o
- endif
- ifdef CONFIG_CTRL_IFACE
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
- 
---- a/wpa_supplicant/ctrl_iface.c
-+++ b/wpa_supplicant/ctrl_iface.c
-@@ -5051,6 +5051,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			reply_len = -1;
- 	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
- 		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -5062,6 +5063,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			else
- 				reply_len += res;
- 		}
-+#endif
- 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
- 		reply_len = wpa_supplicant_ctrl_iface_status(
- 			wpa_s, buf + 6, reply, reply_size);
-@@ -5465,6 +5467,7 @@ char * wpa_supplicant_ctrl_iface_process
- 		reply_len = wpa_supplicant_ctrl_iface_bss(
- 			wpa_s, buf + 4, reply, reply_size);
- #ifdef CONFIG_AP
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
- 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
-@@ -5473,6 +5476,7 @@ char * wpa_supplicant_ctrl_iface_process
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
- 						   reply_size);
-+#endif
- 	} else if (os_strncmp(buf, "DEAUTHENTICATE ", 15) == 0) {
- 		if (ap_ctrl_iface_sta_deauthenticate(wpa_s, buf + 15))
- 			reply_len = -1;
---- a/src/ap/ctrl_iface_ap.c
-+++ b/src/ap/ctrl_iface_ap.c
-@@ -20,6 +20,7 @@
- #include "ctrl_iface_ap.h"
- #include "ap_drv_ops.h"
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- static int hostapd_get_sta_conn_time(struct sta_info *sta,
- 				     char *buf, size_t buflen)
-@@ -129,6 +130,7 @@ int hostapd_ctrl_iface_sta_next(struct h
- 	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
- }
- 
-+#endif
- 
- #ifdef CONFIG_P2P_MANAGER
- static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
-@@ -303,3 +305,4 @@ int hostapd_ctrl_iface_disassociate(stru
- 
- 	return 0;
- }
-+
---- a/src/ap/ieee802_1x.c
-+++ b/src/ap/ieee802_1x.c
-@@ -2048,6 +2048,7 @@ static const char * bool_txt(Boolean boo
- 	return bool ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
- {
-@@ -2200,6 +2201,7 @@ int ieee802_1x_get_mib_sta(struct hostap
- 	return len;
- }
- 
-+#endif
- 
- static void ieee802_1x_finished(struct hostapd_data *hapd,
- 				struct sta_info *sta, int success)
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -2687,6 +2687,7 @@ static const char * wpa_bool_txt(int boo
- 	return bool ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
-@@ -2831,7 +2832,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
- 
- 	return len;
- }
--
-+#endif
- 
- void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
- {
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -1848,6 +1848,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
- }
- 
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
-+
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
- ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
-@@ -1931,6 +1933,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
- 
- 	return (int) len;
- }
-+#endif
- #endif /* CONFIG_CTRL_IFACE */
- 
- 
diff --git a/package/hostapd/patches/470-wpa_ie_cap_workaround.patch b/package/hostapd/patches/470-wpa_ie_cap_workaround.patch
deleted file mode 100644
index 974ec3d..0000000
--- a/package/hostapd/patches/470-wpa_ie_cap_workaround.patch
+++ /dev/null
@@ -1,56 +0,0 @@
---- a/src/common/wpa_common.c
-+++ b/src/common/wpa_common.c
-@@ -965,6 +965,31 @@ const char * wpa_key_mgmt_txt(int key_mg
- }
- 
- 
-+static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
-+				 size_t rsn_ie_len)
-+{
-+	int pos, count;
-+
-+	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
-+	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
-+		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
-+}
-+
-+
- int wpa_compare_rsn_ie(int ft_initial_assoc,
- 		       const u8 *ie1, size_t ie1len,
- 		       const u8 *ie2, size_t ie2len)
-@@ -972,8 +997,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
- 	if (ie1 == NULL || ie2 == NULL)
- 		return -1;
- 
--	if (ie1len == ie2len && os_memcmp(ie1, ie2, ie1len) == 0)
--		return 0; /* identical IEs */
-+	if (ie1len == ie2len) {
-+		u8 *ie_tmp;
-+
-+		if (os_memcmp(ie1, ie2, ie1len) == 0)
-+			return 0; /* identical IEs */
-+
-+		ie_tmp = alloca(ie1len);
-+		memcpy(ie_tmp, ie1, ie1len);
-+		wpa_fixup_wpa_ie_rsn(ie_tmp, ie2, ie1len);
-+
-+		if (os_memcmp(ie_tmp, ie2, ie1len) == 0)
-+			return 0; /* only mismatch in RSN capabilties */
-+	}
- 
- #ifdef CONFIG_IEEE80211R
- 	if (ft_initial_assoc) {
diff --git a/package/hostapd/patches/480-terminate_on_setup_failure.patch b/package/hostapd/patches/480-terminate_on_setup_failure.patch
deleted file mode 100644
index 3f8a778..0000000
--- a/package/hostapd/patches/480-terminate_on_setup_failure.patch
+++ /dev/null
@@ -1,81 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -911,11 +911,8 @@ int hostapd_setup_interface_complete(str
- 	size_t j;
- 	u8 *prev_addr;
- 
--	if (err) {
--		wpa_printf(MSG_ERROR, "Interface initialization failed");
--		eloop_terminate();
--		return -1;
--	}
-+	if (err)
-+		goto error;
- 
- 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
- 	if (hapd->iconf->channel) {
-@@ -935,7 +932,7 @@ int hostapd_setup_interface_complete(str
- 				     hapd->iconf->vht_oper_centr_freq_seg1_idx)) {
- 			wpa_printf(MSG_ERROR, "Could not set channel for "
- 				   "kernel driver");
--			return -1;
-+			goto error;
- 		}
- 	}
- 
-@@ -946,7 +943,7 @@ int hostapd_setup_interface_complete(str
- 			hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,
- 				       HOSTAPD_LEVEL_WARNING,
- 				       "Failed to prepare rates table.");
--			return -1;
-+			goto error;
- 		}
- 	}
- 
-@@ -954,14 +951,14 @@ int hostapd_setup_interface_complete(str
- 	    hostapd_set_rts(hapd, hapd->iconf->rts_threshold)) {
- 		wpa_printf(MSG_ERROR, "Could not set RTS threshold for "
- 			   "kernel driver");
--		return -1;
-+		goto error;
- 	}
- 
- 	if (hapd->iconf->fragm_threshold > -1 &&
- 	    hostapd_set_frag(hapd, hapd->iconf->fragm_threshold)) {
- 		wpa_printf(MSG_ERROR, "Could not set fragmentation threshold "
- 			   "for kernel driver");
--		return -1;
-+		goto error;
- 	}
- 
- 	prev_addr = hapd->own_addr;
-@@ -971,7 +968,7 @@ int hostapd_setup_interface_complete(str
- 		if (j)
- 			os_memcpy(hapd->own_addr, prev_addr, ETH_ALEN);
- 		if (hostapd_setup_bss(hapd, j == 0))
--			return -1;
-+			goto error;
- 		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0)
- 			prev_addr = hapd->own_addr;
- 	}
-@@ -983,7 +980,7 @@ int hostapd_setup_interface_complete(str
- 	if (hostapd_driver_commit(hapd) < 0) {
- 		wpa_printf(MSG_ERROR, "%s: Failed to commit driver "
- 			   "configuration", __func__);
--		return -1;
-+		goto error;
- 	}
- 
- 	/*
-@@ -1004,6 +1001,11 @@ int hostapd_setup_interface_complete(str
- 		   iface->bss[0]->conf->iface);
- 
- 	return 0;
-+
-+error:
-+	wpa_printf(MSG_ERROR, "Interface initialization failed");
-+	eloop_terminate();
-+	return -1;
- }
- 
- 
diff --git a/package/hostapd/patches/500-random_pool_add_kernel.patch b/package/hostapd/patches/500-random_pool_add_kernel.patch
deleted file mode 100644
index ccecb22..0000000
--- a/package/hostapd/patches/500-random_pool_add_kernel.patch
+++ /dev/null
@@ -1,177 +0,0 @@
---- a/src/crypto/random.c
-+++ b/src/crypto/random.c
-@@ -25,6 +25,7 @@
- #include "utils/includes.h"
- #ifdef __linux__
- #include <fcntl.h>
-+#include <sys/stat.h>
- #endif /* __linux__ */
- 
- #include "utils/common.h"
-@@ -33,6 +34,8 @@
- #include "sha1.h"
- #include "random.h"
- 
-+#define RANDOM_STAMPFILE "/var/run/.random_available"
-+
- #define POOL_WORDS 32
- #define POOL_WORDS_MASK (POOL_WORDS - 1)
- #define POOL_TAP1 26
-@@ -43,6 +46,8 @@
- #define EXTRACT_LEN 16
- #define MIN_READY_MARK 2
- 
-+#ifndef CONFIG_NO_RANDOM_POOL
-+
- static u32 pool[POOL_WORDS];
- static unsigned int input_rotate = 0;
- static unsigned int pool_pos = 0;
-@@ -123,7 +128,7 @@ static void random_extract(u8 *out)
- }
- 
- 
--void random_add_randomness(const void *buf, size_t len)
-+static void random_pool_add_randomness(const void *buf, size_t len)
- {
- 	struct os_time t;
- 	static unsigned int count = 0;
-@@ -213,16 +218,22 @@ int random_get_bytes(void *buf, size_t l
- int random_pool_ready(void)
- {
- #ifdef __linux__
-+	struct stat st;
- 	int fd;
- 	ssize_t res;
- 
-+	if (stat(RANDOM_STAMPFILE, &st) == 0)
-+		return 1;
-+
- 	/*
- 	 * Make sure that there is reasonable entropy available before allowing
- 	 * some key derivation operations to proceed.
- 	 */
- 
--	if (dummy_key_avail == sizeof(dummy_key))
-+	if (dummy_key_avail == sizeof(dummy_key)) {
-+		random_mark_pool_ready();
- 		return 1; /* Already initialized - good to continue */
-+	}
- 
- 	/*
- 	 * Try to fetch some more data from the kernel high quality
-@@ -257,6 +268,7 @@ int random_pool_ready(void)
- 	if (dummy_key_avail == sizeof(dummy_key)) {
- 		if (own_pool_ready < MIN_READY_MARK)
- 			own_pool_ready = MIN_READY_MARK;
-+		random_mark_pool_ready();
- 		random_write_entropy();
- 		return 1;
- 	}
-@@ -269,6 +281,7 @@ int random_pool_ready(void)
- 	    total_collected + 10 * own_pool_ready > MIN_COLLECT_ENTROPY) {
- 		wpa_printf(MSG_INFO, "random: Allow operation to proceed "
- 			   "based on internal entropy");
-+		random_mark_pool_ready();
- 		return 1;
- 	}
- 
-@@ -284,10 +297,16 @@ int random_pool_ready(void)
- 
- void random_mark_pool_ready(void)
- {
-+	int fd;
-+
- 	own_pool_ready++;
- 	wpa_printf(MSG_DEBUG, "random: Mark internal entropy pool to be "
- 		   "ready (count=%u/%u)", own_pool_ready, MIN_READY_MARK);
- 	random_write_entropy();
-+
-+	fd = open(RANDOM_STAMPFILE, O_CREAT | O_WRONLY | O_EXCL | O_NOFOLLOW, 0600);
-+	if (fd >= 0)
-+		close(fd);
- }
- 
- 
-@@ -444,3 +463,22 @@ void random_deinit(void)
- 	os_free(random_entropy_file);
- 	random_entropy_file = NULL;
- }
-+
-+#endif /* CONFIG_NO_RANDOM_POOL */
-+
-+
-+void random_add_randomness(const void *buf, size_t len)
-+{
-+#ifdef __linux__
-+	int fd;
-+
-+	fd = open("/dev/random", O_RDWR);
-+	if (fd >= 0) {
-+		write(fd, buf, len);
-+		close(fd);
-+	}
-+#endif
-+#ifndef CONFIG_NO_RANDOM_POOL
-+	random_pool_add_randomness(buf, len);
-+#endif
-+}
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -1226,9 +1226,8 @@ endif
- 
- ifdef CONFIG_NO_RANDOM_POOL
- CFLAGS += -DCONFIG_NO_RANDOM_POOL
--else
--OBJS += ../src/crypto/random.o
- endif
-+OBJS += ../src/crypto/random.o
- 
- ifdef CONFIG_CTRL_IFACE
- ifeq ($(CONFIG_CTRL_IFACE), y)
---- a/wpa_supplicant/Android.mk
-+++ b/wpa_supplicant/Android.mk
-@@ -1191,9 +1191,8 @@ endif
- 
- ifdef CONFIG_NO_RANDOM_POOL
- L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
--else
--OBJS += src/crypto/random.c
- endif
-+OBJS += src/crypto/random.c
- 
- ifdef CONFIG_CTRL_IFACE
- ifeq ($(CONFIG_CTRL_IFACE), y)
---- a/hostapd/Android.mk
-+++ b/hostapd/Android.mk
-@@ -775,12 +775,12 @@ endif
- ifdef CONFIG_NO_RANDOM_POOL
- L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
- else
--OBJS += src/crypto/random.c
--HOBJS += src/crypto/random.c
- HOBJS += src/utils/eloop.c
- HOBJS += $(SHA1OBJS)
- HOBJS += src/crypto/md5.c
- endif
-+OBJS += src/crypto/random.c
-+HOBJS += src/crypto/random.c
- 
- ifdef CONFIG_RADIUS_SERVER
- L_CFLAGS += -DRADIUS_SERVER
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -748,12 +748,12 @@ endif
- ifdef CONFIG_NO_RANDOM_POOL
- CFLAGS += -DCONFIG_NO_RANDOM_POOL
- else
--OBJS += ../src/crypto/random.o
--HOBJS += ../src/crypto/random.o
- HOBJS += ../src/utils/eloop.o
- HOBJS += $(SHA1OBJS)
- HOBJS += ../src/crypto/md5.o
- endif
-+OBJS += ../src/crypto/random.o
-+HOBJS += ../src/crypto/random.o
- 
- ifdef CONFIG_RADIUS_SERVER
- CFLAGS += -DRADIUS_SERVER
diff --git a/package/hostapd/patches/510-bring_down_interface.patch b/package/hostapd/patches/510-bring_down_interface.patch
deleted file mode 100644
index e92c122..0000000
--- a/package/hostapd/patches/510-bring_down_interface.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7616,8 +7616,6 @@ static int wpa_driver_nl80211_set_mode(s
- 			ret = nl80211_set_mode(drv, drv->ifindex, nlmode);
- 			if (ret == -EACCES)
- 				break;
--			res = linux_set_iface_flags(drv->global->ioctl_sock,
--						    bss->ifname, 1);
- 			if (res && !ret)
- 				ret = -1;
- 			else if (ret != -EBUSY)
-@@ -7633,6 +7631,7 @@ static int wpa_driver_nl80211_set_mode(s
- 			   "interface is down");
- 		drv->nlmode = nlmode;
- 		drv->ignore_if_down_event = 1;
-+		linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
- 	}
- 
- done:
diff --git a/package/hostapd/patches/520-fix_wps_pin_crash.patch b/package/hostapd/patches/520-fix_wps_pin_crash.patch
deleted file mode 100644
index 80d562c..0000000
--- a/package/hostapd/patches/520-fix_wps_pin_crash.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -479,6 +479,9 @@ static int hostapd_ctrl_iface_wps_ap_pin
- 	char *pos;
- 	const char *pin_txt;
- 
-+	if (!hapd->wps)
-+		return -1;
-+
- 	pos = os_strchr(txt, ' ');
- 	if (pos)
- 		*pos++ = '\0';
diff --git a/package/hostapd/patches/530-wps_single_auth_enc_type.patch b/package/hostapd/patches/530-wps_single_auth_enc_type.patch
deleted file mode 100644
index 6f4a655..0000000
--- a/package/hostapd/patches/530-wps_single_auth_enc_type.patch
+++ /dev/null
@@ -1,25 +0,0 @@
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -989,11 +989,9 @@ int hostapd_init_wps(struct hostapd_data
- 
- 		if (conf->rsn_pairwise & WPA_CIPHER_CCMP)
- 			wps->encr_types |= WPS_ENCR_AES;
--		if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
-+		else if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
- 			wps->encr_types |= WPS_ENCR_TKIP;
--	}
--
--	if (conf->wpa & WPA_PROTO_WPA) {
-+	} else if (conf->wpa & WPA_PROTO_WPA) {
- 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK)
- 			wps->auth_types |= WPS_AUTH_WPAPSK;
- 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X)
-@@ -1001,7 +999,7 @@ int hostapd_init_wps(struct hostapd_data
- 
- 		if (conf->wpa_pairwise & WPA_CIPHER_CCMP)
- 			wps->encr_types |= WPS_ENCR_AES;
--		if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
-+		else if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
- 			wps->encr_types |= WPS_ENCR_TKIP;
- 	}
- 
diff --git a/package/hostapd/patches/540-dynamic_20_40_mhz.patch b/package/hostapd/patches/540-dynamic_20_40_mhz.patch
deleted file mode 100644
index a7b39db..0000000
--- a/package/hostapd/patches/540-dynamic_20_40_mhz.patch
+++ /dev/null
@@ -1,206 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2474,6 +2474,10 @@ static int hostapd_config_fill(struct ho
- 					   "ht_capab", line);
- 				errors++;
- 			}
-+		} else if (os_strcmp(buf, "dynamic_ht40") == 0) {
-+			conf->dynamic_ht40 = atoi(pos);
-+			if (conf->dynamic_ht40 == 1)
-+				conf->dynamic_ht40 = 1500;
- 		} else if (os_strcmp(buf, "require_ht") == 0) {
- 			conf->require_ht = atoi(pos);
- #endif /* CONFIG_IEEE80211N */
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -515,6 +515,7 @@ struct hostapd_config {
- 	int ieee80211n;
- 	int secondary_channel;
- 	int require_ht;
-+	int dynamic_ht40;
- 	u32 vht_capab;
- 	int ieee80211ac;
- 	int require_vht;
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -22,6 +22,7 @@
- #include "beacon.h"
- #include "iapp.h"
- #include "ieee802_1x.h"
-+#include "ieee802_11.h"
- #include "ieee802_11_auth.h"
- #include "vlan_init.h"
- #include "wpa_auth.h"
-@@ -348,6 +349,7 @@ static void hostapd_cleanup_iface_pre(st
- 
- static void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
- {
-+	hostapd_deinit_ht(iface);
- 	hostapd_free_hw_features(iface->hw_features, iface->num_hw_features);
- 	iface->hw_features = NULL;
- 	os_free(iface->current_rates);
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -269,6 +269,9 @@ struct hostapd_iface {
- 	/* Overlapping BSS information */
- 	int olbc_ht;
- 
-+	int force_20mhz;
-+	struct os_time last_20mhz_trigger;
-+
- 	u16 ht_op_mode;
- 	void (*scan_cb)(struct hostapd_iface *iface);
- };
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -1484,6 +1484,9 @@ static void handle_beacon(struct hostapd
- 					     sizeof(mgmt->u.beacon)), &elems,
- 				      0);
- 
-+	if (!elems.ht_capabilities)
-+		hostapd_trigger_20mhz(hapd->iface);
-+
- 	ap_list_process_beacon(hapd->iface, mgmt, &elems, fi);
- }
- 
---- a/src/ap/ieee802_11.h
-+++ b/src/ap/ieee802_11.h
-@@ -81,4 +81,17 @@ int hostapd_update_time_adv(struct hosta
- void hostapd_client_poll_ok(struct hostapd_data *hapd, const u8 *addr);
- u8 * hostapd_eid_bss_max_idle_period(struct hostapd_data *hapd, u8 *eid);
- 
-+#ifdef CONFIG_IEEE80211N
-+void hostapd_trigger_20mhz(struct hostapd_iface *iface);
-+void hostapd_deinit_ht(struct hostapd_iface *iface);
-+
-+#else
-+static inline void hostapd_deinit_ht(struct hostapd_iface *iface)
-+{
-+}
-+static inline void hostapd_trigger_20mhz(struct hostapd_iface *iface)
-+{
-+}
-+#endif /* CONFIG_IEEE80211N */
-+
- #endif /* IEEE802_11_H */
---- a/src/ap/ieee802_11_ht.c
-+++ b/src/ap/ieee802_11_ht.c
-@@ -20,9 +20,11 @@
- #include "drivers/driver.h"
- #include "hostapd.h"
- #include "ap_config.h"
-+#include "ap_drv_ops.h"
- #include "sta_info.h"
- #include "beacon.h"
- #include "ieee802_11.h"
-+#include "utils/eloop.h"
- 
- 
- u8 * hostapd_eid_ht_capabilities(struct hostapd_data *hapd, u8 *eid)
-@@ -70,12 +72,15 @@ u8 * hostapd_eid_ht_operation(struct hos
- 
- 	oper->control_chan = hapd->iconf->channel;
- 	oper->operation_mode = host_to_le16(hapd->iface->ht_op_mode);
--	if (hapd->iconf->secondary_channel == 1)
--		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
--			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
--	if (hapd->iconf->secondary_channel == -1)
--		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
--			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+
-+	if (!hapd->iface->force_20mhz) {
-+		if (hapd->iconf->secondary_channel == 1)
-+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
-+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+		if (hapd->iconf->secondary_channel == -1)
-+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
-+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+	}
- 
- 	pos += sizeof(*oper);
- 
-@@ -270,3 +275,84 @@ void hostapd_get_ht_capab(struct hostapd
- 
- 	neg_ht_cap->ht_capabilities_info = host_to_le16(cap);
- }
-+
-+static void hostapd_set_force_20mhz(struct hostapd_iface *iface);
-+
-+static void hostapd_restore_40mhz(void *eloop_data, void *user_ctx)
-+{
-+	struct hostapd_iface *iface = eloop_data;
-+	struct os_time time;
-+	int timeout;
-+
-+	if (!iface->last_20mhz_trigger.sec)
-+	    return;
-+
-+	os_get_time(&time);
-+	timeout = iface->last_20mhz_trigger.sec + iface->conf->dynamic_ht40 -
-+		  time.sec;
-+
-+	if (timeout > 0) {
-+		eloop_register_timeout(timeout, 0, hostapd_restore_40mhz,
-+				       iface, NULL);
-+		return;
-+	}
-+
-+	iface->last_20mhz_trigger.sec = 0;
-+	iface->last_20mhz_trigger.usec = 0;
-+
-+	iface->force_20mhz = 0;
-+	hostapd_set_force_20mhz(iface);
-+}
-+
-+static void hostapd_set_force_20mhz(struct hostapd_iface *iface)
-+{
-+	int secondary_channel;
-+	int i;
-+
-+	ieee802_11_set_beacons(iface);
-+
-+	for (i = 0; i < iface->num_bss; i++) {
-+		struct hostapd_data *hapd = iface->bss[i];
-+
-+		if (iface->force_20mhz)
-+			secondary_channel = 0;
-+		else
-+			secondary_channel = hapd->iconf->secondary_channel;
-+
-+		if (hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
-+				     hapd->iconf->channel,
-+				     hapd->iconf->ieee80211n,
-+				     hapd->iconf->ieee80211ac,
-+				     secondary_channel,
-+				     hapd->iconf->vht_oper_chwidth,
-+				     hapd->iconf->vht_oper_centr_freq_seg0_idx,
-+				     hapd->iconf->vht_oper_centr_freq_seg1_idx)) {
-+			wpa_printf(MSG_ERROR, "Could not set channel for "
-+				   "kernel driver");
-+		}
-+	}
-+}
-+
-+void hostapd_deinit_ht(struct hostapd_iface *iface)
-+{
-+	eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
-+}
-+
-+void hostapd_trigger_20mhz(struct hostapd_iface *iface)
-+{
-+	if (!iface->conf->dynamic_ht40)
-+		return;
-+
-+	if (!iface->force_20mhz) {
-+		iface->force_20mhz = 1;
-+		hostapd_set_force_20mhz(iface);
-+	}
-+
-+	if (!iface->last_20mhz_trigger.sec) {
-+		eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
-+		eloop_register_timeout(iface->conf->dynamic_ht40, 0,
-+				       hostapd_restore_40mhz, iface, NULL);
-+	}
-+
-+	os_get_time(&iface->last_20mhz_trigger);
-+}
diff --git a/package/hostapd/patches/550-limit_debug_messages.patch b/package/hostapd/patches/550-limit_debug_messages.patch
deleted file mode 100644
index 659e980..0000000
--- a/package/hostapd/patches/550-limit_debug_messages.patch
+++ /dev/null
@@ -1,213 +0,0 @@
---- a/src/utils/wpa_debug.c
-+++ b/src/utils/wpa_debug.c
-@@ -201,7 +201,7 @@ void wpa_debug_close_linux_tracing(void)
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_printf(int level, const char *fmt, ...)
-+void _wpa_printf(int level, const char *fmt, ...)
- {
- 	va_list ap;
- 
-@@ -248,8 +248,8 @@ void wpa_printf(int level, const char *f
- }
- 
- 
--static void _wpa_hexdump(int level, const char *title, const u8 *buf,
--			 size_t len, int show)
-+void _wpa_hexdump(int level, const char *title, const u8 *buf,
-+		  size_t len, int show)
- {
- 	size_t i;
- 
-@@ -375,20 +375,9 @@ static void _wpa_hexdump(int level, cons
- #endif /* CONFIG_ANDROID_LOG */
- }
- 
--void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump(level, title, buf, len, 1);
--}
--
--
--void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
--}
- 
--
--static void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
--			       size_t len, int show)
-+void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
-+			size_t len, int show)
- {
- 	size_t i, llen;
- 	const u8 *pos = buf;
-@@ -495,19 +484,6 @@ static void _wpa_hexdump_ascii(int level
- }
- 
- 
--void wpa_hexdump_ascii(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump_ascii(level, title, buf, len, 1);
--}
--
--
--void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
--			   size_t len)
--{
--	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
--}
--
--
- #ifdef CONFIG_DEBUG_FILE
- static char *last_path = NULL;
- #endif /* CONFIG_DEBUG_FILE */
-@@ -591,7 +567,7 @@ void wpa_msg_register_ifname_cb(wpa_msg_
- }
- 
- 
--void wpa_msg(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg(void *ctx, int level, const char *fmt, ...)
- {
- 	va_list ap;
- 	char *buf;
-@@ -625,7 +601,7 @@ void wpa_msg(void *ctx, int level, const
- }
- 
- 
--void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
- {
- 	va_list ap;
- 	char *buf;
---- a/src/utils/wpa_debug.h
-+++ b/src/utils/wpa_debug.h
-@@ -43,6 +43,17 @@ int wpa_debug_open_file(const char *path
- int wpa_debug_reopen_file(void);
- void wpa_debug_close_file(void);
- 
-+/* internal */
-+void _wpa_hexdump(int level, const char *title, const u8 *buf,
-+		  size_t len, int show);
-+void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
-+			size_t len, int show);
-+extern int wpa_debug_show_keys;
-+
-+#ifndef CONFIG_MSG_MIN_PRIORITY
-+#define CONFIG_MSG_MIN_PRIORITY 0
-+#endif
-+
- /**
-  * wpa_debug_printf_timestamp - Print timestamp for debug output
-  *
-@@ -63,9 +74,15 @@ void wpa_debug_print_timestamp(void);
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_printf(int level, const char *fmt, ...)
-+void _wpa_printf(int level, const char *fmt, ...)
- PRINTF_FORMAT(2, 3);
- 
-+#define wpa_printf(level, ...)						\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_printf(level, __VA_ARGS__);		\
-+	} while(0)
-+
- /**
-  * wpa_hexdump - conditional hex dump
-  * @level: priority level (MSG_*) of the message
-@@ -77,7 +94,13 @@ PRINTF_FORMAT(2, 3);
-  * output may be directed to stdout, stderr, and/or syslog based on
-  * configuration. The contents of buf is printed out has hex dump.
-  */
--void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len);
-+static inline void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump(level, title, buf, len, 1);
-+}
- 
- static inline void wpa_hexdump_buf(int level, const char *title,
- 				   const struct wpabuf *buf)
-@@ -99,7 +122,13 @@ static inline void wpa_hexdump_buf(int l
-  * like wpa_hexdump(), but by default, does not include secret keys (passwords,
-  * etc.) in debug output.
-  */
--void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len);
-+static inline void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
-+}
- 
- static inline void wpa_hexdump_buf_key(int level, const char *title,
- 				       const struct wpabuf *buf)
-@@ -121,8 +150,14 @@ static inline void wpa_hexdump_buf_key(i
-  * the hex numbers and ASCII characters (for printable range) are shown. 16
-  * bytes per line will be shown.
-  */
--void wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
--		       size_t len);
-+static inline void wpa_hexdump_ascii(int level, const char *title,
-+				     const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump_ascii(level, title, buf, len, 1);
-+}
- 
- /**
-  * wpa_hexdump_ascii_key - conditional hex dump, hide keys
-@@ -138,8 +173,14 @@ void wpa_hexdump_ascii(int level, const 
-  * bytes per line will be shown. This works like wpa_hexdump_ascii(), but by
-  * default, does not include secret keys (passwords, etc.) in debug output.
-  */
--void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
--			   size_t len);
-+static inline void wpa_hexdump_ascii_key(int level, const char *title,
-+					 const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
-+}
- 
- /*
-  * wpa_dbg() behaves like wpa_msg(), but it can be removed from build to reduce
-@@ -172,7 +213,12 @@ void wpa_hexdump_ascii_key(int level, co
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-+void _wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-+#define wpa_msg(ctx, level, ...)					\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_msg(ctx, level, __VA_ARGS__);		\
-+	} while(0)
- 
- /**
-  * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
-@@ -186,8 +232,13 @@ void wpa_msg(void *ctx, int level, const
-  * attached ctrl_iface monitors. In other words, it can be used for frequent
-  * events that do not need to be sent to syslog.
-  */
--void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
- PRINTF_FORMAT(3, 4);
-+#define wpa_msg_ctrl(ctx, level, ...)					\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_msg_ctrl(ctx, level, __VA_ARGS__);		\
-+	} while(0)
- 
- typedef void (*wpa_msg_cb_func)(void *ctx, int level, const char *txt,
- 				size_t len);
diff --git a/package/hostapd/patches/560-indicate-features.patch b/package/hostapd/patches/560-indicate-features.patch
deleted file mode 100644
index 9073bd4..0000000
--- a/package/hostapd/patches/560-indicate-features.patch
+++ /dev/null
@@ -1,82 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -14,6 +14,7 @@
- 
- #include "utils/common.h"
- #include "utils/eloop.h"
-+#include "utils/build_features.h"
- #include "crypto/random.h"
- #include "crypto/tls.h"
- #include "common/version.h"
-@@ -584,7 +585,7 @@ int main(int argc, char *argv[])
- 
- 	wpa_supplicant_event = hostapd_wpa_event;
- 	for (;;) {
--		c = getopt(argc, argv, "Bde:f:hKP:tvg:G:");
-+		c = getopt(argc, argv, "Bde:f:hKP:tg:G:v::");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -616,6 +617,8 @@ int main(int argc, char *argv[])
- 			wpa_debug_timestamp++;
- 			break;
- 		case 'v':
-+			if (optarg)
-+				exit(!has_feature(optarg));
- 			show_version();
- 			exit(1);
- 			break;
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -12,6 +12,7 @@
- #endif /* __linux__ */
- 
- #include "common.h"
-+#include "build_features.h"
- #include "wpa_supplicant_i.h"
- #include "driver_i.h"
- 
-@@ -156,7 +157,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuvW");
-+			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuv::W");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -248,8 +249,12 @@ int main(int argc, char *argv[])
- 			break;
- #endif /* CONFIG_DBUS */
- 		case 'v':
--			printf("%s\n", wpa_supplicant_version);
--			exitcode = 0;
-+			if (optarg) {
-+				exitcode = !has_feature(optarg);
-+			} else {
-+				printf("%s\n", wpa_supplicant_version);
-+				exitcode = 0;
-+			}
- 			goto out;
- 		case 'W':
- 			params.wait_for_monitor++;
---- /dev/null
-+++ b/src/utils/build_features.h
-@@ -0,0 +1,17 @@
-+#ifndef BUILD_FEATURES_H
-+#define BUILD_FEATURES_H
-+
-+static inline int has_feature(const char *feat)
-+{
-+#ifdef IEEE8021X_EAPOL
-+	if (!strcmp(feat, "eap"))
-+		return 1;
-+#endif
-+#ifdef IEEE80211N
-+	if (!strcmp(feat, "11n"))
-+		return 1;
-+#endif
-+	return 0;
-+}
-+
-+#endif /* BUILD_FEATURES_H */
diff --git a/package/hostapd/patches/570-genl_connect_debug.patch b/package/hostapd/patches/570-genl_connect_debug.patch
deleted file mode 100644
index 5f14048..0000000
--- a/package/hostapd/patches/570-genl_connect_debug.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -127,7 +127,7 @@ static struct nl_handle * nl_create_hand
- 	}
- 
- 	if (genl_connect(handle)) {
--		wpa_printf(MSG_ERROR, "nl80211: Failed to connect to generic "
-+		wpa_printf(MSG_DEBUG, "nl80211: Failed to connect to generic "
- 			   "netlink (%s)", dbg);
- 		nl80211_handle_destroy(handle);
- 		return NULL;
diff --git a/package/hostapd/patches/590-hostapd_cli_ifdef.patch b/package/hostapd/patches/590-hostapd_cli_ifdef.patch
deleted file mode 100644
index cbf1e48..0000000
--- a/package/hostapd/patches/590-hostapd_cli_ifdef.patch
+++ /dev/null
@@ -1,50 +0,0 @@
---- a/hostapd/hostapd_cli.c
-+++ b/hostapd/hostapd_cli.c
-@@ -67,7 +67,6 @@ static const char *commands_help =
- #ifdef CONFIG_IEEE80211W
- "   sa_query <addr>      send SA Query to a station\n"
- #endif /* CONFIG_IEEE80211W */
--#ifdef CONFIG_WPS
- "   wps_pin <uuid> <pin> [timeout] [addr]  add WPS Enrollee PIN\n"
- "   wps_check_pin <PIN>  verify PIN checksum\n"
- "   wps_pbc              indicate button pushed to initiate PBC\n"
-@@ -79,7 +78,6 @@ static const char *commands_help =
- #endif /* CONFIG_WPS_NFC */
- "   wps_ap_pin <cmd> [params..]  enable/disable AP PIN\n"
- "   wps_config <SSID> <auth> <encr> <key>  configure AP\n"
--#endif /* CONFIG_WPS */
- "   get_config           show current configuration\n"
- "   help                 show this usage help\n"
- "   interface [ifname]   show interfaces/select interface\n"
-@@ -340,7 +338,6 @@ static int hostapd_cli_cmd_sa_query(stru
- #endif /* CONFIG_IEEE80211W */
- 
- 
--#ifdef CONFIG_WPS
- static int hostapd_cli_cmd_wps_pin(struct wpa_ctrl *ctrl, int argc,
- 				   char *argv[])
- {
-@@ -559,7 +556,6 @@ static int hostapd_cli_cmd_wps_config(st
- 			 ssid_hex, argv[1]);
- 	return wpa_ctrl_command(ctrl, buf);
- }
--#endif /* CONFIG_WPS */
- 
- 
- static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
-@@ -805,7 +801,6 @@ static struct hostapd_cli_cmd hostapd_cl
- #ifdef CONFIG_IEEE80211W
- 	{ "sa_query", hostapd_cli_cmd_sa_query },
- #endif /* CONFIG_IEEE80211W */
--#ifdef CONFIG_WPS
- 	{ "wps_pin", hostapd_cli_cmd_wps_pin },
- 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin },
- 	{ "wps_pbc", hostapd_cli_cmd_wps_pbc },
-@@ -818,7 +813,6 @@ static struct hostapd_cli_cmd hostapd_cl
- #endif /* CONFIG_WPS_NFC */
- 	{ "wps_ap_pin", hostapd_cli_cmd_wps_ap_pin },
- 	{ "wps_config", hostapd_cli_cmd_wps_config },
--#endif /* CONFIG_WPS */
- 	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent },
- 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc },
- 	{ "get_config", hostapd_cli_cmd_get_config },
diff --git a/package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch b/package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch
deleted file mode 100644
index 3345e55..0000000
--- a/package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch
+++ /dev/null
@@ -1,209 +0,0 @@
-From 4bb69d15477e0f2b00e166845341dc933de47c58 Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Sun, 3 Jun 2012 18:22:56 +0200
-Subject: [PATCHv2 601/602] wpa_supplicant: add new config params to be used
- with the ibss join command
-
-Signed-hostap: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver.h            |    6 +++
- wpa_supplicant/config.c         |   96 +++++++++++++++++++++++++++++++++++++++
- wpa_supplicant/config_ssid.h    |    6 +++
- wpa_supplicant/wpa_supplicant.c |   23 +++++++---
- 4 files changed, 124 insertions(+), 7 deletions(-)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -19,6 +19,7 @@
- 
- #define WPA_SUPPLICANT_DRIVER_VERSION 4
- 
-+#include "drivers/nl80211_copy.h"
- #include "common/defs.h"
- 
- #define HOSTAPD_CHAN_DISABLED 0x00000001
-@@ -363,6 +364,11 @@ struct wpa_driver_associate_params {
- 	 */
- 	int freq;
- 
-+	int beacon_interval;
-+	int fixed_freq;
-+	unsigned char rates[NL80211_MAX_SUPP_RATES];
-+	int mcast_rate;
-+
- 	/**
- 	 * bg_scan_period - Background scan period in seconds, 0 to disable
- 	 * background scan, or -1 to indicate no change to default driver
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -14,6 +14,7 @@
- #include "rsn_supp/wpa.h"
- #include "eap_peer/eap.h"
- #include "p2p/p2p.h"
-+#include "drivers/nl80211_copy.h"
- #include "config.h"
- 
- 
-@@ -1376,6 +1377,97 @@ static char * wpa_config_write_p2p_clien
- 
- #endif /* CONFIG_P2P */
- 
-+static int wpa_config_parse_mcast_rate(const struct parse_data *data,
-+				       struct wpa_ssid *ssid, int line,
-+				       const char *value)
-+{
-+	ssid->mcast_rate = (int)(strtod(value, NULL) * 10);
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_mcast_rate(const struct parse_data *data,
-+					  struct wpa_ssid *ssid)
-+{
-+	char *value;
-+	int res;
-+
-+	if (!ssid->mcast_rate == 0)
-+		return NULL;
-+
-+	value = os_malloc(6); /* longest: 300.0 */
-+	if (value == NULL)
-+		return NULL;
-+	res = os_snprintf(value, 5, "%.1f", (double)ssid->mcast_rate / 10);
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
-+static int wpa_config_parse_rates(const struct parse_data *data,
-+				  struct wpa_ssid *ssid, int line,
-+				  const char *value)
-+{
-+	int i;
-+	char *pos, *r, *sptr, *end;
-+	double rate;
-+
-+	pos = (char *)value;
-+	r = strtok_r(pos, ",", &sptr);
-+	i = 0;
-+	while (pos && i < NL80211_MAX_SUPP_RATES) {
-+		rate = 0.0;
-+		if (r)
-+			rate = strtod(r, &end);
-+		ssid->rates[i] = rate * 2;
-+		if (*end != '\0' || rate * 2 != ssid->rates[i])
-+			return 1;
-+
-+		i++;
-+		r = strtok_r(NULL, ",", &sptr);
-+	}
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_rates(const struct parse_data *data,
-+				     struct wpa_ssid *ssid)
-+{
-+	char *value, *pos;
-+	int res, i;
-+
-+	if (ssid->rates[0] <= 0)
-+		return NULL;
-+
-+	value = os_malloc(6 * NL80211_MAX_SUPP_RATES + 1);
-+	if (value == NULL)
-+		return NULL;
-+	pos = value;
-+	for (i = 0; i < NL80211_MAX_SUPP_RATES - 1; i++) {
-+		res = os_snprintf(pos, 6, "%.1f,", (double)ssid->rates[i] / 2);
-+		if (res < 0) {
-+			os_free(value);
-+			return NULL;
-+		}
-+		pos += res;
-+	}
-+	res = os_snprintf(pos, 6, "%.1f",
-+			  (double)ssid->rates[NL80211_MAX_SUPP_RATES - 1] / 2);
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+
-+	value[6 * NL80211_MAX_SUPP_RATES] = '\0';
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
- /* Helper macros for network block parser */
- 
- #ifdef OFFSET
-@@ -1574,6 +1666,9 @@ static const struct parse_data ssid_fiel
- 	{ INT(ap_max_inactivity) },
- 	{ INT(dtim_period) },
- 	{ INT(beacon_int) },
-+	{ INT_RANGE(fixed_freq, 0, 1) },
-+	{ FUNC(rates) },
-+	{ FUNC(mcast_rate) },
- };
- 
- #undef OFFSET
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -11,6 +11,7 @@
- 
- #include "common/defs.h"
- #include "eap_peer/eap_config.h"
-+#include "drivers/nl80211_copy.h"
- 
- #define MAX_SSID_LEN 32
- 
-@@ -600,6 +601,10 @@ struct wpa_ssid {
- 	 * dereferences since it may not be updated in all cases.
- 	 */
- 	void *parent_cred;
-+
-+	int fixed_freq;
-+	unsigned char rates[NL80211_MAX_SUPP_RATES];
-+	double mcast_rate;
- };
- 
- #endif /* CONFIG_SSID_H */
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -1597,15 +1597,24 @@ void wpa_supplicant_associate(struct wpa
- 		params.ssid_len = ssid->ssid_len;
- 	}
- 
--	if (ssid->mode == WPAS_MODE_IBSS && ssid->bssid_set &&
--	    wpa_s->conf->ap_scan == 2) {
--		params.bssid = ssid->bssid;
--		params.fixed_bssid = 1;
-+	if (ssid->mode == WPAS_MODE_IBSS) {
-+		if (ssid->bssid_set && wpa_s->conf->ap_scan == 2) {
-+			params.bssid = ssid->bssid;
-+			params.fixed_bssid = 1;
-+		}
-+		if (ssid->frequency > 0 && params.freq == 0)
-+			/* Initial channel for IBSS */
-+			params.freq = ssid->frequency;
-+		params.fixed_freq = ssid->fixed_freq;
-+		params.beacon_interval = ssid->beacon_int;
-+		i = 0;
-+		while (i < NL80211_MAX_SUPP_RATES) {
-+			params.rates[i] = ssid->rates[i];
-+			i++;
-+		}
-+		params.mcast_rate = ssid->mcast_rate;
- 	}
- 
--	if (ssid->mode == WPAS_MODE_IBSS && ssid->frequency > 0 &&
--	    params.freq == 0)
--		params.freq = ssid->frequency; /* Initial channel for IBSS */
- 	params.wpa_ie = wpa_ie;
- 	params.wpa_ie_len = wpa_ie_len;
- 	params.pairwise_suite = cipher_pairwise;
diff --git a/package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch b/package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch
deleted file mode 100644
index 5a6eb5e..0000000
--- a/package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch
+++ /dev/null
@@ -1,59 +0,0 @@
-From ffc4445958a3ed4064f2e1bf73fa478a61c5cf7b Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Sun, 3 Jun 2012 18:42:25 +0200
-Subject: [PATCHv2 602/602] driver_nl80211: use new parameters during ibss join
-
-Signed-hostap: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver_nl80211.c |   33 ++++++++++++++++++++++++++++++++-
- 1 file changed, 32 insertions(+), 1 deletion(-)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7040,7 +7040,7 @@ static int wpa_driver_nl80211_ibss(struc
- 				   struct wpa_driver_associate_params *params)
- {
- 	struct nl_msg *msg;
--	int ret = -1;
-+	int ret = -1, i;
- 	int count = 0;
- 
- 	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
-@@ -7073,6 +7073,37 @@ retry:
- 	wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
- 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
- 
-+	if (params->fixed_freq) {
-+		wpa_printf(MSG_DEBUG, "  * fixed_freq");
-+		NLA_PUT_FLAG(msg, NL80211_ATTR_FREQ_FIXED);
-+	}
-+
-+	if (params->beacon_interval > 0) {
-+		wpa_printf(MSG_DEBUG, "  * beacon_interval=%d",
-+			   params->beacon_interval);
-+		NLA_PUT_U32(msg, NL80211_ATTR_BEACON_INTERVAL,
-+			    params->beacon_interval);
-+	}
-+
-+	if (params->rates[0] > 0) {
-+		wpa_printf(MSG_DEBUG, "  * basic_rates:");
-+		i = 0;
-+		while (i < NL80211_MAX_SUPP_RATES &&
-+		       params->rates[i] > 0) {
-+			wpa_printf(MSG_DEBUG, "    %.1f",
-+				   (double)params->rates[i] / 2);
-+			i++;
-+		}
-+		NLA_PUT(msg, NL80211_ATTR_BSS_BASIC_RATES, i,
-+			params->rates);
-+	}
-+
-+	if (params->mcast_rate > 0) {
-+		wpa_printf(MSG_DEBUG, "  * mcast_rates=%.1f",
-+			   (double)params->mcast_rate / 10);
-+		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
-+	}
-+
- 	ret = nl80211_set_conn_keys(params, msg);
- 	if (ret)
- 		goto nla_put_failure;
diff --git a/package/hostapd/patches/604-wpa_s-support-htmode-param.patch b/package/hostapd/patches/604-wpa_s-support-htmode-param.patch
deleted file mode 100644
index 267bde8..0000000
--- a/package/hostapd/patches/604-wpa_s-support-htmode-param.patch
+++ /dev/null
@@ -1,156 +0,0 @@
-From b9329c5dfeed7d5c55d2117d8dfe326fc40c8fb1 Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Tue, 3 Jul 2012 00:36:24 +0200
-Subject: [PATCH] wpa_s: support htmode param
-
-possible values are HT20, HT40-, HT40+ and NOHT
-
-Signed-off-by: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver.h            |    2 ++
- src/drivers/driver_nl80211.c    |   16 ++++++++++
- wpa_supplicant/config.c         |   66 +++++++++++++++++++++++++++++++++++++++
- wpa_supplicant/config_ssid.h    |    2 ++
- wpa_supplicant/wpa_supplicant.c |    2 ++
- 5 files changed, 88 insertions(+)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -368,6 +368,8 @@ struct wpa_driver_associate_params {
- 	int fixed_freq;
- 	unsigned char rates[NL80211_MAX_SUPP_RATES];
- 	int mcast_rate;
-+	int ht_set;
-+	unsigned int htmode;
- 
- 	/**
- 	 * bg_scan_period - Background scan period in seconds, 0 to disable
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7104,6 +7104,22 @@ retry:
- 		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
- 	}
- 
-+	if (params->ht_set) {
-+		switch(params->htmode) {
-+			case NL80211_CHAN_HT20:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT20");
-+				break;
-+			case NL80211_CHAN_HT40PLUS:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT40+");
-+				break;
-+			case NL80211_CHAN_HT40MINUS:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT40-");
-+				break;
-+		}
-+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
-+			    params->htmode);
-+	}
-+
- 	ret = nl80211_set_conn_keys(params, msg);
- 	if (ret)
- 		goto nla_put_failure;
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -1408,6 +1408,71 @@ static char * wpa_config_write_mcast_rat
- }
- #endif /* NO_CONFIG_WRITE */
- 
-+static int wpa_config_parse_htmode(const struct parse_data *data,
-+				   struct wpa_ssid *ssid, int line,
-+				   const char *value)
-+{
-+	int i;
-+	static const struct {
-+		const char *name;
-+		unsigned int val;
-+	} htmap[] = {
-+		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
-+		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
-+		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
-+		{ .name = "NOHT", .val = NL80211_CHAN_NO_HT, },
-+	};
-+	ssid->ht_set = 0;;
-+	for (i = 0; i < 4; i++) {
-+		if (strcasecmp(htmap[i].name, value) == 0) {
-+			ssid->htmode = htmap[i].val;
-+			ssid->ht_set = 1;
-+			break;
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_htmode(const struct parse_data *data,
-+				      struct wpa_ssid *ssid)
-+{
-+	char *value;
-+	int res;
-+
-+	value = os_malloc(6); /* longest: HT40+ */
-+	if (value == NULL)
-+		return NULL;
-+
-+	switch(ssid->htmode) {
-+		case NL80211_CHAN_HT20:
-+			res = os_snprintf(value, 4, "HT20");
-+			break;
-+		case NL80211_CHAN_HT40PLUS:
-+			res = os_snprintf(value, 5, "HT40+");
-+			break;
-+		case NL80211_CHAN_HT40MINUS:
-+			res = os_snprintf(value, 5, "HT40-");
-+			break;
-+		case NL80211_CHAN_NO_HT:
-+			res = os_snprintf(value, 4, "NOHT");
-+			break;
-+		default:
-+			os_free(value);
-+			return NULL;
-+	}
-+
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
-+
- static int wpa_config_parse_rates(const struct parse_data *data,
- 				  struct wpa_ssid *ssid, int line,
- 				  const char *value)
-@@ -1669,6 +1734,7 @@ static const struct parse_data ssid_fiel
- 	{ INT_RANGE(fixed_freq, 0, 1) },
- 	{ FUNC(rates) },
- 	{ FUNC(mcast_rate) },
-+	{ FUNC(htmode) },
- };
- 
- #undef OFFSET
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -605,6 +605,8 @@ struct wpa_ssid {
- 	int fixed_freq;
- 	unsigned char rates[NL80211_MAX_SUPP_RATES];
- 	double mcast_rate;
-+	int ht_set;
-+	unsigned int htmode;
- };
- 
- #endif /* CONFIG_SSID_H */
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -1613,6 +1613,8 @@ void wpa_supplicant_associate(struct wpa
- 			i++;
- 		}
- 		params.mcast_rate = ssid->mcast_rate;
-+		params.ht_set = ssid->ht_set;
-+		params.htmode = ssid->htmode;
- 	}
- 
- 	params.wpa_ie = wpa_ie;
diff --git a/package/hostapd/patches/610-max_num_sta_probe.patch b/package/hostapd/patches/610-max_num_sta_probe.patch
deleted file mode 100644
index 141eb5b..0000000
--- a/package/hostapd/patches/610-max_num_sta_probe.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/src/ap/beacon.c
-+++ b/src/ap/beacon.c
-@@ -455,6 +455,10 @@ void handle_probe_req(struct hostapd_dat
- 		return;
- 	}
- 
-+	if (!sta && hapd->num_sta >= hapd->conf->max_num_sta)
-+		wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR " ignored,"
-+			   " too many connected stations.", MAC2STR(mgmt->sa));
-+
- #ifdef CONFIG_INTERWORKING
- 	if (elems.interworking && elems.interworking_len >= 1) {
- 		u8 ant = elems.interworking[0] & 0x0f;
diff --git a/package/hostapd/patches/620-scan_wait.patch b/package/hostapd/patches/620-scan_wait.patch
deleted file mode 100644
index ac2d445..0000000
--- a/package/hostapd/patches/620-scan_wait.patch
+++ /dev/null
@@ -1,65 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -33,6 +33,8 @@
- extern int wpa_debug_level;
- extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
-+static int daemonize = 0;
-+static char *pid_file = NULL;
- 
- extern struct wpa_driver_ops *wpa_drivers[];
- 
-@@ -147,6 +149,14 @@ static void hostapd_logger_cb(void *ctx,
- }
- #endif /* CONFIG_NO_HOSTAPD_LOGGER */
- 
-+static void hostapd_setup_complete_cb(void *ctx)
-+{
-+	if (daemonize && os_daemonize(pid_file)) {
-+		perror("daemon");
-+		return;
-+	}
-+	daemonize = 0;
-+}
- 
- /**
-  * hostapd_init - Allocate and initialize per-interface data
-@@ -190,6 +200,7 @@ static struct hostapd_iface * hostapd_in
- 		if (hapd == NULL)
- 			goto fail;
- 		hapd->msg_ctx = hapd;
-+		hapd->setup_complete_cb = hostapd_setup_complete_cb;
- 	}
- 
- 	return hapd_iface;
-@@ -429,8 +440,6 @@ static void hostapd_global_deinit(const 
- #endif /* CONFIG_NATIVE_WINDOWS */
- 
- 	eap_server_unregister_methods();
--
--	os_daemonize_terminate(pid_file);
- }
- 
- 
-@@ -456,11 +465,6 @@ static int hostapd_global_run(struct hap
- 	}
- #endif /* EAP_SERVER_TNC */
- 
--	if (daemonize && os_daemonize(pid_file)) {
--		perror("daemon");
--		return -1;
--	}
--
- 	eloop_run();
- 
- 	return 0;
-@@ -564,8 +568,7 @@ int main(int argc, char *argv[])
- 	struct hapd_interfaces interfaces;
- 	int ret = 1;
- 	size_t i;
--	int c, debug = 0, daemonize = 0;
--	char *pid_file = NULL;
-+	int c, debug = 0;
- 	const char *log_file = NULL;
- 	const char *entropy_file = NULL;
- 
diff --git a/package/hostapd/patches/630-bool_fix.patch b/package/hostapd/patches/630-bool_fix.patch
deleted file mode 100644
index 510b000..0000000
--- a/package/hostapd/patches/630-bool_fix.patch
+++ /dev/null
@@ -1,14 +0,0 @@
---- a/src/ap/ieee802_1x.c
-+++ b/src/ap/ieee802_1x.c
-@@ -2043,9 +2043,9 @@ void ieee802_1x_notify_pre_auth(struct e
- }
- 
- 
--static const char * bool_txt(Boolean bool)
-+static const char * bool_txt(Boolean bool_val)
- {
--	return bool ? "TRUE" : "FALSE";
-+	return bool_val ? "TRUE" : "FALSE";
- }
- 
- #ifdef CONFIG_CTRL_IFACE_MIB
-- 
1.7.9.5

