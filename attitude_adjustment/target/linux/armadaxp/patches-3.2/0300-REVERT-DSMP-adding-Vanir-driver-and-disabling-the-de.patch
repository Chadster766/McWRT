From 2aaf0fc141fb3a3bd36c789d5a6459f75db297cb Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Sun, 23 Sep 2012 15:48:55 +0200
Subject: [PATCH 300/609] REVERT: DSMP adding Vanir driver and disabling the
 debug

Signed-off-by: Seif Mazareeb <seif@marvell.com>
---
 drivers/scsi/Kconfig                               |    5 -
 drivers/scsi/Makefile                              |    1 -
 drivers/scsi/vanir/History-NonRAID.txt             |  331 --
 drivers/scsi/vanir/Makefile                        |  253 --
 drivers/scsi/vanir/Makefile.kbuild                 |  215 -
 drivers/scsi/vanir/Makefile.xen                    |   26 -
 drivers/scsi/vanir/core/api/core_api.c             |  941 -----
 drivers/scsi/vanir/core/api/core_api.h             |   40 -
 drivers/scsi/vanir/core/api/core_api_bbu.c         |   74 -
 drivers/scsi/vanir/core/api/core_api_exp.c         |  476 ---
 drivers/scsi/vanir/core/api/core_api_flash.c       |  408 --
 drivers/scsi/vanir/core/api/core_api_led.c         |  383 --
 drivers/scsi/vanir/core/api/core_api_pd.c          | 1172 ------
 drivers/scsi/vanir/core/api/core_console.h         |   70 -
 drivers/scsi/vanir/core/core/core_alarm.c          |   98 -
 drivers/scsi/vanir/core/core/core_alarm.h          |   38 -
 drivers/scsi/vanir/core/core/core_device.c         |  288 --
 drivers/scsi/vanir/core/core/core_device.h         |   55 -
 drivers/scsi/vanir/core/core/core_error.c          | 1351 -------
 drivers/scsi/vanir/core/core/core_error.h          |  170 -
 drivers/scsi/vanir/core/core/core_event.c          |  489 ---
 drivers/scsi/vanir/core/core/core_exp.h            |   36 -
 drivers/scsi/vanir/core/core/core_header.h         |   23 -
 drivers/scsi/vanir/core/core/core_init.h           |   22 -
 drivers/scsi/vanir/core/core/core_internal.h       |  651 ---
 drivers/scsi/vanir/core/core/core_large_req.c      |  241 --
 drivers/scsi/vanir/core/core/core_manager.c        | 1107 ------
 drivers/scsi/vanir/core/core/core_manager.h        |  140 -
 drivers/scsi/vanir/core/core/core_protocol.c       |  493 ---
 drivers/scsi/vanir/core/core/core_protocol.h       |  312 --
 drivers/scsi/vanir/core/core/core_resource.c       | 1126 ------
 drivers/scsi/vanir/core/core/core_resource.h       |  199 -
 drivers/scsi/vanir/core/core/core_type.h           |   31 -
 drivers/scsi/vanir/core/core/core_util.c           |  608 ---
 drivers/scsi/vanir/core/core/core_util.h           |  117 -
 drivers/scsi/vanir/core/pl/core_gpio.c             |  725 ----
 drivers/scsi/vanir/core/pl/core_gpio.h             |  210 -
 drivers/scsi/vanir/core/pl/core_rmw_flash.c        |  174 -
 drivers/scsi/vanir/core/pl/core_rmw_flash.h        |   44 -
 drivers/scsi/vanir/core/pl/core_spi.h              |  210 -
 drivers/scsi/vanir/core/pl/spi_hal.h               |   35 -
 drivers/scsi/vanir/core/pm/core_pm.c               |  689 ----
 drivers/scsi/vanir/core/pm/core_pm.h               |   53 -
 drivers/scsi/vanir/core/sas_base/core_sas.h        |  134 -
 drivers/scsi/vanir/core/sas_base/sas_error.c       |  405 --
 drivers/scsi/vanir/core/sas_base/sas_handler.c     | 1878 ---------
 drivers/scsi/vanir/core/sas_base/sas_init.c        |  704 ----
 drivers/scsi/vanir/core/sas_base/sas_util.c        |  435 ---
 drivers/scsi/vanir/core/sas_smp/core_discover.h    | 2256 -----------
 drivers/scsi/vanir/core/sas_smp/core_expander.c    | 1224 ------
 drivers/scsi/vanir/core/sas_smp/core_expander.h    |   45 -
 drivers/scsi/vanir/core/sata_base/core_sata.c      | 1919 ---------
 drivers/scsi/vanir/core/sata_base/core_sata.h      |  401 --
 drivers/scsi/vanir/core/sata_base/sata_error.c     | 1474 -------
 drivers/scsi/vanir/core/scsi/core_sat.c            | 4129 --------------------
 drivers/scsi/vanir/core/scsi/core_sat.h            |   76 -
 drivers/scsi/vanir/core/scsi/core_ses.c            |  669 ----
 drivers/scsi/vanir/core/scsi/core_ses.h            |  424 --
 drivers/scsi/vanir/hba_sm/hba_api.c                |  381 --
 drivers/scsi/vanir/hba_sm/hba_api.h                |   36 -
 drivers/scsi/vanir/hba_sm/mv_hba.h                 |   23 -
 drivers/scsi/vanir/include/com_dbg.h               |   63 -
 drivers/scsi/vanir/include/com_list.c              |  374 --
 drivers/scsi/vanir/include/com_list.h              |  160 -
 drivers/scsi/vanir/include/com_mod_mgmt.h          |  107 -
 drivers/scsi/vanir/include/com_nvram.h             |  259 --
 drivers/scsi/vanir/include/com_scsi.h              |  418 --
 drivers/scsi/vanir/include/com_sgd.h               |  375 --
 drivers/scsi/vanir/include/com_tag.h               |   44 -
 drivers/scsi/vanir/include/com_type.h              |  289 --
 drivers/scsi/vanir/include/com_u64.h               |   37 -
 drivers/scsi/vanir/include/com_util.h              |  232 --
 drivers/scsi/vanir/include/csmisas.h               | 1162 ------
 .../vanir/include/generic/com_adapter_struct.h     |  213 -
 .../scsi/vanir/include/generic/com_array_struct.h  |  128 -
 .../scsi/vanir/include/generic/com_bbu_struct.h    |  100 -
 .../scsi/vanir/include/generic/com_dbg_struct.h    |   80 -
 drivers/scsi/vanir/include/generic/com_define.h    |  178 -
 .../scsi/vanir/include/generic/com_enc_struct.h    |  383 --
 drivers/scsi/vanir/include/generic/com_error.h     |  130 -
 .../scsi/vanir/include/generic/com_event_define.h  |  496 ---
 .../vanir/include/generic/com_event_define_ext.h   |  442 ---
 .../scsi/vanir/include/generic/com_flash_struct.h  |   35 -
 .../vanir/include/generic/com_passthrough_struct.h |   57 -
 drivers/scsi/vanir/include/generic/com_pd_struct.h |  286 --
 .../scsi/vanir/include/generic/com_physical_link.h |   59 -
 drivers/scsi/vanir/include/generic/com_product.h   |  117 -
 .../scsi/vanir/include/generic/com_raid_struct.h   |  210 -
 .../vanir/include/generic/com_request_detail.h     |  144 -
 .../vanir/include/generic/com_request_header.h     |   61 -
 drivers/scsi/vanir/include/generic/com_struct.h    |   45 -
 drivers/scsi/vanir/include/generic/com_vd_struct.h |  137 -
 drivers/scsi/vanir/include/icommon/com_api.h       |  266 --
 .../scsi/vanir/include/icommon/com_diagnostic.h    |   77 -
 .../scsi/vanir/include/icommon/com_event_struct.h  |   71 -
 drivers/scsi/vanir/include/icommon/com_extern.h    |   45 -
 drivers/scsi/vanir/include/icommon/com_flash.h     |   36 -
 drivers/scsi/vanir/include/icommon/com_ioctl.h     |   94 -
 drivers/scsi/vanir/lib/common/com_nvram.c          |  488 ---
 drivers/scsi/vanir/lib/common/com_scsi.c           |   75 -
 drivers/scsi/vanir/lib/common/com_sgd.c            |  851 ----
 drivers/scsi/vanir/lib/common/com_tag.c            |   84 -
 drivers/scsi/vanir/lib/common/com_u64.c            |  140 -
 drivers/scsi/vanir/lib/common/com_util.c           |  569 ---
 drivers/scsi/vanir/linux/hba_exp.c                 |  817 ----
 drivers/scsi/vanir/linux/hba_exp.h                 |  234 --
 drivers/scsi/vanir/linux/hba_header.h              |   32 -
 drivers/scsi/vanir/linux/hba_inter.h               |  135 -
 drivers/scsi/vanir/linux/hba_mod.c                 |  657 ----
 drivers/scsi/vanir/linux/hba_mod.h                 |   89 -
 drivers/scsi/vanir/linux/hba_priv.c                |  256 --
 drivers/scsi/vanir/linux/hba_timer.c               |  478 ---
 drivers/scsi/vanir/linux/hba_timer.h               |   62 -
 drivers/scsi/vanir/linux/linux_iface.c             |  844 ----
 drivers/scsi/vanir/linux/linux_iface.h             |  113 -
 drivers/scsi/vanir/linux/linux_main.c              | 1422 -------
 drivers/scsi/vanir/linux/linux_main.h              |   77 -
 drivers/scsi/vanir/linux/mv_os.c                   |  437 ---
 drivers/scsi/vanir/linux/mv_os.h                   |  310 --
 drivers/scsi/vanir/mv_conf.mk                      |    1 -
 drivers/scsi/vanir/mv_config.h                     |   17 -
 drivers/scsi/vanir/mv_config_vanir.h               |   35 -
 drivers/scsi/vanir/mv_include.h                    |   32 -
 drivers/scsi/vanir/mv_linux.h                      |   24 -
 drivers/scsi/vanir/patch.kbuild                    |   10 -
 drivers/scsi/vanir/patch.sh                        |   87 -
 drivers/scsi/vanir/product/vanir/core_cpu.h        |   91 -
 drivers/scsi/vanir/product/vanir/core_hal.c        |  681 ----
 drivers/scsi/vanir/product/vanir/core_hal.h        |  939 -----
 drivers/scsi/vanir/product/vanir/core_init.c       |  753 ----
 drivers/scsi/vanir/product/vanir/core_spi.c        | 1096 ------
 .../scsi/vanir/product/vanir/mv_product_vanir.h    |   38 -
 drivers/scsi/vanir/readme                          |  130 -
 drivers/scsi/vanir/readme.arm                      |   32 -
 drivers/scsi/vanir/readme.vmware                   |   13 -
 135 files changed, 50302 deletions(-)
 delete mode 100644 drivers/scsi/vanir/History-NonRAID.txt
 delete mode 100644 drivers/scsi/vanir/Makefile
 delete mode 100644 drivers/scsi/vanir/Makefile.kbuild
 delete mode 100644 drivers/scsi/vanir/Makefile.xen
 delete mode 100644 drivers/scsi/vanir/core/api/core_api.c
 delete mode 100644 drivers/scsi/vanir/core/api/core_api.h
 delete mode 100644 drivers/scsi/vanir/core/api/core_api_bbu.c
 delete mode 100644 drivers/scsi/vanir/core/api/core_api_exp.c
 delete mode 100644 drivers/scsi/vanir/core/api/core_api_flash.c
 delete mode 100644 drivers/scsi/vanir/core/api/core_api_led.c
 delete mode 100644 drivers/scsi/vanir/core/api/core_api_pd.c
 delete mode 100644 drivers/scsi/vanir/core/api/core_console.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_alarm.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_alarm.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_device.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_device.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_error.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_error.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_event.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_exp.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_header.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_init.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_internal.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_large_req.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_manager.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_manager.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_protocol.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_protocol.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_resource.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_resource.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_type.h
 delete mode 100644 drivers/scsi/vanir/core/core/core_util.c
 delete mode 100644 drivers/scsi/vanir/core/core/core_util.h
 delete mode 100644 drivers/scsi/vanir/core/pl/core_gpio.c
 delete mode 100644 drivers/scsi/vanir/core/pl/core_gpio.h
 delete mode 100644 drivers/scsi/vanir/core/pl/core_rmw_flash.c
 delete mode 100644 drivers/scsi/vanir/core/pl/core_rmw_flash.h
 delete mode 100644 drivers/scsi/vanir/core/pl/core_spi.h
 delete mode 100644 drivers/scsi/vanir/core/pl/spi_hal.h
 delete mode 100644 drivers/scsi/vanir/core/pm/core_pm.c
 delete mode 100644 drivers/scsi/vanir/core/pm/core_pm.h
 delete mode 100644 drivers/scsi/vanir/core/sas_base/core_sas.h
 delete mode 100644 drivers/scsi/vanir/core/sas_base/sas_error.c
 delete mode 100644 drivers/scsi/vanir/core/sas_base/sas_handler.c
 delete mode 100644 drivers/scsi/vanir/core/sas_base/sas_init.c
 delete mode 100644 drivers/scsi/vanir/core/sas_base/sas_util.c
 delete mode 100644 drivers/scsi/vanir/core/sas_smp/core_discover.h
 delete mode 100644 drivers/scsi/vanir/core/sas_smp/core_expander.c
 delete mode 100644 drivers/scsi/vanir/core/sas_smp/core_expander.h
 delete mode 100644 drivers/scsi/vanir/core/sata_base/core_sata.c
 delete mode 100644 drivers/scsi/vanir/core/sata_base/core_sata.h
 delete mode 100644 drivers/scsi/vanir/core/sata_base/sata_error.c
 delete mode 100644 drivers/scsi/vanir/core/scsi/core_sat.c
 delete mode 100644 drivers/scsi/vanir/core/scsi/core_sat.h
 delete mode 100644 drivers/scsi/vanir/core/scsi/core_ses.c
 delete mode 100644 drivers/scsi/vanir/core/scsi/core_ses.h
 delete mode 100644 drivers/scsi/vanir/hba_sm/hba_api.c
 delete mode 100644 drivers/scsi/vanir/hba_sm/hba_api.h
 delete mode 100644 drivers/scsi/vanir/hba_sm/mv_hba.h
 delete mode 100644 drivers/scsi/vanir/include/com_dbg.h
 delete mode 100644 drivers/scsi/vanir/include/com_list.c
 delete mode 100644 drivers/scsi/vanir/include/com_list.h
 delete mode 100644 drivers/scsi/vanir/include/com_mod_mgmt.h
 delete mode 100644 drivers/scsi/vanir/include/com_nvram.h
 delete mode 100644 drivers/scsi/vanir/include/com_scsi.h
 delete mode 100644 drivers/scsi/vanir/include/com_sgd.h
 delete mode 100644 drivers/scsi/vanir/include/com_tag.h
 delete mode 100644 drivers/scsi/vanir/include/com_type.h
 delete mode 100644 drivers/scsi/vanir/include/com_u64.h
 delete mode 100644 drivers/scsi/vanir/include/com_util.h
 delete mode 100644 drivers/scsi/vanir/include/csmisas.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_adapter_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_array_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_bbu_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_dbg_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_define.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_enc_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_error.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_event_define.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_event_define_ext.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_flash_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_passthrough_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_pd_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_physical_link.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_product.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_raid_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_request_detail.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_request_header.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_struct.h
 delete mode 100644 drivers/scsi/vanir/include/generic/com_vd_struct.h
 delete mode 100644 drivers/scsi/vanir/include/icommon/com_api.h
 delete mode 100644 drivers/scsi/vanir/include/icommon/com_diagnostic.h
 delete mode 100644 drivers/scsi/vanir/include/icommon/com_event_struct.h
 delete mode 100644 drivers/scsi/vanir/include/icommon/com_extern.h
 delete mode 100644 drivers/scsi/vanir/include/icommon/com_flash.h
 delete mode 100644 drivers/scsi/vanir/include/icommon/com_ioctl.h
 delete mode 100644 drivers/scsi/vanir/lib/common/com_nvram.c
 delete mode 100644 drivers/scsi/vanir/lib/common/com_scsi.c
 delete mode 100644 drivers/scsi/vanir/lib/common/com_sgd.c
 delete mode 100644 drivers/scsi/vanir/lib/common/com_tag.c
 delete mode 100644 drivers/scsi/vanir/lib/common/com_u64.c
 delete mode 100644 drivers/scsi/vanir/lib/common/com_util.c
 delete mode 100644 drivers/scsi/vanir/linux/hba_exp.c
 delete mode 100644 drivers/scsi/vanir/linux/hba_exp.h
 delete mode 100644 drivers/scsi/vanir/linux/hba_header.h
 delete mode 100644 drivers/scsi/vanir/linux/hba_inter.h
 delete mode 100644 drivers/scsi/vanir/linux/hba_mod.c
 delete mode 100644 drivers/scsi/vanir/linux/hba_mod.h
 delete mode 100644 drivers/scsi/vanir/linux/hba_priv.c
 delete mode 100644 drivers/scsi/vanir/linux/hba_timer.c
 delete mode 100644 drivers/scsi/vanir/linux/hba_timer.h
 delete mode 100644 drivers/scsi/vanir/linux/linux_iface.c
 delete mode 100644 drivers/scsi/vanir/linux/linux_iface.h
 delete mode 100644 drivers/scsi/vanir/linux/linux_main.c
 delete mode 100644 drivers/scsi/vanir/linux/linux_main.h
 delete mode 100644 drivers/scsi/vanir/linux/mv_os.c
 delete mode 100644 drivers/scsi/vanir/linux/mv_os.h
 delete mode 100644 drivers/scsi/vanir/mv_conf.mk
 delete mode 100644 drivers/scsi/vanir/mv_config.h
 delete mode 100644 drivers/scsi/vanir/mv_config_vanir.h
 delete mode 100644 drivers/scsi/vanir/mv_include.h
 delete mode 100644 drivers/scsi/vanir/mv_linux.h
 delete mode 100644 drivers/scsi/vanir/patch.kbuild
 delete mode 100644 drivers/scsi/vanir/patch.sh
 delete mode 100644 drivers/scsi/vanir/product/vanir/core_cpu.h
 delete mode 100644 drivers/scsi/vanir/product/vanir/core_hal.c
 delete mode 100644 drivers/scsi/vanir/product/vanir/core_hal.h
 delete mode 100644 drivers/scsi/vanir/product/vanir/core_init.c
 delete mode 100644 drivers/scsi/vanir/product/vanir/core_spi.c
 delete mode 100644 drivers/scsi/vanir/product/vanir/mv_product_vanir.h
 delete mode 100644 drivers/scsi/vanir/readme
 delete mode 100644 drivers/scsi/vanir/readme.arm
 delete mode 100644 drivers/scsi/vanir/readme.vmware

--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -354,11 +354,6 @@ config SCSI_MV_THOR
         help
                 Provides support for Marvell thor Storage Controller series.
 
-config SCSI_MV_VANIR
-        tristate "Marvell Storage Controller VANIR"
-        depends on SCSI && BLK_DEV_SD
-        help
-
 config ISCSI_TCP
 	tristate "iSCSI Initiator over TCP/IP"
 	depends on SCSI && INET
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -52,7 +52,6 @@ obj-$(CONFIG_GVP11_SCSI)	+= gvp11.o	wd33
 obj-$(CONFIG_MVME147_SCSI)	+= mvme147.o	wd33c93.o
 obj-$(CONFIG_SGIWD93_SCSI)	+= sgiwd93.o	wd33c93.o
 obj-$(CONFIG_SCSI_MV_THOR)      += thor/
-obj-$(CONFIG_SCSI_MV_VANIR)     += vanir/
 obj-$(CONFIG_ATARI_SCSI)	+= atari_scsi.o
 obj-$(CONFIG_MAC_SCSI)		+= mac_scsi.o
 obj-$(CONFIG_SCSI_MAC_ESP)	+= esp_scsi.o	mac_esp.o
--- a/drivers/scsi/vanir/History-NonRAID.txt
+++ /dev/null
@@ -1,331 +0,0 @@
-================================================================================
-- Version: vanir 4.0.0.1531N
-- Date Release: 06/22/2011
-- Changes:
-	1. Remove the retry EH for timeout request.
-- Related issue:
-	BT3951: [Vanir + Luigi] Kernel panic when shutdown system after several format unit commands.
-	BT3954: [vanir+luigi]Send diagnostic command cause luigi reset.
-	BT3972: ATA Pass through command should return check condition when CC=1.
-================================================================================
-- Version: vanir 4.0.0.1530N
-- Date Release: 05/20/2011
-- Changes:
-	1. Add copyright and History-NonRAID file.
-- Related issue:
-	BT3940: [Vanir+Luigi2] Write buffer cmd update drive FW pkg failed.
-	BT3945: [Vanir+Luigi2] Write buffer cmd return aborted if execute during IO.
-	BT3948: [Vanir+Luigi2] IO stopped while executing write buffer cmd.
-	BT3949: [Vanir+Luigi2] Warnings during make.
-	BT3950: [Vanir+Luigi] Kernel Panic when send read capacity to virtual device.
-	BT3952: [Vanir+Luigi] Commands should be returned after timeout time.
-================================================================================
-- Version: vanir 4.0.0.1529N
-- Date Release: 05/11/2011
-- Changes:
-	1. Clean up source code for NetApp.
-	2. Enhance error handling code.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1528N
-- Date Release: 04/14/2011
-- Changes:
-	1. Clean up some workaround code for Vanir C2.
-	2. Support Device ID 0x9580 for Vanir.
-- Related issue:
-	4518: System hang when connected over 2 expanders cascading to Vanir C2/C1.
-	4472: HD wake up feature using dd/fdisk command as Odin product.
-	4070: dud.config file should be placed at the same folder with install and modules folder in suse driverdisk.
-================================================================================
-- Version: vanir 4.0.0.1527N
-- Date Release: 04/07/2011
-- Changes:
-	1. Support ArmadaXP board and add a readme file.
-	2. Enable MXIC SPI flash support.
-	3. Do STP and SSP Link Layer reset when do mv_reset_phy Hard Reset. Sometimes Vanir ASIC can be stuck(vanir+VG).
-	4. Update PD Page function used during initializing PD id.
-	5. Modified PM error handling.
-- Related issue:
-	4401: [Linux Driver 1525N] Unable to detect drives behind Qriga
-	4459: Add support for SPI flash p/n ST Micro M25P40
-================================================================================
-- Version: vanir 4.0.0.1526N
-- Date Release: 03/10/2011
-- Changes:
-	1. Fix if hot plug disk when disk is initializing, it appears kernel panic issue.
-	2. Add DEF_SCSI_QCMD for kernel 2.6.37.
-	3. Unlock host->lock within queue_command() and clean up spin lock code for tasklet-enabled case.
-	4. Use Command Complete Interrupt Self-Clearing mode for MSI-enabled.
-	5. Add a module param "mv_msi_enable" for driver loading. (insmod mv94xx.ko mv_msi_enable=1)
-- Related issue:
-	4404: Dual vanir controller with Atmel 1033 25DF041A SSH SPI flash BIOS upgrade failure.
-	4418: [Linux Non RAID Driver]can't find SAS HDD after load driver when install OS.
-================================================================================
-- Version: vanir 4.0.0.1525N
-- Date Release: 01/27/2011
-- Changes:
-	1. Support Staggered SPIN UP feature.
-	2. Support PM25LD010C and enhance PM error handling.
-	3. Enhance Multi-LUN support.
-- Related issue:
-	3437: Add 0x2F read log ext commands to be compliant to ATA-8.
-================================================================================
-- Version: vanir 4.0.0.1524N
-- Date Release: 12/17/2010
-- Changes:
-	1. Disable Qriga Rx buffer
-- Related issue:
-	3775: [Vanir+ Qriga C1]SATA HDDs dropped during IO
-	4208: Vanir+Val36+Luigi+SATA SSD, but enter SUSE system, can not find the SSD.
-================================================================================
-- Version: vanir 4.0.0.1523N
-- Date Release: 08/30/2010
-- Changes:
-	1. Support multiple LUN.
-	2. Disable ASIC Watchdog Timeout Workaround, verified it seems not effective under Linux.
-	3. Enhance code about IO stop and system hang when running stress test on Vanir+Valhalla with bad disks.
-- Related issue:
-	2674: [VanirC1] IO drop to 0 after 30 hours of SATA HDD IOstress on Valhalla36 and AIC expanders.
-	3759: Only one disk of 2th expander can be detected when 2 Cascading expander+Hotplug in and out.
-================================================================================
-- Version: vanir 4.0.0.1522N
-- Date Release: 08/19/2010
-- Changes:
-	1. Fix scsi id with phy id.
-	SCSI ID policy:
-		SCSI ID 0 ¨C 7:       disk connected directly from port 0 -7.
-		SCSI ID 8 ¨C MAX ID:  disk connected behind expander/PM.
-	2. Save signature in pd info.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1521N
-- Date Release: 08/06/2010
-- Changes:
-	1. Fixed the issue that cannot insert driver.
-	2. Fixed the issue that lun 1 will be plug out when hotplug in.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1520N
-- Date Release: 08/03/2010
-- Changes:
-	1. Fixed issue that the big lock(disable cpu irq) withint tasklet BH and Timer handler results to system hang during hot-plug handling, reported by Flexstar.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1519N-VanGogh
-- Date Release: 07/05/2010
-- Changes:
-	N/A
-- Related issue:
-	3216: Add vendor unique command in Vanir non RAID driver.
-	3482: [VanGogh with Vanir]FIO failed on one of the Vangogh modules with customer IO config.
-	3159: Add asynch notification support to non RAID driver for Van Gogh.
-================================================================================
-- Version: vanir 4.0.0.1518N
-- Date Release: 07/05/2010
-- Changes:
-	N/A
-- Related issue:
-	2899: Firmware download using hdparm failed when using vanir to download to van gogh.
-================================================================================
-- Version: vanir 4.0.0.1517N
-- Date Release: 06/29/2010
-- Changes:
-	1. Disable Multi-LUN.
-	2. Support DIF.
-	3. Modify for direct-attached SAS device hot-plug handling.
-- Related issue:
-	2717: Wrong number of expanders detected with maximum devices.
-================================================================================
-- Version: vanir 4.0.0.1516N
-- Date Release: 06/01/2010
-- Changes:
-	1. Disable Multi-LUN.
-	2. Support DIF.
-	3. Enhance core driver SAT part for ATA passthrough command.
-- Related issue:
-	2899: Firmware download using hdparm failed when using vanir to download to VanGogh.
-	3185: First party DMA commands sent through pass-through failure.
-================================================================================
-- Version: vanir 4.0.0.1515N
-- Date Release: 05/25/2010
-- Changes:
-	1. Disable Multi-LUN.
-	2. Support DIF.
-	3. Fixed wrongly return ATA Status Return descriptor in sense buffer not data buffer for ATA passthrough command "Return Response Information" protocol.
-	4. For successful ATA passthrough command with ck_cond bit set, fill sense data with the E_Status register value(PIO setup FIS:dw3) instead of Status register value(dw0).
-- Related issue:
-	3153:Vanir C1:only part of HDDs can be recognised after do hotplug.
-================================================================================
-- Version: vanir 4.0.0.1514N
-- Date Release: 05/10/2010
-- Changes:
-	1. Support multiple LUN.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1513N
-- Date Release: 04/29/2010
-- Changes:
-	1. Disable Multi-LUN.
-	2. Support DIF.
-	3. Fixed wrongly parsed sense data about IDNF error for SCSI READ/WRITE commands.
-	4. Fixed wrongly parsed sense data about IDNF error for pass-through ATA read/write commands.
-	5. Support SCSI 6-byte CDB Read/Write.
-	6. Support SATA Power-up in Standby feature.
-	7. Fixed code error within load balance function, which may result to replace driver or hot-plug with expander kernel panic.
-- Related issue:
-	2691:System keeps printing out "CORE: Sata_get_register_set no register set" after starting IO.
-================================================================================
-- Version: vanir 4.0.0.1512N
-- Date Release: 02/23/2010
-- Changes:
-	1. Based on 1510N source code, not include multi-lun code.
-	2. Speed up disk detection when hot plug expander.
-	3. Enhance core driver Error Handling.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.1.1510N
-- Date Release: 02/10/2010
-- Changes:
-	1. Based on 1510N source code, not include multi-lun code.
-	2. Speed up disk detection when hot plug expander.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1511N
-- Date Release: 02/01/2010
-- Changes:
-	1. Support Multi-LUN target device.
-	2. Avoid missing hot plug event, rescan host if message queue is full.
-	3. Merged core driver from windows branch.
-	4. Add check ses support page step for internal ses_state_machine.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1510N
-- Date Release: 01/28/2010
-- Changes:
-	1. Based on 1507N_rc2, not include multi-lun code.
-	2. Increase Max target number to 1024, not report virtual device.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1509N
-- Date Release: 01/26/2010
-- Changes:
-	1. If scsi_add_device() return failed, notify core driver to remove the internal device to keep consistent.
-	2. Do not notify os repeatedly for enclosure device when hot-plug devices behind the expander.
-	3. Enhance core driver error handling.
-	4. Remove reset phy step for expander state machine.
-	5. Increase delay for phy change before handling broadcast, related issue #3164.
-	6. Handle CNCTN_RT_NT_SPRTD_ERR(0x80000010) error as timeout error.
-- Related issue:
-	3164: Error info(0002) was showed after power off Valhalla.
-	3169: Not all PD can be detected after driver insmod until they're hot-plugged.
-================================================================================
-- Version: vanir 4.0.0.1508N
-- Date Release: 01/14/2010
-- Changes:
-	1. Add multiple LUN support.
-	2. Added SAT device support.
-	3. Fixed issue - memory cache allocate failed for duplicate name.
-	4. Add IBM UEFI Server Motherboard IO Workaround.
-- Related issue:
-	2702: [LSI Expander SASX28] Linux still show enclosure info after power off expander.
-================================================================================
-- Version: vanir 4.0.0.1507N
-- Date Release: 01/05/2010
-- Changes:
-	1. Support Florence.
-	2. Fixed issue - memory cache allocate failed for duplicate name
-	3. Support PCIE status showed in MRU&CLI for odin&vanir linux driver.
-	4. Fixed Vanir C1 + PMC/Valhalla 36 hot-plug during IO, re-pluggin cable smp request watchdog timeout issue.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1506N(for C1)
-- Date Release: 12/24/2009
-- Changes:
-	1. Support C1.
-	2. Add debug_mode attribute to hba host for debug use.
-	3. Increase message queue depth = MAX target device to support more than 64 target devices hot-plug.
-	4. Fixed a pd page issue for over 128 devices.
-	5. Update Linux driver ffc() function to fix unassociated FIS received error interrupt when IO on >33 disks.
-	6. Update set_phy_rate function to fix failed to set vanir work under 3Gbps phy-rate.
-	7. Add SCSI_CMD_REQUEST_SENSE command handler for virtual device for linux nonraid driver.
-- Related issue:
-	2063£ºIf set phy rate to 3Gb/s, can't take effect on 6Gb SAS HDD."
-	2383: [vanir+valhalla36] No HDD or expander info shown on Linux MRU.
-	2499: [VanirC0+Valhalla36]Cascading detection failed if add >33 disks.
-	2555: [VanirC0+Valhalla36]detection failed if hotplug with 3 cascading Valhalla.
-================================================================================
-- Version: vanir 4.0.0.1505N
-- Date Release: 12/08/2009
-- Changes:
-	1. Merge code to trunk folder.
-	2. Fixed issue that can not detect SAS disk connected directly after re-plug in SAS disk.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1504N
-- Date Release: 12/04/2009
-- Changes:
-	1. Fixed issue -- Vanir + Valhalla > 33 SATA disks,  time out disk cause remain disk IO stopped. Retry time out request once to avoid reset disk which cause broadcast.
-	2. Expander command time out or watch dog time out when plug out/in PMC cable issue. Disabled ¡°PHY State Machine Timeout¡± interrupt and get better result.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1503N(for C0)
-- Date Release: 12/02/2009
-- Changes:
-	1. Fixed issue - can not find SATA disk connected again when hot plug expander or disks.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1502N(for C0)
-- Date Release: 11/02/2009
-- Changes:
-	1. Clean up PHY Tunning structure related and enable set phy tunning data from HBA page for C0 controller. This can enhance performance.
-	2. Move product folder out from core.
-	3. In order to avoid too many ¡°invalid request¡± and retry, filter LD/Block API command in HBA module, not directly send to core module.
-- Related issue:
-	N/A
-================================================================================
-- Version: vanir 4.0.0.1501N
-- Date Release: 10/22/2009
-- Changes:
-	1. Trash size to fix hot-plug related issue.
-	2. For linux driver, if allocate memory failed, return "Out of memory" error , not ASSERT.
-	3. Modify driver code to support CLI flashrw command.
-	4. Support MV_MAX_TARGET_NUMBER(128) scsi devices.
-	5. Fix hdparm -i get inverse param info(related issue 2168).
-- Related issue:
-	2071: CLI flashrw cmd failed.
-================================================================================
-- Version: vanir 4.0.0.1500N
-- Date Release: 09/02/2009
-- Changes:
-	1. Set smp timeout register to max to fix smp request watchdog timeout.
-	2. Cleanup and fix init_queue_count value is not correct problem.
-	3. Rewrite the "get expander information" API.
-	4. Change the discover virtual request error handling.
-	5. Only return current page when mode sense for SATA.
-	6. Fixed the issue that hdparm -i xxxx doesn't work.
-	7. Fix PD page over writing another uninitialized device if PD page is full.
-- Related issue:
-	1644: The disks connected to Valhalla12 still be showed by 'lsscsi' after power off Valhalla12
-	1969: Reinserted SAS disk of FUJITSU MBA3073RC failed to be found in system.
-	1978: kernel panic if hotplug Vitesse expander SATA/SAS.
-	1955: Plug in a PD and then system met kernel panic.
-	2001: Install RHEL4.8 on free disk fail.
-	2002: Insmod mv94xx.ko under RHEL AS 4U8 64bit failed.
-	2016: Hdparm: it take too long to get state of a PD after put it sleep.
-	2040: Kernel Panic when connecting HDDs with PM.
-	2061: Kernel panic when running tio-test under RHEL AS 4U8.
-	2094: Kernel panic when install MRU under RHEL AS 4U8.
-	2113: Timeout when run  tiotest on md.
--- a/drivers/scsi/vanir/Makefile
+++ /dev/null
@@ -1,253 +0,0 @@
-#
-#
-# Note: This Makefile is for 2.6 kernel only, at present.
-#
-# V0.0.0.6 Ver.Make
-
-# default to build for the running kernel
-ifeq ("x", "x$(KERNEL_SRC)")
-  KERNEL_SRC=/lib/modules/$(shell uname -r)/build
-
-  ifeq ("powerpc", "$(ARCH)")
-	KERNEL_SRC=/root/katmai_29/lib/modules/2.6.29/build
-  endif
-
-  ifeq ("arm", "$(ARCH)")
-	KERNEL_SRC=/root/armadaxp/linux-2.6.35.9
-  endif
-endif
-
-# use KERNEL_SRC if not called by our driver disk maker
-ifeq ("x", "x$(KERNEL_SOURCE_DIR)")
-        KERNEL_SRC_DIR=$(KERNEL_SRC)
-else
-	KERNEL_SRC_DIR=$(KERNEL_SOURCE_DIR)
-endif
-
-ifeq ("x", "x$(KERNEL_BUILD_DIR)")
-	KERNEL_BLD_DIR=$(KERNEL_SRC_DIR)
-else
-        KERNEL_BLD_DIR=$(KERNEL_BUILD_DIR)
-endif
-
-#ifneq ($(KERNELRELEASE),)
-#	include $(SUBDIRS)/mv_conf.mk
-#else
-#	include mv_conf.mk
-#endif
-SUPPORT_VANIR=y
-
-ifneq ("arm", "$(ARCH)")
-CONFIG_64BIT=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_64BIT | awk -F= '{print $$2}')
-CONFIG_REGPARM=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_REGPARM | awk -F= '{print $$2}')
-CONFIG_SUSE_KERNEL=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_SUSE_KERNEL | awk -F= '{print $$2}')
-endif
-
-ifeq ($(ARCH), )
-ifeq ($(strip $(CONFIG_64BIT)),y)
-	ARCH_TYPE=x86_64
-else
-	ARCH_TYPE=i386
-endif
-else
-	ARCH_TYPE=$(ARCH)
-endif
-
-ifeq ("powerpc", "$(ARCH)")
-	MV_CC     =  $(CROSS_COMPILE)gcc
-	MV_LD     =  $(CROSS_COMPILE)ld
-else
-ifeq ("arm", "$(ARCH)")
-	MV_CC	  =  $(CROSS_COMPILE)gcc
-	MV_LD	  =  $(CROSS_COMPILE)ld
-else
-	MV_CC     =  $(CROSS_COMPILE)$(CC)
-	MV_LD     =  $(CROSS_COMPILE)$(LD)
-endif
-endif
-
-export LD_LIBRARY_PATH
-core_com_objs := core/api/core_api.o  core/api/core_api_exp.o core/api/core_api_bbu.o core/api/core_api_flash.o core/api/core_api_led.o core/api/core_api_pd.o \
-		core/core/core_alarm.o core/core/core_device.o	 \
-	   core/core/core_error.o \
-	   core/core/core_event.o core/core/core_large_req.o \
-	   core/core/core_manager.o \
-	   core/core/core_protocol.o \
-	   core/core/core_resource.o \
-	   core/core/core_util.o  \
-	   core/pl/core_gpio.o \
-	   core/pl/core_rmw_flash.o \
-	   core/pm/core_pm.o \
-	   core/sas_base/sas_error.o core/sas_base/sas_handler.o \
-	   core/sas_base/sas_util.o core/sas_base/sas_init.o \
-	   core/sas_smp/core_expander.o \
-	   core/sata_base/core_sata.o core/sata_base/sata_error.o \
-	   core/scsi/core_sat.o \
-	   core/scsi/core_ses.o
-
-
-vanir_objs_$(SUPPORT_VANIR)   := product/vanir/core_spi.o   \
-			       product/vanir/core_hal.o \
-			       product/vanir/core_init.o
-
-odin_objs_$(SUPPORT_ODIN)   := 	product/odin/core_spi.o	\
-					   product/odin/core_hal.o \
-					   product/odin/core_init.o
-
-thor_objs_$(SUPPORT_THOR)   := 	product/thor/core_spi.o	\
-					   product/thor/core_hal.o \
-					   product/thor/core_init.o
-
-CORE_OBJS       := $(core_com_objs) $(odin_objs_y) $(thor_objs_y) $(vanir_objs_y)
-
-
-COMM_OBJS       := lib/common/com_util.o lib/common/com_u64.o      \
-		   lib/common/com_scsi.o lib/common/com_tag.o      \
-		   lib/common/com_sgd.o  lib/common/com_nvram.o    \
-		   linux/hba_priv.o	hba_sm/hba_api.o
-
-OSDEP_OBJS      := linux/linux_main.o    linux/hba_exp.o          \
-		   linux/hba_mod.o       linux/hba_timer.o        \
-		   linux/mv_os.o   linux/linux_iface.o
-
-# for partial source tree building
-include_dir := include  include/generic  include/icommon
-
-header_dirs     :=   $(include_dir)
-
-header_file_$(SUPPORT_VANIR) :=mv_config_vanir.h
-header_file_$(SUPPORT_ODIN) :=mv_config_odin.h
-header_file_$(SUPPORT_THOR) :=mv_config_thor.h
-
-ifeq ($(RAID_MODULE), y)
-LIBMV_OBJS	:=  $(COMM_OBJS) $(RAID_OBJS) $(CORE_OBJS)
-else
-LIBMV_OBJS	:=  $(COMM_OBJS) $(CORE_OBJS)
-endif
-
-HBA_OBJS        := $(OSDEP_OBJS) $(LIBMV_OBJS)
-
-ifneq ("arm", "$(ARCH)")
-INCLUDE_DIR     = -I$(KERNEL_BLD_DIR)/include                          \
-		  -I$(KERNEL_BLD_DIR)/include/scsi                     \
-		  -I$(KERNEL_BLD_DIR)/drivers/scsi                     \
-		  -I$(KERNEL_SRC_DIR)/include                          \
-		  -I$(KERNEL_SRC_DIR)/include/scsi                     \
-		  -I$(KERNEL_SRC_DIR)/drivers/scsi
-endif
-
-
-ifneq ($(KERNELRELEASE),)
-
-ifeq ($(SUPPORT_VANIR),y)
-obj-$(CONFIG_SCSI_MV_VANIR) += mv94xx.o
-#obj-m         :=  mv94xx.o
-mv94xx-objs   :=   $(HBA_OBJS)
-endif
-
-ifeq ($(SUPPORT_ODIN),y)
-obj-m         :=  mv64xx.o
-mv64xx-objs   :=   $(HBA_OBJS)
-endif
-
-ifeq ($(SUPPORT_THOR),y)
-obj-m         :=  mv61xx.o
-mv61xx-objs   :=   $(HBA_OBJS)
-endif
-
-clean-files   +=   Modules.symvers
-clean-files   +=   Module.symvers modules.order
-EXTRA_CFLAGS  :=   -I$(src)/include   -I$(src)/core  \
-		   -I$(src)/include   -I$(src)/core/api  \
-		   -I$(src)/include   -I$(src)/core/core  \
-		   -I$(src)/include   -I$(src)/core/pl  \
-		   -I$(src)/include   -I$(src)/core/pm  \
-		   -I$(src)/include   -I$(src)/core/sas_base  \
-		   -I$(src)/include   -I$(src)/core/sas_smp  \
-		   -I$(src)/include   -I$(src)/core/sata_base  \
-		   -I$(src)/include   -I$(src)/core/scsi  \
-		   -I$(src)/raid       -I$(src)/.               \
-		   -I$(src)/linux  -I$(src)/hba_sm -I$(src)/math            \
-                   -I$(src)/cache      -I$(src)/include/generic \
-		   -I$(src)/include/icommon
-
-ifeq ($(SUPPORT_VANIR),y)
-EXTRA_CFLAGS += -I$(src)/product/vanir
-endif
-
-ifeq ($(SUPPORT_ODIN),y)
-EXTRA_CFLAGS += -I$(src)/product/odin
-endif
-
-ifeq ($(SUPPORT_THOR),y)
-EXTRA_CFLAGS += -I$(src)/product/thor
-endif
-
-EXTRA_CFLAGS  +=  -D__MV_LINUX__ $(INCLUDE_DIR) -std=gnu99 #-D__MV_DEBUG__
-
-ifeq ($(CONFIG_64BIT), y)
-EXTRA_CFLAGS  +=   -D_64_SYS_
-else
-EXTRA_CFLAGS  +=   -D_32_LEGACY_
-endif
-
-EXTRA_CFLAGS  +=   -D_64_BIT_COMPILER
-
-EXTRA_CFLAGS  +=   -include $(src)/mv_config.h
-
-ifeq ($(RAID_MODULE), y)
-EXTRA_CFLAGS  +=   -DRAID_DRIVER=1
-endif
-
-ifeq ($(RAID6_MODULE), y)
-EXTRA_CFLAGS  +=   -DSUPPORT_RAID6=1
-endif
-
-ifeq ($(CACHE_MODULE), y)
-EXTRA_CFLAGS  +=   -DCACHE_MODULE_SUPPORT=1
-endif
-
-ifeq ($(SUPPORT_VANIR), y)
-EXTRA_CFLAGS  +=   -DPRODUCTNAME_VANIR
-endif
-
-ifeq ($(SUPPORT_ODIN), y)
-EXTRA_CFLAGS  +=   -DPRODUCTNAME_ODIN
-endif
-
-ifeq ($(SUPPORT_THOR), y)
-EXTRA_CFLAGS  +=   -DPRODUCTNAME_THOR
-endif
-
-ifeq ($(CONFIG_SUSE_KERNEL), y)
-EXTRA_CFLAGS  += -DIS_OPENSUSE_SLED_SLES=1
-else
-EXTRA_CFLAGS	+= -DIS_OPENSUSE_SLED_SLES=0
-endif
-
-EXTRA_CFLAGS  +=  -Wno-unused-variable
-EXTRA_CFLAGS  += -D__LEGACY_OSSW__=1 -D_OS_LINUX
-
-else
-
-# Why use SUBDIRS? for backward compatibility
-all:
-	$(MAKE) ARCH=$(ARCH_TYPE) CC=$(MV_CC) LD=$(MV_LD) CROSS_COMPILE=$(CROSS_COMPILE) V=$(V) -C $(KERNEL_BLD_DIR) SUBDIRS=`pwd` modules
-
-kbuild:
-	-@cat patch.kbuild | patch -p1 -N -d $(KERNEL_SRC_DIR)/drivers/scsi
-	@sh patch.sh $(KERNEL_SRC_DIR)/drivers/scsi a
-	@mkdir -p $(KERNEL_SRC_DIR)/drivers/scsi/mv
-	@cp -r * $(KERNEL_SRC_DIR)/drivers/scsi/mv
-	@cp -f Makefile.kbuild $(KERNEL_SRC_DIR)/drivers/scsi/mv/Makefile
-	@echo done.
-
-ukbuild:
-	-@cat patch.kbuild | patch -p1 -N -R -d $(KERNEL_SRC_DIR)/drivers/scsi
-	@sh patch.sh $(KERNEL_SRC_DIR)/drivers/scsi
-	@rm -rf $(KERNEL_SRC_DIR)/drivers/scsi/mv
-	@echo Patch has been successfully rewinded.
-
-clean:
-	$(MAKE) ARCH=$(ARCH_TYPE) CC=$(MV_CC) LD=$(MV_LD) CROSS_COMPILE=$(CROSS_COMPILE) V=$(V) -C $(KERNEL_BLD_DIR) SUBDIRS=`pwd` clean
-endif
--- a/drivers/scsi/vanir/Makefile.kbuild
+++ /dev/null
@@ -1,215 +0,0 @@
-#
-#
-# Note: This Makefile is for 2.6 kernel only, at present.
-#
-# V0.0.0.6 Ver.Make
-
-# default to build for the running kernel
-ifeq ("x", "x$(KERNEL_SRC)")
-	KERNEL_SRC=/lib/modules/$(shell uname -r)/build
-
-  ifeq ("powerpc", "$(ARCH)")
-	KERNEL_SRC=/root/katmai_29/lib/modules/2.6.29/build
-  endif
-
-  ifeq ("arm", "$(ARCH)")
-	KERNEL_SRC=/root/armadaxp/linux-2.6.35.9
-  endif
-
-endif
-
-# use KERNEL_SRC if not called by our driver disk maker
-ifeq ("x", "x$(KERNEL_SOURCE_DIR)")
-        KERNEL_SRC_DIR=$(KERNEL_SRC)
-else
-	KERNEL_SRC_DIR=$(KERNEL_SOURCE_DIR)
-endif
-
-ifeq ("x", "x$(KERNEL_BUILD_DIR)")
-	KERNEL_BLD_DIR=$(KERNEL_SRC_DIR)
-else
-        KERNEL_BLD_DIR=$(KERNEL_BUILD_DIR)
-endif
-
-include $(src)/mv_conf.mk
-
-ifeq ("xy", "x$(RAID_MODULE)")
-	LIB_TYPE=_raid_
-endif
-
-# KERNEL_VER := $(shell cat $(KERNEL_BLD_SRC)/include/linux/version.h | grep UTS_RELEASE | cut -c22-24 | head -n 1)
-
-ifneq ("arm", "$(ARCH)")
-# we may build for 32bit kernel on a 64bit system
-CONFIG_64BIT=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_64BIT | awk -F= '{print $$2}')
-CONFIG_REGPARM=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_REGPARM | awk -F= '{print $$2}')
-CONFIG_SUSE_KERNEL=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_SUSE_KERNEL | awk -F= '{print $$2}')
-endif
-
-ifeq ($(ARCH), )
-ifeq ($(strip $(CONFIG_64BIT)),y)
-	ARCH_TYPE=x86_64
-	RAID_LIB_NAME=libmv$(LIB_TYPE)64
-else
-	ARCH_TYPE=i386
-	ifeq ($(strip $(CONFIG_REGPARM)),y)
-		RAID_LIB_NAME=libmv$(LIB_TYPE)32
-	else
-		RAID_LIB_NAME=libmv$(LIB_TYPE)32_noregparm
-	endif
-endif
-else
-	ARCH_TYPE=$(ARCH)
-endif
-
-ifeq ("powerpc", "$(ARCH)")
-	MV_CC     =  $(CROSS_COMPILE)gcc
-	MV_LD     =  $(CROSS_COMPILE)ld
-else
-
-ifeq ("arm", "$(ARCH)")
-	MV_CC	  =  $(CROSS_COMPILE)gcc
-	MV_LD	  =  $(CROSS_COMPILE)ld
-else
-	MV_CC     =  $(CROSS_COMPILE)$(CC)
-	MV_LD     =  $(CROSS_COMPILE)$(LD)
-endif
-endif
-
-export LD_LIBRARY_PATH
-
-core_com_objs := core/api/core_api.o  core/api/core_api_exp.o core/api/core_api_bbu.o core/api/core_api_flash.o core/api/core_api_led.o core/api/core_api_pd.o core/api/core_api_test.o \
-		core/core/core_alarm.o core/core/core_device.o  core/core/core_err_inj.o	 \
-	   core/core/core_error.o \
-	   core/core/core_event.o core/core/core_large_req.o \
-	   core/core/core_manager.o core/core/core_multi_path.o \
-	   core/core/core_pd_map.o \
-	   core/core/core_protocol.o \
-	   core/core/core_resource.o \
-	   core/core/core_util.o  \
-	   core/pl/core_bbu.o  \
-	   core/pl/core_gpio.o \
-	   core/pl/core_i2c.o \
-	   core/pl/core_rmw_flash.o \
-	   core/pl/core_eeprom.o \
-	   core/pm/core_pm.o \
-	   core/sas_base/sas_error.o core/sas_base/sas_handler.o \
-	   core/sas_base/sas_util.o core/sas_base/sas_init.o \
-	   core/sas_smp/core_expander.o \
-	   core/sata_base/core_sata.o core/sata_base/sata_error.o \
-	   core/scsi/core_sat.o \
-	   core/scsi/core_ses.o
-
-
-vanir_objs_$(SUPPORT_VANIR)   := product/vanir/core_spi.o   \
-			       product/vanir/core_hal.o \
-			       product/vanir/core_init.o
-
-odin_objs_$(SUPPORT_ODIN)   := 	product/odin/core_spi.o	\
-					   product/odin/core_hal.o \
-					   product/odin/core_init.o
-
-
-ifeq ($(RAID_MODULE), y)
-vanir_objs_$(SUPPORT_VANIR) += product/vanir/pl_xor.o core/core/core_xor.o core/pl/core_swxor.o
-odin_objs_$(SUPPORT_ODIN) += product/odin/pl_xor.o core/core/core_xor.o core/pl/core_swxor.o
-endif
-
-CORE_OBJS       := $(core_com_objs) $(odin_objs_y) $(thor_objs_y) $(vanir_objs_y)
-
-
-COMM_OBJS       := lib/common/com_util.o lib/common/com_u64.o      \
-		   lib/common/com_scsi.o lib/common/com_tag.o      \
-		   lib/common/com_sgd.o  lib/common/com_nvram.o    \
-		   lib/common/com_roll.o  linux/hba_priv.o	hba_sm/cc.o hba_sm/hba_api.o
-
-OSDEP_OBJS      := linux/linux_main.o    linux/hba_exp.o          \
-		   linux/hba_mod.o       linux/hba_timer.o        \
-		   linux/mv_os.o   linux/linux_iface.o
-
-LIBMV_OBJS	:=  $(COMM_OBJS) $(CORE_OBJS)
-
-HBA_OBJS        := $(OSDEP_OBJS) $(LIBMV_OBJS)
-
-ifneq ("arm", "$(ARCH)")
-INCLUDE_DIR     = -I$(KERNEL_BLD_DIR)/include                          \
-		  -I$(KERNEL_BLD_DIR)/include/scsi                     \
-		  -I$(KERNEL_BLD_DIR)/drivers/scsi                     \
-		  -I$(KERNEL_SRC_DIR)/include                          \
-		  -I$(KERNEL_SRC_DIR)/include/scsi                     \
-		  -I$(KERNEL_SRC_DIR)/drivers/scsi
-endif
-ifeq ($(SUPPORT_VANIR), y)
-obj-$(CONFIG_SCSI_MV_94xx)      :=   mv94xx.o
-mv94xx-objs   :=   $(HBA_OBJS)
-endif
-ifeq ($(SUPPORT_ODIN), y)
-obj-$(CONFIG_SCSI_MV_64xx)      :=   mv64xx.o
-mv64xx-objs   :=   $(HBA_OBJS)
-endif
-clean-files   +=   Modules.symvers
-clean-files   +=   Module.symvers
-EXTRA_CFLAGS  :=   -I$(src)/include   -I$(src)/core  \
-		   -I$(src)/include   -I$(src)/core/api  \
-		   -I$(src)/include   -I$(src)/core/core  \
-		   -I$(src)/include   -I$(src)/core/pl  \
-		   -I$(src)/include   -I$(src)/core/pm  \
-		   -I$(src)/include   -I$(src)/core/sas_base  \
-		   -I$(src)/include   -I$(src)/core/sas_smp  \
-		   -I$(src)/include   -I$(src)/core/sata_base  \
-		   -I$(src)/include   -I$(src)/core/scsi  \
-		   -I$(src)/raid       -I$(src)/.               \
-		   -I$(src)/linux  -I$(src)/hba_sm -I$(src)/math            \
-                   -I$(src)/cache      -I$(src)/include/generic \
-		   -I$(src)/include/icommon
-
-ifeq ($(SUPPORT_VANIR),y)
-EXTRA_CFLAGS += -I$(src)/product/vanir
-endif
-
-ifeq ($(SUPPORT_ODIN),y)
-EXTRA_CFLAGS += -I$(src)/product/odin
-endif
-
-
-EXTRA_CFLAGS  +=  -D__MV_LINUX__ $(INCLUDE_DIR) -std=gnu99 #-D__MV_DEBUG__
-
-ifeq ($(CONFIG_64BIT), y)
-EXTRA_CFLAGS  +=   -D_64_SYS_
-else
-EXTRA_CFLAGS  +=   -D_32_LEGACY_
-endif
-
-EXTRA_CFLAGS  +=   -D_64_BIT_COMPILER
-
-EXTRA_CFLAGS  +=   -include $(src)/mv_config.h
-
-ifeq ($(RAID_MODULE), y)
-EXTRA_CFLAGS  +=   -DRAID_DRIVER=1
-endif
-
-ifeq ($(RAID6_MODULE), y)
-EXTRA_CFLAGS  +=   -DSUPPORT_RAID6=1
-endif
-
-ifeq ($(CACHE_MODULE), y)
-EXTRA_CFLAGS  +=   -DCACHE_MODULE_SUPPORT=1
-endif
-
-ifeq ($(SUPPORT_VANIR), y)
-EXTRA_CFLAGS  +=   -DPRODUCTNAME_VANIR
-endif
-
-ifeq ($(SUPPORT_ODIN), y)
-EXTRA_CFLAGS  +=   -DPRODUCTNAME_ODIN
-endif
-
-
-ifeq ($(CONFIG_SUSE_KERNEL), y)
-EXTRA_CFLAGS  += -DIS_OPENSUSE_SLED_SLES=1
-else
-EXTRA_CFLAGS	+= -DIS_OPENSUSE_SLED_SLES=0
-endif
-
-EXTRA_CFLAGS  +=  -Wno-unused-variable
-EXTRA_CFLAGS  += -D__LEGACY_OSSW__=1 -D_OS_LINUX
--- a/drivers/scsi/vanir/Makefile.xen
+++ /dev/null
@@ -1,26 +0,0 @@
-%.s: %-xen.c FORCE
-	$(call if_changed_dep,cc_s_c)
-
-%.i: %-xen.c FORCE
-	$(call if_changed_dep,cc_i_c)
-
-%.symtypes : %-xen.c FORCE
-	$(call cmd,cc_symtypes_c)
-
-%.o: %-xen.c FORCE
-	$(call cmd,force_checksrc)
-	$(call if_changed_rule,cc_o_c)
-
-$(xen-single-used-m): %.o: %-xen.c FORCE
-	$(call cmd,force_checksrc)
-	$(call if_changed_rule,cc_o_c)
-	@{ echo $(@:.o=.ko); echo $@; } > $(MODVERDIR)/$(@F:.o=.mod)
-
-%.lst: %-xen.c FORCE
-	$(call if_changed_dep,cc_lst_c)
-
-%.s: %-xen.S FORCE
-	$(call if_changed_dep,as_s_S)
-
-%.o: %-xen.S FORCE
-	$(call if_changed_dep,as_o_S)
--- a/drivers/scsi/vanir/core/api/core_api.c
+++ /dev/null
@@ -1,941 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "com_flash.h"
-#include "core_manager.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "com_struct.h"
-#include "com_api.h"
-#include "com_extern.h"
-#include "com_error.h"
-#include "core_console.h"
-#include "core_util.h"
-#include "hba_inter.h"
-#include "core_sas.h"
-#include "core_expander.h"
-#include "core_api.h"
-#include "core_gpio.h"
-#include "core_spi.h"
-#include "core_alarm.h"
-
-MV_U8 api_verify_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_U8 ret;
-
-	switch (req->Cdb[0]) {
-	case SCSI_CMD_INQUIRY:
-		ret = core_api_inquiry(root->core, req);
-		break;
-	case APICDB0_ADAPTER: {
-        switch (req->Cdb[1]) {
-            case APICDB1_ADAPTER_BBU_INFO:
-                ret = mv_get_bbu_info(root->core, req);
-                break;
-            case APICDB1_ADAPTER_BBU_SET_THRESHOLD:
-                ret = mv_set_bbu_threshold(root->core, req);
-                break;
-            case APICDB1_ADAPTER_BBU_POWER_CHANGE:
-                ret = mv_bbu_power_change(root->core, req);
-                break;
-	    default:
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		ret = MV_QUEUE_COMMAND_RESULT_FINISHED;
-		break;
-		}
-	}
-		break;
-	case APICDB0_PD:
-		ret = core_pd_command(root->core, req);
-		break;
-	case APICDB0_FLASH:
-		ret = core_flash_command(root->core, req);
-		break;
-	case APICDB0_BUZZER:
-		ret = core_api_alarm_command(root->core, req);
-		break;
-	case APICDB0_IOCONTROL:
-		ret = core_api_disk_io_control(root->core, req);
-		break;
-	case APICDB0_PASS_THRU_CMD_SCSI:
-	case APICDB0_PASS_THRU_CMD_SCSI_16:
-	case APICDB0_PASS_THRU_CMD_ATA:
-		ret = core_pass_thru_send_command(root->core, req);
-		break;
-	case SCSI_CMD_RCV_DIAG_RSLT:
-	case SCSI_CMD_SND_DIAG:
-		ret = core_ses_command(root->core, req);
-		break;
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		if ((req->Cdb[1] == CDB_CORE_MODULE)
-			&& (req->Cdb[2] == CDB_CORE_SHUTDOWN)) {
-			core_abort_all_running_requests(root->core);
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			ret = MV_QUEUE_COMMAND_RESULT_FINISHED;;
-		break;
-		}
-	default:
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		ret = MV_QUEUE_COMMAND_RESULT_FINISHED;
-		break;
-	}
-
-        return ret;
-}
-
-MV_U8 core_get_disk_info(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-	POS_disk_info os_disk_p;
-	domain_base *p_base;
-	domain_device *dev;
-	MV_U16 id;
-	MV_PVOID buf_ptr = core_map_data_buffer(req);
-
-	if (buf_ptr == NULL ||
-		req->Data_Transfer_Length < sizeof(OS_disk_info)) {
-
-		core_unmap_data_buffer(req);
-		return REQ_STATUS_INVALID_REQUEST;
-	}
-	MV_ZeroMemory(buf_ptr, req->Data_Transfer_Length);
-
-	id = get_id_by_targetid_lun(core, req->Cdb[2], req->Cdb[3]);
-
-	p_base = get_device_by_id(&core->lib_dev, id);
-	if (!p_base) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_HD_ID;
-		core_unmap_data_buffer(req);
-		return REQ_STATUS_ERROR_WITH_SENSE;
-	}
-	os_disk_p = (POS_disk_info)buf_ptr;
-	os_disk_p->queue_depth = p_base->queue_depth;
-
-	if (p_base->type == BASE_TYPE_DOMAIN_DEVICE) {
-		dev = (domain_device *)p_base;
-		if (IS_STP_OR_SATA(dev))
-			os_disk_p->disk_type = DISK_TYPE_SATA;
-		else
-			os_disk_p->disk_type = DISK_TYPE_SAS;
-	}
-
-	return REQ_STATUS_SUCCESS;
-}
-
-MV_U8 core_set_disk_queue_depth(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-	POS_disk_info os_disk_p;
-	domain_base *p_base;
-	domain_device *dev;
-	MV_U16 id;
-	MV_PVOID buf_ptr = core_map_data_buffer(req);
-
-	if (buf_ptr == NULL ||
-		req->Data_Transfer_Length < sizeof(OS_disk_info)) {
-
-		core_unmap_data_buffer(req);
-		return REQ_STATUS_INVALID_REQUEST;
-	}
-
-	id = __MAKE_DEV_ID(req->Cdb[2], req->Cdb[3]);
-	p_base = get_device_by_id(&core->lib_dev, id);
-
-	if (!p_base)
-		goto core_set_disk_queue_depth_id_error;
-
-	os_disk_p = (POS_disk_info)buf_ptr;
-
-	if (os_disk_p->queue_depth == 0)
-		goto core_set_disk_queue_depth_param_error;
-
-	switch (p_base->type) {
-	case BASE_TYPE_DOMAIN_DEVICE:
-		dev = (domain_device *)p_base;
-		if (IS_SSP(dev)) {
-			if (os_disk_p->queue_depth > CORE_SAS_DISK_QUEUE_DEPTH) {
-				goto core_set_disk_queue_depth_param_error;
-			}
-		}
-		else if (IS_STP_OR_SATA(dev) || IS_ATAPI(dev)) {
-			if (os_disk_p->queue_depth > 32) {
-				goto core_set_disk_queue_depth_param_error;
-			}
-		}
-		else {
-			goto core_set_disk_queue_depth_id_error;
-		}
-		break;
-	case BASE_TYPE_DOMAIN_EXPANDER:
-	case BASE_TYPE_DOMAIN_ENCLOSURE:
-	case BASE_TYPE_DOMAIN_PM:
-		if (os_disk_p->queue_depth > 1)
-			goto core_set_disk_queue_depth_param_error;
-		break;
-	default:
-		goto core_set_disk_queue_depth_id_error;
-		break;
-	}
-
-	p_base->queue_depth = os_disk_p->queue_depth;
-	core_unmap_data_buffer(req);
-	return REQ_STATUS_SUCCESS;
-
-core_set_disk_queue_depth_id_error:
-	if (req->Sense_Info_Buffer != NULL)
-		((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_HD_ID;
-	core_unmap_data_buffer(req);
-	return REQ_STATUS_ERROR_WITH_SENSE;
-
-core_set_disk_queue_depth_param_error:
-	if (req->Sense_Info_Buffer != NULL)
-		((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_PARAMETER;
-	core_unmap_data_buffer(req);
-	return REQ_STATUS_ERROR_WITH_SENSE;
-}
-
-MV_U8 core_api_disk_io_control(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-
-	switch (req->Cdb[1]) {
-	case APICDB1_GET_OS_DISK_INFO:
-		req->Scsi_Status = core_get_disk_info(core_p, req);
-		break;
-	case APICDB1_SET_OS_DISK_QUEUE_DEPTH:
-		req->Scsi_Status = core_set_disk_queue_depth(core_p, req);
-		break;
-	default:
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		break;
-	}
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-/* return MV_QUEUE_COMMAND_RESULT_XXX */
-MV_U8 core_api_inquiry(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-	MV_PVOID buf_ptr = core_map_data_buffer(req);
-	MV_U32 length;
-
-	MV_ZeroMemory(buf_ptr, req->Data_Transfer_Length);
-
-	if (req->Cdb[1] & CDB_INQUIRY_EVPD) {
-		MV_U8 MV_INQUIRY_VPD_PAGE0_DATA[6] = {0x00, 0x00, 0x00, 0x02, 0x00, 0x80};
-		MV_U8 MV_INQUIRY_VPD_PAGE83_DATA[16] = {
-			0x00, 0x83, 0x00, 0x0C, 0x01, 0x02, 0x00, 0x08,
-			0x00, 0x50, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00};
-		MV_U32 tmpLen = 0;
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-		/* Shall return the specific page of Vital Production Data */
-		switch (req->Cdb[2]) {
-		case 0x00:	/* Supported VPD pages */
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-				tmpLen = MV_MIN(req->Data_Transfer_Length, VPD_PAGE0_VIRTUALD_SIZE);
-				MV_CopyMemory(buf_ptr, MV_INQUIRY_VPD_PAGE0_VIRTUALD_DATA, tmpLen);
-			}
-
-			break;
-		case 0x80:	/* Unit Serial Number VPD Page */
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-				tmpLen = MV_MIN(req->Data_Transfer_Length, VPD_PAGE80_VIRTUALD_SIZE);
-				MV_CopyMemory(buf_ptr, MV_INQUIRY_VPD_PAGE80_VIRTUALD_DATA, tmpLen);
-			}
-
-			break;
-		case 0x83:	/* Device Identification VPD Page */
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-				tmpLen = MV_MIN(req->Data_Transfer_Length, VPD_PAGE83_VIRTUALD_SIZE);
-				MV_CopyMemory(buf_ptr, MV_INQUIRY_VPD_PAGE83_VIRTUALD_DATA, tmpLen);
-			}
-			break;
-		default:
-			req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-			prot_fill_sense_data(req, SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB);
-			break;
-		}
-		req->Data_Transfer_Length = tmpLen;
-	} else {
-		/* Standard inquiry */
-		if (req->Cdb[2]!=0) {
-			req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-			prot_fill_sense_data(req, SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB);
-		} else {
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-				length = MV_MIN(req->Data_Transfer_Length, VIRTUALD_INQUIRY_DATA_SIZE);
-				MV_CopyMemory(buf_ptr, MV_INQUIRY_VIRTUALD_DATA, length);
-				req->Data_Transfer_Length = length;
-				req->Scsi_Status = REQ_STATUS_SUCCESS;
-			}
-		}
-        }
-
-        core_unmap_data_buffer(req);
-        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-/* return MV_QUEUE_COMMAND_RESULT_XXX */
-MV_U8 core_api_read_capacity_16(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-	domain_device *device = NULL;
-	MV_LBA max_lba;
-	MV_U32 block_length;
-	MV_PU32 p_buffer;
-
-#ifndef SECTOR_SIZE
-	#define SECTOR_SIZE	512
-#endif
-
-	if ((req->Cdb[1] & 0x1f)!=SCSI_CMD_SAI_READ_CAPACITY_16) {
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	p_buffer = (MV_PU32)core_map_data_buffer(req);
-	if (p_buffer == NULL || req->Data_Transfer_Length < 12) {
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	max_lba = device->max_lba;
-	block_length = SECTOR_SIZE;
-	p_buffer[0] = MV_CPU_TO_BE32(max_lba.parts.high);
-	p_buffer[1] = MV_CPU_TO_BE32(max_lba.parts.low);
-	p_buffer[2] = MV_CPU_TO_BE32(block_length);
-
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-/* return MV_QUEUE_COMMAND_RESULT_XXX */
-MV_U8 core_api_read_capacity(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-	domain_device *device = NULL;
-	MV_LBA max_lba;
-	MV_U32 block_length;
-	MV_PU32 p_buffer;
-
-#ifndef SECTOR_SIZE
-	#define SECTOR_SIZE	512
-#endif
-
-	if ((req->Cdb[8] & MV_BIT(1)) == 0) {
-		if (req->Cdb[2] || req->Cdb[3] || req->Cdb[4] || req->Cdb[5]) {
-			req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		}
-	}
-
-	p_buffer = (MV_PU32)core_map_data_buffer(req);
-	if (p_buffer == NULL || req->Data_Transfer_Length < 8) {
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	max_lba = device->max_lba;
-	block_length = SECTOR_SIZE;
-
-	if(max_lba.parts.high != 0)
-		max_lba.parts.low = 0xFFFFFFFF;
-	p_buffer[0] = MV_CPU_TO_BE32(max_lba.parts.low);
-	p_buffer[1] = MV_CPU_TO_BE32(block_length);
-
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-/* return MV_QUEUE_COMMAND_RESULT_XXX */
-MV_U8 core_api_report_lun(MV_PVOID core_p, PMV_Request req)
-{
-	MV_U32 alloc_len, lun_list_len;
-	MV_PU8 buf_ptr;
-
-	alloc_len = ((MV_U32)(req->Cdb[6] << 24)) |
-				((MV_U32)(req->Cdb[7] << 16)) |
-				((MV_U32)(req->Cdb[8] << 8)) |
-				((MV_U32)(req->Cdb[9]));
-
-	buf_ptr = core_map_data_buffer(req);
-
-	/* allocation length should not less than 16 bytes */
-	if (alloc_len < 16 || buf_ptr == NULL) {
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	MV_ZeroMemory(buf_ptr, alloc_len);
-
-	lun_list_len = 16;
-	if (alloc_len >= 24 && req->Data_Transfer_Length >= 24)
-		buf_ptr[23] = 0x01;
-
-	if (req->Data_Transfer_Length >= 4) {
-		buf_ptr[0] = (MV_U8)((lun_list_len & 0xFF000000) >> 24);
-		buf_ptr[1] = (MV_U8)((lun_list_len & 0x00FF0000) >> 16);
-		buf_ptr[2] = (MV_U8)((lun_list_len & 0x0000FF00) >> 8);
-		buf_ptr[3] = (MV_U8)(lun_list_len & 0x000000FF);
-	}
-
-	core_unmap_data_buffer(req);
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-
-MV_VOID
-core_get_pm_information(core_extension *core, domain_pm *pm,
-PPM_Info pm_info)
-{
-	domain_port *port = pm->base.port;
-	MV_U8 i;
-
-	pm_info->Link.Self.DevID = pm->base.id;
-	if (pm->state != PM_STATE_DONE) {
-		pm_info->Link.Self.DevType = DEVICE_TYPE_NONE;
-		return;
-	}
-
-	for(i=0;i<pm->base.root->phy_num;i++){
-		if(port->phy_map&MV_BIT(i))
-			break;
-	}
-
-	pm_info->Link.Self.DevType = DEVICE_TYPE_PM;
-	pm_info->Link.Self.PhyCnt = 1;
-	pm_info->Link.Self.PhyID[0] = i;
-	pm_info->Link.Parent.DevType = DEVICE_TYPE_PORT;
-	pm_info->Link.Parent.DevID = 0;
-	pm_info->Link.Parent.PhyCnt = 1;
-	pm_info->Link.Parent.PhyID[0] = i+(MV_U8)pm->base.root->base_phy_num;
-	pm_info->Link.Parent.EnclosureID = 0xFFFF;
-	pm_info->Link.Self.EnclosureID = 0xFFFF;
-
-	pm_info->VendorId = pm->vendor_id;
-	pm_info->DeviceId = pm->device_id;
-	pm_info->ProductRevision = pm->product_rev;
-	pm_info->PMSpecRevision = pm->spec_rev;
-
-	pm_info->NumberOfPorts = pm->num_ports;
-}
-
-MV_VOID
-core_get_pm_info(MV_PVOID extension, MV_PVOID buffer)
-{
-	core_extension *core = (core_extension *)extension;
-	MV_U16 start_id = 0, end_id = 0;
-	domain_base *base = NULL;
-	domain_pm *pm = NULL;
-	PPM_Info pm_info;
-	PPM_Info_Request pm_req;
-	PRequestHeader header = NULL;
-	MV_U16 i;
-
-	pm_req = (PPM_Info_Request)buffer;
-	header = &pm_req->header;
-
-	if (header->requestType == REQUEST_BY_RANGE) {
-		start_id = header->startingIndexOrId;
-		end_id = MAX_ID;
-	} else if (header->requestType == REQUEST_BY_ID) {
-		start_id = header->startingIndexOrId;
-		end_id = header->startingIndexOrId;
-	}
-	pm_info = pm_req->pmInfo;
-	header->numReturned = 0;
-	header->nextStartingIndex = NO_MORE_DATA;
-
-	for (i = start_id; i <= end_id; i++) {
-		base = get_device_by_id(&core->lib_dev, i);
-		if ((base != NULL)&&(base->type == BASE_TYPE_DOMAIN_PM)) {
-			pm = (domain_pm *)base;
-			core_get_pm_information( core, pm, pm_info );
-		} else {
-			pm_info->Link.Self.DevID = i;
-			pm_info->Link.Self.DevType = DEVICE_TYPE_NONE;
-		}
-
-		if (pm_info->Link.Self.DevType != DEVICE_TYPE_NONE) {
-			header->numReturned++;
-			pm_info++;
-			if ((header->requestType == REQUEST_BY_RANGE) &&
-				(header->numReturned == header->numRequested)) {
-				header->nextStartingIndex = i+1;
-				break;
-			}
-		}
-	}
-}
-
-MV_U8
-core_pd_request_get_pm_info(core_extension * core_p, PMV_Request req)
-{
-	PPM_Info pm_info = NULL;
-	domain_base *base;
-        MV_PVOID buf_ptr = core_map_data_buffer(req);
-	PPM_Info_Request pm_req = (PPM_Info_Request)buf_ptr;
-
-	if (buf_ptr == NULL ||
-		req->Data_Transfer_Length < sizeof(PM_Info_Request)) {
-
-                core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (pm_req->header.requestType == REQUEST_BY_RANGE &&
-		pm_req->header.startingIndexOrId == 0){
-		pm_req->header.startingIndexOrId = 0;
-	} else if (pm_req->header.startingIndexOrId >= MAX_ID) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_PM_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-                core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	core_get_pm_info(core_p, buf_ptr);
-	if (pm_req->header.requestType == REQUEST_BY_ID &&
-		pm_req->header.numReturned == 0) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_PM_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-                core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-        core_unmap_data_buffer(req);
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-
-
-MV_U8 core_pd_request_bsl_dump(core_extension * core_p, PMV_Request req)
-{
-	req->Scsi_Status = REQ_STATUS_ERROR;
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-core_management_command_handler BASEATTR core_pd_cmd_handler[APICDB1_PD_MAX] =
-{
-	core_pd_request_get_hd_info,
-	core_pd_request_get_expander_info,
-	core_pd_request_get_pm_info,
-	core_pd_request_get_hd_config,
-	core_pd_request_set_hd_config,
-	core_pd_request_bsl_dump,
-	core_pd_request_get_enclosure_info,
-	NULL,
-	core_pd_request_get_hd_status,
-	core_pd_request_get_hd_info_ext
-};
-
-MV_U8 core_pd_command(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-
-	if ( req->Cdb[1] >= APICDB1_PD_MAX )
-	{
-		req->Scsi_Status = REQ_STATUS_INVALID_PARAMETER;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-	if (core_pd_cmd_handler[req->Cdb[1]] == NULL)
-	{
-		req->Scsi_Status = REQ_STATUS_INVALID_PARAMETER;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-	return core_pd_cmd_handler[req->Cdb[1]](core, req);
-}
-
-void Core_GetDeviceId(MV_PVOID pModule,MV_U16 begin_id,PDevice_Index pDeviceIndex)
-{
-	core_extension *core;
-	MV_U16 index;
-	domain_base *base = NULL;
-	domain_device *device = NULL;
-	core = (core_extension *)HBA_GetModuleExtension(pModule, MODULE_CORE);
-	pDeviceIndex->end = MV_FALSE;
-	pDeviceIndex->device_id = 0xFFFF;
-	pDeviceIndex->index = 0xFFFF;
-	index = begin_id;
-	for(;index<MAX_ID;index++)
-	{
-		base = get_device_by_id(&core->lib_dev, index);
-		if ((base != NULL) && (base->type == BASE_TYPE_DOMAIN_DEVICE)) {
-			device = (domain_device *)base;
-			if((device->status & DEVICE_STATUS_FUNCTIONAL)&&(IS_HDD(device))&&(!IS_ATAPI(device)))
-			{
-				pDeviceIndex->device_id = device->base.id ;
-				pDeviceIndex->index = index;
-				break;
-			}
-		}
-	}
-	if(index>=MAX_ID)
-		pDeviceIndex->end = MV_TRUE;
-	return;
-}
-
-PPassThorugh_Config pConfig;
-MV_U32 Data_Length;
-
-MV_U32
-core_pass_thru_cal_correct_length (
-	MV_U32 length
-)
-{
-	if( length & 0x80000000)
-		return (0xFFFFFFFF - length )+2;
-	else
-		return 0;
-}
-
-void
-core_pass_thru_callback(MV_PVOID root_p, MV_Request *req)
-{
-	MV_Request *org_req = req->Org_Req;
-	PSCSI_REQUEST_BLOCK Srb = (PSCSI_REQUEST_BLOCK)org_req->Org_Req;
-	pl_root *root = (pl_root *)root_p;
-	PHBA_Extension hba;
-	core_extension *core = (core_extension *)root->core;
-	MV_U32 length;
-	MV_U32 reg[3];
-	MV_U16 deviceId;
-	MV_U8 testsize;
-        MV_PVOID buf_ptr, new_buf_ptr;
-
-        hba = (PHBA_Extension)HBA_GetModuleExtension(core, MODULE_HBA);
-
-	if (req->Scsi_Status == REQ_STATUS_PENDING) {
-		MV_DASSERT(MV_FALSE);
-		return;
-	}
-        org_req->Scsi_Status = req->Scsi_Status;
-
-        buf_ptr = core_map_data_buffer(org_req);
-
-	if (org_req->Cdb[0] == APICDB0_PASS_THRU_CMD_SCSI ||
-		org_req->Cdb[0] == APICDB0_PASS_THRU_CMD_SCSI_16) {
-		switch (org_req->Cdb[0]) {
-		case APICDB0_PASS_THRU_CMD_SCSI:
-			MV_CopyMemory(&org_req->Cdb[4], req->Cdb, 12);
-			break;
-		case APICDB0_PASS_THRU_CMD_SCSI_16:
-			MV_CopyMemory(buf_ptr, req->Cdb, 16);
-			break;
-		default:
-			break;
-		}
-
-		if (req->Cdb[0] == SCSI_CMD_READ_LONG_10) {
-			if (req->Sense_Info_Buffer != NULL) {
-				((MV_PU8)org_req->Sense_Info_Buffer)[0] = 0;
-				length = (((MV_PU8)req->Sense_Info_Buffer)[3] << 24)|
-					(((MV_PU8)req->Sense_Info_Buffer)[4] << 16)|
-					(((MV_PU8)req->Sense_Info_Buffer)[5] << 8)|
-					((MV_PU8)req->Sense_Info_Buffer)[6];
-
-				if (((MV_PU8)req->Sense_Info_Buffer)[2] == 0x25) {
-					length = core_pass_thru_cal_correct_length(length);
-
-	                            if (org_req->Cdb[0] == APICDB0_PASS_THRU_CMD_SCSI_16 ||
-                                          org_req->Data_Transfer_Length < MAX_PASS_THRU_DATA_BUFFER_SIZE) {
-		                            org_req->Data_Transfer_Length = length;
-	                            }
-					goto HBACallback;
-				}
-			}
-		}
-	}
-
-HBACallback:
-	req->Data_Buffer = NULL;
-	req->Data_Transfer_Length = 0;
-	((core_context *)(req->Context[MODULE_CORE]))->buf_wrapper = NULL;
-        SGTable_Init(&req->SG_Table, 0);
-
-       core_unmap_data_buffer(org_req);
-	core_queue_completed_req(root->core, org_req);
-}
-
-MV_U8
-core_pass_thru_send_scsi_command(
-	IN core_extension *core,
-	IN PMV_Request req)
-{
-	PSCSI_REQUEST_BLOCK Srb = (PSCSI_REQUEST_BLOCK)req->Org_Req;
-	MV_U16 device_id;
-	domain_base *base = NULL;
-	PMV_SG_Table pSGTable;
-	MV_U32 lengthLocation;
-	MV_Request *new_req = NULL;
-	MV_PVOID buf_ptr, new_buf_ptr;
-
-	if (req == NULL) {
-		MV_ASSERT(MV_FALSE);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	device_id = req->Cdb[2] | (req->Cdb[3] << 8);
-	base = get_device_by_id(&core->lib_dev, device_id);
-
-	if (base == NULL) {
-		req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	buf_ptr = core_map_data_buffer(req);
-
-	if (req->Cdb[0] == APICDB0_PASS_THRU_CMD_SCSI_16 &&
-		(buf_ptr == NULL || req->Data_Transfer_Length < 16)) {
-
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	new_req = get_intl_req_resource(base->root, 0);
-	if(new_req == NULL){
-		CORE_DPRINT(("ERROR: No more free internal requests. Request aborted.\n"));
-		core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-	}
-
-
-	if (req->Cdb[0] == APICDB0_PASS_THRU_CMD_SCSI_16 ||
-                req->Data_Transfer_Length < MAX_PASS_THRU_DATA_BUFFER_SIZE)
-		Data_Length = req->Data_Transfer_Length;
-
-	switch (req->Cdb[1]) {
-	case APICDB1_SCSI_NON_DATA:
-		new_req->Cmd_Flag = 0;
-		break;
-	case APICDB1_SCSI_PIO_IN:
-		new_req->Cmd_Flag = CMD_FLAG_PIO | CMD_FLAG_DATA_IN;
-		break;
-	case APICDB1_SCSI_PIO_OUT:
-		new_req->Cmd_Flag = CMD_FLAG_PIO;
-		break;
-	default:
-		break;
-	}
-
-	new_req->Device_Id = device_id;
-
-	if (req->Cdb[0] == APICDB0_PASS_THRU_CMD_SCSI_16) {
-		MV_CopyMemory(new_req->Cdb, buf_ptr, 16);
-		if (req->Data_Transfer_Length > 16) {
-			new_req->Data_Buffer = (MV_PVOID)&((MV_PU8)buf_ptr)[16];
-			new_req->Data_Transfer_Length =
-				req->Data_Transfer_Length - 16;
-			((core_context *)new_req->Context[MODULE_CORE])->buf_wrapper =
-				((core_context *)req->Context[MODULE_CORE])->buf_wrapper;
-			MV_CopyPartialSGTable(
-				&new_req->SG_Table,
-				&req->SG_Table,
-				16,
-				req->SG_Table.Byte_Count - 16
-				);
-		}
-	} else {
-		MV_CopyMemory(new_req->Cdb, &req->Cdb[4], 12);
-		new_req->Data_Buffer = req->Data_Buffer;
-		new_req->Data_Transfer_Length = req->Data_Transfer_Length;
-		((core_context *)new_req->Context[MODULE_CORE])->buf_wrapper =
-			((core_context *)req->Context[MODULE_CORE])->buf_wrapper;
-
-		if (req->Data_Transfer_Length > 0) {
-			MV_CopyPartialSGTable(
-				&new_req->SG_Table,
-				&req->SG_Table,
-				0,
-				req->SG_Table.Byte_Count
-				);
-		}
-	}
-
-	new_req->Completion = (void(*)(MV_PVOID,PMV_Request))core_pass_thru_callback;
-	new_req->Org_Req = req;
-
-	core_append_request(base->root, new_req);
-
-	core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-MV_U8
-core_pass_thru_send_command(
-	IN MV_PVOID *core_p,
-	IN PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-	MV_U8 ret;
-
-	switch(req->Cdb[0]) {
-	case APICDB0_PASS_THRU_CMD_SCSI:
-	case APICDB0_PASS_THRU_CMD_SCSI_16:
-		ret = core_pass_thru_send_scsi_command(core, req);
-	        break;
-	default:
-		req->Scsi_Status = REQ_STATUS_INVALID_PARAMETER;
-		ret = MV_QUEUE_COMMAND_RESULT_FINISHED;
-		break;
-	}
-	return ret;
-}
-
-#define VersionLen 16
-MV_BOOLEAN is_old_version_format(MV_PU8 buff)
-{
-	MV_U8 i = 0, dot_count = 0;
-
-	for (i =0; i < VersionLen; i++) {
-		if(buff[i] == '.')
-			dot_count++;
-	}
-	if (dot_count == 3)
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-}
-void Core_Flash_BIOS_Version(MV_PVOID extension,PMV_Request req)
-{
-	AdapterInfo	adapter_info;
-	MV_U32	flash_start_addr,Size;
-	MV_U8	buff[VersionLen];
-	PAdapter_Info data;
-	core_extension *core = (core_extension *)extension;
-	MV_U8 i=0,j=0,temp=0,dot[4]={0,0,0,0};
-	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(core,MODULE_HBA);
-	MV_PVOID buf_ptr = core_map_data_buffer(req);
-
-	if (buf_ptr == NULL ||
-		req->Data_Transfer_Length < sizeof(AdapterInfo)) {
-
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return;
-	}
-
-	adapter_info.bar[FLASH_BAR_NUMBER] = pHBA->Base_Address[FLASH_BAR_NUMBER];
-	if (OdinSPI_Init( &adapter_info )==-1)
-		CORE_DPRINT(("Core_Flash_Bin: FLASH Init FAILED!\n"));
-
-	flash_start_addr=0x00000002;
-	Size=VersionLen;
-
-	OdinSPI_ReadBuf(&adapter_info, flash_start_addr, buff, Size);
-	data =(PAdapter_Info)buf_ptr;
-
-	if ((*(MV_PU32)(&buff[0])!=0xffffffff)||(*(MV_PU32)(&buff[4])!=0xffffffff)) {
-		if(is_old_version_format(buff)){
-			data->BIOSVersion.MajorVersion = buff[0]-0x30;
-			data->BIOSVersion.MinorVersion = buff[2]-0x30;
-			data->BIOSVersion.RevisionNumber  = buff[4]-0x30;
-			data->BIOSVersion.BuildNumber  = (buff[6]-0x30)*10+(buff[7]-0x30);
-
-			/* 1. dot check */
-			for(i = 0;i < VersionLen;i++) {
-				if(buff[i]=='.')
-					dot[j++]=i;
-			}
-			/* 2. fill number */
-			for(i = 0;i < dot[0]; i++){
-				if((dot[0]-i)>1)
-					temp += (buff[i]-0x30)*10;
-				else
-					break;
-			}
-			temp += (buff[i]-0x30);
-			data->BIOSVersion.MajorVersion = temp;
-			temp = 0;
-			for(i = dot[0]+1;i < dot[1]; i++){
-				if ((dot[1]-i)>1)
-					temp += (buff[i]-0x30)*10;
-				else
-					break;
-			}
-			temp += (buff[i]-0x30);
-			data->BIOSVersion.MinorVersion = temp;
-			temp =0;
-			for (i = dot[1]+1; i < dot[2]; i++) {
-				if((dot[2]-i)>1)
-					temp += (buff[i]-0x30)*10;
-				else
-					break;
-			}
-			temp += (buff[i]-0x30);
-			data->BIOSVersion.RevisionNumber = temp;
-			temp =0;
-			for (i = dot[2]+1;i < VersionLen; i++) {
-				if(buff[i]!='0'&&buff[i]!='1'&&buff[i]!='2'&&buff[i]!='3'&&buff[i]!='4'&&buff[i]!='5'
-					&&buff[i]!='6'&&buff[i]!='7'&&buff[i]!='8'&&buff[i]!='9'){
-					dot[3]=i;
-					break;
-				}
-			}
-			for (i = dot[2]+1; i < dot[3]; i++) {
-				if((dot[3]-i)>1)
-					temp += (buff[i]-0x30)*10;
-				else
-					break;
-			}
-			temp += (buff[i]-0x30);
-			data->BIOSVersion.BuildNumber = temp;
-		}else
-		MV_CopyMemory(&data->BIOSVersion, buff, sizeof (Version_Info_CIM));
-	}
-	core_unmap_data_buffer(req);
-}
-
-MV_U8
-core_api_alarm_command(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-
-	switch (req->Cdb[1]) {
-	case APICDB1_BUZZER_ON:
-		core_alarm_change_state(core, ALARM_STATE_1S_1S);
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		break;
-	case APICDB1_BUZZER_OFF:
-		core_alarm_change_state(core, ALARM_STATE_OFF);
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		break;
-	case APICDB1_BUZZER_MUTE:
-		core_alarm_change_state(core, ALARM_STATE_MUTE);
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		break;
-	case APICDB1_BUZZER:
-	default:
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		break;
-	}
-
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
--- a/drivers/scsi/vanir/core/api/core_api.h
+++ /dev/null
@@ -1,40 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined(CORE_API_H)
-#define CORE_API_H
-
-#include "mv_config.h"
-
-
-/* api related functions */
-void Core_Change_LED(
-	IN MV_PVOID core,
-	IN MV_U16 device_id,
-	IN MV_U8 flag);
-
-MV_VOID Core_GetHDInfo(
-	IN MV_PVOID core,
-	IN MV_U16 HDId,
-	OUT MV_PVOID buffer,
-        IN MV_BOOLEAN useVariableSize);
-
-MV_BOOLEAN Core_Set_SCSIID(MV_PVOID core_p, MV_PU16 device_id,
-        MV_PU16 scsi_id, MV_U16 entry_size);
-MV_BOOLEAN Core_Get_SCSIID(MV_PVOID core_p, MV_PU16 device_id,
-        MV_PU16 scsi_id, MV_U16 entry_size);
-
-MV_U8 core_sgpio_set_led( MV_PVOID extension, MV_U16 device_id, MV_U8 light_type,
-        MV_U8 light_behavior, MV_U8 flag);
-#define MAX_BIOS_SIZE           192L * 1024
-#endif /* CORE_API_H */
--- a/drivers/scsi/vanir/core/api/core_api_bbu.c
+++ /dev/null
@@ -1,74 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_manager.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "com_struct.h"
-#include "com_api.h"
-#include "com_error.h"
-#include "core_api.h"
-#include "core_util.h"
-#include "hba_inter.h"
-MV_U8 core_get_battery_status(MV_PVOID p_core_ext)
-{
-    PHBA_Extension hba_ptr = (PHBA_Extension)HBA_GetModuleExtension((core_extension *)p_core_ext, MODULE_HBA);
-    MV_U8 bbu_status = BBU_NORMAL;
-
-    bbu_status = BBU_NOT_PRESENT;
-
-    return bbu_status;
-}
-
-MV_U8
-mv_get_bbu_info(MV_PVOID core, PMV_Request pReq)
-{
-    PHBA_Extension hba_ptr = (PHBA_Extension) HBA_GetModuleExtension(core, MODULE_HBA);
-
-    if (pReq->Sense_Info_Buffer != NULL)
-        ((MV_PU8)pReq->Sense_Info_Buffer)[0] = ERR_NOT_SUPPORTED;
-    pReq->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-
-    return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-
-MV_U8
-mv_set_bbu_threshold(MV_PVOID core, PMV_Request pReq)
-{
-    PHBA_Extension hba_ptr = (PHBA_Extension) HBA_GetModuleExtension(core, MODULE_HBA);
-    HBA_Info_Page		hba_info_param;
-    MV_U8 type = pReq->Cdb[2];
-    MV_U16 lowerbound = (pReq->Cdb[3] << 8) | (pReq->Cdb[4]);
-    MV_U16 upperbound = (pReq->Cdb[5] << 8) | (pReq->Cdb[6]);
-
-    if (pReq->Sense_Info_Buffer != NULL)
-        ((MV_PU8)pReq->Sense_Info_Buffer)[0] = ERR_NOT_SUPPORTED;
-    pReq->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-
-    return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_U8
-mv_bbu_power_change(MV_PVOID core, PMV_Request pReq)
-{
-    PHBA_Extension hba_ptr = (PHBA_Extension) HBA_GetModuleExtension(core, MODULE_HBA);
-    MV_U8 type = pReq->Cdb[2];
-
-    if (pReq->Sense_Info_Buffer != NULL)
-        ((MV_PU8)pReq->Sense_Info_Buffer)[0] = ERR_NOT_SUPPORTED;
-    pReq->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-
-    return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
--- a/drivers/scsi/vanir/core/api/core_api_exp.c
+++ /dev/null
@@ -1,476 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-
-#include "core_type.h"
-#include "core_internal.h"
-#include "com_struct.h"
-#include "com_api.h"
-#include "com_error.h"
-#include "core_console.h"
-#include "core_util.h"
-#include "core_sas.h"
-#include "core_expander.h"
-
-MV_U8 core_get_exp_information(core_extension * core, domain_expander *exp_p,
-        PExp_Info exp_info, PMV_Request req);
-
-MV_VOID core_fill_exp_information(core_extension * core, domain_expander *exp,
-        PExp_Info exp_info);
-
-MV_PVOID core_generate_exp_hardware_req(pl_root *root, domain_expander * exp,
-        PExp_Info exp_info, PMV_Request req, MV_U8 request_type, MV_U8 phy_index);
-
-MV_VOID core_get_exp_information_callback(MV_PVOID root_p, MV_Request *req);
-
-/* return MV_QUEUE_COMMAND_RESULT_XXX */
-MV_U8 core_pd_request_get_expander_info(core_extension * core, PMV_Request req)
-{
-	PExp_Info_Request exp_req;
-       PRequestHeader header = NULL;
-       PExp_Info exp_info = NULL;
-
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_U16 start_id = 0, end_id = 0;
-       MV_U8 j;
-       List_Head smp_list;
-       domain_base *base = NULL;
-       domain_expander *exp, *parent = NULL;
-       MV_Request *new_req = NULL;
-
-	exp_req = (PExp_Info_Request)core_map_data_buffer(req);
-	header = &exp_req->header;
-       req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-	if (exp_req == NULL ||
-		req->Data_Transfer_Length < sizeof(Exp_Info_Request)) {
-
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-        if (req->Cmd_Initiator != NULL) {
-                if (header->startingIndexOrId >= MAX_ID) {
-			if (req->Sense_Info_Buffer != NULL)
-			        ((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_EXP_ID;
-                        req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-                        core_unmap_data_buffer(req);
-		        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	        }
-
-	        if (header->requestType == REQUEST_BY_RANGE) {
-		        start_id = header->startingIndexOrId;
-		        end_id = MAX_ID;
-	        } else if (header->requestType == REQUEST_BY_ID) {
-		        start_id = header->startingIndexOrId;
-		        end_id = header->startingIndexOrId + 1;
-	        }
-
-	        header->numReturned = 0;
-	        header->nextStartingIndex = NO_MORE_DATA;
-
-                ctx->u.api_req.pointer = req->Cmd_Initiator;
-                ctx->u.api_req.remaining = 0;
-                ctx->u.api_req.start = start_id;
-                ctx->u.api_req.end = end_id;
-                req->Cmd_Initiator = NULL;
-        } else {
-                MV_ASSERT(ctx->u.api_req.remaining == 0);
-                MV_ASSERT(ctx->u.api_req.pointer != NULL);
-                CORE_DPRINT(("expander api, start 0x%x, end 0x%x.\n", \
-                        ctx->u.api_req.start, ctx->u.api_req.end));
-        }
-
-        MV_LIST_HEAD_INIT(&smp_list);
-        while (ctx->u.api_req.start < ctx->u.api_req.end) {
-                MV_ASSERT(List_Empty(&smp_list));
-
-                base = get_device_by_id(&core->lib_dev, ctx->u.api_req.start);
-                if ((base == NULL) || (base->type != BASE_TYPE_DOMAIN_EXPANDER)) {
-                        ctx->u.api_req.start++;
-                        continue;
-                }
-
-                exp = (domain_expander *)base;
-                /* during initialization */
-                if (exp->state != EXP_STATE_DONE) {
-                        ctx->u.api_req.start++;
-                        continue;
-	        }
-                if ((exp->base.parent != NULL) &&
-                        (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER)) {
-                        parent = (domain_expander *)exp->base.parent;
-                        /* need do discover to the parent expander */
-                        if (parent->state != EXP_STATE_DONE) {
-                                ctx->u.api_req.start++;
-                                continue;
-                        }
-                }
-
-                exp_info = &exp_req->expInfo[header->numReturned];
-                /* for each expander, fill the already known information */
-		 core_fill_exp_information(core, exp, exp_info);
-
-                if ((exp->base.parent != NULL) &&
-                        (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER)) {
-                        for (j = 0; j < exp_info->Link.Self.PhyCnt; j++) {
-		                new_req = core_generate_exp_hardware_req(
-                                        exp->base.root, exp, exp_info, req, DISCOVER, j);
-                                if (new_req) {
-                                        List_Add(&new_req->Queue_Pointer , &smp_list);
-                                } else {
-                                        goto no_resource;
-                                }
-                        }
-                }
-
-                new_req = core_generate_exp_hardware_req(
-                        exp->base.root, exp, exp_info, req, REPORT_GENERAL, 0);
-
-                if (new_req) {
-                        List_Add(&new_req->Queue_Pointer, &smp_list);
-                } else {
-                        goto no_resource;
-                }
-
-                while (!List_Empty(&smp_list)) {
-                        new_req = List_GetFirstEntry(&smp_list, MV_Request, Queue_Pointer);
-                        core_append_request(exp->base.root, new_req);
-                        ctx->u.api_req.remaining++;
-                }
-
-                ctx->u.api_req.start++;
-		header->numReturned++;
-		if ((header->requestType == REQUEST_BY_RANGE) &&
-			(header->numReturned == header->numRequested)) {
-			header->nextStartingIndex = ctx->u.api_req.start;
-			break;
-		}
-	}
-
-        core_unmap_data_buffer(req);
-
-        req->Cmd_Initiator = ctx->u.api_req.pointer;
-        if (ctx->u.api_req.remaining == 0) {
-                MV_ASSERT(header->numReturned == 0);
-                return MV_QUEUE_COMMAND_RESULT_FINISHED;
-        } else {
-                return MV_QUEUE_COMMAND_RESULT_REPLACED;
-        }
-
-no_resource:
-        while (!List_Empty(&smp_list)) {
-                new_req = List_GetFirstEntry(&smp_list, MV_Request, Queue_Pointer);
-                intl_req_release_resource(&core->lib_rsrc, req);
-        }
-        if (ctx->u.api_req.remaining != 0) {
-                return MV_QUEUE_COMMAND_RESULT_REPLACED;
-        } else {
-                return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-        }
-}
-
-MV_VOID core_fill_exp_information(core_extension *core, domain_expander *exp,
-        PExp_Info exp_info)
-{
-	MV_U8 i, phy_id;
-
-        MV_ASSERT(exp->state == EXP_STATE_DONE);
-	exp_info->Link.Self.DevID = exp->base.id;
-
-	exp_info->Link.Self.DevType = DEVICE_TYPE_EXPANDER;
-	exp_info->Link.Self.PhyCnt = exp->parent_phy_count;
-	MV_CopyMemory( exp_info->Link.Self.SAS_Address, &exp->sas_addr.value, 8 );
-	if (exp->enclosure)
-		exp_info->Link.Self.EnclosureID = exp->enclosure->base.id;
-	else
-		exp_info->Link.Self.EnclosureID = 0xFFFF;
-	exp_info->Link.Parent.EnclosureID = 0xFFFF;
-	exp_info->Link.Parent.PhyCnt = exp->parent_phy_count;
-	MV_CopyMemory(exp_info->Link.Parent.PhyID, exp->parent_phy_id, 8);
-
-	if (exp->base.parent != NULL) {
-		if (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-			exp_info->Link.Parent.DevType = DEVICE_TYPE_EXPANDER;
-			exp_info->Link.Parent.DevID = exp->base.parent->id;
-			if (((domain_expander *)(exp->base.parent))->enclosure)
-				exp_info->Link.Parent.EnclosureID = ((domain_expander *)(exp->base.parent))->enclosure->base.id;
-		} else if (exp->base.parent->type == BASE_TYPE_DOMAIN_PORT) {
-                        phy_id = 0;
-			for (i = 0; i < exp->base.root->phy_num; i++) {
-				if (exp->base.port->phy_map & MV_BIT(i)) {
-					exp_info->Link.Self.PhyID[phy_id] =
-                                                (MV_U8)(exp->base.root->phy[i].att_dev_info >> 24);
-					phy_id++;
-				}
-			}
-
-			exp_info->Link.Parent.DevType = DEVICE_TYPE_PORT;
-			exp_info->Link.Parent.DevID = exp->base.port->base.id;
-			for (i = 0; i < exp->base.root->phy_num; i++) {
-				if( exp->base.port->phy_map & MV_BIT(i) )
-					break;
-			}
-			MV_CopyMemory(exp_info->Link.Parent.SAS_Address, &exp->base.root->phy[i].dev_sas_addr.value, 8);
-			for (i = 0; i < 8; i++)
-				exp_info->Link.Parent.PhyID[i] += (MV_U8)exp->base.root->base_phy_num;
-		}
-	}
-
-	exp_info->RouteTableConfigurable = exp->configurable_route_table;
-	exp_info->PhyCount = exp->phy_count;
-
-	exp_info->ComponentID = exp->component_id;
-	exp_info->ComponentRevisionID = exp->component_rev_id;
-	MV_CopyMemory(exp_info->ComponentVendorID, exp->component_vendor_id, 8);
-	MV_CopyMemory(exp_info->VendorID, exp->vendor_id, 8);
-	MV_CopyMemory(exp_info->ProductID, exp->product_id, 16);
-	MV_CopyMemory(exp_info->ProductRev, exp->product_rev, 4);
-}
-
-MV_PVOID core_generate_exp_hardware_req(pl_root *root, domain_expander * exp,
-        PExp_Info exp_info, PMV_Request req, MV_U8 request_type, MV_U8 phy_index)
-{
-	MV_Request *new_req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-	core_context *ctx = (core_context *)new_req->Context[MODULE_CORE];
-
-        if (new_req == NULL) return NULL;
-
-        if (request_type == DISCOVER) {
-                MV_ASSERT(exp->base.parent != NULL);
-                MV_ASSERT(exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER);
-        }
-
-	ctx->u.api_smp.buffer = exp_info;
-        ctx->u.api_smp.phy_index = phy_index;
-
-	/* Prepare identify ATA task */
-	new_req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	new_req->Cdb[1] = CDB_CORE_MODULE;
-	new_req->Cdb[2] = CDB_CORE_SMP;
-
-        /* send discover request to the parent. send report general to itself */
-	new_req->Device_Id = (request_type == DISCOVER) ? exp->base.parent->id : exp->base.id;
-	new_req->Org_Req = req;
-
-	smp_req = (smp_request *)core_map_data_buffer(new_req);
-	smp_req->function = request_type;
-	if (request_type == DISCOVER) {
-                smp_req->request.Discover.IgnoredByte4_7[0] = 0;
-                smp_req->request.Discover.IgnoredByte4_7[1] = 0;
-                smp_req->request.Discover.IgnoredByte4_7[2] = 0;
-                smp_req->request.Discover.IgnoredByte4_7[3] = 0;
-                smp_req->request.Discover.ReservedByte8 = 0;
-		  smp_req->request.Discover.PhyIdentifier = exp->parent_phy_id[phy_index];
-                smp_req->request.Discover.IgnoredByte10 = 0;
-                smp_req->request.Discover.ReservedByte11 = 0;
-	}
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-	new_req->Completion = (void(*)(MV_PVOID,PMV_Request))core_get_exp_information_callback;
-
-	/* Send this internal request */
-        core_unmap_data_buffer(new_req);
-        return new_req;
-}
-
-MV_VOID core_get_exp_information_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	PMV_Request org_req = (PMV_Request)req->Org_Req;
-	smp_response *smp_req = (smp_response *)core_map_data_buffer(req);
-
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-        core_context *org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-	MV_U16 phy_index = ctx->u.api_smp.phy_index;
-	PExp_Info exp_info = ctx->u.api_smp.buffer;
-        domain_expander *exp;
-
-	if (smp_req->function == DISCOVER) {
-                if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-                        exp_info->Link.Self.PhyID[phy_index] = 0;
-                } else {
-	                exp_info->Link.Self.PhyID[phy_index] =
-                                smp_req->response.Discover.AttachedPhyIdentifier;
-		        if (phy_index == 0) {
-			        /* only need to store the SAS address once */
-			        MV_CopyMemory(exp_info->Link.Parent.SAS_Address,
-                                        smp_req->response.Discover.SASAddress, 8);
-		        }
-                }
-        } else {
-                MV_ASSERT(smp_req->function == REPORT_GENERAL);
-                if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		        exp_info->Configuring = 0;
-                        exp_info->ExpChangeCount = 0;
-                } else {
-                        exp_info->Configuring = smp_req->response.ReportGeneral.Configuring;
-			MV_CopyMemory(&exp_info->ExpChangeCount,
-                                smp_req->response.ReportGeneral.ExpanderChangeCount, 2);
-		        /* convert SAS addr to little-endian */
-		        if (exp_info->Link.Parent.SAS_Address[0] != 0x50)
-			        mv_swap_bytes(exp_info->Link.Parent.SAS_Address, 8);
-		        if (exp_info->Link.Self.SAS_Address[0] != 0x50)
-			        mv_swap_bytes(exp_info->Link.Self.SAS_Address, 8);
-                }
-        }
-
-        core_unmap_data_buffer(req);
-
-        MV_ASSERT(org_ctx->u.api_req.remaining > 0);
-        org_ctx->u.api_req.remaining--;
-
-        if (org_ctx->u.api_req.remaining == 0) {
-                if (org_ctx->u.api_req.start == org_ctx->u.api_req.end) {
-                        req->Cmd_Initiator = ctx->u.api_req.pointer;
-                        core_queue_completed_req(root->core, org_req);
-                } else {
-                        core_append_request(root, org_req);
-                }
-        }
-}
-
-MV_VOID
-core_get_enc_information(core_extension *core, domain_enclosure *enc,
-	PEnclosure_Info pEncInfo)
-{
-	domain_expander *exp;
-	MV_U8 i = 0;
-
-	pEncInfo->Link.Self.DevID = enc->base.id;
-	if ( !(enc->status & ENCLOSURE_STATUS_FUNCTIONAL) ||
-		 (enc->state != ENCLOSURE_INIT_DONE))
-	{
-		pEncInfo->Link.Self.DevType = DEVICE_TYPE_NONE;
-		return;
-	}
-
-	pEncInfo->Link.Self.EnclosureID = enc->base.id;
-	pEncInfo->Link.Self.PhyCnt = 0;
-	pEncInfo->Link.Parent.DevType = DEVICE_TYPE_NONE;
-	pEncInfo->Link.Parent.DevID = 0xFFFF;
-	pEncInfo->Link.Parent.PhyCnt = 0;
-	pEncInfo->Link.Parent.EnclosureID = 0xFFFF;
-	if (enc->base.type == BASE_TYPE_DOMAIN_I2C) {
-		pEncInfo->Link.Self.DevType = DEVICE_TYPE_I2C_ENCLOSURE;
-		pEncInfo->Link.Parent.DevID = enc->base.port->base.id;
-		pEncInfo->Link.Parent.DevType = DEVICE_TYPE_PORT;
-	}
-	else
-		pEncInfo->Link.Self.DevType = DEVICE_TYPE_ENCLOSURE;
-
-	pEncInfo->Status = ENC_STATUS_OK;
-
-	LIST_FOR_EACH_ENTRY_TYPE(exp, &enc->expander_list, domain_expander, enclosure_queue_pointer)
-	{
-		pEncInfo->ExpanderIDs[i] = exp->base.id;
-		i++;
-	}
-	pEncInfo->ExpanderCount = i;
-
-	MV_CopyMemory(pEncInfo->LogicalID, enc->enclosure_logical_id, 8);
-	MV_CopyMemory(pEncInfo->VendorID, enc->vendor_id, 8);
-	MV_CopyMemory(pEncInfo->ProductID, enc->product_id, 16);
-	MV_CopyMemory(pEncInfo->RevisionLevel, enc->product_revision, 4);
-}
-
-MV_VOID core_get_enc_info( MV_PVOID extension, MV_PVOID buffer)
-{
-	core_extension *core = (core_extension *)extension;
-	MV_U16 start_id = 0, end_id = 0;
-	domain_enclosure *enc = NULL;
-	PEnclosure_Info pEncInfo;
-	PEnclosure_Info_Request pEncReq;
-	PRequestHeader header = NULL;
-	MV_U16 i;
-	domain_base *base = NULL;
-
-	pEncReq = (PEnclosure_Info_Request)buffer;
-	header = &pEncReq->header;
-	if (header->requestType == REQUEST_BY_RANGE) {
-		start_id = header->startingIndexOrId;
-		end_id = MAX_ID;
-	} else if (header->requestType == REQUEST_BY_ID) {
-		start_id = header->startingIndexOrId;
-		end_id = header->startingIndexOrId;
-	}
-	pEncInfo = pEncReq->encInfo;
-	header->numReturned = 0;
-	header->nextStartingIndex = NO_MORE_DATA;
-
-	for (i = start_id; i <= end_id; i++) {
-		base = get_device_by_id(&core->lib_dev, i);
-		if ((base!= NULL)&&
-			((base->type == BASE_TYPE_DOMAIN_ENCLOSURE)||
-			(base->type == BASE_TYPE_DOMAIN_I2C))) {
-			enc = (domain_enclosure *)base;
-			core_get_enc_information( core, enc, pEncInfo );
-		} else {
-			pEncInfo->Link.Self.DevID = i;
-			pEncInfo->Link.Self.DevType = DEVICE_TYPE_NONE;
-		}
-
-		if (pEncInfo->Link.Self.DevType != DEVICE_TYPE_NONE) {
-			header->numReturned++;
-			pEncInfo++;
-			if ((header->requestType == REQUEST_BY_RANGE) &&
-				(header->numReturned == header->numRequested)) {
-				header->nextStartingIndex = i+1;
-				break;
-			}
-		}
-	}
-}
-
-MV_U8
-core_pd_request_get_enclosure_info(core_extension * core_p, PMV_Request req)
-{
-	PEnclosure_Info pEncInfo = NULL;
-	domain_base *base = NULL;
-        MV_PVOID buf_ptr = core_map_data_buffer(req);
-	PEnclosure_Info_Request pEncReq = (PEnclosure_Info_Request)buf_ptr;
-
-	if (buf_ptr == NULL ||
-		req->Data_Transfer_Length < sizeof(Enclosure_Info_Request)) {
-
-                core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (pEncReq->header.requestType == REQUEST_BY_RANGE &&
-		pEncReq->header.nextStartingIndex == 0){
-		pEncReq->header.startingIndexOrId = 0;
-	} else if (pEncReq->header.startingIndexOrId >= MAX_ID) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_ENC_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-                core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	core_get_enc_info(core_p, buf_ptr);
-
-	if (pEncReq->header.requestType == REQUEST_BY_ID &&
-		pEncReq->header.numReturned == 0) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_ENC_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-	} else
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-        core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
--- a/drivers/scsi/vanir/core/api/core_api_flash.c
+++ /dev/null
@@ -1,408 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_manager.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "com_struct.h"
-#include "com_api.h"
-#include "com_error.h"
-#include "core_api.h"
-#include "core_util.h"
-#include "com_flash.h"
-#include "hba_inter.h"
-#include "core_spi.h"
-
-MV_U8
-core_flash_bin(
-	IN MV_PVOID core_p,
-	IN PMV_Request req)
-{
-	core_extension  *core = (core_extension *)core_p;
-	HBA_Extension   *hba = (PHBA_Extension)HBA_GetModuleExtension(core_p, MODULE_HBA);
-	AdapterInfo		adapter_info;
-	MV_U32               size = 0,length;
-	MV_U32               buf_start_addr = 0,flash_start_addr = 0;
-	MV_BOOLEAN       need_erase;
-	MV_U8			flash_op,checksum;
-	MV_U16			i,erase_sect_num;
-	MV_U8			buff[16];
-	PFlash_DriveData    data;
-
-        data =(PFlash_DriveData)core_map_data_buffer(req);
-	flash_op = 0;
-	need_erase = MV_FALSE;
-	length = 0;
-
-	if (data == NULL ||
-		req->Data_Transfer_Length < sizeof(Flash_DriveData)) {
-
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	switch (req->Cdb[2]) {
-	case FLASH_UPLOAD:
-		if (data->PageNumber == 0 && data->Data !=NULL)
-			need_erase = MV_TRUE;
-		else if(data->PageNumber>0)
-			need_erase = MV_FALSE;
-		flash_op = 1;
-		size = data->Size;
-		data->Size = 0;
-		CORE_DPRINT(("Upload!\n"));
-		break;
-	case FLASH_DOWNLOAD:
-		flash_op = 2;
-		CORE_DPRINT(("Download!\n"));
-		break;
-	default:
-		req->Scsi_Status = REQ_STATUS_INVALID_PARAMETER;
-		CORE_DPRINT(("Unknown action!\n"));
-	}
-
-	adapter_info = *(AdapterInfo *)core->lib_flash.adapter_info;
-
-	switch (req->Cdb[3]) {
-	case  FLASH_TYPE_BIOS:
-		buf_start_addr = 0x00000000;
-		erase_sect_num = (MV_U16)(MAX_BIOS_SIZE /adapter_info.FlashSectSize);
-		CORE_DPRINT(("BIOS Type!\n"));
-		break;
-	case  FLASH_TYPE_CONFIG:
-		buf_start_addr = 0x30000;
-		erase_sect_num = 1;
-		CORE_DPRINT(("CONFIG Type!\n"));
-		break;
-	default:
-		req->Scsi_Status=REQ_STATUS_INVALID_PARAMETER;
-		CORE_DPRINT(("Unknown Type!\n"));
-		core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (req->Cdb[3] == FLASH_TYPE_CONFIG) {
-		if(need_erase) {
-			flash_start_addr = buf_start_addr;
-			if(OdinSPI_SectErase( &adapter_info, flash_start_addr) != -1){
-				CORE_DPRINT(("Core_Flash_Bin: FLASH ERASE SUCCESS!Erase Sector\n"));
-			} else {
-				CORE_DPRINT(("Core_Flash_Bin: FLASH ERASE FAILED!Erase Sector\n"));
-				req->Scsi_Status = REQ_STATUS_ERROR;
-				return MV_FALSE;
-			}
-		}
-
-	if (flash_op==1){
-		checksum = mvCalculateChecksum(data->Data, size);
-		flash_start_addr = buf_start_addr + data->PageNumber * DRIVER_LENGTH;
-
-		if (OdinSPI_WriteBuf(&adapter_info, flash_start_addr, (MV_U8*)data->Data, size) == -1) {
-			CORE_DPRINT(("Core_Flash_Bin: Write FLASH FAILED!PageNumber is %d\n",data->PageNumber));
-			req->Scsi_Status=REQ_STATUS_ERROR;
-			return MV_FALSE;
-		} else {
-			CORE_DPRINT(("Core_Flash_Bin: Write FLASH SUCCESS!PageNumber is %d,address is %x\n",\
-				data->PageNumber,flash_start_addr));
-		}
-
-		MV_ZeroMemory(data->Data,size);
-		if (OdinSPI_ReadBuf(&adapter_info, flash_start_addr, (MV_U8*)data->Data, size) == -1) {
-			CORE_DPRINT(("Core_Flash_Bin: Read FLASH FAILED!Address is %x\n",flash_start_addr));
-			req->Scsi_Status = REQ_STATUS_ERROR;
-			return MV_FALSE;
-		} else {
-			CORE_DPRINT(("Core_Flash_Bin: Read FLASH SUCCESS!Address is %x\n",flash_start_addr));
-		}
-
-		/* check the sum and return the writen size */
-		if (checksum == mvCalculateChecksum(data->Data, size)){
-			data->Size = (MV_U16)size;
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			CORE_DPRINT(("Core_Flash_Bin: CheckSum is OK!\n"));
-		}
-	}
-
-	if (flash_op == 2){
-		length = 64*1024;
-		flash_start_addr = 0;
-
-		/* calculate the page size */
-		if((MV_U32)((data->PageNumber + 1) * DRIVER_LENGTH)< length)
-		{
-			/* read the whole page */
-			size = DRIVER_LENGTH;
-			data->Size=0;
-			flash_start_addr = buf_start_addr + data->PageNumber * DRIVER_LENGTH;
-			if (OdinSPI_ReadBuf(&adapter_info, flash_start_addr, (MV_U8*)data->Data, size) == -1) {
-				CORE_DPRINT(("Core_Flash_Bin: Read FLASH FAILED!Address is %x\n",flash_start_addr));
-				req->Scsi_Status=REQ_STATUS_ERROR;
-				return MV_FALSE;
-			}
-			data->Size=(MV_U16)size;
-			data->PageNumber++;
-		} else {
-			size=(MV_U16)(length - data->PageNumber * DRIVER_LENGTH);
-			if(size != 0)
-			{
-				data->Size = 0;
-				flash_start_addr = buf_start_addr + data->PageNumber * DRIVER_LENGTH;
-				if (OdinSPI_ReadBuf(&adapter_info, flash_start_addr, (MV_U8*)data->Data, size) == -1) {
-					CORE_DPRINT(("Core_Flash_Bin: Read FLASH FAILED!Address is %x\n",flash_start_addr));
-					req->Scsi_Status = REQ_STATUS_ERROR;
-					return MV_FALSE;
-				}
-			}
-			data->Size = (MV_U16)size;
-			data->isLastPage = MV_TRUE;
-		}
-	}
-    }else if(req->Cdb[3] == FLASH_TYPE_BIOS){
-	/* erase flash */
-	if (need_erase) {
-		for (i = 0; i < erase_sect_num; i++) {
-			flash_start_addr = buf_start_addr + i * adapter_info.FlashSectSize;
-			if (OdinSPI_SectErase(&adapter_info, flash_start_addr) != -1) {
-				CORE_DPRINT(("FLASH ERASE SUCCESS!Erase Sector %d\n", i));
-			} else {
-				CORE_DPRINT(("FLASH ERASE FAILED!Erase Sector %d\n", i));
-				req->Scsi_Status = REQ_STATUS_ERROR;
-                                core_unmap_data_buffer(req);
-				return MV_QUEUE_COMMAND_RESULT_FINISHED;
-			}
-		}
-	}
-
-	/* write flash */
-	if (flash_op == 1) {
-		/*get CheckSum */
-		checksum  = mvCalculateChecksum(data->Data, size);
-		flash_start_addr = buf_start_addr + data->PageNumber * DRIVER_LENGTH;
-		if (OdinSPI_WriteBuf(&adapter_info, flash_start_addr, (MV_U8*)data->Data, size) == -1) {
-			CORE_DPRINT(("Write FLASH FAILED!PageNumber is %d\n",data->PageNumber));
-			req->Scsi_Status = REQ_STATUS_ERROR;
-                        core_unmap_data_buffer(req);
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		} else {
-			CORE_DPRINT(("Write FLASH SUCCESS!PageNumber is %d,address is %x\n",\
-                                data->PageNumber, flash_start_addr));
-		}
-
-		MV_ZeroMemory(data->Data, size);
-		if (OdinSPI_ReadBuf(&adapter_info, flash_start_addr, (MV_U8*)data->Data, size) == -1) {
-			CORE_DPRINT(("Read FLASH FAILED!Address is %x\n", flash_start_addr));
-			req->Scsi_Status = REQ_STATUS_ERROR;
-                        core_unmap_data_buffer(req);
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		} else {
-			CORE_DPRINT(("Read FLASH SUCCESS!Address is %x\n", flash_start_addr));
-		}
-
-		/* check the sum and return the writen size */
-		if (checksum != mvCalculateChecksum(data->Data, size)){
-			CORE_DPRINT(("The Checksum is wrong! \n"));
-		} else {
-			data->Size = (MV_U16)size;
-			CORE_DPRINT(("CheckSum is OK!\n"));
-		}
-	}
-
-		if (flash_op == 2) {
-			/* calculate the bios size */
-			flash_start_addr = 0;
-			if (OdinSPI_ReadBuf(&adapter_info, flash_start_addr, buff, 16) == -1) {
-				CORE_DPRINT(("Read FLASH FAILED!Address is %x\n", flash_start_addr));
-				req->Scsi_Status = REQ_STATUS_ERROR;
-				core_unmap_data_buffer(req);
-				return MV_QUEUE_COMMAND_RESULT_FINISHED;
-			}
-
-			length=buff[2];
-
-			flash_start_addr = 0x140;
-			if (OdinSPI_ReadBuf(&adapter_info, flash_start_addr, buff, 16) == -1) {
-				CORE_DPRINT(("Read FLASH FAILED!Address is %x\n",flash_start_addr));
-				req->Scsi_Status = REQ_STATUS_ERROR;
-				core_unmap_data_buffer(req);
-				return MV_QUEUE_COMMAND_RESULT_FINISHED;
-			}
-
-			length += buff[0];
-			length += buff[1];
-			length *= 512;
-
-			flash_start_addr = 0;
-			buf_start_addr = 0;
-
-			/* calculate the page size */
-			if ((MV_U32)((data->PageNumber + 1) * DRIVER_LENGTH) <= length) {
-				/* read the whole page. */
-				size = DRIVER_LENGTH;
-				data->Size = 0;
-				flash_start_addr = buf_start_addr + data->PageNumber * DRIVER_LENGTH;
-				if (OdinSPI_ReadBuf(&adapter_info, flash_start_addr, (MV_U8*)data->Data, size) == -1) {
-					CORE_DPRINT(("Read FLASH FAILED!Address is %x\n",flash_start_addr));
-					req->Scsi_Status = REQ_STATUS_ERROR;
-					core_unmap_data_buffer(req);
-					return MV_QUEUE_COMMAND_RESULT_FINISHED;
-				}
-				data->Size=(MV_U16)size;
-				data->PageNumber++;
-			} else {
-				/* read the last page */
-				size = (MV_U16)(length-data->PageNumber * DRIVER_LENGTH);
-				data->Size = 0;
-				flash_start_addr = buf_start_addr+data->PageNumber*DRIVER_LENGTH;
-				if (OdinSPI_ReadBuf(&adapter_info, flash_start_addr, (MV_U8*)data->Data, size) == -1) {
-					CORE_DPRINT(("Read FLASH FAILED!Address is %x\n",flash_start_addr));
-					req->Scsi_Status = REQ_STATUS_ERROR;
-					core_unmap_data_buffer(req);
-					return MV_QUEUE_COMMAND_RESULT_FINISHED;
-				}
-				data->Size = (MV_U16)size;
-				data->isLastPage = MV_TRUE;
-			}
-		}
-	}
-
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_U8
-core_flash_rwtest(
-	IN MV_PVOID core_p,
-	IN PMV_Request req)
-{
-	core_extension  *core = (core_extension *)core_p;
-	HBA_Extension   *hba = (PHBA_Extension)HBA_GetModuleExtension(core_p, MODULE_HBA);
-	AdapterInfo		adapter_info;
-	MV_U32               bytes = 0,offset = 0;
-	MV_BOOLEAN		need_erase;
-	MV_U8			flash_op,checksum;
-	PDBG_Flash    data;
-
-	data = (PDBG_Flash)core_map_data_buffer(req);
-	need_erase = MV_FALSE;
-	flash_op = 0;
-
-	if (data == NULL ||
-		req->Data_Transfer_Length < sizeof(DBG_Flash)) {
-
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	switch (req->Cdb[2]) {
-		case FLASH_BYTE_WRITE:
-				flash_op = 1;
-				bytes = data->NumBytes;
-				offset = data->OffSet;
-				if (!(offset % FLASH_SECTOR_SIZE)){
-					need_erase = MV_TRUE;
-				}
-				CORE_DPRINT(("Write Flash Test!\n"));
-				break;
-		case FLASH_BYTE_READ:
-				flash_op = 2;
-				bytes = data->NumBytes;
-				CORE_DPRINT(("Read Flash Test!\n"));
-				break;
-		default:
-			req->Scsi_Status = REQ_STATUS_INVALID_PARAMETER;
-			CORE_DPRINT(("Unknown action!\n"));
-	}
-
-	adapter_info = *(AdapterInfo *)core->lib_flash.adapter_info;
-
-	if(need_erase) {
-		if(OdinSPI_SectErase( &adapter_info,  (offset/FLASH_SECTOR_SIZE)*FLASH_SECTOR_SIZE) != -1){
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: FLASH ERASE SUCCESS!Erase Sector %d\n", offset/FLASH_SECTOR_SIZE));
-		} else {
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: FLASH ERASE FAILED!Erase Sector %d\n", offset/FLASH_SECTOR_SIZE));
-			req->Scsi_Status = REQ_STATUS_ERROR;
-			return MV_FALSE;
-		}
-	}
-
-	/* write flash */
-	if (flash_op==1) {
-		checksum = mvCalculateChecksum(data->Data, bytes);
-
-		if (OdinSPI_WriteBuf(&adapter_info, offset, (MV_U8*)data->Data, bytes) != -1) {
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: Write FLASH SUCCESS!\n"));
-		} else {
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: Write FLASH FAILED!\n"));
-			req->Scsi_Status = REQ_STATUS_ERROR;
-			core_unmap_data_buffer(req);
-			return MV_FALSE;
-		}
-
-		bytes = data->NumBytes;
-		MV_ZeroMemory(data->Data, data->NumBytes);
-		if (OdinSPI_ReadBuf(&adapter_info, data->OffSet, (MV_U8*)data->Data, bytes) != -1) {
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: Read FLASH SUCCESS!Address is %x\n", data->OffSet));
-		} else {
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: Read FLASH FAILED!Address is %x\n", data->OffSet));
-			req->Scsi_Status = REQ_STATUS_ERROR;
-			core_unmap_data_buffer(req);
-			return MV_FALSE;
-		}
-
-		if (checksum == mvCalculateChecksum(data->Data, data->NumBytes)) {
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: CheckSum is OK!\n"));
-		} else
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: CheckSum Failed!\n"));
-	}
-
-	if (flash_op==2) {
-		if(OdinSPI_ReadBuf(&adapter_info, data->OffSet, (MV_U8*)data->Data, bytes) != -1) {
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: Read FLASH SUCCESS!Address is %x\n", data->OffSet));
-		} else {
-			CORE_DPRINT(("Core_Flash_ReadWrite_Test: Read FLASH FAILED!Address is %x\n", data->OffSet));
-			req->Scsi_Status = REQ_STATUS_ERROR;
-			core_unmap_data_buffer(req);
-			return MV_FALSE;
-		}
-	}
-
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_U8
-core_flash_command(
-	IN MV_PVOID core_p,
-	IN PMV_Request p_req
-	)
-{
-	MV_U8 status = MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-	switch (p_req->Cdb[1]) {
-		case APICDB1_FLASH_BIN:
-			status = core_flash_bin(core_p, p_req);
-			break;
-		case APICDB1_TEST_FLASH:
-			status = core_flash_rwtest(core_p, p_req);
-			break;
-		default:
-			p_req->Scsi_Status = REQ_STATUS_INVALID_PARAMETER;
-			break;
-	}
-	return status;
-}
--- a/drivers/scsi/vanir/core/api/core_api_led.c
+++ /dev/null
@@ -1,383 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_manager.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "com_struct.h"
-#include "com_api.h"
-#include "com_error.h"
-#include "core_console.h"
-#include "core_util.h"
-#include "core_api.h"
-#include "core_gpio.h"
-
-MV_U8 core_sgpio_set_led( MV_PVOID extension, MV_U16 device_id, MV_U8 light_type,
-        MV_U8 light_behavior, MV_U8 flag)
-{
-	core_extension *core = (core_extension *)extension;
-	domain_device * device;
-	domain_base * base;
-	pl_root * root;
-	MV_LPVOID mmio = core->mmio_base;
-	MV_U16 index = device_id;
-	MV_U32 tmp = 0x0;
-	MV_U8 offset = 0, mask = 0, i = 0, sgpio_numb;
-	MV_BOOLEAN set_status = MV_FALSE;
-
-	device = (domain_device *)get_device_by_id(&core->lib_dev, index);
-	if (device == NULL) return ERR_INVALID_HD_ID;
-	base = &device->base;
-	for (i = core->chip_info->start_host; i < (core->chip_info->start_host + core->chip_info->n_host); i++) {
-		root = &core->roots[i];
-		if (base->root == root) break;
-	}
-	if (i == core->chip_info->n_host)
-		return ERR_INVALID_HD_ID;
-	sgpio_numb = device->sgpio_drive_number;
-	if ((core->device_id == DEVICE_ID_6480) || (core->device_id == DEVICE_ID_6485)) {
-		if (sgpio_numb>=4) {
-			i = 1;
-			sgpio_numb -= 4;
-		}
-	}
-
-	switch (flag) {
-	case LED_FLAG_REBUILD:
-		light_type = SGPIO_LED_REBUILD;
-		light_behavior = SGPIO_LED_HIGH;
-		break;
-	case LED_FLAG_HOT_SPARE:
-		light_type = SGPIO_LED_LOCATE;
-		light_behavior = SGPIO_LED_BLINK_A;
-		break;
-	case LED_FLAG_FAIL_DRIVE:
-		light_type = SGPIO_LED_ERROR;
-		light_behavior = SGPIO_LED_HIGH;
-		break;
-	case LED_FLAG_ACT:
-		light_type = SGPIO_LED_ACTIVITY;
-		light_behavior = SGPIO_LED_HIGH;
-		break;
-	case LED_FLAG_HOT_SPARE_OFF:
-	case LED_FLAG_OFF_ALL:
-		light_type = SGPIO_LED_ALL;
-		light_behavior = SGPIO_LED_LOW;
-		break;
-	}
-
-	if (flag == 0 || flag == LED_FLAG_OFF_ALL)
-		set_status = MV_TRUE;
-
-	if (!(IS_SGPIO(device))) return ERR_INVALID_HD_ID;
-
-	switch (core->device_id) {
-	case DEVICE_ID_6440:
-	case DEVICE_ID_6445:
-	case DEVICE_ID_6320:
-	case DEVICE_ID_6340:
-		tmp = sgpio_read_pci_register(core, SGPIO_Data_Out_L);
-		break;
-	case DEVICE_ID_6480:
-	case DEVICE_ID_6485:
-	case DEVICE_ID_8180:
-	case DEVICE_ID_9480:
-	case DEVICE_ID_9580:
-	case DEVICE_ID_9588:
-	case DEVICE_ID_9485:
-	case DEVICE_ID_9440:
-	case DEVICE_ID_9445:
-	case DEVICE_ID_948F:
-		mv_sgpio_read_register(mmio,
-			SGPIO_REG_ADDR(i, SGPIO_REG_DRV_CTRL_BASE+sgpio_numb/4*4),
-			tmp);
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-
-	if ((core->device_id == DEVICE_ID_6440) || (core->device_id == DEVICE_ID_6445)
-                        ||(core->device_id == 0x6320) ||(core->device_id == DEVICE_ID_6340)) {
-		if (light_behavior > 1)
-			light_behavior = 1;
-
-		switch(light_type){
-		case SGPIO_LED_ACTIVITY:
-			offset = 0;
-			mask = 0x1;
-			device->sgpio_act_led_status = light_behavior;
-			break;
-		case SGPIO_LED_LOCATE:
-			offset = 1;
-			mask = 0x3;
-			if (set_status)
-				device->sgpio_locate_led_status = light_behavior;
-			break;
-		case SGPIO_LED_ERROR:
-			offset = 1;
-			mask = 0x3;
-			device->sgpio_error_led_status = light_behavior;
-			break;
-		case SGPIO_LED_REBUILD:
-			offset = 1;
-			mask = 0x3;
-			device->sgpio_error_led_status = light_behavior;
-			if (set_status)
-				device->sgpio_locate_led_status = light_behavior;
-			light_behavior = 0x3;
-			break;
-		case SGPIO_LED_ALL:
-			offset = 0;
-			mask = 0x7;
-			device->sgpio_act_led_status = SGPIO_LED_LOW;
-			device->sgpio_locate_led_status = SGPIO_LED_LOW;
-			device->sgpio_error_led_status = SGPIO_LED_LOW;
-			break;
-		}
-	} else {
-		switch (light_type) {
-		case SGPIO_LED_ACTIVITY:
-			offset = DRV_ACTV_LED_OFFSET;
-			mask = DRV_ACTV_LED_MASK;
-			device->sgpio_act_led_status = light_behavior;
-			break;
-		case SGPIO_LED_LOCATE:
-			offset = DRV_ERR_LED_OFFSET;
-			mask = DRV_LOC_LED_MASK | DRV_ERR_LED_MASK;
-			if (set_status)
-				device->sgpio_locate_led_status = light_behavior;
-			light_behavior = light_behavior << 3;
-			break;
-		case SGPIO_LED_ERROR:
-			offset = DRV_ERR_LED_OFFSET;
-			mask = DRV_LOC_LED_MASK | DRV_ERR_LED_MASK;
-			device->sgpio_error_led_status = light_behavior;
-			break;
-		case SGPIO_LED_REBUILD:
-			offset = DRV_ERR_LED_OFFSET;
-			mask = DRV_LOC_LED_MASK | DRV_ERR_LED_MASK;
-			device->sgpio_error_led_status = light_behavior;
-			if (set_status)
-				device->sgpio_locate_led_status = light_behavior;
-			light_behavior = 0x9; /* set both locate and error to 1 (high) */
-			break;
-		case SGPIO_LED_ALL:
-			offset = 0;
-			mask = 0xff;
-			device->sgpio_act_led_status = SGPIO_LED_LOW;
-			device->sgpio_locate_led_status = SGPIO_LED_LOW;
-			device->sgpio_error_led_status = SGPIO_LED_LOW;
-			break;
-		}
-	}
-
-	switch(core->device_id) {
-	case DEVICE_ID_6440:
-	case DEVICE_ID_6445:
-	case DEVICE_ID_6320:
-	case DEVICE_ID_6340:
-		tmp &= ~(mask<<(device->sgpio_drive_number*3+offset));
-		tmp |= light_behavior<<(device->sgpio_drive_number*3+offset);
-		break;
-	case DEVICE_ID_6480:
-	case DEVICE_ID_6485:
-	case DEVICE_ID_8180:
-	case DEVICE_ID_9480:
-	case DEVICE_ID_9580:
-	case DEVICE_ID_9588:
-	case DEVICE_ID_9485:
-	case DEVICE_ID_9440:
-	case DEVICE_ID_9445:
-	case DEVICE_ID_948F:
-		tmp &= ~(mask<<(3-sgpio_numb)*8);
-		tmp |= light_behavior<<(offset+(3-sgpio_numb)*8);
-		mv_sgpio_write_register(mmio,
-			SGPIO_REG_ADDR(i, SGPIO_REG_DRV_CTRL_BASE+sgpio_numb/4*4),
-			tmp);
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-
-	return REQ_STATUS_SUCCESS;
-}
-MV_VOID core_sgpio_control_active_led(MV_PVOID core_p, domain_base * base)
-{
-	core_extension *core = (core_extension *)core_p;
-	MV_U16 i;
-	domain_device *device;
-
-		device = (domain_device *)base;
-		if(device==NULL)
-			return;
-		if((device->base.type != BASE_TYPE_DOMAIN_DEVICE)||(!IS_SGPIO(device)))
-			return;
-		if(((device->base.outstanding_req > 0)&&(device->sgpio_act_led_status == SGPIO_LED_HIGH))
-			||((device->base.outstanding_req == 0)&&(device->sgpio_act_led_status == SGPIO_LED_LOW)))
-			return;
-		if((device->base.outstanding_req > 0)&&(device->sgpio_act_led_status == SGPIO_LED_LOW)){
-			core_sgpio_set_led(core,base->id,0,0,LED_FLAG_ACT);
-			CORE_DPRINT(("device %x outstanding req %x, sgpio_act_led_status: %x turn on\n",base->id, base->outstanding_req, device->sgpio_act_led_status));
-		}
-		else if((device->base.outstanding_req == 0)&&(device->sgpio_act_led_status == SGPIO_LED_HIGH)){
-			core_sgpio_set_led(core,base->id,0,0,LED_FLAG_OFF_ALL);
-			CORE_DPRINT(("device %x outstanding req %x, sgpio_act_led_status: %x turn off\n",base->id, base->outstanding_req, device->sgpio_act_led_status));
-		}
-
-}
-
-MV_VOID core_sgpio_led_off_timeout(domain_base * base, MV_PVOID tmp)
-{
-	domain_device *device;
-	if(base == NULL)
-		return;
-	if(base->type != BASE_TYPE_DOMAIN_DEVICE)
-		return;
-	device = (domain_device *)base;
-	if(!IS_SGPIO(device))
-		return;
-	if (device->active_led_off_timer != NO_CURRENT_TIMER) {
-		core_cancel_timer(base->root->core, device->active_led_off_timer);
-		device->active_led_off_timer = NO_CURRENT_TIMER;
-		core_sgpio_set_led(base->root->core,base->id,0,0,LED_FLAG_OFF_ALL);
-	} else {
-		CORE_DPRINT(("warning: LED timer is abnormal.\n"));
-	}
-}
-
-MV_Request *ses_make_receive_diagnostic_request(domain_enclosure *enc,MV_U8 page_code,
-	MV_ReqCompletion completion);
-void ses_get_status_callback(MV_PVOID root_p, PMV_Request req);
-#define	ses_make_enclosure_status_request(a)		(ses_make_receive_diagnostic_request(a,SES_PG_ENCLOSURE_STATUS,ses_get_status_callback))
-
-MV_BOOLEAN ses_check_supported_page(domain_enclosure *enc, MV_U8 page_code);
-void core_expander_set_led(
-	IN core_extension *core,
-	IN domain_device *device,
-	IN MV_U8 flag
-	)
-{
-	MV_Request *req = NULL;
-	if (device->enclosure== NULL)
-		return;
-	device->ses_request_flag = flag;
-	req = ses_make_enclosure_status_request(device->enclosure);
-	if (req == NULL) {
-		CORE_PRINT(("error: no internal request resource\n"));
-		return;
-	}
-	core_append_request(device->enclosure->base.root, req);
-}
-
-void Core_Change_LED(
-	IN MV_PVOID	extension,
-	IN MV_U16 device_id,
-	IN MV_U8 flag)
-{
-	core_extension * core = (core_extension *)extension;
-	domain_device *device = NULL;
-	domain_base *base = NULL;
-
-	base = get_device_by_id(&core->lib_dev, device_id);
-	if ((base == NULL) || (base->type != BASE_TYPE_DOMAIN_DEVICE))
-		return;
-	else
-		device = (domain_device *)base;
-
-	if (IS_SGPIO(device)) {
-		core_sgpio_set_led(core, device_id, 0, 0, flag);
-		return;
-	} else {
-		core_expander_set_led(core, device, flag);
-	}
-}
-
-MV_VOID
-core_send_ses_command_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_Request *org_req = req->Org_Req;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_enclosure *enc = (domain_enclosure *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	MV_PVOID buf_ptr, new_buf_ptr;
-
-	org_req->Scsi_Status = req->Scsi_Status;
-	if ((req->Scsi_Status != SCSI_STATUS_GOOD)&& (req->Sense_Info_Buffer))
-		MV_CopyMemory(org_req->Sense_Info_Buffer, req->Sense_Info_Buffer, org_req->Sense_Info_Buffer_Length);
-	if (req->Scsi_Status == SCSI_STATUS_GOOD) {
-		if (req->Cmd_Flag & CMD_FLAG_DATA_IN) {
-			buf_ptr = core_map_data_buffer(org_req);
-			new_buf_ptr = core_map_data_buffer(req);
-
-			MV_CopyMemory(buf_ptr, new_buf_ptr, req->Data_Transfer_Length);
-
-			core_unmap_data_buffer(org_req);
-			core_unmap_data_buffer(req);
-		}
-		core_queue_completed_req(root->core, org_req);
-	}
-}
-
-MV_U8
-core_send_ses_command(domain_enclosure *enc, PMV_Request req)
-{
-	pl_root *root = enc->base.root;
-
-	req->Device_Id = enc->base.id;
-	req->Cdb[5] = 0;
-	core_append_request(root, req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-MV_U8
-core_ses_command(
-	IN MV_PVOID core_p,
-	IN PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-	domain_base *base = NULL;
-	domain_enclosure *enc;
-	MV_U8 temp;
-
-	base = (domain_base *)get_device_by_id(&core->lib_dev, req->Cdb[5]);
-	if (base == NULL) {
-		req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-	if(base->type == BASE_TYPE_DOMAIN_ENCLOSURE) {
-		enc = (domain_enclosure *)base;
-		if( !ses_check_supported_page(enc, req->Cdb[2]) )
-		{
-			req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		}
-		return (core_send_ses_command(enc, req));
-	} else if (IS_SGPIO(((domain_device *)base))){
-		temp = core_sgpio_set_led(core, req->Cdb[5], req->Cdb[6], req->Cdb[7], 0);
-		if (temp == REQ_STATUS_SUCCESS)
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-		else {
-			if (req->Sense_Info_Buffer != NULL)
-				((MV_PU8)req->Sense_Info_Buffer)[0] = temp;
-			req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-		}
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	} else
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
--- a/drivers/scsi/vanir/core/api/core_api_pd.c
+++ /dev/null
@@ -1,1172 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "com_struct.h"
-#include "com_api.h"
-#include "com_error.h"
-#include "core_console.h"
-#include "core_util.h"
-#include "core_sas.h"
-
-MV_VOID
-core_get_hd_information(core_extension *core, domain_device *dev,
-	PHD_Info hd)
-{
-	MV_U8 i,j;
-	MV_U8 count;
-	pl_root *root;
-	domain_enclosure *enc = NULL;
-
-	hd->Link.Self.DevID = dev->base.id ;
-	if (dev->base.type == BASE_TYPE_DOMAIN_DEVICE) {
-			if (!(dev->status&DEVICE_STATUS_FUNCTIONAL) ||
-				 (dev->status & DEVICE_STATUS_SECONDARY_PATH) ||
-				 (dev->state != DEVICE_STATE_INIT_DONE)) {
-				hd->Link.Self.DevType = DEVICE_TYPE_NONE;
-				return;
-			}
-		hd->Link.Self.DevType = DEVICE_TYPE_HD;
-		hd->Link.Self.EnclosureID = 0xFFFF;
-		hd->Link.Parent.EnclosureID = 0xFFFF;
-
-		if (IS_ENCLOSURE(dev))
-			hd->Link.Self.DevType = DEVICE_TYPE_ENCLOSURE;
-
-		if (IS_TAPE(dev))
-			hd->Link.Self.DevType = DEVICE_TYPE_TAPE;
-
-		hd->Link.Self.PhyID[0] = 0;
-		hd->Link.Self.PhyCnt = 1;
-
-		if (dev->base.parent != NULL) {
-			if (dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-				hd->Link.Parent.DevID = dev->base.parent->id;
-				hd->Link.Parent.DevType = DEVICE_TYPE_EXPANDER;
-				hd->Link.Parent.PhyID[0] = dev->parent_phy_id;
-				hd->Link.Parent.PhyCnt = 1;
-				if (((domain_expander *)(dev->base.parent))->enclosure)
-					hd->Link.Parent.EnclosureID = ((domain_expander *)(dev->base.parent))->enclosure->base.id;
-				MV_CopyMemory(hd->Link.Parent.SAS_Address, &((domain_expander *)dev->base.parent)->sas_addr.value, 8);
-				MV_CopyMemory(hd->Link.Self.SAS_Address, &dev->sas_addr.value, 8);
-			} else if (dev->base.parent->type == BASE_TYPE_DOMAIN_PM) {
-				hd->Link.Parent.DevID = dev->base.parent->id;  /* PM ID */
-				hd->Link.Parent.DevType = DEVICE_TYPE_PM;
-				hd->Link.Parent.PhyID[0] = dev->pm_port;
-				hd->Link.Parent.PhyCnt = 1;
-			} else if (dev->base.parent->type == BASE_TYPE_DOMAIN_PORT) {
-				hd->Link.Parent.DevID = 0;
-				hd->Link.Parent.DevType = DEVICE_TYPE_PORT;
-
-				count = 0;
-				root = dev->base.root;
-				for (i = 0; i < root->phy_num; i++) {
-					if (dev->base.port->phy_map & MV_BIT(i)) {
-						if ((count == 0) && IS_SSP(dev)) {
-							MV_CopyMemory(hd->Link.Parent.SAS_Address, &root->phy[i].dev_sas_addr.value, 8);
-							MV_CopyMemory(hd->Link.Self.SAS_Address, &root->phy[i].att_dev_sas_addr.value, 8);
-						} else if (count == 0) {
-							MV_CopyMemory(hd->Link.Parent.SAS_Address, &root->phy[i].dev_sas_addr.value, 8);
-						}
-						MV_DASSERT(count < MAX_WIDEPORT_PHYS);
-						hd->Link.Parent.PhyID[count++] = i+(MV_U8)root->base_phy_num;
-					}
-				}
-				hd->Link.Parent.PhyCnt = count;
-			}
-
-		}
-
-		hd->InitStatus = PD_INIT_STATUS_OK;
-		if (IS_STP_OR_SATA(dev)) {
-			hd->HDType = HD_TYPE_SATA;
-			if (IS_ATAPI(dev))
-				hd->HDType |= HD_TYPE_ATAPI;
-		} else {
-			hd->HDType = HD_TYPE_SAS;
-			if (IS_TAPE(dev)) {
-				hd->HDType |= HD_TYPE_TAPE;
-			}
-			if (IS_ENCLOSURE(dev)) {
-				hd->HDType |= HD_TYPE_SES;
-			}
-		}
-
-		mv_swap_bytes(hd->Link.Parent.SAS_Address, 8);
-		mv_swap_bytes(hd->Link.Self.SAS_Address, 8);
-
-		hd->PIOMode = dev->pio_mode;
-		hd->UDMAMode = dev->udma_mode;
-		hd->CurrentPIOMode = dev->current_pio;
-		hd->CurrentUDMAMode = dev->current_udma;
-		hd->FeatureSupport = 0;
-		if (dev->capability& DEVICE_CAPABILITY_NCQ_SUPPORTED)
-			hd->FeatureSupport |= HD_FEATURE_NCQ;
-		if (dev->capability & DEVICE_CAPABILITY_WRITECACHE_SUPPORTED)
-			hd->FeatureSupport |= HD_FEATURE_WRITE_CACHE;
-		if (dev->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED)
-			hd->FeatureSupport |= HD_FEATURE_48BITS;
-		if (dev->capability & DEVICE_CAPABILITY_SMART_SUPPORTED)
-			hd->FeatureSupport |= HD_FEATURE_SMART;
-
-		if (dev->capability & DEVICE_CAPABILITY_RATE_1_5G)
-			hd->FeatureSupport |= HD_FEATURE_1_5G;
-		if (dev->capability & DEVICE_CAPABILITY_RATE_3G)
-			hd->FeatureSupport |= HD_FEATURE_3G;
-		if (dev->capability & DEVICE_CAPABILITY_RATE_6G)
-			hd->FeatureSupport |= HD_FEATURE_6G;
-
-		if (dev->capability & DEVICE_CAPABILITY_SSD)
-			hd->HD_SSD_Type = HD_SSD_TYPE_UNKNOWN_SSD;
-
-		MV_CopyMemory(hd->Model, dev->model_number, 40);
-		MV_CopyMemory(hd->SerialNo, dev->serial_number, 20);
-		MV_CopyMemory(hd->FWVersion, dev->firmware_revision, 8);
-
-		if ((hd->HDType == HD_TYPE_SATA) ||
-			(hd->HDType == HD_TYPE_SAS))
-			MV_CopyMemory(hd->WWN, &dev->WWN, 8);
-
-		hd->BlockSize = dev->sector_size;
-		if (U64_COMPARE_U32(dev->max_lba, 0) != 0) {
-			hd->Size = U64_ADD_U32(dev->max_lba, 1);
-		} else {
-			hd->Size.value = 0;
-		}
-	}else if((dev->base.type == BASE_TYPE_DOMAIN_I2C)||
-		(dev->base.type == BASE_TYPE_DOMAIN_ENCLOSURE)){
-		enc = (domain_enclosure *)dev;
-	if ( !(enc->status&ENCLOSURE_STATUS_FUNCTIONAL) ||
-		 (enc->state != ENCLOSURE_INIT_DONE)) {
-		hd->Link.Self.DevType = DEVICE_TYPE_NONE;
-		return;
-	}
-
-	hd->Link.Self.DevType = DEVICE_TYPE_ENCLOSURE;
-	hd->Link.Self.EnclosureID = 0xFFFF;
-	hd->Link.Parent.EnclosureID = 0xFFFF;
-
-	hd->Link.Self.PhyID[0] = 0;
-	hd->Link.Self.PhyCnt = 1;
-	hd->DeviceType = DT_ENCLOSURE;
-
-	if (dev->base.parent != NULL) {
-		if(dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-			hd->Link.Parent.DevID = dev->base.parent->id;
-			hd->Link.Parent.DevType = DEVICE_TYPE_EXPANDER;
-			hd->Link.Parent.PhyID[0] = dev->parent_phy_id;
-			hd->Link.Parent.PhyCnt = 1;
-			hd->Link.Parent.EnclosureID = enc->base.id;
-
-			MV_CopyMemory( hd->Link.Parent.SAS_Address, &((domain_expander *)enc->base.parent)->sas_addr.value, 8 );
-		} else if(dev->base.parent->type == BASE_TYPE_DOMAIN_PORT) {
-			hd->Link.Self.EnclosureID = enc->base.id;
-			hd->Link.Parent.EnclosureID =enc->base.id;
-			hd->Link.Parent.DevID = 0;
-			hd->Link.Parent.DevType = DEVICE_TYPE_PORT;
-			hd->Link.Parent.PhyCnt = 0;
-		}
-	}
-
-	hd->InitStatus = PD_INIT_STATUS_OK;
-	hd->HDType = HD_TYPE_SAS |HD_TYPE_SES;
-	mv_swap_bytes(hd->Link.Parent.SAS_Address, 8);
-	mv_swap_bytes(hd->Link.Self.SAS_Address, 8);
-	MV_CopyMemory(hd->Model, enc->vendor_id, 8);
-	MV_CopyMemory(hd->Model+8, enc->product_id, 16);
-	MV_CopyMemory(hd->FWVersion, enc->product_revision, 4);
-
-	/* Set PD Sector Size */
-	hd->BlockSize = 0;
-	hd->Size.value = 0;
-
-	}
-}
-
-MV_VOID
-Core_GetHDInfo(
-	IN MV_PVOID extension,
-	IN MV_U16 hd_id,
-	OUT MV_PVOID buffer,
-	IN MV_BOOLEAN useVariableSize
-	)
-{
-	core_extension *core = (core_extension *)extension;
-	MV_U16 start_id = 0, end_id = 0;
-	domain_device *dev = NULL;
-	PHD_Info_Request hd_req;
-	PHD_Info hd_info;
-	PRequestHeader header = NULL;
-	MV_U16 i;
-
-	if (!useVariableSize) {
-		if (hd_id == 0xFF) {
-			start_id = 0;
-			end_id = MAX_ID;
-		} else {
-			start_id = hd_id;
-			end_id = hd_id;
-		}
-		hd_info = (PHD_Info)buffer;
-	} else {
-		hd_req = (PHD_Info_Request)buffer;
-		header = &hd_req->header;
-		if (header->requestType == REQUEST_BY_RANGE) {
-			start_id = header->startingIndexOrId;
-			end_id = MAX_ID;
-		} else if (header->requestType == REQUEST_BY_ID) {
-			start_id = header->startingIndexOrId;
-			end_id = header->startingIndexOrId;
-		}
-		hd_info = hd_req->hdInfo;
-		header->numReturned = 0;
-		header->nextStartingIndex = NO_MORE_DATA;
-	}
-
-	for (i = start_id; i <= end_id; i++) {
-		dev = (domain_device *)get_device_by_id(&core->lib_dev, i);
-		if ((dev != NULL) &&
-			((dev->base.type == BASE_TYPE_DOMAIN_DEVICE)||
-			(dev->base.type == BASE_TYPE_DOMAIN_I2C)||
-			(dev->base.type == BASE_TYPE_DOMAIN_ENCLOSURE))) {
-			core_get_hd_information(core, dev, hd_info);
-		} else {
-			hd_info->Link.Self.DevID = i;
-			hd_info->Link.Self.DevType = DEVICE_TYPE_NONE;
-		}
-
-		if (!useVariableSize) {
-			hd_info++;
-		} else {
-			if (hd_info->Link.Self.DevType != DEVICE_TYPE_NONE) {
-				header->numReturned++;
-				hd_info++;
-				if ((header->requestType == REQUEST_BY_RANGE) &&
-					(header->numReturned == header->numRequested)){
-					header->nextStartingIndex = i+1;
-					break;
-				}
-			}
-		}
-	}
-}
-
-
-
-MV_U8
-core_pd_request_get_hd_info(core_extension * core_p, PMV_Request req)
-{
-	MV_U16 hd_id = 0xFFFF;
-	PHD_Info hd_info = NULL;
-        MV_PVOID buf_ptr = core_map_data_buffer(req);
-	PHD_Info_Request hd_req = (PHD_Info_Request)buf_ptr;
-
-	if (buf_ptr == NULL ||
-		req->Data_Transfer_Length < sizeof(HD_Info_Request)) {
-
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	Core_GetHDInfo(core_p, hd_id, buf_ptr, MV_TRUE);
-
-	if (hd_req->header.requestType == REQUEST_BY_ID &&
-		hd_req->header.numReturned == 0) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_HD_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-	} else
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-        core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_VOID
-core_get_hd_information_ext(core_extension * core_p, domain_device *dev,
-	PHD_Info hd)
-{
-	MV_U8 i;
-	MV_U8 count;
-	pl_root * root;
-	domain_enclosure *enc = NULL;
-
-	hd->Link.Self.DevID = dev->base.id;
-	hd->Link.Self.EnclosureID = 0xFFFF;
-	hd->Link.Parent.EnclosureID = 0xFFFF;
-	if(dev->base.type == BASE_TYPE_DOMAIN_DEVICE){
-		if ( !(dev->status&DEVICE_STATUS_FUNCTIONAL) ||
-			 (dev->status & DEVICE_STATUS_SECONDARY_PATH) ||
-			 (dev->state != DEVICE_STATE_INIT_DONE))
-		{
-			hd->Link.Self.DevType = DEVICE_TYPE_NONE;
-			return;
-		}
-
-		if (IS_ENCLOSURE(dev)) {
-			hd->Link.Self.DevType = DEVICE_TYPE_ENCLOSURE;
-		}
-
-		switch( dev->dev_type ) {
-		case DT_DIRECT_ACCESS_BLOCK:
-			hd->Link.Self.DevType = DEVICE_TYPE_HD;
-			break;
-		case DT_SEQ_ACCESS:
-			hd->Link.Self.DevType = DEVICE_TYPE_TAPE;
-			break;
-		case DT_CD_DVD:
-			hd->Link.Self.DevType = DEVICE_TYPE_CD_DVD;
-			break;
-		case DT_PRINTER:
-			hd->Link.Self.DevType = DEVICE_TYPE_PRINTER;
-			break;
-		case DT_PROCESSOR:
-			hd->Link.Self.DevType = DEVICE_TYPE_PROCESSOR;
-			break;
-		case DT_WRITE_ONCE:
-			hd->Link.Self.DevType = DEVICE_TYPE_WRITE_ONCE;
-			break;
-		case DT_OPTICAL_MEMORY:
-			hd->Link.Self.DevType = DEVICE_TYPE_OPTICAL_MEMORY;
-			break;
-		case DT_MEDIA_CHANGER:
-			hd->Link.Self.DevType = DEVICE_TYPE_MEDIA_CHANGER;
-			break;
-		default:
-			hd->Link.Self.DevType = DEVICE_TYPE_HD;
-		}
-
-		hd->Link.Self.PhyID[0] = 0;
-		hd->Link.Self.PhyCnt = 1;
-
-		if (dev->base.parent != NULL) {
-			if (dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-				hd->Link.Parent.DevID = dev->base.parent->id;
-				hd->Link.Parent.DevType = DEVICE_TYPE_EXPANDER;
-				hd->Link.Parent.PhyID[0] = dev->parent_phy_id;
-				hd->Link.Parent.PhyCnt = 1;
-				if (((domain_expander *)(dev->base.parent))->enclosure) {
-					hd->Link.Parent.EnclosureID = ((domain_expander *)(dev->base.parent))->enclosure->base.id;
-				}
-				MV_CopyMemory( hd->Link.Parent.SAS_Address, &((domain_expander *)dev->base.parent)->sas_addr.value, 8 );
-				MV_CopyMemory( hd->Link.Self.SAS_Address, &dev->sas_addr.value, 8 );
-			} else if(dev->base.parent->type == BASE_TYPE_DOMAIN_PM) {
-				hd->Link.Parent.DevID = dev->base.parent->id;
-				hd->Link.Parent.DevType = DEVICE_TYPE_PM;
-				hd->Link.Parent.PhyID[0] = dev->pm_port;
-				hd->Link.Parent.PhyCnt = 1;
-			} else if(dev->base.parent->type == BASE_TYPE_DOMAIN_PORT) {
-				hd->Link.Parent.DevID = 0;
-				hd->Link.Parent.DevType = DEVICE_TYPE_PORT;
-
-				count = 0;
-				root = dev->base.root;
-				for (i = 0; i < root->phy_num; i++) {
-					if (dev->base.port->phy_map & MV_BIT(i)) {
-						if ((count == 0) && IS_SSP(dev)) {
-							MV_CopyMemory(hd->Link.Parent.SAS_Address, &root->phy[i].dev_sas_addr, 8);
-							MV_CopyMemory(hd->Link.Self.SAS_Address, &root->phy[i].att_dev_sas_addr, 8);
-						}
-						MV_DASSERT(count < MAX_WIDEPORT_PHYS);
-						hd->Link.Parent.PhyID[count++] = i+(MV_U8)root->base_phy_num;
-					}
-				}
-				hd->Link.Parent.PhyCnt = count;
-			}
-		}
-
-		hd->InitStatus = PD_INIT_STATUS_OK;
-
-		hd->ConnectionType = dev->connection;
-		hd->DeviceType = dev->dev_type;
-		if (dev->dev_type == DT_SES_DEVICE)
-			hd->DeviceType = DT_DIRECT_ACCESS_BLOCK;
-
-		mv_swap_bytes(hd->Link.Parent.SAS_Address, 8);
-		mv_swap_bytes(hd->Link.Self.SAS_Address, 8);
-
-		hd->PIOMode = dev->pio_mode;
-		hd->MDMAMode = 0;
-		hd->UDMAMode = dev->udma_mode;
-		hd->CurrentPIOMode = dev->current_pio;
-		hd->CurrentMDMAMode = 0;
-		hd->CurrentUDMAMode = dev->current_udma;
-		hd->ActivityLEDStatus = dev->sgpio_act_led_status;
-		hd->LocateLEDStatus = dev->sgpio_locate_led_status;
-		hd->ErrorLEDStatus = dev->sgpio_error_led_status;
-		hd->ElementIdx = dev->ses_overall_element_index;
-		hd->SesDeviceType = dev->ses_element_type;
-		if(dev->enclosure)
-			hd->Link.Self.EnclosureID = dev->enclosure->base.id;
-		hd->FeatureSupport = 0;
-		if (dev->capability & DEVICE_CAPABILITY_NCQ_SUPPORTED)
-			hd->FeatureSupport |= HD_FEATURE_NCQ;
-		if (dev->capability & DEVICE_CAPABILITY_WRITECACHE_SUPPORTED)
-			hd->FeatureSupport |= HD_FEATURE_WRITE_CACHE;
-		if (dev->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED)
-			hd->FeatureSupport |= HD_FEATURE_48BITS;
-		if (dev->capability & DEVICE_CAPABILITY_SMART_SUPPORTED)
-			hd->FeatureSupport |= HD_FEATURE_SMART;
-
-		if (dev->capability & DEVICE_CAPABILITY_RATE_1_5G)
-			hd->FeatureSupport |= HD_FEATURE_1_5G;
-		if (dev->capability & DEVICE_CAPABILITY_RATE_3G)
-			hd->FeatureSupport |= HD_FEATURE_3G;
-		if (dev->capability & DEVICE_CAPABILITY_RATE_6G)
-			hd->FeatureSupport |= HD_FEATURE_6G;
-
-		if (dev->capability & DEVICE_CAPABILITY_SSD)
-			hd->HD_SSD_Type = HD_SSD_TYPE_UNKNOWN_SSD;
-
-		MV_CopyMemory(hd->Model, dev->model_number, 40);
-		MV_CopyMemory(hd->SerialNo, dev->serial_number, 20);
-		MV_CopyMemory(hd->FWVersion, dev->firmware_revision, 8);
-
-		if ((IS_STP_OR_SATA(dev)) || IS_SSP(dev))
-			MV_CopyMemory(hd->WWN, &dev->WWN, 8);
-
-		hd->Size = U64_ADD_U32(dev->max_lba, 1);
-
-		if((DC_ATA & hd->ConnectionType) && (DC_SERIAL & hd->ConnectionType)){
-			hd->sata_signature=dev->signature;
-		} else
-			hd->sata_signature=0;
-	} else if ((dev->base.type == BASE_TYPE_DOMAIN_I2C)
-		|| (dev->base.type == BASE_TYPE_DOMAIN_ENCLOSURE)) {
-	       enc = (domain_enclosure *)dev;
-		if ( !(enc->status&ENCLOSURE_STATUS_FUNCTIONAL) ||
-			 (enc->state != ENCLOSURE_INIT_DONE)) {
-			hd->Link.Self.DevType = DEVICE_TYPE_NONE;
-			return;
-		}
-
-		hd->Link.Self.DevType = DEVICE_TYPE_ENCLOSURE;
-		hd->Link.Self.EnclosureID = 0xFFFF;
-		hd->Link.Parent.EnclosureID = 0xFFFF;
-
-		hd->Link.Self.PhyID[0] = 0;
-		hd->Link.Self.PhyCnt = 1;
-		hd->DeviceType = DT_ENCLOSURE;
-
-		if (dev->base.parent != NULL) {
-			if(dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-				hd->Link.Parent.DevID = dev->base.parent->id;
-				hd->Link.Parent.DevType = DEVICE_TYPE_EXPANDER;
-				hd->Link.Parent.PhyID[0] = dev->parent_phy_id;
-				hd->Link.Parent.PhyCnt = 1;
-				hd->Link.Parent.EnclosureID = enc->base.id;
-				MV_CopyMemory( hd->Link.Parent.SAS_Address, &((domain_expander *)enc->base.parent)->sas_addr.value, 8 );
-			} else if(dev->base.parent->type == BASE_TYPE_DOMAIN_PORT) {
-				hd->Link.Self.EnclosureID = enc->base.id;
-				hd->Link.Parent.EnclosureID =enc->base.id;
-				hd->Link.Parent.DevID = 0;
-				hd->Link.Parent.DevType = DEVICE_TYPE_PORT;
-				hd->Link.Parent.PhyCnt = 0;
-
-	                }
-
-	        }
-
-		hd->InitStatus = PD_INIT_STATUS_OK;
-		hd->HDType = HD_TYPE_SAS |HD_TYPE_SES;
-
-		mv_swap_bytes(hd->Link.Parent.SAS_Address, 8);
-		mv_swap_bytes(hd->Link.Self.SAS_Address, 8);
-
-		MV_CopyMemory(hd->Model, enc->vendor_id, 8);
-		MV_CopyMemory(hd->Model+8, enc->product_id, 16);
-		MV_CopyMemory(hd->FWVersion, enc->product_revision, 4);
-
-		/* Set PD Sector Size */
-		hd->BlockSize = 0;
-		hd->Size.value = 0;
-       }
-}
-
-MV_VOID core_get_hd_info_ext(MV_PVOID extension, MV_U16 hd_id, MV_PVOID buffer)
-{
-	core_extension * core = (core_extension *)extension;
-	MV_U16 start_id = 0, end_id = 0;
-	domain_device *dev = NULL;
-	PHD_Info_Request hd_req;
-	PHD_Info hd_info;
-	PRequestHeader header = NULL;
-	MV_U16 i;
-
-	hd_req = (PHD_Info_Request)buffer;
-	header = &hd_req->header;
-	if (header->requestType == REQUEST_BY_RANGE) {
-		start_id = header->startingIndexOrId;
-		end_id = MAX_ID;
-	} else if (header->requestType == REQUEST_BY_ID) {
-		start_id = header->startingIndexOrId;
-		end_id = header->startingIndexOrId;
-	}
-	hd_info = hd_req->hdInfo;
-	header->numReturned = 0;
-	header->nextStartingIndex = NO_MORE_DATA;
-
-	for (i = start_id; i <= end_id; i++) {
-		dev = (domain_device *)get_device_by_id(&core->lib_dev, i);
-		if ((dev != NULL) &&
-			((dev->base.type == BASE_TYPE_DOMAIN_DEVICE)||
-			(dev->base.type == BASE_TYPE_DOMAIN_I2C)||
-			(dev->base.type == BASE_TYPE_DOMAIN_ENCLOSURE))) {
-			core_get_hd_information_ext(core, dev, hd_info );
-		} else {
-			hd_info->Link.Self.DevID = i;
-			hd_info->Link.Self.DevType = DEVICE_TYPE_NONE;
-		}
-
-		if (hd_info->Link.Self.DevType != DEVICE_TYPE_NONE) {
-			header->numReturned++;
-			hd_info++;
-			if ((header->requestType == REQUEST_BY_RANGE) &&
-				(header->numReturned == header->numRequested)) {
-				header->nextStartingIndex = i + 1;
-				break;
-			}
-		}
-	}
-}
-
-MV_U8 core_pd_request_get_hd_info_ext(core_extension * core_p, PMV_Request req)
-{
-	MV_U16 hd_id = 0xFFFF;
-	PHD_Info hd_info = NULL;
-        MV_PVOID buf_ptr = core_map_data_buffer(req);
-	PHD_Info_Request hd_req = (PHD_Info_Request)buf_ptr;
-
-	if (buf_ptr == NULL ||
-		req->Data_Transfer_Length < sizeof(HD_Info_Request)) {
-
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (hd_req->header.startingIndexOrId >= MAX_ID) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_HD_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-                core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	core_get_hd_info_ext(core_p, hd_id, buf_ptr);
-
-	if (hd_req->header.requestType == REQUEST_BY_ID &&
-		hd_req->header.numReturned == 0) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_HD_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-	} else
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-        core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_VOID core_get_hd_configuration(core_extension *core, domain_port *port,
-	domain_device *device, PHD_Config hd)
-{
-	if (!(device->status & DEVICE_STATUS_FUNCTIONAL)) {
-		hd->HDID = 0xFF;
-		return;
-	}
-
-	hd->HDID = device->base.id ;
-
-	if (device->setting & DEVICE_SETTING_WRITECACHE_ENABLED)
-		hd->WriteCacheOn = MV_TRUE;
-	else
-		hd->WriteCacheOn = MV_FALSE;
-
-	if (device->setting & DEVICE_SETTING_SMART_ENABLED)
-		hd->SMARTOn = MV_TRUE;
-	else
-		hd->SMARTOn = MV_FALSE;
-
-	if (device->negotiated_link_rate == PHY_LINKRATE_6)
-		hd->DriveSpeed = HD_SPEED_6G;
-	else if (device->negotiated_link_rate == PHY_LINKRATE_3)
-		hd->DriveSpeed = HD_SPEED_3G;
-	else
-		hd->DriveSpeed = HD_SPEED_1_5G;
-}
-
-MV_VOID core_get_hd_config(MV_PVOID extension, MV_PVOID buffer)
-{
-	core_extension * core = (core_extension *)extension;
-	MV_U16 start_id = 0, end_id = 0;
-	domain_port *port = NULL;
-	domain_device *device = NULL;
-	domain_base *base = NULL;
-	PHD_Config hd;
-	PHD_Config_Request config_req;
-	PRequestHeader header = NULL;
-	MV_U16 i;
-
-	config_req = (PHD_Config_Request)buffer;
-	header = &config_req->header;
-	if (header->requestType == REQUEST_BY_RANGE) {
-		start_id = header->startingIndexOrId;
-		end_id = MAX_ID;
-	} else if (header->requestType == REQUEST_BY_ID) {
-		start_id = header->startingIndexOrId;
-		end_id = header->startingIndexOrId;
-	}
-	hd = config_req->hdConfig;
-	header->numReturned = 0;
-	header->nextStartingIndex = NO_MORE_DATA;
-
-	for (i = start_id; i <= end_id; i++) {
-		base = get_device_by_id(&core->lib_dev, i);
-		if ((base != NULL) && (base->type == BASE_TYPE_DOMAIN_DEVICE)) {
-			device = (domain_device *)base;
-			port = device->base.port;
-			core_get_hd_configuration( core, port, device, hd );
-		} else
-			hd->HDID = 0xFF;
-
-		if (hd->HDID != 0xFF) {
-			header->numReturned++;
-			hd++;
-			if ((header->requestType == REQUEST_BY_RANGE) &&
-				(header->numReturned == header->numRequested)) {
-				header->nextStartingIndex = i+1;
-				break;
-			}
-		}
-	}
-}
-
-MV_BOOLEAN core_pd_request_get_hd_config(core_extension * core_p, PMV_Request req)
-{
-	PHD_Config hd_config = NULL;
-	domain_base *base;
-        MV_PVOID buf_ptr = core_map_data_buffer(req);
-	PHD_Config_Request config_req = (PHD_Config_Request)buf_ptr;
-
-	if (buf_ptr == NULL ||
-		req->Data_Transfer_Length < sizeof(HD_Config_Request)) {
-
-                core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (config_req->header.startingIndexOrId >= MAX_ID){
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_HD_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-                core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	core_get_hd_config(core_p, buf_ptr);
-
-	if (config_req->header.requestType == REQUEST_BY_ID &&
-		config_req->header.numReturned == 0){
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = ERR_INVALID_HD_ID;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-	} else
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-       core_unmap_data_buffer(req);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_U8 core_pd_request_smart_return_status_sata_callback(MV_Request *req)
-{
-        PHD_SMART_Status data_buf = core_map_data_buffer(req);
-        MV_U8 ret = MV_FALSE;
-        if (data_buf != NULL &&
-		req->Data_Transfer_Length >= sizeof(HD_SMART_Status))
-		ret = data_buf->SmartThresholdExceeded;
-        core_unmap_data_buffer(req);
-
-        return (ret);
-}
-
-MV_U8 core_pd_request_smart_return_status_ssp_callback(MV_Request *req)
-{
-        MV_U32 length;
-        MV_PU8 data_buf = (MV_PU8)core_map_data_buffer(req);
-        MV_U8 ret;
-
-        if (data_buf[0] != INFORMATIONAL_EXCEPTIONS_LOG_PAGE) {
-                req->Scsi_Status = REQ_STATUS_ERROR;
-                core_unmap_data_buffer(req);
-                return MV_FALSE;
-        }
-
-        length = (data_buf[2] << 8) + data_buf[3];
-        if (length < 7 || data_buf[7] < 3) {
-                req->Scsi_Status = REQ_STATUS_ERROR;
-                core_unmap_data_buffer(req);
-                return MV_FALSE;
-        }
-
-        ret = ssp_ata_parse_log_sense_threshold_exceed(data_buf,
-                        req->Data_Transfer_Length);
-
-        core_unmap_data_buffer(req);
-        return ret;
-}
-
-MV_VOID core_pd_request_get_hd_status_callback(MV_PVOID root_p,
-        MV_Request *req)
-{
-        pl_root *root = (pl_root *)root_p;
-        core_extension *core = (core_extension *)root->core;
-	domain_device *device = (domain_device *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-        core_context *org_ctx;
-
-	PHD_SMART_Status hd_status;
-	PHD_SMART_Status_Request status_req = NULL;
-        MV_Request *org_req;
-        MV_PVOID buf_ptr = NULL;
-        MV_U16 length;
-        MV_U8 ret = MV_FALSE;
-
-        org_req = req->Org_Req;
-	req->Org_Req = NULL;
-	MV_ASSERT(org_req != NULL);
-
-	org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-	MV_ASSERT(org_ctx != NULL);
-	MV_ASSERT(org_ctx->type == CORE_CONTEXT_TYPE_API);
-
-	if (org_req->Scsi_Status == REQ_STATUS_PENDING ||
-		req->Scsi_Status != REQ_STATUS_SUCCESS)
-		org_req->Scsi_Status = req->Scsi_Status;
-
-        if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-
-                length = MV_MIN(org_req->Sense_Info_Buffer_Length,
-                                req->Sense_Info_Buffer_Length);
-
-                if (org_req->Sense_Info_Buffer != NULL &&
-                        req->Sense_Info_Buffer != NULL &&
-                        length != 0)
-
-                        MV_CopyMemory(org_req->Sense_Info_Buffer,
-                                        req->Sense_Info_Buffer,
-                                        length);
-
-                switch (org_req->Cdb[4]) {
-                case APICDB4_PD_SMART_RETURN_STATUS:
-                        core_generate_event(core, EVT_ID_HD_SMART_POLLING_FAIL,
-                                device->base.id, SEVERITY_WARNING, 0, NULL ,0);
-                        break;
-
-                default:
-                        MV_DASSERT(MV_FALSE);
-                        break;
-                }
-
-                return;
-        }
-
-        switch (org_req->Cdb[4]) {
-        case APICDB4_PD_SMART_RETURN_STATUS:
-                if (IS_STP_OR_SATA(device))
-                        ret = core_pd_request_smart_return_status_sata_callback(
-                                req);
-                else if (IS_SSP(device))
-                        ret = core_pd_request_smart_return_status_ssp_callback(
-                                req);
-                else
-                        MV_DASSERT(MV_FALSE);
-
-                if (ret == MV_TRUE)
-                        core_generate_event(core,
-                                EVT_ID_HD_SMART_THRESHOLD_OVER,
-                                device->base.id, SEVERITY_WARNING,
-                                0, NULL ,0);
-
-                buf_ptr = core_map_data_buffer(org_req);
-                status_req = (PHD_SMART_Status_Request)buf_ptr;
-		hd_status = &status_req->hdSmartStatus[status_req->header.numReturned++];
-		hd_status->HDID = device->base.id;
-		hd_status->SmartThresholdExceeded = ret;
-                break;
-
-        default:
-                MV_ASSERT(MV_FALSE);
-                org_req->Scsi_Status = REQ_STATUS_ERROR;
-                break;
-        }
-
-	org_ctx->u.api_req.remaining--;
-	if (org_ctx->u.api_req.remaining == 0) {
-		if (status_req) {
-			if (status_req->header.requestType == REQUEST_BY_ID ||
-				(status_req->header.requestType == REQUEST_BY_RANGE &&
-				org_ctx->u.api_req.end == MAX_ID))
-				status_req->header.nextStartingIndex = NO_MORE_DATA;
-			else
-				status_req->header.nextStartingIndex = org_ctx->u.api_req.end;
-		}
-		core_queue_completed_req(core, org_req);
-	}
-
-        core_unmap_data_buffer(org_req);
-}
-
-MV_Request *core_pd_make_sata_hd_request(pl_root *root,
-        domain_device *dev,
-        MV_U8 cdb2,
-        MV_ReqCompletion completion)
-{
-        MV_Request *new_req;
-        core_extension *core = (core_extension *)root->core;
-
-        new_req = get_intl_req_resource(root, 0);
-        if (new_req == NULL)
-                return NULL;
-
-        new_req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-        new_req->Cdb[1] = CDB_CORE_MODULE;
-        new_req->Cdb[2] = cdb2;
-
-        new_req->Completion = completion;
-        new_req->Device_Id = dev->base.id;
-
-        return new_req;
-}
-
-MV_U8 core_pd_request_get_hd_status(core_extension * core_p, PMV_Request req)
-{
-	PHD_SMART_Status hd_status;
-	PHD_SMART_Status_Request status_req = NULL;
-	domain_device *device;
-	domain_base *base;
-        pl_root *root;
-	MV_U16 hd_id, start_id, end_id, count;
-	MV_U8 status;
-        MV_PU8 sense_buf;
-        MV_Request *new_req;
-	core_context *ctx;
-
-        status = REQ_STATUS_SUCCESS;
-        sense_buf = (MV_PU8)req->Sense_Info_Buffer;
-        new_req = NULL;
-        status_req = (PHD_SMART_Status_Request)core_map_data_buffer(req);
-
-	if (status_req == NULL ||
-		req->Data_Transfer_Length < sizeof(HD_SMART_Status_Request)) {
-
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (status_req->header.requestType == REQUEST_BY_RANGE) {
-		start_id = status_req->header.startingIndexOrId;
-		end_id = MAX_ID;
-	} else if (status_req->header.requestType == REQUEST_BY_ID) {
-		start_id = status_req->header.startingIndexOrId;
-		end_id = start_id + 1;
-	} else {
-		core_unmap_data_buffer(req);
-		if (sense_buf != NULL)
-			sense_buf[0] = ERR_INVALID_PARAMETER;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	status_req->header.numReturned = 0;
-        core_unmap_data_buffer(req);
-
-	ctx = (core_context *)req->Context[MODULE_CORE];
-	ctx->type = CORE_CONTEXT_TYPE_API;
-	ctx->u.api_req.pointer = req->Cmd_Initiator;
-	count = 0;
-
-	for (hd_id = start_id;
-		count < status_req->header.numRequested && hd_id < end_id;
-		hd_id++) {
-
-		base = get_device_by_id(&core_p->lib_dev, hd_id);
-		if (base == NULL)
-			continue;
-		if (base->type != BASE_TYPE_DOMAIN_DEVICE)
-			continue;
-
-		device = (domain_device *)base;
-		if (!(device->status & DEVICE_STATUS_FUNCTIONAL))
-			continue;
-
-		root = device->base.root;
-		switch (req->Cdb[4]) {
-		case APICDB4_PD_SMART_RETURN_STATUS:
-			if (IS_STP_OR_SATA(device)) {
-				new_req = core_pd_make_sata_hd_request(root, device,
-					CDB_CORE_SMART_RETURN_STATUS,
-					core_pd_request_get_hd_status_callback);
-
-			} else if (IS_SSP(device)) {
-				if (!(device->setting & DEVICE_SETTING_SMART_ENABLED))
-					continue;
-
-				new_req = sas_make_log_sense_req(device, 0x2F,
-					core_pd_request_get_hd_status_callback);
-
-			} else {
-				new_req = NULL;
-				status = ERR_INVALID_HD_ID;
-			}
-			break;
-
-		default:
-			new_req = NULL;
-			status = ERR_INVALID_REQUEST;
-			break;
-		}
-
-		if (new_req == NULL)
-			continue;
-
-		new_req->Org_Req = req;
-		count++;
-		core_append_request(root, new_req);
-	}
-
-	if (count == 0) {
-		if (sense_buf != NULL)
-			sense_buf[0] = ERR_INVALID_HD_ID;
-
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	ctx->u.api_req.start = start_id;
-	ctx->u.api_req.end = hd_id;
-	ctx->u.api_req.remaining = count;
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-MV_VOID
-core_pd_request_set_hd_config_callback(MV_PVOID root_p, MV_Request *req)
-{
-        pl_root *root = (pl_root *)root_p;
-        core_extension *core = (core_extension *)root->core;
-        core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-        domain_device *dev = (domain_device *)get_device_by_id(root->lib_dev,
-			req->Device_Id);
-        MV_Request *org_req;
-        MV_U32 length;
-
-        org_req = sas_clear_org_req(req);
-        if (org_req == NULL) {
-                MV_DASSERT(MV_FALSE);
-                return;
-        }
-
-        org_req->Scsi_Status = req->Scsi_Status;
-        if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-
-                length = MV_MIN(req->Sense_Info_Buffer_Length,
-                                org_req->Sense_Info_Buffer_Length);
-
-                if (req->Sense_Info_Buffer != NULL &&
-                        org_req->Sense_Info_Buffer != NULL)
-
-                        MV_CopyMemory(org_req->Sense_Info_Buffer,
-                                        req->Sense_Info_Buffer,
-                                        length);
-
-                        core_queue_completed_req(core, org_req);
-                        return;
-        }
-
-        switch (org_req->Cdb[4]) {
-        case APICDB4_PD_SET_WRITE_CACHE_OFF:
-                dev->setting &= ~DEVICE_SETTING_WRITECACHE_ENABLED;
-                core_generate_event(core, EVT_ID_HD_CACHE_MODE_CHANGE,
-                        dev->base.id, SEVERITY_INFO, 0, NULL ,0);
-                break;
-        case APICDB4_PD_SET_WRITE_CACHE_ON:
-                dev->setting |= DEVICE_SETTING_WRITECACHE_ENABLED;
-                core_generate_event(core, EVT_ID_HD_CACHE_MODE_CHANGE,
-                        dev->base.id, SEVERITY_INFO, 0, NULL ,0);
-                break;
-        case APICDB4_PD_SET_SMART_OFF:
-                dev->setting &= ~DEVICE_SETTING_SMART_ENABLED;
-                break;
-	case APICDB4_PD_SET_SMART_ON:
-                dev->setting |= DEVICE_SETTING_SMART_ENABLED;
-                break;
-
-        default:
-                MV_DASSERT(MV_FALSE);
-                org_req->Scsi_Status = REQ_STATUS_ERROR;
-                break;
-        }
-
-        core_queue_completed_req(core, org_req);
-}
-
-MV_U8
-core_pd_request_set_hd_config(core_extension * core_p, PMV_Request req)
-{
-	domain_device *device;
-	domain_base *base;
-        pl_root *root;
-        core_extension *core;
-	MV_U16 hd_id;
-	MV_U8 status;
-	MV_U32 phy_status;
-        MV_PU8 sense_buf;
-        MV_Request *new_req = NULL;
-
-        status = REQ_STATUS_SUCCESS;
-        sense_buf = req->Sense_Info_Buffer;
-	hd_id = req->Cdb[2] | (req->Cdb[3] << 8);
-	base = get_device_by_id(&core_p->lib_dev, hd_id);
-
-        if (base == NULL) {
-		if (sense_buf != NULL)
-			sense_buf[0] = ERR_INVALID_HD_ID;
-
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-        }
-
-	if (base->type != BASE_TYPE_DOMAIN_DEVICE) {
-		if (sense_buf != NULL)
-			sense_buf[0] = ERR_INVALID_HD_ID;
-
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-        }
-
-	device = (domain_device *)base;
-        root = device->base.root;
-        core = (core_extension *)root->core;
-
-	if (!(device->status & DEVICE_STATUS_FUNCTIONAL)) {
-		if (sense_buf != NULL)
-			sense_buf[0] = ERR_INVALID_HD_ID;
-
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-        }
-
-        switch (req->Cdb[4]) {
-	case APICDB4_PD_SET_WRITE_CACHE_OFF:
-		if (!(device->capability &
-                        DEVICE_CAPABILITY_WRITECACHE_SUPPORTED)) {
-
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		}
-
-                if (IS_STP_OR_SATA(device) || IS_SSP(device)) {
-                        new_req = core_pd_make_sata_hd_request(root,
-                                device,
-                                CDB_CORE_DISABLE_WRITE_CACHE,
-                                core_pd_request_set_hd_config_callback);
-                } else {
-			req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-                        status = ERR_INVALID_HD_ID;
-                }
-		break;
-
-	case APICDB4_PD_SET_WRITE_CACHE_ON:
-		if (!(device->capability &
-                        DEVICE_CAPABILITY_WRITECACHE_SUPPORTED)) {
-			status = ERR_NOT_SUPPORTED;
-
-		} else if (IS_STP_OR_SATA(device) || IS_SSP(device)) {
-                        new_req = core_pd_make_sata_hd_request(root,
-                                device,
-                                CDB_CORE_ENABLE_WRITE_CACHE,
-                                core_pd_request_set_hd_config_callback);
-                } else {
-			req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-                        status = ERR_INVALID_HD_ID;
-                }
-		break;
-
-        case APICDB4_PD_SET_SMART_OFF:
-                if (IS_STP_OR_SATA(device)) {
-                        new_req = core_pd_make_sata_hd_request(root, device,
-                                CDB_CORE_DISABLE_SMART,
-                                core_pd_request_set_hd_config_callback);
-
-                } else if (IS_SSP(device)) {
-                        device->setting &= ~DEVICE_SETTING_SMART_ENABLED;
-                        req->Scsi_Status = REQ_STATUS_SUCCESS;
-                        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-                } else {
-			req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-                        status = ERR_INVALID_HD_ID;
-                }
-                break;
-
-	case APICDB4_PD_SET_SMART_ON:
-                if (IS_STP_OR_SATA(device)) {
-                        new_req = core_pd_make_sata_hd_request(root, device,
-                                CDB_CORE_ENABLE_SMART,
-                                core_pd_request_set_hd_config_callback);
-
-                } else if (IS_SSP(device)) {
-		        if (device->capability &
-                                DEVICE_CAPABILITY_SMART_SUPPORTED) {
-
-                                device->setting |= DEVICE_SETTING_SMART_ENABLED;
-                        }
-
-                        req->Scsi_Status = REQ_STATUS_SUCCESS;
-                        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-                } else {
-			req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-                        status = ERR_INVALID_HD_ID;
-                }
-		break;
-
-	case APICDB4_PD_SET_SPEED_3G:
-	case APICDB4_PD_SET_SPEED_1_5G:
-		status = ERR_INVALID_PARAMETER;
-		break;
-
-	default:
-		status = ERR_INVALID_REQUEST;
-		break;
-        }
-
-        if (new_req != NULL)
-                sas_replace_org_req(root, req, new_req);
-        else if (status == REQ_STATUS_SUCCESS)
-                return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	if (status != REQ_STATUS_SUCCESS) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)req->Sense_Info_Buffer)[0] = status;
-		req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	} else {
-		req->Scsi_Status = REQ_STATUS_PENDING;
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-	}
-}
--- a/drivers/scsi/vanir/core/api/core_console.h
+++ /dev/null
@@ -1,70 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined(CORE_CONSOLE_H)
-#define CORE_CONSOLE_H
-
-#include "mv_config.h"
-#include "core_header.h"
-
-typedef MV_U8 (*core_management_command_handler)(core_extension *, PMV_Request);
-#define HD_WRITECACHE_OFF		0
-#define HD_WRITECACHE_ON		1
-MV_U8 api_verify_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req);
-
-MV_U8
-core_pd_command(
-	IN MV_PVOID root_p,
-	IN PMV_Request pReq
-	);
-
-MV_U8
-core_pass_thru_send_command(
-	IN MV_PVOID *core_p,
-	IN PMV_Request pReq
-	);
-
-MV_U8 core_ses_command(
-	IN MV_PVOID core_p,
-	IN PMV_Request req
-	);
-
-MV_BOOLEAN
-core_flash_command(
-	IN MV_PVOID core_p,
-	IN PMV_Request p_req
-	);
-
-MV_U8 core_api_inquiry(MV_PVOID core_p, PMV_Request req);
-MV_U8 core_api_read_capacity(MV_PVOID core_p, PMV_Request req);
-MV_U8 core_api_read_capacity_16(MV_PVOID core_p, PMV_Request req);
-MV_U8 core_api_report_lun(MV_PVOID core_p, PMV_Request req);
-MV_U8 core_api_disk_io_control(MV_PVOID core_p, PMV_Request req);
-MV_U8 core_api_alarm_command(MV_PVOID core_p, PMV_Request req);
-
-MV_U8
-mv_get_bbu_info(MV_PVOID core, PMV_Request pReq);
-MV_U8
-mv_set_bbu_threshold(MV_PVOID core, PMV_Request pReq);
-MV_U8
-mv_bbu_power_change(MV_PVOID core, PMV_Request pReq);
-
-MV_U8 core_pd_request_get_hd_info(core_extension * core_p, PMV_Request req);
-MV_U8 core_pd_request_get_enclosure_info(core_extension * core_p, PMV_Request req);
-MV_U8 core_pd_request_get_expander_info(core_extension * core_p, PMV_Request req);
-MV_BOOLEAN core_pd_request_get_hd_config(core_extension * core_p, PMV_Request req);
-MV_U8 core_pd_request_set_hd_config(core_extension * core_p, PMV_Request req);
-MV_U8 core_pd_request_get_hd_status(core_extension * core_p, PMV_Request req);
-MV_U8 core_pd_request_get_hd_info_ext(core_extension * core_p, PMV_Request req);
-#endif /* CORE_CONSOLE_H */
--- a/drivers/scsi/vanir/core/core/core_alarm.c
+++ /dev/null
@@ -1,98 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "core_header.h"
-#include "core_internal.h"
-#include "core_manager.h"
-#include "core_util.h"
-#include "core_alarm.h"
-
-MV_VOID
-core_alarm_init(MV_PVOID core_p)
-{
-	core_extension *core = (core_extension *) core_p;
-
-	core->alarm.alarm_state = ALARM_STATE_OFF;
-	core->alarm.reg_setting = 0;
-	core->alarm.timer_id = 0;
-
-	core_alarm_enable_register(core);
-}
-
-MV_VOID
-core_alarm_timer_callback(MV_PVOID core_p, MV_PVOID tmp)
-{
-	core_extension *core = (core_extension *)core_p;
-	MV_U8 time;
-
-	core->alarm.timer_id = 0;
-
-	switch (core->alarm.alarm_state) {
-	case ALARM_STATE_1S_1S:
-		/* 1 second on , 1 second off */
-		if (core->alarm.reg_setting == ALARM_REG_ON) {
-			time = 1;
-			core->alarm.reg_setting = ALARM_REG_OFF;
-			core_alarm_set_register(core, MV_FALSE);
-		} else {
-			time = 1;
-			core->alarm.reg_setting = ALARM_REG_ON;
-			core_alarm_set_register(core, MV_TRUE);
-		}
-		core->alarm.timer_id = core_add_timer(core, time,
-			core_alarm_timer_callback, core, NULL);
-		break;
-	case ALARM_STATE_OFF:
-		core->alarm.reg_setting = ALARM_REG_OFF;
-		core_alarm_set_register(core, MV_FALSE);
-		break;
-	case ALARM_STATE_MUTE:
-		core->alarm.reg_setting = ALARM_REG_OFF;
-		core_alarm_set_register(core, MV_FALSE);
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-}
-
-MV_VOID
-core_alarm_change_state(MV_PVOID core_p, MV_U8 state)
-{
-	core_extension *core = (core_extension *)core_p;
-
-	switch (state) {
-	case ALARM_STATE_OFF:
-		core->alarm.alarm_state = state;
-		if (core->alarm.timer_id == 0)
-			MV_DASSERT(core->alarm.reg_setting == ALARM_REG_OFF);
-		break;
-	case ALARM_STATE_1S_1S:
-		/* 1 second on , 1 second off */
-		core->alarm.alarm_state = state;
-		if (core->alarm.timer_id == 0) {
-			/* lets start in on state first */
-			core->alarm.timer_id = core_add_timer(core, 1,
-				core_alarm_timer_callback, core, NULL);
-			core->alarm.reg_setting = ALARM_REG_ON;
-			core_alarm_set_register(core, MV_TRUE);
-		}
-		break;
-	case ALARM_STATE_MUTE:
-		core->alarm.alarm_state = ALARM_STATE_MUTE;
-		break;
-	default:
-		CORE_DPRINT(("Invalid alarm state: %d.\n", state));
-		break;
-	}
-}
--- a/drivers/scsi/vanir/core/core/core_alarm.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef _CORE_ALARM_H
-#define _CORE_ALARM_H
-
-typedef enum _alarm_state {
-	ALARM_STATE_OFF = 0,
-	ALARM_STATE_1S_1S,	/* 1s on, 1s off */
-	ALARM_STATE_MUTE,
-	ALARM_STATE_MAX,
-} alarm_state;
-
-enum {
-	ALARM_REG_OFF = 0,
-	ALARM_REG_ON,
-};
-
-typedef struct _lib_alarm {
-	MV_U8 alarm_state;
-	MV_U8 reg_setting;
-	MV_U16 timer_id;
-} lib_alarm;
-
-MV_VOID core_alarm_init(MV_PVOID core_p);
-MV_VOID core_alarm_change_state(MV_PVOID core_p, MV_U8 state);
-
-#endif /* _CORE_ALARM_H */
--- a/drivers/scsi/vanir/core/core/core_device.c
+++ /dev/null
@@ -1,288 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-
-#include "core_device.h"
-#include "core_internal.h"
-#include "core_resource.h"
-#include "core_manager.h"
-#include "com_list.h"
-
-#include "core_error.h"
-#include "core_util.h"
-
-domain_base *get_device_by_id(lib_device_mgr *lib_dev, MV_U16 id)
-{
-	if (id >= MAX_ID)
-		return NULL;
-
-	return lib_dev->device_map[id];
-}
-
-MV_U16 get_id_by_phyid(lib_device_mgr *lib_dev, MV_U16 phy_id)
-{
-	domain_base *base;
-	MV_U16 i = 0xFFFF;
-
-	for(i=0; i< MAX_ID; i++) {
-		base = lib_dev->device_map[i];
-		if (base == NULL) continue;
-		if (base->port == NULL) continue;
-		if (base->port->phy == NULL) continue;
-		if (base->port->phy->id == phy_id){
-			return i;
-		}
-	}
-	return 0xFFFF;
-}
-
-MV_U16 get_id_by_targetid_lun(MV_PVOID ext,  MV_U16 id, MV_U16 lun)
-{
-	core_extension *core = HBA_GetModuleExtension(ext, MODULE_CORE);
-	lib_device_mgr *lib_dev = &core->lib_dev;
-	MV_U16 i = id;
-	if (id >= MAX_ID)
-		return i;
-	for(i=0; i<MAX_ID; i++) {
-		domain_base *base;
-		base = lib_dev->device_map[i];
-		if (base ==NULL)
-			continue;
-		if ( (base->TargetID== id)&&(base->LUN == lun)){
-			return i;
-		}
-	}
-	for(i=0; i<MAX_ID; i++) {
-		domain_base *base;
-		base = lib_dev->device_map[i];
-		if (base ==NULL)
-			return i;
-	}
-	return 0xffff;
-}
-
-MV_U16 get_device_lun(lib_device_mgr *lib_dev, MV_U16 id)
-{
-	domain_base *base=NULL;
-	base = lib_dev->device_map[id];
-	if(base == NULL)
-		return 0xffff;
-	return base->LUN ;
-
-}
-MV_U16 get_device_targetid(lib_device_mgr *lib_dev, MV_U16 id)
-{
-	domain_base *base=NULL;
-	base = lib_dev->device_map[id];
-	if(base == NULL)
-		return 0xFFFF;
-	return base->TargetID;
-
-}
-
-domain_device *get_device_by_register_set(pl_root *root,
-	MV_U8 register_set)
-{
-	lib_device_mgr *lib_dev = root->lib_dev;
-	domain_device *device;
-	domain_base *base;
-	MV_U16 i;
-
-	for (i = 0; i < MAX_ID; i++) {
-		base = lib_dev->device_map[i];
-		if ((base != NULL) && (base->type == BASE_TYPE_DOMAIN_DEVICE)) {
-			device = (domain_device *)base;
-			if (IS_STP_OR_SATA(device) &&
-				(device->base.root == root) &&
-				(device->register_set == register_set)) {
-				return device;
-			}
-		}
-	}
-
-	return NULL;
-}
-
-MV_U16 get_available_dev_id_new(lib_device_mgr *lib_dev)
-{
-	MV_U16 i;
-	for (i=PORT_NUMBER; i<MAX_ID; i++) {
-		if (lib_dev->device_map[i] == NULL){
-			return i;
-			}
-	}
-	return MAX_ID;
-}
-
-MV_U16 get_available_dev_id(lib_device_mgr *lib_dev)
-{
-	int i;
-
-	for (i=MAX_ID-1; i>=0; i--) {
-		if (lib_dev->device_map[i] == NULL){
-			return i;
-		}
-	}
-	return MAX_ID;
-}
-
-MV_U16
-get_avail_non_storage_dev_id(lib_device_mgr *lib_dev)
-{
-	MV_U16 i;
-
-	for (i=MV_MAX_HD_DEVICE_ID; i<MAX_ID; i++) {
-		if (lib_dev->device_map[i] == NULL)
-			return i;
-	}
-	return MAX_ID;
-}
-
-MV_VOID release_available_dev_id(lib_device_mgr *lib_dev, MV_U16 id)
-{
-	MV_ASSERT(id < MAX_ID);
-	lib_dev->device_map[id] = NULL;
-}
-
-MV_BOOLEAN change_device_map(lib_device_mgr *lib_dev, domain_base *base,
-	MV_U16 old_id, MV_U16 new_id)
-{
-	MV_ASSERT(old_id < MAX_ID);
-	MV_ASSERT(new_id < MAX_ID);
-	MV_ASSERT(lib_dev->device_map[old_id] == base);
-
-	if (lib_dev->device_map[new_id] != NULL)
-		return MV_FALSE;
-
-	lib_dev->device_map[old_id] = NULL;
-	lib_dev->device_map[new_id] = base;
-	return MV_TRUE;
-}
-
-MV_U16 add_device_map(lib_device_mgr *lib_dev, domain_base *base)
-{
-	MV_U16 id = get_available_dev_id(lib_dev);
-	if (id >= MAX_ID) {
-		CORE_DPRINT(("out of device ids.\n"));
-		return MAX_ID;
-	}
-	lib_dev->device_map[id] = base;
-	return id;
-}
-
-MV_VOID remove_device_map(lib_device_mgr *lib_dev, MV_U16 id)
-{
-	release_available_dev_id(lib_dev, id);
-}
-
-MV_VOID set_up_new_base(pl_root *root, domain_port *port,
-	domain_base *base,
-	command_handler *handler, enum base_type type, MV_U16 size)
-{
-	base->port = port;
-	base->handler = handler;
-	base->queue_depth = 1; /* will be update later */
-	base->root = root;
-	base->type = type;
-	base->LUN = 0;
-	base->TargetID = 0xFFFF;
-	base->multi_lun = MV_FALSE;
-	base->struct_size = size;
-	base->outstanding_req = 0;
-	base->parent = &port->base; /* by default set to port */
-       base->blocked = MV_FALSE;
-	base->cmd_issue_stopped = MV_FALSE;
-
-	/* error handling */
-	MV_LIST_HEAD_INIT(&base->err_ctx.sent_req_list);
-	MV_DASSERT(base->err_ctx.eh_state == 0);
-	base->err_ctx.eh_type = EH_TYPE_NONE;
-	base->err_ctx.eh_state = EH_STATE_NONE;
-	base->err_ctx.error_req = NULL;
-	base->err_ctx.state = BASE_STATE_NONE;
-	base->err_ctx.pm_eh_error_port = 0xff;
-	base->err_ctx.pm_eh_active_port = 0xff;
-	base->err_ctx.timeout_count = 0;
-	base->err_ctx.timer_id = NO_CURRENT_TIMER;
-	base->err_ctx.eh_timer = NO_CURRENT_TIMER;
-	base->err_ctx.error_count = 0;
-}
-
-MV_VOID set_up_new_device(pl_root *root, domain_port *port,
-	domain_device *device,
-	command_handler *handler)
-{
-	set_up_new_base(root, port, &device->base,
-		handler,
-		BASE_TYPE_DOMAIN_DEVICE,
-		sizeof(domain_device));
-	device->status = DEVICE_STATUS_FUNCTIONAL;
-	device->register_set = NO_REGISTER_SET;
-	device->curr_phy_map = 0;
-}
-
-MV_VOID set_up_new_pm(pl_root *root, domain_port *port,
-	domain_pm *pm)
-{
-	set_up_new_base(root, port, &pm->base,
-		(command_handler *)core_get_handler(root, HANDLER_PM),
-                BASE_TYPE_DOMAIN_PM,
-                sizeof(domain_pm));
-	pm->status = PM_STATUS_EXISTING | PM_STATUS_FUNCTIONAL;
-	pm->state = PM_STATE_RESET_DONE;
-	pm->register_set = NO_REGISTER_SET;
-	pm->sata_sig_timer = NO_CURRENT_TIMER;
-
-
-	set_up_new_base(root, port, &port->base,
-		(command_handler *)core_get_handler(root, HANDLER_SATA_PORT),
-		BASE_TYPE_DOMAIN_PORT,
-		sizeof(domain_port));
-	port->pm = pm;
-	port->sata_sig_timer = NO_CURRENT_TIMER;
-
-}
-
-MV_VOID set_up_new_expander(pl_root *root, domain_port *port,
-	domain_expander *expander)
-{
-	set_up_new_base(root, port, &expander->base,
-		(command_handler *)core_get_handler(root, HANDLER_SMP),
-		BASE_TYPE_DOMAIN_EXPANDER,
-		sizeof(domain_expander));
-
-	expander->state = EXP_STATE_REPORT_GENERAL;
-	expander->status = EXP_STATUS_EXISTING | EXP_STATUS_FUNCTIONAL;
-	MV_LIST_HEAD_INIT(&expander->device_list);
-	MV_LIST_HEAD_INIT(&expander->expander_list);
-	expander->device_count = 0;
-	expander->expander_count = 0;
-       expander->has_been_setdown = MV_FALSE;
-	expander->has_been_reset = MV_TRUE;
-	expander->timer_tag = NO_CURRENT_TIMER;
-	MV_ZeroMemory(expander->route_table, sizeof(MV_U16)*MAXIMUM_EXPANDER_PHYS);
-}
-MV_VOID set_up_new_enclosure(pl_root *root, domain_port *port,
-	domain_enclosure *enclosure,
-	command_handler *handler)
-{
-	set_up_new_base(root, port, &enclosure->base,
-		handler,
-		BASE_TYPE_DOMAIN_ENCLOSURE,
-		sizeof(domain_enclosure));
-	MV_LIST_HEAD_INIT(&enclosure->expander_list);
-	enclosure->status = ENCLOSURE_STATUS_EXISTING | ENCLOSURE_STATUS_FUNCTIONAL;
-	enclosure->enc_flag = ENC_FLAG_FIRST_INIT;
-}
--- a/drivers/scsi/vanir/core/core/core_device.h
+++ /dev/null
@@ -1,55 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef _CORE_DEVICE_H
-#define _CORE_DEVICE_H
-
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_internal.h"
-
-struct _lib_device_mgr {
-	domain_base      *device_map[MAX_ID];
-	MV_U16 target_id_map[MV_MAX_TARGET_NUMBER];
-};
-
-domain_base *get_device_by_id(lib_device_mgr *lib_dev, MV_U16 id);
-MV_U16 get_id_by_phyid(lib_device_mgr *lib_dev, MV_U16 phy_id);
-MV_U16 get_id_by_targetid_lun(MV_PVOID ext, MV_U16 id,MV_U16 lun);
-MV_U16 get_device_lun(lib_device_mgr *lib_dev, MV_U16 id);
-MV_U16 get_device_targetid(lib_device_mgr *lib_dev, MV_U16 id);
-domain_device *get_device_by_register_set(pl_root *root,
-	MV_U8 register_set);
-MV_U16 get_available_dev_id_new(lib_device_mgr *lib_dev);
-MV_U16 get_available_dev_id(lib_device_mgr *lib_dev);
-MV_U16 get_avail_non_storage_dev_id(lib_device_mgr *lib_dev);
-MV_VOID release_available_dev_id(lib_device_mgr *lib_dev, MV_U16 id);
-
-MV_U16 add_device_map(lib_device_mgr *lib_dev, domain_base *base);
-MV_VOID remove_device_map(lib_device_mgr *lib_dev, MV_U16 id);
-MV_BOOLEAN change_device_map(lib_device_mgr *lib_dev, domain_base *base,
-	MV_U16 old_id, MV_U16 new_id);
-
-MV_VOID set_up_new_base(pl_root *root, domain_port *port,
-	domain_base *base,
-	command_handler *handler, enum base_type type, MV_U16 size);
-MV_VOID set_up_new_device(pl_root *root, domain_port *port,
-	domain_device *device, command_handler *handler);
-MV_VOID set_up_new_pm(pl_root *root, domain_port *port,
-	domain_pm *pm);
-MV_VOID set_up_new_expander(pl_root *root, domain_port *port,
-	domain_expander *expander);
-MV_VOID set_up_new_enclosure(pl_root *root, domain_port *port,
-	domain_enclosure *enclosure,
-	command_handler *handler);
-#endif /* _CORE_DEVICE_H */
--- a/drivers/scsi/vanir/core/core/core_error.c
+++ /dev/null
@@ -1,1351 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "core_manager.h"
-#include "core_util.h"
-#include "core_hal.h"
-#include "core_sas.h"
-#include "core_sata.h"
-
-#include "core_error.h"
-#include "core_util.h"
-#include "core_protocol.h"
-#include "core_api.h"
-
-#include "core_exp.h"
-#include "core_expander.h"
-
-MV_VOID core_req_timeout(MV_PVOID dev_p, MV_PVOID param);
-extern MV_Request *sas_make_task_req(pl_root *root, domain_device *dev,
-MV_Request *org_req, MV_U8 task_function, MV_ReqCompletion func);
-extern MV_VOID core_clean_init_queue_entry(MV_PVOID root_p,
-				domain_base *base);
-
-/*
- * timer related functions
- */
-MV_VOID mv_add_timer(MV_PVOID core_p, MV_Request *req)
-{
-	core_extension *core = (core_extension *)core_p;
-	domain_base *base;
-	MV_U32 seconds;
-	struct _error_context *err_ctx;
-
-	base = get_device_by_id(&core->lib_dev, req->Device_Id);
-	err_ctx = &base->err_ctx;
-
-	if (err_ctx->timer_id == NO_CURRENT_TIMER) {
-		if (req->Time_Out != 0) {
-			seconds = req->Time_Out;
-		} else {
-			seconds = CORE_REQUEST_TIME_OUT_SECONDS;
-		}
-
-		if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-			domain_device *dev = (domain_device *)base;
-			domain_port *port = (domain_port *)dev->base.port;
-			if (IS_HDD(dev)) {
-				seconds = MV_MAX(seconds,
-					CORE_REQUEST_TIME_OUT_SECONDS);
-				if (req->Cdb[0] == SCSI_CMD_INQUIRY) {
-					seconds = CORE_INQUIRE_TIME_OUT_SECONDS;
-				}
-
-			} else if (IS_OPTICAL(dev)) {
-				seconds = 200;
-			} else if (IS_TAPE(dev)) {
-				seconds = 400;
-			}
-		}
-
-		err_ctx->timer_id = core_add_timer(
-			core, seconds, core_req_timeout, base, req);
-	}
-
-	MV_DASSERT(err_ctx->timer_id != NO_CURRENT_TIMER);
-	List_AddTail(&req->Queue_Pointer, &err_ctx->sent_req_list);
-}
-
-MV_VOID mv_cancel_timer(MV_PVOID core_p, MV_PVOID base_p)
-{
-	core_extension *core = (core_extension *)core_p;
-	domain_base *base = (domain_base *)base_p;
-	struct _error_context *err_ctx = &base->err_ctx;
-
-	if (err_ctx->timer_id != NO_CURRENT_TIMER) {
-		core_cancel_timer(core, err_ctx->timer_id);
-		err_ctx->timer_id = NO_CURRENT_TIMER;
-	}
-}
-
-MV_VOID mv_renew_timer(MV_PVOID core_p, MV_Request *req)
-{
-	core_extension *core = (core_extension *)core_p;
-	domain_base *base;
-	MV_Request *oldest_req;
-	struct _error_context *err_ctx;
-
-	base = get_device_by_id(&core->lib_dev, req->Device_Id);
-	if (base == NULL) {
-		CORE_PRINT(("device %d is gone?", req->Device_Id));
-		return;
-	}
-	err_ctx = &base->err_ctx;
-
-	MV_DASSERT(!List_Empty(&err_ctx->sent_req_list));
-
-	/* check if this is the oldest request */
-	oldest_req = (MV_Request *)List_GetFirstEntry(
-		&err_ctx->sent_req_list, MV_Request, Queue_Pointer);
-
-	if (oldest_req == req) {
-		mv_cancel_timer(core, base);
-
-		if (!List_Empty(&err_ctx->sent_req_list)) {
-			oldest_req = LIST_ENTRY(
-				(&err_ctx->sent_req_list)->next, MV_Request, Queue_Pointer);
-
-			if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-				domain_device *dev = (domain_device *)base;
-				MV_DASSERT(!IS_ATAPI(dev));
-				MV_DASSERT(!IS_TAPE(dev));
-			}
-			err_ctx->timer_id = core_add_timer(
-				core, req->Time_Out,core_req_timeout, base, oldest_req);
-			MV_DASSERT(err_ctx->timer_id != NO_CURRENT_TIMER);
-		} else {
-			MV_DASSERT(err_ctx->timer_id == NO_CURRENT_TIMER);
-		}
-	} else {
-		List_Add(&oldest_req->Queue_Pointer, &err_ctx->sent_req_list);
-		List_Del(&req->Queue_Pointer);
-	}
-}
-
-/*
- * error handling common functions
- */
-/* reset slot - clear command active and command issue */
-MV_VOID prot_reset_slot(pl_root *root, domain_base *base, MV_U16 slot,
-	MV_Request *req)
-{
-	CORE_EH_PRINT(("resetting slot %x, req[%p]\n", slot,req));
-	MV_REG_WRITE_DWORD(root->mmio_base,
-		COMMON_CMD_ADDR, CMD_PORT_ACTIVE0 + ((slot >> 5) << 2));
-	MV_REG_WRITE_DWORD(root->mmio_base,
-		COMMON_CMD_DATA, MV_BIT(slot % 32));
-	prot_clean_slot(root, base, slot, req);
-}
-
-MV_U16 gSMPRetryCount = 0;
-
-extern MV_VOID core_push_queues(MV_PVOID core_p);
-MV_VOID
-sas_wait_for_spinup(MV_PVOID dev, MV_PVOID  tmp)
-{
-	domain_device* device = (domain_device *)dev;
-	core_queue_init_entry(device->base.root, &device->base, MV_FALSE);
-	core_push_queues(device->base.root->core);
-}
-/* handle init request error */
-#define SSP_INIT_REQUEST_RETRY_COUNT         100
-#define SMP_INIT_REQUEST_RETRY_COUNT         10
-#define OTHER_INIT_REQUEST_RETRY_COUNT       10
-void core_handle_init_error(pl_root *root, domain_base *base, MV_Request *req)
-{
-	domain_port *port = base->port;
-	domain_device *dev;
-	domain_expander *exp;
-	domain_expander *tmp_exp;
-	domain_enclosure *enc;
-	struct _error_context *err_ctx = &base->err_ctx;
-	core_context *ctx = NULL;
-	MV_U16 retry_count;
-	MV_U8 i;
-
-	retry_count = OTHER_INIT_REQUEST_RETRY_COUNT;
-	if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-		dev = (domain_device *)base;
-		if (IS_SSP(dev)) {
-			retry_count = SSP_INIT_REQUEST_RETRY_COUNT;
-		}
-	}
-	else if (base->type == BASE_TYPE_DOMAIN_EXPANDER) {
-		retry_count = SMP_INIT_REQUEST_RETRY_COUNT;
-		if (gSMPRetryCount < err_ctx->retry_count) {
-			gSMPRetryCount = err_ctx->retry_count;
-		}
-		MV_ASSERT(gSMPRetryCount <= SMP_INIT_REQUEST_RETRY_COUNT);
-	}
-
-	if (((core_extension *)(root->core))->revision_id != VANIR_C2_REV) {
-		ctx = req->Context[MODULE_CORE];
-		if (ctx->error_info & EH_INFO_WD_TO_RETRY) {
-			pal_abort_port_running_req(root, port);
-
-			core_sleep_millisecond(root->core, 10);
-
-			for (i = 0; i < root->phy_num; i++) {
-				if (root->phy[i].port == port) {
-					WRITE_PORT_PHY_CONTROL(root,
-						(&root->phy[i]),
-						(SCTRL_STP_LINK_LAYER_RESET | SCTRL_SSP_LINK_LAYER_RESET));
-				}
-			}
-
-			core_sleep_millisecond(root->core, 50);
-
-			LIST_FOR_EACH_ENTRY_TYPE(tmp_exp, &port->expander_list,
-				domain_expander, base.queue_pointer) {
-				pal_clean_expander_outstanding_req(root, tmp_exp);
-			}
-
-		}
-	}
-
-
-	/* make the init stage error handling as simple as possible
-	 * don't mess up init state machine with runtime error handling state machine
-	 * if it's media error, just retry several times
-	 * if it's timeout, just give up */
-	MV_DASSERT(req->Scsi_Status != REQ_STATUS_SUCCESS);
-
-	err_ctx->retry_count++;
-
-	if (req->Scsi_Status == REQ_STATUS_TIMEOUT) {
-		if (err_ctx->retry_count < retry_count ) {
-			err_ctx->retry_count = retry_count;
-		}
-	}
-	{
-		switch (base->type) {
-		case BASE_TYPE_DOMAIN_DEVICE:
-			dev = (domain_device *)base;
-			if (IS_STP(dev)) {
-				CORE_DPRINT(("STP device %d status %x has error_count %d, req status %X.\n", base->id, dev->state, err_ctx->retry_count, req->Scsi_Status));
-			}
-			break;
-		default:
-			break;
-		}
-	}
-
-	if ((req->Scsi_Status == REQ_STATUS_NO_DEVICE)
-		|| (err_ctx->retry_count > retry_count)) {
-		switch (base->type) {
-		case BASE_TYPE_DOMAIN_DEVICE:
-			dev = (domain_device *)base;
-			pal_set_down_error_disk(root, dev, MV_TRUE);
-			break;
-		case BASE_TYPE_DOMAIN_PM:
-			pal_set_down_port(root, port);
-			break;
-		case BASE_TYPE_DOMAIN_EXPANDER:
-			exp = (domain_expander *)base;
-                        if (exp->has_been_setdown == MV_TRUE) {
-                                MV_DASSERT(MV_FALSE);
-                                return;
-                        }
-			exp->has_been_setdown = MV_TRUE;
-			pal_set_down_expander(root, exp);
-			break;
-		case BASE_TYPE_DOMAIN_ENCLOSURE:
-			enc = (domain_enclosure *)base;
-			if(req->Scsi_Status == REQ_STATUS_NO_DEVICE){
-				pal_set_down_enclosure(root, enc);
-			}else{
-				enc->state = ENCLOSURE_INIT_DONE;
-				core_init_entry_done(root, port, base);
-				return;
-			}
-			break;
-		case BASE_TYPE_DOMAIN_PORT:
-                case BASE_TYPE_DOMAIN_VIRTUAL:
-		default:
-			MV_ASSERT(MV_FALSE);
-			break;
-		}
-
-		core_init_entry_done(root, port, NULL);
-	} else {
-		if((req->Scsi_Status == REQ_STATUS_HAS_SENSE)){
-			MV_U8 sense_key;
-			MV_U16 timer_id;
-			sense_key = ((MV_U8 *)req->Sense_Info_Buffer)[2] & 0x0f;
-			if(sense_key == SCSI_SK_NOT_READY){
-				timer_id = core_add_timer(root->core, 1, sas_wait_for_spinup, base, NULL);
-				MV_ASSERT(timer_id != NO_CURRENT_TIMER);
-				return;
-			}
-		}
-		core_sleep_millisecond(root->core, 10);
-
-		core_queue_init_entry(root, base, MV_FALSE);
-	}
-}
-
-MV_VOID core_req_timeout(MV_PVOID dev_p, MV_PVOID req_p)
-{
-
-	domain_base *base = NULL;
-	MV_Request *err_req = NULL;
-	pl_root *root = NULL;
-	struct _error_context *err_ctx = NULL;
-	core_context *ctx = NULL;
-	MV_Request *first_req = NULL;
-	MV_U32 tmp=0;
-	domain_device *dev = NULL;
-
-	MV_DASSERT(dev_p!= NULL);
-	MV_DASSERT(req_p!= NULL);
-
-	base = (domain_base *)dev_p;
-	err_req = (MV_Request *)req_p;
-	root = (pl_root *)base->root;
-	err_ctx = &base->err_ctx;
-	ctx = err_req->Context[MODULE_CORE];
-
-	if(IS_ATA_PASSTHRU_CMD(err_req,ATA_CMD_SEC_ERASE_UNIT)){
-		CORE_EH_PRINT(("The command of security erase is running...\n"));
-		err_ctx->timer_id = core_add_timer(root->core, 60,core_req_timeout, base, err_req);
-		return;
-	}
-	MV_REG_WRITE_DWORD(root->mmio_base,
-		COMMON_CMD_ADDR, CMD_PORT_ACTIVE0 + ((ctx->slot >> 5) << 2));
-	tmp = MV_REG_READ_DWORD(root->mmio_base, COMMON_CMD_DATA);
-
-	CORE_EH_PRINT(("device %d request %p [0x%x] time out "\
-		"on slot(0x%x) while active=0x%x.\n", \
-		base->id, err_req, err_req->Cdb[0],
-		ctx->slot, tmp));
-	MV_DumpRequest(err_req, MV_FALSE);
-
-	err_ctx->timer_id = NO_CURRENT_TIMER;
-	if (!List_Empty(&err_ctx->sent_req_list)) {
-		first_req = LIST_ENTRY(
-			(&err_ctx->sent_req_list)->next, MV_Request, Queue_Pointer);
-		MV_ASSERT(first_req == err_req);
-	} else {
-		CORE_DPRINT(("no outstanding req on dev %d?\n", base->id));
-		MV_DASSERT(MV_FALSE);
-		return;
-	}
-
-	io_chip_handle_cmpl_queue_int(root);
-
-	if (List_Empty(&err_ctx->sent_req_list)) {
-		CORE_PRINT(("sent_req_list empty\n"));
-		CORE_PRINT(("device %d missed one interrupt for req %p.\n", \
-			base->id, err_req));
-		goto end_point;
-	} else {
-		first_req = LIST_ENTRY(
-			(&err_ctx->sent_req_list)->next, MV_Request, Queue_Pointer);
-		if (first_req != err_req) {
-			CORE_PRINT(("device %d missed one interrupt for req %p.\n", \
-				base->id, err_req));
-			goto end_point;
-		}
-	}
-
-	if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-		dev = (domain_device *)base;
-		if (dev->state == DEVICE_STATE_INIT_DONE) {
-			core_generate_event(root->core, EVT_ID_HD_TIMEOUT, base->id,
-				SEVERITY_WARNING, 0, NULL,0);
-                }
-        }
-
-	MV_ASSERT(base->id == err_req->Device_Id);
-	MV_ASSERT(base == get_device_by_id(root->lib_dev, err_req->Device_Id));
-
-	/* reset the error req slot */
-	prot_reset_slot(root, base, ctx->slot, err_req);
-
-	MV_ASSERT(err_req->Queue_Pointer.next == NULL);
-	MV_ASSERT(err_req->Queue_Pointer.prev == NULL);
-
-	if (CORE_IS_EH_REQ(ctx) || CORE_IS_INIT_REQ(ctx)) {
-		if (CORE_IS_EH_REQ(ctx)) {
-                        err_req->Scsi_Status = REQ_STATUS_TIMEOUT;
-		} else {
-			core_extension *core=(core_extension *)root->core;
-			if(core->spin_up_group){
-				if(base->type == BASE_TYPE_DOMAIN_DEVICE){
-					dev = (domain_device *)base;
-					if(dev->state != DEVICE_STATE_INIT_DONE){
-						dev->state = DEVICE_STATE_INIT_DONE;
-						dev->status |= DEVICE_STATUS_NO_DEVICE;
-						}
-					}
-			}
-			err_req->Scsi_Status = REQ_STATUS_TIMEOUT;
-		}
-		core_queue_completed_req(root->core, err_req);
-	} else {
-		err_req->Scsi_Status = REQ_STATUS_TIMEOUT;
-		CORE_PRINT(("device %d prepare to do EH for timeout request %p.\n",base->id, err_req));
-		core_queue_error_req(root, err_req, MV_TRUE);
-	}
-
-end_point:
-	core_push_queues(root->core);
-}
-MV_VOID core_clean_error_queue(core_extension *core)
-{
-	MV_Request *req;
-	domain_base *base;
-	pl_root *root;
-
-	while (!Counted_List_Empty(&core->error_queue)) {
-		req = (MV_Request *)Counted_List_GetFirstEntry(
-			&core->error_queue, MV_Request, Queue_Pointer);
-		base = (domain_base *)get_device_by_id(&core->lib_dev, req->Device_Id);
-		root = base->root;
-
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		core_complete_error_req(root, req, req->Scsi_Status);
-	}
-}
-MV_VOID core_handle_error_queue(core_extension *core)
-{
-	MV_Request *req;
-	core_context *ctx;
-	domain_base *base;
-	domain_device *device;
-	MV_BOOLEAN ret = MV_FALSE;
-	MV_Request *old_req = NULL;
-	domain_port *port;
-	pl_root *root;
-	MV_U8 i;
-	MV_U16 k, running_count = 0;
-	MV_U8 j;
-
-	for ( j=core->chip_info->start_host; j<(core->chip_info->start_host + core->chip_info->n_host); j++) {
-		root = &core->roots[j];
-		for (k = 0; k < root->slot_count_support; k++) {
-			req = root->running_req[k];
-			if (req == NULL) continue;
-			running_count++;
-		}
-	}
-	if (running_count)
-		return;
-
-	while (!Counted_List_Empty(&core->error_queue)) {
-		req = (MV_Request *)Counted_List_GetFirstEntry(
-			&core->error_queue, MV_Request, Queue_Pointer);
-		if (req == old_req) {
-			/* has gone through the list */
-			Counted_List_Add(&req->Queue_Pointer, &core->error_queue);
-			return;
-		}
-
-		ctx = (core_context *)req->Context[MODULE_CORE];
-		base = (domain_base *)get_device_by_id(&core->lib_dev, req->Device_Id);
-		port = base->port;
-		root = base->root;
-
-		for (i = 0; i < root->phy_num; i++) {
-			port = &root->ports[i];
-			if (port_has_init_req(root, port)) {
-				Counted_List_Add(&req->Queue_Pointer, &core->error_queue);
-				return;
-			}
-		}
-
-		if(port_is_running_error_handling(root, base->port)) {
-				Counted_List_AddTail(&req->Queue_Pointer, &core->error_queue);
-				if (old_req == NULL) old_req = req;
-				continue;
-		}
-
-		if ((base->err_ctx.state == BASE_STATE_ERROR_HANDLED)
-			|| (base->port->base.err_ctx.state == BASE_STATE_ERROR_HANDLED)){
-			core_push_running_request_back(root, req);
-			if (--base->err_ctx.error_count == 0)
-				base->err_ctx.state = BASE_STATE_NONE;
-			if (!port_has_error_req(root, base->port))
-				base->port->base.err_ctx.state = BASE_STATE_NONE;
-			continue;
-		}
-
-		if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-			device = (domain_device *)base;
-
-			if (IS_SSP(device) && (base->outstanding_req >= 1) ) {
-				Counted_List_AddTail(&req->Queue_Pointer, &core->error_queue);
-				if (old_req == NULL) old_req = req;
-				continue;
-			}
-		}
-
-		if (base->handler->error_handler != NULL) {
-			base->err_ctx.state = BASE_STATE_ERROR_HANDLING;
-			ret = base->handler->error_handler(base, req);
-
-			if (ret == MV_FALSE) {
-				base->err_ctx.state = BASE_STATE_NONE;
-				Counted_List_AddTail(&req->Queue_Pointer, &core->error_queue);
-				if (old_req == NULL) old_req = req;
-			}
-		} else {
-			MV_ASSERT(base->err_ctx.state == BASE_STATE_NONE);
-			if (req->Scsi_Status == REQ_STATUS_TIMEOUT) {
-				req->Scsi_Status = REQ_STATUS_ERROR;
-			}
-			core_complete_error_req(root, req, req->Scsi_Status);
-		}
-	}
-}
-
-MV_U32 pal_abort_device_running_req(pl_root *root, domain_base *base)
-{
-	MV_U16 i;
-	MV_Request *req;
-	core_context *ctx;
-	MV_U32 abort_count = 0;
-
-	/* clean cmpl queue in case request is already finished */
-	io_chip_handle_cmpl_queue_int(root);
-
-	for (i = 0; i < root->slot_count_support; i++) {
-		req = root->running_req[i];
-
-		if (req == NULL) continue;
-		if (base->id != req->Device_Id) continue;
-
-		/* make sure this device should still exist */
-		MV_ASSERT(base == get_device_by_id(root->lib_dev, req->Device_Id));
-
-		ctx = (core_context *)req->Context[MODULE_CORE];
-		prot_reset_slot(root, base, i, req);
-		MV_DASSERT(ctx->slot == i);
-
-		/* it has been removed from the sent list in prot_reset_slot */
-		MV_DASSERT(req->Queue_Pointer.next == NULL);
-		MV_DASSERT(req->Queue_Pointer.prev == NULL);
-		/* sg_wrapper should have been released in prot_reset_slot*/
-		MV_DASSERT(ctx->sg_wrapper == NULL);
-
-		core_push_running_request_back(root, req);
-		abort_count++;
-	}
-
-	MV_ASSERT(List_Empty(&(base->err_ctx.sent_req_list)));
-	CORE_EH_PRINT(("%d requests aborted.\n", abort_count));
-
-	/* clear register set, if any */
-	if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-		domain_device *device = (domain_device *)base;
-
-		if (device->register_set != NO_REGISTER_SET) {
-			MV_DASSERT(device->base.outstanding_req == 0);
-			sata_free_register_set(root, device->register_set);
-			device->register_set = NO_REGISTER_SET;
-		}
-	}
-
-	return abort_count;
-}
-
-extern void core_handle_waiting_queue(core_extension *core);
-MV_U32 pal_abort_port_running_req(pl_root *root, domain_port *port)
-{
-	MV_U16 i;
-	MV_U32 abort_count = 0;
-	domain_base *req_base;
-	domain_device *device;
-	MV_Request *req;
-	core_context *ctx;
-
-	/* clean cmpl queue in case request is already finished */
-	CORE_EH_PRINT(("abort: cmpl queue cleaned, pointer 0x%x\n", root->last_cmpl_q));
-	io_chip_handle_cmpl_queue_int(root);
-
-	for (i = 0; i < root->slot_count_support; i++) {
-		req = root->running_req[i];
-
-		if (req == NULL) continue;
-
-		req_base = get_device_by_id(root->lib_dev, req->Device_Id);
-		MV_ASSERT(req_base != NULL);
-		if (req_base->port != port) continue;
-
-		ctx = (core_context *)req->Context[MODULE_CORE];
-		prot_reset_slot(root, req_base, i, req);
-
-		if (req_base->type == BASE_TYPE_DOMAIN_DEVICE) {
-			domain_device *dev = (domain_device *)req_base;
-			if (dev->register_set != NO_REGISTER_SET)
-				CORE_EH_PRINT(("slot's reg set is %d\n", dev->register_set));
-		}
-
-		MV_DASSERT(ctx->slot == i);
-		MV_DASSERT(req->Queue_Pointer.next == NULL);
-		MV_DASSERT(req->Queue_Pointer.prev == NULL);
-		MV_DASSERT(ctx->sg_wrapper == NULL);
-
-		core_push_running_request_back(root, req);
-		abort_count++;
-	}
-
-	/* clear register set, if any */
-	LIST_FOR_EACH_ENTRY_TYPE(device, &port->device_list, domain_device,
-		base.queue_pointer) {
-		if (device->register_set != NO_REGISTER_SET) {
-			MV_DASSERT(device->base.outstanding_req == 0);
-			CORE_EH_PRINT(("freeing reg set %d\n", device->register_set));
-			sata_free_register_set(root, device->register_set);
-			device->register_set = NO_REGISTER_SET;
-		}
-	}
-	CORE_EH_PRINT(("end of function, reg set enable 0 = 0x%x\n",
-		READ_REGISTER_SET_ENABLE(root, 0)));
-	CORE_EH_PRINT(("end of function, cmpl queue pointer 0x%x\n", root->last_cmpl_q));
-
-	CORE_EH_PRINT(("%d requests aborted.\n", abort_count));
-        return abort_count;
-}
-
-void pal_clean_req_callback(pl_root *root, MV_Request *req)
-{
-	domain_base *base = (domain_base *)get_device_by_id(
-		root->lib_dev, req->Device_Id);
-
-	if (base)
-		CORE_EH_PRINT(("base id %d clean up done, type %d\n", base->id, base->type));
-	else
-		MV_ASSERT(MV_FALSE);
-}
-
-void pal_clean_expander_outstanding_req(pl_root *root, domain_expander *exp)
-{
-	domain_device *device;
-	MV_Request *req=NULL;
-	core_context *ctx;
-
-	LIST_FOR_EACH_ENTRY_TYPE(device, &exp->device_list, domain_device,
-		base.exp_queue_pointer) {
-		if (IS_SSP(device)) {
-			req = sas_make_task_req(root, device, NULL,
-				TMF_ABORT_TASK_SET, (MV_ReqCompletion)pal_clean_req_callback);
-		} else if (IS_STP(device)) {
-			req = smp_make_phy_control_req(device, LINK_RESET,
-				pal_clean_req_callback);
-		}
-		if (!req) {
-			CORE_DPRINT(("clean up ran out of reqs\n"));
-			return;
-		} else {
-			CORE_DPRINT(("sending clean up req to device %d\n",
-				device->base.id));
-		}
-		core_queue_eh_req(root, req);
-	}
-}
-
-MV_U32 pal_complete_device_waiting_queue(pl_root *root, domain_base *base,
-	MV_U8 scsi_status, Counted_List_Head *queue)
-{
-	MV_U32 count;
-	MV_Request *req;
-	MV_U32 cmpl_count = 0;
-	core_extension *core = (core_extension *)root->core;
-
-	/* Return the waiting request related to this device. */
-	count = Counted_List_GetCount(queue, MV_FALSE);
-
-	while (count > 0) {
-		MV_ASSERT(!Counted_List_Empty(queue));
-
-		req = (PMV_Request)Counted_List_GetFirstEntry(
-			queue, MV_Request, Queue_Pointer);
-
-		if (base->id != req->Device_Id) {
-			Counted_List_AddTail(&req->Queue_Pointer, queue);
-			count--;
-			continue;
-		}
-
-		MV_ASSERT(base == get_device_by_id(root->lib_dev, req->Device_Id));
-
-		req->Scsi_Status = scsi_status;
-		core_queue_completed_req(core, req);
-		cmpl_count++;
-		count--;
-	}
-
-	return cmpl_count;
-}
-
-MV_U32 core_complete_device_waiting_queue(pl_root *root, domain_base *base,
-	MV_U8 scsi_status)
-{
-	core_extension *core = (core_extension *)root->core;
-	MV_U32 cmpl_count = 0;
-	MV_U32 error_count = 0;
-
-	/* push completion queue to clear up the aborted requests */
-	core_complete_requests(root->core);
-
-	cmpl_count = pal_complete_device_waiting_queue(
-		root, base, scsi_status, &core->high_priority_queue);
-
-	cmpl_count += pal_complete_device_waiting_queue(
-		root, base, scsi_status, &core->waiting_queue);
-
-	error_count = pal_complete_device_waiting_queue(
-			root, base, scsi_status, &core->error_queue);
-	CORE_EH_PRINT(("completed %d error request.\n", error_count));
-	cmpl_count += error_count;
-
-	MV_ASSERT(scsi_status == REQ_STATUS_NO_DEVICE);
-
-	/* push completion queue to clear up the aborted requests */
-	core_complete_requests(root->core);
-
-	if (base->err_ctx.error_req) {
-		core_complete_error_req(root, base->err_ctx.error_req, scsi_status);
-		base->err_ctx.error_req = NULL;
-                CORE_EH_PRINT(("completed one outstanding error request.\n"));
-
-                /* complete this request */
-                core_complete_requests(root->core);
-	}
-
-	base->err_ctx.eh_type = EH_TYPE_NONE;
-	base->err_ctx.state = BASE_STATE_NONE;
-	base->err_ctx.error_count = 0;
-
-	MV_ASSERT(List_Empty(&base->err_ctx.sent_req_list));
-
-	CORE_EH_PRINT(("%d requests completed with status 0x%x.\n", \
-		cmpl_count, scsi_status));
-	return cmpl_count;
-}
-
-/* after calling this function, domain_expander *exp is not valid any more
- * all the devices under this expander got set down too */
-void pal_set_down_expander(pl_root *root, domain_expander *exp)
-{
-	domain_port *port = exp->base.port;
-	MV_BOOLEAN attached;
-	domain_base *tmp;
-	domain_expander *parent_exp, *tmp_exp;
-	domain_device *dev;
-
-        CORE_EH_PRINT(("begin to set down expander %d\n", exp->base.id));
-        MV_ASSERT(get_device_by_id(root->lib_dev, exp->base.id) != NULL);
-	/* free all devices/expanders attached to this expander */
-	while (!List_Empty(&exp->device_list)) {
-		dev = List_GetFirstEntry(&exp->device_list, domain_device,
-			base.exp_queue_pointer);
-		pal_set_down_disk(root, dev, MV_TRUE);
-		exp->device_count--;
-	}
-
-	while (!List_Empty(&exp->expander_list)) {
-		tmp_exp = List_GetFirstEntry(&exp->expander_list, domain_expander,
-			base.exp_queue_pointer);
-		pal_set_down_expander(root, tmp_exp);
-		exp->expander_count--;
-	}
-
-	if(exp->enclosure){
-		domain_enclosure *associate_enc = exp->enclosure;
-		domain_expander *tmp_exp;
-		attached = MV_FALSE;
-		LIST_FOR_EACH_ENTRY_TYPE(
-			tmp_exp, &associate_enc->expander_list, domain_expander, enclosure_queue_pointer){
-			if(tmp_exp == exp)
-				attached = MV_TRUE;
-		}
-		if(attached == MV_TRUE){
-			List_Del(&exp->enclosure_queue_pointer);
-			exp->enclosure = NULL;
-		}
-		if(List_Empty(&associate_enc->expander_list))
-			pal_set_down_enclosure(root,associate_enc);
-	}
-
-	pal_abort_device_running_req(root, &exp->base);
-	core_complete_device_waiting_queue(root, &exp->base, REQ_STATUS_NO_DEVICE);
-        MV_ASSERT(get_device_by_id(root->lib_dev, exp->base.id) != NULL);
-
-	exp->status = 0;
-	exp->state = EXP_STATE_IDLE;
-
-	/* check whether it has been attached to the port */
-	attached = MV_FALSE;
-	LIST_FOR_EACH_ENTRY_TYPE(
-		tmp, &port->expander_list, domain_base, queue_pointer) {
-		if (tmp == (domain_base *)exp) attached = MV_TRUE;
-	}
-	/* can be FALSE if called by pal_set_down_port */
-	if (attached) {
-		List_Del(&exp->base.queue_pointer);
-		port->expander_count--;
-	}
-
-	/* check whether it has been attached to the other lists */
-	attached = MV_FALSE;
-	LIST_FOR_EACH_ENTRY_TYPE(
-		tmp, &port->current_tier, domain_base, queue_pointer) {
-		if (tmp == (domain_base *)exp) attached = MV_TRUE;
-	}
-	if (attached)
-		List_Del(&exp->base.queue_pointer);
-
-	attached = MV_FALSE;
-	LIST_FOR_EACH_ENTRY_TYPE(
-		tmp, &port->next_tier, domain_base, queue_pointer) {
-		if (tmp == (domain_base *)exp) attached = MV_TRUE;
-	}
-	if (attached)
-		List_Del(&exp->base.queue_pointer);
-
-	/* check whether it has been attached to an expander */
-	MV_ASSERT(exp->base.parent != NULL);
-	if (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-		attached = MV_FALSE;
-		parent_exp = (domain_expander *)exp->base.parent;
-		LIST_FOR_EACH_ENTRY_TYPE(
-			tmp, &parent_exp->expander_list, domain_base, exp_queue_pointer) {
-			if (tmp == (domain_base *)exp) attached = MV_TRUE;
-		}
-		/* attached can be false */
-		if (attached) {
-			List_Del(&exp->base.exp_queue_pointer);
-			parent_exp->expander_count--;
-		}
-	}
-
-	core_clean_init_queue_entry(root, &exp->base);
-
-	MV_ASSERT(List_Empty(&exp->device_list));
-	MV_ASSERT(List_Empty(&exp->expander_list));
-	MV_ASSERT(exp->device_count == 0);
-	MV_ASSERT(exp->expander_count == 0);
-
-	core_generate_event(root->core, EVT_ID_EXPANDER_PLUG_OUT, exp->base.id,
-			SEVERITY_INFO, 0, NULL ,0);
-	CORE_EH_PRINT(("set down expander %d is done\n", exp->base.id));
-
-	free_expander_obj(root, root->lib_rsrc, exp);
-}
-
-/* Set disk status to offline, we still have the data structure and link to it. */
-void pal_set_disk_offline(pl_root *root, domain_device *dev, MV_BOOLEAN notify_os)
-{
-	MV_U8 state = dev->state;
-
-       MV_ASSERT(get_device_by_id(root->lib_dev, dev->base.id) != NULL);
-	pal_abort_device_running_req(root, &dev->base);
-	core_complete_device_waiting_queue(root, &dev->base, REQ_STATUS_NO_DEVICE);
-       MV_ASSERT(get_device_by_id(root->lib_dev, dev->base.id) != NULL);
-
-	dev->status = DEVICE_STATUS_NO_DEVICE;
-	dev->state = DEVICE_STATE_INIT_DONE;
-
-	core_clean_init_queue_entry(root, &dev->base);
-
-	if (dev->register_set != NO_REGISTER_SET) {
-		CORE_EH_PRINT(("free device %d register set %d\n", \
-                        dev->base.id, dev->register_set));
-		MV_DASSERT(dev->base.outstanding_req == 0);
-		sata_free_register_set(root, dev->register_set);
-		dev->register_set = NO_REGISTER_SET;
-	}
-
-        if(notify_os) {
-		core_notify_device_hotplug(root, MV_FALSE, dev->base.id,
-			state == DEVICE_STATE_INIT_DONE);
-        }
-
-	Core_Change_LED(root->core, dev->base.id,LED_FLAG_OFF_ALL);
-
-	CORE_EH_PRINT(("set down disk %d\n", dev->base.id));
-
-}
-
-void pal_set_down_error_disk(pl_root *root, domain_device *dev, MV_BOOLEAN notify_os)
-{
-        /* if it's direct attached disk, remove data structure either */
-        if (!IS_BEHIND_EXP(dev)) {
-                pal_set_down_disk(root, dev, notify_os);
-        } else {
-                pal_set_disk_offline(root, dev, notify_os);
-        }
-
-}
-
-void pal_set_down_multi_lun_disk(pl_root *root, domain_device *dev, MV_BOOLEAN notify_os)
-{
-	domain_port *port = dev->base.port;
-	MV_BOOLEAN attached;
-	domain_base *tmp;
-	domain_expander *exp;
-	domain_pm *pm;
-	MV_U32 i;
-
-	pal_set_disk_offline(root, dev, notify_os);
-	/* check whether it has been attached to the port */
-	attached = MV_FALSE;
-	LIST_FOR_EACH_ENTRY_TYPE(
-		tmp, &port->device_list, domain_base, queue_pointer) {
-		if (tmp == (domain_base *)dev) attached = MV_TRUE;
-	}
-	/* can be false if called by pal_set_down_port */
-	if (attached) {
-		List_Del(&dev->base.queue_pointer);
-		port->device_count--;
-	}
-
-	/* check whether it has been attached to the expander */
-	MV_ASSERT(dev->base.parent != NULL);
-	if (dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-		attached = MV_FALSE;
-		exp = (domain_expander *)dev->base.parent;
-		LIST_FOR_EACH_ENTRY_TYPE(
-			tmp, &exp->device_list, domain_base, exp_queue_pointer) {
-			if (tmp == (domain_base *)dev) attached = MV_TRUE;
-		}
-		/* if set down by pal_set_down_expander, maybe not attached anymore */
-		if (attached) {
-			List_Del(&dev->base.exp_queue_pointer);
-			exp->device_count--;
-		}
-	}
-
-	/* check whether it is attached to the PM */
-	if (dev->base.parent->type == BASE_TYPE_DOMAIN_PM) {
-		attached = MV_FALSE;
-		pm = (domain_pm *)dev->base.parent;
-		for (i = 0; i < CORE_MAX_DEVICE_PER_PM; i++) {
-			if (pm->devices[i] == dev) {
-				attached = MV_TRUE;
-				pm->devices[i] = NULL;
-			}
-		}
-		MV_ASSERT(attached == MV_TRUE);
-	}
-
-
-	free_device_obj(root, root->lib_rsrc, dev);
-}
-
-/* after calling this function, domain_device *dev is not valid any more
- * no matter direct attached or under expander
- */
-void pal_set_down_disk(pl_root *root, domain_device *dev, MV_BOOLEAN notify_os)
-{
-	domain_port *port = dev->base.port;
-	MV_BOOLEAN attached;
-	domain_base *tmp;
-	domain_expander *exp;
-	domain_pm *pm;
-	MV_U32 i;
-
-	core_extension *core = root->core;
-	lib_device_mgr *lib_dev = &core->lib_dev;
-	domain_device *dev_multi_lun;
-         if((dev->base.multi_lun == MV_TRUE)&& (dev->base.LUN==0)){
-		CORE_EH_PRINT(("set down multi lun disk %d\n", dev->base.id));
-			for(i=0; i<MAX_ID; i++) {
-			domain_base *base;
-			base = lib_dev->device_map[i];
-			if (base && ( base->TargetID== dev->base.TargetID) && ( base->LUN!=0)){
-				dev_multi_lun = (domain_device *)base;
-                                   pal_set_down_multi_lun_disk(root, dev_multi_lun, notify_os);
-			}
-		}
-         }else if(dev->base.LUN > 0){
-		pal_set_down_multi_lun_disk(root, dev, notify_os);
-		return;
-         }
-
-	pal_set_disk_offline(root, dev, notify_os);
-	/* check whether it has been attached to the port */
-	attached = MV_FALSE;
-	LIST_FOR_EACH_ENTRY_TYPE(
-		tmp, &port->device_list, domain_base, queue_pointer) {
-		if (tmp == (domain_base *)dev) attached = MV_TRUE;
-	}
-	/* can be false if called by pal_set_down_port */
-	if (attached) {
-		List_Del(&dev->base.queue_pointer);
-		port->device_count--;
-	}
-
-	/* check whether it has been attached to the expander */
-	MV_ASSERT(dev->base.parent != NULL);
-	if (dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-		attached = MV_FALSE;
-		exp = (domain_expander *)dev->base.parent;
-		LIST_FOR_EACH_ENTRY_TYPE(
-			tmp, &exp->device_list, domain_base, exp_queue_pointer) {
-			if (tmp == (domain_base *)dev) attached = MV_TRUE;
-		}
-		/* if set down by pal_set_down_expander, maybe not attached anymore */
-		if (attached) {
-			List_Del(&dev->base.exp_queue_pointer);
-			exp->device_count--;
-		}
-	}
-
-	/* check whether it is attached to the PM */
-	if (dev->base.parent->type == BASE_TYPE_DOMAIN_PM) {
-		attached = MV_FALSE;
-		pm = (domain_pm *)dev->base.parent;
-		for (i = 0; i < CORE_MAX_DEVICE_PER_PM; i++) {
-			if (pm->devices[i] == dev) {
-				attached = MV_TRUE;
-				pm->devices[i] = NULL;
-			}
-		}
-		MV_ASSERT(attached == MV_TRUE);
-	}
-
-	remove_target_map(root->lib_dev->target_id_map, dev->base.TargetID, MV_MAX_TARGET_NUMBER);
-	free_device_obj(root, root->lib_rsrc, dev);
-}
-
-MV_U8 pal_check_disk_exist(void *ext, MV_U16 device_target_id, MV_U16 device_lun)
-{
-	core_extension *core = (core_extension *)HBA_GetModuleExtension(ext, MODULE_CORE);
-	pl_root *root = NULL;
-	domain_base *base = NULL;
-
-	base = get_device_by_id(&core->lib_dev, get_id_by_targetid_lun(core, device_target_id, device_lun));
-	if (base == NULL)
-		return 0;
-
-	return 1;
-}
-MV_U8 pal_set_down_disk_from_upper(void *ext, MV_U16 device_target_id, MV_U16 device_lun)
-{
-	core_extension *core = (core_extension *)HBA_GetModuleExtension(ext, MODULE_CORE);
-	pl_root *root = NULL;
-	domain_base *base = NULL;
-
-	base = get_device_by_id(&core->lib_dev, get_id_by_targetid_lun(core, device_target_id, device_lun));
-	if (base == NULL)
-		return -1;
-
-	root = (pl_root *)base->root;
-	if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-		domain_device *device = (domain_device *)base;
-		if(device->state != DEVICE_STATE_INIT_DONE) {
-			CORE_DPRINT(("device %d is bad disk \n",base->id));
-			return 0;
-		}
-	}
-
-	if (base->type == BASE_TYPE_DOMAIN_DEVICE)
-		pal_set_down_disk(root, (domain_device *)base, MV_FALSE);
-	else if (base->type == BASE_TYPE_DOMAIN_ENCLOSURE)
-		pal_set_down_enclosure(root, (domain_enclosure *)base);
-	else
-		MV_ASSERT(0);
-	CORE_DPRINT(("upper layer notify to set down device %d.\n", device_target_id));
-	return 0;
-}
-
-void pal_set_down_enclosure(pl_root *root, domain_enclosure *enc)
-{
-	MV_BOOLEAN attached;
-	domain_port *port = enc->base.port;
-	domain_expander *tmp_exp;
-	domain_device *tmp_dev;
-	domain_base *tmp_base;
-	MV_U8 dev_id;
-	MV_U32 i;
-
-	/*set all associated expander->enclosure = NULL*/
-	if(!List_Empty(&enc->expander_list)){
-		tmp_exp = List_GetFirstEntry(&enc->expander_list, domain_expander, enclosure_queue_pointer);
-		MV_ASSERT(tmp_exp->enclosure == enc);
-		tmp_exp->enclosure = NULL;
-	}
-
-	/* clean up the enclosure pointer for the attached device */
-	for (dev_id = 0; dev_id < MAX_ID; dev_id++) {
-		tmp_base = get_device_by_id(root->lib_dev, dev_id);
-		if (tmp_base == NULL || tmp_base->type != BASE_TYPE_DOMAIN_DEVICE)
-			continue;
-		tmp_dev = (domain_device*)tmp_base;
-		if (tmp_dev->enclosure == enc)
-			tmp_dev->enclosure = NULL;
-	}
-
-	pal_abort_device_running_req(root, &enc->base);
-	core_complete_device_waiting_queue(root, &enc->base, REQ_STATUS_NO_DEVICE);
-       core_clean_init_queue_entry(root, &enc->base);
-
-	enc->status = 0;
-	enc->state = ENCLOSURE_INQUIRY_DONE;
-
-	core_notify_device_hotplug(root, MV_FALSE, enc->base.id, MV_TRUE);
-	CORE_EH_PRINT(("set down enclosure %d\n", enc->base.id));
-
-	remove_target_map(root->lib_dev->target_id_map, enc->base.TargetID, MV_MAX_TARGET_NUMBER);
-	free_enclosure_obj(root, root->lib_rsrc, enc);
-}
-
-void pal_set_down_pm(pl_root *root, domain_pm *pm, MV_BOOLEAN notify_os)
-{
-	domain_port *port = pm->base.port;
-	MV_U8 i;
-
-	pal_abort_device_running_req(root, &pm->base);
-	core_complete_device_waiting_queue(root, &pm->base, REQ_STATUS_NO_DEVICE);
-
-	for (i=0; i<CORE_MAX_DEVICE_PER_PM; i++) {
-		if (pm->devices[i])
-			pal_set_down_disk(root, pm->devices[i], MV_TRUE);
-	}
-       core_clean_init_queue_entry(root, &pm->base);
-
-	pm->status = 0;
-	pm->state = PM_STATE_RESET_DONE;
-
-	CORE_EH_PRINT(("set down pm %d\n", pm->base.id));
-
-	if (pm->register_set != NO_REGISTER_SET) {
-		MV_DASSERT(pm->base.outstanding_req == 0);
-		sata_free_register_set(root, pm->register_set);
-		pm->register_set = NO_REGISTER_SET;
-	}
-
-	MV_ASSERT(port->pm == pm);
-	port->pm = NULL;
-	free_pm_obj(root, root->lib_rsrc, pm);
-}
-
-/* after calling this function, all devices under this port is invalid.
- * dont access them after that. */
-void pal_set_down_port(pl_root *root, domain_port *port)
-{
-	domain_base *base;
-	domain_device *dev;
-	domain_expander *exp;
-	domain_pm   *pm;
-
-	MV_ASSERT(List_Empty(&port->current_tier));
-	MV_ASSERT(List_Empty(&port->next_tier));
-
-	/* expanders & their devices */
-	while(!List_Empty(&port->expander_list)) {
-		exp = (domain_expander *)List_GetFirstEntry(&port->expander_list,
-			domain_expander, base.queue_pointer);
-		pal_set_down_expander(root, exp);
-		port->expander_count--;
-	}
-
-	/* direct attached, for those without targets */
-	while (!List_Empty(&port->device_list)) {
-		base = List_GetFirstEntry(
-			&port->device_list, domain_base, queue_pointer);
-		MV_ASSERT(base->type == BASE_TYPE_DOMAIN_DEVICE);
-		dev = (domain_device *)base;
-		pal_set_down_disk(root, dev, MV_TRUE);
-		port->device_count--;
-	}
-
-	/* set down pm if any */
-	pm = port->pm;
-	if (pm != NULL) {
-		pal_set_down_pm(root, pm, MV_TRUE);
-		port->pm = NULL;
-	}
-
-	MV_ASSERT(port->device_count == 0);
-	MV_ASSERT(port->expander_count == 0);
-	MV_ASSERT(List_Empty(&port->expander_list));
-	MV_ASSERT(List_Empty(&port->device_list));
-	MV_ASSERT(port->pm == NULL);
-
-	CORE_EH_PRINT(("set down port %d\n", port->base.id));
-}
-
-/* retry we allocate internal request to do the retry*/
-MV_Request *core_eh_retry_org_req(pl_root *root, MV_Request *req,
-	MV_ReqCompletion func)
-{
-	MV_Request *eh_req;
-	core_context *ctx;
-
-	/* dont allocate any data buffer, use the original */
-	eh_req = get_intl_req_resource(root, 0);
-	if (eh_req == NULL) return NULL;
-	ctx = eh_req->Context[MODULE_CORE];
-
-	eh_req->Device_Id = req->Device_Id;
-	eh_req->Data_Buffer = req->Data_Buffer;
-	eh_req->Data_Transfer_Length = req->Data_Transfer_Length;
-
-	MV_CopyMemory(eh_req->Cdb, req->Cdb, MAX_CDB_SIZE);
-	eh_req->Cmd_Flag = req->Cmd_Flag;
-	eh_req->LBA.value = req->LBA.value;
-	eh_req->Sector_Count = req->Sector_Count;
-
-	MV_DASSERT(req->Data_Transfer_Length == req->SG_Table.Byte_Count);
-	/* refer to the original SG.
-	 * actually cover the whole buffer because offset=0, size=whole size */
-	if (req->Data_Transfer_Length > 0) {
-		MV_CopyPartialSGTable(
-			&eh_req->SG_Table,
-			&req->SG_Table,
-			0, /* offset */
-			req->SG_Table.Byte_Count /* size */
-		);
-	}
-	MV_DASSERT(eh_req->Data_Transfer_Length == eh_req->SG_Table.Byte_Count);
-
-	ctx->type = CORE_CONTEXT_TYPE_ORG_REQ;
-	ctx->u.org.org_req = req;
-	ctx->req_type = CORE_REQ_TYPE_RETRY;
-
-	eh_req->Scsi_Status = REQ_STATUS_PENDING;
-	eh_req->Completion = func;
-
-	return eh_req;
-}
-MV_BOOLEAN port_is_running_error_handling(pl_root *root, domain_port *port)
-{
-	domain_base *base;
-
-	LIST_FOR_EACH_ENTRY_TYPE(
-		base, &port->device_list, domain_base, queue_pointer) {
-		if (base->err_ctx.state == BASE_STATE_ERROR_HANDLING)
-			return MV_TRUE;
-	}
-
-
-	LIST_FOR_EACH_ENTRY_TYPE(
-		base, &port->expander_list, domain_base, queue_pointer) {
-		if (base->err_ctx.state == BASE_STATE_ERROR_HANDLING)
-			return MV_TRUE;
-	}
-
-	return MV_FALSE;
-}
-MV_BOOLEAN port_has_error_req(pl_root *root, domain_port *port)
-{
-	domain_base *base;
-
-	LIST_FOR_EACH_ENTRY_TYPE(
-		base, &port->device_list, domain_base, queue_pointer) {
-		if (base->err_ctx.error_count > 0) return MV_TRUE;
-	}
-
-	LIST_FOR_EACH_ENTRY_TYPE(
-		base, &port->expander_list, domain_base, queue_pointer) {
-		if (base->err_ctx.error_count > 0) return MV_TRUE;
-	}
-
-	if (port->pm &&
-		(port->pm->base.err_ctx.error_count > 0)) {
-		return MV_TRUE;
-	}
-
-	return MV_FALSE;
-}
-
-MV_BOOLEAN port_has_init_req(pl_root *root, domain_port *port)
-{
-	if (port->init_count != 0)
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-}
-
-MV_BOOLEAN device_has_error_req(pl_root *root, domain_base *base)
-{
-	if (base->err_ctx.error_count > 0)
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-}
-
-MV_Request *core_make_device_reset_req(pl_root *root, domain_port *port,
-	domain_device *dev, MV_ReqCompletion func)
-{
-
-	MV_Request *req;
-
-	/* allocate resource */
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL) return NULL;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_RESET_DEVICE;
-	req->Cdb[3] = port->phy_map;
-	req->Cmd_Flag = 0;
-	req->Device_Id = dev->base.id;
-	req->Completion = func;
-
-	return req;
-}
-
-MV_Request *core_make_port_reset_req(pl_root *root, domain_port *port,
-	MV_PVOID base, MV_ReqCompletion func)
-{
-	MV_Request *req;
-
-	/* allocate resource */
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL) return NULL;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_RESET_PORT;
-	req->Cdb[3] = port->phy_map;
-	req->Cmd_Flag = 0;
-	req->Device_Id = ((domain_base *)base)->id;
-	req->Completion = func;
-
-	return req;
-}
-
-void pal_abort_running_req_for_async_sdb_fis(pl_root *root, domain_device *dev)
-{
-	MV_Request *req;
-	MV_U8 state = dev->state;
-
-        MV_ASSERT(get_device_by_id(root->lib_dev, dev->base.id) != NULL);
-	pal_abort_device_running_req(root, &dev->base);
-	core_complete_device_waiting_queue(root, &dev->base, REQ_STATUS_NO_DEVICE);
-        MV_ASSERT(get_device_by_id(root->lib_dev, dev->base.id) != NULL);
-
-
-	dev->status &= ~DEVICE_STATUS_FUNCTIONAL;
-	dev->status |= DEVICE_STATUS_WAIT_ASYNC;
-	dev->state = DEVICE_STATE_INIT_DONE;
-
-	if (dev->register_set != NO_REGISTER_SET) {
-		CORE_EH_PRINT(("free device %d register set %d\n", \
-                        dev->base.id, dev->register_set));
-		MV_DASSERT(dev->base.outstanding_req == 0);
-		sata_free_register_set(root, dev->register_set);
-		dev->register_set = NO_REGISTER_SET;
-	}
-
-	CORE_PRINT(("abort disk %d running req for async sdb fis.\n", dev->base.id));
-
-}
--- a/drivers/scsi/vanir/core/core/core_error.h
+++ /dev/null
@@ -1,170 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_ERROR_H
-#define __CORE_ERROR_H
-
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "core_protocol.h"
-
-/* eh_state */
-enum _eh_type
-{
-	EH_TYPE_NONE = 0, /* no error */
-	EH_TYPE_MEDIA_ERROR = 1, /* return is finished with error status */
-	EH_TYPE_TIMEOUT = 2, /* timeout */
-};
-
-#define EH_STATE_NONE 0
-
-enum _sas_eh_timeout_state
-{
-	SAS_EH_TIMEOUT_STATE_NONE = EH_STATE_NONE,
-	SAS_EH_TIMEOUT_STATE_ABORT_REQUEST = 1,
-	SAS_EH_TIMEOUT_STATE_LU_RESET = 2,
-	SAS_EH_TIMEOUT_STATE_DEVICE_RESET = 3,
-	SAS_EH_TIMEOUT_STATE_DEVICE_RESET_WAIT =4,
-	SAS_EH_TIMEOUT_STATE_PORT_RESET = 5,
-	SAS_EH_TIMEOUT_STATE_SET_DOWN = 6,
-};
-
-enum _sas_eh_media_state
-{
-	SAS_EH_MEDIA_STATE_NONE = EH_STATE_NONE,
-	SAS_EH_MEDIA_STATE_RETRY = 1,
-	SAS_EH_MEDIA_STATE_HARD_RESET_WAIT = 2,
-	SAS_EH_MEDIA_STATE_AFTER_RESET = 3,
-};
-
-enum _sata_eh_timeout_state
-{
-	SATA_EH_TIMEOUT_STATE_NONE = EH_STATE_NONE,
-	SATA_EH_TIMEOUT_STATE_SOFT_RESET_1,
-	SATA_EH_TIMEOUT_STATE_SOFT_RESET_WAIT,
-	SATA_EH_TIMEOUT_STATE_SOFT_RESET_0,
-	SATA_EH_TIMEOUT_STATE_HARD_RESET_WAIT,
-	SATA_EH_TIMEOUT_STATE_HARD_RESET,
-	SATA_EH_TIMEOUT_STATE_PORT_RESET,
-	SATA_EH_TIMEOUT_STATE_DEV_HARD_RESET,
-	SATA_EH_TIMEOUT_STATE_DEV_HARD_RESET_DONE,
-	SATA_EH_TIMEOUT_STATE_PM_RESET_WAIT,
-	SATA_EH_TIMEOUT_STATE_PM_SRST_1,
-	SATA_EH_TIMEOUT_STATE_PM_SRST_0,
-	SATA_EH_TIMEOUT_STATE_PM_SRST_WAIT,
-	SATA_EH_TIMEOUT_STATE_PM_REINIT,
-	SATA_EH_TIMEOUT_STATE_SET_DOWN,
-	SATA_EH_TIMEOUT_STATE_RETRY_ORG_REQ,
-};
-
-enum _sata_eh_media_state
-{
-	SATA_EH_MEDIA_STATE_NONE = EH_STATE_NONE,
-	SATA_EH_MEDIA_STATE_READ_LOG_EXTENT = 1,
-	SATA_EH_MEDIA_STATE_RETRY = 2,
-	SATA_EH_MEDIA_STATE_SOFT_RESET_1 = 3,
-	SATA_EH_MEDIA_STATE_SOFT_RESET_0 = 4,
-	SATA_EH_MEDIA_STATE_HARD_RESET_WAIT = 5,
-	SATA_EH_MEDIA_STATE_AFTER_RESET = 6,
-
-};
-
-enum _pm_eh_state
-{
-	PM_EH_STATE_NONE = EH_STATE_NONE,
-	PM_EH_HARD_RESET_DONE		= 1,
-	PM_EH_QRIGA_WORKAROUND		= 2,
-	PM_EH_ENABLE_FEATURES		= 3,
-	PM_EH_DISABLE_ASYNOTIFY		= 4,
-	PM_EH_CLEAR_ERROR_INFO		= 5,
-	PM_EH_SPIN_UP_ALL_PORTS		= 6,
-	PM_EH_ENABLE_PM_PORT_1		= 7,
-	PM_EH_SPIN_UP_DONE			= 8,
-	PM_EH_ENABLE_PM_PORT_0		= 9,
-	PM_EH_SPIN_UP_WAIT			= 10,
-	PM_EH_CHECK_PHY_RDY			= 11,
-	PM_EH_CHECK_PHY_RDY_DONE	= 12,
-	PM_EH_CLEAR_X_BIT			= 13,
-	PM_EH_WAIT_FOR_READY		= 14,
-	PM_EH_ISSUE_SOFT_RESET_1	= 15,
-	PM_EH_ISSUE_SOFT_RESET_0	= 16,
-	PM_EH_WAIT_SIG				= 17,
-	PM_EH_SIG_DONE				= 18,
-	PM_EH_WAIT_AFTER_RESET		= 19,
-	PM_EH_ENABLE_ASYNOTIFY		= 20,
-	PM_EH_ENABLE_ASYNOTIFY_WAIT = 21,
-	PM_EH_DONE					= 22,
-};
-
-enum _atapi_eh_media_state
-{
-	ATAPI_EH_MEDIA_STATE_NONE = SATA_EH_MEDIA_STATE_NONE,
-	ATAPI_EH_MEDIA_STATE_REQUEST_SENSE = 1,
-};
-
-MV_VOID mv_add_timer(MV_PVOID core_p, MV_Request *req);
-MV_VOID mv_cancel_timer(MV_PVOID core_p, MV_PVOID base_p);
-MV_VOID mv_renew_timer(MV_PVOID core_p, MV_Request *req);
-MV_VOID core_req_timeout(MV_PVOID dev_p, MV_PVOID req_p);
-MV_BOOLEAN sata_error_handler(MV_PVOID dev_p, MV_Request *req);
-MV_BOOLEAN ssp_error_handler(MV_PVOID dev_p, MV_Request *req);
-void sata_handle_taskfile_error(pl_root *root, MV_Request *req);
-MV_U32 pal_abort_device_running_req(pl_root *root, domain_base *base);
-MV_U32 pal_abort_port_running_req(pl_root *root, domain_port *port);
-void pal_clean_expander_outstanding_req(pl_root *root, domain_expander *exp);
-MV_U32 core_complete_device_waiting_queue(pl_root *root, domain_base *base,
-	MV_U8 scsi_status);
-MV_Request *core_eh_retry_org_req(pl_root *root, MV_Request *req,
-	MV_ReqCompletion func);
-MV_VOID prot_reset_slot(pl_root *root, domain_base *base, MV_U16 slot,
-	MV_Request *req);
-
-void pal_set_down_expander(pl_root *root, domain_expander *exp);
-void pal_set_down_multi_lun_disk(pl_root *root, domain_device *dev, MV_BOOLEAN notify_os);
-void pal_set_down_disk(pl_root *root, domain_device *dev, MV_BOOLEAN notify_os);
-void pal_set_down_error_disk(pl_root *root, domain_device *dev, MV_BOOLEAN notify_os);
-void pal_set_down_port(pl_root *root, domain_port *port);
-void pal_set_down_enclosure(pl_root *root, domain_enclosure *enc);
-void pal_abort_running_req_for_async_sdb_fis(pl_root *root, domain_device *dev);
-
-MV_BOOLEAN port_is_running_error_handling(pl_root *root, domain_port *port);
-MV_BOOLEAN port_has_error_req(pl_root *root, domain_port *port);
-MV_BOOLEAN port_has_init_req(pl_root *root, domain_port *port);
-MV_BOOLEAN device_has_error_req(pl_root *root, domain_base *base);
-void core_handle_init_error(pl_root *root, domain_base *base, MV_Request *req);
-MV_Request *core_make_port_reset_req(pl_root *root, domain_port *port,
-	MV_PVOID base, MV_ReqCompletion func);
-MV_Request *core_make_device_reset_req(pl_root *root, domain_port *port,
-	domain_device *dev, MV_ReqCompletion func);
-
-MV_BOOLEAN core_simulate_error(pl_root *root, domain_base *base,
-	MV_PU32 cmpl_q, mv_command_table *cmd_table,
-	MV_Request *req);
-
-extern MV_U16 mv_debug_mode;
-#define CORE_EH_PRINT(_x_)        do {if (CORE_DEBUG_INFO & mv_debug_mode)\
-		{if (GENERAL_DEBUG_INFO & mv_debug_mode)\
-		  {MV_DPRINT(("CORE EH: %s ", __FUNCTION__));\
-		  MV_DPRINT (_x_);}\
-		 else \
-		  {MV_PRINT("CORE EH:  ");\
-		  MV_PRINT _x_;} }\
-	} while (0)
-
-#define CORE_EVENT_PRINT(_x_) do {if (CORE_DEBUG_INFO & mv_debug_mode)\
-	{MV_DPRINT(("CORE EVENT: %s ", __FUNCTION__));\
-	MV_DPRINT (_x_);}\
-	} while (0)
-
-#endif /* __CORE_ERROR_H */
--- a/drivers/scsi/vanir/core/core/core_event.c
+++ /dev/null
@@ -1,489 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_manager.h"
-#include "core_resource.h"
-#include "core_error.h"
-#include "core_util.h"
-#include "core_sas.h"
-
-/*
- * PAL Manager drive the event handling
- * 1. don't do event handling when this port has error requests in the queue
- *    so error handling state machine won't mess up with event handling
- */
-
-static void pal_event_handling(domain_phy *phy, MV_U8 event_id);
-static void pl_handle_hotplug_event(pl_root *root, domain_phy *phy);
-static void pl_handle_unplug(pl_root *root, domain_phy *phy);
-static void pl_handle_async_event(pl_root *root, domain_phy *phy);
-void pl_handle_plugin(pl_root *root, domain_phy *phy);
-void sas_handle_unplug(pl_root *root, domain_port *port, domain_phy *phy);
-void sas_handle_plugin(pl_root *root, domain_port *port, domain_phy *phy);
-void sata_handle_unplug(pl_root *root, domain_port *port, domain_phy *phy);
-MV_VOID exp_handle_broadcast(pl_root *root, domain_phy *phy);
-
-extern void update_phy_info(pl_root *root, domain_phy *phy);
-extern void update_port_phy_map(pl_root *root, domain_phy *phy);
-extern void sas_init_port(pl_root *root, domain_port *port);
-extern void sata_init_port(pl_root *root, domain_port *port);
-extern void free_port(pl_root *root, domain_port *port);
-extern void exp_update_direct_attached_phys(domain_port *port);
-
-MV_BOOLEAN pal_check_duplicate_event(pl_root *root, event_record *old_event,
-        MV_U8 phy_id, MV_U8 event_id)
-{
-        /* duplicate event on the same phy */
-        if ((old_event->root == root) && (old_event->event_id == event_id) &&
-                (old_event->phy_id == phy_id)) {
-                return MV_TRUE;
-        }
-
-        /* duplicate broadcast for same wideport */
-	if ((event_id == PL_EVENT_BROADCAST_CHANGE) &&
-		(old_event->event_id == event_id) &&
-		(root->phy[old_event->phy_id].port) &&
-		(old_event->root->phy[old_event->phy_id].port == root->phy[phy_id].port)) {
-		return MV_TRUE;
-        }
-
-        /* duplicate phy change for same wideport */
-        if ((event_id == PL_EVENT_PHY_CHANGE) &&
-		(old_event->event_id == event_id) &&
-		(root->phy[old_event->phy_id].port) &&
-		(old_event->root->phy[old_event->phy_id].port == root->phy[phy_id].port)) {
-              return MV_TRUE;
-        }
-
-        return MV_FALSE;
-}
-
-void pal_notify_event(pl_root *root, MV_U8 phy_id, MV_U8 event_id)
-{
-	core_extension *core = (core_extension *)root->core;
-	event_record *event, *tmp_event;
-
-	if (core->state != CORE_STATE_STARTED)
-		return;
-
-	MV_ASSERT((event_id == PL_EVENT_PHY_CHANGE)
-		|| (event_id == PL_EVENT_ASYNC_NOTIFY)
-		|| (event_id == PL_EVENT_BROADCAST_CHANGE));
-
-	/*
-	 * If the incoming event already has a duplicate in the event queue,
-	 * don't need to add it again.
-	 */
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_event, &core->event_queue, event_record,
-		queue_pointer) {
-                if (pal_check_duplicate_event(root, tmp_event, phy_id, event_id)) {
-                        CORE_EVENT_PRINT(("duplicate event 0x%x on root %p phy 0x%x.\n",\
-				event_id, root, phy_id));
-			return;
-                }
-	}
-
-	/* save the event for late handling */
-	event = get_event_record(root->lib_rsrc);
-	if (event) {
-		event->root = root;
-		event->phy_id = phy_id;
-		event->event_id = event_id;
-		EVENT_SET_DELAY_TIME(event->handle_time, 500);
-		List_AddTail(&event->queue_pointer, &core->event_queue);
-	} else {
-		CORE_EVENT_PRINT(("no resource to queue event 0x%x "
-			"on root %p phy 0x%x.\n",
-			event_id, root, phy_id));
-	}
-}
-void core_clean_event_queue(core_extension *core)
-{
-	event_record *event = NULL;
-	pl_root *root;
-
-	while (!List_Empty(&core->event_queue)) {
-		event = (event_record *)List_GetFirstEntry(
-			&core->event_queue, event_record, queue_pointer);
-		root = event->root;
-		free_event_record(root->lib_rsrc, event);
-	}
-}
-void core_handle_event_queue(core_extension *core)
-{
-	event_record *event = NULL;
-	MV_BOOLEAN ret;
-	pl_root *root;
-	domain_phy *phy;
-	event_record *old_event = NULL;
-	domain_port *port;
-	MV_U32 i;
-
-	while (!List_Empty(&core->event_queue)) {
-		event = (event_record *)List_GetFirstEntry(
-			&core->event_queue, event_record, queue_pointer);
-		if (event == old_event) {
-			List_Add(&event->queue_pointer, &core->event_queue);
-			return;
-		}
-
-		root = event->root;
-		phy = &root->phy[event->phy_id];
-		port = phy->port;
-
-
-		for (i = 0; i < root->phy_num; i++) {
-			port = &root->ports[i];
-			/* if there is init request running,
-			 * don't do the event handling
-			 * it can be two cases,
-			 * a. during bootup(init state machine), event comes.
-			 * b. hotplug comes again before the former one completes.
-			 * we won't do multiple event handling on the same port */
-			if (port_has_init_req(root, port)) {
-				if (old_event == NULL) old_event = event;
-                                List_Add(&event->queue_pointer, &core->event_queue);
-				return;
-			}
-		}
-
-		if (event->event_id == PL_EVENT_PHY_CHANGE) {
-			if (MV_FALSE == time_is_expired(event->handle_time)) {
-				List_Add(&event->queue_pointer, &core->event_queue);
-				return;
-			}
-		}
-
-		pal_event_handling(phy, event->event_id);
-		free_event_record(root->lib_rsrc, event);
-	}
-}
-
-extern MV_VOID pm_hot_plug(domain_pm *pm);
-static void pal_event_handling(domain_phy *phy, MV_U8 event_id)
-{
-        pl_root *root = phy->root;
-        MV_U32 reg = 0;
-	MV_U16 dev_id = 0xFFFF;
-	domain_device *dev  = NULL;
-
-        CORE_EVENT_PRINT(("handle event: phy id %d, event id %d.\n", phy->id, event_id));
-	switch (event_id) {
-	case PL_EVENT_PHY_CHANGE:
-		CORE_EVENT_PRINT(("phy change event: phy %d, irq_status is 0x%x\n", \
-			phy->id, phy->irq_status));
-
-		pl_handle_hotplug_event(root, phy);
-		break;
-
-	case PL_EVENT_ASYNC_NOTIFY:
-		CORE_EVENT_PRINT(("asynchronous notification event: " \
-			"root %p phy id %d phy type =0x%x \n", root, phy->id,phy->type));
-
-		if ((phy->port)&&(phy->port->type == PORT_TYPE_SATA) && (phy->port->pm)) {
-			pm_hot_plug(phy->port->pm);
-		} else if ((phy->port) && (phy->type == PORT_TYPE_SATA)) {
-			reg = MV_REG_READ_DWORD(root->rx_fis,SATA_UNASSOC_D2H_FIS(phy) + 0x0);
-			if (((reg & 0xFF) == SATA_FIS_TYPE_SET_DEVICE_BITS) && (reg & MV_BIT(15))) {
-				dev_id = get_id_by_phyid(root->lib_dev,phy->id);
-				dev = (domain_device *)get_device_by_id(root->lib_dev, dev_id);
-				mv_cancel_timer(root->core,&dev->base);
-				pal_abort_running_req_for_async_sdb_fis(root, dev);
-
-				CORE_EVENT_PRINT(("Notify device %d async event(0x%x) to API.\n",dev_id,PL_EVENT_SDB_ASYNC_NOTIFY));
-				core_generate_event(root->core, PL_EVENT_SDB_ASYNC_NOTIFY, dev_id,SEVERITY_OTHER, 0, NULL,0);
-
-				CORE_EVENT_PRINT(("Sending Ack of SDB FIS to FW.\n"));
-				pl_handle_async_event(root,phy);
-			}
-		}
-		break;
-
-	case PL_EVENT_BROADCAST_CHANGE:
-		CORE_EVENT_PRINT(("broadcast event: root %p phy %d.\n", \
-			root, phy->id));
-		exp_handle_broadcast(root, phy);
-		break;
-
-	default:
-		MV_ASSERT(MV_FALSE);
-	}
-}
-
-static void pl_handle_hotplug_event(pl_root *root, domain_phy *phy)
-{
-	MV_U32 irq = phy->irq_status;
-	MV_U16 j = 0;
-	domain_port *port = phy->port;
-
-	CORE_EVENT_PRINT(("phy %d irq_status = 0x%x.\n", phy->id, irq));
-	if (irq & IRQ_PHY_RDY_CHNG_1_TO_0) {
-		if (!mv_is_phy_ready(root, phy)) {
-			pl_handle_unplug(root, phy);
-		} else {
-			CORE_EVENT_PRINT(("unplug interrupt but "\
-				"phy is still connected.\n"));
-			pl_handle_unplug(root, phy);
-			pl_handle_plugin(root, phy);
-		}
-	} else if (irq & IRQ_PHY_RDY_CHNG_MASK) {
-		/* wait for PHY to be ready */
-		while (j < 500) {
-			core_sleep_millisecond(root->core, 10);
-			if (mv_is_phy_ready(root, phy))
-				break;
-			j++;
-		}
-
-		if (mv_is_phy_ready(root, phy)) {
-			if (port &&
-				((port->device_count!=0) || (port->pm!=NULL) || (port->expander_count!=0))
-				) {
-				pl_handle_unplug(root, phy);
-			}
-			pl_handle_plugin(root, phy);
-		} else {
-			CORE_EVENT_PRINT(("plugin interrupt but phy is gone.\n"));
-		}
-	} else {
-		CORE_EVENT_PRINT(("nothing to do.\n"));
-	}
-
-	phy->irq_status &= ~(IRQ_PHY_RDY_CHNG_MASK|IRQ_PHY_RDY_CHNG_1_TO_0);
-}
-
-static void pl_handle_unplug(pl_root *root, domain_phy *phy)
-{
-	domain_port *port = phy->port;
-
-	if (NULL == port) {
-		CORE_EVENT_PRINT(("unplug phy %d which not exist.\n",
-			phy->id));
-		return;
-	}
-	if (port->type & PORT_TYPE_SATA) {
-		sata_handle_unplug(root, port, phy);
-	} else {
-		sas_handle_unplug(root, port, phy);
-	}
-	CORE_DPRINT(("phy %d is now gone\n", phy->id));
-}
-
-void pl_handle_plugin(pl_root *root, domain_phy *phy)
-{
-	domain_port *port;
-	MV_U32 reg = 0;
-
-	update_phy_info(root, phy);
-	update_port_phy_map(root, phy);
-	port = phy->port;
-
-	if (port == NULL) {
-		return;
-	}
-
-	if (port->type & PORT_TYPE_SATA) {
-
-		reg = READ_PORT_IRQ_STAT(root, phy);
-		if (reg & IRQ_UNASSOC_FIS_RCVD_MASK) {
-			WRITE_PORT_IRQ_STAT(root, phy, IRQ_UNASSOC_FIS_RCVD_MASK);
-		}
-		mv_reset_phy(root, port->phy_map, MV_TRUE);
-
-		core_sleep_millisecond(root->core, 100);
-		sata_init_port(root, port);
-	} else {
-		sas_handle_plugin(root, port, phy);
-	}
-}
-
-void sas_handle_plugin(pl_root *root, domain_port *port, domain_phy *phy)
-{
-	MV_U8 i;
-	MV_U16 j = 0;
-	MV_U8 phyrdy_check_mask = 0;
-	core_extension *core = root->core;
-
-	if(((core->revision_id != VANIR_C1_REV) && (core->revision_id != VANIR_C2_REV))
-           && (port->phy_num == 1))
-	{
-		WRITE_PORT_PHY_CONTROL(root, phy, 0x1);
-
-		/* Check Other phys that need to handle plugin event.*/
-		for (i = 0; i < root->phy_num; i++) {
-			if (root->phy[i].port == NULL)
-				phyrdy_check_mask |= MV_BIT(i);
-		}
-
-		while ((j < 10) && phyrdy_check_mask) {
-			for (i = 0; i < root->phy_num; i++) {
-				if ((phyrdy_check_mask & MV_BIT(i))	&&
-					(mv_is_phy_ready(root, (&root->phy[i])))) {
-						MV_DPRINT(("CORE: STP Hotplug WorkAround Phy%d STP Link Rst\n", i));
-						WRITE_PORT_PHY_CONTROL(root, (&root->phy[i]), 0x1);
-						phyrdy_check_mask &= ~MV_BIT(i);
-				}
-			}
-			core_sleep_millisecond(root->core, 10);
-			j++;
-		}
-	}
-
-	if (!List_Empty(&port->expander_list)) {
-		/* part of a wide port. update phy info */
-		MV_ASSERT(port->att_dev_info & (PORT_DEV_SMP_TRGT | PORT_DEV_STP_TRGT));
-		exp_update_direct_attached_phys(port);
-	} else {
-		sas_init_port(root, port);
-	}
-}
-
-void sas_handle_unplug(pl_root *root, domain_port *port, domain_phy *phy)
-{
-	 domain_expander *exp = NULL;
-	 MV_U8 i, phy_id = 0;
-        MV_U8 phy_map_left;
-
-        domain_phy *tmp_phy;
-        phy_map_left = port->phy_map;
-        core_sleep_millisecond(root->core, 100);
-        for (i = 0; i < root->phy_num; i++) {
-                tmp_phy = &root->phy[i];
-                if (phy_map_left & MV_BIT(i)) {
-	                update_phy_info(root, tmp_phy);
-	                update_port_phy_map(root, tmp_phy);
-                }
-        }
-        phy_map_left = port->phy_map;
-        CORE_EVENT_PRINT(("handle unplug event port %p phy id %d, phy_map 0x%x.\n", \
-                port, phy->id, phy_map_left));
-
-	if (phy_map_left) {
-		if (!List_Empty(&port->expander_list)) {
-			pal_abort_port_running_req(root, port);
-			exp_update_direct_attached_phys(port);
-			LIST_FOR_EACH_ENTRY_TYPE(exp, &port->expander_list,
-				domain_expander, base.queue_pointer) {
-				pal_clean_expander_outstanding_req(root, exp);
-			}
-		} else
-			pal_set_down_port(root, port);
-	} else {
-		pal_set_down_port(root, port);
-	}
-}
-
-void sata_handle_unplug(pl_root *root, domain_port *port, domain_phy *phy)
-{
-	domain_device *device;
-	MV_U32 reg;
-
-	/* it means directly attached disk is unplugged
-	 * or pm is unplugged. */
-	pal_set_down_port(root, port);
-	mv_reset_stp(root, port->phy_map);
-	update_phy_info(root, phy);
-}
-
-MV_VOID exp_handle_broadcast(pl_root *root, domain_phy *phy)
-{
-	domain_port *port = phy->port;
-	domain_expander *exp;
-	core_extension *core = (core_extension *)root->core;
-       MV_U8 phy_map_left;
-       MV_U8 i;
-       domain_phy *tmp_phy;
-
-	if (!port)
-		return;
-
-	CORE_DPRINT(("double checking phy status before broadcast\n"));
-
-       phy_map_left = port->phy_map;
-       core_sleep_millisecond(root->core, 100);
-       core_sleep_millisecond(root->core, 100);
-       for (i = 0; i < root->phy_num; i++) {
-           tmp_phy = &root->phy[i];
-           if (phy_map_left & MV_BIT(i)) {
-		    update_phy_info(root, tmp_phy);
-		    update_port_phy_map(root, tmp_phy);
-           }
-       }
-       phy_map_left = port->phy_map;
-
-	if (phy_map_left == 0) {
-	    /* remove devices attached. complete all requests */
-	    pal_set_down_port(root, port);
-
-	    /* port variables are cleared already in update_port_phy_map */
-           return;
-       }
-
-       exp_update_direct_attached_phys(port);
-
-	/* clear old routing tables & find root expander on this port */
-	LIST_FOR_EACH_ENTRY_TYPE(exp, &port->expander_list, domain_expander,
-		base.queue_pointer) {
-		MV_ZeroMemory(exp->route_table, sizeof(MV_U16)*MAXIMUM_EXPANDER_PHYS);
-		if (exp->base.parent == &port->base) {
-			exp->state = EXP_STATE_DISCOVER;
-			core_queue_init_entry(root, &exp->base, MV_TRUE);
-		}
-	}
-}
-
-static void handle_async_event_callback(MV_PVOID root_p, PMV_Request req)
-{
-	domain_device *device  = NULL;
-	pl_root *root = (pl_root *)root_p;
-
-	device = (domain_device*)get_device_by_id(root->lib_dev,req->Device_Id );
-	if(device)
-		CORE_EVENT_PRINT(("Sending ACK of SDB FIS finished,device->status = 0x%x\n",device->status));
-}
-
-static void pl_handle_async_event(pl_root *root, domain_phy *phy)
-{
-	MV_Request *req;
-	domain_device *device  = NULL;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return;
-
-	req->Cdb[0] = SCSI_CMD_ATA_PASSTHRU_12;
-	req->Cdb[1] = ATA_PROTOCOL_NON_DATA << 1;
-	req->Cdb[2] = 0;
-	req->Cdb[3] = MARVELL_VU_CMD_ASYNC_NOTIFY;
-	req->Cdb[4] = 0;
-	req->Cdb[5] = 0;
-	req->Cdb[6] = 0;
-	req->Cdb[7] = 0;
-	req->Cdb[8] = 0;
-	req->Cdb[9] = SCSI_CMD_MARVELL_VENDOR_UNIQUE;
-	req->Cdb[10] = 0;
-	req->Cdb[11] = 0;
-
-	req->Time_Out = CORE_REQUEST_TIME_OUT_SECONDS;
-	req->Cmd_Flag = CMD_FLAG_NON_DATA;
-
-	req->Device_Id = get_id_by_phyid(root->lib_dev,phy->id);
-	device = (domain_device*)get_device_by_id(root->lib_dev,req->Device_Id );
-	device->status |= DEVICE_STATUS_WAIT_ASYNC;
-
-	req->Completion = handle_async_event_callback;
-	core_append_request(root, req);
-
-}
--- a/drivers/scsi/vanir/core/core/core_exp.h
+++ /dev/null
@@ -1,36 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_EXP_H
-#define __CORE_EXP_H
-
-#include "mv_config.h"
-#include "core_type.h"
-
-MV_U32 Core_ModuleGetResourceQuota(enum Resource_Type type, MV_U16 maxIo);
-void Core_ModuleInitialize(MV_PVOID This, MV_U32 extensionSize, MV_U16 maxIo);
-void Core_ModuleStart(MV_PVOID This);
-MV_VOID Core_ModuleShutdown(MV_PVOID This);
-void Core_ModuleNotification(MV_PVOID, enum Module_Event, struct mod_notif_param*);
-void Core_ModuleSendRequest(MV_PVOID This, PMV_Request pReq);
-void Core_ModuleMonitor(MV_PVOID This);
-void Core_ModuleReset(MV_PVOID This);
-MV_BOOLEAN Core_InterruptCheckIRQ(MV_PVOID This);
-void Core_InterruptHandleIRQ(MV_PVOID This);
-MV_BOOLEAN Core_InterruptServiceRoutine(MV_PVOID This);
-MV_VOID core_push_queues(MV_PVOID core_p);
-MV_VOID core_complete_requests(MV_PVOID core_p);
-MV_U16 core_set_device_id(MV_U32 pad_test);
-#define core_start_cmpl_notify(core)  	HBA_ModuleStarted(core)
-
-#endif /* __CORE_EXP_H */
--- a/drivers/scsi/vanir/core/core/core_header.h
+++ /dev/null
@@ -1,23 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_HEADER_H
-#define __CORE_HEADER_H
-
-#include "mv_config.h"
-#include "core_protocol.h"
-#include "core_hal.h"
-#include "core_manager.h"
-
-
-#endif /* __CORE_HEADER_H */
--- a/drivers/scsi/vanir/core/core/core_init.h
+++ /dev/null
@@ -1,22 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_INIT_H
-#define __CORE_INIT_H
-
-#include "mv_config.h"
-#include "core_type.h"
-
-void io_chip_init(MV_PVOID root);
-
-#endif /* __CORE_INIT_H */
--- a/drivers/scsi/vanir/core/core/core_internal.h
+++ /dev/null
@@ -1,651 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_INTERNAL_H
-#define __CORE_INTERNAL_H
-
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_sata.h"
-#include "core_discover.h"
-#include "core_hal.h"
-#include "core_pm.h"
-#include "core_ses.h"
-
-typedef struct _pl_root pl_root;
-typedef struct _lib_device_mgr lib_device_mgr;
-typedef struct _lib_resource_mgr lib_resource_mgr;
-typedef struct _command_handler command_handler;
-
-typedef struct _domain_phy domain_phy;
-typedef struct _domain_port domain_port;
-typedef struct _domain_device domain_device;
-typedef struct _domain_expander domain_expander;
-typedef struct _domain_pm domain_pm;
-typedef struct _domain_enclosure domain_enclosure;
-
-/*
- * Definition for supported count
- */
-#define CORE_MAX_DEVICE_PER_PM                      5
-
-#define CORE_MAX_DEVICE_SUPPORTED                   (MAX_DEVICE_SUPPORTED_PERFORMANCE + 1) /* Add 1 for virtual device */
-#define CORE_MIN_EXPANDER_SUPPORTED                 2
-#define CORE_MAX_EXPANDER_SUPPORTED                 MAX_EXPANDER_SUPPORTED
-#define CORE_MAX_PM_SUPPORTED                       MAX_PM_SUPPORTED
-#define CORE_MIN_ENC_SUPPORTED                      CORE_MIN_EXPANDER_SUPPORTED
-#define CORE_MAX_ENC_SUPPORTED                      CORE_MAX_EXPANDER_SUPPORTED
-
-
-/* this is the request sg entry for internal request in cached memory */
-#define CORE_MIN_REQ_SG_ENTRY_COUNT                 8
-#define CORE_MAX_REQ_SG_ENTRY_COUNT                 CORE_MIN_REQ_SG_ENTRY_COUNT
-
-/* this is the sg entry for io chip access in uncached memory */
-#define CORE_MIN_HW_SG_ENTRY_COUNT                  (MAX_SG_ENTRY_REDUCED+2+2)
-#define CORE_MAX_HW_SG_ENTRY_COUNT                  (MAX_SG_ENTRY+2)
-#define CORE_HW_SG_ENTRY_SIZE                       sizeof(prd_t)
-
-/* dma sg buffer for io/xor, buffer count */
-#define CORE_MIN_HW_SG_BUFFER_COUNT                 16
-#define CORE_MAX_HW_SG_BUFFER_COUNT                 512
-
-/* perfect value can be MIN_SATA_BUFFER_COUNT + MIN_SES_BUFFER_COUNT + MIN_SMP_SCRATCH_COUNT */
-/* We need at least two buffers for init especially for SATA(SAT) device.*/
-#define CORE_MIN_SCRATCH_BUFFER_COUNT               2
-
-/* perfect value = CORE_MAX_DEVICE_SUPPORTED + MAX_SES_BUFFER_COUNT + CORE_MAX_EXPANDER_SUPPORTED (SATA + SES + SMP) */
-#define CORE_MAX_SCRATCH_BUFFER_COUNT               CORE_MAX_DEVICE_SUPPORTED
-
-/* For some ATA HDD only supports 28 bit LBA DMA. This definition is only for them. */
-#define CORE_MAX_TRANSFER_SIZE                      (128*1024)
-
-/* initialize req + sub req for large req*/
-#define MIN_INTERNAL_REQ_COUNT_FOR_LARGE_REQ        \
-	((MV_MAX_TRANSFER_SIZE + CORE_MAX_TRANSFER_SIZE - 1) / CORE_MAX_TRANSFER_SIZE)
-#define CORE_MIN_INTERNAL_REQ_COUNT                 MIN_INTERNAL_REQ_COUNT_FOR_LARGE_REQ
-/* perfect value = CORE_MAX_DEVICE_SUPPORTED + (MV_MAX_TRANSFER_SIZE + CORE_MAX_TRANSFER_SIZE - 1) / CORE_MAX_TRANSFER_SIZE * (CORE_MAX_DEVICE_SUPPORTED) */
-
-#define CORE_MAX_INTERNAL_REQ_COUNT                 \
-	(MV_MAX(CORE_MAX_DEVICE_SUPPORTED, MIN_INTERNAL_REQ_COUNT_FOR_LARGE_REQ)*2)
-
-/* hardware event count like hotplug */
-#define CORE_MIN_HW_EVENT_COUNT                     10
-#define CORE_MAX_HW_EVENT_COUNT                     20
-
-#define XOR_MAX_SLOT_NUMBER                         64 /* per xor chip */
-
-/* ID pool is shared by all devices */
-#define MAX_ID                                      \
-        (CORE_MAX_DEVICE_SUPPORTED + CORE_MAX_EXPANDER_SUPPORTED + \
-         CORE_MAX_PM_SUPPORTED + CORE_MAX_ENC_SUPPORTED)
-
-
-#define SATA_SCRATCH_BUFFER_SIZE	sizeof(ata_identify_data)
-#define SMP_SCRATCH_BUFFER_SIZE		sizeof(smp_request)
-#define SES_SCRATCH_BUFFER_SIZE		0x400	/* largest observed is 0x248 */
-#define SCRATCH_BUFFER_SIZE			(MV_MAX(SATA_SCRATCH_BUFFER_SIZE, \
-	MV_MAX(SMP_SCRATCH_BUFFER_SIZE, MV_MAX(SES_SCRATCH_BUFFER_SIZE,   \
-	SMP_VIRTUAL_REQ_BUFFER_SIZE))))
-
-#define MAX_RX_FIS_NUMBER              MAX_REGISTER_SET_PER_IO_CHIP + 1
-#define RX_FIS_SIZE                    256
-#define UNASSOCIATED_FIS_POOL_SIZE     2048
-#define MAX_RX_FIS_POOL_SIZE           (RX_FIS_SIZE*MAX_RX_FIS_NUMBER + UNASSOCIATED_FIS_POOL_SIZE)
-#define MIN_RX_FIS_POOL_SIZE           (RX_FIS_SIZE*1 + UNASSOCIATED_FIS_POOL_SIZE)
-#define MAX_REGISTER_SET				128
-#define SECTOR_SIZE				512
-
-enum mv_adapter_state
-{
-	ADAPTER_INITIALIZING = 0,
-	ADAPTER_READY,
-	ADAPTER_FATAL_ERROR,
-	ADAPTER_INIT_DONE
-};
-
-typedef enum _MV_QUEUE_COMMAND_RESULT
-{
-	MV_QUEUE_COMMAND_RESULT_FINISHED = 0,
-	MV_QUEUE_COMMAND_RESULT_FULL,
-	MV_QUEUE_COMMAND_RESULT_NO_RESOURCE,
-	MV_QUEUE_COMMAND_RESULT_SENT,
-	MV_QUEUE_COMMAND_RESULT_PASSED,
-        MV_QUEUE_COMMAND_RESULT_REPLACED,
-        MV_QUEUE_COMMAND_RESULT_BLOCKED,
-} MV_QUEUE_COMMAND_RESULT;
-
-/*
- * domain_port related definition
- */
-enum port_types {
-	PORT_TYPE_SATA          = (1U << 0),
-	PORT_TYPE_SAS           = (1U << 1),
-	PORT_TYPE_PM            = (1U << 2),
-	PORT_TYPE_I2C           = (1U << 3),
-};
-
-/* SATA use only */
-#define PORT_SATA_STATE_POWER_ON		  0x01
-#define PORT_SATA_STATE_SOFT_RESET_1	  0x02
-#define PORT_SATA_STATE_SOFT_RESET_0	  0x03
-#define PORT_SATA_STATE_WAIT_SIG		  0x04
-#define PORT_SATA_STATE_SIG_DONE		  0x05
-
-struct _command_handler
-{
-	MV_BOOLEAN (*init_handler)(MV_PVOID dev_p);
-	MV_U8 (*verify_command)(MV_PVOID root_p, MV_PVOID dev_p,
-		MV_Request *req);
-	MV_VOID (*prepare_command)(MV_PVOID root_p, MV_PVOID dev_p,
-		MV_PVOID cmd_header_p, MV_PVOID cmd_table_p,
-		MV_Request *req);
-	MV_VOID (*send_command)(MV_PVOID root_p, MV_PVOID dev_p,
-		MV_Request *req);
-	MV_VOID (*process_command)(MV_PVOID root_p, MV_PVOID dev_p,
-		MV_PVOID cmpl_q_p, MV_PVOID cmd_table_p,
-		MV_Request *req);
-
-	MV_BOOLEAN (*error_handler)(MV_PVOID dev_p, MV_Request *req);
-};
-
-enum base_type {
-	BASE_TYPE_DOMAIN_DEVICE = 0,
-	BASE_TYPE_DOMAIN_PORT = 1,
-	BASE_TYPE_DOMAIN_PM = 2,
-	BASE_TYPE_DOMAIN_EXPANDER = 3,
-	BASE_TYPE_DOMAIN_ENCLOSURE = 4,
-	BASE_TYPE_DOMAIN_VIRTUAL = 5,
-	BASE_TYPE_DOMAIN_I2C = 6,
-};
-
-enum base_state {
-	BASE_STATE_NONE = 0,
-	BASE_STATE_ERROR_HANDLING = 1,
-	BASE_STATE_ERROR_HANDLED = 2,
-};
-
-struct _error_context
-{
-	MV_U16               timer_id; /* each device has a timer to check request timeout */
-	MV_U16               eh_timer; /* timer used in error handling state machine */
-	MV_U8                state; /* BASE_STATE_XXX */
-	MV_U8                eh_type; /* EH_TYPE_XXX */
-	MV_U8                eh_state; /* XXX_EH_XXX_STATE_XXX */
-	MV_U8                scsi_status; /* save the eh req scsi status */
-
-	MV_U8                pm_eh_error_port; /* port that generated PM error, pm error handling ONLY */
-	MV_U8                pm_eh_active_port; /* port being reset during PM EH, pm error handling ONLY */
-	MV_U16               reserved;
-
-	MV_U8                error_count; /* error requests number currently in the queue */
-	MV_U8                timeout_count; /* number of times this device has timed out */
-	MV_U16               retry_count; /* used in init state machine, init req will just retry */
-
-	MV_Request          *error_req;
-	List_Head            sent_req_list; /* requests sent to the device, in order */
-};
-
-typedef struct _domain_base
-{
-	List_Head            queue_pointer;		/* primary queue pointer, usually for port's lists */
-	List_Head            init_queue_pointer;	/* for init queue */
-	List_Head            exp_queue_pointer;		/* for expander's lists */
-	MV_U16               struct_size;
-	MV_U8                type;
-	MV_U8                multi_lun;
-
-	struct _command_handler *handler;
-
-	MV_U16               id;
-
-	MV_U16 			LUN;
-	MV_U16 			TargetID;
-
-	pl_root              *root;
-	struct _domain_port  *port;
-
-	MV_U16               queue_depth;
-	MV_U16               outstanding_req;
-
-	MV_BOOLEAN           blocked;
-	MV_BOOLEAN           cmd_issue_stopped;
-
-	/* error handling */
-	struct _error_context err_ctx;
-	struct _domain_base   *parent;
-} domain_base;
-
-struct _domain_port {
-	struct _domain_base  base;
-
-	MV_U8      state;              /* for sata only */
-	MV_U8      type;               /* PORT_TYPE_XXX */
-	MV_U8      setting;            /* PORT_SETTING_XXX */
-	MV_U8      phy_num;
-
-	MV_U16	   sata_sig_timer;
-	MV_U8      phy_map;             /* Software's phy map */
-	MV_U8      asic_phy_map;        /* Actual phy map on ASIC */
-
-	MV_U8      link_rate;
-	MV_U8      curr_phy_map;        /* ASIC phy map currently in use*/
-	MV_U8      reserved[2];
-
-	domain_phy *phy; /* only points to the first phy, not queued, helpful for narrow port. */
-
-	MV_U8    device_count;
-	MV_U8    expander_count;
-
-	MV_U16	 init_count;		/* how many devices on this port are currently
-								   in init queue */
-	MV_U32     dev_info;
-	MV_U32     att_dev_info;
-	MV_U64     dev_sas_addr;
-	MV_U64     att_dev_sas_addr;
-
-	List_Head   device_list;
-	List_Head	expander_list;
-	List_Head	current_tier;		/* for discovery */
-	List_Head	next_tier;			/* for discovery */
-	domain_pm   *pm;
-};
-
-enum phy_state_type {
-	PHY_STATE_NONE 			=  0,
-	PHY_STATE_PLUG_IN 		=(1U << 0),
-};
-
-/*
- * domain_phy related definition
- */
-struct _domain_phy
-{
-	domain_port *port;
-        pl_root     *root;
-
-	MV_U8       id;
-	MV_U8       asic_id; /* use for phy id swap */
-	MV_U8       type;
-	MV_U8       reserved0[1];
-
-/* from PORT_CONFIG_ADDR0-3, PhyID/device protocol/sas_addr/SIG/wide_port */
-	MV_U32      dev_info;
-	MV_U32      att_dev_info;
-	MV_U64      dev_sas_addr;
-	MV_U64      att_dev_sas_addr;
-
-/* from PORT_PHY_CONTROL0-3, REG_PORT_PHY_CONTROL, linkrate, current status */
-	MV_U32      phy_status;
-
-/* from PORT_IRQ_MASK0-3 */
-	MV_U32      irq_status;
-	MV_U32      sata_signature;
-
-       MV_U32      phy_irq_mask;
-};
-
-/* domain device capability */
-enum device_capability {
-	DEVICE_CAPABILITY_48BIT_SUPPORTED                   = (1U << 0),
-	DEVICE_CAPABILITY_SMART_SUPPORTED                   = (1U << 1),
-	DEVICE_CAPABILITY_WRITECACHE_SUPPORTED              = (1U << 2),
-	DEVICE_CAPABILITY_NCQ_SUPPORTED                     = (1U << 3),
-	DEVICE_CAPABILITY_RATE_1_5G                         = (1U << 4),
-	DEVICE_CAPABILITY_RATE_3G                           = (1U << 5),
-	DEVICE_CAPABILITY_RATE_6G                           = (1U << 6),
-	DEVICE_CAPABILITY_READLOGEXT_SUPPORTED              = (1U << 7),
-	DEVICE_CAPABILITY_READ_LOOK_AHEAD_SUPPORTED         = (1U << 8),
-	DEVICE_CAPABILITY_SMART_SELF_TEST_SUPPORTED         = (1U << 9),
-	DEVICE_CAPABILITY_PROTECTION_INFORMATION_SUPPORTED  = (1U << 10),
-	DEVICE_CAPABILITY_POIS_SUPPORTED = (1U << 11),
-	DEVICE_CAPABILITY_TRIM_SUPPORTED  = (1U << 12),
-	DEVICE_CAPABILITY_SSD  = (1U << 13),
-};
-
-enum device_state {
-	/* Device initialization state */
-	DEVICE_STATE_IDLE                          = 0x0,
-	DEVICE_STATE_SRST_1                        = 0x3,
-	DEVICE_STATE_SRST_0                        = 0x4,
-	DEVICE_STATE_RESET_DONE                    = 0x5,
-	/* SATA device states */
-	DEVICE_STATE_IDENTIFY_DONE                 = 0x6,
-	DEVICE_STATE_SET_PIO_DONE                  = 0x7,
-	DEVICE_STATE_SET_UDMA_DONE                 = 0x8,
-	DEVICE_STATE_ENABLE_WRITE_CACHE_DONE       = 0x9,
-	DEVICE_STATE_ENABLE_READ_AHEAD_DONE        = 0xA,
-	DEVICE_STATE_SPIN_UP_DONE                  = 0x25,
-	/* SAS device states */
-	DEVICE_STATE_INQUIRY_DONE                  = 0xB,
-	DEVICE_STATE_INQUIRY_EVPD_DONE             = 0xD,
-	DEVICE_STATE_REPORT_LUN		       =0xE,
-	DEVICE_STATE_READ_CAPACITY_DONE            = 0xF,
-	DEVICE_STATE_SET_READ_AHEAD_DONE           = 0x10,
-	DEVICE_STATE_SET_CACHE_ENABLE_DONE         = 0x11,
-	DEVICE_STATE_LOG_SENSE_DONE                = 0x12,
-	/* Device states*/
-	DEVICE_STATE_FORMAT_DONE                   = 0x13,
-	DEVICE_STATE_FORMAT_WRITE                  = 0x14,
-	DEVICE_STATE_FORMAT_VERIFY                 = 0x15,
-	DEVICE_STATE_PM_SOFTRESET                  = 0x16,
-	DEVICE_STATE_STARTSTOP_DONE                = 0x17,
-	DEVICE_STATE_STP_REPORT_PHY				   = 0x18,
-	DEVICE_STATE_STP_RESET_PHY				   = 0x19,
-	DEVICE_STATE_TEST_UNIT_READY_DONE		   = 0x20,
-	DEVICE_STATE_CHECK_DUPLICATE_DONE          = 0x21,
-	DEVICE_STATE_RESMUE_DONE                   = 0x22,
-	DEVICE_STATE_STP_CLEAN_AFFILIATION	   	   = 0x23,
-	DEVICE_STATE_SKIP_INIT_DONE			= 0x24,
-	DEVICE_STATE_INIT_DONE                     = 0xFF,
-};
-
-enum device_setting {
-	DEVICE_SETTING_SMART_ENABLED               = (1U << 0),
-	DEVICE_SETTING_WRITECACHE_ENABLED          = (1U << 1),
-	DEVICE_SETTING_PI_ENABLED                  = (1U << 2),
-	DEVICE_SETTING_READ_LOOK_AHEAD             = (1U << 3),
-	DEVICE_SETTING_NCQ_RUNNING				   = (1U << 4),
-	DEVICE_SETTING_POIS_ENABLED				   = (1U << 5),
-};
-
-enum device_status {
-	DEVICE_STATUS_NO_DEVICE					   = (1U << 0),
-	DEVICE_STATUS_FUNCTIONAL						= (1U << 1),
-	DEVICE_STATUS_SECONDARY_PATH				   = (1U << 2),
-	DEVICE_STATUS_SPINNED_DOWN             	= (1U << 3),
-       DEVICE_STATUS_NEED_RESET                 = (1U << 4),         /* need to hard reset */
-       DEVICE_STATUS_NEED_CLEAR                	= (1U << 5),       /* need to clear aff */
-       DEVICE_STATUS_WAIT_ASYNC                	= (1U << 6),      /* need to async sdb fis */
-	DEVICE_STATUS_FROZEN		   	= (1U << 7),
-	DEVICE_STATUS_SPIN_UP		   	= (1U << 8),
-};
-
-struct _domain_device
-{
-	struct _domain_base  base;
-
-	MV_U8                connection;
-	MV_U8                dev_type;
-	MV_U8                state;            /* DEVICE_STATE_XXX */
-	MV_U8			reserved4;
-	MV_U16                status;           /* DEVICE_STATUS_XXX */
-	MV_U8			reserved6[2];
-
-	MV_U16				 route_index;
-	MV_U8                negotiated_link_rate;
-	MV_U8				 reserved0;
-
-	MV_U64               sas_addr;
-
-	struct _domain_pm	 *pm;
-
-	MV_U16                capability;
-	MV_U16                setting; /* The supported features are enabled or not. */
-
-	MV_U8                 serial_number[20];
-	MV_U8                 model_number[40];
-	MV_U8                 firmware_revision[8];
-
-	MV_U64                WWN;
-       MV_U32                max_transfer_size;
-	MV_U32                sector_size;
-	MV_U64                max_lba;
-
-	MV_U8			sata_sig_timer;
-	MV_U8			pm_port;
-	MV_U8			parent_phy_id;	/* only used if dev is behind expander */
-
-
-	MV_U8			need_config_route:1;
-	MV_U8			reserved1:7;
-
-	MV_U8                 pio_mode;
-	MV_U8                 udma_mode;
-	MV_U8                 current_pio;
-	MV_U8                 current_udma;
-
-	MV_U32                signature; /* HP wants this information */
-	MV_U32                ncq_tags;
-
-	MV_U8                 next_ncq; /* when search free ncq, start from this index */
-	MV_U8                 register_set;
-	MV_U8			phy_change_count;/* only used if dev is behind expander */
-	MV_U8                 curr_phy_map;
-
-       MV_U32                total_formatted_lba_count;
-
-	MV_U8 sgpio_drive_number;
-	MV_U8 sgpio_act_led_status;
-	MV_U8 sgpio_locate_led_status;
-	MV_U8 sgpio_error_led_status;
-	MV_U16 active_led_off_timer;
-	MV_U16 reserved5;
-
-	MV_U8 ses_overall_element_index; /* include type overall */
-	MV_U8 ses_element_index;   /* used only if a SES element, not include overall */
-	MV_U8 ses_slot_number;
-	MV_U8 ses_element_type;
-
-	domain_enclosure *enclosure;		/* Points to the associated enclosure */
-
-	MV_U8 ses_request_flag;
-	MV_U8 reserved3[3];
-};
-
-enum expander_state {
-	/* expander discovery states */
-	EXP_STATE_IDLE					= 0x0,
-	EXP_STATE_REPORT_GENERAL		= 0x1,
-	EXP_STATE_REPORT_MANU_INFO		= 0x2,
-	EXP_STATE_DISCOVER				= 0x3,
-	EXP_STATE_CONFIG_ROUTE			= 0x4,
-	EXP_STATE_NEXT_TIER				= 0x5,
-	/* broadcast/hot plug states */
-	EXP_STATE_CHECK_EXP_CHANGE		= 0x6,
-	EXP_STATE_CHECK_PHY_CHANGE		= 0x7,
-	EXP_STATE_HOT_PLUG_NEXT_TIER	= 0x8,
-	EXP_STATE_RESET_SATA_PHY		= 0x9,
-	EXP_STATE_RESET_WAIT			= 0xA,
-	EXP_STATE_CLEAR_AFFILIATION		= 0xB,
-	EXP_STATE_RESET_WAIT_2			= 0xC,
-	/* other */
-	EXP_STATE_ABORT					= 0xfe,
-	EXP_STATE_DONE					= 0xff,
-};
-
-enum exp_status {
-	EXP_STATUS_NO_DEVICE		= (1U << 0),
-	EXP_STATUS_EXISTING			= (1U << 1),
-	EXP_STATUS_FUNCTIONAL		= (1U << 2),
-	EXP_STATUS_HOT_PLUG			= (1U << 3),
-};
-
-struct _domain_expander
-{
-	struct _domain_base  base;
-
-	List_Head device_list;
-	List_Head expander_list;
-	List_Head enclosure_queue_pointer;
-
-	MV_U64	sas_addr;
-
-	MV_U8	state;
-	MV_U8	status;
-	MV_U8   parent_phy_count;      /* # of phys used to connect this expander
-								    * to its parent */
-	MV_U8	phy_count;			   /* # of phys on this expander */
-
-	MV_U8   parent_phy_id[MAX_WIDEPORT_PHYS];
-	MV_U16	route_table[MAXIMUM_EXPANDER_PHYS];
-
-	MV_U8	device_count;		   /* number of child devices */
-	MV_U8	expander_count;		   /* number of child expanders */
-	MV_U8	neg_link_rate;
-	MV_U8	reserved0;
-
-	MV_U8	vendor_id[8];
-	MV_U8	product_id[16];
-	MV_U8	product_rev[4];
-	MV_U8	component_vendor_id[8];
-
-	MV_U16	component_id;
-	MV_U8	component_rev_id;
-	MV_U8	configurable_route_table:1;
-	MV_U8	configures_others:1;
-	MV_U8	need_report_plugin:1;	/* do we need to generate an event for plug in */
-	MV_U8	has_been_setdown:1;
-	MV_U8	has_been_reset:1;
-	MV_U8	reserved1:3;
-
-	MV_U16	timer_tag;
-	MV_U8	reserved2[2];
-
-	domain_enclosure *enclosure;	/* which enclosure this expander is associated with */
-};
-
-enum pm_status {
-	PM_STATUS_NO_DEVICE			= (1U << 0),
-	PM_STATUS_EXISTING			= (1U << 1),
-	PM_STATUS_FUNCTIONAL		= (1U << 2),
-	PM_STATUS_HOT_PLUG			= (1U << 3),
-	PM_STATUS_DEVICE_PHY_RESET	= (1U << 6),
-};
-
-enum pm_state {
-	/* init states */
-	PM_STATE_RESET_DONE				= 0x0,
-	PM_STATE_READ_INFO_DONE			= 0x1,
-	PM_STATE_READ_ID_DONE			= 0x2,
-	PM_STATE_READ_REV_DONE			= 0x3,
-	PM_STATE_ENABLE_FEATURES		= 0x4,
-	PM_STATE_CLEAR_ERROR_INFO		= 0x5,
-	PM_STATE_SPIN_UP_ALL_PORTS		= 0x6,
-	PM_STATE_SPIN_UP_DONE			= 0x7,
-	PM_STATE_ENABLE_PM_PORT_1		= 0x8,
-	PM_STATE_ENABLE_PM_PORT_0		= 0x9,
-	PM_STATE_PORT_CHECK_PHY_RDY		= 0xa,
-	PM_STATE_CLEAR_X_BIT			= 0xb,
-	PM_STATE_ISSUE_SOFT_RESET_1		= 0xc,
-	PM_STATE_ISSUE_SOFT_RESET_0		= 0xd,
-	PM_STATE_WAIT_SIG				= 0xe,
-	PM_STATE_SIG_DONE				= 0xf,
-
-	/* hot plug states */
-	PM_STATE_READ_GLOBAL_ERROR		= 0x10,
-	PM_STATE_READ_PORT_ERROR		= 0x11,
-	PM_STATE_CLEAR_PORT_ERROR		= 0x12,
-	PM_STATE_WAIT_FOR_READY		    = 0x13,
-	PM_STATE_SET_PMPORT			    = 0x14,
-	PM_STATE_QRIGA_WORKAROUND	    = 0x15,
-	PM_STATE_DISABLE_ASYNOTIFY		= 0x16,
-	PM_STATE_ENABLE_ASYNOTIFY		= 0x17,
-	PM_STATE_DONE					= 0xff,
-};
-
-struct _domain_pm
-{
-	struct _domain_base  base;
-
-	domain_device *devices[CORE_MAX_DEVICE_PER_PM];
-
-	MV_U8	register_set;
-	MV_U16	sata_sig_timer;
-	MV_U8	srst_retry_cnt;
-
-	MV_U8	state;            /* PM_STATE_XXX */
-	MV_U8	status;           /* PM_STATUS_XXX */
-	MV_U8	num_ports;
-	MV_U8	active_port;
-
-	MV_U16	vendor_id;
-	MV_U16	device_id;
-
-	MV_U8	product_rev;
-	MV_U8	spec_rev;		  /* 10 means 1.0, 11 means 1.1 */
-	MV_U8	feature_enabled;
-	MV_U8	retry_cnt;
-
-	MV_U32	sstatus;
-	MV_U32	global_serror;
-};
-
-enum i2c_state{
-	/* i2c device init state*/
-	I2C_STATE_RESET_DONE		= 0x1,
-	I2C_STATE_IDENTIFY_DONE = 0x2,
-	I2C_STATE_INQUIRY_DONE= 0x3,
-	I2C_STATE_INIT_DONE = 0xff,
-};
-
-enum enclosure_state{
-	/*enclosure state*/
-	ENCLOSURE_INQUIRY_DONE = 0x10,
-	ENCLOSURE_CHECK_SUPPORT_PAGE_DONE = 0x11,
-	ENCLOSURE_GET_DEVICE_ELEMENT_DONE =0x12,
-	ENCLOSURE_GET_CONFIGUATION_DONE = 0x13,
-	ENCLOSURE_GET_ELEMENT_DISCRIPTER_DONE =0x14,
-	ENCLOSURE_SKIP_INIT_DONE = 0x15,
-	ENCLOSURE_INIT_DONE = 0xFF,
-};
-
-enum enclosure_status{
-	ENCLOSURE_STATUS_NO_DEVICE		= (1U << 0),
-	ENCLOSURE_STATUS_EXISTING		= (1U << 1),
-	ENCLOSURE_STATUS_FUNCTIONAL		= (1U << 2),
-};
-
-enum _enclosure_flag {
-	ENC_FLAG_NEED_REINIT			= (1U << 0),
-	ENC_FLAG_FIRST_INIT			= (1U << 1),
-};
-struct _domain_enclosure
-{
-	struct _domain_base  base;
-
-	MV_U8   state;            /* PM_STATE_XXX */
-	MV_U8   status;           /* PM_STATUS_XXX */
-	MV_U8   negotiated_link_rate;
-	MV_U8 reserved0;
-
-	MV_U16                setting; /* The supported features are enabled or not. */
-	MV_U8			parent_phy_id;	/* only used if dev is behind expander */
-	MV_U8			enc_flag;     /*when new PD plugged in enclosure need re-init*/
-
-	MV_U64               sas_addr;
-
-	List_Head expander_list;
-
-	MV_U8 vendor_id[8];
-	MV_U8 product_id[16];
-	MV_U8 product_revision[4];
-	MV_U8 enclosure_logical_id[8];
-
-	MV_U8 supported_page_count;
-	MV_U8 reserved1[3];
-	MV_U8 supported_page[32];
-
-};
-
-enum pl_events {
-	PL_EVENT_PHY_CHANGE = 0,
-	PL_EVENT_PHY_DEC_ERROR = 1,
-	PL_EVENT_ASYNC_NOTIFY = 2,
-	PL_EVENT_BROADCAST_CHANGE = 3,
-	PL_EVENT_SDB_ASYNC_NOTIFY = 0xFE00FE,
-};
-
-void pal_notify_event(pl_root *root, MV_U8 phy_id, MV_U8 event);
-
-#endif /* __CORE_INTERNAL_H */
--- a/drivers/scsi/vanir/core/core/core_large_req.c
+++ /dev/null
@@ -1,241 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_util.h"
-#include "core_error.h"
-#include "core_protocol.h"
-#include "core_manager.h"
-#include "core_internal.h"
-
-MV_U16 core_get_free_intl_req_count(pl_root *root)
-{
-        return (root->lib_rsrc->intl_req_count);
-}
-
-void core_sub_request_cmpltn_callback(MV_PVOID root_p, MV_Request *req)
-{
-	MV_Request *large_req;
-	core_context *large_ctx;
-	core_context *sub_ctx;
-
-	pl_root *root = (pl_root *)root_p;
-	core_extension *core = (core_extension *) root->core;
-
-	if (req->Org_Req == NULL)
-		MV_DASSERT(MV_FALSE);
-
-	large_req = req->Org_Req;
-	large_ctx = (core_context *)large_req->Context[MODULE_CORE];
-	sub_ctx = (core_context *)req->Context[MODULE_CORE];
-
-	if (large_ctx == NULL) {
-		MV_ASSERT(MV_FALSE);
-		return;
-	}
-
-	if (large_ctx->type != CORE_CONTEXT_TYPE_LARGE_REQUEST)
-		MV_DASSERT(MV_FALSE);
-
-	if (sub_ctx->type != CORE_CONTEXT_TYPE_SUB_REQUEST)
-		MV_DASSERT(MV_FALSE);
-
-	large_ctx->u.large_req.sub_req_cmplt++;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		large_req->Scsi_Status = req->Scsi_Status;
-		MV_CopyMemory(
-		large_req->Sense_Info_Buffer,
-		req->Sense_Info_Buffer,
-		MV_MIN(large_req->Sense_Info_Buffer_Length,
-		req->Sense_Info_Buffer_Length));
-	}
-
-	/*
-	* Queue the original large request back
-	* into the completion queue to Complete it when all the splitted sub
-	* requests are finished.
-	*/
-	if (large_ctx->u.large_req.sub_req_cmplt ==
-		large_ctx->u.large_req.sub_req_count) {
-
-		if (large_req->Scsi_Status == REQ_STATUS_PENDING)
-			large_req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-		core_queue_completed_req(core, large_req);
-	}
-}
-
-void core_construct_sub_request(core_extension *core,
-        domain_device *device,
-        MV_Request *large_req,
-        MV_Request *sub_req,
-        MV_PVOID data_buff,
-        MV_U32 sector_count,
-        MV_LBA lba,
-        MV_U32 sg_offset)
-{
-	core_context *large_ctx = (core_context *)large_req->Context[MODULE_CORE];
-	core_context *sub_ctx = (core_context *)sub_req->Context[MODULE_CORE];
-	pl_root *root = device->base.root;
-	MV_U16 sg_entry;
-	MV_PVOID sg_entry_ptr;
-
-	MV_LIST_HEAD_INIT(&sub_req->Queue_Pointer);
-
-	if (large_req->Org_Req_Scmd)
-		sub_req->Org_Req_Scmd = large_req->Org_Req_Scmd;
-	sub_req->Device_Id              = large_req->Device_Id;
-	sub_req->Req_Flag               = large_req->Req_Flag;
-	sub_req->Scsi_Status            = large_req->Scsi_Status;
-	sub_req->Tag                    = large_req->Tag;
-	sub_req->Cmd_Initiator          = root;
-	sub_req->Data_Transfer_Length   = sector_count * device->sector_size;
-	sub_req->Org_Req                = large_req;
-	sub_req->Scratch_Buffer         = NULL;
-	sub_req->pRaid_Request          = NULL;
-	sub_req->Cmd_Flag               = large_req->Cmd_Flag;
-	sub_req->Time_Out               = large_req->Time_Out;
-	sub_req->Splited_Count          = 0;
-	sub_req->LBA                    = lba;
-	sub_req->Sector_Count           = sector_count;
-	sub_req->Req_Flag               |= REQ_FLAG_LBA_VALID;
-
-	sub_ctx->slot = 0;
-	sub_ctx->handler = large_ctx->handler;
-	sub_ctx->error_info = large_ctx->error_info;
-	sub_ctx->req_type = large_ctx->req_type;
-
-	sub_ctx->type = CORE_CONTEXT_TYPE_SUB_REQUEST;
-	sub_ctx->u.sub_req.org_buff_ptr = data_buff;
-	sub_req->Completion = core_sub_request_cmpltn_callback;
-
-	if (SCSI_IS_READ(large_req->Cdb[0]))
-		sub_req->Cdb[0] = SCSI_CMD_READ_10;
-	else if (SCSI_IS_WRITE(large_req->Cdb[0]))
-		sub_req->Cdb[0] = SCSI_CMD_WRITE_10;
-	else
-		MV_DASSERT(MV_FALSE);
-
-	sg_entry = sub_req->SG_Table.Max_Entry_Count;
-	sg_entry_ptr = sub_req->SG_Table.Entry_Ptr;
-	sgd_table_init(&sub_req->SG_Table, sg_entry, sg_entry_ptr);
-	sgdt_append_reftbl(&sub_req->SG_Table,
-	                        &large_req->SG_Table,
-	                        sg_offset,
-	                        sub_req->Data_Transfer_Length);
-
-	SCSI_CDB10_SET_LBA(sub_req->Cdb, lba.value);
-	SCSI_CDB10_SET_SECTOR(sub_req->Cdb, sector_count);
-
-}
-
-MV_Request *core_split_large_request(pl_root *root,
-        MV_Request *large_req)
-{
-	core_extension  *core = (core_extension *)root->core;
-	domain_device   *device;
-	core_context    *ctx;
-	MV_Request      *sub_req=NULL;
-	MV_LBA          lba;
-	MV_PU8          data_buff;
-	MV_U8           i;
-	MV_U8           sub_req_count;
-	MV_U32          transfer_size;
-	MV_U32          max_transfer_size;
-	MV_U32          sector_size;
-	MV_U32          sector_count=0;
-	MV_U32          sg_offset;
-	MV_U32          remaining_transfer;
-
-	ctx = (core_context *)large_req->Context[MODULE_CORE];
-	device = (domain_device *)get_device_by_id(root->lib_dev,
-		large_req->Device_Id);
-
-	max_transfer_size = device->max_transfer_size;
-	sector_size = device->sector_size;
-
-	if (large_req->Data_Transfer_Length <= max_transfer_size)
-	        return large_req;
-
-	if ((!SCSI_IS_READ(large_req->Cdb[0])) &&
-		(!SCSI_IS_WRITE(large_req->Cdb[0]))) {
-
-		return large_req;
-	}
-
-	if (!IS_STP_OR_SATA(device) || !IS_HDD(device) ||
-	        device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED) {
-	        return large_req;
-	}
-
-	sub_req_count = (MV_U8) ((large_req->Data_Transfer_Length
-	                        + max_transfer_size - 1)
-	                                / max_transfer_size);
-
-	if (core_get_free_intl_req_count(root) < sub_req_count)
-		return NULL;
-
-	ctx->u.large_req.sub_req_cmplt = 0;
-	ctx->u.large_req.sub_req_count = sub_req_count;
-	ctx->type = CORE_CONTEXT_TYPE_LARGE_REQUEST;
-
-	if (!(large_req->Req_Flag & REQ_FLAG_LBA_VALID))
-		MV_SetLBAandSectorCount(large_req);
-
-	U64_ASSIGN_U64(lba, large_req->LBA);
-	data_buff = core_map_data_buffer(large_req);
-	sg_offset = 0;
-	remaining_transfer = large_req->Data_Transfer_Length;
-
-	for (i = 0; remaining_transfer > 0; i++) {
-		if (remaining_transfer > max_transfer_size)
-			transfer_size = max_transfer_size;
-		else
-			transfer_size = remaining_transfer;
-
-		sector_count = (transfer_size + sector_size - 1) / sector_size;
-		sub_req = get_intl_req_resource(root, 0);
-
-		if (sub_req == NULL) {
-			MV_DASSERT(MV_FALSE);
-			core_unmap_data_buffer(large_req);
-			return large_req;
-		}
-
-		core_construct_sub_request(core, device, large_req, sub_req,
-		                        data_buff, sector_count, lba,
-		                        sg_offset);
-
-		lba = U64_ADD_U32(lba, sector_count);
-		sg_offset += transfer_size;
-		remaining_transfer -= transfer_size;
-		if (data_buff != NULL)
-			data_buff += transfer_size;
-
-		core_append_request(root, sub_req);
-	}
-
-	if (i != sub_req_count) {
-		CORE_DPRINT(("predicted number of split = %d actual number of \
-		split = %d\n", sub_req_count, i));
-	}
-
-	MV_DASSERT(sg_offset == large_req->Data_Transfer_Length);
-	MV_DASSERT(sector_count + (max_transfer_size / sector_size)
-	                * (sub_req_count - 1) == large_req->Sector_Count);
-	core_unmap_data_buffer(large_req);
-	large_req->Scsi_Status = REQ_STATUS_PENDING;
-	return (sub_req);
-}
--- a/drivers/scsi/vanir/core/core/core_manager.c
+++ /dev/null
@@ -1,1107 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "com_dbg.h"
-#include "com_util.h"
-#include "com_u64.h"
-
-#include "core_hal.h"
-#include "core_manager.h"
-#include "core_init.h"
-#include "core_device.h"
-#include "core_sata.h"
-#include "core_sas.h"
-#include "core_resource.h"
-#include "core_alarm.h"
-#include "core_rmw_flash.h"
-#include "core_error.h"
-#include "core_util.h"
-#include "com_api.h"
-#include "core_console.h"
-
-#include "hba_exp.h"
-#include "core_exp.h"
-
-core_extension *gCore = NULL;
-MV_VOID core_handle_waiting_queue(core_extension *core);
-
-MV_VOID core_push_queues(MV_PVOID core_p);
-
-extern MV_VOID core_handle_error_queue(core_extension *core);
-extern void core_handle_event_queue(core_extension *core);
-extern MV_VOID core_clean_waiting_queue(core_extension *core);
-extern MV_VOID core_clean_error_queue(core_extension *core);
-extern void core_clean_event_queue(core_extension *core);
-
-MV_U32 Core_ModuleGetResourceQuota(enum Resource_Type type, MV_U16 max_io)
-{
-	MV_U32 size = 0;
-
-	if (type == RESOURCE_CACHED_MEMORY) {
-		size += core_get_cached_memory_quota(max_io);
-		size += core_rmw_flash_get_cached_memory_quota(max_io);
-		size += core_spin_up_get_cached_memory_quota(max_io);
-		size += 1024; /* memory align. */
-	} else if (type == RESOURCE_UNCACHED_MEMORY) {
-		size += core_get_dma_memory_quota(max_io);
-		size += core_rmw_flash_get_dma_memory_quota(max_io);
-	}
-
-	return size;
-}
-
-MV_VOID init_virtual_device(pl_root *root, lib_resource_mgr *rsrc, lib_device_mgr *lib_dev)
-{
-	domain_device *dev = get_device_obj(root, rsrc);
-	command_handler *handler;
-	MV_U16 old_id = dev->base.id;
-	MV_U16 new_id = VIRTUAL_DEVICE_ID;
-	MV_BOOLEAN ret;
-
-	handler = core_get_handler(root, HANDLER_API);
-
-	if (old_id != new_id) {
-		ret = change_device_map(lib_dev, &dev->base, old_id, new_id);
-		MV_ASSERT(ret == MV_TRUE);
-                dev->base.id = new_id;
-	}
-
-	set_up_new_device(root, NULL, dev, handler);
-	set_up_new_base(root, NULL, &dev->base,
-		handler,
-		BASE_TYPE_DOMAIN_VIRTUAL,
-		sizeof(domain_device));
-
-	dev->base.TargetID = dev->base.id;
-	root->lib_dev->target_id_map[dev->base.TargetID] = dev->base.id;
-}
-
-resource_func_tbl rsrc_func = {os_malloc_mem, NULL, NULL};
-
-static const struct mvs_chip_info mvs_chips[] = {
-	{ DEVICE_ID_9440, 1, 0, 4, 0x800, 64, 64,  11},
-	{ DEVICE_ID_9445, 1, 0, 4, 0x800, 64, 64,  11},
-	{ DEVICE_ID_9480, 2, 0, 4, 0x800, 64, 64,  11},
-	{ DEVICE_ID_9580, 2, 0, 4, 0x800, 64, 64,  11},
-	{ DEVICE_ID_9588, 2, 0, 4, 0x800, 64, 64,  11},
-	{ DEVICE_ID_9485, 2, 0, 4, 0x800, 64, 64,  11},
-	{ DEVICE_ID_9480, 1, 1, 4, 0x800, 64, 64,  11},
-	{ DEVICE_ID_948F, 2, 0, 4, 0x800, 64, 64,  11},
-	{ 0 }
-};
-#define MVS_CHIP_NUM  sizeof(mvs_chips)/(sizeof(mvs_chips[0]))
-
-MV_U32 core_get_chip_info(void *core_p)
-{
-	int i = 0;
-	core_extension * core = (core_extension *)core_p;
-	HBA_Info_Page hba_info_param;
-	MV_U8 prod_id[8] = {'V', 'A', '6', '4', '0', '0', 'm', 0x00};
-
-	for ( i = 0; i < MVS_CHIP_NUM; i++) {
-		if (core->device_id == mvs_chips[i].chip_id) {
-			core->chip_info = &mvs_chips[i];
-			if (IS_VANIR(core)) {
-				if(mv_nvram_init_param(
-					HBA_GetModuleExtension(core, MODULE_HBA),
-					&hba_info_param)
-					) {
-					if (memcmp(hba_info_param.Product_ID, prod_id, 8) == 0) {
-						if (core->chip_info->n_host != 1) {
-							continue;
-						}
-					}
-					if(hba_info_param.DSpinUpGroup==0xff ||
-						hba_info_param.DSpinUpTimer == 0x00 ||
-						hba_info_param.DSpinUpTimer == 0xff){
-
-						hba_info_param.DSpinUpGroup=0;
-						}
-					core->spin_up_group = hba_info_param.DSpinUpGroup;
-					if (core->spin_up_group)
-						core->spin_up_time = hba_info_param.DSpinUpTimer;
-				}
-				CORE_DPRINT(("chip id %X.\n",core->device_id));
-			}
-			return 0;
-		}
-	}
-
-	CORE_DPRINT(("Unknow chip id %X.\n",core->device_id));
-	return -1;
-}
-
-
-MV_VOID Core_ModuleInitialize(MV_PVOID module, MV_U32 size, MV_U16 max_io)
-{
-	core_extension *core = NULL;
-	lib_resource_mgr *rsrc = NULL;
-	lib_device_mgr *lib_dev = NULL;
-	Assigned_Uncached_Memory dma;
-	MV_PU8 global_cached_vir = NULL;
-	MV_U32 global_cached_size;
-	MV_BOOLEAN ret;
-	MV_U32 uncache_size;
-	void * mod_desc;
-	Controller_Infor controller;
-	core = (core_extension*)module;
-
-	/* zero cached memory */
-	mod_desc = core->desc;
-	MV_ZeroMemory(core, size);
-	core->desc = mod_desc;
-	core->bh_enabled = 1;
-	gCore = core;
-	MV_ASSERT(((MV_PTR_INTEGER)core & (SIZE_OF_POINTER - 1)) == 0);
-	rsrc = &core->lib_rsrc;
-	lib_dev = &core->lib_dev;
-	global_cached_vir = (MV_PU8)core + sizeof(core_extension);
-	global_cached_size = size - sizeof(core_extension);
-	/* set up controller information */
-	HBA_GetControllerInfor(core, (PController_Infor)&controller);
-
-	core->vendor_id = controller.Vendor_Id;
-	core->device_id = controller.Device_Id;
-	core->revision_id = controller.Revision_Id;
-	core->mmio_base = controller.Base_Address[MV_PCI_BAR];
-	core->io_base   = controller.Base_Address[MV_PCI_BAR_IO];
-	core->run_as_none_raid = controller.run_as_none_raid;
-
-	if (core_get_chip_info(core)) {
-		return;
-	}
-
-	/* get dma memory */
-	MV_ZeroMemory(&dma, sizeof(Assigned_Uncached_Memory));
-	rsrc_func.extension = (void *)core;
-
-	lib_rsrc_init(rsrc, global_cached_vir, global_cached_size,
-		dma.Virtual_Address, dma.Physical_Address, dma.Byte_Size,
-		&rsrc_func, lib_dev);
-
-	ret = core_init_cached_memory(core, rsrc, max_io);
-	if (MV_FALSE == ret)
-		goto err_alloc_core_mem;
-
-	ret = core_init_dma_memory(core, rsrc, max_io);
-	if (MV_FALSE == ret)
-		goto err_alloc_core_mem;
-
-	init_target_id_map(core->lib_dev.target_id_map, (sizeof(MV_U16)*MV_MAX_TARGET_NUMBER));
-	init_virtual_device(&core->roots[core->chip_info->start_host], rsrc, lib_dev);
-
-	ret = core_init_rmw_flash_memory(core, rsrc, max_io);
-	if (MV_FALSE == ret)
-		goto err_alloc_core_mem;
-
-	return;
-
-err_alloc_core_mem:
-	alloc_uncached_failed(HBA_GetModuleExtension( core, MODULE_HBA ));
-	return;
-}
-
-void core_io_chip_init_done(core_extension *core, MV_BOOLEAN single)
-{
-	sgpio_initialize(core);
-	core_alarm_init(core);
-}
-
-void core_handle_init_queue(core_extension *core, MV_BOOLEAN single)
-{
-	struct _domain_base *base = NULL;
-	MV_BOOLEAN ret;
-
-	MV_DASSERT(Counted_List_GetCount(&core->init_queue, MV_TRUE) == Counted_List_GetCount(&core->init_queue, MV_FALSE));
-	if (single) {
-		if (Counted_List_GetCount(&core->init_queue, MV_FALSE) < core->init_queue_count) {
-			MV_DASSERT(Counted_List_GetCount(&core->init_queue, MV_FALSE) == core->init_queue_count-1);
-			return;
-		}
-	}
-
-	if ((core->state == CORE_STATE_IDLE) && !(core->is_dump)) {
-		CORE_DPRINT(("pushing queue when core state is idle!\n"));
-			return;
-	}
-
-	while (!Counted_List_Empty(&core->init_queue)) {
-		base = Counted_List_GetFirstEntry(&core->init_queue,
-			struct _domain_base, init_queue_pointer);
-
-		ret = base->handler->init_handler(base);
-
-		if (ret == MV_FALSE) {
-			CORE_DPRINT(("init %p fail.\n", base));
-			Counted_List_Add(&base->init_queue_pointer, &core->init_queue);
-			return;
-		}
-
-		if (single) {
-		        break;
-		}
-	}
-
-	if (core->state == CORE_STATE_STARTING) {
-		if (core->init_queue_count == 0) {
-			if (core_check_outstanding_req(core) != 0)
-				return;
-
-			MV_ASSERT(Counted_List_Empty(&core->init_queue));
-			core->state = CORE_STATE_STARTED;
-
-			core_io_chip_init_done(core, single);
-
-			CORE_DPRINT((" finished init, notify upper layer. \n" ));
-			core_start_cmpl_notify(core);
-			return;
-		}
-	}
-}
-
-MV_VOID core_clean_init_queue_entry(MV_PVOID root_p, domain_base *base)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_extension *core = (core_extension *)root->core;
-	domain_base *tmp_base, *found_base = NULL;
-
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_base, &core->init_queue, domain_base,
-		init_queue_pointer) {
-		if (tmp_base == base) {
-			found_base = base;
-			break;
-		}
-	}
-
-	if (found_base) {
-		core_init_entry_done(root, base->port, NULL);
-		Counted_List_Del(&found_base->init_queue_pointer, &core->init_queue);
-	}
-}
-
-MV_VOID Core_ModuleStart(MV_PVOID This)
-{
-	core_extension *core = (core_extension *)This;
-	unsigned long flags;
-	MV_U8 i;
-	Controller_Infor controller;
-
-	HBA_GetControllerInfor(core, (PController_Infor)&controller);
-
-	if(core_reset_controller(core) == MV_FALSE){
-		CORE_DPRINT(("Reset hba failed.\n"));
-		return;
-	}
-
-	controller_init(core);
-
-	OSSW_SPIN_LOCK_IRQSAVE(core, flags);
-
-	for (i=core->chip_info->start_host; i<(core->chip_info->start_host + core->chip_info->n_host); i++){
-		core->roots[i].base_phy_num = i * core->chip_info->n_phy;
-		io_chip_init(&core->roots[i]);
-	}
-	core->state = CORE_STATE_STARTING;
-	core_push_queues(core);
-
-	OSSW_SPIN_UNLOCK_IRQRESTORE(core, flags);
-}
-
-extern MV_VOID core_sgpio_led_off_timeout(domain_base * base, MV_PVOID tmp);
-extern MV_U8 core_sgpio_set_led( MV_PVOID extension, MV_U16 device_id, MV_U8 light_type,
-        MV_U8 light_behavior, MV_U8 flag);
-MV_QUEUE_COMMAND_RESULT core_send_request(core_extension *core, MV_Request *req)
-{
-	core_context *ctx;
-	pl_root *root;
-	MV_QUEUE_COMMAND_RESULT result;
-	struct _domain_base *base;
-
-	if (req->Context[MODULE_CORE] == NULL)
-		req->Context[MODULE_CORE] = get_core_context(&core->lib_rsrc);
-	ctx = req->Context[MODULE_CORE];
-	if (ctx == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	base = (struct _domain_base *)get_device_by_id(&core->lib_dev, req->Device_Id);
-	if (base == NULL) {
-		req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	root = base->root;
-	ctx->handler = base->handler;
-
-	result = prot_send_request(root, base, req);
-
-	if (result == MV_QUEUE_COMMAND_RESULT_SENT)
-		base->outstanding_req++;
-	else if ((result == MV_QUEUE_COMMAND_RESULT_FULL)
-		|| (result == MV_QUEUE_COMMAND_RESULT_NO_RESOURCE)) {
-		if ((req->Context[MODULE_CORE] != NULL)
-			&& (req->Req_Type != REQ_TYPE_CORE)) {
-			free_core_context(root->lib_rsrc, req->Context[MODULE_CORE]);
-			req->Context[MODULE_CORE] = NULL;
-		}
-	}
-
-	if ((core->device_id == DEVICE_ID_6480) || (core->device_id == DEVICE_ID_6485)
-                        ||(core->device_id == 0x8180) || IS_VANIR(core)
-			||(core->device_id == DEVICE_ID_948F)) {
-		if((core->state == CORE_STATE_STARTED)
-			&& (base->type == BASE_TYPE_DOMAIN_DEVICE)
-			&& (IS_SGPIO(((domain_device *)base)))){
-			if(((domain_device *)base)->active_led_off_timer == NO_CURRENT_TIMER){
-				core_sgpio_set_led(core,base->id,0,0,LED_FLAG_ACT);
-			}else{
-				core_cancel_timer(core, ((domain_device *)base)->active_led_off_timer);
-				((domain_device *)base)->active_led_off_timer = NO_CURRENT_TIMER;
-			}
-			((domain_device *)base)->active_led_off_timer = core_add_timer(core, 1, (MV_VOID (*) (MV_PVOID, MV_PVOID))core_sgpio_led_off_timeout, base, NULL);
-		}
-	}
-
-	return result;
-}
-MV_VOID core_clean_waiting_queue(core_extension *core)
-{
-	MV_Request *req;
-
-	while (!Counted_List_Empty(&core->waiting_queue)) {
-		req = (MV_Request *)Counted_List_GetFirstEntry(
-			&core->waiting_queue, MV_Request, Queue_Pointer);
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		core_queue_completed_req(core, req);
-	}
-
-	while (!Counted_List_Empty(&core->high_priority_queue)) {
-		req = (MV_Request *)Counted_List_GetFirstEntry(
-			&core->high_priority_queue, MV_Request, Queue_Pointer);
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		core_queue_completed_req(core, req);
-	}
-
-}
-MV_VOID io_chip_handle_waiting_queue(core_extension *core, Counted_List_Head *queue)
-{
-	MV_Request *req;
-	MV_QUEUE_COMMAND_RESULT result;
-	List_Head tmp_queue;
-        domain_base *base = NULL;
-
-	MV_LIST_HEAD_INIT(&tmp_queue);
-
-	while (!Counted_List_Empty(queue)) {
-		req = (MV_Request *)Counted_List_GetFirstEntry(
-			queue, MV_Request, Queue_Pointer);
-		result = core_send_request(core, req);
-
-		switch ( result )
-		{
-		case MV_QUEUE_COMMAND_RESULT_FINISHED:
-			core_queue_completed_req(core, req);
-			break;
-
-		case MV_QUEUE_COMMAND_RESULT_FULL:
-			List_Add(&req->Queue_Pointer, &tmp_queue);
-			base = (domain_base *)get_device_by_id(&core->lib_dev, req->Device_Id);
-			MV_DASSERT(base != NULL);
-			base->blocked = MV_TRUE;
-			break;
-
-		case MV_QUEUE_COMMAND_RESULT_BLOCKED:
-			List_Add(&req->Queue_Pointer, &tmp_queue);
-			break;
-
-		case MV_QUEUE_COMMAND_RESULT_NO_RESOURCE:
-			Counted_List_Add(&req->Queue_Pointer, queue);
-			goto ending;
-
-		case MV_QUEUE_COMMAND_RESULT_SENT:
-			mv_add_timer(core, req);
-			break;
-
-		case MV_QUEUE_COMMAND_RESULT_REPLACED:
-			break;
-
-		default:
-			MV_ASSERT(MV_FALSE);
-		}
-	}
-
-ending:
-	while (!List_Empty(&tmp_queue)) {
-		req = (MV_Request *)List_GetFirstEntry(
-			&tmp_queue, MV_Request, Queue_Pointer);
-			base = (domain_base *)get_device_by_id(&core->lib_dev, req->Device_Id);
-			MV_DASSERT(base != NULL);
-			base->blocked = MV_FALSE;
-		Counted_List_Add(&req->Queue_Pointer, queue);
-	}
-}
-
-MV_VOID core_handle_waiting_queue(core_extension *core)
-{
-	/* io chip queue: high priority and low priority */
-	io_chip_handle_waiting_queue(core, &core->high_priority_queue);
-	io_chip_handle_waiting_queue(core, &core->waiting_queue);
-}
-
-MV_VOID core_abort_all_running_requests(MV_PVOID core_p)
-{
-	MV_U8 j;
-	MV_U32 i;
-	pl_root *root;
-	domain_port *port;
-	domain_base *base;
-	PMV_Request req = NULL;
-	core_extension *core = (core_extension *)core_p;
-	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(core, MODULE_HBA);
-
-	core_clean_event_queue(core);
-	core_clean_error_queue(core);
-	core_clean_waiting_queue(core);
-
-	for(j = core->chip_info->start_host; j < (core->chip_info->start_host + core->chip_info->n_host); j++) {
-		root = &core->roots[j];
-		for (i = 0; i < root->slot_count_support; i++) {
-			req = root->running_req[i];
-			if (req == NULL) continue;
-
-			base = get_device_by_id(root->lib_dev, req->Device_Id);
-			MV_ASSERT(base != NULL);
-			prot_reset_slot(root, base, i, req);
-			if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-				domain_device *device = (domain_device *)base;
-
-				if (device->register_set != NO_REGISTER_SET) {
-					MV_DASSERT(device->base.outstanding_req == 0);
-					sata_free_register_set(root, device->register_set);
-					device->register_set = NO_REGISTER_SET;
-				}
-			}
-			req->Scsi_Status = REQ_STATUS_ERROR;
-			core_queue_completed_req(core, req);
-		}
-	}
-
-	core_complete_requests(core);
-
-}
-
-MV_VOID Core_ModuleSendRequest(MV_PVOID core_p, PMV_Request req)
-{
-	core_extension *core = (core_extension *)core_p;
-
-	MV_DASSERT(req->Context[MODULE_CORE] == NULL);
-	Counted_List_AddTail(&req->Queue_Pointer, &core->waiting_queue);
-}
-
-MV_VOID Core_ModuleMonitor(MV_PVOID core_p)
-{
-}
-
-MV_VOID Core_ModuleNotification(MV_PVOID core_p, enum Module_Event event,
-	struct mod_notif_param *param)
-{
-}
-
-MV_VOID Core_ModuleReset(MV_PVOID core_p)
-{
-}
-
-MV_VOID Core_ModuleShutdown(MV_PVOID core_p)
-{
-	core_extension *core = (core_extension *)core_p;
-	MV_U8 i;
-	pl_root *root;
-
-	MV_ASSERT(Counted_List_Empty(&core->waiting_queue));
-	MV_ASSERT(Counted_List_Empty(&core->high_priority_queue));
-	MV_ASSERT(Counted_List_Empty(&core->error_queue));
-
-	for (i = core->chip_info->start_host; i<(core->chip_info->start_host + core->chip_info->n_host); i++) {
-		root = &core->roots[i];
-		hal_disable_io_chip(root);
-	}
-
-	ossw_pci_pool_destroy(core->sg_pool);
-	ossw_pci_pool_destroy(core->ct_pool);
-
-}
-
-MV_VOID core_set_chip_options(MV_PVOID ext)
-{
-	pl_root *root = (pl_root *)ext;
-	core_extension *core = (core_extension *)root->core;
-	root->max_register_set = core->chip_info->srs_sz;
-	root->unassoc_fis_offset = core->chip_info->fis_offs;
-	root->max_cmd_slot_width = core->chip_info->slot_width;
-
-	if (root->max_register_set > 64) {
-	        MV_DASSERT(MV_FALSE);
-	} else if (root->max_register_set == 64) {
-		root->sata_reg_set.value = 0;
-
-	} else {
-		root->sata_reg_set.value = (1ULL << (root->max_register_set + 1)) - 1;
-		root->sata_reg_set.value = ~root->sata_reg_set.value;
-	}
-}
-
-
-
-MV_BOOLEAN Core_InterruptCheckIRQ(MV_PVOID This)
-{
-	core_extension *core = (core_extension *)This;
-	return core_clear_int(core);
-}
-
-void Core_InterruptHandleIRQ(MV_PVOID This)
-{
-	core_extension *core = (core_extension *)This;
-	core_handle_int(core);
-	core_complete_requests(core);
-	core_push_queues(core);
-}
-
-MV_BOOLEAN Core_InterruptServiceRoutine(MV_PVOID This)
-{
-	core_extension *core = (core_extension *)This;
-	pl_root *root;
-	MV_BOOLEAN ret = MV_TRUE;
-
-	if(!core->bh_enabled)
-		ret = core_clear_int(core);
-
-	if (ret == MV_TRUE) {
-		core_disable_ints(core);
-		core_handle_int(core);
-		core_complete_requests(core);
-		core_push_queues(core);
-		core_enable_ints(core);
-	}
-
-    return ret;
-}
-
-MV_VOID core_queue_completed_req(MV_PVOID ext, MV_Request *req)
-{
-	core_extension *core = (core_extension *)ext;
-	List_AddTail(&req->Queue_Pointer, &core->complete_queue);
-}
-
-MV_VOID generic_post_callback(core_extension *core, MV_Request *req)
-{
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	if (req->Req_Type != REQ_TYPE_CORE) {
-		if (ctx != NULL) {
-			MV_DASSERT(ctx->buf_wrapper == NULL);
-			free_core_context(&core->lib_rsrc, ctx);
-			req->Context[MODULE_CORE] = NULL;
-		} else {
-			MV_DASSERT(req->Scsi_Status == REQ_STATUS_NO_DEVICE);
-		}
-	} else {
-		intl_req_release_resource(&core->lib_rsrc, req);
-	}
-}
-
-
-MV_VOID core_return_finished_req(core_extension *core, MV_Request *req)
-{
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	if (req->Req_Type != REQ_TYPE_CORE) {
-		generic_post_callback(core, req);
-	}
-
-	if ((IS_ATA_PASSTHRU_CMD(req,SCSI_CMD_MARVELL_VENDOR_UNIQUE))
-		&& (!IS_VU_CMD(req,MARVELL_VU_CMD_ASYNC_NOTIFY))) {
-		domain_device *device  = NULL;
-		device = (domain_device*)get_device_by_id(&core->lib_dev,req->Device_Id );
-		if(device){
-			device->status &= ~DEVICE_STATUS_WAIT_ASYNC;
-			device->status |= DEVICE_STATUS_FUNCTIONAL;
-		}
-	}
-
-	if(req->Completion != NULL)
-		req->Completion(req->Cmd_Initiator, req);
-
-	if (req->Req_Type == REQ_TYPE_CORE) {
-		generic_post_callback(core, req);
-	}
-}
-
-MV_VOID io_chip_complete_requests(core_extension *core)
-{
-	MV_Request *req;
-
-	while (!List_Empty(&core->complete_queue)) {
-		req = (MV_Request *)List_GetFirstEntry(&core->complete_queue,
-			MV_Request, Queue_Pointer);
-		MV_DASSERT(req);
-
-		if (req->Scsi_Status != REQ_STATUS_SUCCESS && \
-			req->Scsi_Status != REQ_STATUS_NO_DEVICE &&\
-			!(req->Scsi_Status == REQ_STATUS_HAS_SENSE && \
-				(req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_16 || req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_12))\
-			&& !((req->Scsi_Status == REQ_STATUS_ERROR_WITH_SENSE) && (req->Cdb[0] == APICDB0_PD)&&
-				(req->Cdb[1] == APICDB1_PD_GETHD_INFO)&&(core->device_id == 0x8180))) {
-			CORE_EH_PRINT(("req %p [0x%x] status 0x%x\n",
-				req, req->Cdb[0], req->Scsi_Status));
-		}
-		core_return_finished_req(core, req);
-	}
-}
-
-MV_VOID core_complete_requests(MV_PVOID core_p)
-{
-	core_extension *core = (core_extension *)core_p;
-
-        io_chip_complete_requests(core);
-}
-
-MV_VOID core_push_queues(MV_PVOID core_p)
-{
-	core_extension *core = (core_extension *)core_p;
-	MV_U32 queue_count1;
-
-	if (!List_Empty(&core->event_queue))
-		core_handle_event_queue(core);
-
-	if (!Counted_List_Empty(&core->error_queue))
-		core_handle_error_queue(core);
-
-	if ((core->state == CORE_STATE_STARTED)) {
-		core_handle_init_queue(core, MV_FALSE);
-	} else if (core->is_dump) {
-		/* for dump mode, do one by one to save memory */
-		/* for hotplug, do init one by one because we need remap device id */
-		core_handle_init_queue(core, MV_TRUE);
-	} else {
-		core_handle_init_queue(core, MV_FALSE);
-	}
-
-	do{
-		core_handle_waiting_queue(core);
-		queue_count1 = Counted_List_GetCount(&core->waiting_queue, MV_FALSE);
-		core_complete_requests(core);
-	}while(Counted_List_GetCount(&core->waiting_queue, MV_FALSE) != queue_count1);
-
-}
-
-MV_U8 get_min_negotiated_link_rate(domain_port *port)
-{
-	pl_root *root = port->base.root;
-	MV_U8 i, min_rate, rate = 0;
-	MV_U32 tmp;
-	domain_phy *phy;
-
-	min_rate = PHY_LINKRATE_6;
-
-	for (i=0; i<root->phy_num; i++) {
-		if (port->phy_map & MV_BIT(i)) {
-			phy = &root->phy[i];
-			tmp = READ_PORT_PHY_CONTROL(root, phy);
-			rate = get_phy_link_rate(tmp);
-			if (rate < min_rate)
-				min_rate = rate;
-		}
-	}
-
-	return min_rate;
-}
-MV_VOID update_base_id(pl_root *root,domain_port *port,domain_device *dev,MV_U8 skip){
-	core_extension * core = (core_extension *)root->core;
-
-	if(!skip){
-		if(core->device_id==DEVICE_ID_6440 || core->device_id==DEVICE_ID_6340 ||
-			core->device_id==DEVICE_ID_6480|| core->device_id==DEVICE_ID_6485){
-			root->lib_rsrc->lib_dev->device_map[dev->base.id]=NULL;
-			dev->base.id=port->phy->id;
-			root->lib_rsrc->lib_dev->device_map[dev->base.id]=&dev->base;
-		}else if(IS_VANIR(core)){
-			root->lib_rsrc->lib_dev->device_map[dev->base.id]=NULL;
-			dev->base.id=(MV_U16)(port->phy->id+root->base_phy_num);
-			root->lib_rsrc->lib_dev->device_map[dev->base.id]=&dev->base;
-		}
-	}
-
-	if (dev->base.id != VIRTUAL_DEVICE_ID)
-		dev->base.TargetID = add_target_map(root->lib_dev->target_id_map, dev->base.id, MV_MAX_TARGET_NUMBER);
-}
-void sas_set_up_new_device(pl_root *root, domain_port *port, domain_device *dev)
-{
-	set_up_new_device(root, port, dev,
-		(command_handler *)
-		core_get_handler(root, HANDLER_SSP));
-
-	dev->connection = DC_SCSI | DC_SERIAL |DC_SGPIO;
-	dev->dev_type = DT_DIRECT_ACCESS_BLOCK;
-	dev->state = DEVICE_STATE_RESET_DONE;
-	dev->base.queue_depth = CORE_SAS_DISK_QUEUE_DEPTH;
-	dev->base.parent = &port->base;
-
-	dev->sas_addr = port->att_dev_sas_addr;
-	dev->negotiated_link_rate = port->link_rate;
-	dev->capability |= DEVICE_CAPABILITY_RATE_1_5G;
-	if (dev->negotiated_link_rate >= SAS_LINK_RATE_3_0_GBPS)
-		dev->capability |= DEVICE_CAPABILITY_RATE_3G ;
-	if (dev->negotiated_link_rate >= SAS_LINK_RATE_6_0_GBPS)
-		dev->capability |= DEVICE_CAPABILITY_RATE_6G ;
-
-	dev->sgpio_drive_number = (MV_U8)port->base.id;
-	dev->active_led_off_timer = NO_CURRENT_TIMER;
-}
-
-void sas_init_port(pl_root *root, domain_port *port)
-{
-	domain_device *device = NULL;
-	domain_expander *expander = NULL;
-	core_extension *core = (core_extension *)root->core;
-	MV_U8 i, phy_id = 0;
-	MV_ULONG flags;
-	struct device_spin_up *tmp=NULL;
-
-	MV_ASSERT(port->phy_map);
-
-	if (port->att_dev_info & (PORT_DEV_SMP_TRGT | PORT_DEV_STP_TRGT)) {
-		expander = get_expander_obj(root, root->lib_rsrc);
-		if (expander == NULL) {
-			CORE_DPRINT(("Ran out of expanders. Aborting.\n"));
-			return;
-		}
-		set_up_new_expander(root, port, expander);
-		expander->base.parent = &port->base;
-		if (core->state == CORE_STATE_STARTED) {
-			expander->need_report_plugin = MV_TRUE;
-		}
-		expander->has_been_setdown = MV_FALSE;
-
-		expander->sas_addr = port->att_dev_sas_addr;
-		expander->neg_link_rate = get_min_negotiated_link_rate(port);
-		List_AddTail(&expander->base.queue_pointer, &port->expander_list);
-		port->expander_count++;
-
-		expander->parent_phy_count = 0;
-		for (i=0; i<root->phy_num; i++) {
-			if (port->phy_map & MV_BIT(i)) {
-				expander->parent_phy_id[phy_id] = i;
-				expander->parent_phy_count++;
-				phy_id++;
-			}
-		}
-
-		core_queue_init_entry(root, &expander->base, MV_TRUE);
-	} else if (port->att_dev_info & PORT_DEV_SSP_TRGT) {
-		device = get_device_obj(root, root->lib_rsrc);
-		if (device == NULL) {
-			CORE_DPRINT(("no more free device\n"));
-			return;
-		}
-		sas_set_up_new_device(root, port, device);
-		update_base_id(root,port,device,MV_FALSE);
-		List_AddTail(&device->base.queue_pointer, &port->device_list);
-		port->device_count++;
-		tmp=get_spin_up_device_buf(root->lib_rsrc);
-		if(!tmp || (core->spin_up_group == 0)){
-			if(tmp){
-				free_spin_up_device_buf(root->lib_rsrc, tmp);
-			}
-			core_queue_init_entry(root, &device->base, MV_TRUE);
-		}else{
-			MV_LIST_HEAD_INIT(&tmp->list);
-			tmp->roots=root;
-			tmp->base=&device->base;
-
-			OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP(core,flags);
-			List_AddTail(&tmp->list,&core->device_spin_up_list);
-			if(core->device_spin_up_timer ==NO_CURRENT_TIMER) {
-				core->device_spin_up_timer=core_add_timer(core, 3,
-					(MV_VOID (*) (MV_PVOID, MV_PVOID))staggered_spin_up_handler,
-					&device->base, NULL);
-			}
-			OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(core,flags);
-		}
-	}
-}
-
-void sas_init_target_device(pl_root *root, domain_port *port, domain_device *dev, MV_U16 targetid, MV_U16 lun)
-{
-	domain_device *device = NULL;
-	domain_expander *expander = NULL;
-	core_extension *core = (core_extension *)root->core;
-	MV_U8 i, phy_id = 0;
-		device = get_device_obj(root, root->lib_rsrc);
-		if (device == NULL) {
-			CORE_DPRINT(("no more free device\n"));
-			return;
-		}
-		sas_set_up_new_device(root, port, device);
-		update_base_id(root,port,device,MV_TRUE);
-		remove_target_map(root->lib_dev->target_id_map, device->base.TargetID, MV_MAX_TARGET_NUMBER);
-		device->base.LUN = lun;
-		device->base.TargetID = targetid;
-		device->sas_addr=dev->sas_addr;
-		device->base.parent=dev->base.parent;
-		CORE_DPRINT(("Init target device Target  ID %d ,  lun  %d\n",device->base.TargetID,device->base.LUN));
-		List_AddTail(&device->base.queue_pointer, &port->device_list);
-		port->device_count++;
-		core_queue_init_entry(root, &device->base, MV_TRUE);
-
-}
-
-extern MV_BOOLEAN sata_port_store_sig(domain_port *port, MV_BOOLEAN from_sig_reg);
-void sata_init_port(pl_root *root, domain_port *port)
-{
-	domain_pm *pm;
-	domain_phy *phy = port->phy;
-
-	CORE_DPRINT(("port %p\n", port));
-	port->state = PORT_SATA_STATE_POWER_ON;
-
-	pm = get_pm_obj(root, root->lib_rsrc);
-	if (pm == NULL) {
-		CORE_DPRINT(("no more free pm\n"));
-		return;
-	}
-	set_up_new_pm(root, port, pm);
-	phy->sata_signature = 0xFFFFFFFF;
-	port->state = PORT_SATA_STATE_POWER_ON;
-	core_queue_init_entry(root, &port->base, MV_TRUE);
-}
-
-void map_phy_id(pl_root *root);
-void io_chip_init(MV_PVOID root_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_extension *core = (core_extension *)root->core;
-	domain_phy *phy = NULL;
-	domain_port *port = NULL;
-	MV_U8 i, tmp_phy_map = 0;
-
-	map_phy_id(root);
-	io_chip_init_registers(root);
-
-	core_sleep_millisecond(core, 100);
-
-	/* get phy information */
-	for (i = 0; i < root->phy_num; i++) {
-		phy = &root->phy[i];
-		update_phy_info(root, phy);
-		update_port_phy_map(root, phy);
-	}
-
-	for (i = 0; i < root->phy_num; i++) {
-		port = &root->ports[i];
-		if (port->type & PORT_TYPE_SATA)
-			tmp_phy_map |= port->phy_map;
-	}
-
-	mv_reset_phy(root, tmp_phy_map, MV_TRUE);
-
-	core_sleep_millisecond(root->core, 100);
-
-	/* to init port, discover first level devices */
-	for (i = 0; i < root->phy_num; i++) {
-		port = &root->ports[i];
-		if (port->phy_num == 0) continue;
-
-		if (port->type & PORT_TYPE_SAS) {
-			sas_init_port(root, port);
-		} else {
-			sata_init_port(root, port);
-		}
-	}
-}
-
-void write_wide_port_register(pl_root *root, domain_port *port)
-{
-	MV_U8 i;
-	MV_U32 reg;
-	domain_phy *phy;
-
-	/* for all phy participated, need update CONFIG_WIDE_PORT register */
-	for (i = 0; i < root->phy_num; i++) {
-		if (port->phy_map & MV_BIT(i)) {
-			phy = &root->phy[i];
-			WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_WIDE_PORT);
-			reg = READ_PORT_CONFIG_DATA(root, phy);
-			reg &= ~WIDE_PORT_PHY_MASK;
-			reg |= port->asic_phy_map;
-			WRITE_PORT_CONFIG_DATA(root, phy, reg);
-		}
-	}
-}
-
-void init_port(pl_root *root, domain_port *port)
-{
-
-	if (port->phy_num) {
-		CORE_DPRINT(("port %p has phy_num %d, phy_map %X, att_dev_sas_addr %016llx.\n",port,port->phy_num,port->phy_map,port->att_dev_sas_addr.value));
-	}
-
-	port->phy_num = 0;
-	port->phy_map = 0;
-	port->asic_phy_map = 0;
-	port->phy = NULL;
-	port->att_dev_sas_addr.value =0;
-
-	MV_ASSERT(port->phy_num == 0);
-	MV_ASSERT(port->phy_map == 0);
-	MV_ASSERT(port->asic_phy_map == 0);
-	MV_ASSERT(port->phy == NULL);
-	MV_ASSERT(U64_COMPARE_U32(port->att_dev_sas_addr, 0) == 0);
-
-	port->base.type = BASE_TYPE_DOMAIN_PORT;
-	port->base.port = port;
-	port->base.root = root;
-
-	MV_LIST_HEAD_INIT(&port->device_list);
-	MV_LIST_HEAD_INIT(&port->expander_list);
-	MV_LIST_HEAD_INIT(&port->current_tier);
-	MV_LIST_HEAD_INIT(&port->next_tier);
-
-	port->device_count = 0;
-	port->expander_count = 0;
-	port->init_count = 0;
-}
-
-domain_port * get_port(pl_root *root, domain_phy *phy)
-{
-	domain_port *port;
-
-	/* wide port will search the existing ports first.
-	 * if cannot find one, will come here */
-	port = &root->ports[phy->id];
-	init_port(root, port);
-	CORE_DPRINT(("phy %d on port %d.\n", phy->id, port->base.id));
-	return port;
-}
-
-void update_port_phy_map(pl_root *root, domain_phy *phy)
-{
-	domain_port *port;
-	MV_U32 i;
-	port = phy->port;
-
-	/*
-	 * the possible case code comes here,
-	 * phy is coming,
-	 * phy is changed, sas to sata, wide port to narrow, different attached sas
-	 * phy is removed,
-	 * for easy approach, deform the port and regenerate the port
-	 */
-	if (port != NULL) {
-		/* deform the wide port */
-		MV_DASSERT(port->phy_num >= 1);
-
-		if (port->phy_num >= 1) {
-			port->phy_num--;
-			port->phy_map &= ~MV_BIT(phy->id);
-			port->asic_phy_map &= ~MV_BIT(phy->asic_id);
-		}
-
-		phy->port = NULL;
-		if (port->phy_num == 0) {
-			MV_ASSERT(port->phy_map == 0);
-			MV_ASSERT(port->asic_phy_map == 0);
-			port->phy = NULL;
-			port->dev_info = 0;
-			port->att_dev_info = 0;
-			MV_ZeroMemory(&port->att_dev_sas_addr, sizeof(port->att_dev_sas_addr));
-			MV_ZeroMemory(&port->dev_sas_addr, sizeof(port->dev_sas_addr));
-		} else {
-			/* update phy and link_rate */
-			port->phy = NULL;
-			port->link_rate = SAS_LINK_RATE_6_0_GBPS;
-			for (i = 0; i < root->phy_num; i++) {
-				domain_phy *tmp_phy;
-				tmp_phy = &root->phy[i];
-				if (port->phy_map & MV_BIT(tmp_phy->id)) {
-					if (port->phy == NULL) {
-						port->phy = tmp_phy;
-					}
-					port->link_rate =
-						MV_MIN(port->link_rate,
-						get_phy_link_rate(tmp_phy->phy_status));
-				}
-			}
-			write_wide_port_register(root, port);
-			port = NULL;
-		}
-	}
-
-	if (0 == (phy->phy_status & SCTRL_PHY_READY_MASK))
-		return;
-
-	/* treat it as a new phy, if it's sas, try to find a wide port */
-	if (phy->type & PORT_TYPE_SAS) {
-		if (!(phy->att_dev_info &
-			(PORT_DEV_SMP_TRGT | PORT_DEV_SSP_TRGT | PORT_DEV_STP_TRGT)))
-			return;
-
-		for (i = 0; i < root->phy_num; i++) {
-			domain_port *tmp_port;
-			tmp_port = &root->ports[i];
-			if ((tmp_port->phy_num > 0)
-				&& (tmp_port->type & PORT_TYPE_SAS)
-				&& (U64_COMPARE_U64(
-					tmp_port->att_dev_sas_addr, phy->att_dev_sas_addr)==0)
-				&& (U64_COMPARE_U64(
-					tmp_port->dev_sas_addr, phy->dev_sas_addr)==0))
-			{
-				/* find the wide port */
-				phy->port = tmp_port;
-				tmp_port->phy_num++;
-				tmp_port->phy_map |= MV_BIT(phy->id);
-				tmp_port->asic_phy_map |= MV_BIT(phy->asic_id);
-
-				MV_ASSERT(tmp_port->phy != NULL);
-
-				tmp_port->link_rate =
-					MV_MIN(tmp_port->link_rate,
-					get_phy_link_rate(phy->phy_status));
-				write_wide_port_register(root, tmp_port);
-				return;
-			}
-
-		}
-	}
-
-	if (port == NULL) {
-		port = get_port(root, phy);
-	}
-	MV_ASSERT(port != NULL);
-	phy->port = port;
-	port->type = phy->type;
-	MV_ASSERT(port->phy_num == 0);
-	port->phy_num = 1;
-	port->phy_map = MV_BIT(phy->id);
-	port->asic_phy_map = MV_BIT(phy->asic_id);
-	port->phy = &root->phy[phy->id];
-	port->link_rate = get_phy_link_rate(phy->phy_status);
-	port->dev_info = phy->dev_info;
-	MV_CopyMemory(&port->dev_sas_addr, &phy->dev_sas_addr,
-		sizeof(phy->dev_sas_addr));
-	port->att_dev_info = phy->att_dev_info;
-	MV_CopyMemory(&port->att_dev_sas_addr, &phy->att_dev_sas_addr,
-		sizeof(phy->att_dev_sas_addr));
-
-	write_wide_port_register(root, port);
-}
--- a/drivers/scsi/vanir/core/core/core_manager.h
+++ /dev/null
@@ -1,140 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_MANAGER_H
-#define __CORE_MANAGER_H
-
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "core_resource.h"
-#include "core_device.h"
-#include "core_gpio.h"
-#include "core_rmw_flash.h"
-#include "core_alarm.h"
-
-struct device_spin_up{
-	List_Head	list;
-	pl_root		*roots;
-	struct _domain_base *base;
-};
-
-enum CORE_STATE {
-	CORE_STATE_IDLE = 0,
-	CORE_STATE_STARTING,
-	CORE_STATE_STARTED,
-};
-
-typedef struct _core_extension {
-	MV_PVOID			  desc;
-	MV_U16                          vendor_id;
-	MV_U16                          device_id;
-
-	const struct mvs_chip_info *chip_info;
-
-	MV_U8                           revision_id;
-	MV_U8                           is_dump;
-	MV_U8                           state;
-	union {
-		MV_U8                   bh_enabled;
-		MV_U8                   reserved0;
-	};
-	MV_U8				s3_state;
-	MV_PVOID                        sg_pool;
-	MV_PVOID                        ct_pool;
-	char				sg_name[CACHE_NAME_LEN];
-	char				ct_name[CACHE_NAME_LEN];
-
-	MV_LPVOID                       mmio_base;
-	MV_LPVOID                       io_base;
-	MV_LPVOID                       nvsram_base;
-	command_handler                 handlers[MAX_NUMBER_HANDLER];
-
-	MV_U16                          max_io;
-	MV_U16                          hw_sg_entry_count; /* It's hardware sg entry count per buffer */
-	MV_U16                          init_queue_count; /* count the number devices need initialization */
-
-	MV_U32                          irq_mask; /* mask for main irq */
-	MV_U32                          main_irq; /* save interrupt status */
-
-	lib_resource_mgr                lib_rsrc;
-	lib_device_mgr                  lib_dev;
-
-	Counted_List_Head               init_queue;
-
-	List_Head                       event_queue;
-
-	Counted_List_Head               error_queue;
-
-	Counted_List_Head               waiting_queue;
-	Counted_List_Head               high_priority_queue;
-
-	List_Head                       complete_queue;
-
-	pl_root                         roots[MAX_NUMBER_IO_CHIP];
-
-	lib_gpio			lib_gpio;
-       lib_rmw_flash                   lib_flash;
-	lib_alarm			alarm;
-	MV_PHYSICAL_ADDR                trash_bucket_dma;
-	MV_U8	run_as_none_raid;
-
-	MV_U8 		spin_up_group;
-	MV_U8		spin_up_time;
-	List_Head	device_spin_up_list;
-	MV_U16	 	device_spin_up_timer;
-	MV_U8		reserved[2];
-} core_extension;
-#define IS_CORE_STARTED(core)	(((core_extension *)core)->state & CORE_STATE_STARTED)
-
-MV_U32 Core_ModuleGetResourceQuota(enum Resource_Type type, MV_U16 maxIo);
-MV_VOID Core_ModuleInitialize(MV_PVOID ModulePointer, MV_U32 extensionSize, MV_U16 maxIo);
-MV_VOID Core_ModuleStart(MV_PVOID This);
-MV_VOID Core_ModuleSendRequest(MV_PVOID This, PMV_Request pReq);
-MV_VOID Core_ModuleMonitor(MV_PVOID This);
-MV_VOID Core_ModuleNotification(MV_PVOID This, enum Module_Event event, struct mod_notif_param *param);
-MV_VOID Core_ModuleReset(MV_PVOID This);
-MV_VOID Core_ModuleShutdown(MV_PVOID This);
-
-MV_VOID core_set_chip_options(MV_PVOID ext);
-MV_VOID core_queue_completed_req(MV_PVOID ext, MV_Request *req);
-MV_VOID core_complete_requests(MV_PVOID core_p);
-MV_VOID core_abort_all_running_requests(MV_PVOID core_p);
-
-void core_disable_ints(void *ext);
-void core_enable_ints(void *ext);
-MV_BOOLEAN core_reset_controller(core_extension * core);
-MV_BOOLEAN core_clear_int(core_extension *core);
-MV_VOID core_handle_int(core_extension *core);
-void update_port_phy_map(pl_root *root, domain_phy *phy);
-MV_VOID controller_init(core_extension *core);
-MV_VOID io_chip_init_registers(pl_root *root);
-void update_phy_info(pl_root *root, domain_phy *phy);
-void core_set_cmd_header_selector(mv_command_header *cmd_header);
-void set_phy_tuning(pl_root *root, domain_phy *phy, PHY_TUNING phy_tuning);
-MV_VOID set_phy_ffe_tuning(pl_root *root, domain_phy *phy, FFE_CONTROL ffe);
-MV_VOID set_phy_rate(pl_root *root, domain_phy *phy, MV_U8 rate);
-MV_U8 get_min_negotiated_link_rate(domain_port *port);
-
-struct mvs_chip_info {
-	MV_U16		chip_id;
-	MV_U8 		n_host;
-	MV_U8		start_host;
-	MV_U32 		n_phy;
-	MV_U32 		fis_offs;
-	MV_U32 		fis_count;
-	MV_U32 		srs_sz;
-	MV_U32 		slot_width;
-};
-
-#endif /* __CORE_MANAGER_H */
--- a/drivers/scsi/vanir/core/core/core_protocol.c
+++ /dev/null
@@ -1,493 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_resource.h"
-#include "core_internal.h"
-#include "core_util.h"
-#include "core_manager.h"
-#include "com_util.h"
-
-#include "core_error.h"
-#include "core_expander.h"
-
-extern MV_PVOID sata_store_received_fis(pl_root *root, MV_U8 register_set, MV_U32 flag);
-
-MV_BOOLEAN prot_init_pl(pl_root *root, MV_U16 max_io,
-	MV_PVOID core, MV_LPVOID mmio,
-	lib_device_mgr *lib_dev, lib_resource_mgr *rsrc)
-{
-	MV_U16 slot_count, delv_q_size, cmpl_q_size, received_fis_count;
-	MV_U32 item_size;
-	MV_PU8 vir;
-	MV_U32 i;
-	domain_port *port;
-	domain_phy *phy;
-	core_extension* core_ext = (core_extension*)core;
-	core_get_supported_pl_counts(max_io, &slot_count, &delv_q_size, &cmpl_q_size, &received_fis_count);
-
-	root->mmio_base = mmio;
-
-	root->lib_dev = lib_dev;
-	root->lib_rsrc = rsrc;
-	root->core = (MV_PVOID)core;
-
-	root->phy_num = core_ext->chip_info->n_phy;
-	root->slot_count_support = slot_count;
-
-	root->delv_q_size = delv_q_size;
-	root->cmpl_q_size = cmpl_q_size;
-	root->last_delv_q = 0xfff;
-	root->last_cmpl_q = 0xfff;
-
-	/* allocate memory for running_req */
-	item_size = sizeof(PMV_Request) * slot_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	root->running_req = (PMV_Request *)vir;
-	root->running_num = 0;
-
-	/* allocate memory for saved fis */
-	item_size = sizeof(saved_fis) * received_fis_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	root->saved_fis_area = (saved_fis *)vir;
-
-	/* allocate memory for command table wrapper */
-	/* this is so far used as a array, not a pool */
-	item_size = sizeof(hw_buf_wrapper) * slot_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	root->cmd_table_wrapper = (hw_buf_wrapper*)vir;
-
-	/* slot pool */
-	item_size = sizeof(MV_U16) * slot_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	root->slot_pool.Stack = (MV_PU16)vir;
-	root->slot_pool.Size = slot_count;
-	Tag_Init_FIFO(&root->slot_pool, root->slot_pool.Size);
-
-	for (i = 0; i < core_ext->chip_info->n_phy; i++) {
-		phy = &(root->phy[i]);
-		phy->id = (MV_U8)i;
-		phy->asic_id = (MV_U8)i;
-              phy->root = root;
-	}
-
-	for (i = 0; i < core_ext->chip_info->n_phy; i++) {
-		extern void init_port(pl_root *root, domain_port *port);
-		port = &(root->ports[i]);
-
-		port->base.id = (MV_U8)i;
-		port->type = PORT_TYPE_SAS;
-
-		port->phy_num = 0;
-		port->phy_map = 0;
-		port->asic_phy_map = 0;
-		port->curr_phy_map = 0;
-		port->phy = NULL;
-
-		init_port(root, port);
-	}
-
-	return MV_TRUE;
-}
-
-MV_QUEUE_COMMAND_RESULT prot_send_request(pl_root *root, struct _domain_base *base,
-	MV_Request *req)
-{
-	mv_command_header *cmd_list = (mv_command_header *)root->cmd_list;
-	mv_command_header *cmd_header;
-	core_context *ctx = req->Context[MODULE_CORE];
-	core_extension * core = (core_extension *)root->core;
-	command_handler *handler = (command_handler *)ctx->handler;
-	hw_buf_wrapper *table_wrapper = NULL, *sg_wrapper = NULL;
-	MV_PHYSICAL_ADDR tmpPhy;
-	MV_U16 slot = 0, prd_num = 0;
-	MV_QUEUE_COMMAND_RESULT result;
-	MV_LPVOID mmio = root->mmio_base;
-	domain_phy *phy;
-	if (base->outstanding_req >= base->queue_depth) {
-		return MV_QUEUE_COMMAND_RESULT_FULL;
-	}
-
-
-	if (base->port != NULL) {
-                if (port_has_error_req(root, base->port) || (base->blocked == MV_TRUE) ||
-			port_has_init_req(root, base->port)) {
-			if (!CORE_IS_EH_REQ(ctx) && !CORE_IS_INIT_REQ(ctx)) {
-				return MV_QUEUE_COMMAND_RESULT_FULL;
-			}
-		}
-	}
-
-	if (base->cmd_issue_stopped) {
-		pal_abort_device_running_req(root, base);
-		hal_enable_register_set(root, base);
-		base->cmd_issue_stopped = MV_FALSE;
-	}
-	if ((BASE_TYPE_DOMAIN_DEVICE == base->type)
-		&& (((domain_device *)base)->status & DEVICE_STATUS_FROZEN) && (!CORE_IS_EH_REQ(ctx))) {
-		req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	/* verify this commands. Maybe can be finished right away without resource */
-	result = handler->verify_command(root, base, req);
-	if (result != MV_QUEUE_COMMAND_RESULT_PASSED) {
-		return result;
-	}
-
-	if (Tag_IsEmpty(&root->slot_pool)) {
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-	} else {
-		slot = Tag_GetOne(&root->slot_pool);
-	}
-	ctx->slot = slot;
-
-	/* set up hardware SG table */
-	sg_wrapper = get_sg_buf(root->lib_rsrc);
-	if (sg_wrapper == NULL) {
-		Tag_ReleaseOne(&root->slot_pool, slot);
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-	}
-
-	req->sg_table = ossw_pci_pool_alloc (core->sg_pool, &req->sg_table_phy.value);
-	if (req->sg_table == NULL) {
-		Tag_ReleaseOne(&root->slot_pool, slot);
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-	} else {
-		MV_ZeroMemory(req->sg_table, CORE_HW_SG_ENTRY_SIZE*CORE_MAX_HW_SG_ENTRY_COUNT);
-	}
-	sg_wrapper->vir = req->sg_table;
-	sg_wrapper->phy =  req->sg_table_phy;
-
-	MV_ZeroMemory(sg_wrapper->vir, CORE_HW_SG_ENTRY_SIZE*CORE_MAX_HW_SG_ENTRY_COUNT);
-	MV_DASSERT(ctx->sg_wrapper == NULL);
-	ctx->sg_wrapper = sg_wrapper;
-
-	/* set up command header */
-	cmd_header = &cmd_list[slot];
-	table_wrapper = &root->cmd_table_wrapper[slot];
-
-	req->cmd_table = ossw_pci_pool_alloc(core->ct_pool, &req->cmd_table_phy.value);
-	if (req->cmd_table == NULL) {
-		Tag_ReleaseOne(&root->slot_pool, slot);
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-	} else {
-		MV_ZeroMemory(req->cmd_table, sizeof(mv_command_table));
-	}
-	table_wrapper->vir = req->cmd_table;
-	table_wrapper->phy =  req->cmd_table_phy;
-
-	MV_ZeroMemory(cmd_header, sizeof(mv_command_header));
-	MV_ZeroMemory(table_wrapper->vir, sizeof(mv_command_table));
-
-	root->running_req[slot] = req;
-	root->running_num++;
-
-	prd_num = prot_set_up_sg_table(root, req, sg_wrapper);
-	cmd_header->ctrl_nprd = MV_CPU_TO_LE32(prd_num << CH_PRD_TABLE_LEN_SHIFT);
-	cmd_header->prd_table_addr = MV_CPU_TO_LE64(sg_wrapper->phy);
-
-
-	tmpPhy.value = table_wrapper->phy.value + OFFSET_OF(struct _mv_command_table, status_buff);
-	cmd_header->status_buff_addr = MV_CPU_TO_LE64(tmpPhy);
-
-	tmpPhy.value = table_wrapper->phy.value + OFFSET_OF(struct _mv_command_table, table);
-	cmd_header->table_addr = MV_CPU_TO_LE64(tmpPhy);
-
-	tmpPhy.value = table_wrapper->phy.value + OFFSET_OF(struct _mv_command_table, open_address_frame);
-	cmd_header->open_addr_frame_addr  = MV_CPU_TO_LE64(tmpPhy);
-
-	/* cmd_header->tag is different between SSP and STP/SATA
-	 * it'll be further handled in prepare_command handler.*/
-	cmd_header->tag = MV_CPU_TO_LE16(slot);
-	cmd_header->data_xfer_len = MV_CPU_TO_LE32(req->Data_Transfer_Length);
-
-	core_set_cmd_header_selector(cmd_header);
-
-	/* splits off to handle protocol-specific tasks */
-	handler->prepare_command(root, base, cmd_header, table_wrapper->vir, req);
-	handler->send_command(root, base, req);
-
-	return MV_QUEUE_COMMAND_RESULT_SENT;
-}
-
-MV_U32 prot_get_delv_q_entry(pl_root *root)
-{
-	MV_LPVOID mmio = root->mmio_base;
-	MV_U32 tmp;
-
-
-	root->last_delv_q++;
-	if (root->last_delv_q >= root->delv_q_size)
-		root->last_delv_q = 0;
-	tmp = (MV_U32)(root->last_delv_q);
-	return tmp;
-}
-
-MV_VOID prot_write_delv_q_entry(pl_root *root, MV_U32 entry)
-{
-	MV_REG_WRITE_DWORD(root->mmio_base, COMMON_DELV_Q_WR_PTR, entry);
-}
-
-PMV_Request get_intl_req_resource(pl_root *root, MV_U32 buf_size)
-{
-	PMV_Request req;
-	core_context *ctx;
-	hw_buf_wrapper *wrapper = NULL;
-
-	PMV_SG_Table sg_tbl;
-
-	req = get_intl_req(root->lib_rsrc);
-	if (req == NULL) return NULL;
-
-	MV_DASSERT(req->Context[MODULE_CORE] == NULL);
-	ctx = get_core_context(root->lib_rsrc);
-	if (ctx == NULL) {
-		free_intl_req(root->lib_rsrc, req);
-		return NULL;
-	}
-
-	MV_DASSERT(buf_size <= SCRATCH_BUFFER_SIZE);
-	if (buf_size != 0) {
-		wrapper = get_scratch_buf(root->lib_rsrc);
-		if (wrapper == NULL) {
-			free_intl_req(root->lib_rsrc, req);
-			free_core_context(root->lib_rsrc, ctx);
-			return NULL;
-		}
-		ctx->buf_wrapper = wrapper;
-		req->Data_Buffer = wrapper->vir;
-	} else {
-		ctx->buf_wrapper = NULL;
-		req->Data_Buffer = NULL;
-	}
-	req->Tag = 0xaa;
-	req->Context[MODULE_CORE] = ctx;
-	req->Cmd_Initiator = root;
-	req->Data_Transfer_Length = buf_size;
-	req->Scsi_Status = REQ_STATUS_PENDING;
-	req->Req_Flag = 0;
-	req->Cmd_Flag = 0;
-	req->Time_Out = 5;
-
-	/* Make the SG table. */
-	sg_tbl = &req->SG_Table;
-	SGTable_Init(sg_tbl, 0);
-	if (buf_size != 0) {
-		SGTable_Append(
-			sg_tbl,
-			wrapper->phy.parts.low,
-			wrapper->phy.parts.high,
-			buf_size);
-	}
-
-	MV_ZeroMemory(req->Cdb, sizeof(req->Cdb));
-	return req;
-}
-
-void intl_req_release_resource(lib_resource_mgr *rsrc, PMV_Request req)
-{
-	core_context *ctx;
-	hw_buf_wrapper *wrapper;
-
-	ctx = req->Context[MODULE_CORE];
-	MV_ASSERT(ctx != NULL);
-
-	wrapper = ctx->buf_wrapper;
-	if (wrapper) {
-		free_scratch_buf(rsrc, wrapper);
-		ctx->buf_wrapper = NULL;
-	}
-
-	if (ctx) {
-		free_core_context(rsrc, ctx);
-		req->Context[MODULE_CORE] = NULL;
-	}
-
-	free_intl_req(rsrc, req);
-}
-
-MV_VOID prot_clean_slot(pl_root *root, domain_base *base, MV_U16 slot,
-	MV_Request *req)
-{
-	hw_buf_wrapper *sg_wrapper;
-	core_extension *core = (core_extension *)root->core;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	root->running_req[slot] = NULL;
-	root->running_num--;
-
-	if (base->outstanding_req) {
-		base->outstanding_req--;
-	}
-	else {
-		CORE_DPRINT(("device %d outstanding req is zero??.\n",base->id));
-	}
-
-	Tag_ReleaseOne(&root->slot_pool, slot);
-
-	ossw_pci_pool_free(core->ct_pool, req->cmd_table, req->cmd_table_phy.value);
-	ossw_pci_pool_free(core->sg_pool, req->sg_table, req->sg_table_phy.value);
-	mv_renew_timer(root->core, req);
-
-	/* not every req will have a sg_wrapper (eg, instant requests) */
-	sg_wrapper = ctx->sg_wrapper;
-	if (sg_wrapper != NULL) {
-		free_sg_buf(root->lib_rsrc, sg_wrapper);
-		ctx->sg_wrapper = NULL;
-	}
-
-	/* release NCQ tag & register set */
-	if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-		domain_device *dev = (domain_device *)base;
-		if (IS_STP_OR_SATA(dev)) {
-			if (req->Cmd_Flag & CMD_FLAG_NCQ) {
-				sata_free_ncq_tag(dev, req);
-			}
-
-			if (ctx->req_flag & CORE_REQ_FLAG_NEED_D2H_FIS) {
-				if (dev->register_set != NO_REGISTER_SET) {
-					if ((req->Scsi_Status != REQ_STATUS_SUCCESS)
-						&& (req->Cmd_Flag & CMD_FLAG_PIO))
-						ctx->received_fis =
-							sata_store_received_fis(root,
-									dev->register_set,
-									(req->Cmd_Flag & (~CMD_FLAG_PIO)));
-					else
-						ctx->received_fis =
-							sata_store_received_fis(root,
-								dev->register_set,
-								req->Cmd_Flag);
-				} else {
-                                        ctx->received_fis = NULL;
-				}
-			}
-			if (dev->register_set != NO_REGISTER_SET) {
-				if (dev->base.outstanding_req == 0) {
-					sata_free_register_set(root, dev->register_set);
-					dev->register_set = NO_REGISTER_SET;
-				}
-			}
-		}
-	} else if (base->type == BASE_TYPE_DOMAIN_PM) {
-		domain_pm *pm = (domain_pm *)base;
-
-		if (ctx->req_flag & CORE_REQ_FLAG_NEED_D2H_FIS) {
-                        if (pm->register_set != NO_REGISTER_SET) {
-			        ctx->received_fis =
-				        sata_store_received_fis(root,
-					        pm->register_set,
-					        req->Cmd_Flag);
-                        } else {
-                                ctx->received_fis = NULL;
-                        }
-		}
-
-		if (pm->register_set != NO_REGISTER_SET) {
-			if (pm->base.outstanding_req == 0) {
-				sata_free_register_set(root, pm->register_set);
-				pm->register_set = NO_REGISTER_SET;
-			}
-		}
-	}
-}
-
-MV_VOID prot_process_cmpl_req(pl_root *root, MV_Request *req)
-{
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	command_handler *handler = (command_handler *)ctx->handler;
-	domain_base *base = (domain_base *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	domain_base *err_req_base;
-	domain_port *err_req_port;
-	PMV_Request err_req = NULL;
-	core_context *err_req_ctx;
-	core_extension *core = root->core;
-	MV_BOOLEAN push_back_req = FALSE;
-
-	MV_DASSERT(ctx != NULL);
-
-	prot_clean_slot(root, base, ctx->slot, req);
-
-	if ((ctx->error_info & EH_INFO_NEED_RETRY)
-		&& !CORE_IS_EH_REQ(ctx)
-		&& !CORE_IS_INIT_REQ(ctx)) {
-		MV_ASSERT(req->Scsi_Status != REQ_STATUS_SUCCESS);
-
-		if ((core->revision_id != VANIR_C2_REV)
-			&& (ctx->error_info & EH_INFO_WD_TO_RETRY) && (!Counted_List_Empty(&core->error_queue))) {
-			LIST_FOR_EACH_ENTRY_TYPE(err_req, &core->error_queue, MV_Request, Queue_Pointer) {
-				err_req_ctx = err_req->Context[MODULE_CORE];
-				if (err_req_ctx->error_info & EH_INFO_WD_TO_RETRY) {
-					err_req_base = (domain_base *)get_device_by_id(
-											&core->lib_dev,
-											err_req->Device_Id
-											);
-					err_req_port = err_req_base->port;
-					if (err_req_port == base->port) {
-						push_back_req = MV_TRUE;
-						break;
-					}
-				}
-			}
-			if (push_back_req) {
-				core_push_running_request_back(root, req);
-			}
-			else {
-				core_queue_error_req(root, req, MV_TRUE);
-				core_sleep_millisecond(core, 1000);
-			}
-		}
-		else
-			core_queue_error_req(root, req, MV_TRUE);
-	} else {
-		core_queue_completed_req(root->core, req);
-	}
-}
-
-err_info_record * prot_get_command_error_info(mv_command_table *cmd_table,
-	 MV_PU32 cmpl_q)
-{
-	MV_U64 tmp;
-	err_info_record *err_info;
-
-	if (!(*cmpl_q & RXQ_ERR_RCRD_XFRD))
-		return NULL;
-
-	tmp.value = (_MV_U64)(*(_MV_U64 *)(&cmd_table->status_buff.err_info));
-	if (U64_COMPARE_U32(tmp, 0) != 0) {
-		CORE_EH_PRINT(("error info 0x%016llx.\n", MV_CPU_TO_LE64(tmp)));
-		err_info = &cmd_table->status_buff.err_info;
-		return err_info;
-	} else {
-		return NULL;
-	}
-}
-
-
-void prot_fill_sense_data(MV_Request *req, MV_U8 sense_key,
-	MV_U8 ad_sense_code)
-{
-	if (req->Sense_Info_Buffer != NULL) {
-		((MV_PU8)req->Sense_Info_Buffer)[0] = 0x70;	/* Current */
-		((MV_PU8)req->Sense_Info_Buffer)[2] = sense_key;
-		/* additional sense length */
-		((MV_PU8)req->Sense_Info_Buffer)[7] = 0;
-		/* additional sense code */
-		((MV_PU8)req->Sense_Info_Buffer)[12] = ad_sense_code;
-	}
-}
--- a/drivers/scsi/vanir/core/core/core_protocol.h
+++ /dev/null
@@ -1,312 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_PROTOCOL_H
-#define __CORE_PROTOCOL_H
-
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_internal.h"
-
-typedef struct _hw_buf_wrapper {
-	struct _hw_buf_wrapper		*next;
-	MV_PVOID					vir;	/* virtual memory address */
-	MV_PHYSICAL_ADDR			phy;	/* physical memory address */
-} hw_buf_wrapper;
-
-typedef struct _saved_fis {
-	MV_U32 dw1;
-	MV_U32 dw2;
-	MV_U32 dw3;
-	MV_U32 dw4;
-} saved_fis;
-
-struct _pl_root {
-	MV_LPVOID	mmio_base;
-	MV_PVOID	core;
-	lib_device_mgr	 *lib_dev;
-	lib_resource_mgr *lib_rsrc;
-
-	MV_U64      sata_reg_set;		   /* bit map. need to change if register set is more than 64 */
-	MV_U32		phy_num;
-	MV_U32		max_register_set;	   /* per chip core */
-	MV_U32       running_num; /* how many requests are outstanding on the ASIC */
-
-	MV_U32		slot_count_support;
-	MV_U32		unassoc_fis_offset;
-	MV_U32		capability;
-
-	PMV_Request	*running_req;
-	saved_fis	*saved_fis_area;
-
-	domain_port	ports[MAX_PORT_PER_PL];
-	domain_phy	phy[MAX_PHY_PER_PL];
-
-	Tag_Stack slot_pool;
-
-	MV_U16 delv_q_size;
-	MV_U16 cmpl_q_size;
-	MV_U16 last_delv_q;
-	MV_U16 last_cmpl_q;
-
-	/* variables to save the interrupt status */
-	MV_U32		comm_irq;
-	MV_U32          comm_irq_mask;
-
-	/*keeps the base phy num of the root*/
-	MV_U32		base_phy_num;
-
-	/* command header list */
-	MV_PVOID cmd_list;
-	MV_PHYSICAL_ADDR cmd_list_dma;
-
-	/* command table */
-	hw_buf_wrapper *cmd_table_wrapper;
-
-	/* received FIS */
-	MV_PVOID rx_fis;
-	MV_PHYSICAL_ADDR rx_fis_dma;
-
-	/* delivery queue */
-	MV_PU32 delv_q;
-	MV_PHYSICAL_ADDR delv_q_dma;
-
-	/* completion queue: cmpl_wp is the write pointer. cmpl_q is the real queue entry 0 */
-	MV_PVOID cmpl_wp;
-	MV_PHYSICAL_ADDR cmpl_wp_dma;
-	MV_PU32  cmpl_q;
-	MV_PHYSICAL_ADDR cmpl_q_dma;
-
-	MV_U32 max_cmd_slot_width;
-};
-
-#define MAX_EVENTS 20
-typedef struct _event_record{
-	List_Head queue_pointer;
-	struct _pl_root *root;
-	MV_U8 phy_id;
-	MV_U8 event_id;
-	unsigned long handle_time;
-} event_record;
-
-enum _core_context_type {
-	CORE_CONTEXT_TYPE_NONE = 0, /* no valid context */
-	CORE_CONTEXT_TYPE_CDB =	1, /* context is the cdb and buffer */
-	CORE_CONTEXT_TYPE_LARGE_REQUEST = 2, /* context for the large request support */
-        CORE_CONTEXT_TYPE_SUB_REQUEST = 3,
-        CORE_CONTEXT_TYPE_ORG_REQ = 4, /* Used in SAT and error handling */
-	CORE_CONTEXT_TYPE_API = 5,
-	CORE_CONTEXT_TYPE_RESET_SATA_PHY = 6,
-	CORE_CONTEXT_TYPE_CLEAR_AFFILIATION = 7,
-	CORE_CONTEXT_TYPE_MAX,
-};
-
-enum _core_req_type {
-	CORE_REQ_TYPE_NONE = 0,
-	CORE_REQ_TYPE_INIT = 1, /* request generated in init state machine */
-	CORE_REQ_TYPE_ERROR_HANDLING = 2, /* request generated during error handling */
-	CORE_REQ_TYPE_RETRY = 3, /* is error handling request too, retry org req */
-};
-
-enum _core_req_flag {
-	CORE_REQ_FLAG_NEED_D2H_FIS	= (1 << 0),
-};
-
-/* eh req includes retried req */
-#define CORE_IS_EH_RETRY_REQ(ctx) \
-	((ctx)->req_type==CORE_REQ_TYPE_RETRY)
-#define CORE_IS_EH_REQ(ctx) \
-	(((ctx)->req_type==CORE_REQ_TYPE_ERROR_HANDLING) \
-		|| ((ctx)->req_type==CORE_REQ_TYPE_RETRY))
-#define CORE_IS_INIT_REQ(ctx) \
-	((ctx)->req_type==CORE_REQ_TYPE_INIT)
-
-enum _error_info {
-	EH_INFO_CMD_ISS_STPD = (1U << 0),
-	EH_INFO_NEED_RETRY = (1U << 1),
-	EH_INFO_STP_WD_TO_RETRY = (1U << 2),
-	EH_INFO_SSP_WD_TO_RETRY = (1U << 3),
-};
-
-#define EH_INFO_WD_TO_RETRY (EH_INFO_STP_WD_TO_RETRY | EH_INFO_SSP_WD_TO_RETRY)
-
-/*
- * core context is used for one time request handling.
- * when calling Completion routine, the core_context will be released.
- * even you want to retry the request, the core cotext will be a new one.
- * so dont try to save information like retry_count in core context
- */
-typedef struct _core_context {
-	struct _core_context *next;
-
-	/*
-	 * following is the request context
-	 */
-	MV_U16 slot; /* which slot it is used */
-	MV_U8 type; /* for the following union data structure CORE_CONTEXT_TYPE_XXX */
-	MV_U8 req_type; /* core internal request type CORE_REQ_TYPE_XXX */
-	MV_U32 req_state;
-
-	MV_U8  ncq_tag;
-	MV_U8  req_flag;	/* core internal request flag CORE_REQ_FLAG_XXX */
-	MV_U8  reserved[2];
-
-	MV_PVOID buf_wrapper; /* wrapper for the scratch buffer */
-	MV_PVOID sg_wrapper; /* wrapper for the hw sg buffer */
-
-	/*
-	 *
-	 */
-	MV_PVOID handler;
-
-	/*
-	 * for error handling
-	 */
-	MV_U32 error_info;
-
-        MV_PVOID received_fis;
-        union {
-                struct {
-                        MV_Request *org_req;
-                        MV_U32 other;
-                } org;
-                struct {
-                        MV_U8 sub_req_cmplt;
-                        MV_U8 sub_req_count;
-                } large_req;
-                struct {
-                        MV_PVOID org_buff_ptr;
-                } sub_req;
-                /* for smp virtual reqs */
-                struct {
-                        MV_U8 current_phy_id;
-                        MV_U8 req_remaining;
-                } smp_discover;
-		struct {
-                        MV_U8 curr_dev_count;
-                        MV_U8 total_dev_count;
-                        MV_U8 req_remaining;
-		} smp_reset_sata_phy;
-		struct {
-			MV_U8 state;
-			MV_U8 curr_dev_count;
-                        MV_U8 total_dev_count;
-			MV_U8 req_remaining;
-			MV_U8 need_wait;
-		} smp_clear_aff;
-                struct {
-                        MV_U8 phy_count;
-                        MV_U8 address_count;
-                        MV_U8 current_phy;
-                        MV_U8 current_addr;
-                        MV_U8 req_remaining;
-                        MV_PVOID org_exp;
-                } smp_config_route;
-                /*for API expander request*/
-                struct{
-                        MV_U16 start;
-                        MV_U16 end;
-                        MV_U32 remaining;
-                        MV_PVOID pointer;
-                }api_req;
-                struct{
-                        MV_U16 phy_index;
-                        MV_PVOID buffer;
-                }api_smp;
-		struct{
-			MV_U8 affiliation_valid;
-		}smp_report_phy;
-        } u;
-} core_context;
-
-#define DC_ATA                                      MV_BIT(0)
-#define DC_SCSI                                     MV_BIT(1)
-#define DC_SERIAL                                   MV_BIT(2)
-#define DC_PARALLEL                                 MV_BIT(3)
-#define DC_ATAPI                                    MV_BIT(4)
-#define DC_SGPIO                                    MV_BIT(5)
-#define DC_I2C                                      MV_BIT(6)
-
-/* PD's Device type defined in SCSI-III specification */
-#define DT_DIRECT_ACCESS_BLOCK                      0x00
-#define DT_SEQ_ACCESS                               0x01
-#define DT_PRINTER                                  0x02
-#define DT_PROCESSOR                                0x03
-#define DT_WRITE_ONCE                               0x04
-#define DT_CD_DVD                                   0x05
-#define DT_OPTICAL_MEMORY                           0x07
-#define DT_MEDIA_CHANGER                            0x08
-#define DT_STORAGE_ARRAY_CTRL                       0x0C
-/* an actual enclosure */
-#define DT_ENCLOSURE                                0x0D
-
-/* The following are defined by Marvell */
-#define DT_EXPANDER                                 0x20
-#define DT_PM                                       0x21
-#define DT_SES_DEVICE                               0x22
-
-#define IS_SSP(dev) ((dev->connection & DC_SCSI) && \
-                     (dev->connection & DC_SERIAL) && \
-                     !(dev->connection & DC_ATA))
-
-#define IS_STP(dev) ((dev->connection & DC_SCSI) && \
-                     (dev->connection & DC_SERIAL) && \
-                     (dev->connection & DC_ATA))
-
-#define IS_SATA(dev) (!(dev->connection & DC_SCSI) && \
-                      (dev->connection & DC_SERIAL) && \
-                      (dev->connection & DC_ATA))
-
-#define IS_STP_OR_SATA(dev) ((dev->connection & DC_ATA) && \
-                             (dev->connection & DC_SERIAL))
-
-#define IS_ATAPI(dev) ((dev->connection & DC_ATAPI) && \
-                       (dev->connection & DC_ATA))
-
-#define IS_TAPE(dev)           (dev->dev_type == DT_SEQ_ACCESS)
-#define IS_ENCLOSURE(dev)      (dev->dev_type == DT_ENCLOSURE)
-#define IS_HDD(dev)            (dev->dev_type == DT_DIRECT_ACCESS_BLOCK)
-#define IS_OPTICAL(dev)        ((dev->dev_type == DT_WRITE_ONCE) || \
-                                (dev->dev_type == DT_CD_DVD) || \
-                                (dev->dev_type == DT_OPTICAL_MEMORY))
-
-#define IS_SGPIO(dev)          (dev->connection & DC_SGPIO)
-#define IS_I2C(dev)            (dev->connection & DC_I2C)
-
-#define IS_BEHIND_PM(dev)      (dev->pm != NULL)
-
-MV_BOOLEAN prot_init_pl(pl_root *root, MV_U16 max_io,
-	MV_PVOID core, MV_LPVOID mmio,
-	lib_device_mgr *lib_dev, lib_resource_mgr *lib_rsrc);
-
-MV_QUEUE_COMMAND_RESULT prot_send_request(pl_root *root,
-	struct _domain_base *base, MV_Request *req);
-
-MV_U32 prot_get_delv_q_entry(pl_root *root);
-MV_VOID prot_write_delv_q_entry(pl_root *root, MV_U32 entry);
-
-PMV_Request get_intl_req_resource(pl_root *root, MV_U32 buf_size);
-MV_VOID intl_req_release_resource(lib_resource_mgr *rsrc, PMV_Request req);
-
-MV_VOID io_chip_clear_int(pl_root *root);
-MV_VOID io_chip_handle_int(pl_root *root);
-
-void prot_fill_sense_data(MV_Request *req, MV_U8 sense_key,
-	MV_U8 ad_sense_code);
-
-MV_VOID prot_clean_slot(pl_root *root, domain_base *base, MV_U16 slot,
-	MV_Request *req);
-
-err_info_record * prot_get_command_error_info(mv_command_table *cmd_table,
-	 MV_PU32 cmpl_q);
-#endif /* __CORE_PROTOCOL_H */
--- a/drivers/scsi/vanir/core/core/core_resource.c
+++ /dev/null
@@ -1,1126 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_resource.h"
-#include "core_manager.h"
-
-#include "com_u64.h"
-#include "com_dbg.h"
-
-#include "core_sas.h"
-#include "core_error.h"
-#include "core_expander.h"
-#include "core_console.h"
-#include "core_util.h"
-
-void core_get_supported_dev (
-	IN MV_U16 max_io,	/* max io count */
-	OUT MV_PU16 hd_count, /* HDD count */
-	OUT MV_PU8 exp_count, /* expander count */
-	OUT MV_PU8 pm_count, /* pm count */
-	OUT MV_PU8 enc_count /* enclosure count */
-	)
-{
-	*hd_count = CORE_MAX_DEVICE_SUPPORTED;
-
-	*pm_count = CORE_MAX_PM_SUPPORTED;
-	if (max_io == 1) {
-		*exp_count = CORE_MIN_EXPANDER_SUPPORTED;
-		*enc_count = CORE_MIN_ENC_SUPPORTED;
-	} else {
-		*exp_count = CORE_MAX_EXPANDER_SUPPORTED;
-		*enc_count = CORE_MAX_ENC_SUPPORTED;
-	}
-}
-
-void core_get_supported_pl_counts(
-	IN MV_U16 max_io,	/* max io count */
-	OUT MV_PU16 slot_count, /* hardware I/O slot count */
-	OUT MV_PU16 delv_q_size, /* deliver queue size */
-	OUT MV_PU16 cmpl_q_size, /* completion queue size */
-	OUT MV_PU16 received_fis_count /* max received FISes we can save. Depends on register set */
-	)
-{
-	if (max_io == 1) {
-		*slot_count = 1;
-		*delv_q_size = *slot_count + 1;
-		*received_fis_count = 1;
-	} else {
-		*slot_count = CORE_MAX_REQUEST_NUMBER;
-		*delv_q_size = *slot_count;
-		*received_fis_count = MAX_REGISTER_SET_PER_IO_CHIP;
-	}
-	*cmpl_q_size = *slot_count + 1 + 10;
-}
-
-void xor_get_supported_pl_counts(
-	IN MV_U16 max_io,	/* max io count */
-	OUT MV_PU16 slot_count, /* hardware I/O slot count */
-	OUT MV_PU16 delv_q_size, /* deliver queue size */
-	OUT MV_PU16 cmpl_q_size /* completion queue size */
-	)
-{
-	if (max_io == 1) {
-		*slot_count = 1;
-		*delv_q_size = *slot_count + 1;
-	} else {
-		*slot_count = XOR_MAX_SLOT_NUMBER;
-		*delv_q_size = *slot_count;
-	}
-
-	*cmpl_q_size = *slot_count + 1;
-}
-
-void core_get_supported_pal_counts(
-	IN MV_U16 max_io,	/* max io count */
-	OUT MV_PU16 intl_req_count, /* internal request count, used for */
-		/* a. initialization(InternalReqCount) b. sub req for large request support(SubReqCount) */
-	OUT MV_PU16 req_sg_entry_count, /* cached memory sg entry count for internal requests */
-	OUT MV_PU16 hw_sg_entry_count, /* dma sg scratch buffer entry count */
-	OUT MV_PU16 hw_sg_buf_count, /* dma sg scratch buffer count */
-	OUT MV_PU16 scratch_buf_count, /* dma internal req scratch buffer, used for */
-		/* a.identify(SATAScratchCount), b. SES (SESControlCount), c. SMP(SMPScratchCount) */
-	OUT MV_PU16 context_count, /* core request context for both internal/external req */
-	OUT MV_PU16 event_count /* hardware event count */
-   )
-{
-	MV_U16 slot_count, delv_q_size, cmpl_q_size, received_fis_count;
-	core_get_supported_pl_counts(max_io, &slot_count, &delv_q_size, &cmpl_q_size, &received_fis_count);
-
-	if (max_io == 1) {
-		*intl_req_count = CORE_MIN_INTERNAL_REQ_COUNT;
-		*req_sg_entry_count = CORE_MIN_REQ_SG_ENTRY_COUNT;
-		*hw_sg_entry_count = CORE_MIN_HW_SG_ENTRY_COUNT;
-		*hw_sg_buf_count = CORE_MIN_HW_SG_BUFFER_COUNT;
-		*scratch_buf_count = CORE_MIN_SCRATCH_BUFFER_COUNT;
-		*event_count = CORE_MIN_HW_EVENT_COUNT;
-	} else {
-		/* internal req count = init req count + sub req for large request support */
-		*intl_req_count = CORE_MAX_INTERNAL_REQ_COUNT;
-		*req_sg_entry_count = CORE_MAX_REQ_SG_ENTRY_COUNT;
-
-		*hw_sg_entry_count = CORE_MAX_HW_SG_ENTRY_COUNT;
-		*hw_sg_buf_count = CORE_MAX_HW_SG_BUFFER_COUNT;
-		*scratch_buf_count = CORE_MAX_SCRATCH_BUFFER_COUNT; /* SATA + SES + SMP */
-		*event_count = CORE_MAX_HW_EVENT_COUNT;
-	}
-
-	*context_count = *intl_req_count + slot_count * MAX_NUMBER_IO_CHIP;
-}
-
-
-#define INTERNAL_REQ_TOTAL_SIZE(sg_entry_n) \
-	(sizeof(MV_Request) + sizeof(MV_SG_Entry) * sg_entry_n + sizeof(struct _sense_data))
-
-MV_U32 core_get_cached_memory_quota(MV_U16 max_io)
-{
-	MV_U32 size = 0;
-
-	MV_U16 slot_count, delv_q_size, cmpl_q_size, received_fis_count;
-	MV_U16 intl_req_count, hw_sg_buf_count, scratch_buf_count, context_count;
-	MV_U16 req_sg_entry_count, hw_sg_entry_count, event_count;
-	MV_U8 exp_count, pm_count, enc_count;
-	MV_U16 hd_count;
-
-	core_get_supported_pl_counts(max_io, &slot_count, &delv_q_size, &cmpl_q_size, &received_fis_count);
-	core_get_supported_pal_counts(max_io, &intl_req_count, &req_sg_entry_count,
-		&hw_sg_entry_count, &hw_sg_buf_count, &scratch_buf_count, &context_count,
-		&event_count);
-	core_get_supported_dev(max_io, &hd_count, &exp_count, &pm_count, &enc_count);
-	size += ROUNDING(sizeof(core_extension), 8);
-	/*
-	 * The following are the pure cached memory allocation.
-	 */
-	/* memory for running_req to store the running requests on slot */
-	size += ROUNDING(sizeof(PMV_Request) * slot_count * MAX_NUMBER_IO_CHIP, 8);
-
-	/* memory for internal reqs */
-	size += ROUNDING(intl_req_count * INTERNAL_REQ_TOTAL_SIZE(req_sg_entry_count), 8);
-	/* request context for both external and internal requests */
-	size += ROUNDING(context_count * sizeof(core_context), 8);
-	/* tag pools */
-	size += ROUNDING(slot_count * MAX_NUMBER_IO_CHIP * sizeof(MV_U16), 8);
-	size += ROUNDING(MAX_NUMBER_IO_CHIP * sizeof(MV_U16), 8);
-
-	/*
-	 * The following are the wrapper for dma memory allocation.
-	 */
-	size += ROUNDING(sizeof(hw_buf_wrapper) * scratch_buf_count, 8);
-	size += ROUNDING(sizeof(hw_buf_wrapper) * hw_sg_buf_count, 8);
-	/* it's used to store command table address. command table is not contiguent. */
-	size += ROUNDING(sizeof(hw_buf_wrapper) * slot_count * MAX_NUMBER_IO_CHIP, 8);
-	size += ROUNDING(sizeof(event_record) * event_count, 8);
-	size += ROUNDING(sizeof(saved_fis) * received_fis_count * MAX_NUMBER_IO_CHIP, 8);
-
-	/* get device data structure memory */
-	size += ROUNDING(sizeof(domain_device) * hd_count, 8);
-	size += ROUNDING(sizeof(domain_expander) * exp_count, 8);
-	size += ROUNDING(sizeof(domain_pm) * pm_count, 8);
-	size += ROUNDING(sizeof(domain_enclosure) * enc_count, 8);
-
-	return size;
-}
-
-MV_U32 core_get_dma_memory_quota(MV_U16 max_io)
-{
-	MV_U32 size = 0;
-
-	MV_U16 scratch_buf_count, intl_req_count;
-	MV_U16 req_sg_entry_count, hw_sg_entry_count, event_count;
-	MV_U16 slot_count, hw_sg_buf_count, delv_q_size, cmpl_q_size, received_fis_count;
-	MV_U16 context_count;
-
-	core_get_supported_pl_counts(max_io, &slot_count, &delv_q_size, &cmpl_q_size, &received_fis_count);
-	core_get_supported_pal_counts(max_io, &intl_req_count, &req_sg_entry_count,
-		&hw_sg_entry_count, &hw_sg_buf_count, &scratch_buf_count, &context_count,
-		&event_count);
-
-	/*
-	 * For dma memory, need extra bytes for ASIC alignment requirement.
-	 * delivery queue/completion queue base address must be 64 byte aligned.
-	 */
-	size = 64 + sizeof(mv_command_header) * slot_count * MAX_NUMBER_IO_CHIP;	/* command list*/
-
-	size += 128 + sizeof(mv_command_table) * slot_count * MAX_NUMBER_IO_CHIP;	/* Command Table */
-
-	/* received FIS */
-	if (max_io > 1) {
-		size += (256 + MAX_RX_FIS_POOL_SIZE) * MAX_NUMBER_IO_CHIP;
-	} else {
-		size += 256 + MIN_RX_FIS_POOL_SIZE;
-	}
-
-	size += (64 + sizeof(MV_U32) * delv_q_size) * MAX_NUMBER_IO_CHIP;
-	size += (64 + sizeof(MV_U32) * cmpl_q_size) * MAX_NUMBER_IO_CHIP;
-
-	/* scratch buffer for initialization/SES/SMP */
-	size += 8 + SCRATCH_BUFFER_SIZE * scratch_buf_count;
-
-	/* buffer for dma SG tables */
-	size += 8 + CORE_HW_SG_ENTRY_SIZE * hw_sg_entry_count * hw_sg_buf_count;
-
-	if( max_io != 1 ) {
-		size += 8 + TRASH_BUCKET_SIZE;
-	}
-
-	return size;
-}
-
-MV_BOOLEAN lib_rsrc_allocate_device(lib_resource_mgr *rsrc, MV_U16 max_io)
-{
-	MV_U16 hd_count;
-	MV_U8 exp_count, pm_count, enc_count;
-	MV_U32 item_size;
-	int i;
-
-	core_get_supported_dev(max_io, &hd_count, &exp_count, &pm_count, &enc_count);
-
-	/* allocate memory for hd */
-	if (hd_count > 0) {
-		item_size = sizeof(domain_device) * hd_count;
-		rsrc->hds = (domain_device *)lib_rsrc_malloc_cached(rsrc, item_size);
-		if (rsrc->hds == NULL) return MV_FALSE;
-		for (i = 0; i < hd_count-1; i++){
-			rsrc->hds[i].base.queue_pointer.next =
-				(List_Head *)&rsrc->hds[i+1];
-		}
-		rsrc->hds[hd_count-1].base.queue_pointer.next = NULL;
-	}
-	rsrc->hd_count = hd_count;
-
-	/* allocate memory for expander */
-	if (exp_count > 0) {
-		item_size = sizeof(domain_expander) * exp_count;
-		rsrc->expanders = (domain_expander *)lib_rsrc_malloc_cached(rsrc, item_size);
-		if (rsrc->expanders == NULL) return MV_FALSE;
-		for (i = 0; i < exp_count-1; i++){
-			rsrc->expanders[i].base.queue_pointer.next =
-				(List_Head *)&rsrc->expanders[i+1];
-		}
-		rsrc->expanders[exp_count-1].base.queue_pointer.next = NULL;
-	}
-	rsrc->exp_count = exp_count;
-
-	/* allocate memory for pm */
-	if (pm_count > 0) {
-		item_size = sizeof(domain_pm) * pm_count;
-		rsrc->pms = (domain_pm *)lib_rsrc_malloc_cached(rsrc, item_size);
-		if (rsrc->pms == NULL) return MV_FALSE;
-		for (i = 0; i < pm_count-1; i++){
-			rsrc->pms[i].base.queue_pointer.next =
-				(List_Head *)&rsrc->pms[i+1];
-		}
-		rsrc->pms[pm_count-1].base.queue_pointer.next = NULL;
-	}
-	rsrc->pm_count = pm_count;
-
-	/* allocate memory for enclosure */
-	if (enc_count > 0) {
-		item_size = sizeof(domain_enclosure) * enc_count;
-		rsrc->enclosures = (domain_enclosure *)lib_rsrc_malloc_cached(rsrc, item_size);
-		if (rsrc->enclosures == NULL) return MV_FALSE;
-		for (i = 0; i < enc_count-1; i++){
-			rsrc->enclosures[i].base.queue_pointer.next =
-				(List_Head *)&rsrc->enclosures[i+1];
-		}
-		rsrc->enclosures[enc_count-1].base.queue_pointer.next = NULL;
-	}
-	rsrc->enc_count = enc_count;
-
-	return MV_TRUE;
-}
-
-
-MV_BOOLEAN lib_rsrc_allocate(lib_resource_mgr *rsrc, MV_U16 max_io)
-{
-	MV_U16 intl_req_count, hw_sg_buf_count, scratch_buf_count, context_count;
-	MV_U16 req_sg_entry_count, hw_sg_entry_count, event_count;
-
-	MV_U32 item_size;
-	MV_PU8 vir;
-
-	MV_Request *req = NULL;
-	hw_buf_wrapper *wrapper = NULL;
-	core_context *context = NULL;
-	event_record *event = NULL;
-	struct device_spin_up *device_su=NULL;
-	MV_U16 i;
-
-	MV_BOOLEAN ret;
-
-	core_get_supported_pal_counts(max_io, &intl_req_count, &req_sg_entry_count,
-		&hw_sg_entry_count, &hw_sg_buf_count, &scratch_buf_count, &context_count,
-		&event_count);
-
-	/* allocate memory for internal request including sg entry and sense */
-	item_size = INTERNAL_REQ_TOTAL_SIZE(req_sg_entry_count) * intl_req_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	rsrc->intl_req_pool = NULL;
-	for (i = 0; i < intl_req_count; i++) {
-		req = (MV_Request *)vir;
-		vir += sizeof(MV_Request);
-
-		req->SG_Table.Entry_Ptr = (PMV_SG_Entry)vir;
-		req->SG_Table.Max_Entry_Count = req_sg_entry_count;
-		vir += sizeof(MV_SG_Entry) * req_sg_entry_count;
-
-		req->Sense_Info_Buffer = vir;
-		req->Sense_Info_Buffer_Length = sizeof(sense_data);
-		vir += sizeof(sense_data);
-
-		req->Queue_Pointer.next = (List_Head *)rsrc->intl_req_pool;
-		rsrc->intl_req_pool = req;
-	}
-	rsrc->intl_req_count = intl_req_count;
-
-	item_size = sizeof(core_context) * context_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	rsrc->context_pool = NULL;
-	for (i = 0; i < context_count; i++) {
-		context = (core_context *)vir;
-		context->type = CORE_CONTEXT_TYPE_NONE;
-		context->next = rsrc->context_pool;
-		rsrc->context_pool = context;
-		vir += sizeof(core_context);
-	}
-	rsrc->context_count = context_count;
-
-	item_size = sizeof(hw_buf_wrapper) * scratch_buf_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	rsrc->scratch_buf_pool = NULL;
-	for (i = 0; i < scratch_buf_count; i++) {
-		wrapper = (hw_buf_wrapper *)vir;
-		wrapper->next = rsrc->scratch_buf_pool;
-		rsrc->scratch_buf_pool = wrapper;
-		vir += sizeof(hw_buf_wrapper);
-	}
-	rsrc->scratch_buf_count = scratch_buf_count;
-
-	item_size = sizeof(hw_buf_wrapper) * hw_sg_buf_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	rsrc->hw_sg_buf_pool = NULL;
-	for (i = 0; i < hw_sg_buf_count; i++) {
-		wrapper = (hw_buf_wrapper *)vir;
-		wrapper->next = rsrc->hw_sg_buf_pool;
-		rsrc->hw_sg_buf_pool = wrapper;
-		vir += sizeof(hw_buf_wrapper);
-	}
-	rsrc->hw_sg_buf_count = hw_sg_buf_count;
-	item_size = sizeof(event_record) * event_count;
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	rsrc->event_pool = NULL;
-	for (i = 0; i < event_count; i++) {
-		event = (event_record *)vir;
-		event->queue_pointer.next = (List_Head *)rsrc->event_pool;
-		rsrc->event_pool = event;
-		vir += sizeof(event_record);
-	}
-	rsrc->event_count = (MV_U8)event_count;
-
-	item_size = sizeof(struct device_spin_up) * CORE_MAX_DEVICE_SUPPORTED;
-		vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-		if (vir == NULL) return MV_FALSE;
-		rsrc->spin_up_device_pool = NULL;
-		for (i = 0; i < CORE_MAX_DEVICE_SUPPORTED; i++) {
-			device_su = (struct device_spin_up *)vir;
-			device_su->list.next = (List_Head *)rsrc->spin_up_device_pool;
-			rsrc->spin_up_device_pool = device_su;
-			vir += sizeof(struct device_spin_up);
-		}
-		rsrc->device_count = (MV_U16)CORE_MAX_DEVICE_SUPPORTED;
-
-	ret = lib_rsrc_allocate_device(rsrc, max_io);
-	if (ret==MV_FALSE) return MV_FALSE;
-
-	return MV_TRUE;
-}
-
-MV_BOOLEAN ses_state_machine(MV_PVOID enc_p);
-
-extern MV_VOID core_init_handlers(core_extension *core);
-MV_BOOLEAN core_init_cached_memory(core_extension *core,
-	lib_resource_mgr *rsrc, MV_U16 max_io)
-{
-	pl_root *root;
-
-	MV_U16 i;
-	MV_BOOLEAN ret;
-
-	MV_U16 intl_req_count, hw_sg_buf_count, scratch_buf_count, context_count;
-	MV_U16 req_sg_entry_count, hw_sg_entry_count, event_count;
-
-	core_get_supported_pal_counts(max_io, &intl_req_count, &req_sg_entry_count,
-		&hw_sg_entry_count, &hw_sg_buf_count, &scratch_buf_count, &context_count,
-		&event_count);
-
-	core->max_io = max_io;
-	if ( max_io==1 )
-		core->is_dump = MV_TRUE;
-	else
-		core->is_dump = MV_FALSE;
-	core->hw_sg_entry_count = hw_sg_entry_count;
-	core->init_queue_count = 0;
-	core->state = CORE_STATE_IDLE;
-
-	MV_COUNTED_LIST_HEAD_INIT(&core->init_queue);
-	MV_COUNTED_LIST_HEAD_INIT(&core->error_queue);
-	MV_COUNTED_LIST_HEAD_INIT(&core->waiting_queue);
-	MV_COUNTED_LIST_HEAD_INIT(&core->high_priority_queue);
-	MV_LIST_HEAD_INIT(&core->complete_queue);
-	MV_LIST_HEAD_INIT(&core->event_queue);
-	MV_LIST_HEAD_INIT(&core->device_spin_up_list);
-	core->device_spin_up_timer=NO_CURRENT_TIMER;
-	core_init_handlers(core);
-
-	/* setup PL variables */
-	for(i = core->chip_info->start_host; i < (core->chip_info->start_host + core->chip_info->n_host); i++) {
-		root = &core->roots[i];
-
-		ret = prot_init_pl(root,
-			max_io,
-			core,
-			(MV_LPVOID)((MV_PU8)core->mmio_base +
-				(MV_IO_CHIP_REGISTER_BASE + (i * MV_IO_CHIP_REGISTER_RANGE))),
-			&core->lib_dev,
-			&core->lib_rsrc
-			);
-		if (MV_FALSE == ret) return ret;
-	}
-
-	/* resource lib */
-	ret = lib_rsrc_allocate(rsrc, max_io);
-	if (MV_FALSE == ret) return ret;
-
-	return MV_TRUE;
-}
-
-MV_BOOLEAN core_init_dma_memory(core_extension * core,
-	lib_resource_mgr *lib_rsrc, MV_U16 max_io)
-{
-	MV_PVOID mem_v=NULL;
-	MV_PHYSICAL_ADDR mem_p;
-	hw_buf_wrapper *wrapper = NULL;
-	MV_U32 item_size, tmp_count, tmp_size, allocated_count;
-	lib_resource_mgr *rsrc = lib_rsrc;
-
-	MV_U16 i, j;
-
-	MV_U16 slot_count, delv_q_size, cmpl_q_size, received_fis_count;
-	MV_U16 intl_req_count, hw_sg_buf_count, scratch_buf_count, context_count;
-	MV_U16 req_sg_entry_count, hw_sg_entry_count, event_count;
-
-	core_get_supported_pl_counts(max_io, &slot_count, &delv_q_size, &cmpl_q_size, &received_fis_count);
-	core_get_supported_pal_counts(max_io, &intl_req_count, &req_sg_entry_count,
-		&hw_sg_entry_count, &hw_sg_buf_count, &scratch_buf_count, &context_count,
-		&event_count);
-	/*
-	* HW binds the list with Command List Base Address register
-	*  so no cache-tune permitted.
-	*/
-	item_size = sizeof(mv_command_header) * slot_count;
-	for(i = core->chip_info->start_host; i < (core->chip_info->start_host + core->chip_info->n_host); i++) {
-		mem_v = lib_rsrc_malloc_dma(rsrc, item_size, 64, &mem_p);
-		if (mem_v == NULL) return MV_FALSE;
-		core->roots[i].cmd_list = mem_v;
-		core->roots[i].cmd_list_dma = mem_p;
-	}
-
-	/* assign delivery queue (64 byte align) */
-	item_size = sizeof(MV_U32) * delv_q_size;
-	for(i = core->chip_info->start_host; i < (core->chip_info->start_host + core->chip_info->n_host); i++) {
-		mem_v = lib_rsrc_malloc_dma(rsrc, item_size, 64, &mem_p);
-		if (mem_v == NULL) return MV_FALSE;
-		core->roots[i].delv_q = mem_v;
-		core->roots[i].delv_q_dma = mem_p;
-	}
-
-	/* assign completion queue (64 byte align) */
-	item_size = sizeof(MV_U32) * cmpl_q_size;
-	for(i = core->chip_info->start_host; i < (core->chip_info->start_host + core->chip_info->n_host); i++) {
-		mem_v = lib_rsrc_malloc_dma(rsrc, item_size, 64, &mem_p);
-		if (mem_v == NULL) return MV_FALSE;
-		core->roots[i].cmpl_wp = mem_v;
-		core->roots[i].cmpl_wp_dma = mem_p;
-		core->roots[i].cmpl_q = (MV_PU32)((MV_PU8)mem_v + sizeof(MV_U32));
-		core->roots[i].cmpl_q_dma = U64_ADD_U32(mem_p, sizeof(MV_U32));
-	}
-
-	/* assign dma memory for received FIS (256 byte align) */
-	if (core->is_dump) {
-		item_size = MIN_RX_FIS_POOL_SIZE;
-	} else {
-		item_size = MAX_RX_FIS_POOL_SIZE;
-	}
-	for(i = core->chip_info->start_host; i < (core->chip_info->start_host + core->chip_info->n_host); i++) {
-		/* for hibernation, the FIS memory is shared */
-		if (i==0 || !core->is_dump) {
-		mem_v = lib_rsrc_malloc_dma(rsrc, item_size, 256, &mem_p);
-		if (mem_v == NULL) return MV_FALSE;
-		}
-		core->roots[i].rx_fis = mem_v;
-		core->roots[i].rx_fis_dma = mem_p;
-	}
-
-	sprintf(core->ct_name,"%s","mv_ct_pool_");
-	core->ct_pool= ossw_pci_pool_create(core->ct_name, core, sizeof(mv_command_table), 64 ,0);
-	if (core->ct_pool == NULL)
-		return MV_FALSE;
-
-	item_size = hw_sg_entry_count * CORE_HW_SG_ENTRY_SIZE;
-	sprintf(core->sg_name,"%s","mv_sg_pool_");
-	core->sg_pool = ossw_pci_pool_create(core->sg_name, core, item_size, 16, 0);
-	if (core->sg_pool == NULL)
-		return MV_FALSE;
-
-	/* assign the scratch buffer resource (8 byte align) */
-	item_size = SCRATCH_BUFFER_SIZE;
-	allocated_count = 0;
-	tmp_count = scratch_buf_count;
-	wrapper = rsrc->scratch_buf_pool;
-	do {
-		tmp_size = item_size * tmp_count;
-		mem_v = lib_rsrc_malloc_dma(rsrc, tmp_size, 8, &mem_p);
-		if (mem_v != NULL) {
-			for (j = 0; j < tmp_count; j++) {
-				MV_ASSERT(wrapper != NULL);
-				wrapper->vir = mem_v;
-				wrapper->phy = mem_p;
-				wrapper = wrapper->next;
-				mem_v = (MV_PU8)mem_v + item_size;
-				mem_p = U64_ADD_U32(mem_p, item_size);
-				allocated_count++;
-				if (allocated_count == scratch_buf_count) {
-					break;
-				}
-			}
-		} else {
-			tmp_count >>= 1;
-		}
-	} while ((tmp_count != 0) && (allocated_count < scratch_buf_count));
-	if (allocated_count < scratch_buf_count) return MV_FALSE;
-	MV_ASSERT(wrapper == NULL);
-
-	if(!core->is_dump) {
-		mem_v = lib_rsrc_malloc_dma(rsrc, TRASH_BUCKET_SIZE, 8, &mem_p);
-		if (mem_v != NULL) {
-			core->trash_bucket_dma = mem_p;
-		} else  {
-			return MV_FALSE;
-		}
-	}
-
-	return MV_TRUE;
-}
-
-PMV_Request get_intl_req_handler(lib_resource_mgr *rsrc);
-void free_intl_req_handler(lib_resource_mgr *rsrc, PMV_Request req);
-core_context *get_core_context_handler(lib_resource_mgr *rsrc);
-void free_core_context_handler(lib_resource_mgr *rsrc, core_context *context);
-hw_buf_wrapper *get_scratch_buf_handler(lib_resource_mgr *rsrc);
-void free_scratch_buf_handler(lib_resource_mgr *rsrc, hw_buf_wrapper *wrapper);
-hw_buf_wrapper *get_sg_buf_handler(lib_resource_mgr *rsrc);
-void free_sg_buf_handler(lib_resource_mgr *rsrc, hw_buf_wrapper *wrapper);
-struct device_spin_up *get_device_spin_up_handler(lib_resource_mgr *rsrc);
-void free_device_spin_up_handler(lib_resource_mgr *rsrc, struct device_spin_up *device);
-event_record *get_event_record_handler(lib_resource_mgr *rsrc);
-void free_event_record_handler(lib_resource_mgr *rsrc, event_record *event);
-domain_device *get_device_handler(lib_resource_mgr *rsrc);
-void free_device_handler(lib_resource_mgr *rsrc, domain_device *device);
-domain_expander *get_expander_handler(lib_resource_mgr *rsrc);
-void free_expander_handler(lib_resource_mgr *rsrc, domain_expander *exp);
-domain_pm *get_pm_handler(lib_resource_mgr *rsrc);
-void free_pm_handler(lib_resource_mgr *rsrc, domain_pm *pm);
-
-domain_enclosure *get_enclosure_handler(lib_resource_mgr *rsrc);
-void free_enclosure_handler(lib_resource_mgr *rsrc, domain_enclosure *enc);
-
-void lib_rsrc_init(lib_resource_mgr *rsrc, MV_PVOID cached_vir, MV_U32 cached_size,
-	MV_PVOID dma_vir, MV_PHYSICAL_ADDR dma_phy, MV_U32 dma_size,
-	resource_func_tbl *func, lib_device_mgr *lib_dev)
-{
-	/* global cached memory buffer */
-	MV_ASSERT((((MV_PTR_INTEGER)cached_vir) & (SIZE_OF_POINTER-1)) == 0);
-	rsrc->global_cached_vir = cached_vir;
-	rsrc->free_cached_vir = cached_vir;
-	rsrc->total_cached_size = cached_size;
-	rsrc->free_cached_size = cached_size;
-
-	/* global dma memory virtual and physical address */
-	MV_ASSERT((((MV_PTR_INTEGER)dma_vir) & (SIZE_OF_POINTER-1)) == 0);
-	rsrc->global_dma_vir = dma_vir;
-	rsrc->free_dma_vir = dma_vir;
-	rsrc->global_dma_phy = dma_phy;
-	rsrc->free_dma_phy = dma_phy;
-	rsrc->total_dma_size = dma_size;
-	rsrc->free_dma_size = dma_size;
-
-	rsrc->func_tbl = *func;
-	rsrc->lib_dev = lib_dev;
-}
-
-void * lib_rsrc_malloc_cached(lib_resource_mgr *rsrc, MV_U32 size)
-{
-	void * vir;
-
-	size = ROUNDING(size, SIZE_OF_POINTER);
-	if (rsrc->free_cached_size < size) {
-		MV_ASSERT(rsrc->func_tbl.malloc != NULL);
-		return rsrc->func_tbl.malloc(rsrc->func_tbl.extension,size, RESOURCE_CACHED_MEMORY, SIZE_OF_POINTER, NULL);
-	}
-
-	vir = rsrc->free_cached_vir;
-	rsrc->free_cached_vir = (MV_PU8)vir + size;
-	rsrc->free_cached_size -= size;
-
-	MV_DASSERT((((MV_PTR_INTEGER)vir) & (SIZE_OF_POINTER-1)) == 0);
-	return vir;
-}
-
-void * lib_rsrc_malloc_dma(lib_resource_mgr *rsrc, MV_U32 size,
-	MV_U16 alignment, MV_PHYSICAL_ADDR *phy)
-{
-	MV_U32 offset = 0;
-	void * vir;
-
-	size = ROUNDING(size, SIZE_OF_POINTER);
-
-	offset = (MV_U32)
-		(ROUNDING(rsrc->free_dma_phy.value, alignment) - rsrc->free_dma_phy.value);
-	if ((rsrc->free_dma_size + offset) < size) {
-		MV_DASSERT(rsrc->func_tbl.malloc != NULL);
-		return rsrc->func_tbl.malloc(rsrc->func_tbl.extension, size, RESOURCE_UNCACHED_MEMORY, alignment, phy);
-	}
-
-	vir = (MV_PU8)rsrc->free_dma_vir + offset;
-	*phy = U64_ADD_U32(rsrc->free_dma_phy, offset);
-
-	rsrc->free_dma_vir = (MV_PU8)vir + size;
-	rsrc->free_dma_phy = U64_ADD_U32(*phy, size);
-	rsrc->free_dma_size -= offset + size;
-
-	return vir;
-}
-
-MV_BOOLEAN core_init_obj(lib_resource_mgr *rsrc, void *obj, MV_U8 obj_type)
-{
-	switch (obj_type) {
-	case CORE_RESOURCE_TYPE_INTERNAL_REQ:
-		{
-			MV_Request *req = (MV_Request *)obj;
-			req->Req_Type = REQ_TYPE_CORE;
-			break;
-		}
-	case CORE_RESOURCE_TYPE_CONTEXT:
-		{
-			core_context *ctx = (core_context *)obj;
-			ctx->req_type = CORE_REQ_TYPE_NONE;
-			ctx->error_info = 0;
-			ctx->type = CORE_CONTEXT_TYPE_NONE;
-			ctx->req_state = 0;
-			ctx->req_flag = 0;
-			ctx->handler = NULL;
-
-			MV_DASSERT(ctx->buf_wrapper == NULL);
-			MV_DASSERT(ctx->sg_wrapper == NULL);
-
-			break;
-		}
-	case CORE_RESOURCE_TYPE_EVENT_RECORD:
-		{
-			event_record *event = (event_record *)obj;
-			event->handle_time = 0x0;
-			break;
-		}
-	case CORE_RESOURCE_TYPE_DOMAIN_DEVICE:
-		{
-			domain_device *dev = (domain_device *)obj;
-                     MV_ASSERT(dev->base.exp_queue_pointer.prev == NULL);
-                     MV_ASSERT(dev->base.exp_queue_pointer.next == NULL);
-			MV_ZeroMemory(dev, sizeof(domain_device));
-			dev->base.id = add_device_map(rsrc->lib_dev, &dev->base);
-			if (dev->base.id == MAX_ID) {
-				/* ran out of IDs */
-				return MV_FALSE;
-			}
-			break;
-		}
-	case CORE_RESOURCE_TYPE_DOMAIN_EXPANDER:
-		{
-			domain_expander *exp = (domain_expander *)obj;
-			MV_ZeroMemory(exp, sizeof(domain_expander));
-			exp->base.id = add_device_map(rsrc->lib_dev, &exp->base);
-			if (exp->base.id == MAX_ID) {
-				/* ran out of IDs */
-				return MV_FALSE;
-			}
-			break;
-		}
-	case CORE_RESOURCE_TYPE_DOMAIN_PM:
-		{
-			domain_pm *pm = (domain_pm *)obj;
-			MV_ZeroMemory(pm, sizeof(domain_pm));
-			pm->base.id = add_device_map(rsrc->lib_dev, &pm->base);
-			if (pm->base.id == MAX_ID) {
-				/* ran out of IDs */
-				return MV_FALSE;
-			}
-			break;
-		}
-	case CORE_RESOURCE_TYPE_DOMAIN_ENCLOSURE:
-		{
-			domain_enclosure *enc = (domain_enclosure *)obj;
-			MV_ZeroMemory(enc, sizeof(domain_enclosure));
-			enc->base.id = add_device_map(rsrc->lib_dev, &enc->base);
-			if (enc->base.id == MAX_ID) {
-				/* ran out of IDs */
-				return MV_FALSE;
-			}
-			break;
-		}
-	case CORE_RESOURCE_TYPE_SPIN_UP_DEVICE:
-		{
-			struct device_spin_up *su=(struct device_spin_up *)obj;
-			MV_ZeroMemory(su,sizeof(struct device_spin_up));
-		}
-
-		break;
-	default:
-		break;
-	}
-
-	return MV_TRUE;
-}
-
-void * core_malloc(MV_PVOID root_p, lib_resource_mgr *rsrc, MV_U8 obj_type)
-{
-	void * obj = NULL;
-	pl_root *root = (pl_root *)root_p;
-
-	if (root_p) {
-		core_extension *core = (core_extension *)root->core;
-		if (core == NULL) {
-			MV_ASSERT(MV_FALSE);
-			return NULL;
-		}
-	}
-		switch (obj_type) {
-		case CORE_RESOURCE_TYPE_INTERNAL_REQ:
-			obj = get_intl_req_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_CONTEXT:
-			obj = get_core_context_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_SCRATCH_BUFFER:
-			obj = get_scratch_buf_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_SG_BUFFER:
-			obj = get_sg_buf_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_EVENT_RECORD:
-			obj = get_event_record_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_DOMAIN_DEVICE:
-			obj = get_device_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_DOMAIN_EXPANDER:
-			obj = get_expander_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_DOMAIN_PM:
-			obj = get_pm_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_DOMAIN_ENCLOSURE:
-			obj = get_enclosure_handler(rsrc);
-			break;
-		case CORE_RESOURCE_TYPE_SPIN_UP_DEVICE:
-			obj =  get_device_spin_up_handler(rsrc);
-			break;
-		default:
-			MV_ASSERT(MV_FALSE);
-			break;
-		}
-
-	if (obj != NULL) {
-		if (core_init_obj(rsrc, obj, obj_type) == MV_FALSE) {
-			core_free(root_p, rsrc, obj, obj_type);
-			obj = NULL;
-		}
-	}
-
-	return obj;
-}
-
-static void core_clean_obj(lib_resource_mgr *rsrc, void * obj, MV_U8 obj_type)
-{
-	switch (obj_type) {
-	case CORE_RESOURCE_TYPE_DOMAIN_DEVICE:
-		{
-			domain_device *dev = (domain_device *)obj;
-			if (dev->base.id != MAX_ID) {
-				remove_device_map(rsrc->lib_dev, dev->base.id);
-			}
-			MV_ASSERT(dev->base.err_ctx.timer_id == NO_CURRENT_TIMER);
-			break;
-		}
-	case CORE_RESOURCE_TYPE_DOMAIN_EXPANDER:
-		{
-			domain_expander *exp = (domain_expander *)obj;
-			if (exp->base.id != MAX_ID) {
-				remove_device_map(rsrc->lib_dev, exp->base.id);
-			}
-			break;
-		}
-	case CORE_RESOURCE_TYPE_DOMAIN_PM:
-		{
-			domain_pm *pm = (domain_pm *)obj;
-			if (pm->base.id != MAX_ID) {
-				remove_device_map(rsrc->lib_dev, pm->base.id);
-			}
-			break;
-		}
-	case CORE_RESOURCE_TYPE_DOMAIN_ENCLOSURE:
-		{
-			domain_enclosure *enc = (domain_enclosure *)obj;
-			if (enc->base.id != MAX_ID) {
-				remove_device_map(rsrc->lib_dev, enc->base.id);
-			}
-			break;
-		}
-	default:
-		break;
-	}
-}
-
-void core_free(MV_PVOID root_p, lib_resource_mgr *rsrc, void * obj, MV_U8 obj_type)
-{
-	pl_root *root = (pl_root *)root_p;
-
-	if (root_p) {
-		core_extension *core = (core_extension *)root->core;
-		if (core == NULL) {
-			MV_ASSERT(MV_FALSE);
-			return;
-		}
-	}
-	core_clean_obj(rsrc, obj, obj_type);
-
-	if (rsrc->func_tbl.free == NULL) {
-		switch (obj_type) {
-		case CORE_RESOURCE_TYPE_INTERNAL_REQ:
-			free_intl_req_handler(rsrc, (PMV_Request)obj);
-			break;
-		case CORE_RESOURCE_TYPE_CONTEXT:
-			free_core_context_handler(rsrc, (core_context *)obj);
-			break;
-		case CORE_RESOURCE_TYPE_SCRATCH_BUFFER:
-                        free_scratch_buf_handler(rsrc, (hw_buf_wrapper *)obj);
-			break;
-		case CORE_RESOURCE_TYPE_SG_BUFFER:
-                        free_sg_buf_handler(rsrc, (hw_buf_wrapper *)obj);
-			break;
-		case CORE_RESOURCE_TYPE_EVENT_RECORD:
-                        free_event_record_handler(rsrc, (event_record *)obj);
-			break;
-		case CORE_RESOURCE_TYPE_DOMAIN_DEVICE:
-			free_device_handler(rsrc, (domain_device *)obj);
-			break;
-		case CORE_RESOURCE_TYPE_DOMAIN_EXPANDER:
-			free_expander_handler(rsrc, (domain_expander *)obj);
-			break;
-		case CORE_RESOURCE_TYPE_DOMAIN_PM:
-			free_pm_handler(rsrc, (domain_pm *)obj);
-			break;
-		case CORE_RESOURCE_TYPE_DOMAIN_ENCLOSURE:
-			free_enclosure_handler(rsrc, (domain_enclosure *)obj);
-			break;
-		case CORE_RESOURCE_TYPE_SPIN_UP_DEVICE:
-			free_device_spin_up_handler(rsrc,(struct device_spin_up *)obj);
-			break;
-		default:
-			MV_DASSERT(MV_FALSE);
-			break;
-		}
-	}
-}
-
-PMV_Request get_intl_req_handler(lib_resource_mgr *rsrc)
-{
-	PMV_Request req = NULL;
-	if (rsrc->intl_req_count > 0) {
-		MV_DASSERT(rsrc->intl_req_pool != NULL);
-		req = rsrc->intl_req_pool;
-		rsrc->intl_req_pool = (PMV_Request)req->Queue_Pointer.next;
-		rsrc->intl_req_count--;
-	} else {
-		MV_DASSERT(rsrc->intl_req_pool == NULL);
-	}
-
-	return req;
-}
-
-void free_intl_req_handler(lib_resource_mgr *rsrc, PMV_Request req)
-{
-	rsrc->intl_req_count++;
-	req->Queue_Pointer.next = (List_Head *)rsrc->intl_req_pool;
-	rsrc->intl_req_pool = req;
-}
-
-core_context *get_core_context_handler(lib_resource_mgr *rsrc)
-{
-	core_context *context = NULL;
-
-	if (rsrc->context_count > 0) {
-		MV_DASSERT(rsrc->context_pool != NULL);
-		context = rsrc->context_pool;
-		rsrc->context_pool = context->next;
-		rsrc->context_count--;
-	} else {
-		MV_DASSERT(rsrc->context_pool == NULL);
-	}
-
-	return context;
-}
-
-void free_core_context_handler(lib_resource_mgr *rsrc, core_context *context)
-{
-	MV_DASSERT(context != NULL);
-	context->next = rsrc->context_pool;
-	rsrc->context_pool = context;
-	rsrc->context_count++;
-}
-
-hw_buf_wrapper *get_scratch_buf_handler(lib_resource_mgr *rsrc)
-{
-	hw_buf_wrapper *wrapper = NULL;
-	if (rsrc->scratch_buf_count > 0) {
-		MV_DASSERT(rsrc->scratch_buf_pool != NULL);
-		wrapper = rsrc->scratch_buf_pool;
-		rsrc->scratch_buf_pool = wrapper->next;
-		rsrc->scratch_buf_count--;
-
-		wrapper->next = NULL;
-	} else {
-		MV_DASSERT(rsrc->scratch_buf_pool == NULL);
-	}
-
-	return wrapper;
-}
-
-void free_scratch_buf_handler(lib_resource_mgr *rsrc, hw_buf_wrapper *wrapper)
-{
-	MV_DASSERT(wrapper != NULL);
-	wrapper->next = rsrc->scratch_buf_pool;
-	rsrc->scratch_buf_pool = wrapper;
-	rsrc->scratch_buf_count++;
-}
-
-hw_buf_wrapper *get_sg_buf_handler(lib_resource_mgr *rsrc)
-{
-	hw_buf_wrapper *wrapper = NULL;
-	if (rsrc->hw_sg_buf_count > 0) {
-		MV_DASSERT(rsrc->hw_sg_buf_pool != NULL);
-		wrapper = rsrc->hw_sg_buf_pool;
-		rsrc->hw_sg_buf_pool = wrapper->next;
-		rsrc->hw_sg_buf_count--;
-
-		wrapper->next = NULL;
-	} else {
-		MV_DASSERT(rsrc->hw_sg_buf_pool == NULL);
-	}
-
-	return wrapper;
-}
-
-void free_sg_buf_handler(lib_resource_mgr *rsrc, hw_buf_wrapper *wrapper)
-{
-	MV_DASSERT(wrapper != NULL);
-	wrapper->next = rsrc->hw_sg_buf_pool;
-	rsrc->hw_sg_buf_pool = wrapper;
-	rsrc->hw_sg_buf_count++;
-}
-
-struct device_spin_up *get_device_spin_up_handler(lib_resource_mgr *rsrc)
-{
-	struct device_spin_up *device = NULL;
-
-	if (rsrc->device_count > 0) {
-		MV_DASSERT(rsrc->spin_up_device_pool != NULL);
-		device = rsrc->spin_up_device_pool;
-		rsrc->spin_up_device_pool = (struct device_spin_up *)device->list.next;
-		rsrc->device_count--;
-	} else {
-		MV_DASSERT(rsrc->spin_up_device_pool == NULL);
-	}
-	return device;
-}
-void free_device_spin_up_handler(lib_resource_mgr *rsrc, struct device_spin_up *device)
-{
-	MV_DASSERT(device != NULL);
-	device->list.next = (List_Head *)rsrc->spin_up_device_pool;
-	rsrc->spin_up_device_pool = device;
-	rsrc->device_count++;
-}
-
-event_record *get_event_record_handler(lib_resource_mgr *rsrc)
-{
-	event_record *event = NULL;
-
-	if (rsrc->event_count > 0) {
-		MV_DASSERT(rsrc->event_pool != NULL);
-		event = rsrc->event_pool;
-		rsrc->event_pool = (event_record *)event->queue_pointer.next;
-		rsrc->event_count--;
-	} else {
-		MV_DASSERT(rsrc->event_pool == NULL);
-	}
-
-	return event;
-}
-
-void free_event_record_handler(lib_resource_mgr *rsrc, event_record *event)
-{
-	MV_DASSERT(event != NULL);
-	event->queue_pointer.next = (List_Head *)rsrc->event_pool;
-	rsrc->event_pool = event;
-	rsrc->event_count++;
-}
-
-domain_device *get_device_handler(lib_resource_mgr *rsrc)
-{
-	domain_device *dev = NULL;
-
-	if (rsrc->hd_count > 0) {
-		dev = rsrc->hds;
-		rsrc->hds = (domain_device *)dev->base.queue_pointer.next;
-		rsrc->hd_count--;
-	} else {
-		MV_DASSERT(rsrc->hds == NULL);
-	}
-
-	return dev;
-}
-
-void free_device_handler(lib_resource_mgr *rsrc, domain_device *device)
-{
-	device->base.queue_pointer.next = (List_Head *)rsrc->hds;
-	rsrc->hds = device;
-	rsrc->hd_count++;
-}
-
-domain_expander *get_expander_handler(lib_resource_mgr *rsrc)
-{
-	domain_expander *exp = NULL;
-
-	if (rsrc->exp_count > 0) {
-		exp = rsrc->expanders;
-		rsrc->expanders = (domain_expander *)exp->base.queue_pointer.next;
-		rsrc->exp_count--;
-	} else {
-		MV_DASSERT(rsrc->expanders == NULL);
-	}
-
-	return exp;
-}
-
-void free_expander_handler(lib_resource_mgr *rsrc, domain_expander *exp)
-{
-	exp->base.queue_pointer.next = (List_Head *)rsrc->expanders;
-	rsrc->expanders = exp;
-	rsrc->exp_count++;
-}
-
-domain_pm *get_pm_handler(lib_resource_mgr *rsrc)
-{
-	domain_pm *pm = NULL;
-
-	if (rsrc->pm_count > 0) {
-		pm = rsrc->pms;
-		rsrc->pms = (domain_pm *)pm->base.queue_pointer.next;
-		rsrc->pm_count--;
-	} else {
-		MV_DASSERT(rsrc->pms == NULL);
-	}
-	return pm;
-}
-
-void free_pm_handler(lib_resource_mgr *rsrc, domain_pm *pm)
-{
-	pm->base.queue_pointer.next = (List_Head *)rsrc->pms;
-	rsrc->pms = pm;
-	rsrc->pm_count++;
-}
-domain_enclosure *get_enclosure_handler(lib_resource_mgr *rsrc)
-{
-	domain_enclosure *enc = NULL;
-
-	if (rsrc->enc_count > 0) {
-		enc = rsrc->enclosures;
-		rsrc->enclosures = (domain_enclosure *)enc->base.queue_pointer.next;
-		rsrc->enc_count--;
-	} else {
-		MV_DASSERT(rsrc->enclosures == NULL);
-	}
-	return enc;
-}
-void free_enclosure_handler(lib_resource_mgr *rsrc, domain_enclosure *enc)
-{
-	enc->base.queue_pointer.next = (List_Head *)rsrc->enclosures;
-	rsrc->enclosures= enc;
-	rsrc->enc_count++;
-}
--- a/drivers/scsi/vanir/core/core/core_resource.h
+++ /dev/null
@@ -1,199 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_RESOURCE_H
-#define __CORE_RESOURCE_H
-
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_protocol.h"
-
-struct _core_extension;
-
-/*
- * resource management for sas/sata part
- */
-MV_U32 core_get_cached_memory_quota(MV_U16 max_io);
-MV_U32 core_get_dma_memory_quota(MV_U16 max_io);
-MV_BOOLEAN core_init_cached_memory(struct _core_extension *core,
-	lib_resource_mgr *lib_rsrc, MV_U16 max_io);
-MV_BOOLEAN core_init_dma_memory(struct _core_extension * core,
-	lib_resource_mgr *lib_rsrc, MV_U16 max_io);
-
-/*
- * resource management interface
- */
-void core_get_supported_dev(MV_U16 max_io, MV_PU16 hd_count, MV_PU8 exp_count,
-	MV_PU8 pm_count, MV_PU8 enc_count);
-
-void core_get_supported_pl_counts(MV_U16 max_io, MV_PU16 slot_count,
-	MV_PU16 delv_q_size, MV_PU16 cmpl_q_size, MV_PU16 received_fis_count);
-
-void xor_get_supported_pl_counts(MV_U16 max_io, MV_PU16 slot_count,
-	MV_PU16 delv_q_size, MV_PU16 cmpl_q_size);
-
-void core_get_supported_pal_counts(MV_U16 max_io, MV_PU16 intl_req_count,
-	MV_PU16 req_sg_entry_count, MV_PU16 hw_sg_entry_count, MV_PU16 hw_sg_buf_count,
-	MV_PU16 scratch_buf_count, MV_PU16 context_count,
-	MV_PU16 event_count);
-
-enum resource_type {
-	CORE_RESOURCE_TYPE_INTERNAL_REQ = 1,
-	CORE_RESOURCE_TYPE_CONTEXT,
-	CORE_RESOURCE_TYPE_SCRATCH_BUFFER,
-	CORE_RESOURCE_TYPE_SG_BUFFER,
-	CORE_RESOURCE_TYPE_EVENT_RECORD,
-
-	CORE_RESOURCE_TYPE_DOMAIN_DEVICE,
-	CORE_RESOURCE_TYPE_DOMAIN_EXPANDER,
-	CORE_RESOURCE_TYPE_DOMAIN_PM,
-	CORE_RESOURCE_TYPE_DOMAIN_ENCLOSURE,
-	CORE_RESOURCE_TYPE_SPIN_UP_DEVICE,
-};
-
-typedef struct _resource_func_tbl {
-	/* dynamic memory malloc free function */
-	void *(*malloc)(void *extension, MV_U32 size, MV_U8 mem_type, MV_U16 alignment, MV_PHYSICAL_ADDR *phy);
-	void (*free)(const void * obj);
-	void * extension;
-} resource_func_tbl;
-
-struct _lib_resource_mgr {
-	/*
-	 * global cached/dma memory management variables
-	 */
-	/* global cached memory buffer */
-	MV_PVOID global_cached_vir;
-	MV_PVOID free_cached_vir;
-	MV_U32 total_cached_size;
-	MV_U32 free_cached_size;
-
-	/* global dma memory virtual and physical address */
-	MV_PVOID global_dma_vir;
-	MV_PHYSICAL_ADDR global_dma_phy;
-	MV_PVOID free_dma_vir;
-	MV_PHYSICAL_ADDR free_dma_phy;
-	MV_U32 total_dma_size;
-	MV_U32 free_dma_size;
-
-	resource_func_tbl	func_tbl;
-	lib_device_mgr          *lib_dev;
-
-	/*
-	 * allocated cached and dma memory
-	 */
-	MV_U16                 intl_req_count;
-	MV_U16                 context_count;
-	MV_U16                 scratch_buf_count;
-	MV_U16                 hw_sg_buf_count;
-	MV_U8                  event_count;
-
-	/* resource pool for cached memory */
-	MV_Request             *intl_req_pool;	/* internal requests pool */
-	core_context           *context_pool; /* core context pool */
-
-	/* resource pool for dma memory */
-	hw_buf_wrapper         *scratch_buf_pool; /* scratch buffer */
-	hw_buf_wrapper         *hw_sg_buf_pool; /* dma sg buffer for ASIC access */
-	event_record           *event_pool; /* event record pool */
-	struct device_spin_up	*spin_up_device_pool;
-
-	/*
-	 * allocated device data structure
-	 */
-	MV_U16                  hd_count; /* how many domain_device available */
-	MV_U8                  exp_count;
-	MV_U8                  pm_count;
-	MV_U8                  enc_count;
-	MV_U8			reserved0;
-	MV_U16                  device_count;
-
-	domain_device          *hds;
-	domain_expander        *expanders;
-	domain_pm              *pms;
-	domain_enclosure       *enclosures;
-
-};
-
-void * core_malloc(MV_PVOID root_p, lib_resource_mgr *rsrc, MV_U8 obj_type);
-void core_free(MV_PVOID root_p, lib_resource_mgr *rsrc, void * obj, MV_U8 obj_type);
-
-void * lib_rsrc_malloc_cached(lib_resource_mgr *rsrc, MV_U32 size);
-void * lib_rsrc_malloc_dma(lib_resource_mgr *rsrc, MV_U32 size,
-	MV_U16 alignment, MV_PHYSICAL_ADDR *phy);
-
-void lib_rsrc_init(lib_resource_mgr *rsrc, MV_PVOID cached_vir, MV_U32 cached_size,
-	MV_PVOID dma_vir, MV_PHYSICAL_ADDR dma_phy, MV_U32 dma_size,
-	resource_func_tbl *func, lib_device_mgr *lib_dev);
-
-#define get_intl_req(rsrc) \
-	(PMV_Request)core_malloc(NULL, rsrc, CORE_RESOURCE_TYPE_INTERNAL_REQ)
-
-#define free_intl_req(rsrc, req) \
-	core_free(NULL, rsrc, req, CORE_RESOURCE_TYPE_INTERNAL_REQ)
-
-#define get_core_context(rsrc) \
-	(core_context *)core_malloc(NULL, rsrc, CORE_RESOURCE_TYPE_CONTEXT)
-
-#define free_core_context(rsrc, context) \
-	core_free(NULL, rsrc, context, CORE_RESOURCE_TYPE_CONTEXT)
-
-#define get_scratch_buf(rsrc) \
-	(hw_buf_wrapper *)core_malloc(NULL, rsrc, CORE_RESOURCE_TYPE_SCRATCH_BUFFER)
-
-#define free_scratch_buf(rsrc, wrapper) \
-	core_free(NULL, rsrc, wrapper, CORE_RESOURCE_TYPE_SCRATCH_BUFFER)
-
-#define get_sg_buf(rsrc) \
-	(hw_buf_wrapper *)core_malloc(NULL, rsrc, CORE_RESOURCE_TYPE_SG_BUFFER)
-
-#define free_sg_buf(rsrc, wrapper) \
-	core_free(NULL, rsrc, wrapper, CORE_RESOURCE_TYPE_SG_BUFFER)
-#define get_spin_up_device_buf(rsrc) \
-		(struct device_spin_up *)core_malloc(NULL, rsrc, CORE_RESOURCE_TYPE_SPIN_UP_DEVICE)
-#define free_spin_up_device_buf(rsrc, device) \
-		core_free(NULL, rsrc, device, CORE_RESOURCE_TYPE_SPIN_UP_DEVICE)
-#define get_event_record(rsrc) \
-	(event_record *)core_malloc(NULL, rsrc, CORE_RESOURCE_TYPE_EVENT_RECORD)
-
-#define free_event_record(rsrc, event) \
-	core_free(NULL, rsrc, event, CORE_RESOURCE_TYPE_EVENT_RECORD)
-
-/*
- * device object data structure allocation and free
- */
-#define get_device_obj(root_p, rsrc) \
-	(domain_device *)core_malloc(root_p, rsrc, CORE_RESOURCE_TYPE_DOMAIN_DEVICE)
-
-#define free_device_obj(root_p, rsrc, dev) \
-	core_free(root_p, rsrc, dev, CORE_RESOURCE_TYPE_DOMAIN_DEVICE)
-
-#define get_expander_obj(root_p, rsrc) \
-	(domain_expander *)core_malloc(root_p, rsrc, CORE_RESOURCE_TYPE_DOMAIN_EXPANDER)
-
-#define free_expander_obj(root_p, rsrc, exp) \
-	core_free(root_p, rsrc, exp, CORE_RESOURCE_TYPE_DOMAIN_EXPANDER)
-
-#define get_pm_obj(root_p, rsrc) \
-	(domain_pm *)core_malloc(root_p, rsrc, CORE_RESOURCE_TYPE_DOMAIN_PM)
-
-#define free_pm_obj(root_p, rsrc, pm) \
-	core_free(root_p, rsrc, pm, CORE_RESOURCE_TYPE_DOMAIN_PM)
-
-#define get_enclosure_obj(root_p, rsrc) \
-	(domain_enclosure *)core_malloc(root_p, rsrc, CORE_RESOURCE_TYPE_DOMAIN_ENCLOSURE)
-
-#define free_enclosure_obj(root_p, rsrc,enc) \
-	core_free(root_p, rsrc,enc,CORE_RESOURCE_TYPE_DOMAIN_ENCLOSURE)
-
-#endif /* __CORE_RESOURCE_H */
--- a/drivers/scsi/vanir/core/core/core_type.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_INCLUDE_H
-#define __CORE_INCLUDE_H
-
-#include "mv_os.h"
-#include "com_define.h"
-#include "com_type.h"
-#include "com_tag.h"
-#include "com_scsi.h"
-#include "com_dbg.h"
-#include "com_util.h"
-#include "com_nvram.h"
-#include "com_sgd.h"
-#include "com_u64.h"
-#include "com_struct.h"
-#include "com_list.h"
-#include "hba_exp.h"
-
-#endif /* __CORE_INCLUDE_H */
--- a/drivers/scsi/vanir/core/core/core_util.c
+++ /dev/null
@@ -1,608 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_util.h"
-#include "core_internal.h"
-#include "core_manager.h"
-
-#include "core_type.h"
-#include "core_error.h"
-#include "hba_exp.h"
-#include "core_spi.h"
-
-int core_suspend(void *ext)
-{
-	AdapterInfo AI;
-	core_extension *core_ext = (core_extension *)ext;
-
-	core_disable_ints(core_ext);
-	return 0;
-}
-
-int core_resume(void *ext)
-{
-	int ret;
-	MV_U8 i;
-	AdapterInfo AI;
-	core_extension *core_ext = (core_extension *)ext;
-	pl_root * root = NULL;
-
-	if(core_reset_controller(core_ext) == MV_FALSE)
-		return -1;
-	core_enable_ints(core_ext);
-
-	for(i = core_ext->chip_info->start_host; i < (core_ext->chip_info->start_host + core_ext->chip_info->n_host); i++){
-		root = &core_ext->roots[i];
-		io_chip_init_registers(root);
-		root->last_cmpl_q = 0xfff;
-		root->last_delv_q = 0xfff;
-		root->running_num = 0;
-	}
-       return 0;
-}
-
-MV_LPVOID get_core_mmio(pl_root *root)
-{
-	core_extension *core = (core_extension *)root->core;
-	return core->mmio_base;
-}
-
-MV_VOID core_queue_init_entry(pl_root *root, MV_PVOID base_ext, MV_BOOLEAN start_init)
-{
-	core_extension *core = (core_extension *)root->core;
-	struct _domain_base *base = (struct _domain_base *)base_ext;
-	struct _error_context *err_ctx = &base->err_ctx;
-	MV_U32 count = Counted_List_GetCount(&core->init_queue, MV_TRUE);
-	MV_U8 i;
-	struct _domain_base *item;
-
-	if (count != Counted_List_GetCount(&core->init_queue, MV_FALSE)) {
-		CORE_DPRINT(("init_queue count  is conflict %d[%d]\n",count,Counted_List_GetCount(&core->init_queue, MV_FALSE)));
-	}
-	MV_DASSERT(count == Counted_List_GetCount(&core->init_queue, MV_FALSE));
-	LIST_FOR_EACH_ENTRY_TYPE(item , &core->init_queue, struct _domain_base,
-		init_queue_pointer) {
-		if (item == base) {
-			CORE_DPRINT(("find same base at init queue %p.\n",base));
-			return;
-		}
-	}
-
-	if (MV_TRUE == start_init) {
-		core->init_queue_count++;
-		base->port->init_count++;
-		err_ctx->retry_count = 0;
-		Counted_List_AddTail(&base->init_queue_pointer, &core->init_queue);
-	} else {
-		/* for dump mode and hotplug, we need totally finish one entry first */
-		Counted_List_Add(&base->init_queue_pointer, &core->init_queue);
-	}
-}
-
-MV_U8 enable_spin_up(MV_PVOID hba){
-	core_extension *core = (core_extension *)HBA_GetModuleExtension(hba, MODULE_CORE);
-	if (core->spin_up_group != 0) {
-		core_notify_device_hotplug(&core->roots[core->chip_info->start_host],
-						MV_TRUE,VIRTUAL_DEVICE_ID, MV_FALSE);
-		return MV_TRUE;
-	} else
-		return MV_FALSE;
-
-}
-MV_U32 core_spin_up_get_cached_memory_quota(MV_U16 max_io)
-{
-	MV_U32 size = 0;
-
-	size=sizeof(struct device_spin_up)*MV_MAX_TARGET_NUMBER;
-
-	return size;
-}
-
-MV_VOID staggered_spin_up_handler(domain_base * base, MV_PVOID tmp)
-{
-	domain_device *device;
-	core_extension *core = (core_extension *)base->root->core;
-	MV_U8 num=0,renew_timer=0;
-	MV_ULONG flags;
-	struct device_spin_up *su=NULL;
-	if((base == NULL) || (core == NULL)){
-		return;
-		}
-	CORE_DPRINT(("Staggered spin up ...\n"));
-	device = (domain_device *)base;
-	OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP((void *)core,flags);
-	while(!List_Empty(&core->device_spin_up_list)){
-		if((num >= core->spin_up_group) || (core->state != CORE_STATE_STARTED)){
-			renew_timer=1;
-			break;
-		}
-		su = (struct device_spin_up *)List_GetFirstEntry(
-			&core->device_spin_up_list, struct device_spin_up,list);
-
-		if(su){
-			if(su->roots==NULL){
-				CORE_DPRINT(("Got a NULL device\n"));
-				continue;
-			}else{
-				if(base->type == BASE_TYPE_DOMAIN_DEVICE){
-					domain_device *tmp_device=(domain_device *)su->base;
-					tmp_device->state=DEVICE_STATE_RESET_DONE;
-				}
-				core_queue_init_entry(su->roots, su->base, MV_TRUE);
-			}
-			num++;
-			free_spin_up_device_buf(su->roots->lib_rsrc,su);
-		}
-
-	}
-	if(List_Empty(&core->device_spin_up_list)){
-		if(core->device_spin_up_timer != NO_CURRENT_TIMER)
-			core_cancel_timer(core, core->device_spin_up_timer);
-		core->device_spin_up_timer =NO_CURRENT_TIMER;
-		}else{
-
-			if(core->device_spin_up_timer ==NO_CURRENT_TIMER){
-				core->device_spin_up_timer=core_add_timer(core, core->spin_up_time, (MV_VOID (*) (MV_PVOID, MV_PVOID))staggered_spin_up_handler, base, NULL);
-			}else{
-				if(renew_timer){
-					core->device_spin_up_timer=core_add_timer(core, core->spin_up_time, (MV_VOID (*) (MV_PVOID, MV_PVOID))staggered_spin_up_handler, base, NULL);
-				}
-			}
-		}
-	OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(core,flags);
-
-}
-
-MV_VOID core_init_entry_done(pl_root *root, domain_port *port,
-	domain_base *base)
-{
-	core_extension *core = (core_extension *)root->core;
-	domain_device *dev;
-	domain_expander *exp;
-	domain_enclosure *enc;
-	MV_ULONG flags;
-
-	if(core->init_queue_count){
-		core->init_queue_count--;
-	} else {
-		CORE_DPRINT(("core->init_queue_count is zero.\n"));
-	}
-
-        if(port->init_count) {
-		port->init_count--;
-        } else {
-        }
-
-        /* if init failure, base == NULL */
-	if (base != NULL) {
-		switch (base->type) {
-		case BASE_TYPE_DOMAIN_DEVICE:
-			dev = (domain_device *)base;
-			MV_ASSERT(dev->status & DEVICE_STATUS_FUNCTIONAL);
-			if ((core->state == CORE_STATE_STARTED)){
-				core_notify_device_hotplug(root, MV_TRUE,
-					base->id, MV_TRUE);
-				if(core->spin_up_group){
-					OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP(core,flags);
-					if(dev->status&DEVICE_STATUS_SPIN_UP){
-						dev->status &=~DEVICE_STATUS_SPIN_UP;
-					}
-					OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(core,flags);
-				}
-			}
-			break;
-		case BASE_TYPE_DOMAIN_ENCLOSURE:
-			enc = (domain_enclosure *)base;
-			if (enc->enc_flag & ENC_FLAG_FIRST_INIT) {
-				enc->enc_flag &= ~ENC_FLAG_FIRST_INIT;
-				if (core->state == CORE_STATE_STARTED)
-					core_notify_device_hotplug(root, MV_TRUE,
-						base->id, MV_TRUE);
-			}
-			break;
-		case BASE_TYPE_DOMAIN_PM:
-			port->pm = (domain_pm *)base;
-			break;
-		case BASE_TYPE_DOMAIN_EXPANDER:
-			exp = (domain_expander *)base;
-			if ((core->state == CORE_STATE_STARTED) &&
-				(exp->enclosure) &&
-				(exp->enclosure->enc_flag & ENC_FLAG_NEED_REINIT)) {
-				exp->enclosure->state = ENCLOSURE_INQUIRY_DONE;
-				exp->enclosure->enc_flag &= ~ENC_FLAG_NEED_REINIT;
-				core_queue_init_entry(root,
-					&exp->enclosure->base, MV_TRUE);
-			}
-			if (exp->need_report_plugin) {
-				core_generate_event(root->core,
-					EVT_ID_EXPANDER_PLUG_IN, exp->base.id,
-					SEVERITY_INFO, 0, NULL, 0);
-				exp->need_report_plugin = MV_FALSE;
-			}
-			break;
-		case BASE_TYPE_DOMAIN_I2C:
-			break;
-		case BASE_TYPE_DOMAIN_PORT:
-			break;
-		default:
-			MV_DASSERT(MV_FALSE);
-			break;
-		}
-	}
-}
-
-MV_PVOID core_get_handler(pl_root *root, MV_U8 handler_id)
-{
-	core_extension *core = (core_extension *)root->core;
-	return (MV_PVOID)&core->handlers[handler_id];
-}
-
-MV_VOID core_append_request(pl_root *root, PMV_Request req)
-{
-	core_extension *core = (core_extension *)root->core;
-
-	Counted_List_AddTail(&req->Queue_Pointer, &core->waiting_queue);
-}
-
-MV_VOID core_push_running_request_back(pl_root *root, PMV_Request req)
-{
-	core_extension *core = (core_extension *)root->core;
-
-	Counted_List_Add(&req->Queue_Pointer, &core->waiting_queue);
-}
-
-MV_VOID core_append_high_priority_request(pl_root *root, PMV_Request req)
-{
-	core_extension *core = (core_extension *)root->core;
-
-	Counted_List_AddTail(&req->Queue_Pointer, &core->high_priority_queue);
-}
-
-void core_append_init_request(pl_root *root, MV_Request *req)
-{
-	core_extension *core = (core_extension *)root->core;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	MV_ASSERT(ctx != NULL);
-
-	ctx->req_type = CORE_REQ_TYPE_INIT;
-	req->Time_Out = HBA_CheckIsFlorence(core) ?
-		CORE_REQ_FLORENCE_INIT_TIMEOUT : CORE_REQ_INIT_TIMEOUT;
-	core_append_request(root, req);
-}
-
-void core_queue_eh_req(pl_root *root, MV_Request *req)
-{
-	core_extension *core = (core_extension *)root->core;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	if (ctx->req_type == CORE_REQ_TYPE_NONE) {
-	ctx->req_type = CORE_REQ_TYPE_ERROR_HANDLING;
-	}
-	MV_ASSERT((ctx->req_type == CORE_REQ_TYPE_ERROR_HANDLING)
-		|| (ctx->req_type == CORE_REQ_TYPE_RETRY));
-
-	req->Time_Out = 2;
-	core_append_high_priority_request(root, req);
-}
-
-void core_queue_error_req(pl_root *root, MV_Request *req, MV_BOOLEAN new_error)
-{
-	core_extension *core = (core_extension *)root->core;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_base *base = (domain_base *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-
-	MV_ASSERT(ctx);
-	MV_ASSERT(get_device_by_id(root->lib_dev, req->Device_Id) == base);
-	MV_ASSERT(!CORE_IS_INIT_REQ(ctx));
-
-	if (new_error) {
-		CORE_EH_PRINT(("dev %d queue original error req %p [0x%x].\n",\
-			base->id, req, req->Cdb[0]));
-		base->err_ctx.error_count++;
-
-		MV_ASSERT(!CORE_IS_EH_REQ(ctx));
-		Counted_List_AddTail(&req->Queue_Pointer, &core->error_queue);
-	} else {
-		CORE_EH_PRINT(("no resource, push back error req %p [0x%x].\n",\
-			req, req->Cdb[0]));
-		Counted_List_Add(&req->Queue_Pointer, &core->error_queue);
-	}
-}
-
-void core_complete_error_req(pl_root *root, MV_Request *req, MV_U8 status)
-{
-	core_extension *core = (core_extension *)root->core;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_base *base = (domain_base *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	struct _error_context *err_ctx = &base->err_ctx;
-
-	CORE_DPRINT(("returns %p with status 0x%x.\n", \
-		req, status));
-	MV_ASSERT(get_device_by_id(root->lib_dev, req->Device_Id) == base);
-
-	MV_ASSERT(ctx->req_type == CORE_REQ_TYPE_NONE);
-	if ((req->Scsi_Status == REQ_STATUS_NO_DEVICE) && (err_ctx->eh_type == EH_TYPE_TIMEOUT)) {
-		domain_device *device = (domain_device *)base;
-		CORE_DPRINT(("Find device %d is bad disk\n",base->id));
-		device->status = DEVICE_STATUS_NO_DEVICE;
-	}
-
-	err_ctx->eh_type = EH_TYPE_NONE;
-	err_ctx->eh_state = EH_STATE_NONE;
-	err_ctx->error_count--;
-	err_ctx->error_req = NULL;
-	if ((status == REQ_STATUS_SUCCESS)
-		&& (err_ctx->state == BASE_STATE_ERROR_HANDLING)) {
-		err_ctx->state = BASE_STATE_ERROR_HANDLED;
-	} else
-		err_ctx->state = BASE_STATE_NONE;
-
-	if (err_ctx->eh_timer != NO_CURRENT_TIMER) {
-		core_cancel_timer(core, err_ctx->eh_timer);
-		err_ctx->eh_timer = NO_CURRENT_TIMER;
-	}
-
-	MV_ASSERT(status != REQ_STATUS_TIMEOUT);
-	req->Scsi_Status = status;
-
-	if ((req->Scsi_Status == REQ_STATUS_SUCCESS)
-		&& (req->Sense_Info_Buffer_Length != 0)
-		&& (req->Sense_Info_Buffer != NULL)) {
-		((MV_PU8)req->Sense_Info_Buffer)[0] = 0;
-		((MV_PU8)req->Sense_Info_Buffer)[2] = 0;
-		((MV_PU8)req->Sense_Info_Buffer)[7] = 0;
-		((MV_PU8)req->Sense_Info_Buffer)[12] = 0;
-		((MV_PU8)req->Sense_Info_Buffer)[13] = 0;
-	}
-
-	core_queue_completed_req(core, req);
-}
-void
-core_notify_device_hotplug(pl_root *root, MV_BOOLEAN plugin,
-	MV_U16 dev_id, MV_U8 generate_event)
-{
-	core_extension *core = (core_extension *)root->core;
-
-	struct mod_notif_param param;
-	MV_PVOID upper_layer;
-	MV_VOID (*notify_func)(MV_PVOID, enum Module_Event, struct mod_notif_param *);
-	domain_base *base;
-	MV_U16 report_id = 0xffff;
-
-	if (core->state != CORE_STATE_STARTED) return;
-
-	base = get_device_by_id(root->lib_dev, dev_id);
-	if (base == NULL) {
-		MV_ASSERT(MV_FALSE);
-		return;
-		goto core_notify_device_hotplug_done;
-	}
-
-	if (plugin == MV_TRUE) {
-		report_id = base->id;
-
-		if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-			if (generate_event == MV_TRUE)
-				core_generate_event(core, EVT_ID_HD_ONLINE,
-					base->id, SEVERITY_INFO, 0, NULL ,0);
-		} else {
-			if(base->type != BASE_TYPE_DOMAIN_ENCLOSURE)
-				if (generate_event == MV_TRUE)
-					core_generate_event(core, EVT_ID_HD_ONLINE,
-						base->id, SEVERITY_INFO, 0, NULL ,0);
-		}
-	} else {
-		report_id = base->id;
-
-		if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-			if (generate_event == MV_TRUE)
-				core_generate_event(core, EVT_ID_HD_OFFLINE,
-					base->id, SEVERITY_WARNING, 0, NULL ,0);
-		} else {
-			if(base->type != BASE_TYPE_DOMAIN_ENCLOSURE)
-				if (generate_event == MV_TRUE)
-					core_generate_event(core, EVT_ID_HD_OFFLINE,
-						base->id, SEVERITY_WARNING, 0, NULL ,0);
-		}
-	}
-
-core_notify_device_hotplug_done:
-
-	CORE_PRINT(("%s device %d.\n",
-		plugin? "plugin" : "unplug",
-		report_id));
-
-	HBA_GetUpperModuleNotificationFunction(core, &upper_layer, &notify_func);
-
-	param.lo = base->TargetID;
-	param.hi = base->LUN;
-	param.param_count = 0;
-
-	notify_func(upper_layer,
-		plugin ? EVENT_DEVICE_ARRIVAL : EVENT_DEVICE_REMOVAL,
-		&param);
-}
-
-MV_U16 core_add_timer(MV_PVOID core, MV_U32 seconds,
-	MV_VOID (*routine) (MV_PVOID, MV_PVOID),
-	MV_PVOID context1, MV_PVOID context2)
-{
-	MV_U16 timer_id =
-		Timer_AddRequest(core, seconds*2, routine, context1, context2);
-	MV_DASSERT(timer_id != NO_CURRENT_TIMER);
-	return timer_id;
-}
-
-MV_VOID core_cancel_timer(MV_PVOID core, MV_U16 timer)
-{
-	Timer_CancelRequest(core, timer);
-}
-
-MV_VOID core_generate_error_event(MV_PVOID core_p, MV_Request *req)
-{
-	core_extension *core = core_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *dev = (domain_device *)get_device_by_id(&core->lib_dev,
-		req->Device_Id);
-	MV_U32 params[MAX_EVENT_PARAMS];
-	MV_PU8 sense;
-	MV_U8 sense_key;
-
-        if(req->Sense_Info_Buffer == NULL) {
-                if (HBA_CheckIsFlorence(core)) {
-                        params[0] = req->Cdb[0];
-                        params[1] = 0xFF;
-                        params[2] = req->Scsi_Status;
-                        params[3] = 0;
-
-		        core_generate_event(core, EVT_ID_HD_SC_ERROR, dev->base.id,
-	                        SEVERITY_INFO, 4, params, 0);
-                }
-		return;
-        }
-	sense = (MV_PU8)req->Sense_Info_Buffer;
-	sense_key = sense[2] & 0x0f;
-
-        if (!HBA_CheckIsFlorence(core)) {
-	        if ((sense_key == SCSI_SK_NO_SENSE) ||
-	                (sense_key == SCSI_SK_UNIT_ATTENTION) ||
-	                (sense_key == SCSI_SK_NOT_READY) ||
-	                (sense_key == SCSI_SK_ILLEGAL_REQUEST))
-	                return;
-        }
-
-	params[0] = req->Cdb[0];
-	params[1] = sense[2];
-	params[2] = sense[12];
-	params[3] = sense[13];
-
-	core_generate_event(core, EVT_ID_HD_SC_ERROR, dev->base.id,
-	        SEVERITY_INFO, 4, params, 0x1e);
-}
-
-MV_U32 List_Get_Count(List_Head * head)
-{
-	List_Head *pPos;
-	MV_U32 count = 0;
-
-	LIST_FOR_EACH(pPos, head) {
-		count++;
-	}
-	return count;
-}
-
-MV_PVOID core_map_data_buffer(MV_Request *req)
-{
-	sg_map(req);
-	return req->Data_Buffer;
-}
-
-MV_VOID core_unmap_data_buffer(MV_Request *req)
-{
-	sg_unmap(req);
-}
-
-MV_U8
-core_check_duplicate_device(pl_root *root,
-	domain_device *dev)
-{
-	core_extension  *core = (core_extension *)root->core;
-	domain_base     *tmp_base;
-	domain_device   *tmp_dev;
-	MV_U16          dev_id;
-
-	if (U64_COMPARE_U32(dev->WWN, 0) == 0) {
-		CORE_PRINT(("Device WWN is 0. Not checking duplicate.\n"));
-		return MV_FALSE;
-	}
-
-	for (dev_id = 0; dev_id < MAX_ID; dev_id++) {
-		if (dev_id == dev->base.id)
-			continue;
-
-		tmp_base = get_device_by_id(&core->lib_dev, dev_id);
-
-		if (tmp_base == NULL)
-			continue;
-
-		if (tmp_base->type != BASE_TYPE_DOMAIN_DEVICE)
-			continue;
-
-		tmp_dev = (domain_device*)tmp_base;
-
-		if (U64_COMPARE_U64(dev->WWN, tmp_dev->WWN) == 0)
-			return MV_TRUE;
-	}
-
-	return MV_FALSE;
-}
-
-MV_U32
-core_check_outstanding_req(MV_PVOID core_p)
-{
-        core_extension *core = (core_extension *)core_p;
-        domain_base *base;
-        MV_U32 result = 0;
-        MV_U16 dev_id;
-
-        for (dev_id = 0; dev_id < MAX_ID; dev_id++) {
-                base = get_device_by_id(&core->lib_dev, dev_id);
-                if (base == NULL)
-                        continue;
-                result += base->outstanding_req;
-        }
-
-        return result;
-}
-
-/*
- * core_wideport_load_balance_asic_phy_map
- *
- * This function returns the asic phy map to use to send a frame to a device.
- * The phy maps returned are of round robin per SAS device, and that SAS
- * device will use the same phy for all commands. STP devices should not
- * use software load balance as hardware will balance the register sets used.
- */
-MV_U8
-core_wideport_load_balance_asic_phy_map(domain_port *port, domain_device *dev)
-{
-	MV_U8 phy_map;
-	MV_U8 asic_phy_map = port->asic_phy_map;
-	domain_base *base = &dev->base;
-	if (BASE_TYPE_DOMAIN_DEVICE != base->type)
-		return asic_phy_map;
-
-	if ((dev->curr_phy_map & asic_phy_map) != 0) return dev->curr_phy_map;
-
-	if (asic_phy_map == 0) return asic_phy_map;
-
-	phy_map = port->curr_phy_map << 1;
-	if (phy_map > asic_phy_map || phy_map == 0)
-		phy_map = (MV_U8)MV_BIT(ossw_ffs(asic_phy_map));
-	while (phy_map <= asic_phy_map) {
-		if (phy_map & asic_phy_map) {
-			port->curr_phy_map = phy_map;
-			dev->curr_phy_map = phy_map;
-			return phy_map;
-		}
-		phy_map <<= 1;
-	}
-
-	MV_DASSERT(MV_FALSE);
-
-	return asic_phy_map;
-}
--- a/drivers/scsi/vanir/core/core/core_util.h
+++ /dev/null
@@ -1,117 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef CORE_UTIL_H
-#define CORE_UTIL_H
-
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_protocol.h"
-#include "hba_timer.h"
-
-MV_VOID staggered_spin_up_handler(domain_base * base, MV_PVOID tmp);
-MV_U32 core_spin_up_get_cached_memory_quota(MV_U16 max_io);
-MV_LPVOID get_core_mmio(pl_root *root);
-MV_PVOID core_get_handler(pl_root *root, MV_U8 handler_id);
-
-/*
- * init state machine related
- * a. core_queue_init_entry with core_init_entry_done
- *    queue domain_base as the member
- * b. core_append_init_request will queue MV_Request
- *    which generated by init state machine
- */
-MV_VOID core_queue_init_entry(pl_root *root, MV_PVOID base_ext,
-	MV_BOOLEAN start_init);
-MV_VOID core_init_entry_done(pl_root *root, domain_port *port,
-	domain_base *base);
-MV_VOID core_append_init_request(pl_root *root, MV_Request *req);
-
-/*
- * error handling related
- * a. core_queue_error_req and core_complete_error_req
- *    for the original error request
- * b. core_queue_eh_req
- *    for error handling request
- */
-MV_VOID core_queue_error_req(pl_root *root, MV_Request *req, MV_BOOLEAN new_error);
-MV_VOID core_complete_error_req(pl_root *root, MV_Request *req, MV_U8 status);
-MV_VOID core_queue_eh_req(pl_root *root, MV_Request *req);
-
-/*
- * normal request
- */
-MV_VOID core_append_request(pl_root *root, MV_Request *req);
-MV_VOID core_push_running_request_back(pl_root *root, MV_Request *req);
-MV_VOID core_append_high_priority_request(pl_root *root, MV_Request *req);
-
-MV_VOID core_notify_device_hotplug(pl_root *root, MV_BOOLEAN plugin,
-	MV_U16 dev_id, MV_U8 generate_event);
-MV_VOID core_generate_error_event(MV_PVOID core_p, MV_Request *req);
-
-MV_Request *core_split_large_request(pl_root *root, MV_Request *large_req);
-
-#define CORE_REQUEST_TIME_OUT_SECONDS	15
-#define CORE_REQ_INIT_TIMEOUT		15
-#define CORE_INQUIRE_TIME_OUT_SECONDS	5
-#define CORE_REQ_FLORENCE_INIT_TIMEOUT	30
-MV_U16 core_add_timer(MV_PVOID core, MV_U32 seconds,
-	MV_VOID (*routine) (MV_PVOID, MV_PVOID),
-	MV_PVOID context1, MV_PVOID context2);
-
-MV_VOID core_cancel_timer(MV_PVOID core, MV_U16 timer);
-
-#define core_sleep_millisecond     HBA_SleepMillisecond
-#define core_sleep_microsecond     HBA_SleepMicrosecond
-
-MV_U32 List_Get_Count(List_Head * head);
-
-#define core_generate_event(ext, eid, did, slv, pc, ptr, tran)                 \
-        {                                                                      \
-                struct mod_notif_param param = {ptr, 0, 0, eid, did, slv, pc,  \
-                                                0, NULL, tran};                \
-                HBA_ModuleNotification(ext, EVENT_LOG_GENERATED, &param);      \
-        }
-#define core_generate_event_with_sense(ext, eid, did, slv, pc, ptr,            \
-                                        senselength, psense)                   \
-	{                                                                      \
-                struct mod_notif_param param = {ptr, 0, 0, eid, did, slv, pc,  \
-                                                senselength, psense};          \
-                HBA_ModuleNotification(ext, EVENT_LOG_GENERATED, &param);      \
-        }
-
-extern MV_U16 mv_debug_mode;
-#define CORE_PLAIN_DPRINT(_x_)        do {if (CORE_DEBUG_INFO & mv_debug_mode)\
-        MV_DPRINT(_x_);\
-        } while (0)
-#define CORE_DPRINT(_x_)        do {if (CORE_DEBUG_INFO & mv_debug_mode)\
-	{MV_DPRINT(("CORE: %s ", __FUNCTION__));\
-	MV_DPRINT(_x_);}\
-	} while (0)
-
-#define CORE_PRINT(_x_)        do {if (CORE_DEBUG_INFO & mv_debug_mode)\
-		{if (GENERAL_DEBUG_INFO & mv_debug_mode) \
-		{CORE_DPRINT(_x_);} else\
-		{MV_PRINT("CORE:  ");\
-		MV_PRINT _x_;} }\
-	} while (0)
-
-MV_PVOID core_map_data_buffer(MV_Request *req);
-MV_VOID core_unmap_data_buffer(MV_Request *req);
-MV_U8  core_check_duplicate_device(pl_root *root, domain_device *dev);
-MV_U32 core_check_outstanding_req(MV_PVOID core_p);
-MV_U8
-core_wideport_load_balance_asic_phy_map(domain_port *port,
-	domain_device *dev);
-
-#endif /* CORE_UTIL_H */
--- a/drivers/scsi/vanir/core/pl/core_gpio.c
+++ /dev/null
@@ -1,725 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_manager.h"
-#include "core_gpio.h"
-#include "com_error.h"
-#include "core_util.h"
-
-MV_U32 sgpio_read_pci_register(MV_PVOID core_p, MV_U8 reg_address) {
-	MV_U32 reg=0;
-	reg = MV_PCI_READ_DWORD( core_p, reg_address );
-	return reg;
-}
-
-void sgpio_write_pci_register(MV_PVOID core_p, MV_U8 reg_address, MV_U32 reg_value) {
-	MV_PCI_WRITE_DWORD( core_p, reg_value, reg_address );
-	return;
-}
-
-void sgpio_sendsgpioframe(MV_PVOID this, MV_U32 value)
-{
-	core_extension * pCore=(core_extension *)this;
-	MV_U32 sgpio_ctl_reg;
-	MV_U32 sgpio_data_out_l;
-	MV_U32 sgpio_data_out_h;
-
-	sgpio_ctl_reg = sgpio_read_pci_register( pCore, SGPIO_Control );
-	sgpio_data_out_l = sgpio_read_pci_register( pCore, SGPIO_Data_Out_L );
-	sgpio_data_out_h = sgpio_read_pci_register( pCore, SGPIO_Data_Out_H );
-
-	sgpio_write_pci_register( pCore, SGPIO_Data_Out_L, value);
-	sgpio_write_pci_register( pCore, SGPIO_Data_Out_H, 0x0);
-	sgpio_data_out_l = sgpio_read_pci_register( pCore, SGPIO_Data_Out_L );
-	sgpio_data_out_h = sgpio_read_pci_register( pCore, SGPIO_Data_Out_H );
-
-	sgpio_ctl_reg = 0xe0;
-	sgpio_ctl_reg |= SGPIO_START_BIT;
-	sgpio_write_pci_register( pCore, SGPIO_Control, sgpio_ctl_reg);
-	sgpio_ctl_reg = sgpio_read_pci_register( pCore, SGPIO_Control );
-
-	core_sleep_millisecond(pCore, 500);
-
-	sgpio_ctl_reg &= ~SGPIO_START_BIT;
-	sgpio_write_pci_register( pCore, SGPIO_Control, sgpio_ctl_reg);
-	sgpio_ctl_reg = sgpio_read_pci_register( pCore, SGPIO_Control );
-}
-
-void sgpio_initialize( MV_PVOID this ) {
-	core_extension * core=(core_extension *)this;
-	pl_root *root=NULL;
-	domain_port *port;
-	domain_device * device;
-	MV_U32 sgpio_init_reg=0;
-	MV_LPVOID mmio = core->mmio_base;
-	MV_U32 tmp, reg_config0, reg_config1, dword_offset0, dword_offset1;
-	MV_U32 count,sgpio;
-	MV_U8 i, device_cnt0, device_cnt1, j;
-
-	if ((core->device_id == DEVICE_ID_6440) || (core->device_id == DEVICE_ID_6445)
-                        ||(core->device_id == 0x6320) ||(core->device_id == DEVICE_ID_6340))
-	{
-		sgpio_init_reg = sgpio_read_pci_register( core, SGPIO_Init );
-		CORE_PRINT(("*  SGPIO_InitReg before initialization = 0x%x \n", sgpio_init_reg ));
-		sgpio_init_reg &= ~SGPIO_Mode;
-		sgpio_write_pci_register(core, SGPIO_Init, sgpio_init_reg );
-		core_sleep_microsecond(core, 1);
-		sgpio_init_reg |= SGPIO_Mode;
-
-		/*
-		*The following lines setup the desired clock frequency in SGPIO_Control register
-		* before clk is started by SGPIO_Init.  Allowing clk to switch frequency during run-time
-		* could result in writing on the wrong edge of the clk.
-		*/
-		sgpio_write_pci_register( core, SGPIO_Init, sgpio_init_reg );
-		sgpio_init_reg = sgpio_read_pci_register( core, SGPIO_Init );
-		CORE_PRINT(("*  SGPIO_InitReg after initialization = 0x%x \n", sgpio_init_reg ));
-	}	else if ((core->device_id == DEVICE_ID_6480)  || (core->device_id == DEVICE_ID_6485)
-		||(core->device_id ==0x8180))	{
-		/*####### disable first ######*/
-		/* sgpio 0 registers */
-		mv_sgpio_read_register(mmio, SGPIO_REG_ADDR(0,SGPIO_REG_CONFIG0), reg_config0);
-		reg_config0 &=~(SGPIO_EN|BLINK_GEN_EN_B|BLINK_GEN_EN_A|AUTO_BIT_LEN);
-		mv_sgpio_write_register(mmio, SGPIO_REG_ADDR(0,SGPIO_REG_CONFIG0), reg_config0);
-
-		/* sgpio 1 registers */
-		mv_sgpio_read_register(mmio, SGPIO_REG_ADDR(1,SGPIO_REG_CONFIG0), reg_config1);
-		reg_config1 &=~(SGPIO_EN|BLINK_GEN_EN_B|BLINK_GEN_EN_A|AUTO_BIT_LEN);
-		mv_sgpio_write_register(mmio, SGPIO_REG_ADDR(1,SGPIO_REG_CONFIG0), reg_config1);
-
-		/*####### enable SGPIO mode in PCI config register ######*/
-		sgpio_write_pci_register(core, 0x44, 0x80);
-
-		/*###### setting Drive Source ######*/
-		device_cnt0=0;
-		dword_offset0=0;
-		device_cnt1=0;
-		dword_offset1=0;
-
-		root = &core->roots[core->chip_info->start_host];
-		for(j=0;j<core->chip_info->n_phy;j++){
-			port = &root->ports[j];
-			if(port->device_count==0)
-			continue;
-			LIST_FOR_EACH_ENTRY_TYPE(device, &port->device_list, domain_device, base.queue_pointer){
-				if(device==NULL)
-				break;
-				if(device->base.parent->type == BASE_TYPE_DOMAIN_PORT){
-				device->connection |= DC_SGPIO;
-				if (j < 4){
-					/* sgpio 0 */
-					mv_sgpio_read_register(mmio,
-						SGPIO_REG_ADDR(0,SGPIO_REG_DRV_SRC_BASE + device_cnt0 - dword_offset0),
-						tmp);
-					tmp &=~(0xff<<(dword_offset0*8));
-
-					mv_sgpio_write_register(mmio,
-						SGPIO_REG_ADDR(0,SGPIO_REG_DRV_SRC_BASE + device_cnt0 - dword_offset0),
-						tmp+(DRV_SRC_PHY(0,j)<<(dword_offset0*8)));
-
-					device->sgpio_drive_number = j;
-					device_cnt0++;
-					dword_offset0++;
-					dword_offset0%=4;
-				}else{
-					/* sgpio 1 */
-					mv_sgpio_read_register(mmio,
-						SGPIO_REG_ADDR(1,SGPIO_REG_DRV_SRC_BASE + device_cnt1 - dword_offset1),
-						tmp);
-					tmp &=~(0xff<<(dword_offset1*8));
-
-					mv_sgpio_write_register(mmio,
-						SGPIO_REG_ADDR(1,SGPIO_REG_DRV_SRC_BASE + device_cnt1 - dword_offset1),
-						tmp+(DRV_SRC_PHY(0,j)<<(dword_offset1*8)));
-
-					device->sgpio_drive_number = j;
-					device_cnt1++;
-					dword_offset1++;
-					dword_offset1%=4;
-				}
-
-				}
-			}
-		}
-
-		/*##### setting control mode #####*/
-		/* sgpio 0 */
-		mv_sgpio_write_register(mmio,
-			SGPIO_REG_ADDR(0,SGPIO_REG_CONTROL),
-			((SDOUT_MD_AUTO<<SDOUT_MD_OFFSET)+SDIN_MD_ONCE));
-
-		/* sgpio 1 */
-		mv_sgpio_write_register(mmio,
-			SGPIO_REG_ADDR(1,SGPIO_REG_CONTROL),
-			((SDOUT_MD_AUTO<<SDOUT_MD_OFFSET)+SDIN_MD_ONCE));
-		/*##### setting blink speeds #####*/
-		/* sgpio 0 */
-		mv_sgpio_read_register(mmio,
-			SGPIO_REG_ADDR(0, SGPIO_REG_CONFIG1),
-			tmp);
-		tmp &= ~(BLINK_LOW_TM_A | BLINK_HI_TM_A);
-		tmp |= 0x11;
-		mv_sgpio_write_register(mmio,
-			SGPIO_REG_ADDR(0, SGPIO_REG_CONFIG1),
-			tmp);
-
-		/* sgpio 1 */
-		mv_sgpio_read_register(mmio,
-			SGPIO_REG_ADDR(1, SGPIO_REG_CONFIG1),
-			tmp);
-		tmp &= ~(BLINK_LOW_TM_A | BLINK_HI_TM_A);
-		tmp |= 0x11;
-		mv_sgpio_write_register(mmio,
-			SGPIO_REG_ADDR(1, SGPIO_REG_CONFIG1),
-			tmp);
-
-		/*##### enable int #####*/
-
-		/* sgpio 0 */
-		mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(0,SGPIO_REG_INT_ENABLE),
-		(MANUAL_MD_REP_DONE|SDIN_DONE));
-
-		/* sgpio 1 */
-		mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(1,SGPIO_REG_INT_ENABLE),
-		(MANUAL_MD_REP_DONE|SDIN_DONE));
-
-		/*##### re-enable SGPIO #####*/
-
-		/* sgpio 0 */
-		reg_config0 |=(SGPIO_EN|BLINK_GEN_EN_B|BLINK_GEN_EN_A);
-		/* SGPIO stream needs minimum 12 bits*/
-		if (device_cnt0 < 4)
-			device_cnt0 = 4;
-		reg_config0 += (device_cnt0*3)<<AUTO_BIT_LEN_OFFSET;
-
-		mv_sgpio_write_register(mmio,
-			SGPIO_REG_ADDR(0,SGPIO_REG_CONFIG0),
-			reg_config0);
-
-		/* sgpio 1 */
-		reg_config1 |=(SGPIO_EN|BLINK_GEN_EN_B|BLINK_GEN_EN_A);
-		/* SGPIO stream needs minimum 12 bits*/
-		if (device_cnt1 < 4)
-			device_cnt1 = 4;
-		reg_config1 += (device_cnt1*3)<<AUTO_BIT_LEN_OFFSET;
-
-		mv_sgpio_write_register(mmio,
-			SGPIO_REG_ADDR(1,SGPIO_REG_CONFIG0),
-			reg_config1);
-
-		CORE_PRINT(("*  SGPIO_InitReg after initialization \n" ));
-
-		for(sgpio=0;sgpio<2;sgpio++){
-			count=0;
-			for(i=0;i<100;i++) {
-				mv_sgpio_read_register(mmio,
-				SGPIO_REG_ADDR(sgpio,SGPIO_REG_INT_CAUSE),
-				tmp);
-
-				if(tmp&SDIN_DONE){
-					CORE_PRINT(("SGPIO%d count:%d, interrupt:%d\n",sgpio,count,tmp));
-					if (count==0) {
-						mv_sgpio_read_register(mmio,
-						SGPIO_REG_ADDR(sgpio,SGPIO_REG_INT_CAUSE),
-						tmp);
-						mv_sgpio_write_register(mmio,
-						SGPIO_REG_ADDR(sgpio,SGPIO_REG_INT_CAUSE),
-						tmp);
-						mv_sgpio_write_register(mmio,
-						SGPIO_REG_ADDR(sgpio,SGPIO_REG_CONTROL),
-						((SDOUT_MD_AUTO<<SDOUT_MD_OFFSET)+SDIN_MD_ONCE));
-					} else {
-						sgpio_isr(this,sgpio);
-						break;
-					}
-					count++;
-				} else
-					core_sleep_millisecond(root->core, 10);
-					if (i == 10) {
-						CORE_PRINT(("no back plan connected\n"));
-					break;
-				}
-			}
-		}
-	}
-
-	if (IS_VANIR(core) || core->device_id == DEVICE_ID_948F) {
-		/* sgpio 0 registers */
-		mv_sgpio_read_register(mmio, SGPIO_REG_ADDR(0,SGPIO_REG_CONFIG0), reg_config0);
-		reg_config0 &=~(SGPIO_EN|BLINK_GEN_EN_B|BLINK_GEN_EN_A|AUTO_BIT_LEN);
-		mv_sgpio_write_register(mmio, SGPIO_REG_ADDR(0,SGPIO_REG_CONFIG0), reg_config0);
-
-		/* sgpio 1 registers */
-		mv_sgpio_read_register(mmio, SGPIO_REG_ADDR(1,SGPIO_REG_CONFIG0), reg_config1);
-		reg_config1 &=~(SGPIO_EN|BLINK_GEN_EN_B|BLINK_GEN_EN_A|AUTO_BIT_LEN);
-		mv_sgpio_write_register(mmio, SGPIO_REG_ADDR(1,SGPIO_REG_CONFIG0), reg_config1);
-
-		/*####### enable SGPIO mode in PCI config register ######*/
-		tmp = MV_REG_READ_DWORD(mmio, 0x10104) & ~0x00000300L;
-		tmp |= 0x00000100L;
-		MV_REG_WRITE_DWORD(mmio, 0x10104, tmp);
-		/*###### setting Drive Source ######*/
-		device_cnt0=0;
-		dword_offset0=0;
-		device_cnt1=0;
-		dword_offset1=0;
-
-		for (i = core->chip_info->start_host;i < (core->chip_info->start_host + core->chip_info->n_host); i++) {
-			root = &core->roots[i];
-			for(j = 0;j < MAX_PORT_PER_PL; j++) {
-				port = &root->ports[j];
-				if (port->device_count==0)
-					continue;
-				LIST_FOR_EACH_ENTRY_TYPE(device, &port->device_list, domain_device, base.queue_pointer) {
-					if (device==NULL)
-						break;
-					if (device->base.parent->type == BASE_TYPE_DOMAIN_PORT) {
-						device->connection |= DC_SGPIO;
-						mv_sgpio_read_register(mmio,
-						        SGPIO_REG_ADDR(i,SGPIO_REG_DRV_SRC_BASE + device_cnt0 - dword_offset0),
-						        tmp);
-						tmp &=~(0xff<<(dword_offset0*8));
-						mv_sgpio_write_register(mmio,
-							SGPIO_REG_ADDR(i,SGPIO_REG_DRV_SRC_BASE + device_cnt0 - dword_offset0),
-						tmp+(DRV_SRC_PHY(0,i)<<(dword_offset0*8)));
-						device->sgpio_drive_number = j;
-						device_cnt0++;
-						dword_offset0++;
-						dword_offset0 %= 4;
-
-					}
-				}
-			}
-		}
-
-	/*##### setting control mode #####*/
-	/* sgpio 0 */
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(0,SGPIO_REG_CONTROL),
-		((SDOUT_MD_AUTO<<SDOUT_MD_OFFSET)+SDIN_MD_ONCE));
-
-	/* sgpio 1 */
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(1,SGPIO_REG_CONTROL),
-		((SDOUT_MD_AUTO<<SDOUT_MD_OFFSET)+SDIN_MD_ONCE));
-	/*##### setting blink speeds #####*/
-	/* sgpio 0 */
-	mv_sgpio_read_register(mmio,
-		SGPIO_REG_ADDR(0, SGPIO_REG_CONFIG1),
-		tmp);
-	tmp &= ~(BLINK_LOW_TM_A | BLINK_HI_TM_A);
-	tmp |= 0x11;
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(0, SGPIO_REG_CONFIG1),
-		tmp);
-
-	/* sgpio 1 */
-	mv_sgpio_read_register(mmio,
-		SGPIO_REG_ADDR(1, SGPIO_REG_CONFIG1),
-		tmp);
-	tmp &= ~(BLINK_LOW_TM_A | BLINK_HI_TM_A);
-	tmp |= 0x11;
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(1, SGPIO_REG_CONFIG1),
-		tmp);
-
-	/*##### enable int #####*/
-
-	/* sgpio 0 */
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(0,SGPIO_REG_INT_ENABLE),
-		(MANUAL_MD_REP_DONE|SDIN_DONE));
-
-	/* sgpio 1 */
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(1,SGPIO_REG_INT_ENABLE),
-		(MANUAL_MD_REP_DONE|SDIN_DONE));
-
-	/*##### re-enable SGPIO #####*/
-
-	/* sgpio 0 */
-	reg_config0 |=(SGPIO_EN|BLINK_GEN_EN_B|BLINK_GEN_EN_A);
-	/* SGPIO stream needs minimum 12 bits*/
-	if (device_cnt0 < 4)
-		device_cnt0 = 4;
-	reg_config0 += (device_cnt0*3)<<AUTO_BIT_LEN_OFFSET;
-
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(0,SGPIO_REG_CONFIG0),
-		reg_config0);
-
-	/* sgpio 1 */
-	reg_config1 |=(SGPIO_EN|BLINK_GEN_EN_B|BLINK_GEN_EN_A);
-	/* SGPIO stream needs minimum 12 bits*/
-	if (device_cnt1 < 4)
-		device_cnt1 = 4;
-	reg_config1 += (device_cnt1*3)<<AUTO_BIT_LEN_OFFSET;
-
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(1,SGPIO_REG_CONFIG0),
-		reg_config1);
-
-	CORE_PRINT(("*  SGPIO_InitReg after initialization \n" ));
-
-	for (sgpio=0;sgpio<2;sgpio++) {
-		count=0;
-		for (i=0;i<100;i++) {
-			mv_sgpio_read_register(mmio,
-			SGPIO_REG_ADDR(sgpio,SGPIO_REG_INT_CAUSE),
-			tmp);
-
-			if (tmp & SDIN_DONE) {
-				CORE_PRINT(("SGPIO%d count:%d, interrupt:%d\n",sgpio,count,tmp));
-				if (count == 0) {
-					mv_sgpio_read_register(mmio,
-					SGPIO_REG_ADDR(sgpio,SGPIO_REG_INT_CAUSE),
-					tmp);
-					mv_sgpio_write_register(mmio,
-					SGPIO_REG_ADDR(sgpio,SGPIO_REG_INT_CAUSE),
-					tmp);
-					mv_sgpio_write_register(mmio,
-					SGPIO_REG_ADDR(sgpio,SGPIO_REG_CONTROL),
-					((SDOUT_MD_AUTO<<SDOUT_MD_OFFSET)+SDIN_MD_ONCE));
-				} else {
-					sgpio_isr(this,sgpio);
-					break;
-				}
-					count++;
-			} else
-				core_sleep_millisecond(root->core, 10);
-				if(i==10){
-					CORE_PRINT(("no back plan connected\n"));
-					break;
-				}
-			}
-		}
-        }
-}
-
-void sgpio_smpreq_callback(core_extension * core, PMV_Request req)
-{
-	MV_U8 port_id;
-	smp_response *smp_resp;
-	domain_port * port;
-	struct _domain_sgpio * sgpio_result = &core->lib_gpio.sgpio_result;
-	smp_resp= (smp_response *)req->Scratch_Buffer;
-
-	switch (smp_resp->function) {
-	case READ_GPIO_REGISTER:
-		CORE_PRINT(("Read GPIO Register Response: \n"));
-		CORE_PRINT(("Data In High 0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-		smp_resp->response.ReadGPIORegister.Data_In_High[0],
-		smp_resp->response.ReadGPIORegister.Data_In_High[1],
-		smp_resp->response.ReadGPIORegister.Data_In_High[2],
-		smp_resp->response.ReadGPIORegister.Data_In_High[3],
-		smp_resp->response.ReadGPIORegister.Data_In_High[4],
-		smp_resp->response.ReadGPIORegister.Data_In_High[5],
-		smp_resp->response.ReadGPIORegister.Data_In_High[6],
-		smp_resp->response.ReadGPIORegister.Data_In_High[7]));
-		CORE_PRINT(("Data In Low 0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-		smp_resp->response.ReadGPIORegister.Data_In_Low[0],
-		smp_resp->response.ReadGPIORegister.Data_In_Low[1],
-		smp_resp->response.ReadGPIORegister.Data_In_Low[2],
-		smp_resp->response.ReadGPIORegister.Data_In_Low[3],
-		smp_resp->response.ReadGPIORegister.Data_In_Low[4],
-		smp_resp->response.ReadGPIORegister.Data_In_Low[5],
-		smp_resp->response.ReadGPIORegister.Data_In_Low[6],
-		smp_resp->response.ReadGPIORegister.Data_In_Low[7]));
-		break;
-	case WRITE_GPIO_REGISTER:
-		CORE_PRINT(("Receive Write GPIO Register Response: \n"));
-		break;
-	}
-	MV_CopyMemory(sgpio_result, req->Scratch_Buffer, sizeof(req->Scratch_Buffer) );
-}
-
-void sgpio_smprequest_read(pl_root * root, PMV_Request req)
-{
-	smp_request*smp_req;
-	PMV_SG_Table sg_table;
-
-	if( req == NULL ){
-		CORE_DPRINT(("ERROR: No more free internal requests. Request aborted.\n"));
-		return;
-	}
-
-	sg_table = &req->SG_Table;
-	/* Prepare identify ATA task */
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SMP;
-	req->Device_Id = 0xFFFF;
-	req->Data_Transfer_Length = sizeof(smp_request);
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function=READ_GPIO_REGISTER;
-	smp_req->smp_frame_type=SMP_REQUEST_FRAME;
-	core_unmap_data_buffer(req);
-	req->Completion = (void(*)(MV_PVOID,PMV_Request))sgpio_smpreq_callback;
-
-	/* Make SG table */
-	SGTable_Init(sg_table, 0);
-
-	/* Send this internal request */
-	Core_ModuleSendRequest(root->core, req);
-}
-
-void sgpio_smprequest_write(core_extension * core)
-{
-	PMV_Request req = get_intl_req_resource(&core->roots[core->chip_info->start_host],sizeof(smp_request));
-	smp_request*smp_req;
-	PMV_SG_Table sg_table;
-
-	if(req == NULL ){
-		CORE_DPRINT(("ERROR: No more free internal requests. Request aborted.\n"));
-		return;
-	}
-	sg_table = &req->SG_Table;
-
-	/* Prepare identify ATA task */
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SMP;
-	req->Device_Id = 0xFFFF;
-	req->Cmd_Initiator = core;
-	req->Data_Transfer_Length = sizeof(smp_request);
-	smp_req=(smp_request *)core_map_data_buffer(req);
-	smp_req->function=WRITE_GPIO_REGISTER;
-	smp_req->smp_frame_type=SMP_REQUEST_FRAME;
-	core_unmap_data_buffer(req);
-	req->Completion = (void(*)(MV_PVOID,PMV_Request))sgpio_smpreq_callback;
-
-	/* Make SG table */
-	SGTable_Init(sg_table, 0);
-
-	/* Send this internal request */
-	Core_ModuleSendRequest(core, req);
-}
-
-void sgpio_process_sdin(MV_PVOID this, MV_U32 sgpio)
-{
-	core_extension * core=(core_extension *)this;
-	MV_LPVOID mmio = core->mmio_base;
-	MV_U32 tmp;
-
-	CORE_DPRINT(("sgpio: sdin done :"));
-	{
-		mv_sgpio_read_register(mmio,
-			SGPIO_REG_ADDR(sgpio,SGPIO_REG_RAW_DIN0 ),
-			tmp);
-		CORE_DPRINT((" 0x%08x",tmp));
-
-		if(((tmp&SDIN_BACK_PLAN_PRESENCE_PATTERN)==SDIN_BACK_PLAN_PRESENCE_PATTERN)
-		&&((tmp&SDIN_DATA_MASK)!=SDIN_DATA_MASK)){
-			CORE_DPRINT(("back plan present\n"));
-			if((tmp&SDIN_DEVICE0_PRESENCE_PATTERN)==SDIN_DEVICE0_PRESENCE_PATTERN){
-				CORE_DPRINT(("device 0 presence\n"));
-
-			}
-			if((tmp&SDIN_DEVICE1_PRESENCE_PATTERN)==SDIN_DEVICE1_PRESENCE_PATTERN)
-			CORE_DPRINT(("device 1 presence\n"));
-			if((tmp&SDIN_DEVICE2_PRESENCE_PATTERN)==SDIN_DEVICE2_PRESENCE_PATTERN)
-			CORE_DPRINT(("device 2 presence\n"));
-			if((tmp&SDIN_DEVICE3_PRESENCE_PATTERN)==SDIN_DEVICE3_PRESENCE_PATTERN)
-			CORE_DPRINT(("device 3 presence\n"));
-		} else
-			CORE_PRINT(("no back plan connected\n"));
-	}
-	CORE_DPRINT(("\n"));
-	/* sgpio 0 */
-	mv_sgpio_write_register(mmio,
-	SGPIO_REG_ADDR(sgpio,SGPIO_REG_CONTROL),
-	((SDOUT_MD_AUTO<<SDOUT_MD_OFFSET)+SDIN_MD_ONCE));
-
-}
-
-void sgpio_isr(MV_PVOID this, MV_U32 sgpio)
-{
-	core_extension * core=(core_extension *)this;
-	MV_LPVOID mmio = core->mmio_base;
-	MV_U32 tmp;
-	void (*callback)(MV_PVOID PortExtension, MV_PVOID context) = core->lib_gpio.sgpio_callback;
-
-	mv_sgpio_read_register(mmio,
-		SGPIO_REG_ADDR(sgpio,SGPIO_REG_INT_CAUSE),
-		tmp);
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(sgpio,SGPIO_REG_INT_CAUSE),
-		tmp);
-
-	if(tmp&SDIN_DONE)
-		sgpio_process_sdin(this,sgpio);
-	else if(tmp&MANUAL_MD_REP_DONE)
-		callback(this, core->lib_gpio.sgpio_cb_context);
-}
-
-MV_U8 sgpio_send_sdout(MV_PVOID This, MV_U8 byte_len, MV_PVOID pbuffer,
-	void (*call_back)(MV_PVOID PortExtension, MV_PVOID context),	MV_PVOID cb_context)
-{
-	core_extension * pCore=(core_extension *)This;
-	MV_LPVOID mmio = pCore->mmio_base;
-	MV_U32 tmp,cntrl_tmp;
-	MV_U8 i,j;
-
-	if(pCore->lib_gpio.sgpio_sdout_inuse)
-		return(MV_FALSE);
-
-	mv_sgpio_read_register(mmio,
-	SGPIO_REG_ADDR(0,SGPIO_REG_CONTROL),
-	cntrl_tmp);
-	cntrl_tmp &=~(SDIN_MD_MASK|SDOUT_MD_MASK|MANUAL_MD_REP_CNT_MASK);
-	mv_sgpio_write_register(mmio,
-	SGPIO_REG_ADDR(0,SGPIO_REG_CONTROL),
-	cntrl_tmp+(SCLK_HALT<<SDOUT_MD_OFFSET)+SDIN_MD_ONCE);
-
-	pCore->lib_gpio.sgpio_sdout_inuse=1;
-	pCore->lib_gpio.sgpio_callback=call_back;
-	pCore->lib_gpio.sgpio_cb_context=cb_context;
-	for (i = 0; (i < (byte_len/4)) && (i < MAX_SDOUT_DWORD); i++) {
-		tmp=*((MV_U32 *)pbuffer + i*4);
-		mv_sgpio_write_register(mmio,
-		        SGPIO_REG_ADDR(0,SGPIO_REG_RAW_DOUT0 + i*4),
-		        tmp);
-	}
-	if ((i<MAX_SDOUT_DWORD) && (byte_len%4)) {
-		mv_sgpio_read_register(mmio,
-			SGPIO_REG_ADDR(0,SGPIO_REG_RAW_DOUT0 + i*4),
-			tmp);
-	for(j=0;j<(byte_len%4);j++)
-		tmp |= (*((MV_U8 *)pbuffer + i*4 + j)) << (j*8);
-		mv_sgpio_write_register(mmio,
-			SGPIO_REG_ADDR(0,SGPIO_REG_RAW_DOUT0 + i*4),
-			tmp);
-	}
-
-	mv_sgpio_read_register(mmio,
-		SGPIO_REG_ADDR(0,SGPIO_REG_CONFIG0),
-		tmp);
-	tmp &= ~MANUAL_BIT_LEN;
-	tmp |= (byte_len*8)<<MANUAL_BIT_LEN_OFFSET;
-	mv_sgpio_write_register(mmio,
-		SGPIO_REG_ADDR(0,SGPIO_REG_CONFIG0),
-		tmp);
-	cntrl_tmp +=
-	(SDOUT_MD_MAUTO<<SDOUT_MD_OFFSET)+
-	SDIN_MD_ONCE+
-	(1<<MAUNAL_MD_REP_CNT_OFFSET);
-	mv_sgpio_write_register(mmio,
-	SGPIO_REG_ADDR(0,SGPIO_REG_CONTROL),
-	cntrl_tmp);
-
-	return MV_TRUE;
-}
-
-MV_U8 sgpio_read_register(MV_PVOID this, MV_U8  reg_type, MV_U8 reg_indx,
-		MV_U8    reg_cnt, MV_PVOID pbuffer)
-{
-	core_extension * pCore=(core_extension *)this;
-	MV_LPVOID mmio = pCore->mmio_base;
-	MV_U32 tmp;
-	MV_U8 i;
-
-	switch(reg_type){
-		case REG_TYPE_CONFIG:
-			MV_CopyMemory(pbuffer, (MV_PVOID)&pCore->lib_gpio.sgpio_config, sizeof(struct _sgpio_config_reg));
-			break;
-		case REG_TYPE_RX:
-			for (i = 0; (i < reg_cnt) && (i < MAX_SDIN_DWORD); i++) {
-				mv_sgpio_read_register(mmio,
-				SGPIO_REG_ADDR(0,SGPIO_REG_RAW_DIN0 + (reg_indx + i)*4),
-				tmp);
-				*((MV_U32 *)pbuffer + i*4)=tmp;
-			}
-			break;
-		case REG_TYPE_RX_GP:
-			for (i = 0; (i < reg_cnt) && ((reg_indx + i) < (MAX_SDIN_DWORD+1)); i++) {
-				if((reg_indx+i)==0)
-					*(MV_U32 *)(pbuffer)=0;
-				else {
-					mv_sgpio_read_register(mmio,
-						SGPIO_REG_ADDR(0,
-						SGPIO_REG_RAW_DIN0 + (reg_indx + i -1)*4),
-						tmp);
-					*((MV_U32 *)pbuffer + i*4)=tmp;
-				}
-			}
-			break;
-		case REG_TYPE_TC:
-			for(i = 0; (i < reg_cnt) && (i < MAX_AUTO_CTRL_DWORD); i++) {
-			mv_sgpio_read_register(mmio,
-			SGPIO_REG_ADDR(0,SGPIO_REG_DRV_CTRL_BASE + (reg_indx + i)*4),
-			tmp);
-			*((MV_U32 *)pbuffer + i*4)=tmp;
-			}
-			break;
-		case REG_TYPE_TC_GP:
-			for (i = 0; (i < reg_cnt) && (i < MAX_SDOUT_DWORD); i++) {
-				if((reg_indx+i)==0){
-					mv_sgpio_read_register(mmio,
-						SGPIO_REG_ADDR(0,SGPIO_REG_CONTROL),
-						tmp);
-					tmp &=~(MANUAL_MD_SLOAD_PTRN_MASK|AUTO_MD_SLOAD_PTRN_MASK);
-					tmp|=((*((MV_U8 *)pbuffer+3))<<16 )+
-					((*((MV_U8 *)pbuffer+3))<<20 );
-					mv_sgpio_write_register(mmio,
-						SGPIO_REG_ADDR(0,SGPIO_REG_CONTROL),tmp);
-				} else {
-					mv_sgpio_read_register(mmio,
-						SGPIO_REG_ADDR(0,SGPIO_REG_RAW_DOUT0 + (reg_indx + i -1)*4),
-						tmp);
-					*((MV_U32 *)pbuffer + i*4) = tmp;
-				}
-			}
-			break;
-		default:
-			return(MV_FALSE);
-	}
-	return(MV_TRUE);
-}
-
-MV_U8 sgpio_write_register( MV_PVOID this,MV_U8 reg_type,MV_U8 reg_indx,
-	MV_U8 reg_cnt, MV_PVOID pbuffer)
-{
-	core_extension * pCore=(core_extension *)this;
-	MV_LPVOID mmio = pCore->mmio_base;
-	MV_U32 tmp;
-	MV_U8 i;
-
-	switch (reg_type) {
-		case REG_TYPE_CONFIG:
-			MV_CopyMemory((MV_PVOID)&pCore->lib_gpio.sgpio_config, pbuffer, sizeof(struct _sgpio_config_reg));
-			break;
-		case REG_TYPE_TC:
-			for (i = 0; (i < reg_cnt) && (i < MAX_AUTO_CTRL_DWORD); i++) {
-				tmp = *((MV_U32 *)pbuffer + i*4);
-				mv_sgpio_write_register(mmio,
-					SGPIO_REG_ADDR(0,SGPIO_REG_DRV_CTRL_BASE + (reg_indx + i)*4), tmp);
-			}
-			break;
-		case REG_TYPE_TC_GP:
-			for(i=0;(i<reg_cnt)&&(i<MAX_SDOUT_DWORD);i++){
-				mv_sgpio_read_register(mmio,
-					SGPIO_REG_ADDR(0,SGPIO_REG_RAW_DOUT0 + (reg_indx + i)*4),
-					tmp);
-				*((MV_U32 *)pbuffer + i*4) = tmp;
-			}
-			break;
-		case REG_TYPE_RX:
-			default:
-		return(MV_FALSE);
-	}
-	return(MV_TRUE);
-}
--- a/drivers/scsi/vanir/core/pl/core_gpio.h
+++ /dev/null
@@ -1,210 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef CORE_GPIO_H
-#define CORE_GPIO_H
-
-#include "mv_config.h"
-struct _domain_sgpio
-{
-	MV_U8 Data_In_Low[8];
-	MV_U8 Data_In_High[8];
-	MV_U32 CRC;
-};
-
-struct _sgpio_config_reg {
-	MV_U8 sup_dev_cnt;
-	MV_U8 gp_reg_cnt:4;
-	MV_U8 cfg_reg_cnt:3;
-	MV_U8 sgpio_enable:1;
-	MV_U8 version:4;
-	MV_U8 rsrv_byte2_bit4_7:4;
-	MV_U8 rsrv_byte3;
-};
-
-typedef struct _lib_gpio {
-	struct _domain_sgpio		sgpio_result;
-	MV_PVOID			sgpio_cb_context;
-	struct _sgpio_config_reg	sgpio_config;
-	void                            (*sgpio_callback)(MV_PVOID extension, MV_PVOID context);
-	MV_U8                           sgpio_sdout_inuse;
-	MV_U8	                        reserved3[3];
-} lib_gpio;
-
-/*
-========================================================================
-SGPIO Defines - Register reside in PCI Configuration
-========================================================================
-*/
-
-/* SGPIO Registers that are available */
-#define Vendor_Unique2           0x44
-#define SGPIO_Init               Vendor_Unique2
-#define SGPIO_Control            0x64
-#define SGPIO_Data_Out_L         0x68
-#define SGPIO_Data_Out_H         0x6C
-#define SGPIO_Data_In_L          0x70
-#define SGPIO_Data_In_H          0x74
-
-/* For setting SGPIO mode during initializaton */
-#define SGPIO_Mode               (1<<7)
-
-/* For setting SGPIO_Control Register */
-#define SGPIO_TRANSFER_LEN(x)    ((x-1)<<4)
-#define SGPIO_SELECT_SPEED(x)    (x<<1)
-#define SGPIO_START_BIT          (1<<0)
-
-/* Clk Frequency availabe for SGPIO */
-#define SGPIO_1KHz               0
-#define SGPIO_10KHz              1
-#define SGPIO_50KHz              2
-#define SGPIO_100KHz             3
-
-
-/*
-========================================================================
-SGPIO Defines
-========================================================================
-*/
-
-/* SGPIO Registers that are available
-   These are accessed through Vendor Specific Port Registers */
-#define SGPIO_REG_CONFIG0            0x000
-#define SGPIO_REG_CONFIG1            0x004
-#define SGPIO_REG_CONFIG2            0x008
-#define SGPIO_REG_CONTROL            0x00C
-#define SGPIO_REG_INT_CAUSE          0x010
-#define SGPIO_REG_INT_ENABLE         0x014
-#define SGPIO_REG_DRV_SRC_BASE       0x020
-#define SGPIO_REG_DRV_CTRL_BASE      0x038
-#define SGPIO_REG_RAW_DOUT0          0x050
-#define SGPIO_REG_RAW_DOUT1          0x054
-#define SGPIO_REG_RAW_DOUT2          0x058
-#define SGPIO_REG_RAW_DIN0           0x05C
-#define SGPIO_REG_RAW_DIN1           0x060
-#define SGPIO_REG_RAW_DIN2           0x064
-/* x=0(SGPIO0) or 1(SGPIO1) , y= SGPIO_REG_CONFIG0,... */
-#define SGPIO_REG_ADDR(x,y)          (y + x*0x100)
-
-/* SGPIO_REG_CONFIG0 */
-#define SGPIO_EN           (1<<0)
-#define BLINK_GEN_EN_B     (1<<1)
-#define BLINK_GEN_EN_A     (1<<2)
-#define INVRT_SCLK         (1<<3)
-#define INVRT_SLOAD        (1<<4)
-#define INVRT_SDOUT        (1<<5)
-#define NEG_SLOAD_EDGE     (1<<6)
-#define NEG_SDOUT_EDGE     (1<<7)
-#define POS_SDIN_EDGE      (1<<8)
-#define MANUAL_BIT_LEN     0x00ff0000
-#define AUTO_BIT_LEN       0xff000000
-#define MANUAL_BIT_LEN_OFFSET 16
-#define AUTO_BIT_LEN_OFFSET 24
-
-/* SGPIO_REG_CONFIG1 */
-#define BLINK_LOW_TM_A     0x0000000f
-#define BLINK_HI_TM_A      0x000000f0
-#define BLINK_LOW_TM_B     0x00000f00
-#define BLINK_HI_TM_B      0x0000f000
-#define MAX_ACTV_ON        0x000f0000
-#define FORCE_ACTV_OFF     0x00f00000
-#define STRCH_ACTV_ON      0x0f000000
-#define STRCH_ACTV_OFF     0xf0000000
-
-/* SGPIO_REG_CONFIG2 */
-  #define SCLK_SELECT        0x000000ff
-
-/* SGPIO_REG_CONTROL */
-#define SDIN_MD_MASK              (0x3<<0)
-#define SDOUT_MD_MASK             (0x3<<2)
-#define MANUAL_MD_REP_CNT_MASK    (0xfff<<4)
-#define MANUAL_MD_SLOAD_PTRN_MASK (0xf<<16)
-#define AUTO_MD_SLOAD_PTRN_MASK   (0xf<<20)
-#define MAUNAL_MD_REP_CNT_OFFSET  4
-enum {
-        SCLK_HALT=0,
-        SDOUT_MD_MANUAL=1,
-        SDOUT_MD_AUTO=2,
-        SDOUT_MD_MAUTO=3,
-        SDIN_MD_ONCE=1,
-        SDIN_MD_CONT=2,
-};
-#define SDOUT_MD_OFFSET      2
-
-/* SGPIO_REG_INT_CAUSE */
-#define SDIN_DONE            (1<<0)
-#define MANUAL_MD_REP_DONE   (1<<1)
-#define MANUAL_MD_REP_REMAIN (0xfff<<8)
-
-/* SGPIO_REG_DRV_SRC_BASE */
-#define DRV_SRC_PHY0_A        0x00
-#define DRV_SRC_SAS_PORT0_A   0x08
-#define DRV_SRC_SAS_PORT4_A   0x10
-#define DRV_SRC_PM_PHY0_A     DRV_SRC_SAS_PORT0_A
-
-  /* x=0(A) or 1(B), y=phy number 0..3 */
-#define DRV_SRC_PHY(x,y)              (DRV_SRC_PHY0_A+y+x*4)
-  /* x=0(A) or 1(B), y=phy number 0..3 */
-#define DRV_SRC_SAS_PORT0_3(x,y)      (DRV_SRC_SAS_PORT0_A+y+x*4)
-  /* x=0(A) or 1(B), y=phy number 4..7 */
-#define DRV_SRC_SAS_PORT4_7(x,y)      (DRV_SRC_SAS_PORT4_A+y+x*4)
-  /* x=0(A) or 1(B), y=phy number 0..3, z=PM port id */
-#define DRV_SRC_PM_PHY(x,y,z)         (DRV_SRC_PM_PHY0_A+y+(x*4)+(z*8))
-
-/* SGPIO_REG_DRV_CTRL_BASE */
-#define MAX_AUTO_CTRL_DWORD 6
-
-#define DRV_ACTV_LED_MASK  (0x7<<5)
-#define DRV_LOC_LED_MASK   (0x3<<3)
-#define DRV_ERR_LED_MASK   0x7
-#define DRV_ACTV_LED_OFFSET 5
-#define DRV_LOC_LED_OFFSET  3
-#define DRV_ERR_LED_OFFSET  0
-enum {
-	LED_LOW           = 0,
-	LED_HI            = 1,
-	LED_BLINK_A       = 2,
-	LED_BLINK_INVRT_A = 3,
-	LED_BLINK_SOF     = 4,
-	LED_BLINK_EOF     = 5,
-	LED_BLINK_B       = 6,
-	LED_BLINK_INVRT_B = 7,
-};
-
-/* SGPIO_REG_RAW_DIN0 SGPIO_REG_RAW_DOUT0 */
-#define MAX_SDIN_DWORD 3
-#define MAX_SDOUT_DWORD 3
-#define SDIN_BACK_PLAN_PRESENCE_PATTERN  	0x492
-#define SDIN_DATA_MASK						0xFFF
-#define SDIN_DEVICE0_PRESENCE_PATTERN		0x3
-#define SDIN_DEVICE1_PRESENCE_PATTERN		0x18
-#define SDIN_DEVICE2_PRESENCE_PATTERN		0xC0
-#define SDIN_DEVICE3_PRESENCE_PATTERN		0x600
-/* application */
-
-enum {
-	REG_TYPE_CONFIG = 0,
-	REG_TYPE_RX = 1,
-	REG_TYPE_RX_GP = 2,
-	REG_TYPE_TC = 3,
-	REG_TYPE_TC_GP = 4,
-};
-
-void sgpio_initialize(MV_PVOID This);
-void sgpio_isr(MV_PVOID This, MV_U32 sgpio);
-MV_U8 Core_SGPIO_set_LED(MV_PVOID extension, MV_U16 device_id, MV_U8 light_type, MV_U8 light_behavior, MV_U8 flag);
-void sgpio_sendsgpioframe(MV_PVOID This, MV_U32 value);
-MV_U32 sgpio_read_pci_register(MV_PVOID core_p, MV_U8 reg_address);
-void sgpio_write_pci_register(MV_PVOID core_p, MV_U8 reg_address, MV_U32 reg_value);
-
-#endif
--- a/drivers/scsi/vanir/core/pl/core_rmw_flash.c
+++ /dev/null
@@ -1,174 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_manager.h"
-#include "core_internal.h"
-#include "core_util.h"
-#include "hba_inter.h"
-
-#include "core_spi.h"
-
-
-MV_U8
-core_init_rmw_flash_memory(MV_PVOID core_p,
-        lib_resource_mgr *rsrc, MV_U16 max_io)
-{
-	core_extension  *core = (core_extension *)core_p;
-	HBA_Extension   *hba = (PHBA_Extension)HBA_GetModuleExtension(core, MODULE_HBA);
-	AdapterInfo     *adapter;
-	MV_U32          item_size;
-	MV_PU8          vir;
-
-	item_size = sizeof(AdapterInfo);
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL) return MV_FALSE;
-	core->lib_flash.adapter_info = (MV_PVOID)vir;
-	adapter = (AdapterInfo *)vir;
-
-	adapter->bar[FLASH_BAR_NUMBER] = hba->Base_Address[FLASH_BAR_NUMBER];
-	if (-1 == OdinSPI_Init(adapter)) {
-	        core->lib_flash.buf_ptr = NULL;
-	        core->lib_flash.buf_size = 0;
-	        core->lib_flash.success = MV_FALSE;
-	        CORE_DPRINT(("Flash init failed\n"));
-	        return MV_FALSE;
-	}
-	item_size = adapter->FlashSectSize;
-
-	vir = (MV_PU8)lib_rsrc_malloc_cached(rsrc, item_size);
-	if (vir == NULL)
-		return MV_FALSE;
-	core->lib_flash.buf_ptr = vir;
-	core->lib_flash.buf_size = item_size;
-	core->lib_flash.success = MV_TRUE;
-       return MV_TRUE;
-}
-
-MV_U32
-core_rmw_flash_get_cached_memory_quota(MV_U16 max_io)
-{
-	MV_U32          size = 0;
-
-	size += sizeof(AdapterInfo);
-	size += FLASH_SECTOR_SIZE;
-	return size;
-}
-
-MV_U32
-core_rmw_flash_get_dma_memory_quota(MV_U16 max_io)
-{
-        return 0;
-}
-
-MV_U8
-core_rmw_read_flash(MV_PVOID core_p,
-        MV_U32 addr,
-        MV_PU8 data,
-        MV_U32 size)
-{
-        core_extension  *core = (core_extension *)core_p;
-        HBA_Extension   *hba = (PHBA_Extension)HBA_GetModuleExtension(core, MODULE_HBA);
-        AdapterInfo	*adapter_info;
-        MV_PU8          vir;
-
-        adapter_info = (AdapterInfo *)core->lib_flash.adapter_info;
-        if (core->lib_flash.success == MV_FALSE) {
-                if (-1 == OdinSPI_Init(adapter_info)) {
-                        CORE_DPRINT(("Flash init failed\n"));
-                        return MV_FALSE;
-                }
-                vir = (MV_PU8)lib_rsrc_malloc_cached(&core->lib_rsrc,
-                                adapter_info->FlashSectSize);
-                if (vir == NULL) return MV_FALSE;
-                core->lib_flash.buf_ptr = vir;
-                core->lib_flash.buf_size = adapter_info->FlashSectSize;
-                core->lib_flash.success = MV_TRUE;
-        }
-
-	OdinSPI_ReadBuf(adapter_info, addr, data, size);
-       return MV_TRUE;
-}
-
-MV_U8
-core_rmw_write_flash(MV_PVOID core_p,
-		MV_U32 addr,
-		MV_PU8 data,
-		MV_U32 size)
-{
-	MV_U32 data_tmp_addr, buf_tmp_addr;
-	MV_U32 data_tmp_size, buf_tmp_size;
-	MV_U32 end, data_offset, buf_offset;
-	MV_PU8 tmp_buf;
-	core_extension  *core = (core_extension *)core_p;
-	HBA_Extension   *hba = (PHBA_Extension)HBA_GetModuleExtension(core, MODULE_HBA);
-	AdapterInfo	*adapter_info;
-	MV_PU8          vir;
-
-	adapter_info = (AdapterInfo *)core->lib_flash.adapter_info;
-	if (core->lib_flash.success == MV_FALSE) {
-		if (-1 == OdinSPI_Init(adapter_info)) {
-			CORE_DPRINT(("Flash init failed\n"));
-			return MV_FALSE;
-		}
-		vir = (MV_PU8)lib_rsrc_malloc_cached(&core->lib_rsrc,
-		adapter_info->FlashSectSize);
-		if (vir == NULL)
-			return MV_FALSE;
-		core->lib_flash.buf_ptr = vir;
-		core->lib_flash.buf_size = adapter_info->FlashSectSize;
-		core->lib_flash.success = MV_TRUE;
-	}
-	tmp_buf = core->lib_flash.buf_ptr;
-	if ((data == NULL) || (tmp_buf == NULL))
-		return MV_FALSE;
-
-	data_tmp_addr = addr;
-	data_tmp_size = 0;
-	data_offset = 0;
-	end = addr + size;
-
-	buf_tmp_size = adapter_info->FlashSectSize;
-	while (data_tmp_addr + data_tmp_size < end) {
-		data_tmp_addr += data_tmp_size;
-		buf_tmp_addr = (data_tmp_addr / buf_tmp_size) * buf_tmp_size;
-
-		data_tmp_size = MV_MIN(buf_tmp_addr + buf_tmp_size, end)
-		- data_tmp_addr;
-
-		data_offset = data_tmp_addr - addr;
-		if (data_offset == 0)
-			buf_offset = data_tmp_addr - buf_tmp_addr;
-		else
-			buf_offset = 0;
-
-		OdinSPI_ReadBuf(adapter_info, buf_tmp_addr,
-		tmp_buf, buf_tmp_size);
-
-		MV_CopyMemory(&tmp_buf[buf_offset],
-		&data[data_offset], data_tmp_size);
-
-		if (OdinSPI_SectErase(adapter_info, data_tmp_addr)
-			== -1) {
-			CORE_DPRINT(("Flash Erase Failed\n"));
-			return MV_FALSE;
-		}
-
-		OdinSPI_WriteBuf(adapter_info, buf_tmp_addr,
-		tmp_buf, buf_tmp_size);
-	}
-
-	MV_DASSERT(data_tmp_addr + data_tmp_size == end);
-	return MV_TRUE;
-}
--- a/drivers/scsi/vanir/core/pl/core_rmw_flash.h
+++ /dev/null
@@ -1,44 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef _CORE_RMW_FLASH
-#define _CORE_RMW_FLASH
-#include "mv_config.h"
-
-/*******************************************************************************
-* Structs and defines                                                          *
-*******************************************************************************/
-enum {
-	FLASH_SECTOR_SIZE       = 0x10000,
-};
-typedef struct _lib_rmw_flash {
-	MV_PVOID        adapter_info;
-	MV_U8           success;
-	MV_U8           reserved[3];
-	MV_U32          buf_size;
-	MV_PU8          buf_ptr;
-} lib_rmw_flash;
-
-/*******************************************************************************
-* Function Prototypes                                                          *
-*******************************************************************************/
-MV_U8 core_init_rmw_flash_memory(MV_PVOID core_p,
-        lib_resource_mgr *rsrc, MV_U16 max_io);
-MV_U32 core_rmw_flash_get_cached_memory_quota(MV_U16 max_io);
-MV_U32 core_rmw_flash_get_dma_memory_quota(MV_U16 max_io);
-MV_U8 core_rmw_read_flash(MV_PVOID core_p, MV_U32 addr,
-        MV_PU8 data, MV_U32 size);
-MV_U8 core_rmw_write_flash(MV_PVOID core_p, MV_U32 addr,
-        MV_PU8 data, MV_U32 size);
-
-#endif
--- a/drivers/scsi/vanir/core/pl/core_spi.h
+++ /dev/null
@@ -1,210 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined( _CORE_SPI_H_ )
-#define _CORE_SPI_H_
-
-#include "core_header.h"
-
-#   define SPI_DBG( _X_ )       MV_DPRINT( _X_ )
-#   define EEPROM_DBG( _X_ )    MV_DPRINT( _X_ )
-
-#define AT25F2048               0x0101
-#define AT25DF041A               0x0102
-#define AT25DF021               0x0103
-#define PM25LD010               0x2110
-
-#define MX25L2005               0x0201
-#define MX25L4005               0x0202
-#define MX25L8005               0x0203
-#define W25X40					0x0301
-#define EN25F20					0x0401
-#define SST25VF040B					0x0501
-
-
-#define SPI_CTRL_REG            0xc0
-#define SPI_CMD_REG             0xc4
-#define SPI_DATA_REG            0xc8f
-
-#define SPI_INS_WREN            0
-#define SPI_INS_WRDI            1
-#define SPI_INS_RDSR            2
-#define SPI_INS_WRSR            3
-#define SPI_INS_READ            4
-#define SPI_INS_PROG            5
-#define SPI_INS_SERASE          6
-#define SPI_INS_CERASE          7
-#define SPI_INS_RDID            8
-#define SPI_INS_PTSEC            9
-#define SPI_INS_UPTSEC            10
-#define SPI_INS_RDPT            11
-
-#define DEFAULT_SPI_FLASH_SIZE          256L * 1024
-#define DEFAULT_SPI_FLASH_SECT_SIZE     64L * 1024
-
-typedef struct _AdapterInfo AdapterInfo;
-struct _AdapterInfo
-{
-    MV_U32      flags;
-    MV_U16      devId;
-    MV_U32      classCode;
-    MV_U8       revId;
-    MV_U8       bus;
-    MV_U8       devFunc;
-    void*       bar[6];
-    MV_U32      ExpRomBaseAddr;
-    MV_U8       version;
-    MV_U8       subVersion;
-
-    MV_U16      FlashID;
-    MV_U32      FlashSize;
-    MV_U32      FlashSectSize;
-};
-
-typedef union
-{
-    struct
-    {
-        MV_U32 low;
-        MV_U32 high;
-    } parts;
-    MV_U8       b[8];
-    MV_U16      w[4];
-    MV_U32      d[2];
-} SAS_ADDRESS, *PSAS_ADDRESS;
-
-#define MAX_BOOTDEVICE_SUPPORTED        8
-
-#pragma pack(1)
-typedef struct _HBA_Info_Main
-{
-
-	MV_U8 signature[4];	//offset 0x0h,4bytes,structure signature
-
-	MV_U16 image_size;	//offset 0x4h,2bytes,512bytes per indecate romsize
-
-	MV_U16 option_rom_checksum;	//offset 0x6h,2 bytes,16BIT CHECKSUM OPTIONROM caculation
-
-	MV_U8  major;	//offset 0x8h,1 byte,BIOS major version
-
-	MV_U8  minor;	//offset 0x9h,1byte,BIOS minor version
-
-	MV_U8  oem_num;	//offset 0xah,1byte,OEM number
-
-	MV_U8  build_version;	//offset 0xbh,1byte,build number
-
-	MV_U32  hba_flag;	/* offset 0xch,4 bytes,
-				     HBA flags:  refers to HBA_FLAG_XX
-					bit 0   --- HBA_FLAG_BBS_ENABLE
-					bit 1   --- HBA_FLAG_SUPPORT_SMART
-					bit 2   --- HBA_FLAG_ODD_BOOT
-					bit 3   --- HBA_FLAG_INT13_ENABLE
-					bit 4   --- HBA_FLAG_ERROR_STOP
-					bit 5   --- HBA_FLAG_ERROR_PASS
-					bit 6   --- HBA_FLAG_SILENT_MODE_ENABLE
-				*/
-
-	MV_U16 boot_order[MAX_BOOTDEVICE_SUPPORTED];	//offset 0x10h,2bytes*Max_bootdevice_supported,BootOrder[0] = 3,means the first bootable device is device 3
-
-	MV_U8 bootablecount;	//bootable device count
-
-	MV_U8  serialnum[20];	//offset 0x20h,20bytes,serial number
-
-	MV_U8  chip_revision;	//offset 0x34h,1 byte,chip revision
-
-	SAS_ADDRESS   sas_address[MAX_NUMBER_IO_CHIP*MAX_PORT_PER_PL];	//offset ,8bytes*MAX_PHYSICAL_PORT_NUMBER
-
-	MV_U8  phy_rate[MAX_NUMBER_IO_CHIP*MAX_PORT_PER_PL];	//offset ,1byte*MAX_PHYSICAL_PORT_NUMBER,0:  1.5 GB/s, 1: 3.0 GB/s
-
-	MV_U32  bootdev_wwn[8]; //this is initial as 0xFFFF,FFFF
-
-	MV_U8  reserve[97];
-
-	MV_U8  checksum;
-}HBA_Info_Main, *pHBA_Info_Main;
-#pragma pack()
-
-int
-OdinSPI_SectErase
-(
-    AdapterInfo *pAI,
-    MV_U32      addr
-);
-int
-OdinSPI_ChipErase
-(
-    AdapterInfo *pAI
-);
-int
-OdinSPI_Write
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U32      Data
-);
-int
-OdinSPI_WriteBuf
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U8       *Data,
-    MV_U32      Count
-);
-int
-OdinSPI_Read
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U8       *Data,
-    MV_U8       Size
-);
-int
-OdinSPI_ReadBuf
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U8       *Data,
-    MV_U32      Count
-);
-int
-OdinSPI_RMWBuf
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U8       *Data,
-    MV_U32      Count,
-    MV_U8       *Buf
-);
-int
-OdinSPI_Init
-(
-    AdapterInfo *pAI
-);
-int
-LoadHBAInfo
-(
-    AdapterInfo *pAI,
-    HBA_Info_Main *pHBAInfo
-);
-
-int
-OdinSPI_Write_SST
-(
-    AdapterInfo *pAI,
-    MV_I32      Addr,
-    MV_U8*      Data,
-    MV_U32      Count
-);
-
-
-#endif
--- a/drivers/scsi/vanir/core/pl/spi_hal.h
+++ /dev/null
@@ -1,35 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined( _SPI_HAL_H_ )
-#define _SPI_HAL_H_
-
-#include "core_header.h"
-
-#define FMemR8( addr, off  )         MV_REG_READ_BYTE( addr, off )
-#define FMemR16( addr, off )         MV_REG_READ_WORD( addr, off )
-#define FMemR32( addr, off )         MV_REG_READ_DWORD( addr, off )
-#define FMemW8( addr, off, var )     MV_REG_WRITE_BYTE( addr, off, var )
-#define FMemW16( addr, off, var )    MV_REG_WRITE_WORD( addr, off, var )
-#define FMemW32( addr, off, var )    MV_REG_WRITE_DWORD( addr, off, var )
-#define MV_IOR8( addr, off )         MV_IO_READ_BYTE( addr, off )
-#define MV_IOR16( addr, off )        MV_IO_READ_WORD( addr, off )
-#define MV_IOR32( addr, off )        MV_IO_READ_DWORD( addr, off )
-#define MV_IOW8( addr, off, data )   MV_IO_WRITE_BYTE( addr, off, data )
-#define MV_IOW16( addr, off, data )  MV_IO_WRITE_WORD( addr, off, data )
-#define MV_IOW32( addr, off, data )  MV_IO_WRITE_DWORD( addr, off, data )
-
-#   define DelayMSec(_X_)        HBA_SleepMillisecond(NULL, _X_)
-#   define DelayUSec(_X_)        HBA_SleepMicrosecond(NULL, _X_)
-
-#endif
--- a/drivers/scsi/vanir/core/pm/core_pm.c
+++ /dev/null
@@ -1,689 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_protocol.h"
-#include "core_sat.h"
-#include "core_pm.h"
-#include "core_util.h"
-#include "core_device.h"
-#include "core_error.h"
-#include "core_resource.h"
-#include "core_sata.h"
-#include "core_manager.h"
-
-extern MV_VOID sata_prepare_command_header(MV_Request *req,
-	mv_command_header *cmd_header, mv_command_table *cmd_table,
-	MV_U8 tag, MV_U8 pm_port);
-extern MV_VOID sata_prepare_command_table(MV_Request *req,
-	mv_command_table *cmd_table, ata_taskfile *taskfile, MV_U8 pm_port);
-extern MV_Request *sata_make_soft_reset_req(domain_port *port,
-	domain_device *device, MV_BOOLEAN srst, MV_BOOLEAN is_port_reset,
-	MV_PVOID callback);
-extern MV_VOID sata_set_up_new_device(pl_root *root, domain_port *port,
-	domain_device *device);
-extern void get_new_and_update_base_id(pl_root *root,domain_base *base);
-
-MV_VOID sata_pm_disk_unplug(domain_pm *pm, MV_U8 unplug_index)
-{
-	domain_device *device = pm->devices[unplug_index];
-	pl_root *root = pm->base.root;
-	MV_U32 reg;
-
-	pal_set_down_disk(root, device, MV_TRUE);
-}
-
-MV_VOID pm_wait_for_spinup(MV_PVOID pm_p, MV_PVOID tmp)
-{
-	domain_pm *pm = (domain_pm *)pm_p;
-
-	pm->state = PM_STATE_SPIN_UP_DONE;
-	core_queue_init_entry(pm->base.root, &pm->base, MV_FALSE);
-}
-
-MV_VOID pm_init_req_callback(MV_PVOID ext, MV_Request *req)
-{
-	pl_root *root = (pl_root *)ext;
-	domain_pm *pm;
-	domain_device *device;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	saved_fis *fis;
-	MV_U32 fis1=0, fis2=0;
-	MV_U16 timer_id;
-
-	if ((req->Cdb[2] == CDB_CORE_SOFT_RESET_1) ||
-		(req->Cdb[2] == CDB_CORE_SOFT_RESET_0)) {
-		device = (domain_device *)get_device_by_id(
-			root->lib_dev, req->Device_Id);
-		pm = device->pm;
-
-		if ((pm->status & PM_STATUS_DEVICE_PHY_RESET) &&
-			(req->Cdb[2] == CDB_CORE_SOFT_RESET_0)) {
-			pm->state = PM_STATE_ENABLE_ASYNOTIFY;
-			core_queue_init_entry(root, &pm->base, MV_FALSE);
-			return;
-		}
-
-		if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-			if (pm->status & PM_STATUS_HOT_PLUG) {
-				pm->state = PM_STATE_SIG_DONE;
-				core_queue_init_entry(root, &pm->base, MV_FALSE);
-			}
-			else {
-				core_handle_init_error(root, &device->base, req);
-			}
-			return;
-		}
-
-	} else {
-		pm = (domain_pm *)get_device_by_id(root->lib_dev, req->Device_Id);
-
-		if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-			core_handle_init_error(root, &pm->base, req);
-			return;
-		}
-	}
-
-	if ((pm->state != PM_STATE_ISSUE_SOFT_RESET_1) &&
-		(pm->state != PM_STATE_ISSUE_SOFT_RESET_0)) {
-
-		fis = (saved_fis *)ctx->received_fis;
-		if (fis == NULL) MV_ASSERT(MV_FALSE);
-		fis1 = fis->dw4;
-		fis2 = fis->dw2;
-	}
-	switch (pm->state) {
-	case PM_STATE_RESET_DONE:
-		if (fis1 <= CORE_MAX_DEVICE_PER_PM)
-			pm->num_ports = (MV_U8)fis1;
-		else
-			pm->num_ports = CORE_MAX_DEVICE_PER_PM;
-		pm->state = PM_STATE_READ_INFO_DONE;
-		break;
-	case PM_STATE_READ_INFO_DONE:
-		pm->vendor_id = ((MV_U8)fis1) | (((MV_U8)fis2) << 8);
-		pm->device_id = (MV_U16)(fis2 >> 8);
-		pm->state = PM_STATE_READ_ID_DONE;
-		if((pm->vendor_id==0x11ab)&&(pm->device_id==0x4140)){
-			if(pm->num_ports==0x05){
-				pm->num_ports=0x04;
-				}
-			pm->state = PM_STATE_QRIGA_WORKAROUND;
-		}
-		break;
-	case PM_STATE_QRIGA_WORKAROUND:
-		pm->state = PM_STATE_READ_ID_DONE;
-		break;
-	case PM_STATE_READ_ID_DONE:
-		pm->product_rev = (MV_U8)fis2;
-		if (fis1 & MV_BIT(3))
-			pm->spec_rev = 12;
-		else if (fis1 & MV_BIT(2))
-			pm->spec_rev = 11;
-		else if (fis1 & MV_BIT(1))
-			pm->spec_rev = 10;
-		else
-			pm->spec_rev = 0;
-		pm->state = PM_STATE_READ_REV_DONE;
-		break;
-	case PM_STATE_READ_REV_DONE:
-		pm->feature_enabled = (MV_U8)(fis1 | MV_BIT(3));
-		pm->state = PM_STATE_ENABLE_FEATURES;
-		break;
-	case PM_STATE_ENABLE_FEATURES:
-		pm->state = PM_STATE_CLEAR_ERROR_INFO;
-		break;
-	case PM_STATE_CLEAR_ERROR_INFO:
-		MV_DASSERT(pm->active_port == 0);
-		pm->state = PM_STATE_SPIN_UP_ALL_PORTS;
-		break;
-	case PM_STATE_SPIN_UP_ALL_PORTS:
-		pm->active_port++;
-		if (pm->active_port >= pm->num_ports) {
-			pm->active_port = 0;
-			timer_id = core_add_timer(root->core, 1, pm_wait_for_spinup, pm, NULL);
-			MV_ASSERT(timer_id != NO_CURRENT_TIMER);
-			return;
-		}
-		break;
-	case PM_STATE_SPIN_UP_DONE:
-		pm->active_port++;
-		if (pm->active_port >= pm->num_ports) {
-			pm->active_port = 0;
-			pm->retry_cnt = 100;
-			pm->srst_retry_cnt = 1;
-			pm->state = PM_STATE_PORT_CHECK_PHY_RDY;
-		}
-		break;
-	case PM_STATE_ENABLE_PM_PORT_1:
-		pm->state = PM_STATE_ENABLE_PM_PORT_0;
-		break;
-	case PM_STATE_ENABLE_PM_PORT_0:
-		pm->state = PM_STATE_PORT_CHECK_PHY_RDY;
-		break;
-	case PM_STATE_PORT_CHECK_PHY_RDY:
-		pm->sstatus = ((MV_U8)fis1) | (((MV_U8)fis2) << 8);
-		pm->base.port->phy->sata_signature = 0xFFFFFFFF;
-
-		if ((pm->sstatus & 0x00F) == 0x003) {
-			pm->state = PM_STATE_CLEAR_X_BIT;
-		} else {
-			if (pm->retry_cnt > 0) {
-				pm->retry_cnt--;
-				core_sleep_millisecond(root->core, 1);
-			} else {
-				/* done retrying, phy not ready, move to next port */
-				if(pm->srst_retry_cnt > 0){
-					pm->srst_retry_cnt--;
-					pm->state = PM_STATE_ENABLE_PM_PORT_1;
-					break;
-				}
-				pm->active_port++;
-				if (pm->active_port >= pm->num_ports) {
-					pm->active_port = 0;
-					pm->state = PM_STATE_DONE;
-				}
-			}
-		}
-		break;
-	case PM_STATE_CLEAR_X_BIT:
-		pm->state = PM_STATE_ISSUE_SOFT_RESET_1;
-
-		if (pm->devices[pm->active_port] == NULL) {
-			/* found a new device */
-			device = get_device_obj(root, root->lib_rsrc);
-			if (device == NULL) {
-				CORE_DPRINT(("no more free device\n"));
-				return;
-			}
-			sata_set_up_new_device(root, pm->base.port, device);
-			get_new_and_update_base_id(root,&device->base);
-			List_AddTail(&device->base.queue_pointer, &device->base.port->device_list);
-			device->base.port->device_count++;
-			pm->devices[pm->active_port] = device;
-			device->pm = pm;
-			device->pm_port = pm->active_port;
-			device->signature=pm->base.port->phy->sata_signature;
-			device->connection = DC_SERIAL | DC_ATA;
-
-			if ( (pm->sstatus & 0xF0) == 0x30 )
-				device->negotiated_link_rate = PHY_LINKRATE_6;
-			else if ( (pm->sstatus & 0xF0) == 0x20 )
-				device->negotiated_link_rate = PHY_LINKRATE_3;
-			else
-				device->negotiated_link_rate = PHY_LINKRATE_1_5;
-
-			if (pm->base.port->phy->sata_signature == 0xEB140101){
-				device->connection |= DC_ATAPI;
-				device->dev_type=DT_CD_DVD;
-			} else{
-				device->dev_type = DT_DIRECT_ACCESS_BLOCK;
-				}
-			device->base.parent = &pm->base;
-		}
-		break;
-	case PM_STATE_ISSUE_SOFT_RESET_1:
-		core_sleep_millisecond(root->core, 50);
-		pm->state = PM_STATE_ISSUE_SOFT_RESET_0;
-		break;
-	case PM_STATE_ISSUE_SOFT_RESET_0:
-		pm->state = PM_STATE_WAIT_SIG;
-
-		if (pm->base.port->phy->sata_signature == 0xEB140101){
-			pm->devices[pm->active_port]->connection |= DC_ATAPI;
-			pm->devices[pm->active_port]->dev_type=DT_CD_DVD;
-			}
-		break;
-	default:
-		CORE_DPRINT(("unknown state\n"));
-		return;
-	}
-
-	core_queue_init_entry(root, &pm->base, MV_FALSE);
-}
-
-MV_VOID pm_hot_plug_req_callback(MV_PVOID ext, MV_Request *req)
-{
-	pl_root *root = (pl_root *)ext;
-	domain_pm *pm = (domain_pm *)get_device_by_id(
-		root->lib_dev, req->Device_Id);
-    domain_device *device;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	saved_fis *fis;
-	MV_U32 fis1, fis2, tmp;
-	MV_U8 i;
-	MV_BOOLEAN plug_in;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		core_handle_init_error(root, &pm->base, req);
-		return;
-	}
-
-	fis = (saved_fis *)ctx->received_fis;
-	if (fis == NULL) MV_ASSERT(MV_FALSE);
-	fis1 = fis->dw4;
-	fis2 = fis->dw2;
-
-	switch (pm->state) {
-	case PM_STATE_DISABLE_ASYNOTIFY:
-		pm->state = PM_STATE_ENABLE_PM_PORT_1;
-		break;
-	case PM_STATE_ENABLE_PM_PORT_1:
-		pm->state = PM_STATE_ENABLE_PM_PORT_0;
-		break;
-	case PM_STATE_ENABLE_PM_PORT_0:
-		core_sleep_millisecond(root->core, 100);
-		pm->state = PM_STATE_PORT_CHECK_PHY_RDY;
-		break;
-	case PM_STATE_READ_GLOBAL_ERROR:
-		pm->global_serror = ((MV_U8)fis1) | (fis2 << 8);
-		for (i=0; i<pm->num_ports; i++) {
-			if (pm->global_serror & MV_BIT(i)) {
-				pm->active_port = i;
-				pm->global_serror &= ~MV_BIT(i);
-				break;
-			}
-		}
-		if (i == pm->num_ports) {
-			CORE_DPRINT(("pm error reg is empty. aborting hot plug\n"));
-			pm->state = PM_STATE_DONE;
-			core_init_entry_done(root, pm->base.port, &pm->base);
-			return;
-		}
-		pm->state = PM_STATE_READ_PORT_ERROR;
-		break;
-	case PM_STATE_READ_PORT_ERROR:
-		tmp = ((MV_U8)fis1) | (fis2 << 8);
-		if (!((tmp & PM_SERROR_PHYRDY_CHANGE) || (tmp & PM_SERROR_EXCHANGED))) {
-			CORE_DPRINT(("pm error reg not sdb. aborting hot plug\n"));
-			pm->state = PM_STATE_DONE;
-			core_init_entry_done(root, pm->base.port, &pm->base);
-			return;
-		}
-		plug_in = (pm->devices[pm->active_port] == NULL);
-		if (((tmp & PM_SERROR_COMM_WAKE) && !plug_in) ||
-			(!(tmp & PM_SERROR_COMM_WAKE) && plug_in)) {
-			CORE_DPRINT(("pm error reg comm_wake doesn't match.\n"));
-		}
-		pm->state = PM_STATE_CLEAR_PORT_ERROR;
-		break;
-	case PM_STATE_CLEAR_PORT_ERROR:
-		pm->state = PM_STATE_PORT_CHECK_PHY_RDY;
-		break;
-
-	case PM_STATE_PORT_CHECK_PHY_RDY:
-		pm->sstatus = ((MV_U8)fis1) | (((MV_U8)fis2) << 8);
-
-		if ((pm->sstatus & 0x00F) == 0x003) {
-			/* We always need to clear x bit
-			 * 1. If device exists and is device reset pm_init_req_callback will not make new dev
-			 * 2. If device does not exit and is plug in pm_init_req_callback will make new dev
-			 */
-			pm->state = PM_STATE_CLEAR_X_BIT;
-		} else {
-			if (pm->devices[pm->active_port] == NULL) {
-				CORE_DPRINT(("pm hot plug: phy is not rdy but no device \
-					exists on this port\n"));
-				if (pm->retry_cnt > 0) {
-					pm->retry_cnt--;
-					core_sleep_millisecond(root->core, 1);
-					break;
-				}
-			} else {
-				sata_pm_disk_unplug(pm, pm->active_port);
-			}
-			pm->state = PM_STATE_SIG_DONE;
-		}
-		break;
-	case PM_STATE_ENABLE_ASYNOTIFY:
-		pm->state = PM_STATE_SIG_DONE;
-		break;
-	}
-
-	core_queue_init_entry(root, &pm->base, MV_FALSE);
-}
-
-MV_VOID pm_hot_plug(domain_pm *pm)
-{
-	pm->state = PM_STATE_READ_GLOBAL_ERROR;
-	pm->status |= PM_STATUS_HOT_PLUG;
-	core_queue_init_entry(pm->base.root, &pm->base, MV_TRUE);
-}
-
-MV_VOID pm_device_phy_reset(domain_pm *pm, MV_U8 device_port)
-{
-	pl_root *root = (pl_root *)pm->base.root;
-	pm->active_port = device_port;
-	pm->state = PM_STATE_DISABLE_ASYNOTIFY;
-	pm->status |= PM_STATUS_DEVICE_PHY_RESET;
-	core_queue_init_entry(pm->base.root, &pm->base, MV_TRUE);
-}
-
-MV_Request *pm_make_pm_register_req(domain_pm *pm, MV_BOOLEAN op,
-	MV_BOOLEAN is_control, MV_U8 pm_port, MV_U8 reg_num, MV_U32 reg_value,
-	MV_PVOID callback)
-{
-	pl_root *root = pm->base.root;
-	MV_Request *req = get_intl_req_resource(root, 0);
-	core_context *ctx;
-
-	if (req == NULL) return NULL;
-
-	ctx = req->Context[MODULE_CORE];
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = (op == PM_OP_WRITE) ?
-		CDB_CORE_PM_WRITE_REG : CDB_CORE_PM_READ_REG;
-	req->Cdb[3] = is_control ? 0xF : pm_port;
-	req->Cdb[4] = reg_num;
-
-	if (op == PM_OP_WRITE) {
-		req->Cdb[5] = (MV_U8)((reg_value & 0xff00) >> 8);
-		req->Cdb[6] = (MV_U8)((reg_value & 0xff0000) >> 16);
-		req->Cdb[7] = (MV_U8)((reg_value & 0xff000000) >> 24) ;
-		req->Cdb[8] = (MV_U8)(reg_value & 0xff);
-	}
-
-	req->Device_Id = pm->base.id;
-	ctx->req_flag |= CORE_REQ_FLAG_NEED_D2H_FIS;
-	req->Completion = (void(*)(MV_PVOID, MV_Request *))callback;
-
-	return req;
-}
-
-MV_VOID pm_sig_time_out(domain_pm *pm, MV_PVOID tmp)
-{
-	pm->state = PM_STATE_SIG_DONE;
-	pm->sata_sig_timer = NO_CURRENT_TIMER;
-	core_queue_init_entry(pm->base.root, &pm->base, MV_FALSE);
-}
-
-MV_BOOLEAN pm_state_machine(MV_PVOID dev)
-{
-	domain_pm *pm = (domain_pm *)dev;
-	pl_root *root = pm->base.root;
-	MV_Request *req = NULL;
-	MV_U32 tmp = 0;
-	MV_U8 i;
-	MV_PVOID callback;
-	core_extension *core = (core_extension *)root->core;
-	MV_ULONG flags;
-	struct device_spin_up *devsp=NULL;
-
-	CORE_DPRINT(("pm %d state 0x%x.\n", pm->base.id, pm->state));
-
-	if (pm->status & (PM_STATUS_HOT_PLUG | PM_STATUS_DEVICE_PHY_RESET))
-		callback = pm_hot_plug_req_callback;
-	else
-		callback = pm_init_req_callback;
-
-	switch (pm->state) {
-	case PM_STATE_RESET_DONE:
-		pm->active_port = 0;
-		for (i=0; i<CORE_MAX_DEVICE_PER_PM; i++) {
-			pm->devices[i] = NULL;
-		}
-		req = pm_make_pm_register_req(pm, PM_OP_READ, MV_TRUE, 0, PM_GSCR_INFO,
-			0, pm_init_req_callback);
-		break;
-	case PM_STATE_QRIGA_WORKAROUND:
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0, 0x9B,
-			0xF0, pm_init_req_callback);
-		break;
-	case PM_STATE_READ_INFO_DONE:
-		req = pm_make_pm_register_req(pm, PM_OP_READ, MV_TRUE, 0, PM_GSCR_ID,
-			0, pm_init_req_callback);
-		break;
-	case PM_STATE_READ_ID_DONE:
-		req = pm_make_pm_register_req(pm, PM_OP_READ, MV_TRUE, 0,
-			PM_GSCR_REVISION, 0, pm_init_req_callback);
-		break;
-	case PM_STATE_READ_REV_DONE:
-		req = pm_make_pm_register_req(pm, PM_OP_READ, MV_TRUE, 0,
-			PM_GSCR_FEATURES_ENABLE, 0, pm_init_req_callback);
-		break;
-	case PM_STATE_ENABLE_FEATURES:
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0,
-			PM_GSCR_FEATURES_ENABLE, pm->feature_enabled,
-			pm_init_req_callback);
-		break;
-	case PM_STATE_CLEAR_ERROR_INFO:
-		tmp = MV_BIT(16) | MV_BIT(26);
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0,
-			PM_GSCR_ERROR_ENABLE, tmp, pm_init_req_callback);
-		break;
-	case PM_STATE_SPIN_UP_ALL_PORTS:
-	case PM_STATE_ENABLE_PM_PORT_1:
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_FALSE, pm->active_port,
-			PM_PSCR_SCONTROL, 0x01, callback);
-		break;
-	case PM_STATE_SPIN_UP_DONE:
-	case PM_STATE_ENABLE_PM_PORT_0:
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_FALSE, pm->active_port,
-			PM_PSCR_SCONTROL, 0x00, callback);
-		break;
-	case PM_STATE_PORT_CHECK_PHY_RDY:
-		req = pm_make_pm_register_req(pm, PM_OP_READ, MV_FALSE, pm->active_port,
-			PM_PSCR_SSTATUS, 0, callback);
-		break;
-	case PM_STATE_CLEAR_X_BIT:
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_FALSE, pm->active_port,
-			PM_PSCR_SERROR, 0xFFFFFFFF, pm_init_req_callback);
-		break;
-	case PM_STATE_ISSUE_SOFT_RESET_1:
-		req = sata_make_soft_reset_req(pm->base.port,
-			pm->devices[pm->active_port], MV_TRUE, MV_FALSE,
-			pm_init_req_callback);
-		break;
-	case PM_STATE_ISSUE_SOFT_RESET_0:
-		req = sata_make_soft_reset_req(pm->base.port,
-			pm->devices[pm->active_port], MV_FALSE, MV_FALSE,
-			pm_init_req_callback);
-		break;
-	case PM_STATE_WAIT_SIG:
-		if (pm->base.port->phy->sata_signature == 0xFFFFFFFF) {
-			MV_ASSERT(pm->sata_sig_timer == NO_CURRENT_TIMER);
-			pm->sata_sig_timer = core_add_timer(root->core, 10,
-					(void (*) (void *, void *))pm_sig_time_out, pm, NULL);
-			MV_ASSERT(pm->sata_sig_timer != NO_CURRENT_TIMER);
-			return MV_TRUE;
-		} else {
-			pm->state = PM_STATE_SIG_DONE;
-		}
-	case PM_STATE_SIG_DONE:
-		/* this device is done, go to the next device */
-		if (pm->status & (PM_STATUS_HOT_PLUG | PM_STATUS_DEVICE_PHY_RESET)) {
-			for (i=0; i<pm->num_ports; i++) {
-				if (pm->global_serror & MV_BIT(i)) {
-					pm->active_port = i;
-					pm->global_serror &= ~MV_BIT(i);
-					break;
-				}
-			}
-			if (i == pm->num_ports) {
-				pm->active_port = 0;
-				pm->state = PM_STATE_DONE;
-				pm->status &= ~(PM_STATUS_HOT_PLUG | PM_STATUS_DEVICE_PHY_RESET);
-			} else {
-				pm->state = PM_STATE_READ_PORT_ERROR;
-			}
-		} else {
-			pm->active_port++;
-			if (pm->active_port >= pm->num_ports) {
-				pm->active_port = 0;
-				pm->state = PM_STATE_DONE;
-			} else {
-				pm->state = PM_STATE_PORT_CHECK_PHY_RDY;
-			}
-		}
-		core_queue_init_entry(root, &pm->base, MV_FALSE);
-		return MV_TRUE;
-
-	case PM_STATE_DISABLE_ASYNOTIFY:
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0,
-			PM_GSCR_FEATURES_ENABLE, pm->feature_enabled & (~MV_BIT(3)),
-			pm_hot_plug_req_callback);
-		break;
-
-	case PM_STATE_READ_GLOBAL_ERROR:
-		req = pm_make_pm_register_req(pm, PM_OP_READ, MV_TRUE, 0,
-			PM_GSCR_ERROR, 0, pm_hot_plug_req_callback);
-		break;
-	case PM_STATE_READ_PORT_ERROR:
-		req = pm_make_pm_register_req(pm, PM_OP_READ, MV_FALSE, pm->active_port,
-			PM_PSCR_SERROR, 0, pm_hot_plug_req_callback);
-		break;
-	case PM_STATE_CLEAR_PORT_ERROR:
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_FALSE, pm->active_port,
-			PM_PSCR_SERROR, 0xFFFFFFFF, pm_hot_plug_req_callback);
-		break;
-
-	case PM_STATE_ENABLE_ASYNOTIFY:
-		req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0,
-			PM_GSCR_FEATURES_ENABLE, pm->feature_enabled | MV_BIT(3),
-			pm_hot_plug_req_callback);
-		break;
-
-	case PM_STATE_DONE:
-		for (i=0; i<pm->num_ports; i++) {
-			if (pm->devices[i] && pm->devices[i]->state == DEVICE_STATE_IDLE) {
-				pm->devices[i]->state = DEVICE_STATE_RESET_DONE;
-				devsp=get_spin_up_device_buf(root->lib_rsrc);
-				if(!devsp || (core->spin_up_group == 0)){
-					if(devsp){
-						free_spin_up_device_buf(root->lib_rsrc,devsp);
-					}
-					core_queue_init_entry(root, &pm->devices[i]->base, MV_TRUE);
-				}else{
-					MV_LIST_HEAD_INIT(&devsp->list);
-					devsp->roots=root;
-					devsp->base=&pm->devices[i]->base;
-
-					OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP(core,flags);
-					List_AddTail(&devsp->list,&core->device_spin_up_list);
-					if(core->device_spin_up_timer ==NO_CURRENT_TIMER){
-						core->device_spin_up_timer=core_add_timer(core, 3, (MV_VOID (*) (MV_PVOID, MV_PVOID))staggered_spin_up_handler, &pm->devices[i]->base, NULL);
-					}
-					OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(core,flags);
-				}
-			}
-		}
-
-		core_init_entry_done(root, pm->base.port, &pm->base);
-		return MV_TRUE;
-	default:
-		return MV_TRUE;
-	}
-
-	if (req) {
-		core_append_init_request(root, req);
-		return MV_TRUE;
-	} else {
-		return MV_FALSE;
-	}
-}
-
-MV_U8 pm_verify_command(MV_PVOID root_p, MV_PVOID dev, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_pm *pm = (domain_pm *)dev;
-	MV_U8 set;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	if (req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC
-	&& req->Cdb[1] == CDB_CORE_MODULE
-	&& req->Cdb[2] == CDB_CORE_RESET_PORT) {
-		mv_reset_phy(root, req->Cdb[3], MV_TRUE);
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (!sat_categorize_cdb(root, req)) {
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if ( !(CORE_IS_INIT_REQ(ctx)) && !(CORE_IS_EH_REQ(ctx))) {
-		req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (pm->register_set == NO_REGISTER_SET) {
-		set = sata_get_register_set(root);
-		if (set == NO_REGISTER_SET)
-			return MV_QUEUE_COMMAND_RESULT_FULL;
-		else
-			pm->register_set = set;
-	}
-
-	return MV_QUEUE_COMMAND_RESULT_PASSED;
-}
-
-MV_VOID pm_prepare_command(MV_PVOID root, MV_PVOID dev, MV_PVOID cmd_header_p,
-	MV_PVOID cmd_table_p, MV_Request *req)
-{
-	ata_taskfile taskfile;
-	MV_BOOLEAN ret;
-	mv_command_header *cmd_header = (mv_command_header *)cmd_header_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	domain_device *device = (domain_device *)dev;
-
-	ret = ata_fill_taskfile(device, req, 0, &taskfile);
-	if (!ret) {
-		MV_DASSERT(MV_FALSE);
-	}
-
-	sata_prepare_command_header(req, cmd_header, cmd_table, 0, 0xF);
-	sata_prepare_command_table(req, cmd_table, &taskfile, 0xF);
-}
-
-MV_VOID pm_send_command(MV_PVOID root_p, MV_PVOID dev, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_U32 entry_nm;
-	domain_pm *pm = (domain_pm *)dev;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	entry_nm = prot_get_delv_q_entry(root);
-
-	root->delv_q[entry_nm] = MV_CPU_TO_LE32(TXQ_MODE_I | ctx->slot | \
-		pm->base.port->asic_phy_map << TXQ_PHY_SHIFT |\
-		 pm->register_set << TXQ_REGSET_SHIFT |TXQ_CMD_STP);
-	prot_write_delv_q_entry(root, entry_nm);
-}
-
-MV_VOID pm_process_command(MV_PVOID root_p, MV_PVOID dev, MV_PVOID cmpl_q_p,
-	MV_PVOID cmd_table_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_pm *pm = (domain_pm *)dev;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	MV_U32 error, cmpl_q = *(MV_PU32)cmpl_q_p;
-	err_info_record *err_info;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	err_info = prot_get_command_error_info(cmd_table, &cmpl_q);
-	if (err_info == 0) {
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-	} else {
-		error = MV_LE32_TO_CPU(err_info->err_info_field_1);
-		CORE_EH_PRINT(("dev %d.\n", req->Device_Id));
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		if (error & CMD_ISS_STPD) {
-			ctx->error_info |= EH_INFO_CMD_ISS_STPD;
-			pm->base.cmd_issue_stopped = MV_TRUE;
-		}
-		ctx->error_info |= EH_INFO_NEED_RETRY;
-	}
-}
--- a/drivers/scsi/vanir/core/pm/core_pm.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_PM_H
-#define __CORE_PM_H
-
-#include "mv_config.h"
-#include "core_type.h"
-
-MV_BOOLEAN pm_state_machine(MV_PVOID dev);
-MV_U8 pm_verify_command(MV_PVOID root_p, MV_PVOID dev,
-       MV_Request *req);
-MV_VOID pm_prepare_command(MV_PVOID root_p, MV_PVOID dev,
-	MV_PVOID cmd_header, MV_PVOID cmd_table,
-	MV_Request *req);
-MV_VOID pm_send_command(MV_PVOID root_p, MV_PVOID dev,
-	MV_Request *req);
-MV_VOID pm_process_command(MV_PVOID root_p, MV_PVOID dev,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table,
-	MV_Request *req);
-
-/* PM registers definitions */
-#define PM_OP_READ					0
-#define PM_OP_WRITE					1
-
-#define PM_GSCR_ID					0
-#define PM_GSCR_REVISION			1
-#define PM_GSCR_INFO				2
-#define PM_GSCR_ERROR				32
-#define PM_GSCR_ERROR_ENABLE		33
-#define PM_GSCR_FEATURES			64
-#define PM_GSCR_FEATURES_ENABLE		96
-
-#define PM_PSCR_SSTATUS				0
-#define PM_PSCR_SERROR				1
-#define PM_PSCR_SCONTROL			2
-#define PM_PSCR_SACTIVE				3
-
-#define PM_SERROR_EXCHANGED			MV_BIT(26)
-#define PM_SERROR_COMM_WAKE			MV_BIT(18)
-#define PM_SERROR_PHYRDY_CHANGE		MV_BIT(16)
-
-#endif /* __CORE_PM_H */
--- a/drivers/scsi/vanir/core/sas_base/core_sas.h
+++ /dev/null
@@ -1,134 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_SAS_H
-#define __CORE_SAS_H
-
-#include "mv_config.h"
-#include "core_type.h"
-
-enum sas_link_rate {
-	SAS_LINK_RATE_UNKNOWN = 0,
-	SAS_PHY_DISABLED = 1,
-	SAS_PHY_RESET_PROBLEM = 2,
-	SAS_SATA_SPINUP_HOLD = 3,
-	SAS_SATA_PORT_SELECTOR = 4,
-	SAS_PHY_RESET_IN_PROGRESS = 5,
-	SAS_LINK_RATE_1_5_GBPS = 8,
-	SAS_LINK_RATE_G1 = SAS_LINK_RATE_1_5_GBPS,
-	SAS_LINK_RATE_3_0_GBPS = 9,
-	SAS_LINK_RATE_G2 = SAS_LINK_RATE_3_0_GBPS,
-	SAS_LINK_RATE_6_0_GBPS = 10,
-};
-
-/*
- * Task Management Functions.
- */
-enum TMF {
-	TMF_ABORT_TASK = 0x01,
-	TMF_ABORT_TASK_SET = 0x02,
-	TMF_CLEAR_TASK_SET = 0x04,
-	TMF_LOGICAL_UNIT_RESET = 0x08,
-	TMF_CLEAR_ACA = 0x40,
-	TMF_QUERY_TASK = 0x80,
-};
-
-/* fixed format sense data from SCSI */
-typedef struct _sense_data
-{
-	MV_U8 response_code : 7; /* 0x70h or 0x71h */
-	MV_U8 valid : 1;
-	MV_U8 obsolete;
-	MV_U8 sense_key : 4;
-	MV_U8 reserved : 1;
-	MV_U8 incorrect_length_indicator : 1;
-	MV_U8 end_of_media : 1;
-	MV_U8 file_mark : 1;
-	MV_U8 information[4];
-	MV_U8 additional_sense_length;
-
-	MV_U8 command_specific_information[4];
-	MV_U8 additional_sense_code;
-	MV_U8 additional_sense_code_qualifier;
-	MV_U8 field_replaceable_unit_code;
-	MV_U8 sense_key_specific[3];
-	MV_U8 additional_sense_bytes[2];
-} sense_data;
-
-#define IS_A_TSK_REQ(req) \
-	((req->Cdb[0]==SCSI_CMD_MARVELL_SPECIFIC)&& \
-	 (req->Cdb[1]==CDB_CORE_MODULE)&& \
-	 (req->Cdb[2]==CDB_CORE_TASK_MGMT))
-
-#define CORE_SAS_DISK_QUEUE_DEPTH 64
-#define IS_BEHIND_EXP(dev) \
-	(dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER)
-#define SAS_SLOW_SPINUP(dev) IS_FUJITSU(dev)
-#define IS_FUJITSU(dev) \
-	(MV_CompareMemory(dev->model_number, "FUJITSU", sizeof("FUJITSU") - 1)\
-	== 0)
-
-MV_U8 ssp_verify_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req);
-MV_VOID ssp_prepare_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmd_header_p, MV_PVOID cmd_table_p,
-	MV_Request *req);
-MV_VOID ssp_send_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req);
-MV_VOID ssp_process_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table_p,
-	MV_Request *req);
-
-MV_U8 smp_verify_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req);
-MV_VOID smp_prepare_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmd_header_p, MV_PVOID cmd_table_p,
-	MV_Request *req);
-MV_VOID smp_send_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req);
-MV_VOID smp_process_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table_p,
-	MV_Request *req);
-
-MV_VOID stp_prepare_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmd_header_p, MV_PVOID cmd_table_p,
-	MV_Request *req);
-MV_VOID stp_process_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table_p,
-	MV_Request *req);
-
-MV_BOOLEAN sas_init_state_machine(MV_PVOID dev);
-
-MV_Request *sas_make_marvell_specific_req(MV_PVOID dev_p,
-        MV_U8 cmd, MV_ReqCompletion cmpltn);
-MV_Request *sas_make_mode_sense_req(MV_PVOID dev_p,
-        MV_ReqCompletion cmpltn);
-MV_Request *sas_make_log_sense_req(MV_PVOID dev_p,
-        MV_U8 page, MV_ReqCompletion cmpltn);
-MV_Request *sas_make_sync_cache_req(MV_PVOID dev_p,
-        MV_ReqCompletion cmpltn);
-MV_VOID sas_replace_org_req(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *new_req);
-MV_Request *sas_get_org_req(MV_Request *req);
-MV_Request *sas_clear_org_req(MV_Request *req);
-MV_U8 ssp_ata_parse_log_sense_threshold_exceed(MV_PU8 data_buf, MV_U32 length);
-MV_Request *sas_make_inquiry_req(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_BOOLEAN EVPD, MV_U8 page, MV_ReqCompletion completion);
-MV_Request *ssp_make_virtual_phy_reset_req(MV_PVOID dev_p,
-	MV_U8 operation, MV_PVOID callback);
-MV_Request *sas_make_report_lun_req(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_ReqCompletion completion);
-void mv_int_to_reqlun(MV_U16 lun, MV_U8*reqlun);
-void sas_check_wide_port_device(MV_PVOID port_p);
-
-#endif /* __CORE_SAS_H */
--- a/drivers/scsi/vanir/core/sas_base/sas_error.c
+++ /dev/null
@@ -1,405 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "core_manager.h"
-
-#include "core_sas.h"
-#include "core_hal.h"
-#include "core_error.h"
-#include "core_util.h"
-#include "core_expander.h"
-
-MV_Request *sas_make_task_req(pl_root *root, domain_device *dev,
-	MV_Request *org_req, MV_U8 task_function, MV_ReqCompletion func);
-static void ssp_error_handling_callback(pl_root *root, MV_Request *req);
-MV_VOID ssp_wait_hard_reset(MV_PVOID dev_p, MV_PVOID tmp);
-
-/*
- * two cases will call this function
- * 1. ssp_error_handler: original error request comes here.
- * 2. ssp_error_handling_callback:
- *    a. it's the error handling(eh) request either success or fail
- *    b. retried req will come here only if fails.
- *       if success, ssp_error_handling_callback has returned it.
- */
-static MV_BOOLEAN ssp_timeout_state_machine(pl_root *root,
-        domain_device *dev, MV_BOOLEAN success)
-{
-	struct _error_context *err_ctx = &(dev->base.err_ctx);
-	domain_port *port = (domain_port *)dev->base.port;
-	domain_expander *tmp_exp;
-	MV_Request *eh_req = NULL;
-	MV_Request *org_req = err_ctx->error_req;
-	MV_U8 i;
-
-	MV_ASSERT(err_ctx->eh_type == EH_TYPE_TIMEOUT);
-	MV_ASSERT(org_req != NULL);
-
-	CORE_EH_PRINT(("device %d state %d success 0x%x\n",\
-		dev->base.id, err_ctx->eh_state, success));
-
-	/* for all following state, if eh request returns successfully,
-	 * retry the original request
-	 * if retry req success, already returned org by ssp_error_handling_callback */
-	if (success == MV_TRUE) {
-		if ((org_req->Org_Req_Scmd)
-			&& ((struct scsi_cmnd *)org_req->Org_Req_Scmd)->allowed
-		) {
-			eh_req = core_eh_retry_org_req(
-					root, org_req,
-	                                (MV_ReqCompletion)ssp_error_handling_callback);
-			if (eh_req == NULL) return MV_FALSE;
-			core_queue_eh_req(root, eh_req);
-		} else
-			core_complete_error_req(root, org_req, REQ_STATUS_SUCCESS);
-
-		return MV_TRUE;
-	}
-
-	switch (err_ctx->eh_state) {
-	case SAS_EH_TIMEOUT_STATE_NONE:
-		err_ctx->timeout_count++;
-
-		if (((core_extension *)(root->core))->revision_id != VANIR_C2_REV) {
-			pal_abort_port_running_req(root, port);
-
-			core_sleep_millisecond(root->core, 10);
-
-			for (i = 0; i < dev->base.root->phy_num; i++) {
-				if (dev->base.root->phy[i].port == port) {
-					WRITE_PORT_PHY_CONTROL(root,
-						(&dev->base.root->phy[i]),
-						(SCTRL_STP_LINK_LAYER_RESET | SCTRL_SSP_LINK_LAYER_RESET));
-				}
-			}
-
-			core_sleep_millisecond(root->core, 50);
-
-			LIST_FOR_EACH_ENTRY_TYPE(tmp_exp, &port->expander_list,
-					domain_expander, base.queue_pointer) {
-					pal_clean_expander_outstanding_req(root, tmp_exp);
-			}
-		}
-
-		eh_req = sas_make_task_req(
-			root, dev, org_req, TMF_ABORT_TASK,
-			(MV_ReqCompletion)ssp_error_handling_callback);
-		if (eh_req == NULL) return MV_FALSE;
-		err_ctx->eh_state = SAS_EH_TIMEOUT_STATE_ABORT_REQUEST;
-		CORE_EH_PRINT(("device %d sending abort TMF.\n",\
-			dev->base.id));
-		break;
-	case SAS_EH_TIMEOUT_STATE_ABORT_REQUEST:
-		/* case =
-		 * a. task management request comes back but failed
-		 * b. retried req which is failed */
-
-		eh_req = sas_make_task_req(
-			root, dev, org_req, TMF_LOGICAL_UNIT_RESET,
-			(MV_ReqCompletion)ssp_error_handling_callback);
-		if (eh_req == NULL) return MV_FALSE;
-		err_ctx->eh_state = SAS_EH_TIMEOUT_STATE_LU_RESET;
-		CORE_EH_PRINT(("device %d sending logical unit reset TMF.\n",\
-			dev->base.id));
-		break;
-
-	case SAS_EH_TIMEOUT_STATE_LU_RESET:
-		/* case =
-		 * a. task management request finished but failed
-		 * b. retried req which is failed */
-
-		pal_abort_device_running_req(root, &dev->base);
-		if (IS_BEHIND_EXP(dev)) {
-			eh_req = ssp_make_virtual_phy_reset_req(dev,
-				LINK_RESET, ssp_error_handling_callback);
-
-		} else {
-			eh_req = core_make_device_reset_req(
-				root, port, dev,
-				(MV_ReqCompletion)ssp_error_handling_callback);
-		}
-		if (eh_req == NULL) return MV_FALSE;
-		err_ctx->eh_state = SAS_EH_TIMEOUT_STATE_DEVICE_RESET;
-		CORE_EH_PRINT(("device %d sending device reset.\n",\
-			dev->base.id));
-		break;
-
-	case SAS_EH_TIMEOUT_STATE_DEVICE_RESET:
-		/* case =
-		 * a. device reset request is failed
-		 * b. retried req which is failed */
-
-		if (IS_BEHIND_EXP(dev)) {
-			eh_req = ssp_make_virtual_phy_reset_req(dev,
-				HARD_RESET, ssp_error_handling_callback);
-		} else {
-			eh_req = core_make_port_reset_req(
-				root, port, dev,
-				(MV_ReqCompletion)ssp_error_handling_callback);
-		}
-		if (eh_req == NULL) return MV_FALSE;
-		err_ctx->eh_state = SAS_EH_TIMEOUT_STATE_PORT_RESET;
-		CORE_EH_PRINT(("device %d sending port reset.\n",\
-			dev->base.id));
-		break;
-
-	case SAS_EH_TIMEOUT_STATE_PORT_RESET:
-		/* case =
-		 * a. port reset request failed
-		 * b. retried req which is failed
-		 * c. if > MAX_TIMEOUT_ALLOWED, jump to set down*/
-		CORE_EH_PRINT(("device %d: complete req with ERROR\n",dev->base.id));
-		dev->status |= DEVICE_STATUS_FROZEN;
-		core_complete_error_req(root, org_req, REQ_STATUS_ERROR);
-
-		return MV_TRUE;
-	default:
-		MV_ASSERT(MV_FALSE);
-	}
-
-	MV_ASSERT(eh_req != NULL);
-	core_queue_eh_req(root, eh_req);
-	return MV_TRUE;
-}
-
-/*
- * it's called either by the ssp_error_handler
- * or ssp_error_handling_callback
- * refer to sas_timeout_state_machine
- */
-static MV_BOOLEAN ssp_media_error_state_machine(pl_root *root,
-	domain_device *dev, MV_BOOLEAN success)
-{
-	struct _error_context *err_ctx = &(dev->base.err_ctx);
-	MV_Request *org_req = err_ctx->error_req;
-	MV_Request *eh_req = NULL;
-
-	MV_ASSERT(err_ctx->eh_type == EH_TYPE_MEDIA_ERROR);
-	MV_ASSERT(org_req != NULL);
-
-	CORE_EH_PRINT(("device %d state %d success 0x%x\n",\
-		dev->base.id, err_ctx->eh_state, success));
-
-	switch (err_ctx->eh_state) {
-	case SAS_EH_MEDIA_STATE_NONE:
-		MV_ASSERT(success == MV_FALSE);
-		eh_req = core_eh_retry_org_req(
-				root, org_req, (MV_ReqCompletion)ssp_error_handling_callback);
-		if (eh_req == NULL) return MV_FALSE;
-		core_queue_eh_req(root, eh_req);
-		err_ctx->eh_state = SAS_EH_MEDIA_STATE_RETRY;
-		break;
-	case SAS_EH_MEDIA_STATE_RETRY:
-		MV_ASSERT(success == MV_FALSE);
-		core_complete_error_req(root, org_req, REQ_STATUS_ERROR);
-		break;
-
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-
-	return MV_TRUE;
-}
-
-/*
- * in two cases code will come here
- * 1. the original error req is called using handler when error is first hit
- * 2. if in state machine lack of resource,
- *    the original error request got pushed to the queue again.
- *    see the comments in the function.
- */
-MV_BOOLEAN ssp_error_handler(MV_PVOID dev_p, MV_Request *req)
-{
-	domain_device *dev = (domain_device *)dev_p;
-	pl_root *root = dev->base.root;
-	struct _error_context *err_ctx = &dev->base.err_ctx;
-
-	MV_ASSERT(dev->base.type == BASE_TYPE_DOMAIN_DEVICE);
-	MV_ASSERT(IS_SSP(dev));
-
-	CORE_EH_PRINT(("device %d eh_type %d eh_state %d status 0x%x req %p Cdb[0x%x]\n",\
-                dev->base.id, err_ctx->eh_type, err_ctx->eh_state,
-                err_ctx->scsi_status, req, req->Cdb[0]));
-
-	/* process_command can only return five status
-	 * REQ_STATUS_SUCCESS, XXX_HAS_SENSE, XXX_ERROR, XXX_TIMEOUT, XXX_NO_DEVICE */
-	if (err_ctx->eh_type == EH_TYPE_NONE) {
-		MV_ASSERT((req->Scsi_Status == REQ_STATUS_ERROR)
-			|| (req->Scsi_Status == REQ_STATUS_HAS_SENSE)
-			|| (req->Scsi_Status == REQ_STATUS_TIMEOUT));
-		MV_ASSERT((err_ctx->error_req == NULL)
-                        || (err_ctx->error_req == req));
-		err_ctx->error_req = req;
-
-		if (req->Scsi_Status == REQ_STATUS_TIMEOUT) {
-			err_ctx->eh_type = EH_TYPE_TIMEOUT;
-			err_ctx->eh_state = SAS_EH_TIMEOUT_STATE_NONE;
-                     return ssp_timeout_state_machine(root, dev, MV_FALSE);
-		} else {
-			err_ctx->eh_type = EH_TYPE_MEDIA_ERROR;
-			err_ctx->eh_state = SAS_EH_MEDIA_STATE_NONE;
-			return ssp_media_error_state_machine(root, dev, MV_FALSE);
-		}
-	} else {
-		/* code comes here if ssp_error_handling_callback
-                 * cannot continue because short of resource
-		 * no device should be handled already
-                 * but the req is the original error request not eh req
-                 * because the eh req has released already
-                 * the eh req scsi status is saved in err_ctx->scsi_status */
-              MV_ASSERT(req == err_ctx->error_req);
-
-		MV_ASSERT((err_ctx->scsi_status == REQ_STATUS_ERROR)
-			|| (err_ctx->scsi_status == REQ_STATUS_HAS_SENSE)
-			|| (err_ctx->scsi_status == REQ_STATUS_SUCCESS)
-			|| (err_ctx->scsi_status == REQ_STATUS_TIMEOUT));
-
-		MV_ASSERT((err_ctx->eh_type == EH_TYPE_MEDIA_ERROR)
-			||(err_ctx->eh_type == EH_TYPE_TIMEOUT));
-
-		if (err_ctx->eh_type == EH_TYPE_TIMEOUT) {
-                        return ssp_timeout_state_machine(root, dev,
-                                (err_ctx->scsi_status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE));
-		} else {
-			return ssp_media_error_state_machine(root, dev,
-                                (err_ctx->scsi_status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE));
-		}
-	}
-}
-
-static void ssp_error_handling_callback(pl_root *root, MV_Request *req)
-{
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *dev = (domain_device *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	struct _error_context *err_ctx = &dev->base.err_ctx;
-	MV_BOOLEAN ret = MV_TRUE;
-	MV_Request *org_req = err_ctx->error_req;
-
-	MV_ASSERT(dev->base.type == BASE_TYPE_DOMAIN_DEVICE);
-	MV_ASSERT(IS_SSP(dev));
-	MV_ASSERT(CORE_IS_EH_REQ(ctx));
-	MV_ASSERT((err_ctx->eh_type == EH_TYPE_MEDIA_ERROR)
-		|| (err_ctx->eh_type == EH_TYPE_TIMEOUT));
-	MV_ASSERT(org_req != NULL);
-
-	CORE_EH_PRINT(("device %d eh_type %d eh_state %d eh_status 0x%x req %p Cdb[0x%x] status 0x%x\n",\
-                dev->base.id, err_ctx->eh_type, err_ctx->eh_state,
-                err_ctx->scsi_status, req, req->Cdb[0], req->Scsi_Status));
-
-	if (req->Scsi_Status == REQ_STATUS_NO_DEVICE) {
-		core_complete_error_req(root, org_req, REQ_STATUS_NO_DEVICE);
-		goto end_point;
-	} else if (req->Scsi_Status == REQ_STATUS_TIMEOUT) {
-		if (err_ctx->eh_type == EH_TYPE_MEDIA_ERROR) {
-			err_ctx->eh_type = EH_TYPE_TIMEOUT;
-			err_ctx->eh_state = SAS_EH_TIMEOUT_STATE_NONE;
-		}
-		/* continue the state machine */
-	} else if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-		if (CORE_IS_EH_RETRY_REQ(ctx)) {
-			/* original req retry success, complete state machine*/
-			core_complete_error_req(root, org_req, REQ_STATUS_SUCCESS);
-			goto end_point;
-		}
-	} else if (req->Scsi_Status == REQ_STATUS_HAS_SENSE) {
-		if (CORE_IS_EH_RETRY_REQ(ctx)) {
-			/* copy sense code */
-			MV_CopyMemory(org_req->Sense_Info_Buffer,
-				req->Sense_Info_Buffer,
-				MV_MIN(org_req->Sense_Info_Buffer_Length,
-				req->Sense_Info_Buffer_Length));
-			core_complete_error_req(root, org_req, REQ_STATUS_HAS_SENSE);
-			goto end_point;
-		}
-	}
-
-
-	MV_ASSERT((req->Scsi_Status == REQ_STATUS_ERROR)
-		|| (req->Scsi_Status == REQ_STATUS_HAS_SENSE)
-		|| (req->Scsi_Status == REQ_STATUS_TIMEOUT)
-		|| (req->Scsi_Status == REQ_STATUS_SUCCESS));
-
-	if (err_ctx->eh_type == EH_TYPE_MEDIA_ERROR) {
-		ret = ssp_media_error_state_machine(root, dev,
-                        (req->Scsi_Status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE));
-	} else {
-        ret = ssp_timeout_state_machine(root, dev,
-                (req->Scsi_Status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE));
-	}
-
-end_point:
-	if (ret == MV_FALSE) {
-              err_ctx->scsi_status = req->Scsi_Status;
-		core_queue_error_req(root, org_req, MV_FALSE);
-        }
-}
-
-MV_Request *sas_make_task_req(pl_root *root, domain_device *dev,
-	MV_Request *org_req, MV_U8 task_function, MV_ReqCompletion func)
-{
-	core_context *ctx;
-	MV_Request *req;
-	MV_U16 tag;
-
-        /* allocate resource */
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL) return NULL;
-
-	if (task_function == TMF_ABORT_TASK_SET) {
-		tag = CORE_MAX_REQUEST_NUMBER << root->max_cmd_slot_width |
-			CORE_MAX_REQUEST_NUMBER;
-	} else {
-		ctx = (core_context *)org_req->Context[MODULE_CORE];
-		tag = (org_req->Tag<<root->max_cmd_slot_width) | ctx->slot;
-	}
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_TASK_MGMT;
-	req->Cdb[3] = (MV_U8)(tag&0xff);
-	req->Cdb[4] = (MV_U8)(tag>>8);
-	req->Cdb[5] = task_function;
-	MV_ZeroMemory(&(req->Cdb[6]), 8);
-	mv_int_to_reqlun(dev->base.LUN, &(req->Cdb[6]));
-
-	req->Cmd_Flag = 0;
-
-	req->Device_Id = dev->base.id;
-	req->Completion = func;
-
-	return req;
-}
-
-MV_VOID ssp_wait_hard_reset(MV_PVOID dev_p, MV_PVOID tmp)
-{
-        domain_device *dev = (domain_device *)dev_p;
-        pl_root *root = dev->base.root;
-        MV_BOOLEAN ret = MV_FALSE;
-        struct _error_context *err_ctx = &dev->base.err_ctx;
-
-        err_ctx->eh_timer = NO_CURRENT_TIMER;
-        if (err_ctx->eh_type == EH_TYPE_TIMEOUT)
-		ret = ssp_timeout_state_machine(root, dev, MV_TRUE);
-        else if (err_ctx->eh_type == EH_TYPE_MEDIA_ERROR)
-		ret = ssp_media_error_state_machine(root, dev, MV_TRUE);
-
-        if (ret == MV_FALSE) {
-                err_ctx->scsi_status = REQ_STATUS_SUCCESS;
-                core_queue_error_req(root, err_ctx->error_req, MV_FALSE);
-        }
-}
--- a/drivers/scsi/vanir/core/sas_base/sas_handler.c
+++ /dev/null
@@ -1,1878 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_sas.h"
-#include "core_internal.h"
-#include "core_manager.h"
-#include "com_api.h"
-#include "com_u64.h"
-#include "com_error.h"
-
-#include "core_util.h"
-#include "core_error.h"
-#include "core_sat.h"
-#include "core_console.h"
-#include "core_expander.h"
-
-#define IS_A_SMP_REQ(pReq) \
-	((pReq->Cdb[0]==SCSI_CMD_MARVELL_SPECIFIC)&& \
-	 (pReq->Cdb[1]==CDB_CORE_MODULE)&& \
-	 (pReq->Cdb[2]==CDB_CORE_SMP))
-
-extern MV_VOID prot_process_cmpl_req(pl_root *root, MV_Request *req);
-extern MV_VOID ssp_ata_intl_req_callback(MV_PVOID root_p, MV_Request *req);
-extern MV_U8 ssp_ata_parse_smart_return_status(domain_device *device,
-	MV_Request *org_req, MV_Request *new_req);
-extern MV_Request *smp_make_discover_req(domain_expander *exp,
-	MV_Request *vir_req, MV_U8 phy_id, MV_PVOID callback);
-extern MV_VOID smp_req_discover_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p);
-extern MV_VOID smp_req_reset_sata_phy_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p);
-extern MV_VOID smp_req_clear_aff_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p);
-extern MV_Request *smp_make_config_route_req(domain_expander *exp,
-	MV_Request *vir_req, MV_U16 route_index, MV_U8 phy_id, MV_U64 *sas_addr,
-	MV_PVOID callback);
-extern MV_VOID smp_req_config_route_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p);
-extern MV_Request *smp_make_phy_crtl_by_id_req(MV_PVOID exp_p,
-	MV_U8 phy_id, MV_U8 operation, MV_PVOID callback);
-extern MV_Request *smp_make_report_phy_sata_by_id_req(MV_PVOID exp_p,
-	MV_U8 phy_id, MV_PVOID callback);
-extern domain_base *exp_search_phy(domain_expander *exp, MV_U8 phy_id);
-MV_VOID ssp_ata_fill_inquiry_device(domain_device *dev, MV_Request *req);
-MV_VOID ssp_mode_page_rmw_callback(MV_PVOID root_p, MV_Request *req);
-extern MV_VOID smp_physical_req_callback(MV_PVOID root_p, MV_Request *req);
-
-MV_U8 ssp_verify_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_extension *core = (core_extension *)root->core;
-	domain_device *dev = (domain_device *)dev_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_QUEUE_COMMAND_RESULT result = MV_QUEUE_COMMAND_RESULT_PASSED;
-	MV_Request *new_req;
-	MV_U8 ret;
-	HD_SMART_Status *status;
-
-	if (req->Cdb[0] == APICDB0_ADAPTER){
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (req->Cdb[0] == SCSI_CMD_START_STOP_UNIT)
-		req->Time_Out = 60;
-
-	if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC) &&
-		(req->Cdb[1] == CDB_CORE_MODULE)) {
-
-		switch (req->Cdb[2]) {
-		case CDB_CORE_TASK_MGMT:
-			break;
-
-		case CDB_CORE_RESET_DEVICE:
-			mv_reset_phy(root, req->Cdb[3], MV_FALSE);
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-		case CDB_CORE_RESET_PORT:
-			mv_reset_phy(root, req->Cdb[3], MV_TRUE);
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-		case CDB_CORE_ENABLE_SMART:
-			if (!(dev->capability &
-				DEVICE_CAPABILITY_SMART_SUPPORTED))
-				CORE_DPRINT(("Device %d does not "\
-				"support SMART, but returning "\
-				"REQ_STATUS_SUCCESS anyway\n",\
-				dev->base.id));
-			else
-				dev->setting |= DEVICE_SETTING_SMART_ENABLED;
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-		case CDB_CORE_DISABLE_SMART:
-			dev->setting &= ~DEVICE_SETTING_SMART_ENABLED;
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-		case CDB_CORE_ENABLE_WRITE_CACHE:
-			new_req = sas_make_mode_sense_req(dev,
-			ssp_mode_page_rmw_callback);
-
-			if (new_req == NULL)
-				return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-			sas_replace_org_req(root, req, new_req);
-			return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-		case CDB_CORE_DISABLE_WRITE_CACHE:
-			new_req = sas_make_mode_sense_req(dev,
-			ssp_mode_page_rmw_callback);
-
-			if (new_req == NULL)
-				return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-			sas_replace_org_req(root, req, new_req);
-			return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-		case CDB_CORE_ENABLE_READ_AHEAD:
-			new_req = sas_make_mode_sense_req(dev,
-			ssp_mode_page_rmw_callback);
-			if (new_req == NULL)
-				return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-			sas_replace_org_req(root, req, new_req);
-			return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-		case CDB_CORE_DISABLE_READ_AHEAD:
-			new_req = sas_make_mode_sense_req(dev,
-			ssp_mode_page_rmw_callback);
-
-			if (new_req == NULL)
-				return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-			sas_replace_org_req(root, req, new_req);
-			return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-		case CDB_CORE_SMART_RETURN_STATUS:
-			if (!(dev->capability &
-				DEVICE_CAPABILITY_SMART_SUPPORTED)) {
-				req->Scsi_Status = REQ_STATUS_SUCCESS;
-				status = core_map_data_buffer(req);
-				if (status != NULL)
-					status->SmartThresholdExceeded = MV_FALSE;
-				core_unmap_data_buffer(req);
-				return MV_QUEUE_COMMAND_RESULT_FINISHED;
-			}
-
-			/* Page=2F(Informal Exceptions Log) */
-			new_req = sas_make_log_sense_req(dev,
-			0x2F,
-			ssp_ata_intl_req_callback);
-
-			if (new_req == NULL)
-				return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-			sas_replace_org_req(root, req, new_req);
-			return MV_QUEUE_COMMAND_RESULT_REPLACED;
-		case CDB_CORE_OS_SMART_CMD:
-                        if (req->Cdb[3] == ATA_CMD_IDENTIFY_ATA) {
-
-                                ssp_ata_fill_inquiry_device(dev, req);
-                                req->Scsi_Status = REQ_STATUS_SUCCESS;
-			        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-                        }
-
-                        if (!(dev->capability &
-                                DEVICE_CAPABILITY_SMART_SUPPORTED)) {
-
-			        req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-			        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-                        }
-
-                        switch (req->Cdb[4]) {
-                        case ATA_CMD_ENABLE_SMART:
-                                if (!(dev->capability &
-                                        DEVICE_CAPABILITY_SMART_SUPPORTED)) {
-
-                                        CORE_DPRINT(("Device %d does "\
-                                                "not support SMART, but "\
-                                                "returning REQ_STATUS_SUCCESS"\
-                                                " anyway\n", dev->base.id));
-                                } else if (!(dev->setting &
-                                        DEVICE_SETTING_SMART_ENABLED)) {
-
-                                        dev->setting |=
-                                                DEVICE_SETTING_SMART_ENABLED;
-                                }
-
-                                req->Scsi_Status = REQ_STATUS_SUCCESS;
-                                return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-                        case ATA_CMD_DISABLE_SMART:
-                                dev->setting &= ~DEVICE_SETTING_SMART_ENABLED;
-
-                                req->Scsi_Status = REQ_STATUS_SUCCESS;
-                                return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-                        case ATA_CMD_SMART_RETURN_STATUS:
-                                if (!(dev->capability &
-                                        DEVICE_CAPABILITY_SMART_SUPPORTED)) {
-
-                                        req->Scsi_Status = REQ_STATUS_SUCCESS;
-                                        status = (HD_SMART_Status *)
-                                                core_map_data_buffer(req);
-                                        if (status != NULL)
-                                                status->SmartThresholdExceeded
-                                                        = MV_FALSE;
-                                        core_unmap_data_buffer(req);
-                                        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-                                }
-
-                                /* Page=2F(Informal Exceptions Log) */
-                                new_req = sas_make_log_sense_req(dev,
-                                                0x2F,
-                                                ssp_ata_intl_req_callback);
-
-                                ret = MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-                                if (new_req == NULL)
-                                        return ret;
-
-                                sas_replace_org_req(root, req, new_req);
-                                return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-                        case ATA_CMD_SMART_READ_DATA:
-                        case ATA_CMD_SMART_ENABLE_ATTRIBUTE_AUTOSAVE:
-                        case ATA_CMD_SMART_EXECUTE_OFFLINE:
-                        case ATA_CMD_SMART_READ_LOG:
-                        case ATA_CMD_SMART_WRITE_LOG:
-
-                                req->Scsi_Status = REQ_STATUS_SUCCESS;
-                                return MV_QUEUE_COMMAND_RESULT_FINISHED;
-                        }
-
-                        break;
-		case CDB_CORE_SSP_VIRTUAL_PHY_RESET:
-			new_req = smp_make_phy_control_req(dev, req->Cdb[3],
-				smp_physical_req_callback);
-			if (!new_req) return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-			((core_context *)new_req->Context[MODULE_CORE])->u.org.org_req = req;
-			core_queue_eh_req(root, new_req);
-			return MV_QUEUE_COMMAND_RESULT_REPLACED;
-		default:
-			req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		}
-
-	}
-
-	switch (req->Cdb[0]) {
-	case APICDB0_PASS_THRU_CMD_SCSI:
-	case APICDB0_PASS_THRU_CMD_ATA:
-		result = core_pass_thru_send_command(root->core, req);
-		break;
-	case APICDB0_PD:
-		switch (req->Cdb[1]) {
-		case APICDB1_PD_SETSETTING:
-			switch (req->Cdb[4]) {
-			case APICDB4_PD_SET_WRITE_CACHE_OFF:
-	                        if (!(dev->setting &
-	                                DEVICE_SETTING_WRITECACHE_ENABLED)) {
-
-	                                req->Scsi_Status = REQ_STATUS_SUCCESS;
-	                                return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	                        }
-
-	                        new_req = sas_make_mode_sense_req(dev,
-	                                ssp_mode_page_rmw_callback);
-
-	                        if (new_req == NULL)
-	                                return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	                        sas_replace_org_req(root, req, new_req);
-	                        return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	                case APICDB4_PD_SET_WRITE_CACHE_ON:
-	                        if (dev->setting & DEVICE_SETTING_WRITECACHE_ENABLED) {
-	                                req->Scsi_Status = REQ_STATUS_SUCCESS;
-	                                return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	                        }
-
-	                        new_req = sas_make_mode_sense_req(dev,
-	                                ssp_mode_page_rmw_callback);
-
-	                        if (new_req == NULL)
-	                                return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	                        sas_replace_org_req(root, req, new_req);
-	                        return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	                case APICDB4_PD_SET_SMART_OFF:
-	                        if (dev->setting & DEVICE_SETTING_SMART_ENABLED) {
-	                                dev->setting &= ~DEVICE_SETTING_SMART_ENABLED;
-	                        }
-
-	                        req->Scsi_Status = REQ_STATUS_SUCCESS;
-	                        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-	                case APICDB4_PD_SET_SMART_ON:
-	                        if (!(dev->capability &
-	                                DEVICE_CAPABILITY_SMART_SUPPORTED)) {
-
-	                                CORE_DPRINT(("Device %d does not "\
-	                                        "support SMART, but returning "\
-	                                        "REQ_STATUS_SUCCESS anyway\n",\
-	                                        dev->base.id));
-
-	                        } else if (!(dev->setting &
-	                                DEVICE_SETTING_SMART_ENABLED)) {
-
-	                                dev->setting &= ~DEVICE_SETTING_SMART_ENABLED;
-	                        }
-
-	                        req->Scsi_Status = REQ_STATUS_SUCCESS;
-	                        return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-	                default:
-	                        CORE_DPRINT(("Unsupported API PD "\
-	                                "Setting %d\n", req->Cdb[4]));
-
-	                        if (req->Sense_Info_Buffer != NULL &&
-	                                req->Sense_Info_Buffer_Length != 0)
-
-	                                ((MV_PU8)req->Sense_Info_Buffer)[0]
-	                                        = ERR_INVALID_PARAMETER;
-
-	                        req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-	                        result = MV_QUEUE_COMMAND_RESULT_FINISHED;
-	                        break;
-	                }
-	                break;
-
-	        case APICDB1_PD_GETSTATUS:
-	                switch (req->Cdb[4]) {
-	                case APICDB4_PD_SMART_RETURN_STATUS:
-	                        if (!(dev->capability &
-	                                DEVICE_CAPABILITY_SMART_SUPPORTED)) {
-
-	                                req->Scsi_Status = REQ_STATUS_SUCCESS;
-	                                status = core_map_data_buffer(req);
-	                                if (status != NULL)
-	                                        status->SmartThresholdExceeded = MV_FALSE;
-	                                core_unmap_data_buffer(req);
-	                                return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	                        }
-
-	                        /* Page=2F(Informal Exceptions Log) */
-	                        new_req = sas_make_log_sense_req(dev, 0x2F,
-	                                        ssp_ata_intl_req_callback);
-
-	                        if (new_req == NULL)
-	                                return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	                        sas_replace_org_req(root, req, new_req);
-	                        return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	                default:
-	                        CORE_DPRINT(("Unsupported API PD "\
-	                                "Get Status %d\n", req->Cdb[4]));
-
-	                        if (req->Sense_Info_Buffer != NULL &&
-	                                req->Sense_Info_Buffer_Length != 0)
-
-	                                ((MV_PU8)req->Sense_Info_Buffer)[0]
-	                                        = ERR_INVALID_PARAMETER;
-
-	                        req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-	                        result = MV_QUEUE_COMMAND_RESULT_FINISHED;
-	                        break;
-	                }
-	        }
-       break;
-
-	default:
-		result = MV_QUEUE_COMMAND_RESULT_PASSED;
-	}
-
-	return result;
-}
-
-MV_VOID ssp_ata_host_string2ata(MV_U16 *source, MV_U16 *target,
-	MV_U32 words_count)
-{
-	MV_U32 i;
-	for (i=0; i < words_count; i++) {
-		target[i] = (source[i] >> 8) | ((source[i] & 0xff) << 8);
-		target[i] = MV_LE16_TO_CPU(target[i]);
-	}
-}
-
-
-MV_VOID ssp_ata_fill_inquiry_device(domain_device *dev, MV_Request *req)
-{
-        ata_identify_data *dst = (ata_identify_data *)core_map_data_buffer(req);
-        MV_U16  tmp;
-        MV_LBA max_lba;
-
-        MV_ZeroMemory(dst, sizeof(ata_identify_data));
-
-        tmp = 0x8000;
-        ssp_ata_host_string2ata(&tmp, &dst->general_config, 1);
-
-        /* serial number */
-        ssp_ata_host_string2ata((MV_PU16)dev->serial_number,
-                (MV_PU16)dst->serial_number, 10);
-
-        /* firmware */
-        ssp_ata_host_string2ata((MV_PU16)dev->firmware_revision,
-                (MV_PU16)dst->firmware_revision, 4);
-
-        /* model */
-        ssp_ata_host_string2ata((MV_PU16)dev->model_number,
-                (MV_PU16)dst->model_number, 20);
-
-        tmp = 0;
-        if (dev->capability & DEVICE_CAPABILITY_SMART_SUPPORTED)
-                tmp |= MV_BIT(0);
-
-        ssp_ata_host_string2ata(&tmp,
-                &dst->command_set_supported[0], 1);
-
-        tmp = MV_BIT(10);
-        ssp_ata_host_string2ata(&tmp,
-                &dst->command_set_supported[1], 1);
-
-        tmp = 0;
-        if (dev->setting & DEVICE_SETTING_SMART_ENABLED)
-                tmp |= MV_BIT(0);
-        if (dev->setting & DEVICE_SETTING_WRITECACHE_ENABLED)
-                tmp |= MV_BIT(5);
-        if (dev->setting & DEVICE_SETTING_READ_LOOK_AHEAD)
-                tmp |= MV_BIT(6);
-
-        ssp_ata_host_string2ata(&tmp,
-                &dst->command_set_enabled[0], 1);
-
-        /* max lba */
-        max_lba = U64_ADD_U32(dev->max_lba, 1);
-        tmp = (MV_U16)(max_lba.parts.low & 0xFFFF);
-        ssp_ata_host_string2ata(&tmp,
-                &dst->max_lba[0], 1);
-        ssp_ata_host_string2ata(&tmp,
-                &dst->user_addressable_sectors[0], 1);
-
-        tmp = (MV_U16)((max_lba.parts.low >> 16) & 0xFFFF);
-        ssp_ata_host_string2ata(&tmp,
-                &dst->max_lba[1], 1);
-        ssp_ata_host_string2ata(&tmp,
-                &dst->user_addressable_sectors[1], 1);
-
-        tmp = (MV_U16)(max_lba.parts.high & 0xFFFF);
-        ssp_ata_host_string2ata(&tmp,
-                &dst->max_lba[2], 1);
-        tmp = (MV_U16)((max_lba.parts.high >> 16) & 0xFFFF);
-        ssp_ata_host_string2ata(&tmp,
-                &dst->max_lba[3], 1);
-
-        core_unmap_data_buffer(req);
-}
-
-MV_VOID
-ssp_ata_intl_req_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_Request *org_req = sas_clear_org_req(req);
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *dev = (domain_device *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	core_extension *core = (core_extension *)root->core;
-	MV_U32 length;
-
-	if (org_req == NULL) {
-		MV_DASSERT(MV_FALSE);
-		return;
-	}
-
-        org_req->Scsi_Status = req->Scsi_Status;
-        if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-                length = MV_MIN(org_req->Sense_Info_Buffer_Length,
-                                req->Sense_Info_Buffer_Length);
-
-                if (length != 0 &&
-                        org_req->Sense_Info_Buffer != NULL &&
-                        req->Sense_Info_Buffer != NULL)
-
-                        MV_CopyMemory(
-                                org_req->Sense_Info_Buffer,
-                                req->Sense_Info_Buffer,
-                                length);
-
-                if ((org_req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC &&
-                        org_req->Cdb[2] == CDB_CORE_OS_SMART_CMD &&
-                        org_req->Cdb[3] == ATA_CMD_SMART &&
-                        org_req->Cdb[4] == ATA_CMD_SMART_RETURN_STATUS) ||
-                        (org_req->Cdb[0] == APICDB0_PD &&
-                        org_req->Cdb[1] == APICDB1_PD_GETSTATUS &&
-                        org_req->Cdb[4] == APICDB4_PD_SMART_RETURN_STATUS)) {
-
-                        core_generate_event(core, EVT_ID_HD_SMART_POLLING_FAIL,
-                                dev->base.id, SEVERITY_WARNING, 0, NULL ,0);
-                }
-
-                core_queue_completed_req(core, org_req);
-                return;
-        }
-
-	switch (org_req->Cdb[0]) {
-        case SCSI_CMD_MARVELL_SPECIFIC:
-                if (org_req->Cdb[1] != CDB_CORE_MODULE)
-                        MV_DASSERT(MV_FALSE);
-
-		switch (org_req->Cdb[2]) {
-                case CDB_CORE_ENABLE_WRITE_CACHE:
-                        dev->setting |= DEVICE_SETTING_WRITECACHE_ENABLED;
-                        break;
-
-                case CDB_CORE_DISABLE_WRITE_CACHE:
-                        dev->setting &= ~DEVICE_SETTING_WRITECACHE_ENABLED;
-                        break;
-
-                case CDB_CORE_ENABLE_READ_AHEAD:
-                        dev->setting |= DEVICE_SETTING_READ_LOOK_AHEAD;
-                        break;
-
-                case CDB_CORE_DISABLE_READ_AHEAD:
-                        dev->setting &= ~DEVICE_SETTING_READ_LOOK_AHEAD;
-                        break;
-
-                case CDB_CORE_SMART_RETURN_STATUS:
-                        ssp_ata_parse_smart_return_status(dev, org_req, req);
-                        break;
-                case CDB_CORE_OS_SMART_CMD:
-                        switch (org_req->Cdb[4]) {
-                        case ATA_CMD_SMART_RETURN_STATUS:
-                                ssp_ata_parse_smart_return_status(dev,
-                                        org_req, req);
-                                break;
-
-                        default:
-                                MV_DASSERT(MV_FALSE);
-                                break;
-                        }
-                        break;
-                case CDB_CORE_SHUTDOWN:
-                        break;
-                default:
-                        MV_DASSERT(MV_FALSE);
-                        break;
-                }
-                break;
-
-        case APICDB0_PD:
-                switch (org_req->Cdb[1]) {
-                case APICDB1_PD_SETSETTING:
-                        switch (org_req->Cdb[4]) {
-                        case APICDB4_PD_SET_WRITE_CACHE_OFF:
-                                dev->setting &=
-                                        ~DEVICE_SETTING_WRITECACHE_ENABLED;
-
-                                core_generate_event(core,
-                                        EVT_ID_HD_CACHE_MODE_CHANGE,
-                                        dev->base.id, SEVERITY_INFO,
-                                        0, NULL ,0);
-                                break;
-
-                        case APICDB4_PD_SET_WRITE_CACHE_ON:
-                                dev->setting |=
-                                        DEVICE_SETTING_WRITECACHE_ENABLED;
-
-                                core_generate_event(core,
-                                        EVT_ID_HD_CACHE_MODE_CHANGE,
-                                        dev->base.id, SEVERITY_INFO,
-                                        0, NULL ,0);
-                                break;
-
-                        case APICDB4_PD_SET_SMART_OFF:
-                        case APICDB4_PD_SET_SMART_ON:
-                                break;
-                        default:
-		                MV_DASSERT(MV_FALSE);
-                                return;
-                        }
-                        break;
-
-                case APICDB1_PD_GETSTATUS:
-                        switch (org_req->Cdb[4]) {
-                        case APICDB4_PD_SMART_RETURN_STATUS:
-                                ssp_ata_parse_smart_return_status(dev,
-					org_req, req);
-                                break;
-
-                        default:
-		                MV_DASSERT(MV_FALSE);
-                                return;
-                        }
-                        break;
-                }
-                break;
-
-	default:
-		MV_DASSERT(MV_FALSE);
-                return;
-	}
-
-        core_queue_completed_req(core, org_req);
-}
-
-MV_VOID
-ssp_mode_page_rmw_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_Request *org_req, *new_req;
-	core_context *org_ctx;
-	domain_device *dev;
-	MV_U32 length;
-	MV_PU8 org_buf_ptr, new_buf_ptr;
-
-	org_req = sas_clear_org_req(req);
-
-	if (org_req == NULL) {
-		MV_ASSERT(MV_FALSE);
-		return;
-	}
-
-	org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-	dev = (domain_device *)get_device_by_id(root->lib_dev,
-	org_req->Device_Id);
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		length = MV_MIN(req->Sense_Info_Buffer_Length,
-		org_req->Sense_Info_Buffer_Length);
-
-		MV_CopyMemory(org_req->Sense_Info_Buffer,
-			req->Sense_Info_Buffer,
-			length);
-
-		org_req->Scsi_Status = req->Scsi_Status;
-		core_queue_completed_req(root->core, org_req);
-		return;
-	}
-
-	org_buf_ptr = core_map_data_buffer(req);
-
-	MV_DASSERT(org_buf_ptr[3] == 0);
-	MV_DASSERT((org_buf_ptr[4] & 0x6F) == 0x08);
-
-	switch (org_req->Cdb[0]) {
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		if (org_req->Cdb[1] != CDB_CORE_MODULE)
-			MV_DASSERT(MV_FALSE);
-
-		switch (org_req->Cdb[2]) {
-		case CDB_CORE_ENABLE_WRITE_CACHE:
-			if (org_buf_ptr[6 + org_buf_ptr[3]] & MV_BIT(2)) {
-				dev->setting |= DEVICE_SETTING_WRITECACHE_ENABLED;
-				org_req->Scsi_Status = req->Scsi_Status;
-				core_queue_completed_req(root->core, org_req);
-				core_unmap_data_buffer(req);
-				return;
-			}
-			break;
-
-		case CDB_CORE_DISABLE_WRITE_CACHE:
-			if (!(org_buf_ptr[6 + org_buf_ptr[3]] & MV_BIT(2))) {
-				dev->setting &= ~DEVICE_SETTING_WRITECACHE_ENABLED;
-				org_req->Scsi_Status = req->Scsi_Status;
-				core_queue_completed_req(root->core, org_req);
-				core_unmap_data_buffer(req);
-				return;
-			}
-			break;
-
-		case CDB_CORE_ENABLE_READ_AHEAD:
-			if (!(org_buf_ptr[16 + org_buf_ptr[3]] & MV_BIT(5))) {
-				dev->setting |= DEVICE_SETTING_READ_LOOK_AHEAD;
-				org_req->Scsi_Status = req->Scsi_Status;
-				core_queue_completed_req(root->core, org_req);
-				core_unmap_data_buffer(req);
-				return;
-			}
-			break;
-
-		case CDB_CORE_DISABLE_READ_AHEAD:
-			if (org_buf_ptr[16 + org_buf_ptr[3]] & MV_BIT(5)) {
-				dev->setting &= ~DEVICE_SETTING_READ_LOOK_AHEAD;
-				org_req->Scsi_Status = req->Scsi_Status;
-				core_queue_completed_req(root->core, org_req);
-				core_unmap_data_buffer(req);
-				return;
-			}
-			break;
-
-		default:
-			MV_DASSERT(MV_FALSE);
-			break;
-		}
-		break;
-
-	case APICDB0_PD:
-		switch (org_req->Cdb[1]) {
-		case APICDB1_PD_SETSETTING:
-			switch (org_req->Cdb[4]) {
-			case APICDB4_PD_SET_WRITE_CACHE_OFF:
-				if (!(org_buf_ptr[6 + org_buf_ptr[3]] & MV_BIT(2))) {
-					dev->setting &= ~DEVICE_SETTING_WRITECACHE_ENABLED;
-					org_req->Scsi_Status = req->Scsi_Status;
-					core_queue_completed_req(root->core, org_req);
-					core_unmap_data_buffer(req);
-					return;
-				}
-				break;
-
-			case APICDB4_PD_SET_WRITE_CACHE_ON:
-				if (org_buf_ptr[6 + org_buf_ptr[3]] & MV_BIT(2)) {
-					dev->setting |= DEVICE_SETTING_WRITECACHE_ENABLED;
-					org_req->Scsi_Status = req->Scsi_Status;
-					core_queue_completed_req(root->core, org_req);
-					core_unmap_data_buffer(req);
-					return;
-				}
-				break;
-			default:
-				MV_DASSERT(MV_FALSE);
-				break;
-			}
-			break;
-		default:
-			MV_DASSERT(MV_FALSE);
-			break;
-		}
-		break;
-
-	default:
-		MV_DASSERT(MV_FALSE);
-		break;
-	}
-
-	new_req = get_intl_req_resource(root, 24);
-
-	if (new_req == NULL) {
-		if (req->Sense_Info_Buffer != NULL)
-			((MV_PU8)org_req->Sense_Info_Buffer)[0] = ERR_NO_RESOURCE;
-
-		org_req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-		core_unmap_data_buffer(req);
-		core_queue_completed_req(root->core, org_req);
-		return;
-	}
-
-	new_req->Cdb[0] = SCSI_CMD_MODE_SELECT_6;
-	new_req->Cdb[1] = 0x11;
-	new_req->Cdb[4] = 24;
-
-	new_req->Device_Id = dev->base.id;
-	new_req->Cmd_Flag = 0;
-	new_req->Completion = ssp_ata_intl_req_callback;
-
-	new_buf_ptr = core_map_data_buffer(new_req);
-
-	MV_CopyMemory(&new_buf_ptr[4], &(org_buf_ptr[4 + org_buf_ptr[3]]), 20);
-
-        /* Mode Data Length = 0 */
-        /* When using the MODE SELECT command, this field is reserved */
-	new_buf_ptr[0] = 0;
-	new_buf_ptr[1] = 0;
-	new_buf_ptr[2] = 0;
-	new_buf_ptr[3] = 0;
-	new_buf_ptr[4] &= 0x7F;
-
-	switch (org_req->Cdb[0]) {
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		if (org_req->Cdb[1] != CDB_CORE_MODULE)
-		        MV_DASSERT(MV_FALSE);
-
-		switch (org_req->Cdb[2]) {
-		case CDB_CORE_ENABLE_WRITE_CACHE:
-			new_buf_ptr[6] |= MV_BIT(2);
-			break;
-
-		case CDB_CORE_DISABLE_WRITE_CACHE:
-			new_buf_ptr[6] &= ~MV_BIT(2);
-			break;
-
-		case CDB_CORE_ENABLE_READ_AHEAD:
-			new_buf_ptr[16] &= ~MV_BIT(5);
-			break;
-
-		case CDB_CORE_DISABLE_READ_AHEAD:
-			new_buf_ptr[16] |= MV_BIT(5);
-			break;
-
-		default:
-			MV_DASSERT(MV_FALSE);
-			break;
-		}
-		break;
-
-	case APICDB0_PD:
-		switch (org_req->Cdb[1]) {
-		case APICDB1_PD_SETSETTING:
-			switch (org_req->Cdb[4]) {
-			case APICDB4_PD_SET_WRITE_CACHE_OFF:
-				new_buf_ptr[6] &= ~MV_BIT(2);
-				break;
-			case APICDB4_PD_SET_WRITE_CACHE_ON:
-				new_buf_ptr[6] |= MV_BIT(2);
-				break;
-			default:
-				MV_DASSERT(MV_FALSE);
-				break;
-			}
-			break;
-		default:
-			MV_DASSERT(MV_FALSE);
-			break;
-		}
-		break;
-
-		default:
-		MV_DASSERT(MV_FALSE);
-		break;
-	}
-
-	core_unmap_data_buffer(req);
-	core_unmap_data_buffer(new_req);
-
-	sas_replace_org_req(root, org_req, new_req);
-}
-
-MV_VOID ssp_prepare_task_management_command(pl_root *root,
-	domain_device *dev, mv_command_header *cmd_header,
-	mv_command_table *cmd_table,  MV_Request *req)
-{
-	MV_U64 val64;
-	MV_U16 tag;
-	MV_U32 ch_dword_0 = 0;
-
-	/*
-	 * CDB[3..4] = tag
-	 * CDB[5] = task function
-	 * CDB[6..13] = lun
-	 */
-
-	tag = (MV_U16)(req->Cdb[4]<<8) + (MV_U16)req->Cdb[3];
-	cmd_header->frame_len = MV_CPU_TO_LE16(
-		(((sizeof(ssp_task_iu) + sizeof(ssp_frame_header)) / 4) & CH_FRAME_LEN_MASK)
-		| (1<<CH_MAX_SIMULTANEOUS_CONNECTIONS_SHIFT));
-	cmd_header->tag |= req->Tag << root->max_cmd_slot_width;
-
-	MV_CopyMemory(&cmd_table->table.ssp_cmd_table.data.task.lun, &req->Cdb[6], 8);
-	cmd_table->table.ssp_cmd_table.data.task.tag = MV_CPU_TO_BE16(tag);
-	cmd_table->table.ssp_cmd_table.data.task.task_function = req->Cdb[5];
-
-        ((MV_PU16)cmd_table->table.ssp_cmd_table.data.task.reserved1)[0] = 0;
-        cmd_table->table.ssp_cmd_table.data.task.reserved2 = 0;
-        MV_ZeroMemory(cmd_table->table.ssp_cmd_table.data.task.reserved3, 14);
-
-	ch_dword_0 |= FRAME_TYPE_TASK << CH_SSP_FRAME_TYPE_SHIFT;
-	cmd_header->ctrl_nprd |= MV_CPU_TO_LE32(ch_dword_0);
-
-	cmd_table->open_address_frame.frame_control = (ADDRESS_OPEN_FRAME << OF_FRAME_TYPE_SHIFT |\
-		PROTOCOL_SSP << OF_PROT_TYPE_SHIFT | OF_MODE_INITIATOR << OF_MODE_SHIFT);
-        ((MV_PU8)&cmd_table->open_address_frame)[1] = dev->negotiated_link_rate;
-	*(MV_U16 *)(cmd_table->open_address_frame.connect_tag) =
-		MV_CPU_TO_BE16(dev->base.id + 1);
-	U64_ASSIGN(val64, MV_CPU_TO_BE64(dev->sas_addr));
-	MV_CopyMemory(cmd_table->open_address_frame.dest_sas_addr, &val64, 8);
-}
-
-MV_VOID ssp_prepare_io_command(pl_root *root, domain_device *dev,
-	mv_command_header *cmd_header, mv_command_table *cmd_table,
-	MV_Request *req)
-{
-	MV_U64 val64;
-	domain_enclosure *enc = NULL;
-	MV_BOOLEAN is_enclosure = MV_FALSE;
-	MV_U32 ch_dword_0 = 0;
-	domain_base *base = (domain_base*)dev;
-
-	mv_int_to_reqlun(base->LUN, req->lun);
-	if(dev->base.type == BASE_TYPE_DOMAIN_ENCLOSURE){
-		is_enclosure = MV_TRUE;
-		enc = (domain_enclosure *)dev;
-	}
-
-	if(!is_enclosure) {
-		if (dev->setting & DEVICE_SETTING_PI_ENABLED)
-		{
-
-			MV_ZeroMemory(&cmd_table->table.ssp_cmd_table.data.command.pir, sizeof(protect_info_record));
-	              cmd_table->table.ssp_cmd_table.data.command.pir.USR_DT_SZ  =
-				MV_CPU_TO_LE16((dev->sector_size - 8)/4);
-			cmd_header->data_xfer_len +=
-				MV_CPU_TO_LE32((cmd_header->data_xfer_len/
-					(dev->sector_size-8))
-					*8);
-
-			switch(req->Cdb[0])
-			{
-			/*READ*/
-			case SCSI_CMD_READ_10:
-			case SCSI_CMD_READ_12:
-			case SCSI_CMD_READ_16:
-					cmd_table->table.ssp_cmd_table.data.command.pir.T10_CHK_EN = 1;
-					cmd_table->table.ssp_cmd_table.data.command.pir.T10_CHK_MSK = 0xf3;
-
-			/*VERIFY*/
-			case SCSI_CMD_VERIFY_10:
-			case SCSI_CMD_VERIFY_12:
-			case SCSI_CMD_VERIFY_16:
-			/*WRITE*/
-			case SCSI_CMD_WRITE_10:
-			case SCSI_CMD_WRITE_12:
-			case SCSI_CMD_WRITE_16:
-			/*WRITE&VERIFY*/
-			case SCSI_CMD_WRITE_VERIFY_10:
-			case SCSI_CMD_WRITE_VERIFY_12:
-			case SCSI_CMD_WRITE_VERIFY_16:
-			/*WRITE SAME*/
-			case SCSI_CMD_WRITE_SAME_10:
-			case SCSI_CMD_WRITE_SAME_16:
-			/*XDWRITE*/
-			case SCSI_CMD_XDWRITE_10:
-			/*XPWRITE*/
-			case SCSI_CMD_XPWRITE_10:
-			/*XDREAD*/
-			case SCSI_CMD_XDREAD_10:
-			/*XDWRITEREAD*/
-			case SCSI_CMD_XDWRITEREAD_10:
-				if ((req->Cdb[0] & 0xf0) != 0x80) {
-					cmd_table->table.ssp_cmd_table.data.command.pir.LBRT_GEN_VAL =
-						MV_CPU_TO_LE32(req->Cdb[5] +
-							(req->Cdb[4]<<8) +
-							(req->Cdb[3]<<16) +
-							(req->Cdb[2]<<24));
-				} else {
-					cmd_table->table.ssp_cmd_table.data.command.pir.LBRT_GEN_VAL =
-						MV_CPU_TO_LE32(req->Cdb[9] +
-							(req->Cdb[8]<<8) +
-							(req->Cdb[7]<<16) +
-							(req->Cdb[6]<<24));
-				}
-				cmd_table->table.ssp_cmd_table.data.command.pir.LBRT_CHK_VAL =
-					cmd_table->table.ssp_cmd_table.data.command.pir.LBRT_GEN_VAL;
-				cmd_table->table.ssp_cmd_table.data.command.pir.INCR_LBRT = 1;
-				cmd_table->table.ssp_cmd_table.data.command.pir.CHK_DSBL_MD = 1;
-
-				if (req->EEDPFlags & 0x3)
-					cmd_table->table.ssp_cmd_table.data.command.pir.T10_RMV_EN = 1;
-				else if (req->EEDPFlags & 0x4)
-					cmd_table->table.ssp_cmd_table.data.command.pir.T10_INSRT_EN = 1;
-
-				cmd_header->pir_fmt = MV_CPU_TO_LE16(0xA000);
-				ch_dword_0 |= CH_SSP_VERIFY_DATA_LEN;
-
-			case SCSI_CMD_FORMAT_UNIT:
-				ch_dword_0 |= CH_PI_PRESENT;
-				break;
-			default:
-				ch_dword_0 &= (~ CH_SSP_VERIFY_DATA_LEN);
-				break;
-			}
-		}
-	}
-	cmd_header->frame_len =
-		MV_CPU_TO_LE16((((sizeof(ssp_command_iu) + sizeof(ssp_frame_header)+3)/4) & CH_FRAME_LEN_MASK)
-		| (1<<CH_MAX_SIMULTANEOUS_CONNECTIONS_SHIFT));
-	cmd_header->tag |= req->Tag << root->max_cmd_slot_width;
-	ch_dword_0 |= FRAME_TYPE_COMMAND << CH_SSP_FRAME_TYPE_SHIFT;
-	cmd_header->ctrl_nprd |= MV_CPU_TO_LE32(ch_dword_0);
-
-	MV_ZeroMemory(&cmd_table->table.ssp_cmd_table.data.command.command_iu,
-		sizeof(ssp_command_iu));
-	MV_CopyMemory(&cmd_table->table.ssp_cmd_table.data.command.command_iu.cdb[0],
-		&req->Cdb[0], 16);
-	MV_CopyMemory(&cmd_table->table.ssp_cmd_table.data.command.command_iu.lun[0],
-		&req->lun[0], 8);
-
-	cmd_table->open_address_frame.frame_control = (ADDRESS_OPEN_FRAME << OF_FRAME_TYPE_SHIFT |\
-		PROTOCOL_SSP << OF_PROT_TYPE_SHIFT | OF_MODE_INITIATOR << OF_MODE_SHIFT);
-
-	if(is_enclosure)
-		((MV_PU8)&cmd_table->open_address_frame)[1] = enc->negotiated_link_rate;
-	else
-		((MV_PU8)&cmd_table->open_address_frame)[1] = dev->negotiated_link_rate;
-
-	*(MV_U16 *)(cmd_table->open_address_frame.connect_tag) = MV_CPU_TO_BE16(dev->base.id + 1);
-
-	if(is_enclosure)
-		U64_ASSIGN(val64, MV_CPU_TO_BE64(enc->sas_addr));
-	else
-		U64_ASSIGN(val64, MV_CPU_TO_BE64(dev->sas_addr));
-
-	MV_CopyMemory(cmd_table->open_address_frame.dest_sas_addr, &val64, 8);
-}
-
-MV_VOID ssp_prepare_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmd_header_p, MV_PVOID cmd_table_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *dev = (domain_device *)dev_p;
-	mv_command_header *cmd_header = (mv_command_header *)cmd_header_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-
-	cmd_header->ctrl_nprd |= MV_CPU_TO_LE32(CH_SSP_TP_RETRY);
-	cmd_header->max_rsp_frame_len = MV_CPU_TO_LE16(MAX_RESPONSE_FRAME_LENGTH >> 2);
-
-	if (IS_A_TSK_REQ(req)) {
-		ssp_prepare_task_management_command(
-			root, dev, cmd_header, cmd_table, req);
-	} else {
-		ssp_prepare_io_command(
-			root, dev, cmd_header, cmd_table, req);
-	}
-}
-
-MV_VOID ssp_send_command(MV_PVOID root_p, MV_PVOID dev_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *dev = (domain_device *)dev_p;
-	domain_port *port = dev->base.port;
-	core_context *ctx = req->Context[MODULE_CORE];
-
-	MV_U8 phy_map;
-	MV_U32 entry_nm;
-
-	entry_nm = prot_get_delv_q_entry(root);
-
-	if (CORE_IS_EH_REQ(ctx))
-		phy_map = port->asic_phy_map;
-	else
-		phy_map = core_wideport_load_balance_asic_phy_map(port, dev);
-
-	if (IS_A_TSK_REQ(req)) {
-		root->delv_q[entry_nm] = MV_CPU_TO_LE32(TXQ_MODE_I | ctx->slot | \
-			phy_map  << TXQ_PHY_SHIFT | TXQ_CMD_SSP |\
-						1 << TXQ_PRIORITY_SHIFT);
-	} else {
-		root->delv_q[entry_nm] = MV_CPU_TO_LE32(TXQ_MODE_I | ctx->slot | \
-			phy_map  << TXQ_PHY_SHIFT | TXQ_CMD_SSP);
-	}
-
-	prot_write_delv_q_entry(root, entry_nm);
-}
-
-/* this includes error handling for SMP, STP and SSP*/
-MV_VOID sas_process_command_error(pl_root *root, domain_base *base,
-	mv_command_table *cmd_table, err_info_record *err_info, MV_Request *req)
-{
-	domain_port *port = base->port;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_U32 error = MV_LE32_TO_CPU(err_info->err_info_field_1);
-
-	MV_ASSERT(base == get_device_by_id(root->lib_dev, req->Device_Id));
-
-	if (error & CMD_ISS_STPD){
-		ctx->error_info |= EH_INFO_CMD_ISS_STPD;
-		base->cmd_issue_stopped = MV_TRUE;
-	}
-
-	if (error & NO_DEST_ERR){
-		req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-		/* suppose CMD_ISS_STPD is not set. otherwise need start issue somewhere */
-		MV_ASSERT(!(ctx->error_info & EH_INFO_NEED_RETRY));
-		return;
-	}
-
-#define SAS_TIMEOUT_REASON (OPEN_TMOUT_ERR| NAK_ERR | ACK_NAK_TO | RD_DATA_OFFST_ERR |\
-		XFR_RDY_OFFST_ERR | UNEXP_XFER_RDY_ERR | DATA_OVR_UNDR_FLW_ERR | WD_TMR_TO_ERR |\
-		SYNC_ERR | TX_STOPPED_EARLY | CNCTN_RT_NT_SPRTD_ERR)
-
-        if (error & SAS_TIMEOUT_REASON) {
-			if (IS_A_SMP_REQ(req)) {
-				req->Scsi_Status = REQ_STATUS_ERROR;
-			} else {
-				req->Scsi_Status = REQ_STATUS_TIMEOUT;
-			}
-
-			if (error & (WD_TMR_TO_ERR | TX_STOPPED_EARLY))
-				ctx->error_info |= EH_INFO_WD_TO_RETRY;
-
-	        ctx->error_info |= EH_INFO_NEED_RETRY;
-		return;
-	}
-
-	if (error & TFILE_ERR) {
-		/* SSP or STP requests */
-		MV_DASSERT(!IS_A_SMP_REQ(req));
-		sata_handle_taskfile_error(root, req);
-		return;
-	}
-
-	if (error & RESP_BFFR_OFLW) {
-		CORE_EH_PRINT(("Response Buffer Overflow Condition meet.\n"));
-	}
-	MV_ASSERT(((MV_U64 *)err_info)->value != 0);
-
-	CORE_EH_PRINT(("attention: req %p[0x%x] unknown error 0x%08x 0x%08x! "\
-		"treat as media error.\n",\
-		req, req->Cdb[0],
-		((MV_U64 *)err_info)->parts.high, \
-		((MV_U64 *)err_info)->parts.low));
-
-	req->Scsi_Status = REQ_STATUS_ERROR;
-	ctx->error_info |= EH_INFO_NEED_RETRY;
-	return;
-}
-
-typedef struct mv_scsi_sense_hdr {
-        MV_U8 response_code;       /* permit: 0x0, 0x70, 0x71, 0x72, 0x73 */
-        MV_U8 sense_key;
-        MV_U8 asc;
-        MV_U8 ascq;
-}*MV_PSB_HDR,MV_SB_HDR;
-
-MV_BOOLEAN ssp_sense_valid(MV_PSB_HDR sshdr)
-{
-	if (!sshdr)
-		return MV_FALSE;
-
-	return (sshdr->response_code & 0x70) == 0x70 ;
-}
-
-MV_BOOLEAN ssp_normalize_sense(MV_PU8 sense_buffer, MV_U32 sb_len, MV_PSB_HDR sshdr)
-{
-	if (!sense_buffer || !sb_len)
-		return MV_FALSE;
-
-	MV_ZeroMemory(sshdr,sizeof(*sshdr));
-
-	sshdr->response_code = (sense_buffer[0] & 0x7f);
-
-	if (!ssp_sense_valid(sshdr))
-		return MV_FALSE;
-
-	if (sshdr->response_code >= 0x72) {
-                if (sb_len > 1)
-                        sshdr->sense_key = (sense_buffer[1] & 0xf);
-                if (sb_len > 2)
-                        sshdr->asc = sense_buffer[2];
-                if (sb_len > 3)
-                        sshdr->ascq = sense_buffer[3];
-        } else {
-                if (sb_len > 2)
-                        sshdr->sense_key = (sense_buffer[2] & 0xf);
-                if (sb_len > 7) {
-                        sb_len = (sb_len < (MV_U32)(sense_buffer[7] + 8)) ?
-                                         sb_len : (MV_U32)(sense_buffer[7] + 8);
-                        if (sb_len > 12)
-                                sshdr->asc = sense_buffer[12];
-                        if (sb_len > 13)
-                                sshdr->ascq = sense_buffer[13];
-                }
-        }
-	return MV_TRUE;
-}
-
-/* if return MV_TRUE, means we want to retry this request */
-MV_BOOLEAN parse_sense_error(MV_PU8 sense_buffer, MV_U32 sb_len)
-{
-	MV_SB_HDR sshdr;
-
-	if(!ssp_normalize_sense(sense_buffer, sb_len, &sshdr))
-		return MV_FALSE;
-
-	/* Mode Parameters changed */
-	if (sshdr.sense_key == SCSI_SK_UNIT_ATTENTION &&
-		sshdr.asc == 0x2a && sshdr.ascq == 0x01)
-		return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-MV_VOID ssp_process_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *dev = (domain_device *)dev_p;
-	 core_extension *core = (core_extension *)root->core;
-	MV_U32 cmpl_q = *(MV_PU32)cmpl_q_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	err_info_record *err_info;
-	ssp_response_iu *resp_iu;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_U32 sense_length;
-	MV_SB_HDR sshdr;
-	domain_device *device;
-	MV_Sense_Data *sense_data;
-
-	err_info = prot_get_command_error_info(cmd_table, &cmpl_q);
-	if (err_info) {
-		CORE_EH_PRINT(("dev %d.\n", req->Device_Id));
-		sas_process_command_error(
-			root, &dev->base, cmd_table, err_info, req);
-		return;
-	}
-
-	if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC) &&
-		(req->Cdb[1] == CDB_CORE_MODULE)) {
-		switch (req->Cdb[2])
-		{
-		}
-	}
-
-	resp_iu = &cmd_table->status_buff.data.ssp_resp;
-	/* if response frame is not transferred, success */
-	/* if response frame is transfered and status is GOOD, success */
-	if (!(cmpl_q & RXQ_RSPNS_XFRD) || (cmpl_q & RXQ_RSPNS_XFRD && \
-		(resp_iu->status==SCSI_STATUS_GOOD))) {
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		return;
-	}
-
-	sense_length = MV_BE32_TO_CPU(resp_iu->sense_data_len);
-	if( sense_length && (resp_iu->data_pres & SENSE_ONLY) &&
-		ssp_normalize_sense(resp_iu->data, sense_length, &sshdr)) {
-			CORE_EH_PRINT(("dev %d req 0x%x status 0x%x sense length %d " \
-				"sense(key 0x%x, asc 0x%x ascq 0x%x).\n", \
-			        dev->base.id,req->Cdb[0], resp_iu->status, sense_length, \
-			sshdr.sense_key, sshdr.asc, sshdr.ascq));
-
-	}
-
-	switch (resp_iu->status) {
-	case SCSI_STATUS_CHECK_CONDITION:
-		if ((req->Cdb[0] == SCSI_CMD_REPORT_LUN) && (IS_ENCLOSURE(dev))) {
-			MV_U8 *buf = core_map_data_buffer(req);
-
-			if (buf != NULL) {
-				MV_ZeroMemory(buf, req->Data_Transfer_Length);
-				buf[3] = 0x08;
-				req->Scsi_Status = REQ_STATUS_SUCCESS;
-				core_unmap_data_buffer(req);
-				return;
-			} else {
-			core_unmap_data_buffer(req);
-		}
-		}else{
-			if (req->Cdb[0] == SCSI_CMD_START_STOP_UNIT) {
-				HBA_SleepMillisecond(NULL,500);
-			}
-			sense_data = (MV_Sense_Data *)&resp_iu->data[0];
-			if(sense_data->SenseKey == UNIT_ATTENTION ){
-				if((sense_data->AdditionalSenseCode== 0x3F) && (sense_data->AdditionalSenseCodeQualifier ==0x0e)){
-					CORE_PRINT(("REPORT LUN DATA Changed\n"));
-					device =(domain_device *) get_device_by_id(root->lib_dev,
-						get_id_by_targetid_lun(core, get_device_targetid(root->lib_dev, req->Device_Id), 0));
-					if(device == NULL)
-						break;
-					if(device->state == DEVICE_STATE_INIT_DONE){
-						device->state = DEVICE_STATE_REPORT_LUN;
-							core_queue_init_entry(root, &device->base, MV_FALSE);
-					}
-				}
-			}
-		}
-
-		if (parse_sense_error(resp_iu->data, sense_length)) {
-			req->Scsi_Status = REQ_STATUS_ERROR;
-			ctx->error_info |= EH_INFO_NEED_RETRY;
-		} else {
-			sense_length = MV_MIN(req->Sense_Info_Buffer_Length,
-				sense_length);
-			if (sense_length != 0) {
-				req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-
-				MV_CopyMemory(req->Sense_Info_Buffer,
-					resp_iu->data, sense_length);
-			} else {
-				req->Scsi_Status = REQ_STATUS_ERROR;
-			}
-		}
-		break;
-
-	case SCSI_STATUS_FULL:
-		if (dev->base.outstanding_req > 1) {
-			dev->base.queue_depth = dev->base.outstanding_req - 1;
-		} else {
-			dev->base.queue_depth = 1;
-		}
-
-		CORE_DPRINT(("set queue depth to %d.\n", dev->base.queue_depth));
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		ctx->error_info |= EH_INFO_NEED_RETRY;
-		break;
-
-	default:
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		break;
-	}
-
-        if (req->Scsi_Status != REQ_STATUS_SUCCESS)
-                core_generate_error_event(root->core, req);
-}
-
-extern MV_VOID sata_prepare_command_header(MV_Request *req,
-	mv_command_header *cmd_header, mv_command_table *cmd_table,
-	MV_U8 tag, MV_U8 pm_port);
-extern MV_VOID sata_prepare_command_table(MV_Request *req,
-	mv_command_table *cmd_table, ata_taskfile *taskfile, MV_U8 pm_port);
-
-MV_VOID stp_prepare_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmd_header_p, MV_PVOID cmd_table_p, MV_Request *req)
-{
-	domain_device *device = (domain_device *)dev_p;
-	mv_command_header *cmd_header = (mv_command_header *)cmd_header_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	ata_taskfile taskfile;
-	MV_BOOLEAN ret;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_U8 tag;
-	MV_U64 val64;
-
-	if (req->Cmd_Flag & CMD_FLAG_NCQ) {
-		sata_get_ncq_tag(device, req);
-		tag = ctx->ncq_tag;
-	} else {
-		tag = req->Tag;
-	}
-
-	ret = ata_fill_taskfile(device, req, tag, &taskfile);
-
-	if (!ret) {
-		MV_DASSERT(MV_FALSE);
-	}
-
-	sata_prepare_command_header(req, cmd_header, cmd_table, tag,
-		device->pm_port);
-	sata_prepare_command_table(req, cmd_table, &taskfile, device->pm_port);
-
-	cmd_table->open_address_frame.frame_control = (ADDRESS_OPEN_FRAME << OF_FRAME_TYPE_SHIFT |\
-		PROTOCOL_STP << OF_PROT_TYPE_SHIFT | OF_MODE_INITIATOR << OF_MODE_SHIFT);
-
-        ((MV_PU8)&cmd_table->open_address_frame)[1] = device->negotiated_link_rate;
-	*(MV_U16 *)cmd_table->open_address_frame.connect_tag =
-		MV_CPU_TO_BE16(device->base.id+1);
-	U64_ASSIGN(val64, MV_CPU_TO_BE64(device->sas_addr));
-	MV_CopyMemory(cmd_table->open_address_frame.dest_sas_addr, &val64, 8);
-}
-
-MV_VOID stp_process_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *dev = (domain_device *)dev_p;
-	MV_U32 cmpl_q = *(MV_PU32)cmpl_q_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	err_info_record *err_info;
-
-	err_info = prot_get_command_error_info(cmd_table, &cmpl_q);
-	if (err_info) {
-		CORE_EH_PRINT(("dev %d, req %p has error info.\n", req->Device_Id, req));
-		MV_DumpRequest(req, 0);
-		sas_process_command_error(
-			root, &dev->base, cmd_table, err_info, req);
-		return;
-	}
-
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	return;
-}
-
-MV_U8 smp_translate_reset_sata_phy_req(pl_root *root,
-	domain_expander *exp, MV_Request *req)
-{
-	MV_Request *new_req = NULL;
-	core_context *ctx, *phy_ctx;
-        domain_device *tmp_dev;
-
-	ctx = req->Context[MODULE_CORE];
-	if (ctx->type != CORE_CONTEXT_TYPE_RESET_SATA_PHY) MV_ASSERT(MV_FALSE);
-	ctx->u.smp_reset_sata_phy.req_remaining = 0;
-        req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-	for ( ; ctx->u.smp_reset_sata_phy.curr_dev_count <
-                ctx->u.smp_reset_sata_phy.total_dev_count;
-		ctx->u.smp_reset_sata_phy.curr_dev_count++) {
-
-		tmp_dev = List_GetFirstEntry(&exp->device_list, domain_device,
-                        base.exp_queue_pointer);
-                if (IS_STP(tmp_dev)) {
-                        new_req = smp_make_phy_crtl_by_id_req(exp,
-			        tmp_dev->parent_phy_id,
-			        LINK_RESET,
-					smp_physical_req_callback);
-                } else {
-                        List_AddTail(&tmp_dev->base.exp_queue_pointer, &exp->device_list);
-                        continue;
-                }
-
-                if (new_req) {
-                        List_AddTail(&tmp_dev->base.exp_queue_pointer, &exp->device_list);
-
-	                phy_ctx = (core_context *)new_req->Context[MODULE_CORE];
-	                phy_ctx->type = CORE_CONTEXT_TYPE_ORG_REQ;
-	                phy_ctx->u.org.org_req = req;
-
-	                if (CORE_IS_INIT_REQ(ctx))
-		                core_append_init_request(root, new_req);
-	                else if (CORE_IS_EH_REQ(ctx))
-		                core_queue_eh_req(root, new_req);
-	                else
-		                core_append_request(root, new_req);
-
-	                ctx->u.smp_reset_sata_phy.req_remaining++;
-
-                } else {
-                        List_Add(&tmp_dev->base.exp_queue_pointer, &exp->device_list);
-
-	                if (ctx->u.smp_reset_sata_phy.req_remaining != 0) {
-		                return MV_QUEUE_COMMAND_RESULT_REPLACED;
-	                } else {
-		                return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-	                }
-                }
-        }
-
-	if (ctx->u.smp_reset_sata_phy.req_remaining > 0)
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_U8 smp_translate_clear_aff_all_req(pl_root *root,
-	domain_expander *exp, MV_Request *req)
-{
-	MV_Request *new_req = NULL;
-	core_context *ctx, *phy_ctx;
-	domain_base *base;
-	domain_device *tmp_dev;
-	MV_U8 state;
-
-	ctx = req->Context[MODULE_CORE];
-	MV_ASSERT(ctx->type == CORE_CONTEXT_TYPE_CLEAR_AFFILIATION);
-	ctx->u.smp_clear_aff.req_remaining = 0;
-	state = ctx->u.smp_clear_aff.state;
-        req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-        for ( ; ctx->u.smp_clear_aff.curr_dev_count <
-                ctx->u.smp_clear_aff.total_dev_count;
-                ctx->u.smp_clear_aff.curr_dev_count++) {
-
-                switch (state) {
-                case CLEAR_AFF_STATE_REPORT_PHY_SATA:
-
-                        tmp_dev = List_GetFirstEntry(&exp->device_list, domain_device,
-                                base.exp_queue_pointer);
-                        if (IS_STP(tmp_dev)) {
-                                new_req = smp_make_report_phy_sata_by_id_req(exp,
-											tmp_dev->parent_phy_id,
-											smp_physical_req_callback);
-                                if (new_req) {
-                                        List_AddTail(&tmp_dev->base.exp_queue_pointer,
-                                                &exp->device_list);
-                                } else {
-                                        List_Add(&tmp_dev->base.exp_queue_pointer,
-                                                &exp->device_list);
-                                }
-                        } else {
-                                List_AddTail(&tmp_dev->base.exp_queue_pointer,
-                                        &exp->device_list);
-                                continue;
-                        }
-	                break;
-
-                case CLEAR_AFF_STATE_CLEAR_AFF:
-                        tmp_dev = List_GetFirstEntry(&exp->device_list, domain_device,
-                                base.exp_queue_pointer);
-                        if (tmp_dev->status & DEVICE_STATUS_NEED_RESET) {
-                                new_req = smp_make_phy_crtl_by_id_req(exp,
-			                tmp_dev->parent_phy_id,
-			                HARD_RESET,
-			                smp_physical_req_callback);
-                        } else if (tmp_dev->status & DEVICE_STATUS_NEED_CLEAR) {
-		                new_req = smp_make_phy_crtl_by_id_req(exp,
-			                tmp_dev->parent_phy_id,
-			                CLEAR_AFFILIATION,
-			                smp_physical_req_callback);
-                        } else {
-                                List_AddTail(&tmp_dev->base.exp_queue_pointer,
-                                        &exp->device_list);
-                                continue;
-                        }
-
-                        if (new_req) {
-                                tmp_dev->status &= ~(DEVICE_STATUS_NEED_RESET |
-                                        DEVICE_STATUS_NEED_CLEAR);
-                                List_AddTail(&tmp_dev->base.exp_queue_pointer,
-                                        &exp->device_list);
-                        } else {
-                                List_Add(&tmp_dev->base.exp_queue_pointer,
-                                        &exp->device_list);
-                        }
-	                ctx->u.smp_clear_aff.need_wait = MV_TRUE;
-	                break;
-                default:
-	                MV_ASSERT(MV_FALSE);
-	                break;
-                }
-
-	        if (new_req) {
-		        phy_ctx = (core_context *)new_req->Context[MODULE_CORE];
-		        phy_ctx->type = CORE_CONTEXT_TYPE_ORG_REQ;
-		        phy_ctx->u.org.org_req = req;
-
-		        if (CORE_IS_INIT_REQ(ctx))
-			        core_append_init_request(root, new_req);
-		        else if (CORE_IS_EH_REQ(ctx))
-			        core_queue_eh_req(root, new_req);
-		        else
-			        core_append_request(root, new_req);
-
-		        ctx->u.smp_clear_aff.req_remaining++;
-	        } else {
-		        if (ctx->u.smp_clear_aff.req_remaining != 0) {
-			        return MV_QUEUE_COMMAND_RESULT_REPLACED;
-		        } else {
-			        return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-		        }
-                }
-        }
-
-	if (ctx->u.smp_clear_aff.req_remaining > 0)
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_U8 smp_translate_phy_req(pl_root *root, domain_expander *exp,
-	MV_Request *req)
-{
-	MV_Request *new_req = NULL;
-	core_context *ctx;
-	smp_virtual_config_route_buffer *buf;
-	MV_U8 i, j, phy_id;
-
-	switch (req->Cdb[2]) {
-	case CDB_CORE_SMP_VIRTUAL_DISCOVER:
-		ctx = req->Context[MODULE_CORE];
-		CORE_DPRINT(("discover: phy count = %d\n", exp->phy_count));
-		ctx->u.smp_discover.req_remaining = 0;
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		for ( ; ctx->u.smp_discover.current_phy_id < exp->phy_count;
-			ctx->u.smp_discover.current_phy_id++) {
-			new_req = smp_make_discover_req(exp, req,
-				ctx->u.smp_discover.current_phy_id, smp_physical_req_callback);
-			if (new_req) {
-				core_append_init_request(root, new_req);
-				ctx->u.smp_discover.req_remaining++;
-			} else {
-				if (ctx->u.smp_discover.req_remaining != 0) {
-					return MV_QUEUE_COMMAND_RESULT_REPLACED;
-				} else {
-					return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-				}
-			}
-		}
-		if (ctx->u.smp_discover.req_remaining == 0)
-			MV_ASSERT(MV_FALSE);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case CDB_CORE_SMP_VIRTUAL_CONFIG_ROUTE:
-		ctx = req->Context[MODULE_CORE];
-		buf = (smp_virtual_config_route_buffer *)core_map_data_buffer(req);
-
-		CORE_DPRINT(("smp config: phy %d/%d addr %d/%d.\n",\
-			ctx->u.smp_config_route.current_phy, \
-			ctx->u.smp_config_route.phy_count,\
-			ctx->u.smp_config_route.current_addr, \
-			ctx->u.smp_config_route.address_count));
-		ctx->u.smp_config_route.req_remaining = 0;
-                req->Scsi_Status = REQ_STATUS_SUCCESS;
-		for (i=ctx->u.smp_config_route.current_phy;
-			i<ctx->u.smp_config_route.phy_count; i++) {
-			phy_id = buf->phy_id[i];
-
-			for (j=ctx->u.smp_config_route.current_addr;
-				j<ctx->u.smp_config_route.address_count; j++) {
-
-				new_req = smp_make_config_route_req(exp, req,
-					exp->route_table[phy_id], phy_id, &buf->sas_addr[j],
-					smp_physical_req_callback);
-				if (new_req) {
-					exp->route_table[phy_id]++;
-					core_append_init_request(root, new_req);
-					ctx->u.smp_config_route.req_remaining++;
-				} else {
-					ctx->u.smp_config_route.current_phy = i;
-					ctx->u.smp_config_route.current_addr = j;
-                                        core_unmap_data_buffer(req);
-					if (ctx->u.smp_config_route.req_remaining == 0) {
-						return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-					} else {
-						return MV_QUEUE_COMMAND_RESULT_REPLACED;
-					}
-				}
-			}
-			ctx->u.smp_config_route.current_addr = 0;
-		}
-		ctx->u.smp_config_route.current_phy = ctx->u.smp_config_route.phy_count;
-		ctx->u.smp_config_route.current_addr = ctx->u.smp_config_route.address_count;
-                core_unmap_data_buffer(req);
-		if (ctx->u.smp_config_route.req_remaining == 0)
-			MV_ASSERT(MV_FALSE);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case CDB_CORE_SMP_VIRTUAL_RESET_SATA_PHY:
-		return (smp_translate_reset_sata_phy_req(root, exp, req));
-	case CDB_CORE_SMP_VIRTUAL_CLEAR_AFFILIATION_ALL:
-		return (smp_translate_clear_aff_all_req(root, exp,req));
-	default:
-		break;
-	}
-
-	req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_U8 smp_verify_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)dev_p;
-
-	if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC) &&
-		(req->Cdb[1] == CDB_CORE_MODULE) &&
-		(req->Cdb[2] == CDB_CORE_RESET_PORT)) {
-			mv_reset_phy(root, req->Cdb[3], MV_TRUE);
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC) &&
-		(req->Cdb[1] == CDB_CORE_MODULE) &&
-		(req->Cdb[2] != CDB_CORE_SMP)) {
-
-		return (smp_translate_phy_req(root, exp, req));
-	} else {
-		if (req->Data_Buffer == NULL) {
-			CORE_DPRINT(("smp req no data buffer.\n"));
-			req->Scsi_Status = REQ_STATUS_ERROR;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		}
-	}
-
-	return MV_QUEUE_COMMAND_RESULT_PASSED;
-}
-
-MV_U32 smp_get_request_len(MV_U8 function)
-{
-	MV_U32 req_len = 4;
-
-	switch (function) {
-	case REPORT_GENERAL:
-	case REPORT_MANUFACTURER_INFORMATION:
-		req_len += sizeof(struct SMPRequestGeneralInput) - sizeof(MV_U32);
-		break;
-	case REPORT_SELF_CONFIGURATION_STATUS:
-		req_len += sizeof(struct SMPRequestSelfConfigurationInput) -
-			sizeof(MV_U32);
-		break;
-	case DISCOVER:
-	case REPORT_PHY_ERROR_LOG:
-	case REPORT_PHY_SATA:
-	case REPORT_PHY_EVENT_INFORMATION:
-	case REPORT_PHY_BROADCAST_COUNTS:
-		req_len += sizeof(struct SMPRequestPhyInput) - sizeof(MV_U32);
-		break;
-	case REPORT_ROUTE_INFORMATION:
-		req_len += sizeof(struct SMPRequestRouteInformationInput) -
-			sizeof(MV_U32);
-		break;
-	case DISCOVER_LIST:
-		req_len += sizeof(struct SMPRequestDiscoverList) - sizeof(MV_U32);
-		break;
-	case REPORT_EXPANDER_ROUTE_TABLE:
-		req_len += sizeof(struct SMPRequestReportExpanderRouteTable) -
-			sizeof(MV_U32);
-		break;
-	case CONFIGURE_GENERAL:
-		req_len += sizeof(struct SMPRequestConfigureGeneral) - sizeof(MV_U32);
-		break;
-	case ENABLE_DISABLE_ZONING:
-		req_len += sizeof(struct SMPRequestEnableDisableZoning) -
-			sizeof(MV_U32);
-		break;
-	case ZONED_BROADCAST:
-		req_len += sizeof(struct SMPRequestZonedBroadcast) - sizeof(MV_U32);
-		break;
-	case CONFIGURE_ROUTE_INFORMATION:
-		req_len += sizeof(struct SMPRequestConfigureRouteInformation) -
-			sizeof(MV_U32);
-		break;
-	case PHY_CONTROL:
-		req_len += sizeof(struct SMPRequestPhyControl) - sizeof(MV_U32);
-		break;
-	case PHY_TEST:
-		req_len += sizeof(struct SMPRequestPhyTest) - sizeof(MV_U32);
-		break;
-	case CONFIGURE_PHY_EVENT_INFORMATION:
-		req_len += sizeof(struct SMPRequestConfigurePhyEventInformation) -
-			sizeof(MV_U32);
-		break;
-	}
-
-	return req_len;
-}
-
-MV_U32 smp_get_response_len(MV_U8 function)
-{
-	MV_U32 resp_len = 4;
-
-	switch (function) {
-	case REPORT_GENERAL:
-		resp_len += sizeof(struct SMPResponseReportGeneral) - sizeof(MV_U32);
-		break;
-	case REPORT_MANUFACTURER_INFORMATION:
-		resp_len += sizeof(struct SMPResponseReportManufacturerInformation) -
-			sizeof(MV_U32);
-		break;
-	case REPORT_SELF_CONFIGURATION_STATUS:
-		resp_len += sizeof(struct SMPResponseReportSelfConfigurationStatus) -
-			sizeof(MV_U32);
-		break;
-	case DISCOVER:
-		resp_len += sizeof(struct SMPResponseDiscover) - sizeof(MV_U32);
-		break;
-	case REPORT_PHY_ERROR_LOG:
-		resp_len += sizeof(struct SMPResponseReportPhyErrorLog) -
-			sizeof(MV_U32);
-		break;
-	case REPORT_PHY_SATA:
-		resp_len += sizeof(struct SMPResponseReportPhySATA) - sizeof(MV_U32);
-		break;
-	case REPORT_ROUTE_INFORMATION:
-		resp_len += sizeof(struct SMPResponseReportRouteInformation) -
-			sizeof(MV_U32);
-		break;
-	case REPORT_PHY_EVENT_INFORMATION:
-		resp_len += sizeof(struct SMPResponseReportPhyEventInformation) -
-			sizeof(MV_U32);
-		break;
-	case REPORT_PHY_BROADCAST_COUNTS:
-		resp_len += sizeof(struct SMPResponseReportBroadcastCounts) -
-			sizeof(MV_U32);
-		break;
-	case DISCOVER_LIST:
-		resp_len += sizeof(struct SMPResponseDiscoverList) - sizeof(MV_U32);
-		break;
-	case REPORT_EXPANDER_ROUTE_TABLE:
-		resp_len += sizeof(struct SMPResponseReportExpanderTable) -
-			sizeof(MV_U32);
-		break;
-	case CONFIGURE_GENERAL:
-	case ENABLE_DISABLE_ZONING:
-	case ZONED_BROADCAST:
-	case CONFIGURE_ROUTE_INFORMATION:
-	case PHY_CONTROL:
-	case PHY_TEST:
-	case CONFIGURE_PHY_EVENT_INFORMATION:
-		resp_len += sizeof(struct SMPResponseConfigureFunction) -
-			sizeof(MV_U32);
-		break;
-	}
-
-	return resp_len;
-}
-
-MV_VOID smp_prepare_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmd_header_p, MV_PVOID cmd_table_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)dev_p;
-	mv_command_header *cmd_header = (mv_command_header *)cmd_header_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	MV_PVOID buf_ptr = core_map_data_buffer(req);
-	smp_request *smp_req = (smp_request *)buf_ptr;
-	MV_U32 req_len;
-	MV_U64 val64;
-
-	cmd_header->max_rsp_frame_len = MAX_RESPONSE_FRAME_LENGTH >> 2;
-	req_len = smp_get_request_len(smp_req->function);
-	cmd_header->frame_len = MV_CPU_TO_LE16(((MV_U16)(req_len+3)/4) | (1<<CH_MAX_SIMULTANEOUS_CONNECTIONS_SHIFT));
-	cmd_header->tag |= req->Tag << root->max_cmd_slot_width;
-
-	cmd_table->open_address_frame.frame_control = (ADDRESS_OPEN_FRAME << OF_FRAME_TYPE_SHIFT |\
-		PROTOCOL_SMP << OF_PROT_TYPE_SHIFT | OF_MODE_INITIATOR << OF_MODE_SHIFT);
-	*(MV_U16 *)(cmd_table->open_address_frame.connect_tag) = MV_CPU_TO_BE16(0xffff);
-	((MV_PU8)&cmd_table->open_address_frame)[1] = exp->neg_link_rate;
-	U64_ASSIGN(val64, MV_CPU_TO_BE64(exp->sas_addr));
-	MV_CopyMemory(cmd_table->open_address_frame.dest_sas_addr,
-		&val64, 8);
-
-	MV_CopyMemory(&cmd_table->table.smp_cmd_table, buf_ptr, req_len);
-	core_unmap_data_buffer(req);
-}
-
-MV_VOID smp_send_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)dev_p;
-	domain_port *port = exp->base.port;
-	core_context *ctx = req->Context[MODULE_CORE];
-
-	MV_U8 phy_map;
-	MV_U32 entry_nm;
-
-	entry_nm = prot_get_delv_q_entry(root);
-	phy_map = port->asic_phy_map;
-
-	root->delv_q[entry_nm] = MV_CPU_TO_LE32(TXQ_MODE_I | ctx->slot | \
-		phy_map << TXQ_PHY_SHIFT | TXQ_CMD_SMP);
-
-	prot_write_delv_q_entry(root, entry_nm);
-}
-
-MV_VOID smp_process_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table_p,
-	MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)dev_p;
-	MV_U32 cmpl_q = *(MV_PU32)cmpl_q_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	err_info_record *err_info;
-	smp_response *smp_resp =
-		(smp_response *)cmd_table->status_buff.data.smp_resp;
-	MV_U32 resp_len;
-	MV_PVOID buf_ptr;
-	domain_port *port = exp->base.port;
-	MV_U8 i;
-
-	err_info = prot_get_command_error_info(cmd_table, &cmpl_q);
-	if (err_info) {
-		CORE_EH_PRINT(("dev %d has error info.\n", req->Device_Id));
-		/* error information record has some fields set. */
-		sas_process_command_error(
-			root, &exp->base, cmd_table, err_info, req);
-		return;
-	}
-
-	if (smp_resp->function_result == SMP_FUNCTION_ACCEPTED) {
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-                buf_ptr = core_map_data_buffer(req);
-		if (buf_ptr != NULL) {
-			if (cmd_table->status_buff.data.smp_resp[3] == 0) {
-				resp_len = smp_get_response_len(smp_resp->function);
-			} else {
-				/* get response len from RESPONSE LENGTH field of response data */
-				resp_len =4;
-				resp_len += cmd_table->status_buff.data.smp_resp[3] * 4;
-			}
-			resp_len = (resp_len < req->Data_Transfer_Length) ? resp_len :
-				req->Data_Transfer_Length;
-			MV_CopyMemory(buf_ptr, &cmd_table->status_buff.data.smp_resp,
-				resp_len);
-		}
-		core_unmap_data_buffer(req);
-	} else {
-                req->Scsi_Status = REQ_STATUS_SUCCESS;
-	}
-}
--- a/drivers/scsi/vanir/core/sas_base/sas_init.c
+++ /dev/null
@@ -1,704 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_sas.h"
-#include "core_internal.h"
-#include "core_manager.h"
-#include "core_util.h"
-
-#include "core_error.h"
-
-PMV_Request sas_make_read_capacity_req(pl_root *root, domain_device *device);
-PMV_Request sas_make_start_stop_unit_req(pl_root *root,
-	domain_device *device, MV_BOOLEAN start);
-PMV_Request sas_make_test_unit_ready_req(pl_root *root, domain_device *device,
-	MV_U8 control);
-static void sas_init_req_callback(MV_PVOID root_p, PMV_Request req);
-extern void sas_init_target_device(pl_root *root, domain_port *port,domain_device *dev,MV_U16 targetid, MV_U16 lun);
-extern void get_new_and_update_base_id(pl_root *root,domain_base *base);
-
-MV_BOOLEAN sas_init_state_machine(MV_PVOID dev)
-{
-	domain_device *device = (domain_device *)dev;
-	domain_port *port = device->base.port;
-	pl_root *root = device->base.root;
-	PMV_Request req = NULL;
-	domain_phy *phy;
-	MV_U8 i;
-
-	CORE_DPRINT(("dev %d state 0x%x.\n", device->base.id, device->state));
-
-	switch (device->state) {
-	case DEVICE_STATE_RESET_DONE:
-		if (!IS_BEHIND_EXP(device)) {
-			core_sleep_millisecond(root->core, 1);
-			for (i = 0; i < root->phy_num; i++) {
-				if (port->phy_map & MV_BIT(i)) {
-					phy = &root->phy[i];
-					WRITE_PORT_CONFIG_ADDR(root, phy,
-						CONFIG_PHY_CONTROL);
-					WRITE_PORT_CONFIG_DATA(root, phy, 0x00);
-				}
-			}
-		}
-
-		/* to do standard inquiry */
-		req = sas_make_inquiry_req(root, device, MV_FALSE, 0,
-			sas_init_req_callback);
-		break;
-
-	case DEVICE_STATE_INQUIRY_DONE:
-		/* to do inquiry about vital product data and find WWN */
-		req = sas_make_inquiry_req(root, device, MV_TRUE, 0x83,
-			sas_init_req_callback);
-		break;
-
-	case DEVICE_STATE_INQUIRY_EVPD_DONE:
-		if (core_check_duplicate_device(root, device) == MV_TRUE) {
-			CORE_PRINT(("Duplicate SAS Address. Set down\n"));
-			core_init_entry_done(root, device->base.port, NULL);
-			pal_set_down_disk(root, device, MV_FALSE);
-			return MV_TRUE;
-		}
-		device->state = DEVICE_STATE_CHECK_DUPLICATE_DONE;
-
-	case DEVICE_STATE_CHECK_DUPLICATE_DONE:
-		if (!IS_BEHIND_EXP(device)) {
-			if (SAS_SLOW_SPINUP(device))
-				core_sleep_millisecond(root->core, 500);
-			else
-				core_sleep_millisecond(root->core, 1);
-			for (i = 0; i < root->phy_num; i++) {
-				if (port->phy_map & MV_BIT(i)) {
-					phy = &root->phy[i];
-					WRITE_PORT_CONFIG_ADDR(root, phy,
-						CONFIG_PHY_CONTROL);
-					WRITE_PORT_CONFIG_DATA(root, phy, 0x04);
-				}
-			}
-		}
-
-		/* to do start unit */
-		req = sas_make_start_stop_unit_req(root, device, MV_TRUE);
-		break;
-
-	case DEVICE_STATE_STARTSTOP_DONE:
-		/* to do test unit ready */
-		req = sas_make_test_unit_ready_req(root, device, 0);
-		break;
-
-	case DEVICE_STATE_TEST_UNIT_READY_DONE:
-		/* to do read capacity */
-
-		req = sas_make_read_capacity_req(root, device);
-		break;
-
-	case DEVICE_STATE_READ_CAPACITY_DONE:
-                req = sas_make_marvell_specific_req(device,
-                        CDB_CORE_ENABLE_READ_AHEAD,
-                        sas_init_req_callback);
-		break;
-
-	case DEVICE_STATE_SET_READ_AHEAD_DONE:
-		req = sas_make_marvell_specific_req(device,
-			CDB_CORE_ENABLE_WRITE_CACHE,
-			sas_init_req_callback);
-		break;
-
-	case DEVICE_STATE_SET_CACHE_ENABLE_DONE:
-		req = sas_make_log_sense_req(device,
-			0x00, sas_init_req_callback);
-		break;
-	case DEVICE_STATE_LOG_SENSE_DONE:
-	case DEVICE_STATE_REPORT_LUN:
-		if (device->base.LUN == 0) {
-			req = sas_make_report_lun_req(root,device,
-				sas_init_req_callback);
-			break;
-		}
-		/* initialization procedure is done. */
-		device->state = DEVICE_STATE_INIT_DONE;
-	case DEVICE_STATE_INIT_DONE:
-	default:
-		core_init_entry_done(root, port, dev);
-		return MV_TRUE;
-	}
-
-	if (req != NULL) {
-		core_append_init_request(root, req);
-		return MV_TRUE;
-	} else {
-		return MV_FALSE;
-	}
-}
-
-void sas_inquiry_callback(domain_device *dev, PMV_Request req);
-void sas_report_luns_callback(domain_device *dev, PMV_Request req);
-void sas_read_capacity_callback(domain_device *dev, PMV_Request req);
-void sas_start_stop_unit_callback(domain_device *dev, PMV_Request req);
-void sas_test_unit_ready_callback(domain_device *dev, MV_Request *req);
-void sas_log_sense_callback(domain_device *dev, PMV_Request req);
-MV_VOID sas_enable_read_ahead_callback(MV_Request *req, domain_device *dev);
-MV_VOID sas_enable_write_cache_callback(MV_Request *req, domain_device *dev);
-
-static void sas_init_req_callback(MV_PVOID root_p, PMV_Request req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *dev;
-
-	dev = (domain_device *)get_device_by_id(root->lib_dev, req->Device_Id);
-	MV_ASSERT(dev != NULL);
-
-	if (req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC &&
-		req->Cdb[1] == CDB_CORE_MODULE) {
-		switch (req->Cdb[2]) {
-		case CDB_CORE_ENABLE_READ_AHEAD:
-			sas_enable_read_ahead_callback(req, dev);
-			break;
-		case CDB_CORE_ENABLE_WRITE_CACHE:
-			sas_enable_write_cache_callback(req, dev);
-			break;
-		default:
-			MV_ASSERT(MV_FALSE);
-			break;
-		}
-
-	} else if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		core_handle_init_error(root, &dev->base, req);
-		return;
-	}
-
-	switch (req->Cdb[0]) {
-	case SCSI_CMD_INQUIRY:
-		sas_inquiry_callback(dev, req);
-		break;
-
-	case SCSI_CMD_READ_CAPACITY_10:
-	case SCSI_CMD_READ_CAPACITY_16:
-		sas_read_capacity_callback(dev, req);
-		break;
-	case SCSI_CMD_START_STOP_UNIT:
-		sas_start_stop_unit_callback(dev, req);
-		break;
-	case SCSI_CMD_TEST_UNIT_READY:
-		sas_test_unit_ready_callback(dev, req);
-		break;
-	case SCSI_CMD_LOG_SENSE:
-		sas_log_sense_callback(dev, req);
-		break;
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		break;
-	case SCSI_CMD_REPORT_LUN:
-		sas_report_luns_callback(dev, req);
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-	if(dev->dev_type != DT_ENCLOSURE
-		&& dev->dev_type != DT_SES_DEVICE)
-	core_queue_init_entry(root, &dev->base, MV_FALSE);
-}
-
-
-PMV_Request sas_make_read_capacity_req(pl_root *root, domain_device *device)
-{
-	PMV_Request req;
-	MV_U32 buf_size;
-
-	if (device->capability & DEVICE_CAPABILITY_PROTECTION_INFORMATION_SUPPORTED)
-		buf_size = 0x20;
-	else
-		buf_size = 8;
-
-	/* allocate resource */
-	req = get_intl_req_resource(root, buf_size);
-	if (req == NULL) return NULL;
-
-	/* Prepare read capacity */
-	if (device->capability & DEVICE_CAPABILITY_PROTECTION_INFORMATION_SUPPORTED) {
-		req->Cdb[0] = SCSI_CMD_READ_CAPACITY_16;
-		req->Cdb[1] = 0x10;
-		req->Cdb[13] = 0x20;
-	} else {
-		req->Cdb[0] = SCSI_CMD_READ_CAPACITY_10;
-	}
-
-	req->Device_Id = device->base.id;
-
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-	req->Completion = sas_init_req_callback;
-	return req;
-}
-
-PMV_Request sas_make_start_stop_unit_req(pl_root *root,
-	domain_device *device, MV_BOOLEAN start)
-{
-	PMV_Request req;
-	MV_U32 buf_size = 0;
-
-	/* allocate resource */
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL) return NULL;
-
-	/* Prepare start/stop unit command */
-	req->Cdb[0] = SCSI_CMD_START_STOP_UNIT;
-	req->Cdb[1] = (MV_TRUE==start)? 0: 1;	/* immediate */
-	req->Cdb[4] = (MV_TRUE==start)? 1: 0;
-
-	req->Device_Id = device->base.id;
-
-	req->Cmd_Flag = 0;
-	req->Completion = sas_init_req_callback;
-	return req;
-}
-
-PMV_Request sas_make_test_unit_ready_req(pl_root *root, domain_device *device,
-	MV_U8 control)
-{
-	PMV_Request req;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL) return NULL;
-
-	/* Prepare start/stop unit command */
-	req->Cdb[0] = SCSI_CMD_TEST_UNIT_READY;
-	req->Cdb[5] = control;
-
-	req->Device_Id = device->base.id;
-	req->Completion = sas_init_req_callback;
-	return req;
-}
-
-/*
- * state machine callback functions
- */
-void parse_evpd_inquiry(domain_device *dev, MV_PU8 buf)
-{
-	MV_PU8 desc;
-	MV_U32 vpd_len;
-	MV_U8 fujitsu;
-
-	/* it's the "device identification" page */
-	if (buf[1] != 0x83)
-		CORE_DPRINT(("device identification error %x.\n",buf[1]));
-	MV_DASSERT(buf[1] == 0x83);
-
-	vpd_len = ((buf[2] << 8) | buf[3]) + 4;
-	desc = buf + 4;
-	fujitsu = IS_FUJITSU(dev);
-
-	/* See SPC 7.6.3 for Device Identification VPD page */
-	while (desc < buf + vpd_len) {
-		MV_U8 proto = desc[0] >> 4;
-		MV_U8 code_set = desc[0] & 0xf;
-		MV_U8 piv = desc[1] & 0x80;
-		MV_U8 assoc = (desc[1] & 0x30) >> 4;
-		MV_U8 ident_type = desc[1] & 0xf;
-		MV_U8 len = desc[3];
-
-		/* NAA identification type */
-		if (!fujitsu) {
-			if (piv && ident_type == 0x03 && assoc == 0x02 \
-				&& code_set == 0x01 && len == 0x08 && proto == 0x06) {
-				dev->WWN.value = MV_BE64_TO_CPU(*(MV_U64 *)&desc[4]);
-				return;
-			}
-			/* Association is zero for SAT device (SAT spec 2.0) */
-			if (piv == 0 && ident_type == 0x03 && (assoc == 0x02 || assoc == 0x00)  \
-				&& code_set == 0x01 && len == 0x08 && proto == 0) {
-				dev->WWN.value = MV_BE64_TO_CPU(*(MV_U64 *)&desc[4]);
-				return;
-			}
-		} else {
-			if (ident_type == 0x03 && assoc == 0x0 && code_set == 0x01
-				&& len == 0x08) {
-				dev->WWN.value = MV_BE64_TO_CPU(*(MV_U64 *)&desc[4]);
-				return;
-			}
-		}
-		desc += len + 4;
-	}
-
-	CORE_PRINT(("Didn't find the WWN for device %d.\n", dev->base.id));
-}
-
-void parse_standard_inquiry(domain_device *dev, MV_PU8 buf)
-{
-	/* parse standard inquiry data to find out the device type */
-	pl_root *root = dev->base.root;
-        domain_port *port = dev->base.port;
-	domain_enclosure *enc;
-	if (buf[5]&0x01) {
-		/* A PROTECT bit set to one indicates that
-		 * the logical unit supports protection information. */
-		dev->capability |= DEVICE_CAPABILITY_PROTECTION_INFORMATION_SUPPORTED;
-	}
-	if((buf[6]&0x40)||((buf[0]&0x1f)==0x0d))	{
-		if((buf[0]&0x1f)==0x0d){
-			dev->dev_type = DT_ENCLOSURE;
-		}else
-			dev->dev_type = DT_SES_DEVICE;
-
-		enc = get_enclosure_obj(root, root->lib_rsrc);
-		if (enc) {
-		        if(dev->base.parent&&dev->base.parent->port){
-			        set_up_new_enclosure(root, port, enc,
-				        (command_handler *)
-				        core_get_handler(root, HANDLER_ENC));
-			        enc->base.parent = dev->base.parent;
-			        enc->state = ENCLOSURE_INQUIRY_DONE;
-			        enc->negotiated_link_rate = dev->negotiated_link_rate;
-			        enc->setting = dev->setting;
-			        enc->parent_phy_id = dev->parent_phy_id;
-			        MV_CopyMemory(&enc->sas_addr, &dev->sas_addr, 8);
-			        if(IS_BEHIND_EXP(dev)){
-				        List_AddTail(&((domain_expander *)dev->base.parent)->enclosure_queue_pointer, &enc->expander_list);
-				        ((domain_expander *)dev->base.parent)->enclosure = enc;
-			        }
-		        }
-		        MV_CopyMemory(enc->vendor_id, &buf[8], 8);
-		        MV_CopyMemory(enc->product_revision, &buf[32],4);
-		        MV_CopyMemory(enc->product_id, &buf[16], 16);
-		}
-
-		/*set down disk*/
-              /* in callback routine, should call core_init_entry_done to clean up for the HD
-                 * set down disk will minus init_count only if it still in the init queue
-                 * and should set down disk after enclosure get related information */
-		core_init_entry_done(root, port, NULL);
-		pal_set_down_disk(root, dev, MV_FALSE);
-		get_new_and_update_base_id(root,&enc->base);
-
-
-                if (!enc) {
-		        CORE_DPRINT(("ran out of enclosure. abort initialization\n"));
-			return;
-                } else {
-		        core_queue_init_entry(root, &enc->base, MV_TRUE);
-                }
-	}else if((buf[0]&0x1f)==0x01){
-		dev->dev_type = DT_SEQ_ACCESS;
-		dev->base.queue_depth = 1;
-	} else{
-		dev->dev_type=buf[0] & 0x1F;
-		}
-	/*
-	 * Standard inquiry:
-	 * Byte 8-15 T10 Vendor Identification
-	 * Byte 16-31 Product Identification
-	 * Byte 32-35 Revision Level
-	 * Byte 36-55 Vendor Specific. FIJISHU use it as the serial number.
-	 * Need double check other vendors.
-	 */
-
-	MV_CopyMemory(dev->model_number, &buf[8], 24);
-	MV_CopyMemory(dev->firmware_revision, &buf[32], 4);
-	MV_CopyMemory(dev->serial_number, &buf[36], 20);
-}
-
-void sas_inquiry_callback(domain_device *dev, PMV_Request req)
-{
-	MV_U8 *buf = (MV_U8 *)core_map_data_buffer(req);
-
-	if (req->Cdb[1] & MV_BIT(0)) {
-		/* pass EVPD inquiry */
-		parse_evpd_inquiry(dev, buf);
-
-		dev->state = DEVICE_STATE_INQUIRY_EVPD_DONE;
-	} else {
-		/* pass standard inquiry */
-		parse_standard_inquiry(dev, buf);
-		if(dev->dev_type != DT_DIRECT_ACCESS_BLOCK){
-			dev->state = DEVICE_STATE_INIT_DONE;
-			if (dev->base.LUN == 0) {
-				dev->state=DEVICE_STATE_REPORT_LUN;
-			}
-		} else
-			dev->state = DEVICE_STATE_INQUIRY_DONE;
-
-	}
-	if((dev->dev_type == DT_ENCLOSURE)||
-		(dev->dev_type == DT_SES_DEVICE)){
-		dev->state = DEVICE_STATE_INIT_DONE;
-		dev->status &= ~DEVICE_STATUS_FUNCTIONAL;
-	}
-
-        core_unmap_data_buffer(req);
-}
-
-MV_U16 sas_get_exist_target_lun( pl_root *root, MV_U16 target, MV_U16 *lun_map)
-{
-	core_extension *core = root->core;
-	lib_device_mgr *lib_dev = &core->lib_dev;
-	MV_U16 i=0;
-	MV_U16 org_lun_cnt =0;
-	for(i = 0; i <MV_MAX_LUN_NUMBER;i++){
-		lun_map[i] = 0xFFFF;
-	}
-
-	for(i=0; i<MAX_ID; i++) {
-		domain_base *base;
-		base = lib_dev->device_map[i];
-		if (base ==NULL)
-			continue;
-		 if ( base->TargetID == target){
-			lun_map[org_lun_cnt] = base->LUN;
-			org_lun_cnt++;
-		}
-	}
-	return org_lun_cnt;
-}
-
-MV_U16 	sas_check_target_lun( pl_root *root, MV_U16 target, MV_U16 lun)
-{
-	core_extension *core = root->core;
-	lib_device_mgr *lib_dev = &core->lib_dev;
-	MV_U16 i=0;
-
-	for(i=0; i<MAX_ID; i++) {
-		domain_base *base;
-		base = lib_dev->device_map[i];
-		if (base && ( base->TargetID== target) && ( base->LUN== lun)){
-			return MV_TRUE;
-		}
-	}
-	return MV_FALSE;
-}
-
-struct mv_scsi_lun {
-	MV_U8 scsi_lun[8];
-};
-
-int mv_scsilun_to_int(struct mv_scsi_lun *scsilun)
-{
-	int i;
-	unsigned int lun;
-
-	lun = 0;
-	for (i = 0; i < sizeof(lun); i += 2)
-		lun = lun | (((scsilun->scsi_lun[i] << 8) |
-			      scsilun->scsi_lun[i + 1]) << (i * 8));
-	return lun;
-}
-
-void sas_report_luns_callback(domain_device *dev, PMV_Request req)
-{
-	MV_U8 *buf = (MV_U8 *)core_map_data_buffer(req);
-	struct mv_scsi_lun *lun_data;
-	MV_U8 tmp;
-	unsigned int length,lun_cnt;
-	int i,k;
-	MV_U16 lunp,id;
-	MV_U16  lun,target;
-	MV_U16 lun_map[MV_MAX_LUN_NUMBER], org_lun_map[MV_MAX_LUN_NUMBER];
-	MV_BOOLEAN  lun_tag = MV_FALSE;
-	pl_root *root = (pl_root *)dev->base.root;
-	core_extension *core =  (core_extension *)root->core;
-	domain_port *port = (domain_port *)dev->base.port;
-	domain_device *dev_down;
-
-	length = ((buf[0] << 24) |(buf[1] << 16)|(buf[2] << 8)|(buf[3] << 0));
-	lun_cnt = length/8;
-
-	if(lun_cnt == 0)
-		goto finished;
-	else if(lun_cnt == 1)
-		dev->base.multi_lun = MV_FALSE;
-	else if(lun_cnt >1)
-		dev->base.multi_lun = MV_TRUE;
-
-	target = dev->base.TargetID;
-	lun_data = (struct mv_scsi_lun *)buf;
-	if(dev->state == DEVICE_STATE_LOG_SENSE_DONE) {
-		for(i = 1; i < (lun_cnt+1); i++)  {
-			lun = (MV_U32)((buf[i*8]<<8) | (buf[i*8+1]<<0)|(buf[i*8+2]<<24)|(buf[i*8+3]<<16))&0xffff;
-			if(dev->base.LUN ==0 && lun!=0){
-				sas_init_target_device(root, port,dev,target, lun);
-			}
-		}
-	} else if(dev->state == DEVICE_STATE_REPORT_LUN){
-		MV_U16 org_lun_cnt = sas_get_exist_target_lun(root, target, org_lun_map);
-		for(i = 0; i <MV_MAX_LUN_NUMBER;i++){
-			lun_map[i] = 0xFFFF;
-		}
-		for (i = 1; i < (lun_cnt+1); i++) {
-			lun = (MV_U32)((buf[i*8]<<8)|(buf[i*8+1]<<0)|(buf[i*8+2]<<24)|(buf[i*8+3]<<16))&0xffff;
-			lun_map[i-1]=lun;
-			if(lun > MV_MAX_LUN_NUMBER)
-				continue;
-			if(sas_check_target_lun(root, target, lun) == MV_FALSE) {
-				sas_init_target_device(root, port,dev,target,lun);
-			}
-		}
-		for(k = 0; k < org_lun_cnt ; k++){
-			lun_tag = MV_FALSE;
-			for(i = 0; i < lun_cnt; i++){
-				if(org_lun_map[k] == lun_map[i]){
-					lun_tag = MV_TRUE;
-					break;
-				}
-			}
-			if(lun_tag == MV_FALSE){
-				id = get_id_by_targetid_lun(core, dev->base.TargetID, org_lun_map[k]);
-				dev_down = (domain_device *)get_device_by_id(root->lib_dev, id);
-				pal_set_down_disk(root, dev_down, MV_TRUE);
-			}
-		}
-	}
-finished:
-		dev->state = DEVICE_STATE_INIT_DONE;
-
-		core_unmap_data_buffer(req);
-}
-
-void sas_read_capacity_callback(domain_device *dev, PMV_Request req)
-{
-	pl_root *root = dev->base.root;
-	core_extension *core = (core_extension *)root->core;
-	MV_U8 *buf = (MV_U8 *)core_map_data_buffer(req);
-	core_context *ctx = req->Context[MODULE_CORE];
-	struct _error_context *err_ctx = &dev->base.err_ctx;
-
-	/* read capacity 10 */
-	if (req->Cdb[0] == SCSI_CMD_READ_CAPACITY_10) {
-		dev->sector_size = buf[7]+(buf[6]<<8)+(buf[5]<<16)+(buf[4]<<24);
-
-		U32_ASSIGN_U64(dev->max_lba, (MV_U32)(buf[3]+(buf[2]<<8)+(buf[1]<<16)+(buf[0]<<24)));
-
-		if ((dev->sector_size == 0) ||
-			(dev->sector_size > dev->max_lba.value))
-		{
-			MV_DASSERT(MV_FALSE);
-			err_ctx->retry_count++;
-                     core_unmap_data_buffer(req);
-			core_sleep_millisecond(root->core, 10);
-			return;
-		}
-	} else {
-		/* read capacity 16 */
-		dev->sector_size = buf[11]+(buf[10]<<8)+(buf[9]<<16)+(buf[8]<<24);
-		U32_ASSIGN_U64(dev->max_lba, buf[7]+(buf[6]<<8)+(buf[5]<<16)+(buf[4]<<24)+
-				(((_MV_U64) buf[3])<<32) +
-				(((_MV_U64) buf[2])<<40) +
-				(((_MV_U64) buf[1])<<48) +
-				(((_MV_U64) buf[0])<<56));
-		if(buf[12]&0x01) {
-			dev->setting |= DEVICE_SETTING_PI_ENABLED;
-			dev->sector_size +=8;
-		}
-	}
-
-       dev->max_transfer_size = CORE_MAX_TRANSFER_SIZE;
-
-	CORE_PRINT(("Device[0x%x] sector size 0x%x max LBA 0x%08x%08x\n",
-		req->Device_Id, dev->sector_size,
-		dev->max_lba.parts.high, dev->max_lba.parts.low));
-
-	if (core->is_dump == MV_TRUE)
-		dev->state = DEVICE_STATE_INIT_DONE;
-	else
-		dev->state = DEVICE_STATE_READ_CAPACITY_DONE;
-
-        core_unmap_data_buffer(req);
-}
-
-void sas_start_stop_unit_callback(domain_device *dev, PMV_Request req)
-{
-	dev->state = DEVICE_STATE_STARTSTOP_DONE;
-}
-
-void sas_test_unit_ready_callback(domain_device *dev, MV_Request *req)
-{
-	struct _error_context *err_ctx = &dev->base.err_ctx;
-	MV_U8 sense_key;
-
-	if (req->Scsi_Status == REQ_STATUS_HAS_SENSE) {
-		sense_key = ((MV_U8 *)req->Sense_Info_Buffer)[2] & 0x0f;
-		if ((sense_key == SCSI_SK_UNIT_ATTENTION) ||
-			(sense_key == SCSI_SK_NOT_READY)) {
-			err_ctx->retry_count++;
-			core_sleep_millisecond(dev->base.root->core, 10);
-			return;
-		}
-	}
-
-	dev->state = DEVICE_STATE_TEST_UNIT_READY_DONE;
-}
-
-void sas_log_sense_callback(domain_device *dev, PMV_Request req)
-{
-	MV_U16 length;
-	MV_U16 i;
-	MV_PU8 data_buf;
-
-	dev->capability &= ~DEVICE_CAPABILITY_SMART_SUPPORTED;
-	dev->setting &= ~DEVICE_SETTING_SMART_ENABLED;
-	data_buf = (MV_PU8)core_map_data_buffer(req);
-	length = (data_buf[2] << 8) + data_buf[3];
-
-	/* Check whether it supports 0x2F log page which we will use
-	        to check smart status. */
-	for (i = 0; i < length; i++) {
-		if (data_buf[4 + i] ==
-			INFORMATIONAL_EXCEPTIONS_LOG_PAGE) {
-			dev->capability |=
-				DEVICE_CAPABILITY_SMART_SUPPORTED;
-			dev->setting |=
-				DEVICE_SETTING_SMART_ENABLED;
-			break;
-		}
-	}
-
-	dev->state = DEVICE_STATE_LOG_SENSE_DONE;
-	core_unmap_data_buffer(req);
-}
-
-MV_VOID
-sas_enable_read_ahead_callback(MV_Request *req, domain_device *dev)
-{
-	dev->state = DEVICE_STATE_SET_READ_AHEAD_DONE;
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-}
-
-MV_VOID
-sas_enable_write_cache_callback(MV_Request *req, domain_device *dev)
-{
-	if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-		dev->capability |= DEVICE_CAPABILITY_WRITECACHE_SUPPORTED;
-	} else {
-		dev->capability &= ~DEVICE_CAPABILITY_WRITECACHE_SUPPORTED;
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-	}
-	dev->state = DEVICE_STATE_SET_CACHE_ENABLE_DONE;
-}
-
-void sas_check_wide_port_device(MV_PVOID port_p)
-{
-	domain_port *port = (domain_port *)port_p;
-	pl_root *root = port->base.root;
-	domain_device *dev = NULL, *matched_dev = NULL;
-	MV_U8 phy_id = 0, i, count = 0;
-
-	/* find the device that was attached to the port */
-	LIST_FOR_EACH_ENTRY_TYPE(dev, &port->device_list, domain_device,
-		base.queue_pointer) {
-		if (dev->base.parent == &port->base)
-			matched_dev = dev;
-		count++;
-	}
-	MV_ASSERT(matched_dev != NULL);
-}
--- a/drivers/scsi/vanir/core/sas_base/sas_util.c
+++ /dev/null
@@ -1,435 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_sas.h"
-#include "core_internal.h"
-#include "core_manager.h"
-#include "com_api.h"
-#include "com_u64.h"
-
-#include "core_util.h"
-#include "core_error.h"
-#include "core_sat.h"
-
-MV_VOID sas_replace_org_req(MV_PVOID root_p,
-	MV_Request *org_req,
-	MV_Request *new_req)
-{
-	pl_root *root = (pl_root *) root_p;
-	core_context *org_ctx;
-	core_context *new_ctx;
-
-	if (org_req == NULL || new_req == NULL) {
-		MV_ASSERT(MV_FALSE);
-		return;
-	}
-	org_ctx = (core_context*)org_req->Context[MODULE_CORE];
-	new_ctx = (core_context*)new_req->Context[MODULE_CORE];
-
-	new_ctx->req_type = org_ctx->req_type;
-	new_req->Time_Out = org_req->Time_Out;
-	new_req->Org_Req = org_req;
-	core_append_request(root, new_req);
-}
-
-MV_Request *sas_get_org_req(MV_Request *req)
-{
-	core_context *ctx;
-
-	if (req == NULL) {
-		MV_ASSERT(MV_FALSE);
-		return NULL;
-	}
-
-	return (req->Org_Req);
-}
-
-MV_Request *sas_clear_org_req(MV_Request *req)
-{
-	core_context *ctx;
-	MV_Request *org_req;
-
-	if (req == NULL) {
-		MV_ASSERT(MV_FALSE);
-		return NULL;
-	}
-
-	org_req = req->Org_Req;
-	req->Org_Req = NULL;
-
-	return (org_req);
-}
-
-MV_Request
-*sas_make_mode_sense_req(MV_PVOID dev_p,
-        MV_ReqCompletion cmpltn)
-{
-	domain_device *dev = (domain_device *)dev_p;
-	pl_root *root = dev->base.root;
-	MV_Request *req;
-	MV_U8 length = MAX_MODE_PAGE_LENGTH;      /* Mode Page Cache */
-
-	req = get_intl_req_resource(root, length);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_MODE_SENSE_6;
-	req->Cdb[1] = 0x08; /* disable block descriptors */
-	req->Cdb[2] = 0x08; /* PC = 0, Page Code = 0x08(caching) */
-	req->Cdb[3] = 0;    /* Subpage Code = 0 */
-	req->Cdb[4] = length;
-
-	req->Device_Id = dev->base.id;
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-	req->Completion = cmpltn;
-
-	return req;
-}
-
-MV_Request
-*sas_make_marvell_specific_req(MV_PVOID dev_p,
-        MV_U8 cmd,
-        MV_ReqCompletion cmpltn)
-{
-	domain_device *dev = (domain_device *)dev_p;
-	pl_root *root = dev->base.root;
-	MV_Request *req;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = cmd;
-
-	req->Device_Id = dev->base.id;
-	req->Cmd_Flag = 0;
-	req->Completion = cmpltn;
-
-	return req;
-}
-
-MV_Request *sas_make_log_sense_req(MV_PVOID dev_p,
-	MV_U8 page,
-	MV_ReqCompletion cmpltn)
-{
-	domain_device *dev = (domain_device *)dev_p;
-	pl_root *root = dev->base.root;
-	MV_Request *req;
-	MV_U16 buf_size = MAX_MODE_LOG_LENGTH;
-
-	req = get_intl_req_resource(root, buf_size);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_LOG_SENSE;
-	req->Cdb[1] = 0;                        /* SP=0 PPC=0 */
-	req->Cdb[2] = 0x40 | (page & 0x3F);     /* PC=01b */
-	req->Cdb[7] = (buf_size >> 8) & 0xFF;
-	req->Cdb[8] = buf_size & 0xFF;
-	req->Cdb[9] = 0;                       /* Control */
-
-	req->Device_Id = dev->base.id;
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-	req->Completion = cmpltn;
-
-	return req;
-}
-
-MV_Request *sas_make_sync_cache_req(MV_PVOID dev_p,
-	MV_ReqCompletion cmpltn)
-{
-	domain_device *dev = (domain_device *)dev_p;
-	pl_root *root = dev->base.root;
-	MV_Request *req;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_SYNCHRONIZE_CACHE_10;
-
-	req->Device_Id = dev->base.id;
-	req->Cmd_Flag = 0;
-	req->Completion = cmpltn;
-
-	return req;
-}
-
-
-MV_U8 ssp_ata_parse_log_sense_threshold_exceed(MV_PU8 data_buf, MV_U32 length)
-{
-	if (data_buf == NULL || length < 9) {
-		MV_DASSERT(MV_FALSE);
-		return MV_FALSE;
-	}
-
-	if (data_buf[8] == SCSI_ASC_FAILURE_PREDICTION_THRESHOLD_EXCEEDED)
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-}
-
-MV_VOID ssp_ata_parse_smart_return_status(domain_device *dev,
-	MV_Request *org_req, MV_Request *new_req)
-{
-	pl_root *root = dev->base.root;
-	core_extension *core = (core_extension *)root->core;
-	HD_SMART_Status *status;
-	MV_PVOID new_buf_ptr;
-	MV_U8 ret;
-
-	if (org_req == NULL || new_req == NULL) {
-		MV_ASSERT(MV_FALSE);
-		return;
-	}
-
-	new_buf_ptr = core_map_data_buffer(new_req);
-	ret = ssp_ata_parse_log_sense_threshold_exceed(
-	new_buf_ptr,
-	new_req->Data_Transfer_Length);
-
-	status = core_map_data_buffer(org_req);
-
-	if (status != NULL)
-		status->SmartThresholdExceeded = ret;
-
-	if (ret == MV_TRUE)
-		core_generate_event(core, EVT_ID_HD_SMART_THRESHOLD_OVER,
-		dev->base.id, SEVERITY_WARNING, 0, NULL ,0);
-
-	core_unmap_data_buffer(org_req);
-	core_unmap_data_buffer(new_req);
-}
-
-MV_Request *sas_make_inquiry_req(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_BOOLEAN EVPD, MV_U8 page, MV_ReqCompletion completion)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *dev = (domain_device *)dev_p;
-	PMV_Request req;
-
-	/* allocate resource */
-	req = get_intl_req_resource(root, 0x60);
-	if (req == NULL)
-		return NULL;
-
-	/* Prepare inquiry */
-	if (!EVPD) {
-		req->Cdb[0] = SCSI_CMD_INQUIRY;
-		req->Cdb[1] = 0;
-		req->Cdb[4] = 0x60;
-	} else {
-		req->Cdb[0] = SCSI_CMD_INQUIRY;
-		req->Cdb[1] = 0x01; /* EVPD inquiry */
-		req->Cdb[2] = page;
-		req->Cdb[4] = 0x60;
-	}
-	req->Device_Id = dev->base.id;
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-	req->Completion = completion;
-	return req;
-}
-
-MV_Request *sas_make_report_lun_req(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_ReqCompletion completion)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *dev = (domain_device *)dev_p;
-	PMV_Request req;
-	MV_U16 buf_size = 0x400;
-
-	/* allocate resource */
-	req = get_intl_req_resource(root, buf_size);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_REPORT_LUN;
-	req->Cdb[2] = 0;
-	/*Cdb[6..9] means the allocation length, and it equals to buf_size */
-	req->Cdb[8] = 0x4;
-	req->Cdb[9] = 0x00;
-
-	req->Device_Id = dev->base.id;
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-	req->Completion = completion;
-	return req;
-}
-
-MV_Request *
-ssp_make_virtual_phy_reset_req(MV_PVOID dev_p,
-	MV_U8 operation, MV_PVOID callback)
-{
-	domain_device *dev = (domain_device *)dev_p;
-	pl_root *root = dev->base.root;
-	MV_Request *req = get_intl_req_resource(root, 0);
-
-	if (req == NULL) return NULL;
-
-	MV_ASSERT(dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER);
-
-	req->Device_Id = dev->base.id;
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SSP_VIRTUAL_PHY_RESET;
-	req->Cdb[3] = operation;
-	req->Completion = callback;
-
-	return req;
-}
-
-
-MV_VOID
-stp_req_report_phy_sata_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_Request *org_req = ctx->u.org.org_req;
-	core_context *org_req_ctx = (core_context *)org_req->Context[MODULE_CORE];
-	domain_expander *exp = (domain_expander *)exp_p;
-	domain_device *device = NULL;
-	smp_response *smp_resp = NULL;
-
-	if (exp) {
-		if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-			smp_resp = (smp_response *)core_map_data_buffer(req);
-			if (smp_resp != NULL) {
-				LIST_FOR_EACH_ENTRY_TYPE(device,
-				&exp->device_list, domain_device,
-				base.exp_queue_pointer) {
-					if (device->parent_phy_id ==
-						smp_resp->response.ReportPhySATA.PhyIdentifier)
-						break;
-				}
-
-				if (device == NULL) {
-					MV_ASSERT(MV_FALSE);
-					return;
-				}
-
-				switch (device->state) {
-				case DEVICE_STATE_STP_REPORT_PHY:
-					if (smp_resp->response.ReportPhySATA.AffiliationValid) {
-						CORE_DPRINT(("Find device %d phy %d has affiliation_valid.\n",device->base.id, smp_resp->response.ReportPhySATA.PhyIdentifier));
-						org_req_ctx->u.smp_report_phy.affiliation_valid = 1;
-					}
-					else {
-						device->signature =
-						smp_resp->response.ReportPhySATA.fis.lba_high << 24 |
-						smp_resp->response.ReportPhySATA.fis.lba_mid << 16 |
-						smp_resp->response.ReportPhySATA.fis.lba_low << 8 |
-						smp_resp->response.ReportPhySATA.fis.sector_count;
-					}
-					break;
-				default:
-					break;
-				}
-			}
-			core_unmap_data_buffer(req);
-		}
-	}
-
-	core_queue_completed_req(root->core, org_req);
-}
-
-MV_VOID stp_req_disc_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_base *base = get_device_by_id(root->lib_dev, req->Device_Id);
-	domain_device *device = NULL;
-	core_context *ctx = NULL;
-
-	if (!base)
-		return;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		core_handle_init_error(root, base, req);
-		return;
-	}
-
-	MV_DASSERT(base->type == BASE_TYPE_DOMAIN_DEVICE);
-	device = (domain_device *)base;
-	ctx = (core_context *)req->Context[MODULE_CORE];
-
-	switch (device->state) {
-	case DEVICE_STATE_STP_RESET_PHY:
-		device->state = DEVICE_STATE_STP_REPORT_PHY;
-		core_sleep_millisecond(root->core, 100);
-		break;
-	case DEVICE_STATE_STP_REPORT_PHY:
-		if (ctx->u.smp_report_phy.affiliation_valid == 1) {
-			device->state = DEVICE_STATE_STP_RESET_PHY;
-		}
-		else {
-			device->state = DEVICE_STATE_RESET_DONE;
-		}
-		break;
-	}
-
-	core_queue_init_entry(root, base, MV_FALSE);
-}
-
-MV_Request *stp_make_report_phy_sata_req(domain_device *dev, MV_PVOID callback)
-{
-	pl_root *root = dev->base.root;
-	MV_Request *req = get_intl_req_resource(root, 0);
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	if (req == NULL)
-		return NULL;
-
-	MV_DASSERT(dev->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER);
-
-	req->Device_Id = dev->base.id;
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_STP_VIRTUAL_REPORT_SATA_PHY;
-	req->Completion = callback;
-
-	ctx->u.smp_report_phy.affiliation_valid = 0;
-
-	return req;
-}
-
-MV_Request *stp_make_phy_reset_req(domain_device *device, MV_U8 operation,
-	MV_PVOID callback)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req = get_intl_req_resource(root, 0);
-
-	if (req == NULL) {
-		return NULL;
-	}
-
-	MV_DASSERT(device->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER);
-
-	req->Device_Id = device->base.id;
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_STP_VIRTUAL_PHY_RESET;
-	req->Cdb[3] = operation;
-	req->Completion = callback;
-
-	return req;
-}
-
-void mv_int_to_reqlun(MV_U16 lun, MV_U8*reqlun)
-{
-	reqlun[1] = lun & 0xFF;
-	reqlun[0] = (lun >> 8) & 0xFF;
-	reqlun[2] = 0;
-	reqlun[3] = 0;
-}
--- a/drivers/scsi/vanir/core/sas_smp/core_discover.h
+++ /dev/null
@@ -1,2256 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_DISCOVER_H
-#define __CORE_DISCOVER_H
-
-#include "mv_config.h"
-#include "core_sata.h"
-
-/* assume the maximum number of phys in an expander device is 128 */
-#define MAXIMUM_EXPANDER_PHYS 		128
-/* assume the maximum number of indexes per phy is 128 */
-#define MAXIMUM_EXPANDER_INDEXES 		128
-
-/* limit to 8 initiators for this example */
-#define MAXIMUM_INITIATORS 			8
-
-/* defines for address frame types */
-#define OF_FRAME_TYPE_SHIFT                              0
-#define ADDRESS_IDENTIFY_FRAME 		0x00
-#define ADDRESS_OPEN_FRAME 			0x01
-
-
-/* defines for SMP frame types */
-#define SMP_REQUEST_FRAME 			0x40
-#define SMP_RESPONSE_FRAME 			0x41
-
-
-/* defines for SMP request functions */
-#define REPORT_GENERAL 				0x00
-#define REPORT_MANUFACTURER_INFORMATION 	0x01
-#define READ_GPIO_REGISTER			0x02
-#define REPORT_SELF_CONFIGURATION_STATUS	0x03
-#define DISCOVER 				0x10
-#define REPORT_PHY_ERROR_LOG 			0x11
-#define REPORT_PHY_SATA 			0x12
-#define REPORT_ROUTE_INFORMATION 		0x13
-#define REPORT_PHY_EVENT_INFORMATION		0x14
-#define REPORT_PHY_BROADCAST_COUNTS		0x15
-#define DISCOVER_LIST				0x16
-#define REPORT_EXPANDER_ROUTE_TABLE		0x17
-#define CONFIGURE_GENERAL			0x80
-#define ENABLE_DISABLE_ZONING			0x81
-#define WRITE_GPIO_REGISTER 			0x82
-#define ZONED_BROADCAST				0x85
-#define CONFIGURE_ROUTE_INFORMATION 		0x90
-#define PHY_CONTROL 				0x91
-#define PHY_TEST 				0x92
-#define CONFIGURE_PHY_EVENT_INFORMATION		0x93
-
-
-enum sas_proto {
-	SATA_PROTO    = 1,
-	SAS_PROTO_SMP = 2,		/* protocol */
-	SAS_PROTO_STP = 4,		/* protocol */
-	SAS_PROTO_SSP = 8,		/* protocol */
-	SAS_PROTO_ALL = 0xE,
-};
-
-/* defines for open responses, arbitrary values, not defined in the spec */
-#define OPEN_ACCEPT 				0
-#define OPEN_REJECT_BAD_DESTINATION 		1
-#define OPEN_REJECT_RATE_NOT_SUPPORTED 	2
-#define OPEN_REJECT_NO_DESTINATION 		3
-#define OPEN_REJECT_PATHWAY_BLOCKED 		4
-#define OPEN_REJECT_PROTOCOL_NOT_SUPPORTED 	5
-#define OPEN_REJECT_RESERVE_ABANDON 		6
-#define OPEN_REJECT_RESERVE_CONTINUE 		7
-#define OPEN_REJECT_RESERVE_INITIALIZE 	8
-#define OPEN_REJECT_RESERVE_STOP 		9
-#define OPEN_REJECT_RETRY 			10
-#define OPEN_REJECT_STP_RESOURCES_BUSY 	11
-#define OPEN_REJECT_WRONG_DESTINATION 	12
-#define OPEN_REJECT_WAITING_ON_BREAK 		13
-
-/* definitions for discovery algorithm use */
-enum
-{
-	SAS_SIMPLE_LEVEL_DESCENT = 0,
-	SAS_UNIQUE_LEVEL_DESCENT
-};
-enum
-{
-	SAS_10_COMPATIBLE = 0,
-	SAS_11_COMPATIBLE
-};
-
-/* definitions for SMP function results */
-enum SMPFunctionResult
-{
-	SMP_REQUEST_ACCEPTED = 0x0,
-	SMP_FUNCTION_ACCEPTED = 0x0,
-	SMP_UNKNOWN_FUNCTION = 0x1,
-	SMP_FUNCTION_FAILED = 0x2,
-	SMP_INVALID_REQUEST_FRAME_LENGTH = 0x3,
-        SMP_INVALID_EXPANDER_CHANGE_COUNT = 0x4,
-        SMP_BUSY = 0x5,
-        SMP_INCOMPLETE_DESCRIPTOR_LIST = 0x6,
-
-	SMP_PHY_DOES_NOT_EXIST = 0x10,
-	SMP_INDEX_DOES_NOT_EXIST = 0x11,
-	SMP_PHY_DOES_NOT_SUPPORT_SATA = 0x12,
-	SMP_UNKNOWN_PHY_OPERATION = 0x13,
-	SMP_UNKNOWN_PHY_TEST_FUNCTION = 0x14,
-	SMP_PHY_TEST_FUNCTION_IN_PROGRESS = 0x15,
-	SMP_PHY_VACANT = 0x16,
-	SMP_UNKNOWN_PHY_EVENT_SOURCE = 0x17,
-        SMP_UNKNOWN_DESCRIPTOR_TYPE = 0x18,
-        SMP_UNKNOW_PHY_FILTER = 0x19,
-        SMP_AFFILIATION_VIOLATION = 0x1a,
-
-	SMP_ZONE_VIOLATION = 0x20,
-	SMP_NO_MANAGEMENT_ACCESS_RIGHTS = 0x21,
-	SMP_UNKNOWN_ENABLE_DISABLE_ZONING_VALUE = 0x22,
-        SMP_ZONE_LOCK_VIOLATION = 0x23,
-        SMP_NOT_ACTIVATED = 0x24,
-        SMP_ZONE_GROUP_OUT_OF_RANGE = 0x25,
-        SMP_NO_PHYSICAL_PRESENCE = 0x26,
-        SMP_SAVING_NOT_SUPPORTED = 0x27,
-        SMP_SOURCE_ZONE_GROUP_DOES_NOT_EXIST = 0X28,
-        SMP_DISABLED_PASSWORD_NOT_SUPPORTED = 0x29,
-};
-
-
-/* DEV_TYPE values */
-enum DeviceType {
-	NO_DEVICE   = 0,	  /* protocol */
-	SAS_END_DEV = 1,	  /* protocol */
-	EDGE_DEV    = 2,	  /* protocol */
-	FANOUT_DEV  = 3,	  /* protocol */
-	SAS_HA      = 4,
-	SATA_DEV    = 5,
-	SATA_PM     = 7,
-	SATA_PM_PORT= 8,
-};
-
-
-/* RoutingAttribute */
-enum RoutingAttribute
-{
-	DIRECT = 0,
-	SUBTRACTIVE,
-	TABLE,
-	/*
-		this attribute is a psuedo attribute, used to reflect the function
-		result of SMP_PHY_VACANT in a fabricated discover response
-	*/
-	PHY_NOT_USED = 15
-};
-
-/* ConnectorType */
-enum ConnectorType
-{
-	UNKNOWN_CONNECTOR = 0,
-	SFF_8470_EXTERNAL_WIDE,
-	SFF_8484_INTERNAL_WIDE = 0x10,
-	SFF_8484_COMPACT_INTERNAL_WIDE,
-	SFF_8482_BACKPLANE = 0x20,
-	SATA_HOST_PLUG,
-	SAS_DEVICE_PLUG,
-	SATA_DEVICE_PLUG
-};
-/* RouteFlag */
-enum DisableRouteEntry
-{
-	ENABLED = 0,
-	DISABLED
-};
-
-/* Connect_Rate */
-enum PhysicalLinkRate {
-	PHY_LINKRATE_NONE = 0,
-	PHY_LINKRATE_UNKNOWN = 0,
-	PHY_DISABLED,
-	PHY_RESET_PROBLEM,
-	PHY_SPINUP_HOLD,
-	PHY_PORT_SELECTOR,
-	RESET_IN_PROGRESS,
-	/*
-	 * this is a psuedo link rate, used to reflect the function
-	 * result of SMP_PHY_VACANT in a fabricated discover response
-	*/
-	PHY_DOES_NOT_EXIST,
-	PHY_LINKRATE_1_5 = 0x08,
-	PHY_LINKRATE_G1  = PHY_LINKRATE_1_5,
-	PHY_LINKRATE_3   = 0x09,
-	PHY_LINKRATE_G2  = PHY_LINKRATE_3,
-	PHY_LINKRATE_6   = 0x0A,
-};
-
-/* PhyOperation */
-enum PhyOperation
-{
-	PHY_NOP = 0,
-	LINK_RESET,
-	HARD_RESET,
-	DISABLE,
-	CLEAR_ERROR_LOG = 5,
-	CLEAR_AFFILIATION,
-	TRANSMIT_SATA_PORT_SELECTION_SIGNAL,
-	CLEAR_STP_NEXUS_LOSS
-};
-
-/* EnableDisableZoning*/
-enum EnableDisableZoning
-{
-	NO_CHANGE=0,
-	ENABLE_ZONING,
-	DISABLE_ZONING,
-};
-
-/* BroadcastType*/
-enum BroadcastType
-{
-	BROADCAST_CHANGE = 0,
-	BROADCAST_RESERVED_CHANGE0,
-	BROADCAST_RESERVED_CHANGE1,
-	BROADCAST_SES,
-	BROADCAST_EXPANDER,
-	BROADCAST_ASYNCHRONOUS_EVENT,
-	BROADCAST_RESERVED_CHANGE3,
-	BROADCAST_RESERVED_CHANGE4,
-};
-
-/* DescriptorType */
-enum DescriptorType
-{
-	LONG_FORMAT_DESCRIPTOR=0,
-	SHORT_FORMAT_DESCRIPTOR,
-};
-
-/* PortType */
-enum PortType
-{
-	PORT_IS_TARGET=0,
-	PORT_IS_INITIATOR
-};
-
-
-/*
- *   The structures assume a char bitfield is valid, this is compiler
- * dependent defines would be more portable, but less descriptive
- * the Identify frame is exchanged following OOB, for this
- * code it contains the identity information for the attached device
- * and the initiator application client.
- */
-enum
-{
-	FRAME_PORT_TYPE_SMP         = (1 << 1),
-	FRAME_PORT_TYPE_STP         = (1 << 2),
-	FRAME_PORT_TYPE_SSP         = (1 << 3),
-	FRAME_ATT_DEV_TYPE_SMP      = (1 << 1),
-	FRAME_ATT_DEV_TYPE_STP      = (1 << 2),
-	FRAME_ATT_DEV_TYPE_SSP      = (1 << 3),
-	FRAME_ATT_DEV_SATA_DEV      = (1 << 0),
-	FRAME_ATT_DEV_SATA_HOST     = (1 << 0),
-	FRAME_ATT_DEV_SATA_SELECTOR = (1 << 7),
-};
-
-struct Identify
-{
-/* byte 0 */
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-	MV_U8 RestrictedByte0Bit7 : 1;
-	MV_U8 DeviceType          : 3;
-	MV_U8 AddressFrameType    : 4;
-#else
-	/* 	0x0: ADDRESS_IDENTIFY_FRAME */
-	MV_U8 AddressFrameType    : 4;
-	/*  001b: End device
-	 *  010b: Edge expander device
-	 *  011b: Fanout expander device
-	 *  Others: Reserved.
-	 */
-	MV_U8 DeviceType          : 3;
-	MV_U8 RestrictedByte0Bit7 : 1;
-#endif /*  __MV_BIG_ENDIAN_BITFIELD__ */
-/* byte 1 */
-	MV_U8 RestrictedByte1;
-/* byte 2 */
-	MV_U8 InitiatorBits;
-/* byte 3 */
-	MV_U8 TargetBits;
-/* byte 4-11 */
-	MV_U8 DeviceName[8];
-/*  byte 12-19  */
-	MV_U64 SASAddress;
-/* byte 20 */
-	MV_U8 PhyIdentifier;
-/* byte 21 */
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-	MV_U8 ReservedByte21Bit1_7 : 7;
-	MV_U8 BreakReplyCapable    : 1;
-#else
-	MV_U8 BreakReplyCapable    : 1;
-	MV_U8 ReservedByte21Bit1_7 : 7;
-#endif /* __MV_BIG_ENDIAN_BITFIELD__ */
-/* byte 22-27 */
-	MV_U8 ReservedByte22_27[6];
-/* byte 28-31 */
-	MV_U32 CRC;
-}; /* struct Identify */
-
-/*
- * replaced by struct _OPEN_ADDRESS_FRAME
-*/
-
-/* request specific bytes for a general input function */
-struct SMPRequestGeneralInput
-{
-	/* byte 4-7 */
-	MV_U32 CRC;
-};
-
-/* request specific bytes for a phy input function */
-struct SMPRequestPhyInput
-{
-	/* byte 4-7 */
-	MV_U8 IgnoredByte4_7[4];
-	/* byte 8 */
-	MV_U8 ReservedByte8;
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-	/* byte 10 */
-	MV_U8 IgnoredByte10;
-	/* byte 11 */
-	MV_U8 ReservedByte11;
-	/* byte 12-15 */
-	MV_U32 CRC;
-}; /* struct SMPRequestPhyInput */
-
-
-/* request specific bytes for a self configuration expander function */
-struct SMPRequestSelfConfigurationInput
-{
-	/* byte 4-6 */
-	MV_U8 IgnoredByte4_6[3];
-	/* byte 7 */
-	MV_U8 StartSelfConfigurationStatusDescriptorIndex;
-	/* byte 8-11 */
-	MV_U32 CRC;
-}; /* struct SMPRequestSelfConfigurationInput */
-
-/* request specific bytes for a request route function */
-struct SMPRequestRouteInformationInput
-{
-	/* byte 4-5 */
-	MV_U8 IgnoredByte4_5[2];
-	/* byte 6-7 */
-	MV_U8 ExpanderRouteIndex[2];
-	/* byte 8 */
-	MV_U8 ReservedByte8;
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-	/* byte 10 */
-	MV_U8 IgnoredByte10;
-	/* byte 11 */
-	MV_U8 ReservedByte11;
-	/* byte 12-15 */
-	MV_U32 CRC;
-}; /* struct SMPRequestRouteInformationInput */
-
-/* request specific bytes for SMP DISCOVER LIST function */
-struct SMPRequestDiscoverList
-{
-	/* byte 4-7 */
-	MV_U8 ReservedByte4_7[4];
-	/* byte 8 */
-	MV_U8 StartingPhyIdentifier;
-	/* byte 9 */
-	MV_U8 MaximumNumberOfDescriptors;
-
-	/* byte 10 */
-	MV_U8 PhyFilter:4;
-	MV_U8 IgnoredByte10Bit4_6:3;
-	MV_U8 IgnoreZoneGroup:1;
-
-	/* byte 11 */
-	MV_U8 DescriptorType:4;
-	MV_U8 IgnoredByte11Bit4_7:4;
-
-	/* byte 12-15 */
-	MV_U8 IgnoredByte12_15[4];
-
-	/* byte 16-27 */
-	MV_U8 VendorSpecific[12];
-
-	/* byte 28-31 */
-	MV_U32 CRC;
-}; /* struct SMPRequestDiscoverList */
-
-/* request specific bytes for SMP REPORT EXPANDER ROUTE TABLE function */
-struct SMPRequestReportExpanderRouteTable
-{
-	/* byte 4-7 */
-	MV_U8 ReservedByte4_7[4];
-	/* byte 8-9 */
-	MV_U8 MaximumNumberOfDescriptors[2];
-
-	/* byte 10-15 */
-	MV_U8 StartingRoutedSASAddressIndex[6];
-
-	/* byte 16-18 */
-	MV_U8 IgnoredByte16_18[3];
-
-	/* byte 19 */
-	MV_U8 StartingPhyIdentifier;
-
-	/* byte 20-27 */
-	MV_U8 IgnoredByte20_27[8];
-
-	/* byte 28-31 */
-	MV_U32 CRC;
-}; /* struct SMPRequestReportExpanderRouteTable */
-
-/* request specific bytes for SMP CONFIGUARE GENERAL function */
-struct SMPRequestConfigureGeneral
-{
-	/* byte 4-5 */
-	MV_U8 ExpectedExpanderChangeCount[2];
-	/* byte 6-7 */
-	MV_U8 IgnoredByte6_7[2];
-
-	/* byte 8 */
-	MV_U8 UpdateSTPBusInactivityTimeLimit:1;
-	MV_U8 UpdateSTPMaxConnectTimeLimit:1;
-	MV_U8 UpdateSTPSMPNexusLossTime:1;
-	MV_U8 IgnoredByte8Bit3_7:5;
-
-	/* byte 9 */
-	MV_U8 IgnoredByte9;
-
-	/* byte 10-11 */
-	MV_U8 STPBusInactivityTimeLimit[2];
-	/* byte 12-13 */
-	MV_U8 STPMaxConnectTimeLimit[2];
-
-	/* byte 14-15 */
-	MV_U8 STPSMPNexusLossTime[2];
-
-	/* byte 16-19 */
-	MV_U32 CRC;
-}; /* struct SMPRequestConfigureGeneral */
-
-/* request specific bytes for ENABLE DISABLE ZONING function */
-struct SMPRequestEnableDisableZoning
-{
-	/* byte 4-5 */
-	MV_U8 ExpectedExpanderChangeCount[2];
-
-	/* byte 6-7 */
-	MV_U8 IgnoredByte4_5[2];
-
-	/* byte 8 */
-	MV_U8 EnableDisableZoning:1;
-	MV_U8 ReservedByte8Bit1_7:7;
-
-	/* byte 9-11 */
-	MV_U8 IgnoredByte9_11;
-
-	/* byte 12-15 */
-	MV_U32 CRC;
-}; /* struct SMPRequestEnableDisableZoning */
-
-/* request specific bytes for SMP ZONED BROADCAST function */
-struct SMPRequestZonedBroadcast
-{
-	/* byte 4-5 */
-	MV_U8 RestrictByte4_5[2];
-	/* byte 6 */
-	MV_U8 BroadcastType:3;
-	MV_U8 ReservedByte6Bit3_7:5;
-	/* byte 7 */
-	MV_U8 NumberOfBroadcastSourceZoneGroups;
-	/* byte 8-135 */
-	MV_U8 BroadcastSourceZoneGroup[0x80];
-	/* value between 0 and 127 */
-	/*
-	 * byte 135 -n: PAD field
-	 * Contains zero,one,two or three bytes set to 0x00 such that
-	 * total length of the SMP request is a multiple of four
-	*/
-	MV_U8 Pad[3];
-	/* byte n-4-n */
-	MV_U32 CRC;
-}; /* struct SMPRequestZonedBroadcast */
-
-/* request specific bytes for SMP ConfigureRouteInformation function */
-struct SMPRequestConfigureRouteInformation
-{
-	/* byte 4-5 */
-	MV_U8 ExpectedExpanderChangeCount[2];
-	/* byte 6-7 */
-	MV_U8 ExpanderRouteIndex[2];
-	/* byte 8 */
-	MV_U8 ReservedByte8;
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-	/* byte 10-11 */
-	MV_U8 ReservedByte10_11[2];
-	/* byte 12 */
-	MV_U8 IgnoredByte12Bit0_6:7;
-	/*
-	* if a routing error is detected
-	* then the route is disabled by
-	* setting this bit
-	*/
-	MV_U8 DisableRouteEntry:1;
-	/* byte 13-15 */
-	MV_U8 IgnoredByte13_15[3];
-	/* byte 16-23 */
-	MV_U8 RoutedSASAddress[8]; 	/*
-					 * identical to the AttachedSASAddress
-					 * found through discovery
-					 */
-	/* byte 24-39 */
-	MV_U8 ReservedByte24_39[16];
-
-	/* byte 40-43 */
-	MV_U32 CRC;
-}; /* struct SMPRequestConfigureRouteInformation */
-
-/* request specific bytes for SMP Phy Control function */
-struct SMPRequestPhyControl
-{
-	/* byte 4-5 */
-	MV_U8 ExpectedExpanderChangeCount[2];
-
-	/* byte 6-8 */
-	MV_U8 IgnoredByte6_8[3];
-
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-
-	/* byte 10 */
-	MV_U8 PhyOperation;
-
-	/* byte 11 */
-	MV_U8 UpdatePartialPathwayTimeoutValue:1;
-	MV_U8 ReservedByte11Bit1_7:7;
-
-	/* byte 12-31 */
-	MV_U8 IgnoredByte12_31[20];
-
-	/* byte 32 */
-	MV_U8 IgnoredByte32Bit0_3:4;
-	MV_U8 ProgrammedMinimumPhysicalLinkRate:4;
-
-	/* byte 33 */
-	MV_U8 IgnoredByte33Bit0_3:4;
-	MV_U8 ProgrammedMaximumPhysicalLinkRate:4;
-
-	/* byte 34-35 */
-	MV_U8 IgnoredByte34_35[2];
-
-	/* byte 36 */
-	MV_U8 PartialPathwayTimeoutValue:4;
-	MV_U8 ReservedByte36Bit4_7:4;
-
-	/* byte 37-39 */
-	MV_U8 ReservedByte37_39[3];
-
-	/* byte 40-43 */
-	MV_U32 CRC;
-}; /* struct SMPRequestPhyControl */
-
-/* request specific bytes for SMP Phy Test function */
-struct SMPRequestPhyTest
-{
-	/* byte 4-5 */
-	MV_U8 ExpectedExpanderChangeCount[2];
-
-	/* byte 6-8 */
-	MV_U8 IgnoredByte6_8[3];
-
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-
-	/* byte 10 */
-	MV_U8 PhyTestFunction;
-
-	/* byte 11 */
-	MV_U8 PhyTestPattern;
-
-	/* byte 12-14 */
-	MV_U8 ReservedByte12_14[3];
-
-	/* byte 15 */
-	MV_U8 PhyTestPatternPhysicalLinkRate:4;
-	MV_U8 ReservedByte15Bit4_7:4;
-
-	/* byte 16-18 */
-	MV_U8 ReservedByte16_18[3];
-
-	/* byte 19 */
-	MV_U8 PhyTestPatternDwordsControl;
-
-	/* byte 20-27 */
-	MV_U8 PhyTestPatternDwords[8];
-
-	/* byte 28-39 */
-	MV_U8 ReservedByte28_39[12];
-
-	/* byte 40-43 */
-	MV_U32 CRC;
-}; /* struct SMPRequestPhyTest */
-
-/* request specific bytes for SMP CONFIGUARE PHY EVENT INFORMATION function */
-struct SMPRequestConfigurePhyEventInformation
-{
-	/* byte 4-5 */
-	MV_U8 ExpectedExpanderChangeCount[2];
-
-	/* byte 6 */
-	MV_U8 ClearPeaks:1;
-	MV_U8 ReservedByte6Bit1_7:6;
-
-	/* byte 7-8 */
-	MV_U8 ReservedByte7_8[2];
-
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-
-	/* byte 10 */
-	MV_U8 ReservedByte10;
-
-	/* byte 11 */
-	MV_U8 NumberOfPhyEventConfigurationDescriptors;
-
-	/* byte 11-138 */
-	MV_U8 PhyEventConfigurationDescriptors[0x80];
-	MV_U32 CRC;
-}; /* struct SMPRequestConfigurePhyEventInformation */
-
-
-/*
- * request sent specific to SMP Read SGPIO
- * Corresponds to READ_GPIO_REGISTER define
- */
-struct SMPRequestReadGPIORegister
-{
-	/* byte 4 */
-	MV_U8 RegisterCount;
-	/* byte 5-7 */
-	MV_U8 ReservedByte[3];
-	MV_U32 CRC;
-};
-
-/*
-	request sent specific to SMP Write SGPIO
-	Corresponds to WRITE_GPIO_REGISTER define
-*/
-struct SMPRequestWriteGPIORegister
-{
-	/* byte 4 */
-	MV_U8 RegisterCount;
-
-	/* byte 5-7 */
-	MV_U8 ReservedByte[3];
-
-	/* byte 8-15 */
-	MV_U8 Data_Out_Low[8];
-
-	/* byte 16-23 */
-	MV_U8 Data_Out_High[8];
-
-	MV_U32 CRC;
-};
-
-/*
-	generic structure referencing an SMP Request, must be initialized
-	before being used
-*/
-typedef struct _smp_request
-{
-	/* byte 0 */
-	MV_U8 smp_frame_type; /* always SMP_REQUEST_FRAME = 0x40 */
-
-	/* byte 1 */
-	MV_U8 function;
-
-	/* byte 2 */
-	MV_U8 resp_len;		/* Allocated response length, set to zero
-				   for compatibility */
-	/* byte 3 */
-	MV_U8 req_len;		/* Request length, set to zero
-				   for compatibility */
-	/* bytes 4-n */
-	union
-	{
-	/* #define REPORT_GENERAL 			0x00 */
-		struct SMPRequestGeneralInput 		ReportGeneral;
-
-	/* #define REPORT_MANUFACTURER_INFORMATION 	0x01 */
-		struct SMPRequestGeneralInput 		ReportManufacturerInformation;
-
-	/* #define READ_GPIO_REGISTER			0x02 */
-		struct SMPRequestReadGPIORegister		ReadGPIORegister;
-
-	/* #define REPORT_SELF_CONFIGURATION_STATUS	0x03 */
-		struct SMPRequestSelfConfigurationInput	ReportSelfConfigurationStatus;
-
-	/* #define DISCOVER 				0x10 */
-		struct SMPRequestPhyInput 		Discover;
-
-	/* #define REPORT_PHY_ERROR_LOG 			0x11 */
-		struct SMPRequestPhyInput 		ReportPhyErrorLog;
-
-	/* #define REPORT_PHY_SATA 			0x12 */
-		struct SMPRequestPhyInput 		ReportPhySATA;
-
-	/* #define REPORT_ROUTE_INFORMATION 		0x13 */
-		struct SMPRequestRouteInformationInput 	ReportRouteInformation;
-
-	/* #define REPORT_PHY_EVENT_INFORMATION		0x14 */
-		struct SMPRequestPhyInput			ReportPhyEventInformation;
-
-	/* #define REPORT_PHY_BROADCAST_COUNTS		0x15 */
-		struct SMPRequestPhyInput			ReportPhyBroadcaseCounts;
-
-	/* #define DISCOVER_LIST				0x16 */
-		struct SMPRequestDiscoverList		DiscoverList;
-
-	/* #define REPORT_EXPANDER_ROUTE_TABLE		0x17 */
-		struct SMPRequestReportExpanderRouteTable	ReportExpanderRouteTable;
-
-	/* #define CONFIGURE_GENERAL			0x80 */
-		struct SMPRequestConfigureGeneral		ConfigureGeneral;
-
-	/* #define ENABLE_DISABLE_ZONING			0x81 */
-		struct SMPRequestEnableDisableZoning	EnableDisableZoning;
-
-	/* #define WRITE_GPIO_REGISTER			0x82 */
-		struct SMPRequestWriteGPIORegister		WriteGPIORegister;
-
-	/* #define ZONED_BROADCAST			0x85 */
-		struct SMPRequestZonedBroadcast		ZonedBroadcast;
-
-	/* #define CONFIGURE_ROUTE_INFORMATION 		0x90 */
-		struct SMPRequestConfigureRouteInformation 	ConfigureRouteInformation;
-
-	/* #define PHY_CONTROL 				0x91 */
-		struct SMPRequestPhyControl 		PhyControl;
-
-	/* #define PHY_TEST 				0x92 */
-		struct SMPRequestPhyTest 			PhyTest;
-
-	/* #define CONFIGURE_PHY_EVENT_INFORMATION	0x93 */
-		struct SMPRequestConfigurePhyEventInformation	ConfigurePhyEventInformation;
-
-	} request;
-} smp_request; /* struct _smp_request */
-
-typedef struct _smp_request mv_smp_command_table;
-
-/*
-request specific bytes for SMP Report General response, intended to be
-referenced by SMPResponse
-*/
-struct SMPResponseReportGeneral
-{
-	/*
-	byte 4-5: EXPANDER CHANGE COUNT
-	Counts the number of Broadcast (Change)s originated by an expander device.
-	Management device servers in expander devices shall support this field.
-	Management device servers in other device types (e.g., end devices) shall
-	set this field to 0000h. This field shall be set to at least 0001h at power
-	on. If the expander device has originated Broadcast (Change) for any reason
-	described in 7.11 since transmitting a REPORT GENERAL response, it shall increment
-	this field at least once from the value in the previous REPORT GENERAL response.
-	It shall not increment this field when forwarding a Broadcast (Change). This field
-	shall wrap to at least 0001h after the maximum value (i.e., FFFFh) has been reached.
-	*/
-	MV_U8 ExpanderChangeCount[2];
-	/*
-	byte 6-7: EXPANDER ROUTE INDEXES
-	Contains the maximum number of expander route indexes per phy for the expander
-	device. Management device servers in externally configurable expander devices
-	containing phy-based expander route tables shall support this field. Management
-	device servers in other device types (e.g., end devices, externally configurable
-	expander devices with expander-based expander route tables, and self-configuring
-	expander devices) shall set the EXPANDER ROUTE INDEXES field to zero. Not all
-	phys in an externally configurable expander device are required to support the
-	maximum number indicated by this field.
-	*/
-	MV_U8 ExpanderRouteIndexes[2];
-
-	/* byte 8: reserved */
-
-	MV_U8 ReservedByte8;
-	/*
-	byte 9:NUMBER OF PHYS
-	Contains the number of phys in the device, including any virtual phys and any
-	vacant phys
-	*/
-	MV_U8 NumberOfPhys;
-
-
-	/*
-	byte 10-bit0:
-	EXTERNALLY CONFIGURABLE ROUTE TABLE
-	Set to one indicates that the management device server is in an externally
-	configurable expander device that has a phy-based expander route table
-	that is required to be configured with the SMP CONFIGURE ROUTE INFORMATION
-	function. An EXTERNALLY CONFIGURABLE ROUTE TABLE bit set to zero indicates
-	that the management device server is not in an externally configurable expander
-	device (e.g., it is in an end device, in a self-configuring expander device,
-	or in an expander device with no phys with table routing attributes).
-
-	byte 10-bit1:
-	CONFIGURING
-	Set to one indicates that the management device server is in a self-configuring
-	expander device, the self-configuring expander device¡¯s management application
-	client is currently performing the discover process, and it has identified at
-	least one change to its expander routing table. A CONFIGURING bit set to zero
-	indicates that the management device server is not in a self-configuring expander
-	device currently performing the discover process and changing its expander
-	routing table. Changes in this bit from one to zero result in a Broadcast (Change)
-	being originated. Management device servers in self-configuring expander
-	devices shall support this bit. Management device servers in externally
-	configurable expander devices and in other device types shall set the CONFIGURING
-	bit to zero.
-
-	byte 10-bit2:
-	CONFIGURES OTHERS
-	Set to one indicates that the expander device is a self-configuring expander
-	device that performs the configuration subprocess. A CONFIGURES OTHERS bit set
-	to zero indicates the expander device may or may not perform the configuration
-	subprocess. Self-configuring expander devices compliant with this standard
-	shall set the CONFIGURES OTHERS bit to one.If the CONFIGURES OTHERS bit is set
-	to zero, the expander device may configure all externally configurable expander
-	devices in the SAS domain.
-
-	byte 10-bit7:
-	TABLE TO TABLE SUPPORTED
-	Set to one indicates the expander device is a self-configuring expander
-	device that supports its table routing phys being attached to table routing
-	phys in other expander devices. The TABLE TO TABLE SUPPORTED bit shall only
-	be set to one if the EXTERNALLY CONFIGURABLE ROUTE TABLE bit is set to
-	zero. A TABLE TO TABLE SUPPORTED bit set to zero indicates the expander device
-	is not a self-configuring expander device that supports its table routing
-	phys being attached to table routing phys in other expander devices.
-	*/
-
-
-	MV_U8 ConfigurableRouteTable:1;		/* BIT 0*/
-	MV_U8 Configuring:1;					/* BIT 1*/
-	MV_U8 ConfiguresOthers:1;			/* BIT 2*/
-	MV_U8 ReservedByte10Bit3_6:4;		/* BIT 3-6*/
-	MV_U8 TableToTableSupported:1;		/* BIT 7*/
-
-	/* byte 11: reserved */
-	MV_U8 ReservedByte11;
-
-	/*
-	byte 12-19:
-	ENCLOSURE LOGICAL IDENTIFIER
-	Identifies the enclosure, if any, in which the device is located, and is
-	defined in SES-2. The ENCLOSURE LOGICAL IDENTIFIER field shall be set to
-	the same value reported by the enclosure services process, if any, for
-	the enclosure. An ENCLOSURE LOGICAL IDENTIFIER field set to zero indicates
-	no enclosure information is available.
-	*/
-	MV_U8 EnclosureLogicalIdentifier[8];
-
-	/* 	byte 20-29: reserved */
-	MV_U8 ReservedByte20_29[10];
-
-	/*
-	byte 30-31:
-	STP BUS INACTIVITY TIME LIMIT
-	Contains the bus inactivity time limit for STP connections which is set by
-	the CONFIGURE GENERAL function
-	*/
-	MV_U8 STPBusInactivityTimeLimit[2];
-
-	/*
-	byte 32-33:
-	STP MAXIMUM CONNECT TIME LIMIT
-	Contains the maximum connect time limit for STP connections
-	which is set by the CONFIGURE GENERAL function.
-	*/
-	MV_U8 STPMaxConnectTimeLimit[2];
-
-	/*
-	byte 34-35:
-	STP SMP I_T NEXUS LOSS TIME
-	Contains the time that an STP target port and an SMP initiator port retry
-	certain connection requests which is set by the CONFIGURE GENERAL function.
-	*/
-	MV_U8 STPSMPNexusLossTime[2];
-
-	/*
-	byte 36-bit0:
-	ZONING ENABLED
-	Set to one indicates that zoning is enabled in the expander device. A ZONING
-	ENABLED bit set to zero indicates that zoning is disabled in the expander
-	device. The ZONING ENABLED bit shall be set to zero if the ZONING SUPPORTED bit
-	is set to zero.
-
-	byte 36-bit1:
-	ZONING SUPPORTED
-	Set to one indicates that zoning is supported by the expander device(i.e., it
-	is a zoning expander device). A ZONING SUPPORTED bit set to zero indicates that
-	zoning is not supported by the expander device.
-
-	byte 36-bit2:
-	PHYSICAL PRESENCE ASSERTED
-	Set to one indicates that the expander device is currently detecting
-	physical presence. A PHYSICAL PRESENCE ASSERTED bit set to zero indicates that
-	the expander device is not currently detecting physical presence. The PHYSICAL
-	PRESENCE ASSERTED bit shall be set to zero if the PHYSICAL PRESENCE SUPPORTED
-	bit is set to zero.
-
-	byte 36-bit3:
-	PHYSICAL PRESENCE SUPPORTED
-	Set to one indicates that the expander device supports physical presense
-	as a mechanism for allowing zoning to be enabled or disabled from phys in
-	zone groups without access to zone group 2. A PHYSICAL PRESENCE SUPPORTED bit
-	set to zero indicates that the expander device does not support physical
-	presence as a mechanism for allowing zoning to be enabled or disabled.
-
-	*/
-	MV_U8 ZoningEnabled:1;				/* Bit 0*/
-	MV_U8 ZoningSupported:1;			/* Bit 1*/
-	MV_U8 PhysicalPresenceAsserted:1;	/* Bit 2*/
-	MV_U8 PhysicalPresenceSupported:1;	/* Bit 3*/
-	MV_U8 ReservedByte36Bit4_7:4;		/* Bit 4-7*/
-
-	/* 	byte 37: reserved */
-	MV_U8 ReservedByte37;
-
-	/*
-	byte 38-39:
-	MAXIMUM NUMBER OF ROUTED SAS ADDRESSES
-	Contains the number of routed SAS addresses in an expander-based expander route
-	table. Management device servers in expander devices containing expander-based
-	expander route tables shall support this field. Management device servers in
-	other device types (e.g., end devices and expander devices with phy-based expander
-	route tables) shall set this field to 0000h.
-	*/
-	MV_U8 MaxNumRoutedSASAddr[2];
-
-	/* 	byte 40-43 CRC */
-	MV_U32 CRC;
-}; /* struct SMPResponseReportGeneral */
-
-
-	/*
-	request specific bytes for SMP Report Manufacturer Information response,
-	intended to be referenced by SMPResponse
-	*/
-struct SMPResponseReportManufacturerInformation
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-
-	/* byte 6-7 */
-	MV_U8 ReservedByte6_7[2];
-
-	/* byte 8	*/
-	MV_U8 SAS11Format:1;
-	MV_U8 ReservedByte8_Bit1_7:7;
-
-	/* byte 9-11 */
-	MV_U8 IgnoredByte9_11[3];
-
-	/* byte 12-19 */
-	MV_U8 VendorIdentification[8];
-
-	/* byte 20-35 */
-	MV_U8 ProductIdentification[16];
-
-	/* byte 36-39 */
-	MV_U8 ProductRevisionLevel[4];
-
-	/* byte 40-47 */
-	MV_U8 ComponentVendorIdentification[8];
-
-	/* byte 48-49 */
-	MV_U8 ComponentID[2];
-
-	/* byte 50 */
-	MV_U8 ComponentRevisionID;
-
-	/* byte 51 */
-	MV_U8 ReservedByte51;
-
-	/* byte 52-59 */
-
-	MV_U8 VendorSpecific[8];
-	/* byte 60-63 */
-	MV_U32 CRC;
-}; /* struct SMPResponseReportManufacturerInformation */
-
-/*
-	request specific bytes for SMP Report Self-Configuration Status response,
-	intended to be referenced by SMPResponse
-*/
-struct SMPResponseReportSelfConfigurationStatus
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-
-	/* byte 6 */
-	MV_U8 ReservedByte6;
-
-	/* byte 7 */
-	MV_U8 StartingSelfConfigurationStatusDescriptorIndex;
-
-	/* byte 8-12	*/
-	MV_U8 ReservedByte8_12[5];
-
-	/* byte 13 */
-	MV_U8 MaxSupportedSelfConfigurationStatusDescriptors;
-
-	/* byte 14 */
-	MV_U8 TotalNumberOfSelfConfigurationStatusDescriptors;
-
-	/* byte 15 */
-	MV_U8 NumberOfSelfConfigurationStatusDescriptors;
-
-	/* byte 16-31 */
-	MV_U8 SelfConfigurationStatusDescriptor[16];
-/*
-	byte SelfConfigurationStatusDescriptor_1[16];
-		...
-	byte SelfConfigurationStatusDescriptor_n[16];
-
-*/
-	MV_U32 CRC;
-}; /* struct SMPResponseReportSelfConfigurationStatus */
-
-/*
-	request specific bytes for SMP Report Phy Error Log response,
-	intended to be referenced by SMPResponse
-*/
-struct SMPResponseReportPhyErrorLog
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-
-	/* byte 6-8 */
-	MV_U8 ReservedByte6_8[3];
-
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-
-	/* byte 10-11 */
-	MV_U8 ReservedByte10_11[2];
-
-	/* byte 12-15 */
-	MV_U8 InvalidDwordCount[4];
-
-	/* byte 16-19 */
-	MV_U8 RunningDisparityErrorCount[4];
-
-	/* byte 20-23 */
-	MV_U8 LossOfDwordSynchronizationCount[4];
-
-	/* byte 24-27 */
-	MV_U8 PhyResetProblemCount[8];
-
-	/* byte 28-31 */
-	MV_U32 CRC;
-}; /* struct SMPResponseReportPhyErrorLog */
-
-/*
-	Response specific bytes for SMP Discover Descriptor, intended to be
-	referenced by SMPResponseDiscover, SMPResponseDiscoverList
-*/
-struct DiscoverLongFormatDescriptor
-{
-	/* byte 48-49: Reserved */
-	MV_U8 ReservedByte48_49[2];
-
-	/* byte 50-51: Vendor specific */
-	MV_U8 VendorSpecific[2];
-
-/*
-	byte 52-59: ATTACHED DEVICE NAME
-	Contains the value of the the device name field received in the IDENTIFY
-	address frame during the identification sequence. If the attached port is
-	an expander port or a SAS port, the ATTACHED DEVICE NAME field contains the
-	device name of the attached expander device or SAS device. If the attached port
-	is a SATA device port, the ATTACHED DEVICE NAME field contains 00000000 00000000h.
-	The ATTACHED DEVICE NAME field shall be updated:
-		a) after the identification sequence completes, if a SAS phy or expander phy is attached; or
-		b) after the COMSAS Detect Timeout timer expires, if a SATA phy is attached.
-*/
-	MV_U8 AttachedDeviceName[8];
-
-/*
-Zone group		Configurable 	Description
-				zone permission
-				table entries
-
-0 				No 		Phys in zone group 0 only have access to
-						other phys in zone group 1.
-
-1 				No 		Phys in zone group 1 have access to other
-						phys in all zone groups.
-
-2 				Yes		Phys in zone group 2 have access to other
-						phys based on the zone permission table.
-						A management device server in a zoning
-						expander device with zoning enabled only
-						allows management application clients using
-						phys in zone groups with access to zone
-						group 2 to perform the following SMP functions:
-							a) SMP zoning configuration functions (e.g., CONFIGURE ZONE
-							PERMISSION); and
-							b) SMP expander configuration functions (i.e., CONFIGURE GENERAL).
-						A management device server in a zoning
-						expander device with zoning enabled only
-						allows management application clients to
-						perform certain SMP phy-based control and
-						configuration functions (i.e., PHY CONTROL,
-						PHY TEST FUNCTION, and CONFIGURE PHY EVENT
-						INFORMATION) if the zone group of the management
-						application client¡¯s phy has access to
-						zone group 2 or the zone group of the specified phy.
-
-3 			Yes			Phys in zone group 3 have access to other phys based
-						on the zone permission table.
-						A management device server in a zoning expander device
-						with zoning enabled only allows management application
-						clients using a phy in a zone group with access to
-						zone group 3 to perform certain SMP zoning-related
-						functions (i.e., ZONED BROADCAST).
-
-4 to 7 			Reserved
-
-8 to 127 Yes 					Phys in zone groups 8 through 127 have access to other
-								phys based on the zone permission table.
-
-
-
-			Source zone group determination
-Attribute of the expander phy that		Source zone group
-received the OPEN address frame
-ZONE ADDRESS	Routing	INSIDE ZPSDS
-RESOLVED bit	method	bit
-0 				Any		0 		Zone group of the receiving expander phy
-
-0 				Any 	1			Source zone group specified by the SOURCE ZONE
-								GROUP field in the received OPEN address frame.
-
-1				Direct	0			Zone group of the receiving expander phy.
-
-1 				Direct	1			Not applicable.
-
-
-1 				Subtractive 0			Zone group of the receiving expander phy.
-
-1				Subtractive 1			Not applicable.
-
-
-1				Table	0			Zone group stored in the zoning expander route
-								table for the source SAS address. If the source
-								SAS address is not found in the zoning expander
-								route table then the zone group of the receiving
-								expander phy.
-1				Table 	1	 		Not applicable.
-
-
-
-			Destination zone group determination
-Routing method of the			Destination zone group
-destination expander phy
-Direct 						Zone group of the destination expander phy.
-
-Subtractive 					Zone group of the destination expander phy (i.e., the
-						subtractive expander phy).
-
-Table 						Zone group stored in the zoning expander route table for
-						the destination SAS address.
-
-At the completion of a link reset sequence, if a SATA device is attached to an expander phy, the
-zoning expander device with zoning enabled shall set the INSIDE ZPSDS bit to zero for that expander phy.
-At the completion of a link reset sequence, if a SATA device is not attached to an expander phy, the zoning
-expander device with zoning enabled shall update the phy zone information fields based on:
-a) the REQUESTED INSIDE ZPSDS bit and the INSIDE ZPSDS PERSISTENT bit in the zone phy information (i.e.,
-the bits transmitted in the outgoing IDENTIFY address frame); and
-b) the REQUESTED INSIDE ZPSDS bit and INSIDE ZPSDS PERSISTENT bit received in the incoming IDENTIFY
-address frame.
-
-		Phy zone information fields after by a link reset seqeunce
-REQUESTED						INSIDE ZPSDS		Phy zone information field changes
-INSIDE ZPSDS bit				PERSISTENT bit
-
-Transmitted Received 			Transmitted Received
-0 			0 or 1				0 or 1 		0 or 1 	The zoning expander device shall set the INSIDE
-														ZPSDS bit to zero.
-
-1 			0					0 or 1 		0 or 1	The zoning expander device shall set the INSIDE
-														ZPSDS bit to zero.
-
-1 			1 					0			0		If the SAS address received in the IDENTIFY
-													address frame during the identification
-													sequence is different from the SAS address
-													prior to the completion of the link reset
-1			1					0			1		sequence, then the zoning expander device
-													shall set:
-													a) the REQUESTED INSIDE ZPSDS bit to zero; and
-1			1					1			0		b) the INSIDE ZPSDS bit to zero.
-													If the SAS address received in the IDENTIFY
-													address frame during the identification
-													sequence is the same as the SAS address prior
-													to the completion of the link reset sequence,
-													then the zoning expander device shall set:
-													a) the INSIDE ZPSDS bit to one;
-													b) the ZONE GROUP field to one; and
-													c) the ZONE ADDRESS RESOLVED bit to zero.
-
-1			1					1			1		The zoning expander device shall set:
-													a) the INSIDE ZPSDS bit to one;
-													b) the ZONE GROUP field to one; and
-													c) the ZONE ADDRESS RESOLVED bit to zero.
-
-
-If the ZONE GROUP PERSISTENT bit is set to one, then a link reset sequence shall not cause the zone
-group value of an expander phy to change unless the INSIDE ZPSDS bit changes from zero to one.
-If the ZONE GROUP PERSISTENT bit is set to zero, then table 29 specifies events based on the initial
-condition of an expander phy that shall cause a zoning expander device with zoning enabled to change the
-ZONE GROUP field of the expander phy to its default value (e.g., zero).
-
-	Events that cause the ZONE GROUP field to be set to its default value when the ZONE GROUP
-	PERSISTENT bit set to zero
-Initial condition 			Event after the initial condition is established
-Completed link reset		A subsequent link reset sequence completes and:
-sequence with a				a) the SAS address received in the IDENTIFY address frame during
-SAS device attached			the identification sequence is different from the SAS address prior to the
-					completion of the link reset sequence; or
-					b) a SATA device is attached.
-
-Completed link reset		Either:
-sequence with a			a) A subsequent link reset sequence completes and:
-SATA device			A) a hot-plug timeout occurred between the time of the initial
-attached				condition and the time the link reset sequence completed;
-				B) the zoning expander device has detected the possibility that a new SATA
-				device has been inserted. The method of detection is outside the scope of
-				this standard (e.g., an enclosure services process reports a change in the
-				ELEMENT STATUS CODE field in the Device or Array Device element (see
-				SES-2), or a change in the WORLD WIDE NAME field in the attached SATA
-				device¡¯s IDENTIFY DEVICE or IDENTIFY PACKET DEVICE data (see
-				ATA8-ACS)); or
-				C) a SAS phy or expander phy is attached;
-				or
-				b) The expander phy is disabled with the SMP PHY CONTROL function
-				DISABLE phy operation.
-
-The BPP determines the source zone group(s) of the Broadcast as follows:
-a) if the BPP receives a Broadcast Event Notify message from an expander phy (i.e., a zoning expander
-phy received a BROADCAST), the Broadcast has a single source zone group set to the zone group of
-that expander phy; and
-b) if the BPP receives a message from the management device server indicating that it received an SMP
-ZONED BROADCAST request from an SMP initiator port that has access to zone group 3, the
-Broadcast has each of the source zone groups specified in the SMP ZONED BROADCAST request.
-The BPP forwards the Broadcast to each expander port other than the one on which the Broadcast was
-received (i.e., the expander port that received the BROADCAST or SMP ZONED BROADCAST request) if
-any of the source zone groups have access to the zone group of the expander port.
-To forward a Broadcast to an expander port:
-a) if the expander port¡¯s INSIDE ZPSDS bit is set to one, the BPP shall request that the SMP initiator port
-establish a connection on at least one phy in the expander port to the SMP target port of the attached
-expander device and transmit an SMP ZONED BROADCAST request specifying the source zone
-group(s); and
-b) if the expander port¡¯s INSIDE ZPSDS bit is set to zero, the BPP shall send a Transmit Broadcast
-message to at least one phy in the expander port, causing it to transmit a BROADCAST.
-
-
-	byte 60-bit0: ZONING ENABLED
-	Set to one indicates that zoning is enabled in the expander device.
-	A ZONING ENABLED bit set to zero indicates that zoning is disabled
-	in the expander device.
-
-	byte 60-bit1: INSIDE ZPSDS
-	Indicates if the phy is inside or on the boundary of a ZPSDS.
-	0: The phy is attached to an end device, an expander device that does not support
-	   zoning, or a zoning expander device with zoning disabled.
-	1: The phy is attached a zoning expander device with zoning enabled and is thus
-	   inside a ZPSDS.
-
-	The bit is not directly changeable and only changes following a link reset sequence,
-	based on the REQUESTED INSIDE ZPSDS bit.
-
-	byte 60-bit2: ZONE GROUP PERSISTENT
-	Specifies the method of determining the zone group value of the phy after a link
-	reset sequence when the INSIDE ZPSDS is set to zero.
-
-	byte 60-bit3: ZONE ADDRESS RESOLVED
-	Specifies the method used to determine the source code group for a connection request
-	received by a phy at the boundary of the ZPSDS.
-	The bit may be set to one when:
-	 a) the phy is contained within a zoning expander device; and
-	 b) the INSIDE ZPSDS bit for the phy is set to zero.
-	The bit may be set to zero when:
-	 a) the phy is contained within a non-zoning expander device; or
-	 b) the phy is contained within a zoning expander device and the INSIDE ZPSDS for the
-	    phy is set to one.
-
-
-	byte 60-bit4: REQUESTED INSIDE ZPSDS
-	Used to establish the boundary of the ZPSDS and to determine the value of other zone
-	phy information fields after a link reset sequence.
-
-	byte 60-bit5: INSIDE ZPSDS PERSISTENT
-	Indicates the method used to determine the value of the INSIDE ZPSDS bit after a
-	link reset sequence.
-
-	byte 60-bit6: REQUESTED INSIDE ZPSDS CHANGED BY EXPANDER
-	Set to one indicates that the zoning expander device set the REQUESTED INSIDE
-	ZPSDS bit to zero in the zone phy information at the completion of the last
-	link reset sequence. A REQUESTED INSIDE ZPSDS CHANGED BY EXPANDER bit set to
-	zero indicates that the zoning expander device did not set the REQUESTED INSIDE
-	ZPSDS bit to zero in the zone phy information at the completion of the last link
-	reset sequence.
-	The zone manager may use the REQUESTED INSIDE ZPSDS CHANGED BY EXPANDER bit to
-	determine why the REQUESTED INSIDE ZPSDS bit has changed in the DISCOVER
-	response from the value to which it last set the bit.
-
-
-	All phys in an expander port shall have the same zone phy information. The zone phy
-	information fields should be no-volatile and shall be preserved while zone is
-	disabled.
-*/
-	MV_U8 ZoningEnabled:1;			/* bit 0 */
-	MV_U8 InsideZPSDS:1;				/* bit 1 */
-	MV_U8 ZoneGroupPersistent:1;		/* bit 2 */
-	MV_U8 ZoneAddressResolved:1;		/* bit 3 */
-	MV_U8 RequestedInsideZPSDS:1;	/* bit 4 */
-	MV_U8 InsideZPSDSPersistent:1;	/* bit 5 */
-	MV_U8 RequestedInsideZPSDSChangedbyExpander:1;	/* bit 6 */
-	MV_U8 ReservedByte60Bit7:1;
-
-/*	byte 61-62: Reserved */
-	MV_U8 ReservedByte61_62[2];
-
-/*
-	byte 63: ZONE GROUP
-	Contains a value in the range of 0 to 127 that specifies the zone group to which the phy
-	blongs. The zone group of the SMP initiator port and SMP target port in a zoning expander
-	device shall be 1.
-
-*/
-	MV_U8 ZoneGroup;
-
-/*
-	byte 64:SELF-CONFIGURATION STATUS
-	Indicates the status of a self-configuring expander device pertaining to
-	the specified phy.
-
-	Code 	Description
-	00h 	Reserved
-	01h 	Error not related to a specific layer
-	02h 	The expander device currently has a connection or is currently attempting to establish a
-			connection with the SMP target port with the indicated SAS address.
-	03h 	Expander route table is full. The expander device was not able to add the indicated SAS
-			address to the expander route table.
-	04h		Expander device is out of resources (e.g., it discovered too many SAS addresses while
-			performing the discover process through a subtractive port). This does not affect the expander
-			route table.
-	05h-1Fh Reserved for status not related to specific layers
-
-	Status reported by the phy layer:
-	20h 	Error reported by the phy layer
-	21h 	All phys in the expander port containing the indicated phy lost dword synchronication
-	22h-3Fh Reserved for status reported by the phy layer
-
-*/
-	MV_U8 SelfConfigurationStatus;
-
-/*
-	byte 65: SELF-CONFIGURATION LEVELS COMPLETED
-	Indicates the number of levels of expander devices beyond the expander port
-	containing the specified phy for which the self-configuring expander device¡¯s
-	management application client has completed the discover process.
-
-	Code 	Description
-	00h		The management application client:
-			a) has not begun the discover process through the expander port containing the specified
-			phy; or
-			b) has not completed the discover process through the expander port containing the
-			specified phy.
-	01h 	The management application client has completed discovery of the expander device
-			attached to the expander port containing the specified phy (i.e., level 1).
-	02h		The management application client has completed discovery of the expander devices
-			attached to the expander device attached to the expander port containing the specified phy
-			(i.e., level 2).
-	... ...
-	FFh 	The management application client has completed discovery of the expander devices
-			attached at level 255.
-*/
-	MV_U8 SelfConfgurationLevelsCompleted;
-
-/*	byte 66-67: Reserved */
-	MV_U8 ReservedByte66_67[2];
-
-/*
-	byte 68-75: SELF-CONFIGURATION SAS ADDRESS
-	Indicates the SAS address of the SMP target port to which the self-configuring
-	expander device established a connection or attempted to establish a connection
-	using the specified phy and resulted in the status indicated by the
-	SELF-CONFIGURATION STATUS field.
-*/
-	MV_U8 SelfConfigurationSASAddress[8];
-}; /* DiscoverLongFormatDescriptor */
-
-
-
-/*
- * Response specific bytes for SMP Discover, intended to be referenced
- * by SMPResponse
- */
-struct SMPResponseDiscover
-{
-/*
-	byte 4-5:
-	EXPANDER CHANGE COUNT
-	Counts the number of Broadcast (Change)s originated by an expander device.
-	Management device servers in expander devices shall support this field.
-	Management device servers in other device types (e.g., end devices) shall
-	set this field to 0000h. This field shall be set to at least 0001h at power
-	on. If the expander device has originated Broadcast (Change) for any reason
-	described in 7.11 since transmitting a REPORT GENERAL response, it shall increment
-	this field at least once from the value in the previous REPORT GENERAL response.
-	It shall not increment this field when forwarding a Broadcast (Change). This field
-	shall wrap to at least 0001h after the maximum value (i.e., FFFFh) has been reached.
-*/
-	MV_U8 ExpanderChangeCount[2];
-
-/*	byte 6-8: Reserved	*/
-	MV_U8 ReservedByte6_8[3];
-
-/*
-	byte 9: PHY IDENTIFIER
-	Indicates the phy for which physical configuration link information
-	is being returned.
-*/
-	MV_U8 PhyIdentifier;
-
-/*	byte 10-11: Reserved	*/
-	MV_U8 ReservedByte10_11[2];
-
-/*
-	byte 12-bit4-6:ATTACHED DEVICE TYPE
-	001b: No device
-	010b: End device
-	010b: Expander device
-	011b: Expander device compliant with a previous version of this standard
-	Others: Reserved
-*/
-	MV_U8 ReservedByte12Bit0_3:4;	/* Bit0-3 */
-	MV_U8 AttachedDeviceType:3;		/* Bit4-6 */
-	MV_U8 IgnoredByte12Bit7:1;		/* Bit7 */
-/*
-	byte 13-bit0-3:	NEGOTIATED PHYSICAL LINK RATE
-	0x0: UNKNOW, Phy is enabled; unknown physical link rate.
-	0x1: DISABLED, Phy is disabled.
-	0x2: PHY_RESET_PROBLEM
-	0x3: SPINUP_HOLD, detected a SATA device and entered the SATA spinup hold state.
-	0x4: PORT_SELECTOR
-	0x5: RESET_IN_PROGRESS
-	0x8: G1, Phy is enabled; 1,5 Gbps physical link rate.
-	0x9: G2, Phy is enabled; 3,0 Gbps physical link rate.
-
-*/
-	MV_U8 NegotiatedPhysicalLinkRate:4;
-	MV_U8 ReservedByte13Bit4_7:4;
-
-/*
-	byte 14-bit0:ATTACHED SATA HOST
-	Set to one indicates a SATA host port is attached. An ATTACHED SATA HOST bit set
-	to zero indicates a SATA host port is not attached.
-
-	byte 14-bit1:ATTACHED SMP INITIATOR
-	Set to one specifies that an SMP initiator port is present.
-
-
-	byte 14-bit2:ATTACHED STP INITIATOR
-	Set to one specifies that an STP initiator port is present.
-
-
-	byte 14-bit3:ATTACHED SSP INITIATOR
-	Set to one specifies that an SSP initiator port is present.
-
-
-
-*/
-	MV_U8 InitiatorBits;
-	MV_U8 TargetBits;
-/*
-	byte 16-23:SAS ADDRESS
-	Contains the value of the SAS ADDRESS field transmitted in the IDENTIFY address
-	frame during the identification sequence. If the phy is an expander phy, the
-	SAS ADDRESS field contains the SAS address of the expander device. If the phy
-	is a SAS phy, the SAS ADDRESS field contains the SAS address of the SAS port.
-*/
-	MV_U8 SASAddress[8];
-
-
-/*
-	byte 24-31:ATTACHED SAS ADDRESS
-	Contains the value of the SAS ADDRESS field received in the IDENTIFY
-	address frame during the identification sequence. If the attached port
-	is an expander port, the ATTACHED SAS ADDRESS field contains the SAS address
-	of the attached expander device. If the attached port is a SAS port, the
-	ATTACHED SAS ADDRESS field contains SAS address of the attached SAS port.
-	If the attached port is a SATA device port, the ATTACHED SAS ADDRESS field
-	contains the SAS address of the STP/SATA bridge.
-	The ATTACHED SAS ADDRESS field shall be updated:
-		a) after the identification sequence completes, if a SAS phy or expander
-	phy is attached; or
-		b) after the COMSAS Detect Timeout timer expires (see 6.8.3.9), if a SATA
-	phy is attached.
-	An STP initiator port should not make a connection request to the attached SAS address until the ATTACHED
-	DEVICE TYPE field is set to a value other than 000b.
-*/
-	MV_U8 AttachedSASAddress[8];
-
-/*
-	byte 32: ATTACHED PHY IDENTIFIER
-	Contains a phy identifier for the attached phy:
-	a) If the attached phy is a SAS phy or an expander phy, the ATTACHED PHY
-	IDENTIFIER field contains the value of the PHY IDENTIFIER field received
-	in the IDENTIFY address frame during the identification sequence:
-		A) If the attached phy is a SAS phy, the ATTACHED PHY IDENTIFIER field
-		contains the phy identifier of the attached SAS phy in the attached SAS device;
-		B) If the attached phy is an expander phy, the ATTACHED PHY IDENTIFIER
-		field contains the phy identifier of the attached expander phy in the attached
-		expander device;
-	b) If the attached phy is a SATA device phy, the ATTACHED PHY IDENTIFIER field
-	contains 00h;
-	c) If the attached phy is a SATA port selector phy and the expander device is
-	able to determine the port of the SATA port selector to which it is attached,
-	the ATTACHED PHY IDENTIFIER field contains 00h or 01h; and
-	d) If the attached phy is a SATA port selector phy and the expander device is not
-	able to determine the port of the SATA port selector to which it is attached,
-	the ATTACHED PHY IDENTIFIER field contains 00h.
-
-	The ATTACHED PHY IDENTIFIER field shall be updated:
-		a) after the identification sequence completes, if a SAS phy or expander phy is attached; or
-		b) after the COMSAS Detect Timeout timer expires, if a SATA phy is attached.
-*/
-
-	MV_U8 AttachedPhyIdentifier;
-
-
-/*
-	byte 32-bit0:ATTACHED BREAK_REPLY CAPABLE
-	Set to one indicate that the phy is capable of responding to received BREAK primitive
-	sequences with a BREAK_REPLY primitive sequence.
-
-	byte 32-bit1: ATTACHED REQUESTED INSIDE ZPSDS
-	Is used to establish the boundary of ZPSDS. The bit is transmitted in the IDENTIFY
-	address frame to the attached phy and is used to determine the value of other zone
-	phy information fields after a link reset sequence.
-
-	byte 32-bit2: ATTACHED INSIDE ZPSDS PERSISTENT
-	Indicate the method used to determine the value of the INSIZE ZPSDS bit after a link
-	reset sequence. The bit is transmitted in the IDENTIFY address frame.
-
-*/
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-	MV_U8 ReservedByte32Bit3_7          : 5;
-	MV_U8 AttachedInsideZPSDSPersistent : 1;  /* Bit 2 */
-	MV_U8 AttachedRequestedInsideZPSDS  : 1;  /* Bit 1 */
-	MV_U8 AttachedBreakReplyCapable     : 1;  /* Bit 0 */
-#else
-	MV_U8 AttachedBreakReplyCapable     : 1;  /* Bit 0 */
-	MV_U8 AttachedRequestedInsideZPSDS  : 1;  /* Bit 1 */
-	MV_U8 AttachedInsideZPSDSPersistent : 1;  /* Bit 2 */
-	MV_U8 ReservedByte32Bit3_7          : 5;
-#endif /* __MV_BIG_ENDIAN_BITFIELD__ */
-
-/*	byte 34-39: Reserved */
-	MV_U8 ReservedByte34_39[6];
-
-/*
-	byte 40-bit0-3:HARDWARE MINIMUM PHYSICAL LINK RATE
-	Indicates the minimum physical link rate supported by the phy.
-	0x8: 1.5Gbps
-	0x9: 3.0Gbps
-	Others: Reserved
-
-	byte 40-bit4-7:PROGRAMMED MINIMUM PHYSICAL LINK RATE
-	Indicates the minimum physical link rate set by the PHY CONTROL function.
-	The default value shall be the value of the HARDWARE MINIMUM PHYSICAL LINK RATE
-	field.
-
-	0x0: Not programmable
-	0x8: 1.5Gbps
-	0x9: 3.0Gbps
-	Others: Reserved
-*/
-
-	MV_U8 HardwareMinimumPhysicalLinkRate:4;
-	MV_U8 ProgrammedMinimumPhysicalLinkRate:4;
-
-/*
-	byte 41-bit0-3:HARDWARE MAXIMUM PHYSICAL LINK RATE
-	Indicates the maximum physical link rate supported by the phy.
-	0x8: 1.5Gbps
-	0x9: 3.0Gbps
-	Others: Reserved
-
-	byte 41-bit4-7:PROGRAMMED MAXIMUM PHYSICAL LINK RATE
-	Indicates the maximum physical link rate set by the PHY CONTROL function.
-	The default value shall be the value of the HARDWARE MINIMUM PHYSICAL LINK RATE
-	field.
-
-	0x0: Not programmable
-	0x8: 1.5Gbps
-	0x9: 3.0Gbps
-	Others: Reserved
-*/
-	MV_U8 HardwareMaximumPhysicalLinkRate:4;
-	MV_U8 ProgrammedMaximumPhysicalLinkRate:4;
-
-/*
-	byte 42: PHY CHANGE COUNT
-	Counts the number of Broadcast(Change)s originated by an expander phy.
-	Expander devices shall support this field. Other device types shall not support
-	this field. This field shall be set to zero at power on. The expander device shall
-	increment this field at least once when it originates a Broadcast (Change) for
-	any reason from the specified expander phy and shall not increment this field when
-	forwarding a Broadcast (Change).
-	After incrementing the PHY CHANGE COUNT field, the expander device is not
-	required to increment the PHY CHANGE COUNT field again unless a DISCOVER response
-	is transmitted. The PHY CHANGE COUNT field shall wrap to zero after the maximum
-	value (i.e., FFh) has been reached.
-	Application clients that use the PHY CHANGE COUNT field should read it often
-	enough to ensure that it does not increment a multiple of 256 times between
-	reading the field.
-*/
-	MV_U8 PhyChangeCount;
-
-
-/*
-	byte 43-bit0-3:PARTIAL PATHWAY TIMEOUT VALUE
-	Indicates the partial pathway timeout value in microseconds set by the PHY
-	CONTROL function. The recommended default value for PARTIAL PATHWAY TIMEOUT
-	VALUE is 7 ¦Ìs.
-
-	byte 43-bit7: VIRTUAL PHY
-	Set to one indicates the phy is part of an internal port and the attached device
-	is contained within the expander device. A VIRTUAL PHY bit set to zero indicates
-	the phy is a physical phy and the attached device is not contained within the
-	expander device.
-*/
-	MV_U8 PartialPathwayTimeoutValue:4;
-	MV_U8 IgnoredByte36Bit4_6:3;
-	MV_U8 VirtualPhy:1;
-
-/*
-	byte 44-bit0-3: ROUTING ATTRIBUTE
-	Indicates the routing attribute supported by the phy.
-
-	Code 	Name 			Description
-	0h 		Direct 			Direct routing method for attached end devices.
-							Attached expander devices are not supported on this phy.
-
-	1h 		Subtractive		a) subtractive routing method for attached expander.
-							b) direct routing method for attached end devices.
-
-	2h 		Table			a) table routing method for attached expander devices;
-							b) direct routing method for attached end devices.
-
-	The ROUTING ATTRIBUTE field shall not change based on the attached device type.
-*/
-
-	MV_U8 RoutingAttribute:4;
-	MV_U8 ReservedByte44Bit4_7:4;
-
-/*
-	byte 45-bit0-6:CONNECTOR TYPE
-	Indicates the type of connector used to access the phy, as reported by the
-	enclosure services process for the enclosure. A CONNECTOR TYPE field set to 00h
-	indicates no connector information is available and that the CONNECTOR ELEMENT
-	INDEX field and the CONNECTOR PHYSICAL LINK fields are invalid and shall be
-	ignored.
-*/
-	MV_U8 ConnectorType:7;
-	MV_U8 ReservedByte45Bit7:1;
-
-/*
-	byte 46:CONNECTOR ELEMENT INDEX
-	Indicates the element index of the SAS Connector element representing the
-	connector used to access the phy, as reported by the enclosure services
-	process for the enclosure.
-*/
-	MV_U8 ConnectorElementIndex;
-
-/*
-	byte 47: CONNECTOR PHYSICAL LINK
-	Indicates the physical link in the connector used to access the phy, as
-	reported by the enclosure services process for the enclosure.
-*/
-	MV_U8 ConnectorPhysicalLink;
-
-	struct DiscoverLongFormatDescriptor	LongFormatDescriptor;
-
-
-/*
-	byte 76-77: CRC
-*/
-	MV_U32 CRC;
-
-}; /* struct SMPResponseDiscover */
-
-/*
-	request specific bytes for SMP Report PHY SATA response,
-	intended to be referenced by SMPResponse
-*/
-struct SMPResponseReportPhySATA
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-
-	/* byte 6-8 */
-	MV_U8 ReservedByte6_8[3];
-
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-
-	/* byte 10 */
-	MV_U8 ReservedByte10;
-
-	/* byte 11 */
-	MV_U8 AffiliationValid:1;
-	MV_U8 AffiliationSupported:1;
-	MV_U8 STPNexusLossOccurred:1;
-	MV_U8 ReservedByte11Bit3_7:5;
-
-	/* byte 12-15 */
-	MV_U8 ReservedByte10_15[4];
-
-	/* byte 16-23 */
-	MV_U8 STPSASAddress[8];
-
-	/* 24-43 */
-	sata_fis_reg_d2h fis;
-
-	/* byte 44-47 */
-	MV_U8 ReservedByte44_47[4];
-
-	/* byte 48-55 */
-	MV_U8 AffiliatedSTPInitiatorSASAddress[8];
-
-	/* byte 56-63 */
-	MV_U8 STPNexusLossSASAddress[8];
-
-	/* byte 64-67 */
-	MV_U32 CRC;
-}; /* struct SMPResponseReportPhySATA */
-
-
-/*
-	response specific bytes for SMP Report Route Information, intended to be
-	referenced by SMPResponse
-*/
-struct SMPResponseReportRouteInformation
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-	/* byte 6-7 */
-	MV_U8 ExpanderRouteIndex[2];
-	/* byte 8 */
-	MV_U8 ReservedByte8;
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-	/* byte 10-11 */
-	MV_U8 ReservedByte10_11[2];
-	/* byte 12 */
-	MV_U8 IgnoredByte12Bit0_6:7;
-	MV_U8 ExpanderRouteEntryDisabled:1;
-	/* byte 13-15 */
-	MV_U8 IgnoredByte13_15[3];
-	/* byte 16-23 */
-	MV_U8 RoutedSASAddress[8];
-	/* byte 24-39 */
-	MV_U8 ReservedByte24_39[16];
-	/* byte 40-43 */
-	MV_U32 CRC;
-}; /* struct SMPResponseReportRouteInformation */
-
-/*
-	response specific bytes for SMP Report Phy Event Information, intended to be
-	referenced by SMPResponse
-*/
-struct SMPResponseReportPhyEventInformation
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-
-	/* byte 6-8 */
-	MV_U8 ReservedByte6_8[3];
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-	/* byte 10-14 */
-	MV_U8 ReservedByte10_14[5];
-
-	/* byte 15 */
-	MV_U8 NumberOfPhyEventDescriptors;
-
-	/* byte 16-27 */
-	MV_U8 PhyEventDescriptor[12];
-/*
-	byte PhyEventDescriptor[12];
-		...
-	byte PhyEventDescriptor[12];
-
-*/
-	MV_U32 CRC;
-}; /* struct SMPResponseReportPhyEventInformation */
-
-
-/*
-	response specific bytes for SMP Report Phy Broadcast Counts, intended to be
-	referenced by SMPResponse
-*/
-struct SMPResponseReportBroadcastCounts
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-
-	/* byte 6-8 */
-	MV_U8 ReservedByte6_8[3];
-	/* byte 9 */
-	MV_U8 PhyIdentifier;
-	/* byte 10-11 */
-	MV_U8 ReservedByte10_11[2];
-
-	/* byte 12 */
-	MV_U8 ChangeCountValid:1;
-	MV_U8 ReservedChange0CountValid:1;
-	MV_U8 ReservedChange1CountValid:1;
-	MV_U8 SESCountValid:1;
-	MV_U8 ExpanderCountValid:1;
-	MV_U8 AsysnchronousEventCountValid:1;
-	MV_U8 Reserved3CountValid:1;
-	MV_U8 Reserved4CountValid:1;
-
-	/* byte 13-15 */
-	MV_U8 ReservedByte13_15[3];
-
-	/* byte 16 */
-	MV_U8 BroadcastChangeCount;
-
-	/* byte 17 */
-	MV_U8 BroadcastReserved0ChangeCount;
-
-	/* byte 18 */
-	MV_U8 BroadcastReserved1ChangeCount;
-
-	/* byte 19 */
-	MV_U8 BroadcastSESCount;
-
-	/* byte 20 */
-	MV_U8 BroadcastExpanderCount;
-
-	/* byte 21 */
-	MV_U8 BroadcastAsynchronousEventCount;
-
-	/* byte 22 */
-	MV_U8 BroadcastReserved3ChangeCount;
-
-	/* byte 23 */
-	MV_U8 BroadcastReserved4ChangeCount;
-
-	MV_U32 CRC;
-}; /* struct SMPResponseReportBroadcastCounts */
-
-
-/*
-	response specific bytes for SMP Discover List Descriptor, intended to be
-	referenced by SMPResponseDiscoverList
-*/
-struct DiscoverShortFormatDescriptor
-{
-	/* byte 48 */
-	MV_U8 PhyIdentifier;
-
-	/* byte 49 */
-	MV_U8 FunctionResult;
-
-	/* byte 50 */
-	MV_U8 ReservedByte50Bit0_3:4;
-	MV_U8 AttachedDeviceType:3;
-	MV_U8 ReservedByte50Bit7:1;
-
-	/* byte 51 */
-	MV_U8 NegotiatedPhysicalLinkRate:4;
-	MV_U8 ReservedByte51Bit4_7:4;
-
-	/* byte 52 */
-	MV_U8 AttachedSataHost:1;
-	MV_U8 AttachedSMPInitiator:1;
-	MV_U8 AttachedSTPInitiator:1;
-	MV_U8 AttachedSSPInitiator:1;
-	MV_U8 ReservedByte52Bit4_7:4;
-
-	/* byte 53 */
-	MV_U8 AttachedSataDevice:1;
-	MV_U8 AttachedSMPTarget:1;
-	MV_U8 AttachedSTPTarget:1;
-	MV_U8 AttachedSSPTarget:1;
-	MV_U8 ReservedByte53Bit4_6:3;
-	MV_U8 AttachedSataPortSelector:1;
-
-	/* byte 54 */
-	MV_U8 RoutingAttribute:4;
-	MV_U8 ReservedByte54Bit4_6:3;
-	MV_U8 VirtualPhy:1;
-
-	/* byte 55 */
-	MV_U8 ReservedByte55;
-
-	/* byte 56 */
-	MV_U8 ZoneGroup;
-
-	/* byte 57 */
-	MV_U8 ReservedByte57Bit0:1;
-	MV_U8 InsideZPSDS:1;
-	MV_U8 ZoneGroupPersistent:1;
-	MV_U8 ZoneAddressResolved:1;
-	MV_U8 RequestedInsideZPSDS:1;
-	MV_U8 InsideZPSDSPersistent:1;
-	MV_U8 ReservedByte57Bit6_7:2;
-
-	/* byte 58 */
-	MV_U8 AttachedPhyIdentifier;
-
-	/* byte 59 */
-	MV_U8 PhyChangeCount;
-
-	/* byte 60-68 */
-	MV_U8 AttachedSASAddress[8];
-
-	/* byte 69-72 */
-	MV_U8 ReservedByte68_72[4];
-
-
-}; /* DiscoverShortFormatDescriptor */
-
-union DiscoverListDescriptor
-{
-	struct DiscoverShortFormatDescriptor	ShortFormatDescriptor;
-	struct DiscoverLongFormatDescriptor		LongFormatDescriptor;
-
-};
-
-/*
-	response specific bytes for SMP Discover List, intended to be
-	referenced by SMPResponse
-*/
-struct SMPResponseDiscoverList
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-
-	/* byte 6-7 */
-	MV_U8 ReservedByte6_8[2];
-	/* byte 8 */
-	MV_U8 StartingPhyIdentifier;
-
-	/* byte 9 */
-	MV_U8 NumberOfDescriptors;
-	/* byte 10 */
-	MV_U8 PhyFilter:4;
-	MV_U8 ReservedByte10Bit4_7:4;
-	/* byte 11 */
-	MV_U8 DescriptorType:4;
-	MV_U8 ReservedByte11Bit4_7:4;
-	/* byte 12 */
-	MV_U8 DescriptorLength;
-
-	/* byte 13-15 */
-	MV_U8 ReservedByte13_15[3];
-
-	/* byte 16 */
-	MV_U8 ConfigurableRouteTable:1;
-	MV_U8 Congiguring:1;
-	MV_U8 ReservedByte16Bit2_5:4;
-	MV_U8 ZoningEnabled:1;
-	MV_U8 ZoningSupported:1;
-
-	/* byte 17-31 */
-	MV_U8 ReservedByte17_31[15];
-
-	/* byte 32-47 */
-	MV_U8 VendorSpecific[16];
-
-	/* byte 48 - n */
-	union DiscoverListDescriptor 	FirstDescriptor;
-
-/*
-	DiscoverListDescriptor 	SecondDescriptor;
-		...
-	DiscoverListDescriptor 	LastDescriptor;
-
-*/
-	MV_U32 CRC;
-}; /* struct SMPResponseDiscoverList */
-
-
-/*
-	response specific bytes for Expander Route Table Descriptor, intended to be
-	referenced by SMPResponseReportExpanderTable
-*/
-struct ExpanderRouteTableDescriptor
-{
-	/* byte 32-37 */
-	MV_U8 PhyBitMap[6];
-
-	/* byte 38 */
-	MV_U8 ReservedByte38Bit0_6:7;
-	MV_U8 ZoneGroupValid:1;
-
-	/* byte 39 */
-	MV_U8 ZoneGroup;
-
-	/* byte 40-48 */
-	MV_U8 RoutedSASAddress[8];
-
-};/* ExpanderRouteTableDescriptor */
-
-/*
-	response specific bytes for SMP Report Expander Route Table, intended to be
-	referenced by SMPResponse
-*/
-struct SMPResponseReportExpanderTable
-{
-	/* byte 4-5 */
-	MV_U8 ExpanderChangeCount[2];
-
-	/* byte 6-7 */
-	MV_U8 ExpanderRouteTableChangeCount[2];
-	/* byte 8 */
-	MV_U8 ReservedByte8Bit0:1;
-	MV_U8 Configuring:1;
-	MV_U8 ReservedByte8Bit2_7:6;
-
-
-	/* byte 9 */
-	MV_U8 ReservedByte9;
-
-	/* byte 10-11 */
-	MV_U8 NumberOfDescriptors[2];
-
-	/* byte 12-13 */
-	MV_U8 FirstRoutedSASAddressIndex[2];
-
-	/* byte 14-15 */
-	MV_U8 LastRoutedSASAddressIndex[2];
-
-	/* byte 13-15 */
-	MV_U8 ReservedByte13_15[3];
-
-	/* byte 16-18 */
-	MV_U8 ReservedByte16_18[3];
-
-	/* byte 19 */
-	MV_U8 StartingPhyIdentifier;
-
-	/* byte 20-31 */
-	MV_U8 ReservedByte20_31[12];
-
-	/* byte 32 - n */
-	struct ExpanderRouteTableDescriptor 	FirstRouteTableDescriptor;
-
-/*
-	ExpanderRouteTableDescriptor 	SecondRouteTableDescriptor;
-		...
-	ExpanderRouteTableDescriptor 	LastRouteTableDescriptor;
-
-*/
-	MV_U32 CRC;
-}; /* struct SMPResponseReportExpanderTable */
-
-struct SMPResponseConfigureFunction
-{
-	/* byte 4-7 */
-	MV_U32 CRC;
-};
-
-/*
-	response specific to SMP Read SGPIO
-	Corresponds to READ_GPIO_REGISTER define
-*/
-struct SMPResponseReadGPIORegister
-{
-	/* byte 4-11 */
-	MV_U8 Data_In_Low[8];
-
-	/* byte 12-19 */
-	MV_U8 Data_In_High[8];
-
-	MV_U32 CRC;
-};
-
-/*
-	response specific to SMP Write SGPIO
-	Corresponds to WRITE_GPIO_REGISTER define
-*/
-struct SMPResponseWriteGPIORegister
-{
-	MV_U32 CRC;
-};
-
-/*
-	generic structure referencing an SMP Response, must be initialized
-	before being used
-*/
-typedef struct _smp_response
-{
-	/* byte 0 */
-	MV_U8 smp_frame_type; /* always 41h for SMP responses */
-	/* byte 1 */
-	MV_U8 function;
-	/* byte 2 */
-	MV_U8 function_result;
-	/* byte 3 */
-	MV_U8 reservedbyte3;
-	/* bytes 4-n */
-	union
-	{
-/* #define REPORT_GENERAL 						0x00 */
-		struct SMPResponseReportGeneral ReportGeneral;
-
-/* #define REPORT_MANUFACTURER_INFORMATION 		0x01 */
-		struct SMPResponseReportManufacturerInformation ReportManufacturerInformation;
-
-/* #define READ_GPIO_REGISTER					0x02 */
-		struct SMPResponseReadGPIORegister					ReadGPIORegister;
-
-/* #define REPORT_SELF_CONFIGURATION_STATUS	0x03 */
-		struct SMPResponseReportSelfConfigurationStatus	ReportSelfConfigurationStatus;
-
-/* #define DISCOVER 							0x10 */
-		struct SMPResponseDiscover 						Discover;
-
-/* #define REPORT_PHY_ERROR_LOG 				0x11 */
-		struct SMPResponseReportPhyErrorLog 			ReportPhyErrorLog;
-
-/* #define REPORT_PHY_SATA 						0x12 */
-		struct SMPResponseReportPhySATA 				ReportPhySATA;
-
-/* #define REPORT_ROUTE_INFORMATION 			0x13 */
-		struct SMPResponseReportRouteInformation 		ReportRouteInformation;
-
-/* #define REPORT_PHY_EVENT_INFORMATION			0x14 */
-		struct SMPResponseReportPhyEventInformation		ReportPhyEventInformation;
-
-/* #define REPORT_PHY_BROADCAST_COUNTS			0x15 */
-		struct SMPResponseReportBroadcastCounts			ReportBroadcastCounts;
-
-/* #define DISCOVER_LIST						0x16 */
-		struct SMPResponseDiscoverList					DiscoverList;
-
-/* #define REPORT_EXPANDER_ROUTE_TABLE			0x17 */
-		struct SMPResponseReportExpanderTable			ReportExpanderTable;
-
-/* #define CONFIGURE_GENERAL					0x80 */
-		struct SMPResponseConfigureFunction				ConfigureGeneral;
-
-/* #define ENABLE_DISABLE_ZONING				0x81 */
-		struct SMPResponseConfigureFunction				EnableDisableZoning;
-
-/* #define WRITE_GPIO_REGISTER					0x82 */
-		struct SMPResponseWriteGPIORegister			WriteGPIORegister;
-
-/* #define ZONED_BROADCAST						0x85 */
-		struct SMPResponseConfigureFunction				ZonedBroadcast;
-
-/* #define CONFIGURE_ROUTE_INFORMATION 			0x90 */
-		struct SMPResponseConfigureFunction				ConfigureRouteInformation;
-
-/* #define PHY_CONTROL 							0x91 */
-		struct SMPResponseConfigureFunction 			PhyControl;
-
-/* #define PHY_TEST 							0x92 */
-		struct SMPResponseConfigureFunction 			PhyTest;
-
-/* #define CONFIGURE_PHY_EVENT_INFORMATION		0x93 */
-		struct SMPResponseConfigureFunction 			ConfigurePhyEventInformation;
-
-	} response;
-} smp_response;
-
-/*
-	this structure is how this simulation obtains its knowledge about the
-	initiator port that is doing the discover, it is not defined as part of
-	the standard...
-*/
-
-struct ApplicationClientKnowledge
-{
-	MV_U64 SASAddress;
-	MV_U8 NumberOfPhys;
-	MV_U8 InitiatorBits;
-	MV_U8 TargetBits;
-};
-	/*
-	the RouteTableEntry structure is used to contain the internal copy of
-	the expander route table
-	*/
-struct RouteTableEntry
-{
-	MV_U8 ExpanderRouteEntryDisabled;
-	MV_U64 RoutedSASAddress;
-};
-
-	/*
-	the TopologyTable structure is the summary of the information gathered
-	during the discover process, the table presented here is not concerned
-	about memory resources consumed, production code would be more concerned
-	about specifying necessary elements explicitly.
-	*/
-struct TopologyTable
-{
-	/*
-	 pointer to a simple list of expanders in topology
-	a walk through this link will encounter all expanders in
-	discover order.
-	*/
-	struct TopologyTable *Next;
-
-	/*
-		simple reference to this device, primarily to keep identification of
-		this structure simple, otherwise, the only place the address is
-		located is within the Phy element.
-	*/
-	MV_U64 SASAddress;
-
-	/* information from REPORT_GENERAL	*/
-	struct SMPResponseReportGeneral Device;
-	/* information from DISCOVER */
-	struct SMPResponseDiscover Phy[MAXIMUM_EXPANDER_PHYS];
-	/* list of route indexes for each phy */
-	MV_U16 RouteIndex[MAXIMUM_EXPANDER_PHYS];
-	/* internal copy of the route table for the expander */
-	struct RouteTableEntry	RouteTable[MAXIMUM_EXPANDER_PHYS][MAXIMUM_EXPANDER_INDEXES];
-};
-
-#endif /* __CORE_DISCOVER_H */
--- a/drivers/scsi/vanir/core/sas_smp/core_expander.c
+++ /dev/null
@@ -1,1224 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-
-#include "core_type.h"
-#include "core_util.h"
-#include "core_device.h"
-#include "core_sas.h"
-#include "core_manager.h"
-#include "core_expander.h"
-
-#include "core_error.h"
-#include "core_resource.h"
-
-MV_VOID exp_found_new_device(smp_response *smp_resp, domain_expander *exp,
-	MV_U64 sas_addr, MV_BOOLEAN is_stp, MV_BOOLEAN lsi_workaround);
-MV_VOID exp_found_new_expander(smp_response *smp_resp, domain_expander *exp,
-	MV_U64 sas_addr);
-extern MV_VOID stp_req_report_phy_sata_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p);
-
-MV_VOID exp_bcst_unplug_dev(domain_expander *exp, domain_device *unplug_dev)
-{
-	pl_root *root = exp->base.root;
-	pal_set_down_disk(root, unplug_dev, MV_TRUE);
-}
-
-MV_VOID exp_bcst_unplug_exp_phy(domain_expander *exp, domain_expander *unplug_exp,
-	MV_U8 phy_id)
-{
-	pl_root *root = exp->base.root;
-	core_extension *core = (core_extension *)root->core;
-	domain_device *device;
-	MV_U8 i;
-	domain_port *port = exp->base.port;
-	domain_expander *tmp_exp = NULL;
-
-	if (unplug_exp->parent_phy_count > 1) {
-		/* is wideport */
-		for (i=0; i<MAX_WIDEPORT_PHYS; i++) {
-			if (unplug_exp->parent_phy_id[i] == phy_id) {
-				unplug_exp->parent_phy_id[i] =
-					unplug_exp->parent_phy_id[unplug_exp->parent_phy_count-1];
-				unplug_exp->parent_phy_count--;
-				break;
-			}
-		}
-	} else {
-		pal_set_down_expander(root, unplug_exp);
-	}
-}
-void get_new_and_update_base_id(pl_root *root,domain_base *base){
-	core_extension * core = (core_extension *)root->core;
-	MV_U16 new_id=0xffff;
-
-	if(core->device_id==DEVICE_ID_6440 || core->device_id==DEVICE_ID_6340 ||
-		core->device_id==DEVICE_ID_6480|| core->device_id==DEVICE_ID_6485
-			||IS_VANIR(core)){
-			new_id=get_available_dev_id_new(&core->lib_dev);
-			root->lib_rsrc->lib_dev->device_map[base->id]=NULL;
-			base->id=new_id;
-			root->lib_rsrc->lib_dev->device_map[new_id]=base;
-	}
-
-	if (base->id != VIRTUAL_DEVICE_ID)
-		base->TargetID = add_target_map(root->lib_dev->target_id_map,base->id, MV_MAX_TARGET_NUMBER);
-}
-MV_VOID exp_found_new_device(smp_response *smp_resp, domain_expander *exp,
-	MV_U64 sas_addr, MV_BOOLEAN is_stp, MV_BOOLEAN lsi_workaround)
-{
-	pl_root *root = exp->base.root;
-	domain_device *device = get_device_obj(root, root->lib_rsrc);
-	MV_U8 max_link_rate;
-
-	if (!device) {
-		CORE_DPRINT(("ran out of device. abort initialization\n"));
-		return;
-	}
-
-	if (is_stp) {
-		set_up_new_device(root, exp->base.port, device,
-			(command_handler *)
-			core_get_handler(root, HANDLER_STP));
-
-		if (lsi_workaround)
-			device->status |= DEVICE_STATUS_NEED_RESET;
-
-		device->state = DEVICE_STATE_STP_REPORT_PHY;
-		device->connection = DC_SCSI | DC_SERIAL | DC_ATA;
-		device->dev_type = DT_DIRECT_ACCESS_BLOCK;
-	} else {
-		set_up_new_device(root, exp->base.port, device,
-			(command_handler *)
-			core_get_handler(root, HANDLER_SSP));
-		device->state = DEVICE_STATE_RESET_DONE;
-		device->connection = DC_SCSI | DC_SERIAL;
-		device->dev_type = DT_DIRECT_ACCESS_BLOCK;
-		device->base.queue_depth = CORE_SAS_DISK_QUEUE_DEPTH;
-	}
-	get_new_and_update_base_id(root,&device->base);
-
-	device->sas_addr = sas_addr;
-	device->parent_phy_id = smp_resp->response.Discover.PhyIdentifier;
-	device->phy_change_count = smp_resp->response.Discover.PhyChangeCount;
-	device->negotiated_link_rate =
-		MV_MIN(smp_resp->response.Discover.NegotiatedPhysicalLinkRate,
-		exp->neg_link_rate);
-	max_link_rate =
-		MV_MIN(smp_resp->response.Discover.HardwareMaximumPhysicalLinkRate,
-		exp->neg_link_rate);
-	device->capability |= DEVICE_CAPABILITY_RATE_1_5G;
-	if (device->negotiated_link_rate >= SAS_LINK_RATE_3_0_GBPS)
-		device->capability |= DEVICE_CAPABILITY_RATE_3G;
-	if (device->negotiated_link_rate >= SAS_LINK_RATE_6_0_GBPS)
-		device->capability |= DEVICE_CAPABILITY_RATE_6G;
-
-	device->base.parent = &exp->base;
-	exp->base.port->device_count++;
-	List_AddTail(&device->base.queue_pointer, &exp->base.port->device_list);
-	exp->device_count++;
-	List_AddTail(&device->base.exp_queue_pointer, &exp->device_list);
-	if(exp->enclosure){
-		exp->enclosure->enc_flag |= ENC_FLAG_NEED_REINIT;
-	}
-	CORE_DPRINT(("add expander device list, device sas address %016llx, expander device count:0x%x\n",
-		device->sas_addr.value, exp->device_count));
-}
-
-domain_expander *exp_check_existing_expander(domain_port *port,
-	MV_U64 sas_addr)
-{
-	domain_expander *tmp_exp;
-
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_exp, &port->expander_list, domain_expander,
-		base.queue_pointer) {
-		if (U64_COMPARE_U64(sas_addr, tmp_exp->sas_addr) == 0)
-			return tmp_exp;
-	}
-
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_exp, &port->current_tier, domain_expander,
-		base.queue_pointer) {
-		if (U64_COMPARE_U64(sas_addr, tmp_exp->sas_addr) == 0)
-			return tmp_exp;
-	}
-
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_exp, &port->next_tier, domain_expander,
-		base.queue_pointer) {
-		if (U64_COMPARE_U64(sas_addr, tmp_exp->sas_addr) == 0)
-			return tmp_exp;
-	}
-	return MV_FALSE;
-}
-
-MV_VOID exp_found_new_expander(smp_response *smp_resp, domain_expander *exp,
-	MV_U64 sas_addr)
-{
-	domain_expander *new_exp, *exist_exp = NULL;
-	domain_port *port = exp->base.port;
-	pl_root *root = exp->base.root;
-	core_extension *core = (core_extension *)root->core;
-	MV_U8 i;
-
-	exist_exp = exp_check_existing_expander(port, sas_addr);
-	if (exist_exp) {
-		/*
-		 * another expander with the same sas address already exists,
-		 * we found a wideport
-		 */
-		MV_DASSERT(exist_exp->base.parent == &exp->base);
-		exist_exp->parent_phy_id[exist_exp->parent_phy_count] =
-			smp_resp->response.Discover.PhyIdentifier;
-		exist_exp->parent_phy_count++;
-		return;
-	}
-
-	new_exp = get_expander_obj(root, root->lib_rsrc);
-	if (new_exp == NULL) {
-		CORE_DPRINT(("Ran out of expanders. Aborting.\n"));
-		return;
-	}
-
-	set_up_new_expander(root, port, new_exp);
-	new_exp->base.parent = &exp->base;
-
-	new_exp->sas_addr = sas_addr;
-	new_exp->neg_link_rate =
-		MV_MIN(smp_resp->response.Discover.NegotiatedPhysicalLinkRate,
-		exp->neg_link_rate);
-	new_exp->parent_phy_id[0] = smp_resp->response.Discover.PhyIdentifier;
-	new_exp->parent_phy_count = 1;
-	if (core->state == CORE_STATE_STARTED) {
-		new_exp->need_report_plugin = MV_TRUE;
-	}
-	new_exp->has_been_setdown = MV_FALSE;
-
-	/* do not add to port's expander lists yet. will do so after
-	 * initialization is over */
-	List_AddTail(&new_exp->base.queue_pointer, &port->next_tier);
-	List_AddTail(&new_exp->base.exp_queue_pointer, &exp->expander_list);
-	exp->expander_count++;
-}
-
-domain_base *exp_search_phy(domain_expander *exp, MV_U8 phy_id)
-{
-	domain_device *tmp_dev;
-	domain_expander *tmp_exp;
-	MV_U8 i;
-
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_dev, &exp->device_list, domain_device,
-		base.exp_queue_pointer) {
-		if (tmp_dev->parent_phy_id == phy_id) {
-			return (domain_base *)tmp_dev;
-		}
-	}
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_exp, &exp->expander_list,
-		domain_expander, base.exp_queue_pointer) {
-		for (i = 0; i < tmp_exp->parent_phy_count; i++) {
-			if (tmp_exp->parent_phy_id[i] == phy_id) {
-				return (domain_base *)tmp_exp;
-			}
-		}
-	}
-	if (exp->enclosure) {
-		if (exp->enclosure->parent_phy_id == phy_id)
-			return (domain_base *)exp->enclosure;
-	}
-
-	return NULL;
-}
-
-MV_VOID smp_process_discover(smp_response *smp_resp, domain_expander *exp, MV_Request *req)
-{
-	pl_root *root = exp->base.root;
-	domain_base *base;
-	domain_expander *tmp_exp;
-	MV_U64 sas_addr, parent_sas_addr;
-	core_context *ctx = req->Context[MODULE_CORE];
-	MV_U8 phy_id = (MV_U8)(ctx->u.org.other);
-
-	base = exp_search_phy(exp, phy_id);
-
-	if ((smp_resp->function_result == SMP_FUNCTION_ACCEPTED)) {
-		MV_ASSERT(phy_id == smp_resp->response.Discover.PhyIdentifier);
-
-		MV_CopyMemory(&sas_addr,
-			smp_resp->response.Discover.AttachedSASAddress, 8);
-		U64_ASSIGN(sas_addr, MV_CPU_TO_BE64(sas_addr));
-
-		if (smp_resp->response.Discover.AttachedDeviceType != NO_DEVICE) {
-			if (base) {
-				if (base->type == BASE_TYPE_DOMAIN_EXPANDER) {
-					LIST_FOR_EACH_ENTRY_TYPE(tmp_exp,
-						&exp->base.port->next_tier, domain_expander,
-						base.queue_pointer) {
-						if (&tmp_exp->base == base) {
-							return;
-						}
-					}
-					List_Del(&base->queue_pointer);
-					base->port->expander_count--;
-					((domain_expander *)base)->state = EXP_STATE_DISCOVER;
-					List_AddTail(&base->queue_pointer, &base->port->next_tier);
-				} else if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-					if (U64_COMPARE_U64(sas_addr,
-						((domain_device *)base)->sas_addr) != 0) {
-						exp_bcst_unplug_dev(exp, (domain_device *)base);
-						goto found_new;
-					}
-				}
-				return;
-			}
-
-found_new:
-			if (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-				U64_ASSIGN_U64(parent_sas_addr,
-					((domain_expander *)exp->base.parent)->sas_addr);
-			} else {
-				U64_ASSIGN_U64(parent_sas_addr, exp->sas_addr);
-			}
-			if (U64_COMPARE_U64(parent_sas_addr, sas_addr) != 0) {
-				if (smp_resp->response.Discover.TargetBits &
-					FRAME_ATT_DEV_TYPE_SSP) {
-					exp_found_new_device(smp_resp, exp, sas_addr, MV_FALSE,
-						MV_FALSE);
-				} else if (smp_resp->response.Discover.TargetBits &
-					(FRAME_ATT_DEV_TYPE_STP | FRAME_ATT_DEV_SATA_DEV)) {
-					exp_found_new_device(smp_resp, exp, sas_addr, MV_TRUE,
-						MV_FALSE);
-				} else if (smp_resp->response.Discover.TargetBits &
-					FRAME_ATT_DEV_TYPE_SMP) {
-					exp_found_new_expander(smp_resp, exp, sas_addr);
-				}
-			}
-		} else {
-			if (base) {
-				if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-					exp_bcst_unplug_dev(exp, (domain_device *)base);
-				} else if (base->type == BASE_TYPE_DOMAIN_EXPANDER) {
-					exp_bcst_unplug_exp_phy(exp, (domain_expander *)base, phy_id);
-				}
-			}
-		}
-	} else {
-		if (base) {
-			if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-				exp_bcst_unplug_dev(exp, (domain_device *)base);
-			} else if (base->type == BASE_TYPE_DOMAIN_EXPANDER) {
-				exp_bcst_unplug_exp_phy(exp, (domain_expander *)base, phy_id);
-			}
-		}
-	}
-}
-
-MV_VOID smp_req_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)get_device_by_id(
-		root->lib_dev, req->Device_Id);
-	domain_expander *parent;
-	domain_device *device;
-	smp_response *smp_resp;
-	core_context *ctx;
-
-	if (!exp)
-		MV_ASSERT(MV_FALSE);
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		core_handle_init_error(root, &exp->base, req);
-		return;
-	}
-
-	smp_resp = (smp_response *)core_map_data_buffer(req);
-	switch (exp->state) {
-	case EXP_STATE_REPORT_GENERAL:
-	if (smp_resp->function_result != SMP_FUNCTION_ACCEPTED) {
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-		core_handle_init_error(root, &exp->base, req);
-		return;
-	}
-
-		exp->phy_count = smp_resp->response.ReportGeneral.NumberOfPhys;
-		exp->configurable_route_table =
-			smp_resp->response.ReportGeneral.ConfigurableRouteTable;
-		exp->configures_others =
-			smp_resp->response.ReportGeneral.ConfiguresOthers;
-		if (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-			parent = (domain_expander *)exp->base.parent;
-			if (parent->configures_others) {
-				exp->configures_others = 1;
-			}
-		}
-		exp->state = EXP_STATE_REPORT_MANU_INFO;
-		break;
-	case EXP_STATE_REPORT_MANU_INFO:
-		exp->component_rev_id = smp_resp->response.
-			ReportManufacturerInformation.ComponentRevisionID;
-		MV_CopyMemory(&exp->component_id, smp_resp->response.
-			ReportManufacturerInformation.ComponentID, 2);
-		MV_CopyMemory(&exp->component_vendor_id, smp_resp->response.
-			ReportManufacturerInformation.ComponentVendorIdentification,
-			8);
-		MV_CopyMemory(&exp->vendor_id, smp_resp->response.
-			ReportManufacturerInformation.VendorIdentification, 8);
-		MV_CopyMemory(&exp->product_id, smp_resp->response.
-			ReportManufacturerInformation.ProductIdentification, 16);
-		MV_CopyMemory(&exp->product_rev, smp_resp->response.
-			ReportManufacturerInformation.ProductRevisionLevel, 4);
-		exp->state = EXP_STATE_DISCOVER;
-		break;
-	case EXP_STATE_DISCOVER:
-		if (exp->has_been_reset == MV_TRUE) {
-			if (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-				exp->state = EXP_STATE_CONFIG_ROUTE;
-			}
-			else {
-				exp->state = EXP_STATE_NEXT_TIER;
-			}
-		}
-		else {
-			exp->state = EXP_STATE_RESET_SATA_PHY;
-		}
-		break;
-	case EXP_STATE_RESET_SATA_PHY:
-		exp->has_been_reset = MV_TRUE;
-		exp->state = EXP_STATE_RESET_WAIT;
-		break;
-
-	case EXP_STATE_CLEAR_AFFILIATION:
-		ctx = req->Context[MODULE_CORE];
-		MV_ASSERT(ctx->type == CORE_CONTEXT_TYPE_CLEAR_AFFILIATION);
-		if (ctx->u.smp_clear_aff.need_wait == MV_FALSE) {
-			if (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER) {
-				exp->state = EXP_STATE_CONFIG_ROUTE;
-			}
-			else {
-				exp->state = EXP_STATE_NEXT_TIER;
-			}
-		} else {
-			exp->state = EXP_STATE_RESET_WAIT_2;
-		}
-		break;
-
-	case EXP_STATE_CONFIG_ROUTE:
-		exp->state = EXP_STATE_NEXT_TIER;
-		break;
-	}
-
-	core_unmap_data_buffer(req);
-	core_queue_init_entry(root, &exp->base, MV_FALSE);
-}
-
-MV_VOID smp_req_discover_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)exp_p;
-	smp_response *smp_resp;
-	core_context *ctx = req->Context[MODULE_CORE];
-	MV_Request *vir_req = (MV_Request *)ctx->u.org.org_req;
-	core_context *vir_ctx = vir_req->Context[MODULE_CORE];
-
-	MV_ASSERT(vir_ctx->u.smp_discover.req_remaining > 0);
-	vir_ctx->u.smp_discover.req_remaining--;
-
-	if (exp) {
-		if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-			smp_resp = (smp_response *)core_map_data_buffer(req);
-			smp_process_discover(smp_resp, exp, req);
-			core_unmap_data_buffer(req);
-		}
-	}
-
-	if (vir_ctx->u.smp_discover.req_remaining == 0) {
-		if (vir_req->Scsi_Status == REQ_STATUS_SUCCESS) {
-			if (vir_ctx->u.smp_discover.current_phy_id < exp->phy_count) {
-				core_append_init_request(root, vir_req);
-			} else {
-				core_queue_completed_req(root->core, vir_req);
-			}
-		} else {
-			core_queue_completed_req(root->core, vir_req);
-		}
-	}
-}
-
-MV_VOID smp_req_reset_sata_phy_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)exp_p;
-	core_context *ctx = req->Context[MODULE_CORE];
-	MV_Request *vir_req = (MV_Request *)ctx->u.org.org_req;
-	core_context *vir_ctx = vir_req->Context[MODULE_CORE];
-
-	MV_ASSERT(vir_ctx->type == CORE_CONTEXT_TYPE_RESET_SATA_PHY);
-	MV_ASSERT(vir_ctx->u.smp_reset_sata_phy.req_remaining > 0);
-	vir_ctx->u.smp_reset_sata_phy.req_remaining--;
-
-	if (vir_ctx->u.smp_reset_sata_phy.req_remaining == 0) {
-		if (vir_req->Scsi_Status == REQ_STATUS_SUCCESS) {
-			MV_ASSERT(vir_ctx->u.smp_reset_sata_phy.total_dev_count ==
-				exp->device_count);
-			if (vir_ctx->u.smp_reset_sata_phy.curr_dev_count <
-				vir_ctx->u.smp_reset_sata_phy.total_dev_count) {
-				core_append_init_request(root, vir_req);
-			} else {
-				core_queue_completed_req(root->core, vir_req);
-			}
-		}
-		else {
-			core_queue_completed_req(root->core, vir_req);
-		}
-	}
-}
-
-MV_VOID smp_req_clear_aff_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)exp_p;
-	smp_response *smp_resp;
-	struct SMPResponseReportPhySATA *report;
-	core_context *ctx = req->Context[MODULE_CORE];
-	MV_Request *vir_req = (MV_Request *)ctx->u.org.org_req;
-	core_context *vir_ctx = vir_req->Context[MODULE_CORE];
-	domain_base *base;
-
-	MV_ASSERT(vir_ctx->u.smp_clear_aff.req_remaining > 0);
-	vir_ctx->u.smp_clear_aff.req_remaining--;
-
-	MV_ASSERT(vir_ctx->type == CORE_CONTEXT_TYPE_CLEAR_AFFILIATION);
-
-	if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-		switch (vir_ctx->u.smp_clear_aff.state) {
-		case CLEAR_AFF_STATE_REPORT_PHY_SATA:
-			smp_resp = (smp_response *)core_map_data_buffer(req);
-			report = &smp_resp->response.ReportPhySATA;
-
-			base = exp_search_phy(exp, report->PhyIdentifier);
-			if (base) {
-				MV_ASSERT(base->type == BASE_TYPE_DOMAIN_DEVICE);
-					if (report->AffiliationValid) {
-						((domain_device *)base)->status |= DEVICE_STATUS_NEED_RESET;
-					}
-			} else {
-				MV_ASSERT(MV_FALSE);
-			}
-			break;
-		case CLEAR_AFF_STATE_CLEAR_AFF:
-			break;
-
-		default:
-			MV_ASSERT(MV_FALSE);
-			break;
-		}
-	}
-
-	if (vir_ctx->u.smp_clear_aff.req_remaining == 0) {
-		if (vir_req->Scsi_Status == REQ_STATUS_SUCCESS) {
-			MV_ASSERT(vir_ctx->u.smp_clear_aff.total_dev_count ==
-				exp->device_count);
-			if (vir_ctx->u.smp_clear_aff.curr_dev_count <
-				vir_ctx->u.smp_clear_aff.total_dev_count) {
-				core_append_init_request(root, vir_req);
-			} else if (vir_ctx->u.smp_clear_aff.state ==
-				CLEAR_AFF_STATE_REPORT_PHY_SATA) {
-				vir_ctx->u.smp_clear_aff.curr_dev_count = 0;
-				vir_ctx->u.smp_clear_aff.state = CLEAR_AFF_STATE_CLEAR_AFF;
-				core_append_init_request(root, vir_req);
-			}
-			else {
-				core_queue_completed_req(root->core, vir_req);
-			}
-		}
-		else {
-			core_queue_completed_req(root->core, vir_req);
-		}
-	}
-}
-
-domain_expander *exp_find_config_route_ancestor(pl_root *root,
-	domain_expander *exp)
-{
-	domain_expander *parent;
-
-	while (exp->base.parent && (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER)) {
-		parent = (domain_expander *)exp->base.parent;
-		if (parent->configurable_route_table &&
-			!parent->configures_others) {
-			return exp;
-		}
-		exp = parent;
-	}
-
-	return NULL;
-}
-
-MV_VOID smp_req_config_route_callback(MV_PVOID root_p, MV_Request *req, MV_PVOID exp_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)exp_p;
-	domain_expander *ancestor, *org_exp;
-	core_context *ctx = req->Context[MODULE_CORE];
-	MV_Request *vir_req = (MV_Request *)ctx->u.org.org_req;
-	core_context *vir_ctx = vir_req->Context[MODULE_CORE];
-	smp_virtual_config_route_buffer *buf;
-	smp_response *smp_resp;
-	MV_U8 i, phy_id;
-
-	if (!exp) {
-		/* expander is gone, abort */
-		MV_ASSERT(MV_FALSE);
-		vir_ctx->u.smp_config_route.req_remaining--;
-		if (vir_ctx->u.smp_config_route.req_remaining == 0) {
-			org_exp = (domain_expander *)vir_ctx->u.smp_config_route.org_exp;
-			vir_req->Device_Id = org_exp->base.id;
-			vir_req->Scsi_Status = REQ_STATUS_ERROR;
-			core_queue_completed_req(root->core, vir_req);
-		}
-		return;
-	}
-
-	smp_resp = (smp_response *)core_map_data_buffer(req);
-	if (smp_resp->function_result != SMP_FUNCTION_ACCEPTED) {
-		req->Scsi_Status = REQ_STATUS_ERROR;
-	}
-	core_unmap_data_buffer(req);
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		core_handle_init_error(root, &exp->base, req);
-		return;
-	}
-
-	vir_ctx->u.smp_config_route.req_remaining--;
-	if (vir_ctx->u.smp_config_route.req_remaining == 0) {
-		if ((vir_ctx->u.smp_config_route.current_phy <
-			vir_ctx->u.smp_config_route.phy_count) ||
-			(vir_ctx->u.smp_config_route.current_addr <
-			vir_ctx->u.smp_config_route.address_count)) {
-
-			core_append_init_request(root, vir_req);
-		} else {
-			/*
-			* config route for this expander is finished.
-			* check if parent needs to be configured also.
-			*/
-			ancestor = exp_find_config_route_ancestor(root, exp);
-			if (ancestor) {
-				MV_ASSERT(ancestor->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER);
-			/* update phy IDs */
-			buf = (smp_virtual_config_route_buffer *)
-			core_map_data_buffer(vir_req);
-			for (i=0; i<ancestor->parent_phy_count; i++)
-				buf->phy_id[i] = ancestor->parent_phy_id[i];
-				core_unmap_data_buffer(vir_req);
-				vir_ctx->u.smp_config_route.current_addr = 0;
-				vir_ctx->u.smp_config_route.current_phy = 0;
-				MV_ASSERT(vir_ctx->u.smp_config_route.org_exp);
-				vir_ctx->u.smp_config_route.phy_count =
-					ancestor->parent_phy_count;
-				vir_req->Device_Id = ancestor->base.parent->id;
-				core_append_init_request(root, vir_req);
-				return;
-			}
-			org_exp = (domain_expander *)vir_ctx->u.smp_config_route.org_exp;
-			vir_req->Device_Id = org_exp->base.id;
-			vir_req->Scsi_Status = REQ_STATUS_SUCCESS;
-			core_queue_completed_req(root->core, vir_req);
-		}
-	}
-}
-
-MV_VOID smp_req_fill_common_fields(MV_Request *req, domain_expander *exp,
-	MV_PVOID callback)
-{
-	smp_request *smp_req;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SMP;
-	req->Device_Id = exp->base.id;
-	req->Cmd_Initiator = exp->base.root;
-	req->Completion = (void(*)(MV_PVOID,MV_Request *))callback;
-
-	/* Need to clear out these bytes */
-	smp_req = core_map_data_buffer(req);
-	smp_req->resp_len = 0;
-	smp_req->req_len = 0;
-	core_unmap_data_buffer(req);
-}
-
-MV_VOID smp_physical_req_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_expander *exp = (domain_expander *)get_device_by_id(
-		root->lib_dev, req->Device_Id);
-	core_context *ctx = req->Context[MODULE_CORE];
-	MV_Request *vir_req = (MV_Request *)ctx->u.org.org_req;
-	core_context *vir_ctx = vir_req->Context[MODULE_CORE];
-
-	if (vir_req->Scsi_Status == REQ_STATUS_PENDING) {
-		vir_req->Scsi_Status = REQ_STATUS_SUCCESS;
-	}
-
-	if (!exp) {
-		/* expander is gone, abort */
-		MV_ASSERT(MV_FALSE);
-		req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-	}
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		vir_req->Scsi_Status = req->Scsi_Status;
-		if (ctx->error_info) {
-			vir_ctx->error_info |= ctx->error_info;
-		}
-	}
-
-	switch (vir_req->Cdb[2]) {
-		case CDB_CORE_SMP_VIRTUAL_CLEAR_AFFILIATION_ALL:
-			smp_req_clear_aff_callback(root_p, req, exp);
-			break;
-		case CDB_CORE_SMP_VIRTUAL_RESET_SATA_PHY:
-			smp_req_reset_sata_phy_callback(root, req, exp);
-			break;
-		case CDB_CORE_SMP_VIRTUAL_CONFIG_ROUTE:
-			smp_req_config_route_callback(root, req, exp);
-			break;
-		case CDB_CORE_SMP_VIRTUAL_DISCOVER:
-			smp_req_discover_callback(root, req, exp);
-			break;
-		case CDB_CORE_STP_VIRTUAL_REPORT_SATA_PHY:
-			stp_req_report_phy_sata_callback(root, req, exp);
-			break;
-		case CDB_CORE_STP_VIRTUAL_PHY_RESET:
-		case CDB_CORE_SSP_VIRTUAL_PHY_RESET:
-			core_queue_completed_req(root->core, vir_req);
-			break;
-		default:
-			MV_ASSERT(MV_FALSE);
-			break;
-	}
-
-}
-
-MV_Request *smp_make_report_general_req(domain_expander *exp,
-	MV_PVOID callback)
-{
-	pl_root *root = exp->base.root;
-	MV_Request *req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-
-	if (req == NULL)
-		return NULL;
-	smp_req_fill_common_fields(req, exp, callback);
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function = REPORT_GENERAL;
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_Request *smp_make_report_manu_info_req(domain_expander *exp,
-	MV_PVOID callback)
-{
-	pl_root *root = exp->base.root;
-	MV_Request *req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-
-	if (req == NULL) {
-		return NULL;
-	}
-	smp_req_fill_common_fields(req, exp, callback);
-
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function = REPORT_MANUFACTURER_INFORMATION;
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_Request *smp_make_discover_req(domain_expander *exp, MV_Request *vir_req,
-	MV_U8 phy_id, MV_PVOID callback)
-{
-	pl_root *root = exp->base.root;
-	MV_Request *req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-	core_context *ctx;
-
-	if (req == NULL)
-		return NULL;
-	smp_req_fill_common_fields(req, exp, callback);
-	ctx = req->Context[MODULE_CORE];
-	ctx->u.org.org_req = vir_req;
-	ctx->u.org.other = phy_id;
-
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function = DISCOVER;
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-	smp_req->request.Discover.IgnoredByte4_7[0] = 0; /* byte 4-7 */
-	smp_req->request.Discover.IgnoredByte4_7[1] = 0;
-	smp_req->request.Discover.IgnoredByte4_7[2] = 0;
-	smp_req->request.Discover.IgnoredByte4_7[3] = 0;
-	smp_req->request.Discover.ReservedByte8 = 0; /* byte 8*/
-	smp_req->request.Discover.PhyIdentifier = phy_id; /* byte 9*/
-	smp_req->request.Discover.IgnoredByte10 = 0; /* byte 10-11 */
-	smp_req->request.Discover.ReservedByte11 = 0;
-	/* smp_req->request.Discover.CRC byte 12-15 */
-
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_Request *smp_make_config_route_req(domain_expander *exp,
-	MV_Request *vir_req, MV_U16 route_index, MV_U8 phy_id, MV_U64 *sas_addr,
-	MV_PVOID callback)
-{
-	pl_root *root = exp->base.root;
-	MV_Request *req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-	core_context *ctx;
-
-	if (req == NULL) {
-		return NULL;
-	}
-	smp_req_fill_common_fields(req, exp, callback);
-	ctx = req->Context[MODULE_CORE];
-	ctx->u.org.org_req = vir_req;
-
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function = CONFIGURE_ROUTE_INFORMATION;
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-	smp_req->request.ConfigureRouteInformation.ExpanderRouteIndex[0] =
-		(route_index & 0xFF00) >> 8;
-	smp_req->request.ConfigureRouteInformation.ExpanderRouteIndex[1] =
-		(route_index & 0xFF);
-	smp_req->request.ConfigureRouteInformation.PhyIdentifier = phy_id;
-	MV_CopyMemory(smp_req->request.ConfigureRouteInformation.RoutedSASAddress,
-		sas_addr, 8);
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_Request *smp_make_phy_control_req(domain_device *device, MV_U8 operation,
-	MV_PVOID callback)
-{
-	pl_root *root = device->base.root;
-	domain_expander *exp = (domain_expander *)device->base.parent;
-	MV_Request *req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-
-	if (req == NULL) {
-		return NULL;
-	}
-	smp_req_fill_common_fields(req, exp, callback);
-
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function = PHY_CONTROL;
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-	smp_req->request.PhyControl.PhyIdentifier = device->parent_phy_id;
-	smp_req->request.PhyControl.PhyOperation = operation;
-	smp_req->request.PhyControl.ProgrammedMaximumPhysicalLinkRate = 0;
-	smp_req->request.PhyControl.ProgrammedMinimumPhysicalLinkRate = 0;
-	smp_req->request.PhyControl.ExpectedExpanderChangeCount[0] = 0;
-	smp_req->request.PhyControl.ExpectedExpanderChangeCount[1] = 0;
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_Request *smp_make_phy_crtl_by_id_req(MV_PVOID exp_p,
-	MV_U8 phy_id, MV_U8 operation, MV_PVOID callback)
-{
-	domain_expander *exp = (domain_expander *)exp_p;
-	pl_root *root = (pl_root *)exp->base.root;
-	MV_Request *req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-
-	if (req == NULL) return NULL;
-
-	smp_req_fill_common_fields(req, exp, callback);
-
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function = PHY_CONTROL;
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-	smp_req->request.PhyControl.PhyIdentifier = phy_id;
-	smp_req->request.PhyControl.PhyOperation = operation;
-	smp_req->request.PhyControl.ProgrammedMaximumPhysicalLinkRate = 0;
-	smp_req->request.PhyControl.ProgrammedMinimumPhysicalLinkRate = 0;
-	smp_req->request.PhyControl.ExpectedExpanderChangeCount[0] = 0;
-	smp_req->request.PhyControl.ExpectedExpanderChangeCount[1] = 0;
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_Request *smp_make_report_phy_sata_req(domain_device *device,
-	MV_PVOID callback)
-{
-	pl_root *root = device->base.root;
-	domain_expander *exp = (domain_expander *)device->base.parent;
-	MV_Request *req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-
-	if (req == NULL)
-		return NULL;
-
-	smp_req_fill_common_fields(req, exp, callback);
-
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function = REPORT_PHY_SATA;
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-	smp_req->request.ReportPhySATA.PhyIdentifier = device->parent_phy_id;
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_Request *smp_make_report_phy_sata_by_id_req(MV_PVOID exp_p,
-	MV_U8 phy_id, MV_PVOID callback)
-{
-	domain_expander *exp = (domain_expander *)exp_p;
-	pl_root *root = (pl_root *)exp->base.root;
-	MV_Request *req = get_intl_req_resource(root, sizeof(smp_request));
-	smp_request *smp_req;
-
-	if (req == NULL) return NULL;
-
-	smp_req_fill_common_fields(req, exp, callback);
-
-	smp_req = (smp_request *)core_map_data_buffer(req);
-	smp_req->function = REPORT_PHY_SATA;
-	smp_req->smp_frame_type = SMP_REQUEST_FRAME;
-	smp_req->request.ReportPhySATA.PhyIdentifier = phy_id;
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_Request *smp_make_virtual_discover_req(domain_expander *exp,
-	MV_PVOID callback)
-{
-	pl_root *root = exp->base.root;
-	MV_Request *req = get_intl_req_resource(root, 0);
-	core_context *ctx;
-
-	if (req == NULL) {
-		return NULL;
-	}
-
-	ctx = req->Context[MODULE_CORE];
-	ctx->u.smp_discover.current_phy_id = 0;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SMP_VIRTUAL_DISCOVER;
-	req->Device_Id = exp->base.id;
-	req->Cmd_Initiator = exp->base.root;
-	req->Completion = (void(*)(MV_PVOID,MV_Request *))callback;
-
-	return req;
-}
-
-MV_Request *smp_make_virtual_reset_sata_phy_req(domain_expander *exp,
-	MV_PVOID callback)
-{
-	pl_root *root = exp->base.root;
-	MV_Request *req;
-	core_context *ctx;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL) return NULL;
-
-	ctx = req->Context[MODULE_CORE];
-	ctx->type = CORE_CONTEXT_TYPE_RESET_SATA_PHY;
-	ctx->u.smp_reset_sata_phy.curr_dev_count = 0;
-        ctx->u.smp_reset_sata_phy.total_dev_count = exp->device_count;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SMP_VIRTUAL_RESET_SATA_PHY;
-	req->Device_Id = exp->base.id;
-	req->Cmd_Initiator = exp->base.root;
-	req->Completion = (void(*)(MV_PVOID,MV_Request *))callback;
-
-	return req;
-}
-
-MV_Request *smp_make_vir_clear_aff_all_req(domain_expander *exp,
-	MV_PVOID callback)
-{
-	pl_root *root = exp->base.root;
-	MV_Request *req;
-	core_context *ctx;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL) return NULL;
-
-	ctx = req->Context[MODULE_CORE];
-	ctx->type = CORE_CONTEXT_TYPE_CLEAR_AFFILIATION;
-	ctx->u.smp_clear_aff.state = CLEAR_AFF_STATE_REPORT_PHY_SATA;
-	ctx->u.smp_clear_aff.curr_dev_count = 0;
-	ctx->u.smp_clear_aff.total_dev_count = exp->device_count;
-	ctx->u.smp_clear_aff.need_wait = MV_FALSE;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SMP_VIRTUAL_CLEAR_AFFILIATION_ALL;
-	req->Device_Id = exp->base.id;
-	req->Cmd_Initiator = exp->base.root;
-	req->Completion = (void(*)(MV_PVOID,MV_Request *))callback;
-
-	return req;
-}
-
-MV_Request *smp_make_virtual_config_route_req(domain_expander *exp,
-	MV_PVOID callback)
-{
-	pl_root *root = exp->base.root;
-	domain_expander *tmp_exp, *ancestor;
-	domain_device *tmp_dev;
-	MV_Request *req = get_intl_req_resource(root, SMP_VIRTUAL_REQ_BUFFER_SIZE);
-	smp_virtual_config_route_buffer *buf;
-	core_context *ctx;
-	MV_U64 val_64;
-	MV_U8 addr_count = 0, phy_count, i;
-
-	if (req == NULL)
-		return NULL;
-
-	ancestor = exp_find_config_route_ancestor(root, exp);
-	if (ancestor == NULL){
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		return req;
-	}
-	MV_ASSERT(ancestor->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER);
-
-	buf = (smp_virtual_config_route_buffer *)core_map_data_buffer(req);
-	ctx = req->Context[MODULE_CORE];
-
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_dev, &exp->device_list, domain_device,
-		base.exp_queue_pointer) {
-		if (tmp_dev->status & DEVICE_STATUS_FUNCTIONAL) {
-			U64_ASSIGN(val_64, MV_CPU_TO_BE64(tmp_dev->sas_addr));
-			MV_CopyMemory(&buf->sas_addr[addr_count], &val_64, 8);
-			addr_count++;
-		}
-	}
-	if (exp->enclosure) {
-		if(exp->enclosure->status & ENCLOSURE_STATUS_FUNCTIONAL){
-			U64_ASSIGN(val_64, MV_CPU_TO_BE64(exp->enclosure->sas_addr));
-			MV_CopyMemory(&buf->sas_addr[addr_count], &val_64, 8);
-			addr_count++;
-		}
-	}
-	LIST_FOR_EACH_ENTRY_TYPE(tmp_exp, &exp->expander_list, domain_expander,
-		base.exp_queue_pointer) {
-		if (tmp_exp->status & EXP_STATUS_FUNCTIONAL) {
-			U64_ASSIGN(val_64, MV_CPU_TO_BE64(tmp_exp->sas_addr));
-			MV_CopyMemory(&buf->sas_addr[addr_count], &val_64, 8);
-			addr_count++;
-		}
-	}
-
-	phy_count = ancestor->parent_phy_count;
-	for (i=0; i<phy_count; i++)
-		buf->phy_id[i] = ancestor->parent_phy_id[i];
-
-	ctx->u.smp_config_route.current_addr = 0;
-	ctx->u.smp_config_route.current_phy = 0;
-	ctx->u.smp_config_route.address_count = addr_count;
-	ctx->u.smp_config_route.phy_count = phy_count;
-	ctx->u.smp_config_route.org_exp = exp;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SMP_VIRTUAL_CONFIG_ROUTE;
-	req->Device_Id = ancestor->base.parent->id;
-	req->Cmd_Initiator = root;
-	req->Completion = (void(*)(MV_PVOID,MV_Request *))callback;
-
-	core_unmap_data_buffer(req);
-	return req;
-}
-
-MV_VOID exp_init_reset_wait_callback(pl_root *root, domain_expander *exp)
-{
-	domain_base *base;
-
-	base = get_device_by_id(root->lib_dev, exp->base.id);
-	if ((base == NULL) || (base != &exp->base)) {
-		CORE_PRINT(("Expander is gone.\n"));
-		return;
-	}
-
-	switch (exp->state) {
-	case EXP_STATE_RESET_WAIT:
-		exp->state = EXP_STATE_CLEAR_AFFILIATION;
-		break;
-	case EXP_STATE_RESET_WAIT_2:
-		if (exp->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER)
-			exp->state = EXP_STATE_CONFIG_ROUTE;
-		else
-			exp->state = EXP_STATE_NEXT_TIER;
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-	}
-
-	exp->timer_tag = NO_CURRENT_TIMER;
-	core_queue_init_entry(root, &exp->base, MV_FALSE);
-}
-
-MV_VOID exp_push_next_expander(pl_root *root, domain_port *port)
-{
-	domain_expander *exp, *parent_exp;
-
-	if (!List_Empty(&port->current_tier)) {
-		exp = (domain_expander *)List_GetFirstEntry(&port->current_tier,
-			domain_expander, base.queue_pointer);
-		List_AddTail(&exp->base.queue_pointer, &port->expander_list);
-		port->expander_count++;
-		core_queue_init_entry(root, &exp->base, MV_TRUE);
-	}
-}
-
-MV_BOOLEAN exp_state_machine(MV_PVOID expander)
-{
-	domain_expander *exp = (domain_expander *)expander, *tmp_exp;
-	domain_device *tmp_device;
-	domain_port *port = exp->base.port;
-	pl_root *root = exp->base.root;
-	MV_Request *req = NULL;
-	MV_U8 i;
-	MV_ULONG flags;
-	core_extension *core = (core_extension *)root->core;
-
-	CORE_DPRINT(("exp %d state 0x%x.\n", exp->base.id, exp->state));
-
-	switch (exp->state) {
-	case EXP_STATE_REPORT_GENERAL:
-		req = smp_make_report_general_req(exp, smp_req_callback);
-		break;
-	case EXP_STATE_REPORT_MANU_INFO:
-		req = smp_make_report_manu_info_req(exp, smp_req_callback);
-		break;
-	case EXP_STATE_DISCOVER:
-		req = smp_make_virtual_discover_req(exp, smp_req_callback);
-		break;
-	case EXP_STATE_RESET_SATA_PHY:
-		req = smp_make_virtual_reset_sata_phy_req(exp, smp_req_callback);
-		break;
-	case EXP_STATE_RESET_WAIT:
-		MV_ASSERT(exp->timer_tag == NO_CURRENT_TIMER);
-		exp->timer_tag = core_add_timer(root->core, 2,
-			(void(*)(void *, void *))exp_init_reset_wait_callback, root, exp);
-		MV_ASSERT(exp->timer_tag != NO_CURRENT_TIMER);
-		return MV_TRUE;
-	case EXP_STATE_CLEAR_AFFILIATION:
-		req = smp_make_vir_clear_aff_all_req(exp, smp_req_callback);
-		break;
-	case EXP_STATE_RESET_WAIT_2:
-		MV_ASSERT(exp->timer_tag == NO_CURRENT_TIMER);
-		exp->timer_tag = core_add_timer(root->core, 2,
-			(void(*)(void *, void *))exp_init_reset_wait_callback, root, exp);
-		MV_ASSERT(exp->timer_tag != NO_CURRENT_TIMER);
-		return MV_TRUE;
-	case EXP_STATE_CONFIG_ROUTE:
-		if (exp_find_config_route_ancestor(root, exp) != NULL) {
-			req = smp_make_virtual_config_route_req(exp, smp_req_callback);
-			break;
-		}
-		/* otherwise, don't need to config route, move on */
-	case EXP_STATE_NEXT_TIER:
-		/*
-		 * discovery for this expander is done. next step is to initialize any
-		 * new devices and do discovery for new expanders
-		 */
-		LIST_FOR_EACH_ENTRY_TYPE(tmp_device, &exp->device_list, domain_device,
-			base.exp_queue_pointer) {
-
-			if ((tmp_device->state != DEVICE_STATE_INIT_DONE) &&
-				!(tmp_device->status&DEVICE_STATUS_SPIN_UP)){
-				struct device_spin_up *tmp=NULL;
-
-				tmp=get_spin_up_device_buf(root->lib_rsrc);
-				if(!tmp || (core->spin_up_group == 0)){
-					if(tmp)
-						free_spin_up_device_buf(root->lib_rsrc,tmp);
-					core_queue_init_entry(root, &tmp_device->base, MV_TRUE);
-				}else{
-					MV_LIST_HEAD_INIT(&tmp->list);
-					tmp->roots=root;
-					tmp->base=&tmp_device->base;
-
-					if(tmp_device->status & DEVICE_STATUS_SPIN_UP){
-						free_spin_up_device_buf(root->lib_rsrc,tmp);
-						continue;
-					}
-
-					OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP(core,flags);
-					tmp_device->status |=DEVICE_STATUS_SPIN_UP;
-					List_AddTail(&tmp->list,&core->device_spin_up_list);
-					if(core->device_spin_up_timer ==NO_CURRENT_TIMER){
-						core->device_spin_up_timer=core_add_timer(core,3, (MV_VOID (*) (MV_PVOID, MV_PVOID))staggered_spin_up_handler, &tmp_device->base, NULL);
-					}
-					OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(core,flags);
-				}
-			}
-		}
-		if (List_Empty(&port->current_tier)) {
-			while(!List_Empty(&port->next_tier)) {
-				tmp_exp = (domain_expander *)List_GetFirstEntry(&port->next_tier,
-					domain_expander, base.queue_pointer);
-				List_AddTail(&tmp_exp->base.queue_pointer, &port->current_tier);
-			}
-		}
-		exp->state = EXP_STATE_DONE;
-	case EXP_STATE_DONE:
-		exp_push_next_expander(root, port);
-		core_init_entry_done(root, port, &exp->base);
-		return MV_TRUE;
-	}
-
-	if (req) {
-		core_append_init_request(root, req);
-		return MV_TRUE;
-	} else {
-		return MV_FALSE;
-	}
-}
-
-void exp_update_direct_attached_phys(domain_port *port)
-{
-	pl_root *root = port->base.root;
-	domain_expander *exp = NULL;
-	MV_U8 phy_id = 0, i;
-
-	if (List_Empty(&port->expander_list))
-		return;
-
-	/*
-	 * find the expander that was attached to the port, and update
-	 * phy information
-	 */
-	LIST_FOR_EACH_ENTRY_TYPE(exp, &port->expander_list, domain_expander,
-		base.queue_pointer) {
-		if (exp->base.parent == &port->base)
-			break;
-	}
-	MV_DASSERT(exp != NULL);
-	exp->parent_phy_count = 0;
-	for (i=0; i<root->phy_num; i++) {
-		if (port->phy_map & MV_BIT(i)) {
-			exp->parent_phy_id[phy_id] = i;
-			exp->parent_phy_count++;
-			phy_id++;
-		}
-	}
-}
--- a/drivers/scsi/vanir/core/sas_smp/core_expander.h
+++ /dev/null
@@ -1,45 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_EXPANDER_H
-#define __CORE_EXPANDER_H
-
-#include "mv_config.h"
-
-#define SMP_VIRTUAL_REQ_BUFFER_SIZE			sizeof(smp_virtual_config_route_buffer)
-
-typedef enum _CLEAR_AFF_STATUS {
-	CLEAR_AFF_STATUS_NO_CLEAR = 0,
-	CLEAR_AFF_STATUS_IS_SATA,
-	CLEAR_AFF_STATUS_NEED_CLEAR,
-	CLEAR_AFF_STATUS_NEED_RESET,
-	CLEAR_AFF_STATUS_MAX,
-} CLEAR_AFF_STATUS;
-
-typedef struct _smp_virtual_config_route_buffer
-{
-	MV_U64	sas_addr[MAXIMUM_EXPANDER_PHYS];
-	MV_U8	phy_id[MAX_WIDEPORT_PHYS];
-} smp_virtual_config_route_buffer;
-
-enum _CORE_CONTEXT_CLEAR_AFF_STATE {
-	CLEAR_AFF_STATE_REPORT_PHY_SATA = 0,
-	CLEAR_AFF_STATE_CLEAR_AFF,
-	CLEAR_AFF_STATE_MAX,
-};
-
-MV_BOOLEAN exp_state_machine(MV_PVOID expander);
-MV_Request *smp_make_phy_control_req(domain_device *device,
-	MV_U8 operation, MV_PVOID callback);
-
-#endif /* __CORE_EXPANDER_H */
--- a/drivers/scsi/vanir/core/sata_base/core_sata.c
+++ /dev/null
@@ -1,1919 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_sata.h"
-#include "core_internal.h"
-#include "core_init.h"
-#include "core_resource.h"
-#include "core_exp.h"
-#include "core_device.h"
-#include "core_sat.h"
-#include "core_util.h"
-#include "core_manager.h"
-#include "core_error.h"
-#include "core_console.h"
-#include "hba_exp.h"
-#include "com_define.h"
-#include "core_expander.h"
-
-extern MV_Request *smp_make_report_phy_sata_req(domain_device *device,
-	MV_PVOID callback);
-extern MV_VOID pm_sig_time_out(domain_pm *pm, MV_PVOID tmp);
-extern MV_VOID stp_req_disc_callback(MV_PVOID root_p, MV_Request *req);
-extern MV_Request *stp_make_report_phy_sata_req(domain_device *dev, MV_PVOID callback);
-extern MV_Request *stp_make_phy_reset_req(domain_device *device, MV_U8 operation,
-	MV_PVOID callback);
-extern MV_VOID smp_physical_req_callback(MV_PVOID root_p, MV_Request *req);
-extern MV_VOID update_base_id(pl_root *root,domain_port *port,domain_device *dev,MV_U8 skip);
-
-
-MV_VOID sata_ata2host_string(MV_U16 *source, MV_U16 *target,
-	MV_U32 words_count)
-{
-	MV_U32 i;
-	for (i=0; i < words_count; i++) {
-		target[i] = (source[i] >> 8) | ((source[i] & 0xff) << 8);
-		target[i] = MV_LE16_TO_CPU(target[i]);
-	}
-}
-
-MV_U8 sata_entry_exist(List_Head *list, List_Head *entry)
-{
-	List_Head *ptr;
-
-	for (ptr = list->next; ptr != list; ptr = ptr->next)
-	if (ptr == entry)
-	return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-
-/*
- * Create WWN for SATA device from serial number and model number in
- * IDENTIFY data. This is used on SATA disk which does not support ATA 8
- * or higher
- */
-MV_U64 sata_create_wwn_old(ata_identify_data *identify_data)
-{
-	MV_U64 wwn;
-
-	wwn.parts.low = wwn.parts.high = 0;
-	/* Use CRC of serial number as lower part of WWN */
-	wwn.parts.low = MV_CRC((MV_PU8)identify_data->serial_number, 20);
-	/* Use CRC of model number as higher part of WWN */
-	wwn.parts.high = MV_CRC((MV_PU8)identify_data->model_number, 40);
-	return wwn;
-}
-
-MV_U64 sata_create_wwn(ata_identify_data *identify_data)
-{
-	return sata_create_wwn_old(identify_data);
-}
-
-static void swap_buf_le16(MV_PU16 buf, unsigned int buf_words)
-{
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-        unsigned int i;
-
-        for (i = 0; i < buf_words; i++)
-                buf[i] = MV_LE16_TO_CPU(buf[i]);
-#endif
-}
-struct model_number{
-        char            *model_number;
-        unsigned char   size;
-	int  (*func)(ata_identify_data *,domain_device *);
-
-};
-int dec_queue_depth_workaround(ata_identify_data *identify_data,domain_device *device){
-
-	if(device->base.queue_depth > 1 ){
-		device->base.queue_depth -= 1;
-		}
-	return 0;
-}
-int esata_workaround(ata_identify_data *identify_data,domain_device *device){
-	if (device->capability | DEVICE_CAPABILITY_NCQ_SUPPORTED) {
-			device->capability &= ~DEVICE_CAPABILITY_NCQ_SUPPORTED;
-	}
-	return 0;
-}
-
-void check_model_number(ata_identify_data *identify_data,domain_device *device,struct model_number *check_model,unsigned int num){
-	unsigned int i,result;
-	unsigned char *check=device->model_number;
-	 for(i=0;i<num;i++){
-                result=memcmp(check,check_model[i].model_number,check_model[i].size);
-		if(result==0){
-			check_model[i].func(identify_data,device);
-			}
-        }
-}
-
-MV_VOID sata_parse_identify_data(domain_device *device,
-	ata_identify_data *identify_data)
-{
-	MV_U8 i;
-	domain_port *port = device->base.port;
-	struct model_number check_model[]={
-		{"STT_FTD28GX25H",14,dec_queue_depth_workaround},
-		{"eSATA SSD",9,esata_workaround},
-	};
-	unsigned int num=sizeof(check_model)/sizeof(struct model_number);
-
-	swap_buf_le16((MV_PU16)identify_data, 256);
-
-	if (identify_data->general_config & IDENTIFY_GENERAL_CONFIG_ATAPI )
-		device->dev_type = (identify_data->general_config &
-			IDENTIFY_CMD_PACKET_SET_MASK) >> 8;
-
-	/* Get serial number, firmware revision and model number. */
-	MV_CopyMemory(device->serial_number, identify_data->serial_number, 20);
-	MV_CopyMemory(device->firmware_revision,
-		identify_data->firmware_revision, 8);
-	MV_CopyMemory(device->model_number, identify_data->model_number, 40);
-
-	sata_ata2host_string((MV_U16 *)device->serial_number,
-		(MV_U16 *)device->serial_number, 10);
-	sata_ata2host_string((MV_U16 *)device->firmware_revision,
-		(MV_U16 *)device->firmware_revision, 4);
-	sata_ata2host_string((MV_U16 *)device->model_number,
-		(MV_U16 *)device->model_number, 20);
-
-	/* capacity: 48 bit LBA, smart, write cache and NCQ */
-	device->capability = 0;
-	device->setting = 0;
-	if (identify_data->command_set_supported[1] & MV_BIT(10))
-		device->capability |= DEVICE_CAPABILITY_48BIT_SUPPORTED;
-	if (identify_data->command_set_supported[0] & MV_BIT(0)) {
-		device->capability |= DEVICE_CAPABILITY_SMART_SUPPORTED;
-		if (identify_data->command_set_enabled[0] & MV_BIT(0))
-			device->setting |= DEVICE_SETTING_SMART_ENABLED;
-		if (identify_data->command_set_supported_extension & MV_BIT(0))
-			device->capability |= DEVICE_CAPABILITY_SMART_SELF_TEST_SUPPORTED;
-	}
-	if (identify_data->command_set_supported[0] & MV_BIT(5)) {
-		device->capability |= DEVICE_CAPABILITY_WRITECACHE_SUPPORTED;
-		if (identify_data->command_set_enabled[0] & MV_BIT(5))
-			device->setting |= DEVICE_SETTING_WRITECACHE_ENABLED;
-	}
-	if (identify_data->command_set_supported[0] & MV_BIT(6)
-		&& !(device->dev_type & DT_CD_DVD)) {
-		device->capability |= DEVICE_CAPABILITY_READ_LOOK_AHEAD_SUPPORTED;
-		if (identify_data->command_set_enabled[0] & MV_BIT(6))
-			device->setting |= DEVICE_SETTING_READ_LOOK_AHEAD;
-	}
-	if (((identify_data->specific_config == 0x37c8
-			|| identify_data->specific_config == 0x738c))
-		|| ((identify_data->command_set_supported[1] & MV_BIT(5))
-			&& (identify_data->command_set_supported[1] & MV_BIT(6)))){
-		device->capability |= DEVICE_CAPABILITY_POIS_SUPPORTED;
-	}
-	if ((identify_data->specific_config == 0x37c8
-			|| identify_data->specific_config == 0x738c)
-		&& (!(identify_data->command_set_enabled[1] & MV_BIT(5))
-			&& !(identify_data->command_set_enabled[1] & MV_BIT(6)))) {
-		device->setting |= DEVICE_SETTING_POIS_ENABLED;
-	} else
-		device->setting &= ~DEVICE_SETTING_POIS_ENABLED;
-
-	if (identify_data->sata_capabilities & MV_BIT(8)) {
-		if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED) {
-			device->capability |= DEVICE_CAPABILITY_NCQ_SUPPORTED;
-		}
-	}
-
-	if (!IS_ATAPI(device)) {
-		/* capacity: trim support*/
-		if(identify_data->reserved7[8]&MV_BIT(0)){
-				device->capability |= DEVICE_CAPABILITY_TRIM_SUPPORTED;
-		}
-
-		/* capacity: non rotating media */
-		if(identify_data->reserved8[11] == 0x0001){
-				device->capability |= DEVICE_CAPABILITY_SSD;
-		}
-	}
-
-
-	device->base.queue_depth = identify_data->queue_depth + 1;
-
-	if(device->base.queue_depth > 32)
-		device->base.queue_depth = 32;
-
-	if (identify_data->sata_capabilities & MV_BIT(3))
-		device->capability |= DEVICE_CAPABILITY_RATE_6G;
-	if (device->negotiated_link_rate == PHY_LINKRATE_6)
-		device->capability |= DEVICE_CAPABILITY_RATE_6G;
-	if (identify_data->sata_capabilities & MV_BIT(2))
-		device->capability |= DEVICE_CAPABILITY_RATE_3G;
-	if (identify_data->sata_capabilities & MV_BIT(1))
-		device->capability |= DEVICE_CAPABILITY_RATE_1_5G;
-	if (identify_data->command_set_supported_extension & MV_BIT(5)) {
-		if (identify_data->command_set_default & MV_BIT(5))
-			device->capability |= DEVICE_CAPABILITY_READLOGEXT_SUPPORTED;
-	}
-
-	/* Disk size */
-	if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED) {
-		device->max_lba.parts.low = *((MV_PU32)&identify_data->max_lba[0]);
-		device->max_lba.parts.high = *((MV_PU32)&identify_data->max_lba[2]);
-	} else {
-		device->max_lba.parts.low =
-			*((MV_PU32)&identify_data->user_addressable_sectors[0]);
-		device->max_lba.parts.high = 0;
-	}
-	/*
-	 * The disk size as indicated by the ATA spec is the total addressable
-	 * sectors on the drive; while Max LBA is the LBA of the last logical
-	 * block on the drive
-	 */
-	device->max_lba = U64_SUBTRACT_U32(device->max_lba, 1);
-
-	/* PIO, MDMA and UDMA mode */
-	if ((identify_data->fields_valid & MV_BIT(1)) &&
-		(identify_data->pio_modes & 0x0F)) {
-	if ((MV_U8)identify_data->pio_modes >= 0x2)
-			device->pio_mode = 0x04;
-		else
-			device->pio_mode = 0x03;
-	} else {
-	device->pio_mode = 0x02;
-	}
-	device->udma_mode = 0xFF;
-	if (identify_data->fields_valid & MV_BIT(2)) {
-		for (i=0; i<7; i++) {
-			if (identify_data->udma_modes & MV_BIT(i))
-				device->udma_mode = i;
-		}
-	}
-
-	device->max_transfer_size = CORE_MAX_TRANSFER_SIZE;
-
-	if (device->dev_type == DT_CD_DVD)
-		device->sector_size = 4 * SECTOR_SIZE;
-	else
-		device->sector_size = SECTOR_SIZE;
-
-	/* check identify data word 106 */
-	if (((identify_data->physical_logical_sector_size & MV_BIT(15)) == 0) &&
-		((identify_data->physical_logical_sector_size & MV_BIT(14)) != 0)) {
-		/* word 106 is valid */
-		if ((identify_data->physical_logical_sector_size & MV_BIT(12)) != 0)
-			/* Logical sector longer than 256 words */
-			/* Check identify data word 117-118 */
-			device->sector_size = ((MV_U32)
-				(((MV_U32)identify_data->words_per_logical_sector[1]) << 16) |
-				((MV_U32)identify_data->words_per_logical_sector[0])) * 2;
-	}
-
-	device->WWN = sata_create_wwn(identify_data);
-
-	check_model_number(identify_data,device,check_model,num);
-}
-
-MV_VOID sata_port_intl_req_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_pm *pm = (domain_pm *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	domain_port *port = pm->base.port;
-
-	if (port->sata_sig_timer != NO_CURRENT_TIMER) {
-		core_cancel_timer(root->core, port->sata_sig_timer);
-		port->sata_sig_timer = NO_CURRENT_TIMER;
-	}
-
-	CORE_DPRINT(("port %p phy %d state 0x%x req %p,port->sata_sig_timer=%x.\n", \
-		port, port->phy->id, port->state, req,port->sata_sig_timer));
-
-	switch(port->state) {
-	case PORT_SATA_STATE_SOFT_RESET_1:
-		core_sleep_millisecond(root->core, 50);
-		port->phy->sata_signature = 0xFFFFFFFF;
-		port->state = PORT_SATA_STATE_SOFT_RESET_0;
-		break;
-	case PORT_SATA_STATE_SOFT_RESET_0:
-		port->state = PORT_SATA_STATE_WAIT_SIG;
-		break;
-	default:
-		MV_DASSERT(MV_FALSE);
-		return;
-	}
-
-	core_queue_init_entry(root, &port->base, MV_FALSE);
-}
-
-MV_VOID sata_device_intl_req_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *device = (domain_device *)get_device_by_id(
-		root->lib_dev, req->Device_Id);
-	ata_identify_data *identify_data;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		core_handle_init_error(root, &device->base, req);
-		return;
-	}
-
-	identify_data = (ata_identify_data *)core_map_data_buffer(req);
-
-	switch (req->Cdb[0]) {
-	case SCSI_CMD_INQUIRY:
-		MV_ASSERT(device->state == DEVICE_STATE_RESET_DONE);
-		if (IS_ATAPI(device)) {
-			sata_parse_identify_data(device, identify_data);
-		}
-		device->state = DEVICE_STATE_IDENTIFY_DONE;
-		break;
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		switch (req->Cdb[2]) {
-		case CDB_CORE_SET_PIO_MODE:
-			MV_DASSERT(device->state == DEVICE_STATE_SPIN_UP_DONE);
-			device->state = DEVICE_STATE_SET_PIO_DONE;
-			break;
-		case CDB_CORE_SET_UDMA_MODE:
-			MV_DASSERT(device->state == DEVICE_STATE_SET_PIO_DONE);
-			device->state = DEVICE_STATE_SET_UDMA_DONE;
-			break;
-		case CDB_CORE_ENABLE_WRITE_CACHE:
-			MV_DASSERT(device->state == DEVICE_STATE_SET_UDMA_DONE);
-			device->state = DEVICE_STATE_ENABLE_WRITE_CACHE_DONE;
-			break;
-		case CDB_CORE_ENABLE_READ_AHEAD:
-			MV_DASSERT(device->state ==
-			        DEVICE_STATE_ENABLE_WRITE_CACHE_DONE);
-			device->state = DEVICE_STATE_ENABLE_READ_AHEAD_DONE;
-			break;
-		case CDB_CORE_SET_FEATURE_SPINUP:
-			MV_DASSERT(device->state ==
-			        DEVICE_STATE_IDENTIFY_DONE);
-			device->state = DEVICE_STATE_SPIN_UP_DONE;
-			break;
-		}
-		break;
-	}
-
-	core_unmap_data_buffer(req);
-	core_queue_init_entry(root, &device->base, MV_FALSE);
-}
-
-
-
-MV_Request *sata_make_soft_reset_req(domain_port *port, domain_device *device,
-	MV_BOOLEAN srst, MV_BOOLEAN is_port_reset, MV_PVOID callback)
-{
-	pl_root *root = port->base.root;
-	MV_Request *req =  get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = srst ? CDB_CORE_SOFT_RESET_1 : CDB_CORE_SOFT_RESET_0;
-	req->Cdb[3] = is_port_reset ? 0xF : device->pm_port;
-	if (device)
-		req->Device_Id = device->base.id;
-	else
-		req->Device_Id = port->pm->base.id;
-	req->Completion = (void(*)(MV_PVOID,MV_Request *))callback;
-
-	return req;
-}
-
-MV_Request *sata_make_identify_req(domain_device *device,
-	MV_BOOLEAN EVPD, MV_U8 page)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req = get_intl_req_resource(root, 0x200);
-
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_INQUIRY;
-	if (EVPD) {
-		req->Cdb[1] = 0x01;
-		req->Cdb[2] = page;
-	} else {
-		req->Cdb[1] = 0;
-	}
-
-	/* buffer size */
-	req->Cdb[3] = 0x2;
-	req->Cdb[4] = 0x00;
-	req->Device_Id = device->base.id;
-	req->Completion = (void(*)(MV_PVOID,MV_Request *))
-		sata_device_intl_req_callback;
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-
-	return req;
-}
-
-MV_Request *sata_make_set_pio_mode_req(domain_device *device)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req;
-	MV_U8 mode = device->pio_mode;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	if (IS_ATAPI(device)) {
-		if (mode > 2)
-			mode = device->pio_mode = 2;
-	}
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SET_PIO_MODE;
-	req->Cdb[3] = mode;
-	req->Device_Id = device->base.id;
-	req->Completion = (void(*)(MV_PVOID,MV_Request *))
-		sata_device_intl_req_callback;
-
-	device->current_pio = mode;
-
-	return req;
-}
-
-MV_Request *sata_make_set_udma_mode_req(domain_device *device)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req;
-	MV_U8 mode = device->udma_mode;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	if (IS_ATAPI(device)) {
-		if (mode > 4)
-			mode = device->udma_mode = 4;
-	}
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_SET_UDMA_MODE;
-	req->Cdb[3] = mode;
-	req->Device_Id = device->base.id;
-	req->Completion = (void(*)(MV_PVOID,PMV_Request))
-		sata_device_intl_req_callback;
-
-	device->current_udma = mode;
-	return req;
-}
-
-MV_Request *sata_make_enable_write_cache_req(domain_device *device,
-        MV_U8 enable)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE; /* disable block descriptors */
-	if (enable)
-		req->Cdb[2] = CDB_CORE_ENABLE_WRITE_CACHE;
-	else
-		req->Cdb[2] = CDB_CORE_DISABLE_WRITE_CACHE;
-
-	req->Device_Id = device->base.id;
-	req->Completion = sata_device_intl_req_callback;
-
-	return req;
-}
-
-MV_Request *sata_make_enable_read_ahead_req(domain_device *device)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE; /* disable block descriptors */
-	req->Cdb[2] = CDB_CORE_ENABLE_READ_AHEAD;
-
-	req->Device_Id = device->base.id;
-	req->Completion = sata_device_intl_req_callback;
-
-	return req;
-}
-
-MV_Request *sata_make_set_feature_spinup_req(domain_device *device)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE; /* disable block descriptors */
-	req->Cdb[2] = CDB_CORE_SET_FEATURE_SPINUP;
-
-	req->Device_Id = device->base.id;
-	req->Completion = sata_device_intl_req_callback;
-
-	return req;
-}
-
-MV_Request *sata_make_start_stop_req(domain_device *device,
-        MV_U8 start)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req;
-
-	req = get_intl_req_resource(root, 0);
-	if (req == NULL)
-		return NULL;
-
-	req->Cdb[0] = SCSI_CMD_START_STOP_UNIT;
-	req->Cdb[1] = 0;                       /* IMMED=0 */
-	req->Cdb[2] = 0;
-	req->Cdb[3] = 0;
-	if (start == MV_TRUE)
-		req->Cdb[4] = 1;
-	else
-		req->Cdb[4] = 0;
-
-	req->Device_Id = device->base.id;
-	req->Completion = sata_device_intl_req_callback;
-
-	return req;
-}
-
-MV_VOID sata_set_up_new_device(pl_root *root, domain_port *port,
-	domain_device *device)
-{
-	set_up_new_device(root, port, device,
-		(command_handler *)
-		core_get_handler(root, HANDLER_SATA));
-
-	device->state = DEVICE_STATE_IDLE;
-	device->negotiated_link_rate = port->link_rate;
-
-}
-
-MV_VOID sata_port_process_new(domain_port *port)
-{
-	domain_phy *phy;
-	pl_root *root = port->base.root;
-	domain_device *device = NULL;
-	core_extension *core = (core_extension *)root->core;
-	MV_ULONG flags;
-	struct device_spin_up *tmp=NULL;
-
-	phy = port->phy;
-	if (phy->sata_signature == 0x96690101) {
-		MV_DASSERT(port->pm != NULL);
-		port->pm->base.struct_size = sizeof(domain_pm);
-		core_queue_init_entry(root, &port->pm->base, MV_TRUE);
-	} else {
-		/* release the PM that was obtained during port soft reset */
-		free_pm_obj(root, root->lib_rsrc, port->pm);
-		port->pm = NULL;
-
-		/* get a new device */
-		device = get_device_obj(root, root->lib_rsrc);
-		if (device == NULL) {
-			CORE_DPRINT(("no more free device\n"));
-			return;
-		}
-		sata_set_up_new_device(root, port, device);
-		update_base_id(root,port,device,MV_FALSE);
-		device->signature = port->phy->sata_signature;
-		if (device->signature == 0xEB140101) {
-			device->connection = DC_SERIAL | DC_ATA | DC_ATAPI;
-		} else {
-			device->connection = DC_SERIAL | DC_ATA;
-		}
-		device->connection |= DC_SGPIO;
-		device->sgpio_drive_number = (MV_U8)port->base.id;
-		device->active_led_off_timer = NO_CURRENT_TIMER;
-		device->dev_type = DT_DIRECT_ACCESS_BLOCK;
-		device->base.parent = &port->base;
-		device->state = DEVICE_STATE_RESET_DONE;
-
-		List_AddTail(&device->base.queue_pointer, &port->device_list);
-		port->device_count++;
-
-		tmp=get_spin_up_device_buf(root->lib_rsrc);
-		if(!tmp || (core->spin_up_group == 0)){
-			if(tmp){
-				free_spin_up_device_buf(root->lib_rsrc,tmp);
-			}
-			core_queue_init_entry(root, &device->base, MV_TRUE);
-		}else{
-			MV_LIST_HEAD_INIT(&tmp->list);
-			tmp->roots=root;
-			tmp->base=&device->base;
-
-			OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP(core,flags);
-			List_AddTail(&tmp->list,&core->device_spin_up_list);
-			if(core->device_spin_up_timer ==NO_CURRENT_TIMER){
-				core->device_spin_up_timer=core_add_timer(core, 3, (MV_VOID (*) (MV_PVOID, MV_PVOID))staggered_spin_up_handler, &device->base, NULL);
-			}
-			OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(core,flags);
-		}
-	}
-}
-
-MV_VOID sata_sig_time_out(domain_port *port, MV_PVOID tmp)
-{
-	pl_root *root = port->base.root;
-	CORE_DPRINT(("port %p\n", port));
-	/*
-	 * Signature FIS did not return. We proceed with initialization anyway
-	 * (sometimes the drive can still recover. If not, we will deal with
-	 * it during time out handling)
-	 */
-	if (port->state == PORT_SATA_STATE_POWER_ON) {
-		port->state = PORT_SATA_STATE_SOFT_RESET_1;
-	} else if (port->state == PORT_SATA_STATE_WAIT_SIG) {
-		port->state = PORT_SATA_STATE_SIG_DONE;
-	} else {
-		MV_DASSERT(MV_FALSE);
-	}
-
-	port->sata_sig_timer = NO_CURRENT_TIMER;
-	core_queue_init_entry(root, &port->base, MV_FALSE);
-}
-
-MV_BOOLEAN sata_port_state_machine(MV_PVOID dev)
-{
-	domain_port *port = (domain_port *)dev;
-	pl_root *root = port->base.root;
-	MV_Request *req = NULL;
-
-	CORE_DPRINT(("port %p phy %d state 0x%x,port->sata_sig_timer=%x, port->phy->sata_signature=%x.\n", port, port->phy->id, port->state,port->sata_sig_timer,port->phy->sata_signature));
-
-	switch (port->state) {
-	case PORT_SATA_STATE_POWER_ON:
-		if (port->phy->sata_signature == 0xFFFFFFFF) {
-			MV_ASSERT(port->sata_sig_timer == NO_CURRENT_TIMER);
-			port->sata_sig_timer = core_add_timer(
-				root->core, 12,
-				(void(*)(void *, void *))sata_sig_time_out, port, NULL);
-			MV_ASSERT(port->sata_sig_timer != NO_CURRENT_TIMER);
-			CORE_DPRINT(("port %p PORT_SATA_STATE_POWER_ON generate timer %d.\n", \
-				port, port->sata_sig_timer));
-			return MV_TRUE;
-		} else {
-			port->state = PORT_SATA_STATE_SOFT_RESET_1;
-		}
-	case PORT_SATA_STATE_SOFT_RESET_1:
-		req = sata_make_soft_reset_req(port, NULL, MV_TRUE, MV_TRUE,
-			sata_port_intl_req_callback);
-		break;
-	case PORT_SATA_STATE_SOFT_RESET_0:
-		req = sata_make_soft_reset_req(port, NULL, MV_FALSE, MV_TRUE,
-			sata_port_intl_req_callback);
-		break;
-	case PORT_SATA_STATE_WAIT_SIG:
-		if (port->phy->sata_signature == 0xFFFFFFFF) {
-			MV_ASSERT(port->sata_sig_timer == NO_CURRENT_TIMER);
-			port->sata_sig_timer = core_add_timer(
-					root->core, 10,
-					(void (*) (void *, void *))sata_sig_time_out, port, NULL);
-			MV_ASSERT(port->sata_sig_timer != NO_CURRENT_TIMER);
-			CORE_DPRINT(("port %p PORT_SATA_STATE_WAIT_SIG generate timer %d.\n", \
-				port, port->sata_sig_timer));
-			return MV_TRUE;
-		} else {
-			port->state = PORT_SATA_STATE_SIG_DONE;
-		}
-	case PORT_SATA_STATE_SIG_DONE:
-		/*
-		 * this port state machine is done, next step is to detect device,
-		 * and either go into device or PM state machine
-		 */
-		sata_port_process_new(port);
-		/*
-		 * finish port init entry after queuing device init entries -
-		 * this is necessary to ensure event handling is pushed
-		 * properly
-		 */
-		core_init_entry_done(root, port, &port->base);
-		return MV_TRUE;
-	}
-
-	if (req) {
-		core_append_init_request(root, req);
-		return MV_TRUE;
-	} else {
-		return MV_FALSE;
-	}
-}
-
-MV_BOOLEAN sata_device_state_machine(MV_PVOID dev)
-{
-	domain_device *device = (domain_device *)dev;
-	pl_root *root = device->base.root;
-	MV_Request *req = NULL;
-
-	CORE_DPRINT(("dev %p(%d) state 0x%x.\n", dev, device->base.id, device->state));
-
-	switch (device->state) {
-	case DEVICE_STATE_STP_RESET_PHY:
-		req = stp_make_phy_reset_req(device, HARD_RESET,
-			stp_req_disc_callback);
-		break;
-	case DEVICE_STATE_STP_REPORT_PHY:
-		req = stp_make_report_phy_sata_req(device,
-			stp_req_disc_callback);
-		break;
-	case DEVICE_STATE_IDLE:
-		if((device->pm)&&(device->state==DEVICE_STATE_IDLE)){
-				device->state=DEVICE_STATE_RESET_DONE;
-			}
-		break;
-	case DEVICE_STATE_RESET_DONE:
-		req = sata_make_identify_req(device,
-			MV_FALSE, 0x00);
-		break;
-	case DEVICE_STATE_IDENTIFY_DONE:
-		if ((device->capability & DEVICE_CAPABILITY_POIS_SUPPORTED)
-			&& (device->setting & DEVICE_SETTING_POIS_ENABLED)) {
-			req = sata_make_set_feature_spinup_req(device);
-			break;
-		}
-		device->state=DEVICE_STATE_SPIN_UP_DONE;
-	case DEVICE_STATE_SPIN_UP_DONE:
-
-		if (core_check_duplicate_device(root, device) == MV_TRUE) {
-			CORE_PRINT(("Duplicate SATA device. Set down\n"));
-			core_init_entry_done(root, device->base.port, NULL);
-			pal_set_down_disk(root, device, MV_FALSE);
-			return MV_TRUE;
-		}
-
-		req = sata_make_set_pio_mode_req(device);
-		break;
-	case DEVICE_STATE_SET_PIO_DONE:
-		req = sata_make_set_udma_mode_req(device);
-		break;
-	case DEVICE_STATE_SET_UDMA_DONE:
-		if (device->capability & DEVICE_CAPABILITY_WRITECACHE_SUPPORTED) {
-			req = sata_make_enable_write_cache_req(device, MV_TRUE);
-			break;
-		}else
-			device->state = DEVICE_STATE_ENABLE_WRITE_CACHE_DONE;
-	case DEVICE_STATE_ENABLE_WRITE_CACHE_DONE:
-		if (device->capability & DEVICE_CAPABILITY_READ_LOOK_AHEAD_SUPPORTED) {
-	                req = sata_make_enable_read_ahead_req(device);
-	                break;
-		}else
-			device->state = DEVICE_STATE_ENABLE_READ_AHEAD_DONE;
-	case DEVICE_STATE_ENABLE_READ_AHEAD_DONE:
-	case DEVICE_STATE_SKIP_INIT_DONE:
-		device->state = DEVICE_STATE_INIT_DONE;
-		core_init_entry_done(root, device->base.port, &device->base);
-		return MV_TRUE;
-	case DEVICE_STATE_INIT_DONE:
-		if(device->status & DEVICE_STATUS_NO_DEVICE){
-			core_init_entry_done(root, device->base.port, &device->base);
-			return MV_TRUE;
-		}
-        default:
-                MV_ASSERT(MV_FALSE);
-                return MV_FALSE;
-	}
-
-	if (req) {
-		core_append_init_request(root, req);
-		return MV_TRUE;
-	} else {
-		return MV_FALSE;
-	}
-}
-
-MV_BOOLEAN sata_port_store_sig(domain_port *port, MV_BOOLEAN from_sig_reg)
-{
-	domain_phy *phy = port->phy;
-	pl_root *root = port->base.root;
-	MV_U32 tmp, status;
-	MV_U8 retry;
-
-	if (from_sig_reg) {
-		/* read signature from signature registers */
-		phy->sata_signature = 0;
-
-        /* check the STATUS field in the FIS */
-        WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_SATA_SIG0);
-        tmp = READ_PORT_CONFIG_DATA(root, phy);
-        status = (tmp>>16) & 0xFF;
-        if (status & 0x80) {
-            /* busy */
-            CORE_DPRINT(("phy %d signature busy\n", phy->id));
-            return MV_FALSE;
-        }
-
-		WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_SATA_SIG3);
-		tmp = READ_PORT_CONFIG_DATA(root, phy) & 0xFF;
-		phy->sata_signature |= tmp;
-
-		WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_SATA_SIG1);
-		tmp = READ_PORT_CONFIG_DATA(root, phy) & 0xFFFFFF;
-		phy->sata_signature |= (tmp<<8);
-
-		CORE_DPRINT(("sig from signature FIS, 0x%x\n", phy->sata_signature));
-	} else {
-		/* read signature from unassociated FIS structure */
-		phy->sata_signature = 0;
-
-        /* check the STATUS field in the FIS */
-        tmp = MV_REG_READ_DWORD(root->rx_fis,
-			(SATA_UNASSOC_D2H_FIS(phy)));
-        status = (tmp>>16) & 0xFF;
-        if (status & 0x80) {
-            /* busy */
-            CORE_DPRINT(("phy %d signature busy\n", phy->id));
-            return MV_FALSE;
-        }
-
-		tmp = MV_REG_READ_DWORD(root->rx_fis,
-			(SATA_UNASSOC_D2H_FIS(phy)+0xc));
-		phy->sata_signature |= tmp;
-
-		tmp = MV_REG_READ_DWORD(root->rx_fis,
-			(SATA_UNASSOC_D2H_FIS(phy)+0x4));
-		phy->sata_signature |= (tmp<<8);
-
-		CORE_DPRINT(("sig from unassociated FIS, 0x%x\n", phy->sata_signature));
-	}
-
-	return MV_TRUE;
-}
-
-MV_VOID sata_port_notify_event(MV_PVOID port_p, MV_U32 irq_status)
-{
-	domain_port *port = (domain_port *)port_p;
-	pl_root *root = port->base.root;
-	MV_BOOLEAN ret;
-
-	if (port->state != PORT_SATA_STATE_SIG_DONE) {
-		CORE_DPRINT(("port %p state %d, irq_status %08X.\n", port, port->state,irq_status));
-		if (irq_status & IRQ_SIG_FIS_RCVD_MASK) {
-			ret = sata_port_store_sig(port, MV_TRUE);
-			if (!ret) {
-				CORE_DPRINT(("WD workaround, wait for second FIS\n"));
-				return;
-			}
-		} else if (irq_status & IRQ_UNASSOC_FIS_RCVD_MASK) {
-			ret = sata_port_store_sig(port, MV_FALSE);
-		}
-
-		if (port->sata_sig_timer != NO_CURRENT_TIMER) {
-			core_cancel_timer(root->core, port->sata_sig_timer);
-			port->sata_sig_timer = NO_CURRENT_TIMER;
-			CORE_DPRINT(("got FIS interrupt, call sata_sig_time_out directly.\n"));
-			sata_sig_time_out(port, NULL);
-		}
-	} else if (port->pm != NULL) {
-		CORE_DPRINT(("pm port %p state %d.\n", port, port->pm->state));
-		/* PM is waiting for this */
-		if( port->pm->state == PM_STATE_CLEAR_X_BIT ){
-			if (irq_status & IRQ_SIG_FIS_RCVD_MASK) {
-				sata_port_store_sig(port, MV_TRUE);
-				goto got_sig;
-			} else if (irq_status & IRQ_UNASSOC_FIS_RCVD_MASK) {
-				sata_port_store_sig(port, MV_FALSE);
-				goto got_sig;
-			}
-			return ;
-	        got_sig:
-			if (port->pm->sata_sig_timer != NO_CURRENT_TIMER) {
-					core_cancel_timer(root->core,
-						port->pm->sata_sig_timer);
-				port->pm->sata_sig_timer = NO_CURRENT_TIMER;
-					CORE_DPRINT(("got FIS interrupt, call pm_sig_time_out directly.\n"));
-				pm_sig_time_out(port->pm, NULL);
-			}
-		}
-	}
-}
-
-MV_VOID sata_scsi_report_lun(pl_root *root, MV_Request *req)
-{
-	MV_U32 alloc_len, lun_list_len;
-	MV_PU8 buf_ptr;
-
-	alloc_len = ((MV_U32)(req->Cdb[6] << 24)) |
-		((MV_U32)(req->Cdb[7] << 16)) |
-		((MV_U32)(req->Cdb[8] << 8)) |
-		((MV_U32)(req->Cdb[9]));
-
-	if (alloc_len < 16) {
-		req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-		prot_fill_sense_data(req, SCSI_SK_ILLEGAL_REQUEST,
-		SCSI_ASC_INVALID_FEILD_IN_CDB);
-		return;
-	}
-
-	buf_ptr = core_map_data_buffer(req);
-	MV_ZeroMemory(buf_ptr, alloc_len);
-	if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-		lun_list_len = 16;
-		if (alloc_len >= 24 && req->Data_Transfer_Length >= 24)
-			buf_ptr[23] = 0x01;	/* LUN1 has device */
-	} else {
-		/* Only LUN0 has device */
-		lun_list_len = 8;
-	}
-
-	if (req->Data_Transfer_Length >= 4) {
-		buf_ptr[0] = (MV_U8)((lun_list_len & 0xFF000000) >> 24);
-		buf_ptr[1] = (MV_U8)((lun_list_len & 0x00FF0000) >> 16);
-		buf_ptr[2] = (MV_U8)((lun_list_len & 0x0000FF00) >> 8);
-		buf_ptr[3] = (MV_U8)(lun_list_len & 0x000000FF);
-	}
-
-	core_unmap_data_buffer(req);
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-}
-
-MV_VOID sata_scsi_fill_self_test_log_page(MV_PU8 buf,
-	MV_U8 page_num)
-{
-	/* Parameter Code*/
-	buf[0] = 0;
-	buf[1] = page_num + 1;
-
-	/* DU, DS, TSD, ETC, TMC, LBIN, LP set to 0*/
-	buf[2] = 0;
-
-	/* Parameter length*/
-	buf[3] = 0x10;
-	buf[4] = 0;
-	buf[5] = 0;
-	buf[6] = 0;
-	buf[7] = 0;
-	buf[8] = 0;
-	buf[9] = 0;
-	buf[10] = 0;
-	buf[11] = 0;
-	buf[12] = 0;
-	buf[13] = 0;
-	buf[14] = 0;
-	buf[15] = 0;
-	buf[16] = 0;
-	buf[17] = 0;
-	buf[18] = 0;
-	buf[19] = 0;
-}
-
-MV_U32 sata_scsi_fill_log_sense_supported(domain_device *device,
-        MV_PU8 data_buf)
-{
-	MV_U8 length = 0;
-
-	if (device->capability &
-		DEVICE_CAPABILITY_SMART_SUPPORTED) {
-		data_buf[length++] = WRITE_ERROR_COUNTER_LOG_PAGE;
-		data_buf[length++] = READ_ERROR_COUNTER_LOG_PAGE;
-		data_buf[length++] = READ_REVERSE_ERROR_COUNTER_LOG_PAGE;
-		data_buf[length++] = VERIFY_ERROR_COUNTER_LOG_PAGE;
-		data_buf[length++] = TEMPERATURE_LOG_PAGE;
-		if (device->capability &
-			DEVICE_CAPABILITY_SMART_SELF_TEST_SUPPORTED) {
-			data_buf[length++] = SELF_TEST_RESULTS_LOG_PAGE;
-		}
-		data_buf[length++] = INFORMATIONAL_EXCEPTIONS_LOG_PAGE;
-	}
-
-        return (length);
-}
-
-MV_U32 sata_scsi_fill_log_sense_self_test(MV_PU8 data_buf)
-{
-	MV_U8 i;
-	for (i = 0; i < 20; i++) {
-		sata_scsi_fill_self_test_log_page(
-		&data_buf[i * 20],
-		i);
-	}
-
-	return 0x190;
-}
-
-MV_U32 sata_scsi_fill_log_sense_error_counter(MV_PU8 data_buf,
-        MV_U8 page_code)
-{
-	/* DU=0, DS=0, TSD=0, ETC=0, TMC=0, LBIN=1, LP=1 */
-	data_buf[0] = 0x03;
-	data_buf[1] = 2; /* parameter length */
-	data_buf[2] = 0;
-	data_buf[3] = 0; /* no errors */
-
-	return 4;
-}
-
-MV_U32 sata_scsi_fill_log_sense_temperature(MV_PU8 data_buf)
-{
-	data_buf[0] = 0;
-	data_buf[1] = 0; /* parameter code = 0*/
-	data_buf[2] = 0x03; /* LBIN=1, LP=1 */
-	data_buf[3] = 0x02; /* parameter length = 2 */
-	data_buf[4] = 0;
-	data_buf[5] = 0xFF; /* temperature in Celsius */
-	data_buf[6] = 0;
-	data_buf[7] = 01; /* parameter code = 1*/
-	data_buf[8] = 0x03; /* LBIN=1, LP=1 */
-	data_buf[9] = 0x02; /* parameter length = 2 */
-	data_buf[10] = 0;
-	data_buf[11] = 0xFF; /* reference temperature in Celsius */
-
-	return 0x0C;
-}
-
-MV_U8 sata_scsi_log_sense(pl_root *root, MV_Request *req)
-{
-	MV_U8 i = 0;
-	MV_U32 length = 0;
-	MV_PU8 data_buf;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, req->Device_Id);
-
-	/* Check page control (PC) settings*/
-	if ((req->Cdb[2] & 0xC0) != 0x40) {
-		req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-		prot_fill_sense_data(req, SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB);
-
-		return MV_TRUE;
-	}
-
-	data_buf = core_map_data_buffer(req);
-	/* Report log based on page code*/
-	switch (req->Cdb[2] & 0x3F) {
-	case SUPPORTED_LOG_PAGES_LOG_PAGE:
-		if (req->Data_Transfer_Length >= 11)
-			length = sata_scsi_fill_log_sense_supported(device,
-			&data_buf[4]);
-			break;
-
-	case SELF_TEST_RESULTS_LOG_PAGE:
-		if (req->Data_Transfer_Length >= 404)
-			length = sata_scsi_fill_log_sense_self_test(
-			&data_buf[4]);
-			break;
-	case WRITE_ERROR_COUNTER_LOG_PAGE:
-	case READ_ERROR_COUNTER_LOG_PAGE:
-	case READ_REVERSE_ERROR_COUNTER_LOG_PAGE:
-	case VERIFY_ERROR_COUNTER_LOG_PAGE:
-		if (req->Data_Transfer_Length >= 8)
-			length = sata_scsi_fill_log_sense_error_counter(
-				&data_buf[4], req->Cdb[2] & 0x3F);
-		break;
-	case TEMPERATURE_LOG_PAGE:
-		if (req->Data_Transfer_Length >= 16)
-			length = sata_scsi_fill_log_sense_temperature(
-				&data_buf[4]);
-		break;
-	case INFORMATIONAL_EXCEPTIONS_LOG_PAGE:
-		core_unmap_data_buffer(req);
-		return MV_FALSE;
-	default:
-		prot_fill_sense_data(req, SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB);
-		core_unmap_data_buffer(req);
-		req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-		return MV_TRUE;
-	}
-
-	if (req->Data_Transfer_Length >= 4) {
-		data_buf[0] = req->Cdb[2] & 0x3F;
-		data_buf[1] = 0; /* reserved */
-		data_buf[2] = (MV_U8)(length >> 8) & 0xFF; /* length */
-		data_buf[3] = (MV_U8)length & 0xFF; /* length */
-	}
-
-	core_unmap_data_buffer(req);
-	req->Data_Transfer_Length = length;
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-	return MV_TRUE;
-}
-
-MV_U8 sata_scsi_fill_mode_page_direct_access(MV_PU8 buf, domain_device *device)
-{
-        buf[0] = 0x00;
-        buf[1] = 0x01;
-        buf[2] = 0x00;
-
-        return 3;
-}
-
-MV_U8 sata_scsi_fill_mode_page_caching(MV_PU8 buf, domain_device *device)
-{
-	buf[0] = 0x08;		/* Page Code, PS = 0; */
-	buf[1] = 0x12;		/* Page Length */
-	buf[2] = 0;
-	/* set the WCE bit based on device identification data */
-	if (device->setting & DEVICE_SETTING_WRITECACHE_ENABLED)
-		buf[2] |= MV_BIT(2);
-	buf[3] = 0;	/* Demand read/write retention priority */
-	buf[4] = 0xff;	/* Disable pre-fetch trnasfer length (4,5) */
-	buf[5] = 0xff;	/* all anticipatory pre-fetching is disabled */
-	buf[6] = 0;	/* Minimum pre-fetch (6,7) */
-	buf[7] = 0;
-	buf[8] = 0;	/* Maximum pre-fetch (8,9) */
-	buf[9] = 0x01;
-	buf[10] = 0;	/* Maximum pre-fetch ceiling (10,11) */
-	buf[11] = 0x01;
-	buf[12] = 0;
-
-	/* set the DRA bit based on device identification data */
-
-	/* A disable read-ahead (DRA) bit set to one specifies that the device
-	 * server shall not read into the pre-fetch buffer any logical blocks
-	 * beyond the addressed logical block(s). A DRA bit set to zero
-	 * specifies that the device server may continue to read logical blocks
-	 * into the pre-fetch buffer beyond the addressed logical block(s).
-	 */
-	if (!(device->setting & DEVICE_SETTING_READ_LOOK_AHEAD))
-		buf[12] |= MV_BIT(5);
-	buf[13] = 0x01;	/* Number of cache segments */
-	buf[14] = 0xff;	/* Cache segment size (14, 15) */
-	buf[15] = 0xff;
-	buf[16] = 0;
-	buf[17] = 0;
-	buf[18] = 0;
-	buf[19] = 0;
-	return 0x14;	/* Total page length in byte */
-}
-
-MV_U8 sata_scsi_fill_mode_page_rw_error(MV_PU8 data_buf, domain_device *device)
-{
-	data_buf[0] = RW_ERROR_RECOVERY_MODE_PAGE;
-	data_buf[1] = 0x0A; /* page length */
-	data_buf[2] = 0x80; /* AWRE bit */
-	data_buf[3] = 0; /* read retry count */
-	data_buf[4] = 0;
-	data_buf[5] = 0;
-	data_buf[6] = 0;
-	data_buf[7] = 0;
-	data_buf[8] = 0; /* write retry count */
-	data_buf[9] = 0;
-	data_buf[10] = 0;
-	data_buf[11] = 0;
-
-	return 12;
-}
-
-MV_U8 sata_scsi_fill_mode_page_ctrl(MV_PU8 data_buf, domain_device *device)
-{
-	data_buf[0] = CONTROL_MODE_PAGE;
-	data_buf[1] = 0x0A; /* page length */
-	data_buf[2] = 0x02; /* GLTSD=1 */
-	data_buf[3] = 0;
-	data_buf[4] = 0;
-	data_buf[5] = 0;
-	data_buf[6] = 0;
-	data_buf[7] = 0;
-	data_buf[8] = 0xFF;
-	data_buf[9] = 0xFF; /* busy timeout period */
-	if (device->capability & DEVICE_CAPABILITY_SMART_SELF_TEST_SUPPORTED) {
-		data_buf[10] = 0x02; /* extended self-test cmpltn time */
-		data_buf[11] = 0x58; /* see 05-359r1 */
-	} else {
-		data_buf[10] = 0;
-		data_buf[11] = 0;
-	}
-
-	return 12;
-}
-
-MV_U8 sata_scsi_fill_mode_page_port(MV_PU8 data_buf, domain_device *device)
-{
-	data_buf[0] = PORT_MODE_PAGE;
-	data_buf[1] = 0x01; /* page length */
-	data_buf[2] = 0x08; /* protocol identifier = ATA */
-
-	return 3;
-}
-
-MV_U8 sata_scsi_fill_mode_page_iec(MV_PU8 data_buf, domain_device *device)
-{
-	data_buf[0] = INFORMATIONAL_EXCEPTIONS_CONTROL_MODE_PAGE;
-	data_buf[1] = 0x0A; /* page length */
-	/* PERF=1, RSRV, EBF=1, EWasc=1, DExcpt=0, TEST=1, EBACKerr=1, LOGERR=1 */
-	data_buf[2] = 0xB7;
-	data_buf[3] = 0x04; /* MRIE=Unconditionally generate recovered error */
-	data_buf[4] = 0;
-	data_buf[5] = 0;
-	data_buf[6] = 0;
-	data_buf[7] = 0; /* INTERVAL TIMER */
-	data_buf[8] = 0;
-	data_buf[9] = 0;
-	data_buf[10] = 0;
-	data_buf[11] = 0; /* REPORT COUNT */
-
-	return 12;
-}
-
-MV_U8 sata_scsi_fill_mode_page_all(MV_PU8 data_buf, domain_device *device)
-{
-	MV_U8 length = 0;
-
-	length += sata_scsi_fill_mode_page_direct_access(&data_buf[length],
-	                device);
-	length += sata_scsi_fill_mode_page_caching(&data_buf[length], device);
-	length += sata_scsi_fill_mode_page_rw_error(&data_buf[length], device);
-	length += sata_scsi_fill_mode_page_ctrl(&data_buf[length], device);
-	length += sata_scsi_fill_mode_page_port(&data_buf[length], device);
-	length += sata_scsi_fill_mode_page_iec(&data_buf[length], device);
-
-	return length;
-}
-MV_U8 sata_check_page_control(MV_Request *req,MV_U8 page_control){
-	MV_U8 ret=0;
-	switch(page_control){
-		case 0:
-			ret=0;
-			break;
-		case 3:
-			ret=1;
-			req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-			prot_fill_sense_data(req, SCSI_SK_ILLEGAL_REQUEST, SCSI_ASC_SAVING_PARAMETERS_NOT_SUPPORT);
-			break;
-		case 1:
-		case 2:
-		default:
-			ret=1;
-			req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-			prot_fill_sense_data(req, SCSI_SK_ILLEGAL_REQUEST, SCSI_ASC_INVALID_FEILD_IN_CDB);
-			break;
-		}
-	return ret;
-}
-
-MV_VOID sata_scsi_mode_sense(pl_root *root, MV_Request *req)
-{
-	MV_U8 page_code = req->Cdb[2] & 0x3F;	/* Same for mode sense 6 and 10 */
-	MV_U8 page_control=req->Cdb[2]>>6;
-	MV_U32 page_len = 0, tmp_len = 0;
-	domain_device *device = (domain_device *)
-	get_device_by_id(root->lib_dev, req->Device_Id);
-	MV_PU8 buf_ptr = core_map_data_buffer(req);
-	MV_U32 offset;
-
-	if (req->Cdb[0] == SCSI_CMD_MODE_SENSE_6)
-		offset = 4;
-	else
-		offset = 8;
-
-	switch (page_code) {
-	case DIRECT_ACCESS_BLOCK_DEVICE_MODE_PAGE:
-		page_len = 3;
-		if (req->Data_Transfer_Length >= (3 + offset))
-		page_len = sata_scsi_fill_mode_page_direct_access(
-		                &buf_ptr[offset], device);
-		break;
-	case RW_ERROR_RECOVERY_MODE_PAGE:
-		page_len = 12;
-		if (req->Data_Transfer_Length >= 12 + offset)
-		page_len = sata_scsi_fill_mode_page_rw_error(
-		                &buf_ptr[offset], device);
-		break;
-	case CACHE_MODE_PAGE:
-		page_len = 20;
-		if(sata_check_page_control(req,page_control))
-			break;
-		if (req->Data_Transfer_Length >= 20 + offset)
-		page_len = sata_scsi_fill_mode_page_caching(
-		                &buf_ptr[offset], device);
-		break;
-	case CONTROL_MODE_PAGE:
-		page_len = 12;
-		if (req->Data_Transfer_Length >= 12 + offset)
-		page_len = sata_scsi_fill_mode_page_ctrl(
-		                &buf_ptr[offset], device);
-		break;
-	case PORT_MODE_PAGE:
-		page_len = 3;
-		if (req->Data_Transfer_Length >= 3 + offset)
-		page_len = sata_scsi_fill_mode_page_port(
-		                &buf_ptr[offset], device);
-		break;
-	case INFORMATIONAL_EXCEPTIONS_CONTROL_MODE_PAGE:
-		page_len = 12;
-		if (req->Data_Transfer_Length >= 12 + offset)
-		page_len = sata_scsi_fill_mode_page_iec(
-		                &buf_ptr[offset], device);
-		break;
-	case ALL_MODE_PAGE:
-		page_len = 62;
-		if (req->Data_Transfer_Length >= 62 + offset)
-		page_len = sata_scsi_fill_mode_page_all(
-		                &buf_ptr[offset], device);
-		break;
-	default:
-		req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-		prot_fill_sense_data(req, SCSI_SK_ILLEGAL_REQUEST,
-		SCSI_ASC_INVALID_FEILD_IN_CDB);
-		return;
-	}
-
-
-	/* Mode Data Length, it does not include the number of bytes in */
-	/* Mode Data Length field */
-	if (req->Cdb[0] == SCSI_CMD_MODE_SENSE_6) {
-		buf_ptr[0] = (MV_U8)(page_len + 3);    /* Mode data length */
-		buf_ptr[1] = 0;                /* Medium type=0 */
-		buf_ptr[2] = 0;                /* Device-Specific Parameter*/
-		buf_ptr[3] = 0;                /* Block Descriptor Length=0 */
-		tmp_len = MV_MIN(req->Data_Transfer_Length, (page_len + 4));
-	} else {
-		tmp_len = page_len + 6;
-		buf_ptr[0] = (MV_U8)(((MV_U16)tmp_len) >> 8);
-		buf_ptr[1] = (MV_U8)tmp_len;
-		buf_ptr[2] = 0;
-		buf_ptr[3] = 0;
-		buf_ptr[4] = 0;
-		buf_ptr[5] = 0;
-		buf_ptr[6] = 0;
-		buf_ptr[7] = 0;
-		tmp_len = MV_MIN(req->Data_Transfer_Length, (page_len + 8));
-	}
-
-	core_unmap_data_buffer(req);
-	req->Data_Transfer_Length = tmp_len;
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-}
-
-MV_U8
-mode_select_helper(pl_root *root, MV_Request *req)
-{
-	MV_U32  length = req->Data_Transfer_Length;
-	MV_U8   PF = (req->Cdb[1] & MV_BIT(4)) >> 4;
-	MV_U8   SP = (req->Cdb[1] & MV_BIT(0));
-	MV_U8*	list = core_map_data_buffer(req);
-	MV_U32  offset;
-	MV_U32  cache_page_offset = 0;
-	MV_U8   ret = 0;
-
-	if (PF == 0) {
-		ret = 0x2; /* Invalid field in CDB */
-		goto mode_select_helper_end;
-	}
-
-	if (SP == 1) {
-		ret = 0x2; /* PARAMETER LIST LENGTH ERROR */
-		goto mode_select_helper_end;
-	}
-
-	if (length == 0) {
-		ret = 0;
-		goto mode_select_helper_end;
-	}
-
-	if (length < 4) {
-		ret = 0x1; /* PARAMETER LIST LENGTH ERROR */
-		goto mode_select_helper_end;
-	}
-
-	if (list[0] || (list[1] != MV_SCSI_DIRECT_ACCESS_DEVICE) || list[2]) {
-		ret = 0x3; /* Invalid field in parameter list */
-		goto mode_select_helper_end;
-	}
-
-	if (list[3]) {
-		if (list[3] != 8) {
-			ret = 0x3; /* Invalid field in parameter list */
-			goto mode_select_helper_end;
-		}
-
-		if (length < 12) {
-			ret = 0x1; /* PARAMETER LIST LENGTH ERROR */
-			goto mode_select_helper_end;
-		}
-
-		if (list[4] || list[5] || list[6] || list[7] || list[8] || list[9] ||
-		(list[10] != 0x2) || list[11]) {
-			ret = 0x3; /* Invalid field in parameter list */
-			goto mode_select_helper_end;
-		}
-	}
-	offset = 4 + list[3];/* skip the mode parameter block descriptor */
-
-	if (length == offset) {
-		ret = 0;
-		goto mode_select_helper_end;
-	}
-
-	while ((offset + 2) < length) {
-		switch (list[offset] & 0x3f) {
-		case CACHE_MODE_PAGE:
-			ret = 0xff;
-			goto mode_select_helper_end;
-		case CONTROL_MODE_PAGE:
-			if ((list[offset] != 0xa) || (list[offset+1] != 0xa)) {
-			ret = 0x3;
-			goto mode_select_helper_end;
-			}
-
-			if (list[offset + 3] != MV_BIT(4)) {
-				ret = 0x3;
-				goto mode_select_helper_end;
-			}
-
-			if (list[offset + 2] || list[offset + 4] || list[offset + 5] ||
-			list[offset + 6] || list[offset + 7]||list[offset + 8] ||
-			list[offset + 9]|| list[offset + 10] || list[offset + 11]) {
-				ret = 0x3;
-				goto mode_select_helper_end;
-			}
-
-			offset += list[offset + 1] + 2;
-			break;
-		default:
-			ret = 0x3; /* Invalid field in parameter list */
-			goto mode_select_helper_end;
-		}
-	}
-
-	if (length != offset)
-		ret = 0x1; /* PARAMETER LIST LENGTH ERROR */
-
-mode_select_helper_end:
-	core_unmap_data_buffer(req);
-	return ret;
-}
-
-MV_BOOLEAN sata_scsi_mode_select(pl_root *root, MV_Request *req)
-{
-	MV_U8 result;
-	result = mode_select_helper(root, req);
-
-	if (result == 0xff)
-		return MV_FALSE;
-
-	if (result == 0x0) {
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-	} else if (req->Sense_Info_Buffer_Length > sizeof(MV_Sense_Data)) {
-		if (result == 0x1) {/*PARAMETER LIST LENGTH ERROR*/
-			MV_SetSenseData(
-			(PMV_Sense_Data)req->Sense_Info_Buffer,
-			SCSI_SK_ILLEGAL_REQUEST, 0x1a, 0);
-		} else if (result == 0x2) {
-			MV_SetSenseData(
-			(PMV_Sense_Data)req->Sense_Info_Buffer,
-			SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ADSENSE_INVALID_CDB, 0);
-		} else if (result == 0x3) {
-			MV_SetSenseData(
-			(PMV_Sense_Data)req->Sense_Info_Buffer,
-			SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FIELD_IN_PARAMETER, 0);
-		} else {
-			MV_SetSenseData(
-			(PMV_Sense_Data)req->Sense_Info_Buffer,
-			SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ADSENSE_NO_SENSE, 0);
-		}
-		req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-	} else {
-		req->Scsi_Status = REQ_STATUS_INVALID_PARAMETER;
-	}
-
-	return MV_TRUE;
-}
-
-void sata_scsi_read_defect_data(pl_root *root, MV_Request *req)
-{
-	MV_U32 length;
-	MV_PU8 buf_ptr = core_map_data_buffer(req);
-
-	length = MV_MIN(req->Data_Transfer_Length, 4);
-
-	if (length >= 4) {
-		buf_ptr[0] = 0;
-		buf_ptr[1] = req->Cdb[2] & 0x07;
-		buf_ptr[2] = 0;
-		buf_ptr[3] = 0;
-	}
-
-	core_unmap_data_buffer(req);
-	req->Data_Transfer_Length = length;
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-}
-
-void sata_get_ncq_tag(MV_PVOID dev_p, MV_Request *req)
-{
-	domain_device *device = (domain_device *)dev_p;
-	int tag;
-	core_context *ctx = req->Context[MODULE_CORE];
-
-	MV_DASSERT(IS_STP_OR_SATA(device));
-	MV_DASSERT(req->Cmd_Flag & CMD_FLAG_NCQ);
-
-	tag = ffc(device->ncq_tags);
-
-	MV_DASSERT(tag != -1);
-
-	if (tag >= 32) tag -= 32;
-	device->next_ncq = tag+1;
-	if (device->next_ncq >= 32) device->next_ncq -= 32;
-
-	MV_DASSERT(tag >= 0);
-
-	device->ncq_tags |= MV_BIT(tag);
-	ctx->ncq_tag = (MV_U8) tag;
-}
-
-void sata_free_ncq_tag(MV_PVOID dev_p, MV_Request *req)
-{
-	domain_device *device = (domain_device *)dev_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_U8 tag = ctx->ncq_tag;
-
-	MV_DASSERT(IS_STP_OR_SATA(device));
-	MV_DASSERT(req->Cmd_Flag & CMD_FLAG_NCQ);
-
-	device->ncq_tags &= ~MV_BIT(tag);
-}
-
-MV_BOOLEAN sata_check_instant_req(pl_root *root, domain_device *device,
-	MV_Request *req)
-{
-	MV_BOOLEAN ret = MV_TRUE;
-
-	if (req->Cdb[0] == APICDB0_ADAPTER){
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		return MV_TRUE;
-	}
-
-	if (IS_ATAPI(device)) {
-		if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC) &&
-			(req->Cdb[1] == CDB_CORE_MODULE) &&
-			(req->Cdb[2] == CDB_CORE_OS_SMART_CMD)) {
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_TRUE;
-		}
-
-		if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC) &&
-			(req->Cdb[1] == CDB_CORE_MODULE) &&
-			(req->Cdb[2] == CDB_CORE_RESET_PORT)) {
-			mv_reset_phy(root, req->Cdb[3], MV_TRUE);
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_TRUE;
-		}
-
-		return MV_FALSE;
-	}
-
-	switch (req->Cdb[0]) {
-	case SCSI_CMD_RESERVE_6:
-	case SCSI_CMD_RELEASE_6:
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		break;
-	case SCSI_CMD_REPORT_LUN:
-		sata_scsi_report_lun(root, req);
-		break;
-	case SCSI_CMD_MODE_SENSE_6:
-	case SCSI_CMD_MODE_SENSE_10:
-		sata_scsi_mode_sense(root, req);
-		break;
-	case SCSI_CMD_MODE_SELECT_6:
-	case SCSI_CMD_MODE_SELECT_10:
-		ret = sata_scsi_mode_select(root, req);
-		break;
-	case SCSI_CMD_LOG_SENSE:
-		ret = sata_scsi_log_sense(root, req);
-		break;
-	case SCSI_CMD_READ_DEFECT_DATA_10:
-		sata_scsi_read_defect_data(root, req);
-		break;
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		if (req->Cdb[1] == CDB_CORE_MODULE) {
-			if (req->Cdb[2] == CDB_CORE_RESET_DEVICE) {
-				if (device->base.parent->type == BASE_TYPE_DOMAIN_PM)
-				{
-					extern MV_VOID pm_device_phy_reset(domain_pm *pm, MV_U8 device_port);
-					pm_device_phy_reset(device->pm, device->pm_port);
-					req->Scsi_Status = REQ_STATUS_SUCCESS;
-					ret = MV_TRUE;
-				}
-				else
-				{
-					mv_reset_phy(root, req->Cdb[3], MV_FALSE);
-					req->Scsi_Status = REQ_STATUS_SUCCESS;
-					ret = MV_TRUE;
-				}
-			} else if (req->Cdb[2] == CDB_CORE_RESET_PORT) {
-				mv_reset_phy(root, req->Cdb[3], MV_TRUE);
-				req->Scsi_Status = REQ_STATUS_SUCCESS;
-				ret = MV_TRUE;
-			} else {
-				ret = MV_FALSE;
-			}
-		} else {
-			ret = MV_FALSE;
-		}
-		break;
-	default:
-		ret = MV_FALSE;
-		break;
-	}
-
-	return ret;
-}
-
-MV_U8 sata_verify_command(MV_PVOID root, MV_PVOID dev_p,
-	MV_Request *req)
-{
-	domain_device *device = (domain_device *)dev_p;
-        core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_U8 tag, set, ret;
-       MV_Request *sub_req;
-	MV_Request *new_req = NULL;
-
-	if (!(device->status & DEVICE_STATUS_FUNCTIONAL)) {
-		if( !(IS_ATA_PASSTHRU_CMD(req,SCSI_CMD_MARVELL_VENDOR_UNIQUE))) {
-			req->Scsi_Status = REQ_STATUS_NO_DEVICE;
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		}
-	}
-
-	if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC) &&
-		(req->Cdb[1] == CDB_CORE_MODULE) &&
-		(req->Cdb[2] == CDB_CORE_STP_VIRTUAL_PHY_RESET)) {
-		new_req = smp_make_phy_control_req(device, req->Cdb[3],
-			smp_physical_req_callback);
-		if (!new_req) {
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-		}
-		((core_context *)new_req->Context[MODULE_CORE])->u.org.org_req = req;
-		core_queue_eh_req(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-	}
-
-	if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC) &&
-		(req->Cdb[1] == CDB_CORE_MODULE) &&
-		(req->Cdb[2] == CDB_CORE_STP_VIRTUAL_REPORT_SATA_PHY)) {
-			new_req = smp_make_report_phy_sata_req(device, smp_physical_req_callback);
-			if (!new_req)
-				return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-			((core_context *)new_req->Context[MODULE_CORE])->u.org.org_req = req;
-			if (CORE_IS_INIT_REQ(ctx))
-				core_append_init_request(root, new_req);
-			else if (CORE_IS_EH_REQ(ctx))
-				core_queue_eh_req(root, new_req);
-			else
-				core_append_request(root, new_req);
-
-			return MV_QUEUE_COMMAND_RESULT_REPLACED;
-		}
-
-	if (sata_check_instant_req(root, device, req))
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-	if((req->Cdb[0] == APICDB0_PASS_THRU_CMD_SCSI)||
-                (req->Cdb[0] == APICDB0_PASS_THRU_CMD_ATA)){
-		return (core_pass_thru_send_command(
-                                ((pl_root *)root)->core, req));
-	}
-
-	sub_req = core_split_large_request(root, req);
-	if (sub_req == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-	else if (sub_req != req)
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	if (sat_categorize_cdb(root, req) == MV_FALSE) {
-		req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	ret = scsi_ata_translation(root, req);
-	if (ret == MV_QUEUE_COMMAND_RESULT_FINISHED) {
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	} else if (ret == MV_QUEUE_COMMAND_RESULT_NO_RESOURCE ||
-		ret == MV_QUEUE_COMMAND_RESULT_REPLACED) {
-		req->Scsi_Status = REQ_STATUS_PENDING;
-		return ret;
-	}
-
-	if (device->register_set == NO_REGISTER_SET) {
-		set = sata_get_register_set(root);
-		if (set == NO_REGISTER_SET)
-			return MV_QUEUE_COMMAND_RESULT_FULL;
-		else
-			device->register_set = set;
-	}
-
-	if (req->Cmd_Flag & CMD_FLAG_NCQ) {
-		if (device->base.outstanding_req != 0) {
-			if (!(device->setting & DEVICE_SETTING_NCQ_RUNNING)) {
-				/* non ncq request is running */
-				return MV_QUEUE_COMMAND_RESULT_FULL;
-			} else {
-				MV_DASSERT(device->base.outstanding_req < 32);
-			}
-		} else {
-			device->setting |= DEVICE_SETTING_NCQ_RUNNING;
-		}
-	} else {
-		if (device->base.outstanding_req != 0) {
-			return MV_QUEUE_COMMAND_RESULT_FULL;
-		} else {
-			device->setting &= ~DEVICE_SETTING_NCQ_RUNNING;
-		}
-	}
-
-	return MV_QUEUE_COMMAND_RESULT_PASSED;
-}
-
-MV_VOID sata_prepare_command_header(MV_Request *req,
-	mv_command_header *cmd_header, mv_command_table *cmd_table,
-	MV_U8 tag, MV_U8 pm_port)
-{
-	MV_U32 dword_0= 0;
-	if (req->Cmd_Flag & CMD_FLAG_PACKET)
-		dword_0 |= CH_ATAPI;
-	if (req->Cmd_Flag & CMD_FLAG_SOFT_RESET)
-		dword_0 |= CH_RESET;
-	if (req->Cmd_Flag & CMD_FLAG_NCQ)
-		dword_0 |= CH_FPDMA;
-
-	dword_0 |= (pm_port & CH_PM_PORT_MASK);
-	cmd_header->ctrl_nprd |= MV_CPU_TO_LE32(dword_0);
-	cmd_header->frame_len = MV_CPU_TO_LE16(FIS_REG_H2D_SIZE_IN_DWORD);
-	cmd_header->tag = MV_CPU_TO_LE16(tag);
-}
-
-MV_VOID sata_prepare_command_table(MV_Request *req, mv_command_table *cmd_table,
-	ata_taskfile *taskfile, MV_U8 pm_port)
-{
-	scsi_to_sata_fis(req, cmd_table->table.stp_cmd_table.fis, taskfile, pm_port);
-
-	if (req->Cmd_Flag & CMD_FLAG_PACKET) {
-		MV_CopyMemory(&cmd_table->table.stp_cmd_table.atapi_cdb, req->Cdb,
-			MAX_CDB_SIZE);
-	}
-}
-
-MV_VOID sata_prepare_command(MV_PVOID root, MV_PVOID dev_p,
-	MV_PVOID cmd_header_p, MV_PVOID cmd_table_p, MV_Request *req)
-{
-	domain_device *device = (domain_device *)dev_p;
-	mv_command_header *cmd_header = (mv_command_header *)cmd_header_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	ata_taskfile taskfile;
-	MV_BOOLEAN ret;
-	core_context *ctx = req->Context[MODULE_CORE];
-	MV_U8 tag;
-
-	if (req->Cmd_Flag & CMD_FLAG_NCQ) {
-		sata_get_ncq_tag(device, req);
-		tag = ctx->ncq_tag;
-	} else {
-		tag = req->Tag;
-	}
-
-	if (IS_ATAPI(device)) {
-		ret = atapi_fill_taskfile(device, req, &taskfile);
-	} else {
-		ret = ata_fill_taskfile(device, req, tag, &taskfile);
-	}
-	if (!ret) {
-		MV_DASSERT(MV_FALSE);
-	}
-
-	sata_prepare_command_header(req, cmd_header, cmd_table, tag,
-		device->pm_port);
-	if (req->Cmd_Flag & CMD_FLAG_SOFT_RESET) {
-		if (!taskfile.control) {
-			cmd_header->ctrl_nprd &= MV_CPU_TO_LE32(~CH_RESET);
-		}
-	}
-
-	sata_prepare_command_table(req, cmd_table, &taskfile, device->pm_port);
-}
-
-MV_VOID sata_send_command(MV_PVOID root_p, MV_PVOID dev_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_U8 phy_map;
-	MV_U32 entry_nm;
-	domain_device *device = (domain_device *)dev_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	entry_nm = prot_get_delv_q_entry(root);
-	phy_map = device->base.port->asic_phy_map;
-
-	root->delv_q[entry_nm] = MV_CPU_TO_LE32(TXQ_MODE_I | ctx->slot | phy_map << TXQ_PHY_SHIFT | \
-		device->register_set << TXQ_REGSET_SHIFT |TXQ_CMD_STP);
-
-	prot_write_delv_q_entry(root, entry_nm);
-}
-
-MV_VOID sata_process_command(MV_PVOID root_p, MV_PVOID dev_p,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table_p, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_device *device = (domain_device *)dev_p;
-	mv_command_table *cmd_table = (mv_command_table *)cmd_table_p;
-	MV_U32 error,tmp, cmpl_q = *(MV_PU32)cmpl_q_p;
-	err_info_record *err_info;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_U32 params[MAX_EVENT_PARAMS];
-
-
-	err_info = prot_get_command_error_info(cmd_table, &cmpl_q);
-	if (err_info == 0) {
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-	} else {
-		CORE_EH_PRINT(("dev %d, req %p.\n", req->Device_Id, req));
-		error = MV_LE32_TO_CPU(err_info->err_info_field_1);
-		req->Scsi_Status = REQ_STATUS_ERROR;
-
-		if (error & CMD_ISS_STPD){
-			ctx->error_info |= EH_INFO_CMD_ISS_STPD;
-			device->base.cmd_issue_stopped = MV_TRUE;
-		}
-
-		if ((error & WD_TMR_TO_ERR) || (error & TX_STOPPED_EARLY)){
-			req->Scsi_Status = REQ_STATUS_TIMEOUT;
-			ctx->error_info |= EH_INFO_STP_WD_TO_RETRY;
-			ctx->error_info |= EH_INFO_NEED_RETRY;
-			return;
-		}
-
-		if (error & TFILE_ERR){
-			sata_handle_taskfile_error(root, req);
-
-                     if (sat_get_org_req(req) == NULL)
-			core_generate_error_event(root->core, req);
-			return;
-                }
-		if (error & R_ERR){
-			MV_REG_WRITE_DWORD(root->mmio_base,COMMON_CMD_ADDR, CMD_SATA_TFDATA0);
-			tmp=MV_REG_READ_DWORD(root->mmio_base,COMMON_CMD_DATA);
-			if((tmp&0xff)==0x40 && (tmp&0xff00)==0 ){
-				req->Scsi_Status = REQ_STATUS_SUCCESS;
-				return;
-			}
-		}
-
-		MV_ASSERT(((MV_U64 *)err_info)->value != 0);
-
-		CORE_EH_PRINT(("attention: req %p[0x%x] unknown error 0x%08x 0x%08x! "\
-			"treat as media error.\n",\
-			req, req->Cdb[0],
-			((MV_U64 *)err_info)->parts.high, \
-			((MV_U64 *)err_info)->parts.low));
-
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		ctx->error_info |= EH_INFO_NEED_RETRY;
-	}
-}
-
-MV_PVOID sata_store_received_fis(pl_root *root, MV_U8 register_set, MV_U32 flag)
-{
-	saved_fis *fis = &root->saved_fis_area[register_set];
-
-	if ((flag & CMD_FLAG_PIO) && (flag & CMD_FLAG_DATA_IN)) {
-		fis->dw1 = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_PIO_FIS(root, register_set) + 0x0);
-		fis->dw2 = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_PIO_FIS(root, register_set) + 0x4);
-		fis->dw3 = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_PIO_FIS(root, register_set) + 0x8);
-		fis->dw4 = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_PIO_FIS(root, register_set) + 0xC);
-	} else {
-		fis->dw1 = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_D2H_FIS(root, register_set) + 0x0);
-		fis->dw2 = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_D2H_FIS(root, register_set) + 0x4);
-		fis->dw3 = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_D2H_FIS(root, register_set) + 0x8);
-		fis->dw4 = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_D2H_FIS(root, register_set) + 0xC);
-	}
-	return (MV_PVOID)fis;
-}
--- a/drivers/scsi/vanir/core/sata_base/core_sata.h
+++ /dev/null
@@ -1,401 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_SATA_H
-#define __CORE_SATA_H
-
-#include "mv_config.h"
-#include "core_type.h"
-
-MV_BOOLEAN sata_port_state_machine(MV_PVOID dev);
-MV_BOOLEAN sata_device_state_machine(MV_PVOID dev);
-
-MV_VOID sata_port_notify_event(MV_PVOID port_p, MV_U32 irq_status);
-MV_U8 sata_verify_command(MV_PVOID root_p, MV_PVOID dev,
-       MV_Request *req);
-MV_VOID sata_prepare_command(MV_PVOID root_p, MV_PVOID dev,
-	MV_PVOID cmd_header, MV_PVOID cmd_table,
-	MV_Request *req);
-MV_VOID sata_send_command(MV_PVOID root_p, MV_PVOID dev,
-	MV_Request *req);
-MV_VOID sata_process_command(MV_PVOID root_p, MV_PVOID dev,
-	MV_PVOID cmpl_q_p, MV_PVOID cmd_table,
-	MV_Request *req);
-MV_BOOLEAN sata_check_complete_command(MV_PVOID root_p, MV_Request *req);
-MV_BOOLEAN sata_detect_phy_rdy(MV_PVOID sata_port);
-
-void sata_get_ncq_tag(MV_PVOID dev_p, MV_Request *req);
-void sata_free_ncq_tag(MV_PVOID dev_p, MV_Request *req);
-
-void sata_free_register_set(MV_PVOID root_p, MV_U8 set);
-
-/*
- * ======================================================================
- * ATA definition
- * ======================================================================
- */
-
-/* PIO command */
-#define ATA_CMD_READ_PIO				0x20
-#define ATA_CMD_READ_PIO_MULTIPLE                       0xC4
-#define ATA_CMD_READ_PIO_EXT			0x24
-#define ATA_CMD_READ_PIO_MULTIPLE_EXT 	0x29
-#define ATA_CMD_WRITE_PIO				0x30
-#define ATA_CMD_WRITE_PIO_MULTIPLE                      0xC5
-#define ATA_CMD_WRITE_PIO_EXT			0x34
-#define ATA_CMD_WRITE_PIO_MULTIPLE_EXT	0x39
-#define ATA_CMD_WRITE_PIO_MULTIPLE_FUA_EXT              0xCE
-
-#define IS_ATA_MULTIPLE_READ_WRITE(x) \
-        ((x == ATA_CMD_READ_PIO_MULTIPLE)\
-        ||(x == ATA_CMD_READ_PIO_MULTIPLE_EXT)\
-        ||(x == ATA_CMD_WRITE_PIO_MULTIPLE)\
-        ||(x == ATA_CMD_WRITE_PIO_MULTIPLE_EXT)\
-        ||(x == ATA_CMD_WRITE_PIO_MULTIPLE_FUA_EXT))
-
-/* DMA read write command */
-#define ATA_CMD_READ_DMA				0xC8	/* 24 bit DMA read */
-#define ATA_CMD_READ_DMA_QUEUED			0xC7	/* 24 bit TCQ DMA read */
-#define ATA_CMD_READ_DMA_EXT			0x25	/* 48 bit DMA read */
-#define ATA_CMD_READ_DMA_QUEUED_EXT		0x26	/* 48 bit TCQ DMA read */
-#define ATA_CMD_READ_FPDMA_QUEUED		0x60	/* NCQ DMA read: SATA only.
-												 * Always 48 bit */
-
-#define ATA_CMD_WRITE_DMA				0xCA
-#define ATA_CMD_WRITE_DMA_QUEUED		0xCC
-#define ATA_CMD_WRITE_DMA_EXT  			0x35
-#define ATA_CMD_WRITE_DMA_QUEUED_EXT	0x36
-#define ATA_CMD_WRITE_FPDMA_QUEUED		0x61
-
-/* Identify command */
-#define ATA_CMD_IDENTIFY_ATA			0xEC
-#define ATA_CMD_IDENTIFY_ATAPI			0xA1
-
-#define ATA_CMD_VERIFY					0x40	/* 24 bit read verifty */
-#define ATA_CMD_VERIFY_EXT				0x42	/* 48 bit read verify */
-
-#define ATA_CMD_FLUSH					0xE7	/* 24 bit flush */
-#define ATA_CMD_FLUSH_EXT				0xEA	/* 48 bit flush */
-
-#define ATA_CMD_PACKET					0xA0
-#define ATA_CMD_SMART					0xB0
-	#define ATA_CMD_SMART_READ_DATA 					0xD0
-        #define ATA_CMD_SMART_READ_ATTRIBUTE_THRESHOLDS 0xD1
-	#define ATA_CMD_SMART_ENABLE_ATTRIBUTE_AUTOSAVE	0xD2
-        #define ATA_CMD_SMART_SAVE_ATTRIBUTE_VALUES     0xD3
-	#define ATA_CMD_SMART_EXECUTE_OFFLINE				0xD4
-	#define ATA_CMD_SMART_READ_LOG						0xD5
-	#define ATA_CMD_SMART_WRITE_LOG 					0xD6
-	#define ATA_CMD_ENABLE_SMART				0xD8
-	#define ATA_CMD_DISABLE_SMART				0xD9
-	#define ATA_CMD_SMART_RETURN_STATUS			0xDA
-
-#define ATA_CMD_SET_FEATURES			0xEF
-	#define ATA_CMD_ENABLE_WRITE_CACHE			0x02
-	#define ATA_CMD_SET_TRANSFER_MODE			0x03
-	#define ATA_CMD_SET_POIS_SPINUP			0x07
-	#define ATA_CMD_DISABLE_READ_LOOK_AHEAD		0x55
-	#define ATA_CMD_DISABLE_REVERT_TO_DEFAULT	0x66
-	#define ATA_CMD_DISABLE_WRITE_CACHE			0x82
-	#define ATA_CMD_ENABLE_READ_LOOK_AHEAD		0xAA
-	#define ATA_CMD_ENABLE_REVERT_TO_DEFAULT	0xCC
-
-#define ATA_CMD_SEEK					0x70
-#define ATA_CMD_READ_LOG_EXT			0x2F
-#define ATA_CMD_DOWNLOAD_MICROCODE		0x92
-
-/* PM commands & registers */
-#define ATA_CMD_PM_READ				0xE4
-#define ATA_CMD_PM_WRITE			0xE8
-#ifndef ATA_CMD_PM_CHECK
-#define ATA_CMD_PM_CHECK			0xE5
-#endif
-#define ATA_CMD_MEDIA_EJECT                     0xED
-#define ATA_CMD_IDLE                            0xE3
-#define ATA_CMD_IDLE_IMMEDIATE                  0xE1
-#define ATA_CMD_STANDBY                         0xE2
-#define ATA_CMD_STANDBY_IMMEDIATE               0xE0
-#define ATA_CMD_SLEEP                           0xE6
-#define ATA_CMD_EXECUTE_DEVICE_DIAGNOSTIC		0x90
-
-struct _ata_taskfile;
-typedef struct _ata_taskfile ata_taskfile;
-
-struct _ata_taskfile {
-	MV_U8	features;
-	MV_U8	sector_count;
-	MV_U8	lba_low;
-	MV_U8	lba_mid;
-	MV_U8	lba_high;
-	MV_U8	device;
-	MV_U8	command;
-
-	MV_U8	control;
-
-	/* extension */
-	MV_U8	feature_exp;
-	MV_U8	sector_count_exp;
-	MV_U8	lba_low_exp;
-	MV_U8	lba_mid_exp;
-	MV_U8	lba_high_exp;
-};
-
-/* ATA device identify frame */
-typedef struct _ata_identify_data {
-	MV_U16 general_config;							/*	0	*/
-	MV_U16 obsolete0;								/*	1	*/
-	MV_U16 specific_config;							/*	2	*/
-	MV_U16 obsolete1;								/*	3	*/
-	MV_U16 retired0[2];								/*	4-5	*/
-	MV_U16 obsolete2;								/*	6	*/
-	MV_U16 reserved0[2];							/*	7-8	*/
-	MV_U16 retired1;								/*	9	*/
-	MV_U8 serial_number[20];				        /*	10-19	*/
-	MV_U16 retired2[2];								/*	20-21	*/
-	MV_U16 obsolete3;								/*	22	*/
-	MV_U8 firmware_revision[8];						/*	23-26	*/
-	MV_U8 model_number[40];							/*	27-46	*/
-	MV_U16 maximum_block_transfer;					/*	47	*/
-	MV_U16 reserved1;								/*	48	*/
-	MV_U16 capabilities[2];							/*	49-50	*/
-	MV_U16 obsolete4[2];							/*	51-52	*/
-	MV_U16 fields_valid;							/*	53	*/
-	MV_U16 obsolete5[5];							/*	54-58	*/
-	MV_U16 current_multiple_sector_setting;			/*	59	*/
-	MV_U16 user_addressable_sectors[2];				/*	60-61	*/
-	MV_U16 atapi_dmadir;							/*	62	*/
-	MV_U16 multiword_dma_modes;						/*	63	*/
-	MV_U16 pio_modes;								/*	64	*/
-	MV_U16 minimum_multiword_dma_cycle_time;		/*	65	*/
-	MV_U16 recommended_multiword_dma_cycle_time;	/*	66	*/
-	MV_U16 minimum_pio_cycle_time;					/*	67	*/
-	MV_U16 minimum_pio_cycle_time_iordy;			/*	68	*/
-	MV_U16 reserved2[2];							/*	69-70	*/
-	MV_U16 atapi_reserved[4];						/*	71-74	*/
-	MV_U16 queue_depth;								/*	75	*/
-	MV_U16 sata_capabilities;						/*	76	*/
-	MV_U16 sata_reserved;							/*	77	*/
-	MV_U16 sata_feature_supported;					/*	78	*/
-	MV_U16 sata_feature_enabled;					/*	79	*/
-	MV_U16 major_version;							/*	80	*/
-	MV_U16 minor_version;							/*	81	*/
-	MV_U16 command_set_supported[2];				/*	82-83	*/
-	MV_U16 command_set_supported_extension;			/*	84	*/
-	MV_U16 command_set_enabled[2];					/*	85-86	*/
-	MV_U16 command_set_default;						/*	87	*/
-	MV_U16 udma_modes;								/*	88	*/
-	MV_U16 time_for_security_erase;					/*	89	*/
-	MV_U16 time_for_enhanced_security_erase;		/*	90	*/
-	MV_U16 current_advanced_power_manage_value;		/*	91	*/
-	MV_U16 master_password_revision;				/*	92	*/
-	MV_U16 hardware_reset_result;					/*	93	*/
-	MV_U16 acoustic_manage_value;					/*	94	*/
-	MV_U16 stream_minimum_request_size;				/*	95	*/
-	MV_U16 stream_transfer_time_dma;				/*	96	*/
-	MV_U16 stream_access_latency;					/*	97	*/
-	MV_U16 stream_performance_granularity[2];		/*	98-99	*/
-	MV_U16 max_lba[4];								/*	100-103	*/
-	MV_U16 stream_transfer_time_pio;				/*	104	*/
-	MV_U16 reserved3;								/*	105	*/
-	MV_U16 physical_logical_sector_size;			/*	106	*/
-	MV_U16 delay_acoustic_testing;					/*	107	*/
-	MV_U16 naa;										/*	108	*/
-	MV_U16 unique_id1;								/*	109	*/
-	MV_U16 unique_id2;								/*	110	*/
-	MV_U16 unique_id3;								/*	111	*/
-	MV_U16 reserved4[4];							/*	112-115	*/
-	MV_U16 reserved5;								/*	116	*/
-	MV_U16 words_per_logical_sector[2];				/*	117-118	*/
-	MV_U16 reserved6[8];							/*	119-126	*/
-	MV_U16 removable_media_status_notification;		/*	127	*/
-	MV_U16 security_status;							/*	128	*/
-	MV_U16 vendor_specific[31];						/*	129-159	*/
-	MV_U16 cfa_power_mode;							/*	160	*/
-	MV_U16 reserved7[15];							/*	161-175	*/
-	MV_U16 current_media_serial_number[30];			/*	176-205	*/
-	MV_U16 reserved8[49];							/*	206-254	*/
-	MV_U16 integrity_word;							/*	255	*/
-} ata_identify_data;
-
-#define IDENTIFY_CMD_PACKET_SET_MASK 0x1f00
-#define IDENTIFY_CMD_PACKET_SET_TAPE 0x0100
-#define IDENTIFY_GENERAL_CONFIG_ATAPI MV_BIT(15)
-
-#define ATA_REGISTER_DATA			0x08
-#define ATA_REGISTER_ERROR			0x09
-#define ATA_REGISTER_FEATURES		0x09
-#define ATA_REGISTER_SECTOR_COUNT	0x0A
-#define ATA_REGISTER_LBA_LOW		0x0B
-#define ATA_REGISTER_LBA_MID		0x0C
-#define ATA_REGISTER_LBA_HIGH		0x0D
-#define ATA_REGISTER_DEVICE			0x0E
-#define ATA_REGISTER_STATUS			0x0F
-#define ATA_REGISTER_COMMAND		0x0F
-
-#define ATA_REGISTER_ALT_STATUS		0x16
-#define ATA_REGISTER_DEVICE_CONTROL	0x16
-
-#define MAX_MODE_PAGE_LENGTH            66
-#define MAX_MODE_LOG_LENGTH             404
-
-/*
- * ======================================================================
- * SATA definition
- * ======================================================================
- */
-
-#define FIS_REG_H2D_SIZE_IN_DWORD	5
-
-#define RX_FIS_DMA_REG	0x00
-#define RX_FIS_PIO_REG	0x20
-#define RX_FIS_RES_REG	0x34
-#define RX_FIS_D2H_REG	0x40
-#define RX_FIS_SDB_REG	0x58
-#define RX_FIS_UNK_REG	0x60
-
-
-/* offset for SATA FIS areas */
-#define SATA_RECEIVED_DMA_FIS(root, reg_set)  (root->unassoc_fis_offset + \
-						0x100 * reg_set + RX_FIS_DMA_REG)
-#define SATA_RECEIVED_PIO_FIS(root, reg_set)  (root->unassoc_fis_offset + \
-						0x100 * reg_set + RX_FIS_PIO_REG)
-#define SATA_RECEIVED_D2H_FIS(root, reg_set)  (root->unassoc_fis_offset + \
-						0x100 * reg_set + RX_FIS_D2H_REG)
-#define SATA_RECEIVED_SDB_FIS(root, reg_set)  (root->unassoc_fis_offset + \
-						0x100 * reg_set + RX_FIS_SDB_REG)
-
-#define SATA_UNASSOC_D2H_FIS(phy)	(0x100 * phy->asic_id)
-
-/* FIS type definition */
-#define SATA_FIS_TYPE_REG_H2D			0x27	/* Register FIS - Host to Device */
-#define SATA_FIS_TYPE_REG_D2H			0x34	/* Register FIS - Device to Host */
-
-#define SATA_FIS_TYPE_DMA_ACTIVATE		0x39	/* DMA Activate FIS - Device to Host */
-#define SATA_FIS_TYPE_DMA_SETUP			0x41	/* DMA Setup FIS - Bi-directional */
-
-#define SATA_FIS_TYPE_DATA				0x46	/* Data FIS - Bi-directional */
-#define SATA_FIS_TYPE_BIST_ACTIVATE		0x58	/* BIST Activate FIS - Bi-directional */
-#define SATA_FIS_TYPE_PIO_SETUP			0x5F	/* PIO Setup FIS - Device to Host */
-#define SATA_FIS_TYPE_SET_DEVICE_BITS	0xA1	/* Set Device Bits FIS - Device to Host */
-
-#define H2D_COMMAND_SET_FLAG 0x80
-
-/* SATA FIS: Register-Host to Device*/
-typedef struct _sata_fis_reg_h2d
-{
-	MV_U8	fis_type;
-	MV_U8	cmd_pm;
-	MV_U8	command;
-	MV_U8	features;
-
-	MV_U8	lba_low;
-	MV_U8	lba_mid;
-	MV_U8	lba_high;
-	MV_U8	device;
-
-	MV_U8	lba_low_exp;
-	MV_U8	lba_mid_exp;
-	MV_U8	lba_high_exp;
-	MV_U8	features_exp;
-
-	MV_U8	sector_count;
-	MV_U8	sector_count_exp;
-	MV_U8	ICC;				/*ICC (SATA 3.0) - Isochronous Command Completion (ICC)
-							 * contains a value is set by the host to inform device of a time limit.
-							 * If a command does not define the use of this field, it shall be reserved.*/
-	MV_U8	control;
-	MV_U8	reserved2[4];
-
-} sata_fis_reg_h2d;
-
-typedef struct _sata_fis_reg_d2h
-{
-	MV_U8 fis_type;
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-	MV_U8	reserved0 : 1;
-	MV_U8	interrupt : 1;
-	MV_U8	reserved1 : 2;
-	MV_U8	pm_port : 4;
-#else
-	MV_U8	pm_port : 4;
-	MV_U8	reserved1 : 2;
-	MV_U8	interrupt : 1;
-	MV_U8	reserved0 : 1;
-#endif /* __MV_BIG_ENDIAN_BITFIELD__ */
-	MV_U8	status;
-	MV_U8	error;
-
-	MV_U8	lba_low;
-	MV_U8	lba_mid;
-	MV_U8	lba_high;
-	MV_U8	device;
-
-	MV_U8	lba_low_exp;
-	MV_U8	lba_mid_exp;
-	MV_U8	lba_high_exp;
-	MV_U8	reserved2;
-
-	MV_U8	sector_count;
-	MV_U8	sector_count_exp;
-	MV_U8	reserved3[2];
-
-	MV_U8	reserved4[4];
-} sata_fis_reg_d2h;
-
-#define NO_REGISTER_SET			0xFF
-
-enum _ata_err_byte {
-        ATA_ERR_ICRC    = MV_BIT(7),
-        ATA_ERR_UNC     = MV_BIT(6),
-        ATA_ERR_MC      = MV_BIT(5),
-        ATA_ERR_IDNF    = MV_BIT(4),
-        ATA_ERR_MCR     = MV_BIT(3),
-        ATA_ERR_ABRT    = MV_BIT(2),
-        ATA_ERR_NM      = MV_BIT(1),
-        ATA_ERR_MED     = MV_BIT(0),
-};
-
-enum _ata_status_byte {
-        ATA_STATUS_BSY  = MV_BIT(7),
-        ATA_STATUS_DRDY = MV_BIT(6),
-        ATA_STATUS_DF   = MV_BIT(5),
-        ATA_STATUS_DRQ  = MV_BIT(3),
-        ATA_STATUS_ERR  = MV_BIT(0),
-};
-
-enum _ata_self_test_code {
-        DEFAULT_SELF_TEST                       = 0x0,
-        BACKGROUND_SHORT_SELF_TEST              = 0x1,
-        BACKGROUND_EXTENDED_SELF_TEST           = 0x2,
-        ABORT_BACKGROUND_SELF_TEST              = 0x4,
-        FOREGROUND_SHORT_SELF_TEST              = 0x5,
-        FOREGROUND_EXTENDED_SELF_TEST           = 0x6,
-};
-
-enum _ata_passthru_protocol {
-        ATA_PROTOCOL_HARD_RESET                 = 0x00,
-        ATA_PROTOCOL_SRST                       = 0x01,
-        ATA_PROTOCOL_NON_DATA                   = 0x03,
-        ATA_PROTOCOL_PIO_IN                     = 0x04,
-        ATA_PROTOCOL_PIO_OUT                    = 0x05,
-        ATA_PROTOCOL_DMA                        = 0x06,
-        ATA_PROTOCOL_DMA_QUEUED                 = 0x07,
-        ATA_PROTOCOL_DEVICE_DIAG                = 0x08,
-        ATA_PROTOCOL_DEVICE_RESET               = 0x09,
-        ATA_PROTOCOL_UDMA_IN                    = 0x0A,
-        ATA_PROTOCOL_UDMA_OUT                   = 0x0B,
-        ATA_PROTOCOL_FPDMA                      = 0x0C,
-        ATA_PROTOCOL_RTN_INFO                   = 0x0F,
-};
-
-#endif /* __CORE_SATA_H */
--- a/drivers/scsi/vanir/core/sata_base/sata_error.c
+++ /dev/null
@@ -1,1474 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "core_manager.h"
-#include "core_sat.h"
-#include "core_error.h"
-#include "core_util.h"
-#include "core_sata.h"
-
-#define IS_READ_LOG_EXT_REQ(req) \
-	((req->Cdb[0]==SCSI_CMD_MARVELL_SPECIFIC)&& \
-	 (req->Cdb[1]==CDB_CORE_MODULE)&& \
-	 (req->Cdb[2]==CDB_CORE_READ_LOG_EXT))
-
-static MV_BOOLEAN sata_timeout_state_machine(pl_root *root,
-        domain_device *dev, MV_BOOLEAN success);
-static MV_BOOLEAN sata_media_error_state_machine(pl_root *root,
-	domain_device *dev, MV_BOOLEAN success);
-static void sata_error_handling_callback(pl_root *root, MV_Request *req);
-static void pm_error_handling_callback(pl_root *root, MV_Request *req);
-extern MV_Request *sata_make_soft_reset_req(domain_port *port,
-	domain_device *device, MV_BOOLEAN srst, MV_BOOLEAN is_port_reset,
-	MV_PVOID callback);
-extern MV_Request *stp_make_phy_reset_req(domain_device *device, MV_U8 operation,
-	MV_PVOID callback);
-MV_VOID sata_wait_hard_reset(MV_PVOID dev_p, MV_PVOID req_p);
-MV_VOID pm_eh_wait(MV_PVOID dev_p, MV_PVOID tmp);
-
-MV_Request *stp_make_report_phy_sata_req(domain_device *dev, MV_PVOID callback);
-
-static MV_BOOLEAN atapi_media_error_state_machine(pl_root *root,
-        domain_device *dev, MV_BOOLEAN success);
-static MV_Request *atapi_make_request_sense_req(domain_device *device,
-	MV_ReqCompletion func);
-
-/*
- * two cases will call this function
- * 1. sata_error_handler: original error request comes here.
- * 2. sata_error_handling_callback:
- *    a. it's the error handling(eh) request either success or fail
- *    b. retried req will come here only if fails.
- *       if success, sata_error_handling_callback has returned it.
- */
-static MV_BOOLEAN sata_timeout_state_machine(pl_root *root,
-	domain_device *dev, MV_BOOLEAN success)
-{
-	struct _error_context *err_ctx = &dev->base.err_ctx;
-	domain_port *port = (domain_port *)dev->base.port;
-	domain_phy *phy = NULL;
-	domain_expander *tmp_exp;
-	MV_Request *eh_req = NULL;
-	MV_Request *org_req = err_ctx->error_req;
-	MV_U8 i;
-	MV_U32 reg;
-
-	MV_ASSERT(err_ctx->eh_type == EH_TYPE_TIMEOUT);
-	MV_ASSERT(err_ctx->error_req != NULL);
-
-	CORE_EH_PRINT(("device %d state %d success=0x%x\n",\
-		dev->base.id, err_ctx->eh_state, success));
-
-	switch (err_ctx->eh_state) {
-	case SATA_EH_TIMEOUT_STATE_NONE:
-		err_ctx->timeout_count++;
-
-		if ((((core_extension *)(root->core))->revision_id != VANIR_C2_REV)
-			&& (IS_STP(dev))) {
-			pal_abort_port_running_req(root, port);
-
-			core_sleep_millisecond(root->core, 10);
-
-			for (i = 0; i < dev->base.root->phy_num; i++) {
-				if (dev->base.root->phy[i].port == port) {
-					phy = &(dev->base.root->phy[i]);
-
-					phy->phy_irq_mask &= ~(IRQ_PHY_RDY_CHNG_MASK | IRQ_PHY_RDY_CHNG_1_TO_0);
-					WRITE_PORT_IRQ_MASK(root, phy, phy->phy_irq_mask);
-
-					core_sleep_millisecond(root->core, 10);
-
-					reg = READ_PORT_PHY_CONTROL(root, phy);
-					reg |= (SCTRL_STP_LINK_LAYER_RESET | SCTRL_SSP_LINK_LAYER_RESET);
-					WRITE_PORT_PHY_CONTROL(root,
-						phy,
-						reg);
-
-					core_sleep_millisecond(root->core, 50);
-
-					WRITE_PORT_IRQ_STAT(root, phy, \
-						(IRQ_PHY_RDY_CHNG_MASK | IRQ_PHY_RDY_CHNG_1_TO_0));
-
-					phy->phy_irq_mask |= (IRQ_PHY_RDY_CHNG_MASK | IRQ_PHY_RDY_CHNG_1_TO_0);
-					WRITE_PORT_IRQ_MASK(root, phy, phy->phy_irq_mask);
-				}
-			}
-
-			core_sleep_millisecond(root->core, 50);
-
-			LIST_FOR_EACH_ENTRY_TYPE(tmp_exp, &port->expander_list,
-			  domain_expander, base.queue_pointer) {
-				pal_clean_expander_outstanding_req(root, tmp_exp);
-			}
-		}
-		else {
-			pal_abort_device_running_req(root, &dev->base);
-		}
-
-		if (IS_STP(dev)) {
-			eh_req = stp_make_phy_reset_req(dev, LINK_RESET,
-				sata_error_handling_callback);
-			if (eh_req == NULL) return MV_FALSE;
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_WAIT;
-			CORE_EH_PRINT(("device %d sending phy control link reset request.\n",\
-				dev->base.id));
-		} else {
-			eh_req = sata_make_soft_reset_req(
-				port, dev, MV_TRUE, MV_FALSE, sata_error_handling_callback);
-			if (eh_req == NULL) return MV_FALSE;
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_1;
-			CORE_EH_PRINT(("device %d sending soft reset(1) request.\n",\
-				dev->base.id));
-		}
-		break;
-
-	case SATA_EH_TIMEOUT_STATE_SOFT_RESET_1:
-		eh_req = sata_make_soft_reset_req(
-			port, dev, MV_FALSE, MV_FALSE, sata_error_handling_callback);
-		if (eh_req == NULL) {
-			return MV_FALSE;
-		}
-		err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_WAIT;
-		CORE_EH_PRINT(("device %d sending soft reset(0) request.\n",\
-			dev->base.id));
-		break;
-
-    case SATA_EH_TIMEOUT_STATE_SOFT_RESET_WAIT:
-		if (success == MV_TRUE) {
-			CORE_EH_PRINT(("device %d waiting after soft reset.\n", dev->base.id));
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_0;
-			MV_ASSERT(err_ctx->eh_timer == NO_CURRENT_TIMER);
-			err_ctx->eh_timer = core_add_timer(root->core, 10, sata_wait_hard_reset, dev, NULL);
-			MV_ASSERT(err_ctx->eh_timer != NO_CURRENT_TIMER);
-			return MV_TRUE;
-		} else {
-			/* If reset command self failed, not add delay and go to
-			  * below retry flow, but go to higher level error handling
-			  * directly.*/
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_0;
-		}
-
-	case SATA_EH_TIMEOUT_STATE_SOFT_RESET_0:
-		/* case
-		 * a. soft reset request comes back, either fail or success
-		 * b. retried req which failed, (if success,
-		 *    won't come here because it's finished). */
-		if (success == MV_TRUE) {
-			/* error handling req success, retry original req */
-			eh_req = core_eh_retry_org_req(
-				root, org_req,
-				(MV_ReqCompletion)sata_error_handling_callback);
-			if (eh_req == NULL) {
-				return MV_FALSE;
-			}
-		}
-		else {
-			if (IS_STP(dev)) {
-				eh_req = stp_make_phy_reset_req(dev, HARD_RESET,
-					sata_error_handling_callback);
-				if (eh_req == NULL) {
-					return MV_FALSE;
-				}
-				CORE_EH_PRINT(("device %d sending phy control hard reset request.\n",\
-					dev->base.id));
-				err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_HARD_RESET_WAIT;
-			}
-			else {
-				eh_req = core_make_port_reset_req(root, port, dev,
-					(MV_ReqCompletion)sata_error_handling_callback);
-				if (eh_req == NULL) {
-					return MV_FALSE;
-				}
-				CORE_EH_PRINT(("device %d sending hard reset request.\n",\
-					dev->base.id));
-				err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_HARD_RESET_WAIT;
-			}
-		}
-		break;
-
-	case SATA_EH_TIMEOUT_STATE_HARD_RESET_WAIT:
-		if (success == MV_TRUE) {
-			CORE_EH_PRINT(("device %d waiting after hard reset.\n", dev->base.id));
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_HARD_RESET;
-			MV_ASSERT(err_ctx->eh_timer == NO_CURRENT_TIMER);
-			err_ctx->eh_timer = core_add_timer(root->core, 10, sata_wait_hard_reset, dev, NULL);
-			MV_ASSERT(err_ctx->eh_timer != NO_CURRENT_TIMER);
-			return MV_TRUE;
-		} else {
-			/* If reset command self failed, not add delay and go to
-			 * below retry flow, but go to higher level error handling
-			 * directly.*/
-		err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_HARD_RESET;
-        }
-
-	case SATA_EH_TIMEOUT_STATE_HARD_RESET:
-		/* case =
-		 * a. hard reset request comes back
-		 * b. retried req which is failed. (if success, won't come to state machine)
-		 * c. if time count>MAX_TIMEOUT_ALLOWED, may jump to this step to set down */
-		if (success == MV_TRUE) {
-			/* error handling req success, retry original req */
-			eh_req = core_eh_retry_org_req(
-				root, org_req,
-				(MV_ReqCompletion)sata_error_handling_callback);
-			if (eh_req == NULL) {
-				return MV_FALSE;
-			}
-			break;
-		}
-		else {
-			CORE_EH_PRINT(("device %d: complete req with ERROR\n",dev->base.id));
-			dev->status |= DEVICE_STATUS_FROZEN;
-			core_complete_error_req(root, org_req, REQ_STATUS_ERROR);
-
-			return MV_TRUE;
-		}
-
-	default:
-		MV_ASSERT(MV_FALSE);
-	}
-
-	MV_ASSERT(eh_req != NULL);
-	core_queue_eh_req(root,eh_req);
-	return MV_TRUE;
-}
-
-extern MV_Request *pm_make_pm_register_req(domain_pm *pm, MV_BOOLEAN op,
-	MV_BOOLEAN is_control, MV_U8 pm_port, MV_U8 reg_num, MV_U32 reg_value,
-	MV_PVOID callback);
-
-MV_BOOLEAN pm_eh_make_init_ports_reqs(
-	pl_root *root,
-	domain_pm *pm,
-	MV_Request *last_eh_req,
-	MV_BOOLEAN reset_device,
-	MV_PVOID callback)
-{
-	struct _error_context *pm_err_ctx = &pm->base.err_ctx;
-	domain_port *port = (domain_port *)pm->base.port;
-	MV_Request *eh_req = NULL;
-	MV_Request *org_req = pm_err_ctx->error_req;
-	MV_U32 tmp = 0;
-	MV_U8 i;
-	saved_fis *fis;
-	MV_U32 fis1, fis2;
-	core_context *ctx = NULL;
-	MV_BOOLEAN ret = MV_FALSE;
-
-	if (pm_err_ctx->eh_state == PM_EH_STATE_NONE) {
-		if (!reset_device) {
-			pm_err_ctx->pm_eh_active_port = 0;
-			pm_err_ctx->eh_state = PM_EH_QRIGA_WORKAROUND;
-		}
-		else {
-			pm_err_ctx->pm_eh_active_port = pm_err_ctx->pm_eh_error_port;
-			pm_err_ctx->eh_state = PM_EH_DISABLE_ASYNOTIFY;
-		}
-	}
-
-	switch (pm_err_ctx->eh_state) {
-	case PM_EH_STATE_NONE:
-	case PM_EH_HARD_RESET_DONE:
-	case PM_EH_QRIGA_WORKAROUND:
-		eh_req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0, 0x9B,
-			0xF0, callback);
-		pm_err_ctx->eh_state = PM_EH_ENABLE_FEATURES;
-		break;
-
-	case PM_EH_ENABLE_FEATURES:
-	case PM_EH_DISABLE_ASYNOTIFY:
-		eh_req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0,
-			PM_GSCR_FEATURES_ENABLE, pm->feature_enabled & (~MV_BIT(3)),
-			callback);
-		if (!reset_device) {
-			pm_err_ctx->eh_state = PM_EH_CLEAR_ERROR_INFO;
-		}
-		else {
-			pm_err_ctx->eh_state = PM_EH_ENABLE_PM_PORT_1;
-		}
-		break;
-
-	case PM_EH_CLEAR_ERROR_INFO:
-		tmp = MV_BIT(16) | MV_BIT(26);
-		eh_req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0,
-			PM_GSCR_ERROR_ENABLE, tmp, callback);
-		pm_err_ctx->eh_state = PM_EH_SPIN_UP_ALL_PORTS;
-		break;
-
-	case PM_EH_SPIN_UP_ALL_PORTS:
-	case PM_EH_ENABLE_PM_PORT_1:
-		eh_req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_FALSE, pm_err_ctx->pm_eh_active_port,
-			PM_PSCR_SCONTROL, 0x01, callback);
-		if (!reset_device) {
-			pm_err_ctx->pm_eh_active_port++;
-			if (pm_err_ctx->pm_eh_active_port == pm->num_ports) {
-				pm_err_ctx->pm_eh_active_port = 0;
-				pm_err_ctx->eh_state = PM_EH_SPIN_UP_DONE;
-			}
-		}
-		else {
-			pm_err_ctx->eh_state = PM_EH_ENABLE_PM_PORT_0;
-		}
-		break;
-
-	case PM_EH_SPIN_UP_DONE:
-	case PM_EH_ENABLE_PM_PORT_0:
-		eh_req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_FALSE, pm_err_ctx->pm_eh_active_port,
-			PM_PSCR_SCONTROL, 0x00, callback);
-		if (!reset_device) {
-			pm_err_ctx->pm_eh_active_port++;
-			if (pm_err_ctx->pm_eh_active_port == pm->num_ports) {
-				pm_err_ctx->pm_eh_active_port = 0;
-				pm_err_ctx->eh_state = PM_EH_SPIN_UP_WAIT;
-			}
-		}
-		else {
-			pm_err_ctx->eh_state = PM_EH_SPIN_UP_WAIT;
-		}
-		break;
-
-	case PM_EH_SPIN_UP_WAIT:
-		CORE_EH_PRINT(("Waiting after pm hard reset phys.\n"));
-		pm_err_ctx->eh_state = PM_EH_CHECK_PHY_RDY;
-		MV_ASSERT(pm_err_ctx->eh_timer == NO_CURRENT_TIMER);
-		pm_err_ctx->eh_timer = core_add_timer(root->core, 5, pm_eh_wait, pm, NULL);
-		MV_ASSERT(pm_err_ctx->eh_timer != NO_CURRENT_TIMER);
-		return MV_TRUE;
-
-	case PM_EH_CHECK_PHY_RDY:
-		eh_req = pm_make_pm_register_req(pm, PM_OP_READ, MV_FALSE, pm_err_ctx->pm_eh_active_port,
-			PM_PSCR_SSTATUS, 0, callback);
-		pm_err_ctx->eh_state = PM_EH_CHECK_PHY_RDY_DONE;
-		break;
-
-	case PM_EH_CHECK_PHY_RDY_DONE:
-
-		MV_ASSERT(last_eh_req != NULL);
-		ctx = (core_context *)last_eh_req->Context[MODULE_CORE];
-		fis = (saved_fis *)ctx->received_fis;
-		if (fis == NULL) MV_ASSERT(MV_FALSE);
-		fis1 = fis->dw4;
-		fis2 = fis->dw2;
-
-		pm->sstatus = ((MV_U8)fis1) | (((MV_U8)fis2) << 8);
-		pm->base.port->phy->sata_signature = 0xFFFFFFFF;
-
-		if ((pm->sstatus & 0x00F) != 0x003) {
-			if (!reset_device) {
-				/* 1. Set down this disk if there is one, and not EH disk. Phy is gone. */
-				if (pm_err_ctx->pm_eh_active_port != pm_err_ctx->pm_eh_error_port) {
-					if (pm->devices[pm_err_ctx->pm_eh_active_port]) {
-						pal_set_down_disk(pm->base.root,
-							pm->devices[pm_err_ctx->pm_eh_active_port],
-							MV_TRUE);
-
-					}
-				}
-
-				/* 2. Move to next port. */
-				pm_err_ctx->pm_eh_active_port++;
-				if (pm_err_ctx->pm_eh_active_port >= pm->num_ports) {
-					pm_err_ctx->pm_eh_active_port = 0xff;
-					pm_err_ctx->eh_state = PM_EH_DONE;
-				} else {
-					pm_err_ctx->eh_state = PM_EH_CHECK_PHY_RDY;
-				}
-			}
-			else {
-				pm_err_ctx->eh_state = PM_EH_DONE;
-			}
-			return MV_FALSE;
-		}
-		pm_err_ctx->eh_state = PM_EH_CLEAR_X_BIT;
-
-	case PM_EH_CLEAR_X_BIT:
-		eh_req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_FALSE, pm_err_ctx->pm_eh_active_port,
-			PM_PSCR_SERROR, 0xFFFFFFFF, callback);
-		pm_err_ctx->eh_state = PM_EH_ISSUE_SOFT_RESET_1;
-		break;
-
-	case PM_EH_ISSUE_SOFT_RESET_1:
-		eh_req = sata_make_soft_reset_req(pm->base.port,
-			pm->devices[pm_err_ctx->pm_eh_active_port], MV_TRUE, MV_FALSE,
-			callback);
-		pm_err_ctx->eh_state = PM_EH_ISSUE_SOFT_RESET_0;
-		break;
-
-	case PM_EH_ISSUE_SOFT_RESET_0:
-		core_sleep_millisecond(root->core, 50);
-		eh_req = sata_make_soft_reset_req(pm->base.port,
-			pm->devices[pm_err_ctx->pm_eh_active_port], MV_FALSE, MV_FALSE,
-			callback);
-		pm_err_ctx->eh_state = PM_EH_WAIT_SIG;
-		break;
-
-	case PM_EH_WAIT_SIG:
-		pm_err_ctx->eh_state = PM_EH_SIG_DONE;
-
-	case PM_EH_SIG_DONE:
-		if (!reset_device) {
-			pm_err_ctx->pm_eh_active_port++;
-			if (pm_err_ctx->pm_eh_active_port >= pm->num_ports) {
-				pm_err_ctx->pm_eh_active_port = 0xff;
-				pm_err_ctx->eh_state = PM_EH_WAIT_AFTER_RESET;
-			} else {
-				pm_err_ctx->eh_state = PM_EH_CHECK_PHY_RDY;
-			}
-		}
-		else {
-			pm_err_ctx->eh_state = PM_EH_WAIT_AFTER_RESET;
-		}
-		return MV_FALSE;
-
-	case PM_EH_WAIT_AFTER_RESET:
-		CORE_EH_PRINT(("Waiting after pm soft reset phys.\n"));
-		pm_err_ctx->eh_state = PM_EH_ENABLE_ASYNOTIFY;
-		MV_ASSERT(pm_err_ctx->eh_timer == NO_CURRENT_TIMER);
-		pm_err_ctx->eh_timer = core_add_timer(root->core, 5, pm_eh_wait, pm, NULL);
-		MV_ASSERT(pm_err_ctx->eh_timer != NO_CURRENT_TIMER);
-		return MV_TRUE;
-
-	case PM_EH_ENABLE_ASYNOTIFY:
-		eh_req = pm_make_pm_register_req(pm, PM_OP_WRITE, MV_TRUE, 0,
-			PM_GSCR_FEATURES_ENABLE, pm->feature_enabled | MV_BIT(3),
-			callback);
-		pm_err_ctx->eh_state = PM_EH_ENABLE_ASYNOTIFY_WAIT;
-		break;
-
-	case PM_EH_ENABLE_ASYNOTIFY_WAIT:
-		CORE_EH_PRINT(("Waiting after enable asynchronous notification.\n"));
-		pm_err_ctx->eh_state = PM_EH_DONE;
-		MV_ASSERT(pm_err_ctx->eh_timer == NO_CURRENT_TIMER);
-		pm_err_ctx->eh_timer = core_add_timer(root->core, 5, pm_eh_wait, pm, NULL);
-		MV_ASSERT(pm_err_ctx->eh_timer != NO_CURRENT_TIMER);
-		return MV_TRUE;
-
-	case PM_EH_DONE:
-		return MV_FALSE;
-	default:
-		MV_ASSERT(MV_FALSE);
-	}
-
-	MV_ASSERT(eh_req != NULL);
-	core_queue_eh_req(root,eh_req);
-	return MV_TRUE;
-}
-
-extern void pal_set_down_pm(pl_root *root, domain_pm *pm, MV_BOOLEAN notify_os);
-
-static MV_BOOLEAN
-sata_timeout_state_machine_behind_pm(
-	pl_root *root,
-	MV_PVOID dev_p,
-	MV_BOOLEAN success,
-	MV_Request *last_eh_req)
-{
-	domain_base *base = (domain_base *) dev_p;
-	domain_device *dev = NULL;
-	domain_pm *pm = NULL;
-	struct _error_context *err_ctx = NULL;
-	struct _error_context *pm_err_ctx = NULL;
-	domain_port *port = (domain_port *)base->port;
-	MV_Request *eh_req = NULL;
-	MV_Request *org_req = NULL;
-	MV_U8 i;
-	MV_U8 pm_port = 0xFF;
-	MV_BOOLEAN pm_eh_return;
-
-	switch (base->type) {
-	case BASE_TYPE_DOMAIN_PM:
-		pm = (domain_pm *) dev_p;
-		pm_err_ctx = &pm->base.err_ctx;
-		pm_port = pm_err_ctx->pm_eh_error_port;
-		dev = pm->devices[pm_port];
-		err_ctx = &dev->base.err_ctx;
-
-		break;
-
-	case BASE_TYPE_DOMAIN_DEVICE:
-		dev = (domain_device *) dev_p;
-		err_ctx = &dev->base.err_ctx;
-		pm = dev->pm;
-		pm_port = dev->pm_port;
-		pm_err_ctx = &pm->base.err_ctx;
-
-		break;
-
-	default:
-		MV_ASSERT(MV_FALSE);
-	}
-	org_req = err_ctx->error_req;
-
-	CORE_EH_PRINT(("device %d state %d, pm %d state %d success=0x%x\n",\
-		dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state,\
-		success));
-
-	switch (err_ctx->eh_state) {
-	case SATA_EH_TIMEOUT_STATE_NONE:
-
-		/* case =
-		 * a. original error request
-		 * b. media error state machine got timeout */
-		err_ctx->timeout_count++;
-		MV_ASSERT(pm_err_ctx->eh_state == PM_EH_STATE_NONE);
-		MV_ASSERT(pm_err_ctx->state == BASE_STATE_NONE);
-		MV_ASSERT(pm_err_ctx->error_req == NULL);
-		MV_ASSERT(pm_err_ctx->eh_type == EH_TYPE_NONE);
-		pm_err_ctx->state = BASE_STATE_ERROR_HANDLING;
-		pm_err_ctx->pm_eh_error_port = pm_port;
-		pm_err_ctx->pm_eh_active_port = 0;
-		pm_err_ctx->timeout_count++;
-		pm_err_ctx->error_req = org_req;
-		pm_err_ctx->eh_type = EH_TYPE_TIMEOUT;
-		pm_err_ctx->eh_state = PM_EH_STATE_NONE;
-
-		pal_abort_device_running_req(root, &dev->base);
-		eh_req = sata_make_soft_reset_req(
-			port, dev, MV_TRUE, MV_FALSE, pm_error_handling_callback);
-		if (eh_req == NULL) {
-			return MV_FALSE;
-		}
-		err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_1;
-		CORE_EH_PRINT(("device %d state %d, pm %d state %d sending soft reset(1) request to device.\n",\
-			dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-
-		break;
-	case SATA_EH_TIMEOUT_STATE_SOFT_RESET_1:
-		eh_req = sata_make_soft_reset_req(
-			port, dev, MV_FALSE, MV_FALSE, pm_error_handling_callback);
-		if (eh_req == NULL) {
-			return MV_FALSE;
-		}
-		err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_WAIT;
-		CORE_EH_PRINT(("device %d state %d, pm %d state %d sending soft reset(0) request to device.\n",\
-			dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-		break;
-
-	case SATA_EH_TIMEOUT_STATE_SOFT_RESET_WAIT:
-		if (success == MV_TRUE) {
-			CORE_EH_PRINT(("device %d state %d, pm %d state %d waiting after device soft reset.\n",\
-				dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_0;
-			MV_ASSERT(err_ctx->eh_timer == NO_CURRENT_TIMER);
-			err_ctx->eh_timer = core_add_timer(root->core, 5, sata_wait_hard_reset, dev, NULL);
-			MV_ASSERT(err_ctx->eh_timer != NO_CURRENT_TIMER);
-			return MV_TRUE;
-		} else {
-			/* If reset command self failed, do not add delay and go to
-			 * next state and directly do hard reset.*/
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SOFT_RESET_0;
-		}
-
-	case SATA_EH_TIMEOUT_STATE_SOFT_RESET_0:
-		/* case
-		 * a. soft reset request comes back, either fail or success
-		 * b. retried req which failed, (if success,
-		 *    won't come here because it's finished). */
-		if (success == MV_TRUE) {
-			/* error handling req success, retry original req */
-			eh_req = core_eh_retry_org_req(
-				root, org_req,
-				(MV_ReqCompletion)pm_error_handling_callback);
-			if (eh_req == NULL) {
-				return MV_FALSE;
-			}
-
-			break;
-		}
-		else {
-			/* Continue with Device Hard Reset.*/
-			success = MV_TRUE;
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_DEV_HARD_RESET;
-		}
-	case SATA_EH_TIMEOUT_STATE_DEV_HARD_RESET:
-		if (success == MV_TRUE) {
-			/* Reset Device behind PM, issue requests to PM.*/
-			pm_eh_return = pm_eh_make_init_ports_reqs(
-				root, pm, last_eh_req, MV_TRUE, pm_error_handling_callback);
-			if (pm_err_ctx->eh_state == PM_EH_DONE) {
-				pm_err_ctx->eh_state = PM_EH_STATE_NONE;
-				err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_DEV_HARD_RESET_DONE;
-			}
-			return pm_eh_return;
-		}
-		else {
-		/* Reset Device behind PM failed */
-			pm_err_ctx->eh_state = PM_EH_STATE_NONE;
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_DEV_HARD_RESET_DONE;
-		}
-
-	case SATA_EH_TIMEOUT_STATE_DEV_HARD_RESET_DONE:
-		if (success == MV_TRUE) {
-			/* error handling req success, retry original req */
-			eh_req = core_eh_retry_org_req(
-				root, org_req,
-				(MV_ReqCompletion)pm_error_handling_callback);
-			if (eh_req == NULL) {
-				return MV_FALSE;
-			}
-		}
-		/* Hard reset the PM
-		 * if Soft Reset fails or Retry request fails */
-		else {
-			pal_abort_port_running_req(root, port);
-			core_sleep_millisecond(root->core, 10);
-
-			eh_req = core_make_port_reset_req(root, port, pm,
-				(MV_ReqCompletion)pm_error_handling_callback);
-			if (eh_req == NULL) {
-				return MV_FALSE;
-			}
-			CORE_EH_PRINT(("device %d state %d, pm %d state %d sending OOB reset request to pm.\n",\
-				dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_PM_RESET_WAIT;
-		}
-		break;
-
-	case SATA_EH_TIMEOUT_STATE_PM_RESET_WAIT:
-		if (success == MV_TRUE) {
-			CORE_EH_PRINT(("device %d state %d, pm %d state %d waiting after pm hard reset.\n",\
-				dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_PM_SRST_1;
-			MV_ASSERT(err_ctx->eh_timer == NO_CURRENT_TIMER);
-			/* Don't need to wait a long time here,
-			 * wait is needed after enabling async notification
-			 */
-			err_ctx->eh_timer = core_add_timer(root->core, 2, sata_wait_hard_reset, dev, NULL);
-			MV_ASSERT(err_ctx->eh_timer != NO_CURRENT_TIMER);
-			return MV_TRUE;
-		}
-		else {
-			/* If reset command self failed, do not add delay and go to
-			 * below retry to try reinit PM.*/
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_PM_SRST_1;
-		}
-
-	case SATA_EH_TIMEOUT_STATE_PM_SRST_1:
-		eh_req = sata_make_soft_reset_req(port, NULL, MV_TRUE, MV_TRUE,
-			pm_error_handling_callback);
-		if (eh_req == NULL) {
-			return MV_FALSE;
-		}
-		err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_PM_SRST_0;
-		CORE_EH_PRINT(("device %d state %d, pm %d state %d sending soft reset(1) request to pm.\n",\
-			dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-		break;
-
-	case SATA_EH_TIMEOUT_STATE_PM_SRST_0:
-		eh_req = sata_make_soft_reset_req(port, NULL, MV_FALSE, MV_TRUE,
-			pm_error_handling_callback);
-		if (eh_req == NULL) {
-			return MV_FALSE;
-		}
-		err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_PM_SRST_WAIT;
-		CORE_EH_PRINT(("device %d state %d, pm %d state %d sending soft reset(0) request to pm.\n",\
-			dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-		break;
-
-	case SATA_EH_TIMEOUT_STATE_PM_SRST_WAIT:
-		if (success == MV_TRUE) {
-			CORE_EH_PRINT(("device %d state %d, pm %d state %d waiting after pm soft reset.\n",\
-				dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_PM_REINIT;
-			MV_ASSERT(err_ctx->eh_timer == NO_CURRENT_TIMER);
-			/* Don't need to wait a long time here,
-			 * wait is needed after enabling async notification
-			 */
-			err_ctx->eh_timer = core_add_timer(root->core, 2, sata_wait_hard_reset, dev, NULL);
-			MV_ASSERT(err_ctx->eh_timer != NO_CURRENT_TIMER);
-			return MV_TRUE;
-		}
-		else {
-			/* If reset command self failed, not add delay and go to
-			 * below retry flow, but go to higher level error handling
-			 * directly.*/
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_PM_REINIT;
-        }
-
-	case SATA_EH_TIMEOUT_STATE_PM_REINIT:
-		if (success == MV_TRUE) {
-			pm_eh_return = pm_eh_make_init_ports_reqs(
-				root, pm, last_eh_req, MV_FALSE, pm_error_handling_callback);
-			if (pm_err_ctx->eh_state == PM_EH_DONE) {
-				err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_RETRY_ORG_REQ;
-			}
-			return pm_eh_return;
-		}
-		else {
-			/* PM Reset Failed
-			 * let's set down the PM and Disks. */
-
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SET_DOWN;
-			pm_err_ctx->eh_state = PM_EH_STATE_NONE;
-			pm_err_ctx->eh_type = EH_TYPE_NONE;
-			pm_err_ctx->error_req = NULL;
-			pm_err_ctx->state = BASE_STATE_NONE;
-
-			core_complete_error_req(root, org_req, REQ_STATUS_NO_DEVICE);
-
-			CORE_EH_PRINT(("device %d state %d, pm %d state %d set down pm.\n",\
-				dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-
-			/* set down pm. after that, dont use pm and attached disks any more */
-			pal_set_down_pm(root, pm, MV_TRUE);
-
-			return MV_TRUE;
-		}
-	case SATA_EH_TIMEOUT_STATE_RETRY_ORG_REQ:
-		/* case =
-		 * a. hard reset request comes back
-		 * b. retried req which is failed. (if success, won't come to state machine)
-		 * c. if time count>MAX_TIMEOUT_ALLOWED, may jump to this step to set down */
-		if (success == MV_TRUE) {
-			/* error handling req success, retry original req */
-			eh_req = core_eh_retry_org_req(
-				root, org_req,
-				(MV_ReqCompletion)pm_error_handling_callback);
-			if (eh_req == NULL) {
-				return MV_FALSE;
-			}
-			break;
-		}
-		else {
-
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_SET_DOWN;
-			pm_err_ctx->state = BASE_STATE_NONE;
-			pm_err_ctx->eh_state = PM_EH_STATE_NONE;
-			pm_err_ctx->pm_eh_error_port = 0xff;
-			pm_err_ctx->pm_eh_active_port = 0xff;
-			pm_err_ctx->error_req = NULL;
-			pm_err_ctx->eh_type = EH_TYPE_NONE;
-
-			core_complete_error_req(root, org_req, REQ_STATUS_NO_DEVICE);
-
-			CORE_EH_PRINT(("device %d state %d, pm %d state %d set down disk.\n",\
-				dev->base.id, err_ctx->eh_state, pm->base.id, pm_err_ctx->eh_state));
-
-			/* set down disk. after that, dont use dev any more */
-			pal_set_down_error_disk(root, dev, MV_TRUE);
-
-			return MV_TRUE;
-		}
-
-	default:
-		MV_ASSERT(MV_FALSE);
-	}
-
-	MV_ASSERT(eh_req != NULL);
-	core_queue_eh_req(root,eh_req);
-	return MV_TRUE;
-}
-
-static MV_BOOLEAN
-sata_timeout_error_handler(
-	pl_root *root,
-	domain_device *dev,
-	MV_BOOLEAN success,
-	MV_Request *last_eh_req)
-{
-
-	if (IS_BEHIND_PM(dev)) {
-		return sata_timeout_state_machine_behind_pm(root, dev, success, last_eh_req);
-	}
-	else {
-		return sata_timeout_state_machine(root, dev, success);
-	}
-}
-
-MV_BOOLEAN sata_error_handler(MV_PVOID dev_p, MV_Request *req)
-{
-	domain_device *dev = (domain_device *)dev_p;
-	core_context *ctx = req->Context[MODULE_CORE];
-	pl_root *root = dev->base.root;
-	struct _error_context *err_ctx = &dev->base.err_ctx;
-
-	MV_ASSERT(dev->base.type == BASE_TYPE_DOMAIN_DEVICE);
-
-	CORE_EH_PRINT(("device %d eh_type %d eh_state %d status 0x%x req %p Cdb[0x%x]\n",\
-		dev->base.id, err_ctx->eh_type, err_ctx->eh_state,
-		err_ctx->scsi_status, req, req->Cdb[0]));
-
-	/* process_command can only return five status
-	 * REQ_STATUS_SUCCESS, XXX_HAS_SENSE, XXX_ERROR, XXX_TIMEOUT, XXX_NO_DEVICE */
-	if (err_ctx->eh_type == EH_TYPE_NONE) {
-		MV_ASSERT((req->Scsi_Status == REQ_STATUS_ERROR)
-			|| (req->Scsi_Status == REQ_STATUS_HAS_SENSE)
-			|| (req->Scsi_Status == REQ_STATUS_TIMEOUT));
-		MV_ASSERT((err_ctx->error_req == NULL)
-			|| (err_ctx->error_req == req));
-		err_ctx->error_req = req;
-			err_ctx->scsi_status = req->Scsi_Status;
-
-		if (err_ctx->scsi_status == REQ_STATUS_TIMEOUT) {
-			if (IS_BEHIND_PM(dev)) {
-				domain_pm *pm = dev->pm;
-				struct _error_context *pm_err_ctx = &pm->base.err_ctx;
-
-				/* 1. If PM is doing error handling initiated by different
-				 *    drive do not start error handling on this device.
-				 *    push back the org request to waiting queue.
-				 * 2. Drive already in EH should not come here,
-				 *    eh_type should not be EH_TYPE_NONE
-				 */
-				if (pm_err_ctx->state == BASE_STATE_ERROR_HANDLING) {
-					/* the eh_type in pm_err_ctx describes the pm_port */
-					if (pm_err_ctx->pm_eh_error_port != dev->pm_port) {
-						core_push_running_request_back(root, req);
-						return MV_TRUE;
-					}
-				}
-			}
-
-			err_ctx->eh_type = EH_TYPE_TIMEOUT;
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_NONE;
-			return sata_timeout_error_handler(root, dev, MV_FALSE, NULL);
-		}
-		else {
-			err_ctx->eh_type = EH_TYPE_MEDIA_ERROR;
-			err_ctx->eh_state = SATA_EH_MEDIA_STATE_NONE;
-
-			if (IS_ATAPI(dev)) {
-				return atapi_media_error_state_machine(
-					root, dev, MV_FALSE);
-			}
-			else {
-				return sata_media_error_state_machine(
-					root, dev, MV_FALSE);
-			}
-		}
-	}
-	else {
-		/* code comes here if sata_error_handling_callback
-		 * or pm_error_handling_callback
-		 * cannot continue because short of resource
-		 * no device should be handled already
-		 * but the req is the original error request not eh req
-		 * because the eh req has released already
-		 * the eh req scsi status is saved in err_ctx->scsi_status */
-		MV_ASSERT(req == err_ctx->error_req);
-		MV_ASSERT((err_ctx->scsi_status == REQ_STATUS_ERROR)
-			|| (err_ctx->scsi_status == REQ_STATUS_HAS_SENSE)
-			|| (err_ctx->scsi_status == REQ_STATUS_SUCCESS)
-			|| (err_ctx->scsi_status == REQ_STATUS_TIMEOUT));
-		MV_ASSERT((err_ctx->eh_type == EH_TYPE_MEDIA_ERROR)
-			||(err_ctx->eh_type == EH_TYPE_TIMEOUT));
-
-		if (err_ctx->eh_type == EH_TYPE_TIMEOUT) {
-			return sata_timeout_error_handler(root, dev,
-				(err_ctx->scsi_status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE), NULL);
-		}
-		else {
-			if (IS_ATAPI(dev)) {
-				return atapi_media_error_state_machine(
-					root, dev,
-					(err_ctx->scsi_status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE));
-			}
-			else {
-				return sata_media_error_state_machine(
-					root, dev,
-					(err_ctx->scsi_status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE));
-			}
-		}
-	}
-}
-
-static MV_Request *sata_make_read_log_ext_req(domain_device *device,
-	MV_ReqCompletion func)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req;
-
-	req = get_intl_req_resource(root, SATA_SCRATCH_BUFFER_SIZE);
-	if (req == NULL) {
-		return NULL;
-	}
-
-	req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	req->Cdb[1] = CDB_CORE_MODULE;
-	req->Cdb[2] = CDB_CORE_READ_LOG_EXT;
-
-	req->Device_Id = device->base.id;
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-	req->Completion = func;
-
-	MV_DASSERT(SATA_SCRATCH_BUFFER_SIZE >= sizeof(ata_identify_data));
-	MV_DASSERT(req->Data_Transfer_Length % 2 == 0);
-
-	return req;
-}
-
-/*
- * media error handling state machine:
- * a. if it's NCQ request, send "read log extent" command;
- * b. retry request but always non-NCQ mode;
- * c. if still has error, return the request with error status.
- */
-static MV_BOOLEAN sata_media_error_state_machine(pl_root *root,
-	domain_device *dev, MV_BOOLEAN success)
-{
-	struct _error_context *err_ctx = &(dev->base.err_ctx);
-	domain_port *port = (domain_port *)dev->base.port;
-	MV_Request *eh_req;
-	MV_Request *org_req = err_ctx->error_req;
-
-	MV_ASSERT(err_ctx->eh_type == EH_TYPE_MEDIA_ERROR);
-	MV_ASSERT(org_req != NULL);
-	MV_ASSERT(!IS_ATAPI(dev));
-
-	CORE_EH_PRINT(("device %d state %d success=0x%x\n",\
-		dev->base.id, err_ctx->eh_state, success));
-
-	switch (err_ctx->eh_state) {
-	case SATA_EH_MEDIA_STATE_NONE:
-		MV_ASSERT(success == MV_FALSE);
-		pal_abort_device_running_req(root, &dev->base);
-		if ((org_req->Cmd_Flag&CMD_FLAG_NCQ)
-			&& (dev->capability & DEVICE_CAPABILITY_NCQ_SUPPORTED)) {
-			/* read log ext */
-			eh_req = sata_make_read_log_ext_req(
-					dev, (MV_ReqCompletion)sata_error_handling_callback);
-			if (eh_req == NULL) return MV_FALSE;
-			err_ctx->eh_state =
-				SATA_EH_MEDIA_STATE_READ_LOG_EXTENT;
-			break;
-		}
-	case SATA_EH_MEDIA_STATE_READ_LOG_EXTENT:
-                if (success) {
-		        eh_req = core_eh_retry_org_req(
-				root, org_req, (MV_ReqCompletion)sata_error_handling_callback);
-			if (eh_req == NULL) return MV_FALSE;
-			err_ctx->eh_state = SATA_EH_MEDIA_STATE_RETRY;
-                } else {
-                        /* put back the error request as timeout to trigger the timeout handling */
-                        org_req = err_ctx->error_req;
-                        org_req->Scsi_Status = REQ_STATUS_TIMEOUT;
-
-	                err_ctx->eh_type = EH_TYPE_NONE;
-	                err_ctx->eh_state = EH_STATE_NONE;
-	                err_ctx->error_req = NULL;
-                        err_ctx->scsi_status = REQ_STATUS_TIMEOUT;
-                        MV_ASSERT(err_ctx->eh_timer == NO_CURRENT_TIMER);
-                        MV_ASSERT(err_ctx->timer_id == NO_CURRENT_TIMER);
-                        MV_ASSERT(err_ctx->state == BASE_STATE_ERROR_HANDLING);
-                        err_ctx->state = BASE_STATE_NONE;
-
-                        core_queue_error_req(root, org_req, MV_FALSE);
-                        return MV_TRUE;
-                }
-		break;
-	case SATA_EH_MEDIA_STATE_RETRY:
-		MV_ASSERT(success == MV_FALSE);
-		core_complete_error_req(root, org_req, REQ_STATUS_ERROR);
-		return MV_TRUE;
-	default:
-		MV_ASSERT(MV_FALSE);
-		return MV_FALSE;
-	}
-
-	MV_ASSERT(eh_req != NULL);
-	core_queue_eh_req(root,eh_req);
-
-	return MV_TRUE;
-}
-
-void sata_handle_taskfile_error(pl_root *root, MV_Request *req)
-{
-	domain_device *dev = NULL;
-	MV_U32 reg;
-	MV_U8 err_reg, status_reg;
-	MV_U8 lba[8];
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-	dev = (domain_device *)get_device_by_id(root->lib_dev, req->Device_Id);
-	MV_ASSERT(dev->base.type == BASE_TYPE_DOMAIN_DEVICE);
-	if (IS_ATAPI(dev)) {
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		ctx->error_info |= EH_INFO_NEED_RETRY;
-		return;
-	}
-
-	reg = MV_REG_READ_DWORD(root->rx_fis,
-		SATA_RECEIVED_D2H_FIS(root, dev->register_set));
-	status_reg = (MV_U8)((reg >> 16) & 0xff);
-	err_reg = (MV_U8)((reg >> 24) & 0xff);
-	CORE_EH_PRINT(("device %d task file error, D2H[0]=0x%x.\n", \
-		dev->base.id, reg));
-
-	reg = MV_REG_READ_DWORD(root->rx_fis,
-		SATA_RECEIVED_D2H_FIS(root, dev->register_set) + 4);
-	lba[0] = (MV_U8)(reg & 0xff);
-	lba[1] = (MV_U8)((reg >> 8) & 0xff);
-	lba[2] = (MV_U8)((reg >> 16) & 0xff);
-	reg = MV_REG_READ_DWORD(root->rx_fis,
-		SATA_RECEIVED_D2H_FIS(root, dev->register_set) + 8);
-	lba[3] = (MV_U8)(reg & 0xff);
-	lba[4] = (MV_U8)((reg >> 8) & 0xff);
-	lba[5] = (MV_U8)((reg >> 16) & 0xff);
-	lba[6] = 0;
-	lba[7] = 0;
-	CORE_DPRINT(("task file error, status=0x%x, error=0x%x, lba[0-3]=0x%x, "\
-		"lba[4-7]=0x%x.\n", status_reg, err_reg,\
-		*(MV_PU32)&lba[0], *(MV_PU32)&lba[4]));
-	CORE_DPRINT(("request info: \n"));
-	MV_DumpRequest(req, MV_FALSE);
-
-	/* If this command is an ATA Passthru then don't retry since
-	   it should be "pass thru" with no additional error handling */
-	/*Let NCQ command by ATA_PASSThrough also go through
-	   media error state machine - read log ext step, to return the
-	   sense with error info from read log ext command.*/
-	if (((req->Cdb[0] != SCSI_CMD_ATA_PASSTHRU_12) &&
-		(req->Cdb[0] != SCSI_CMD_ATA_PASSTHRU_16)) ||
-		(req->Cmd_Flag & CMD_FLAG_NCQ)) {
-
-		ctx->error_info |= EH_INFO_NEED_RETRY;
-	}
-
-	if (!(status_reg & (ATA_STATUS_ERR | ATA_STATUS_DF))
-		&& (req->Cmd_Flag & CMD_FLAG_NCQ)) {
-		reg = MV_REG_READ_DWORD(root->rx_fis,
-			SATA_RECEIVED_SDB_FIS(root, dev->register_set));
-		status_reg = (MV_U8) ((reg >> 16) & 0xff);
-		err_reg = (MV_U8) (reg >> 24);
-	}
-
-	/* set the return status */
-	if ((status_reg & (ATA_STATUS_ERR | ATA_STATUS_DF)) && err_reg) {
-		sat_make_sense(root, req, status_reg, err_reg,
-                        (MV_U64*)&lba[0]);
-	} else {
-		CORE_EH_PRINT(("device %d task file registers shows up OK "\
-			 "but still need to handle the error.\n", \
-			 dev->base.id));
-		req->Scsi_Status = REQ_STATUS_ERROR;
-	}
-
-	return;
-}
-
-static void pm_error_handling_callback(pl_root *root, MV_Request *req)
-{
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_base *base = (domain_base *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	domain_device *dev = NULL;
-	domain_pm *pm = NULL;
-	struct _error_context *err_ctx = NULL;
-	struct _error_context *pm_err_ctx = NULL;
-	MV_BOOLEAN ret = MV_TRUE;
-	MV_Request *org_req = NULL;
-
-	MV_ASSERT(CORE_IS_EH_REQ(ctx));
-
-	switch(base->type) {
-	case BASE_TYPE_DOMAIN_PM:
-		pm = (domain_pm *)base;
-		pm_err_ctx = &base->err_ctx;
-		MV_ASSERT(pm_err_ctx->state == BASE_STATE_ERROR_HANDLING);
-
-		err_ctx = &(pm->devices[pm_err_ctx->pm_eh_error_port]->base.err_ctx);
-		MV_ASSERT(err_ctx->eh_type == EH_TYPE_TIMEOUT);
-
-		org_req = err_ctx->error_req;
-		MV_ASSERT(org_req != NULL);
-
-		ret = sata_timeout_state_machine_behind_pm(root, pm,
-			(req->Scsi_Status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE), req);
-		if (ret == MV_FALSE) {
-			err_ctx->scsi_status = req->Scsi_Status;
-			err_ctx->state = BASE_STATE_NONE;
-			core_queue_error_req(root, org_req, MV_FALSE);
-		}
-		return;
-	case BASE_TYPE_DOMAIN_DEVICE:
-		dev = (domain_device *)base;
-		MV_ASSERT(IS_BEHIND_PM(dev));
-		pm = dev->pm;
-		pm_err_ctx = &pm->base.err_ctx;
-		MV_ASSERT(pm_err_ctx->state == BASE_STATE_ERROR_HANDLING);
-
-		err_ctx = &(pm->devices[pm_err_ctx->pm_eh_error_port]->base.err_ctx);
-		MV_ASSERT(err_ctx->eh_type == EH_TYPE_TIMEOUT);
-
-		org_req = err_ctx->error_req;
-		MV_ASSERT(org_req != NULL);
-
-		if (pm_err_ctx->pm_eh_error_port != dev->pm_port) {
-			ret = sata_timeout_state_machine_behind_pm(root, pm,
-				MV_TRUE, req);
-			if (ret == MV_FALSE) {
-				err_ctx->state = BASE_STATE_NONE;
-				err_ctx->scsi_status = REQ_STATUS_SUCCESS;
-				core_queue_error_req(root, org_req, MV_FALSE);
-			}
-		}
-		else {
-			MV_ASSERT(pm_err_ctx->pm_eh_error_port == dev->pm_port);
-
-			if (req->Scsi_Status == REQ_STATUS_NO_DEVICE ||
-				( CORE_IS_EH_RETRY_REQ(ctx) &&
-					( req->Scsi_Status == REQ_STATUS_SUCCESS ))) {
-				if ((pm_err_ctx->state = BASE_STATE_ERROR_HANDLING)
-					&& (pm_err_ctx->pm_eh_error_port == dev->pm_port)) {
-						pm_err_ctx->pm_eh_error_port = 0xff;
-						pm_err_ctx->pm_eh_active_port = 0xff;
-						pm_err_ctx->state = BASE_STATE_NONE;
-						pm_err_ctx->eh_state = EH_STATE_NONE;
-						pm_err_ctx->error_req = NULL;
-						pm_err_ctx->eh_type = EH_TYPE_NONE;
-				}
-			}
-
-			if (req->Scsi_Status == REQ_STATUS_NO_DEVICE) {
-				core_complete_error_req(root, org_req, REQ_STATUS_NO_DEVICE);
-				goto end_point;
-			} else if (req->Scsi_Status == REQ_STATUS_TIMEOUT) {
-				if (err_ctx->eh_type == EH_TYPE_MEDIA_ERROR) {
-					err_ctx->eh_type = EH_TYPE_TIMEOUT;
-					err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_NONE;
-				}
-			} else if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-				if (CORE_IS_EH_RETRY_REQ(ctx)) {
-					core_complete_error_req(root, org_req, REQ_STATUS_SUCCESS);
-					goto end_point;
-				}
-			} else if (req->Scsi_Status == REQ_STATUS_HAS_SENSE) {
-				if (CORE_IS_EH_RETRY_REQ(ctx)) {
-					/* copy sense code */
-					MV_CopyMemory(org_req->Sense_Info_Buffer,
-						req->Sense_Info_Buffer,
-						MV_MIN(org_req->Sense_Info_Buffer_Length,
-						req->Sense_Info_Buffer_Length));
-				}
-			}
-
-			MV_ASSERT((req->Scsi_Status == REQ_STATUS_ERROR)
-				|| (req->Scsi_Status == REQ_STATUS_HAS_SENSE)
-				|| (req->Scsi_Status == REQ_STATUS_TIMEOUT)
-				|| (req->Scsi_Status == REQ_STATUS_SUCCESS));
-
-			ret = sata_timeout_error_handler(root, dev,
-				(req->Scsi_Status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE), req);
-end_point:
-			if (ret == MV_FALSE) {
-				err_ctx->scsi_status = req->Scsi_Status;
-				err_ctx->state = BASE_STATE_NONE;
-				core_queue_error_req(root, org_req, MV_FALSE);
-			}
-		}
-		return;
-	default:
-		MV_ASSERT(MV_FALSE);
-	}
-
-}
-
-
-static void sata_error_handling_callback(pl_root *root, MV_Request *req)
-{
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *dev = (domain_device *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	struct _error_context *err_ctx = &dev->base.err_ctx;
-	MV_BOOLEAN ret = MV_TRUE;
-	MV_Request *org_req = err_ctx->error_req;
-
-	MV_ASSERT(dev->base.type == BASE_TYPE_DOMAIN_DEVICE);
-	MV_ASSERT(CORE_IS_EH_REQ(ctx));
-	MV_ASSERT((err_ctx->eh_type == EH_TYPE_MEDIA_ERROR)
-		|| (err_ctx->eh_type == EH_TYPE_TIMEOUT));
-	MV_ASSERT(org_req != NULL);
-
-	CORE_EH_PRINT(("device %d eh_type %d eh_state %d eh_status 0x%x req %p Cdb[0x%x] status 0x%x\n",\
-		dev->base.id, err_ctx->eh_type, err_ctx->eh_state,
-		err_ctx->scsi_status, req, req->Cdb[0], req->Scsi_Status));
-
-	if ((req->Cdb[0] == SCSI_CMD_MARVELL_SPECIFIC)
-		&& (req->Cdb[1] == CDB_CORE_MODULE)
-		&& (req->Cdb[2] == CDB_CORE_READ_LOG_EXT)) {
-
-		if ( (org_req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_12) ||
-			(org_req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_16) ) {
-			/*update received fis from read log ext data for ATA_Passthrough command,
-			   scsi_ata_ata_passthru_callback will make the sense data.*/
-			core_context *org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-			saved_fis *fis = (saved_fis *)org_ctx->received_fis;
-
-			if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-				MV_PU32 buf_ptr = (MV_PU32)core_map_data_buffer(req);
-				fis->dw1 = buf_ptr[0];
-				fis->dw2 = buf_ptr[1];
-				fis->dw3 = buf_ptr[2];
-				fis->dw4 = buf_ptr[3];
-				org_ctx->received_fis = (MV_PVOID)fis;
-				core_unmap_data_buffer(req);
-
-				org_req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-				core_complete_error_req(root, org_req, REQ_STATUS_HAS_SENSE);
-				goto end_point;
-			}
-
-		} else {
-			/*make sense data based on read log ext data for the failed NCQ command.*/
-			MV_U8 i,j;
-			MV_U8 temp_buffer[17];
-			MV_U8 status, error;
-			static const unsigned char sense_table[][4] = {
-				{0xd1,		SCSI_SK_ABORTED_COMMAND, 0x00, 0x00},	// Device busy					Aborted command
-				{0xd0,		SCSI_SK_ABORTED_COMMAND, 0x00, 0x00},	// Device busy					Aborted command
-				{0x61,		SCSI_SK_HARDWARE_ERROR, 0x00, 0x00},	// Device fault 				Hardware error
-				{0x84,		SCSI_SK_ABORTED_COMMAND, 0x47, 0x00},	// Data CRC error				SCSI parity error
-				{0x37,		SCSI_SK_NOT_READY, 0x04, 0x00}, 	// Unit offline 				Not ready
-				{0x09,		SCSI_SK_NOT_READY, 0x04, 0x00}, 	// Unrecovered disk error		Not ready
-				{0x01,		SCSI_SK_MEDIUM_ERROR, 0x13, 0x00},	// Address mark not found		Address mark not found for data field
-				{0x02,		SCSI_SK_HARDWARE_ERROR, 0x00, 0x00},	// Track 0 not found		  Hardware error
-				{0x04,		SCSI_SK_ABORTED_COMMAND, 0x00, 0x00},	// Aborted command				Aborted command
-				{0x08,		SCSI_SK_NOT_READY, 0x04, 0x00}, 	// Media change request   FIXME: faking offline
-				{0x10,		SCSI_SK_ABORTED_COMMAND, 0x14, 0x00},	// ID not found 				Recorded entity not found
-				{0x08,		SCSI_SK_NOT_READY, 0x04, 0x00}, 	// Media change 	  FIXME: faking offline
-				{0x40,		SCSI_SK_MEDIUM_ERROR, 0x11, 0x04},	// Uncorrectable ECC error		Unrecovered read error
-				{0x80,		SCSI_SK_MEDIUM_ERROR, 0x11, 0x04},	// Block marked bad 	  Medium error, unrecovered read error
-				{0xFF, 0xFF, 0xFF, 0xFF}, // END mark
-			};
-
-	        MV_PU8 buf_ptr = core_map_data_buffer(req);
-			MV_DASSERT(buf_ptr != NULL);
-			if ((buf_ptr != NULL) && (req->Data_Transfer_Length >= 16)) {
-				CORE_EH_PRINT(("read log ext page 0x10: \n"));
-				for (i = 0; i < 16; i++) {
-					CORE_PLAIN_DPRINT((" %x", buf_ptr[i]));
-				}
-				CORE_PLAIN_DPRINT(("\n"));
-				CORE_EH_PRINT(("the original request:\n"));
-				MV_DumpRequest(org_req, MV_FALSE);
-			}
-			status = buf_ptr[2];
-			error = buf_ptr[3];
-			if (buf_ptr[2] & (1 << 7)) {
-				buf_ptr[3] = 0;
-			}
-
-			for (j=0; j<17; j++)
-				temp_buffer[j] = 0;
-
-			temp_buffer[0] = 0x72;
-			if (buf_ptr[3]) {
-				for (j = 0; sense_table[j][0] != 0xFF; j++) {
-					if ((sense_table[j][0] & buf_ptr[3]) == sense_table[j][0]) {
-						temp_buffer[1] = sense_table[j][1];
-						temp_buffer[2] = sense_table[j][2];
-						temp_buffer[3] = sense_table[j][3];
-					}
-				}
-				temp_buffer[1] &= 0x0F;
-			}
-			temp_buffer[7] = 12;   /*ADDITIONAL SENSE LENGTH*/
-			temp_buffer[8] = 0x00; /*DESCRIPTOR TYPE*/
-			temp_buffer[9] = 10;   /*ADDITIONAL LENGTH = 12-2 */
-
-			temp_buffer[10] |= 0x80;  /* valid */
-			temp_buffer[11] = buf_ptr[10]; /*LBA 48:24*/
-			temp_buffer[12] = buf_ptr[9];
-			temp_buffer[13] = buf_ptr[8];
-
-			temp_buffer[14] = buf_ptr[6];  /*LBA 24:0*/
-			temp_buffer[15] = buf_ptr[5];
-			temp_buffer[16] = buf_ptr[4];
-			if( org_req->Sense_Info_Buffer != NULL )
-				MV_CopyMemory(org_req->Sense_Info_Buffer,temp_buffer,17);
-
-			core_unmap_data_buffer(req);
-			if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-				org_req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-				core_complete_error_req(root, org_req, REQ_STATUS_HAS_SENSE);
-				goto end_point;
-			}
-		}
-
-	}
-
-	if (req->Scsi_Status == REQ_STATUS_NO_DEVICE) {
-		core_complete_error_req(root, org_req, REQ_STATUS_NO_DEVICE);
-		goto end_point;
-	} else if (req->Scsi_Status == REQ_STATUS_TIMEOUT) {
-		if (err_ctx->eh_type == EH_TYPE_MEDIA_ERROR) {
-			err_ctx->eh_type = EH_TYPE_TIMEOUT;
-			err_ctx->eh_state = SATA_EH_TIMEOUT_STATE_NONE;
-		}
-	} else if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-		if (CORE_IS_EH_RETRY_REQ(ctx)) {
-			core_complete_error_req(root, org_req, REQ_STATUS_SUCCESS);
-			goto end_point;
-		}
-	} else if (req->Scsi_Status == REQ_STATUS_HAS_SENSE) {
-		if (CORE_IS_EH_RETRY_REQ(ctx)) {
-			/* copy sense code */
-			MV_CopyMemory(org_req->Sense_Info_Buffer,
-				req->Sense_Info_Buffer,
-				MV_MIN(org_req->Sense_Info_Buffer_Length,
-				req->Sense_Info_Buffer_Length));
-		}
-	}
-
-	MV_ASSERT((req->Scsi_Status == REQ_STATUS_ERROR)
-		|| (req->Scsi_Status == REQ_STATUS_HAS_SENSE)
-		|| (req->Scsi_Status == REQ_STATUS_TIMEOUT)
-		|| (req->Scsi_Status == REQ_STATUS_SUCCESS));
-
-	if (err_ctx->eh_type == EH_TYPE_MEDIA_ERROR) {
-		if (IS_ATAPI(dev)) {
-			if ((req->Cdb[0] == SCSI_CMD_REQUEST_SENSE)
-				&& (req->Scsi_Status == REQ_STATUS_SUCCESS)) {
-				MV_PVOID buf_ptr = core_map_data_buffer(req);
-				/* copy sense code */
-				MV_CopyMemory(org_req->Sense_Info_Buffer,
-					buf_ptr,
-					MV_MIN(org_req->Sense_Info_Buffer_Length,
-					req->Data_Transfer_Length));
-
-				org_req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-				core_unmap_data_buffer(req);
-			}
-
-			ret = atapi_media_error_state_machine(root, dev,
-				(req->Scsi_Status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE));
-		}
-		else {
-			ret = sata_media_error_state_machine(root, dev,
-				(req->Scsi_Status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE));
-		}
-	}
-	else {
-		ret = sata_timeout_error_handler(root, dev,
-			(req->Scsi_Status==REQ_STATUS_SUCCESS?MV_TRUE:MV_FALSE), req);
-	}
-
-end_point:
-	if (ret == MV_FALSE) {
-		err_ctx->scsi_status = req->Scsi_Status;
-		err_ctx->state = BASE_STATE_NONE;
-		core_queue_error_req(root, org_req, MV_FALSE);
-	}
-}
-
-static MV_BOOLEAN atapi_media_error_state_machine(pl_root *root,
-	domain_device *dev, MV_BOOLEAN success)
-{
-	struct _error_context *err_ctx = &(dev->base.err_ctx);
-	MV_Request *eh_req;
-	MV_Request *org_req = err_ctx->error_req;
-
-	MV_DASSERT(err_ctx->eh_type == EH_TYPE_MEDIA_ERROR);
-	MV_DASSERT(org_req != NULL);
-
-	switch (err_ctx->eh_state) {
-	case ATAPI_EH_MEDIA_STATE_NONE:
-		MV_DASSERT(success == MV_FALSE);
-
-		eh_req = atapi_make_request_sense_req(
-				dev, (MV_ReqCompletion)sata_error_handling_callback);
-		if (eh_req == NULL) return MV_FALSE;
-		core_queue_eh_req(root, eh_req);
-		err_ctx->eh_state =
-			ATAPI_EH_MEDIA_STATE_REQUEST_SENSE;
-		break;
-
-	case ATAPI_EH_MEDIA_STATE_REQUEST_SENSE:
-		if (success == MV_TRUE) {
-			MV_DASSERT(org_req->Scsi_Status == REQ_STATUS_HAS_SENSE);
-		} else {
-			org_req->Scsi_Status = REQ_STATUS_ERROR;
-		}
-
-		core_complete_error_req(root, org_req, org_req->Scsi_Status);
-		break;
-
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-
-	return MV_TRUE;
-}
-
-static MV_Request *atapi_make_request_sense_req(domain_device *device,
-	MV_ReqCompletion func)
-{
-	pl_root *root = device->base.root;
-	MV_Request *req;
-	MV_U8 sense_size = 18;
-
-	req = get_intl_req_resource(root, sense_size);
-	if (req == NULL) {
-		return NULL;
-	}
-
-	req->Cdb[0] = SCSI_CMD_REQUEST_SENSE;
-	req->Cdb[4] = sense_size;
-	req->Device_Id = device->base.id;
-	req->Completion = func;
-
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-
-	return req;
-}
-
-MV_VOID sata_wait_hard_reset(MV_PVOID dev_p, MV_PVOID tmp)
-{
-        domain_device *dev = (domain_device *)dev_p;
-        pl_root *root = dev->base.root;
-        MV_BOOLEAN ret = MV_FALSE;
-        struct _error_context *err_ctx = &dev->base.err_ctx;
-
-        err_ctx->eh_timer = NO_CURRENT_TIMER;
-        if (err_ctx->eh_type == EH_TYPE_TIMEOUT)
-		ret = sata_timeout_error_handler(root, dev, MV_TRUE, NULL);
-        else if (err_ctx->eh_type == EH_TYPE_MEDIA_ERROR)
-		ret = sata_media_error_state_machine(root, dev, MV_TRUE);
-        if (ret == MV_FALSE) {
-		err_ctx->scsi_status = REQ_STATUS_SUCCESS;
-		err_ctx->state = BASE_STATE_NONE;
-		core_queue_error_req(root, err_ctx->error_req, MV_FALSE);
-        }
-}
-
-MV_VOID pm_eh_wait(MV_PVOID dev_p, MV_PVOID tmp)
-{
-        domain_pm *pm = (domain_pm *)dev_p;
-		domain_device *dev;
-        pl_root *root = pm->base.root;
-        MV_BOOLEAN ret = MV_FALSE;
-        struct _error_context *pm_err_ctx = &pm->base.err_ctx;
-        struct _error_context *err_ctx;
-
-        dev = pm->devices[pm_err_ctx->pm_eh_error_port];
-		if (dev == NULL) {
-			return;
-		}
-		err_ctx	= &(dev->base.err_ctx);
-
-		pm_err_ctx->eh_timer = NO_CURRENT_TIMER;
-        if (err_ctx->eh_type == EH_TYPE_TIMEOUT)
-		ret = sata_timeout_error_handler(root, dev, MV_TRUE, NULL);
-		else {
-			MV_ASSERT(MV_FALSE);
-		}
-        if (ret == MV_FALSE) {
-		err_ctx->scsi_status = REQ_STATUS_SUCCESS;
-              err_ctx->state = BASE_STATE_NONE;
-              core_queue_error_req(root, err_ctx->error_req, MV_FALSE);
-        }
-}
--- a/drivers/scsi/vanir/core/scsi/core_sat.c
+++ /dev/null
@@ -1,4129 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "com_error.h"
-#include "core_error.h"
-#include "core_sata.h"
-#include "core_type.h"
-#include "core_internal.h"
-#include "core_protocol.h"
-#include "core_device.h"
-#include "core_exp.h"
-#include "core_sat.h"
-#include "core_util.h"
-#include "core_manager.h"
-#include "core_expander.h"
-
-#include "hba_exp.h"
-#include "com_define.h"
-
-extern saved_fis *sata_get_received_fis(pl_root *root,	MV_U8 register_set);
-MV_BOOLEAN bad_atapi_device_model(domain_device *device);
-MV_VOID scsi_ata_translation_callback(MV_PVOID root_p, MV_Request *req);
-void scsi_ata_check_condition(MV_Request *req, MV_U8 sense_key,
-	MV_U8 sense_code, MV_U8 sense_qualifier);
-
-/*******************************************************************************
-*       ATA PASSTHRU STATUS RETURN DESCRIPTOR                                  *
-*     ___________________________________________                              *
-*     0 |         DESCRIPTOR CODE (0x09)         |                             *
-*     __|________________________________________|                             *
-*     1 |   ADDITIONAL DESCRIPTOR LENGTH (0x0C)  |                             *
-*     __|________________________________________|                             *
-*     2 |             RESERVED             | EXT |                             *
-*     __|__________________________________|_____|                             *
-*     3 |                 ERROR                  |                             *
-*     __|________________________________________|                             *
-*     4 |            SECTOR COUNT EXT            |                             *
-*     __|________________________________________|                             *
-*     5 |              SECTOR COUNT              |                             *
-*     __|________________________________________|                             *
-*     6 |              LBA LOW EXT               |                             *
-*     __|________________________________________|                             *
-*     7 |                LBA LOW                 |                             *
-*     __|________________________________________|                             *
-*     8 |              LBA MID EXT               |                             *
-*     __|________________________________________|                             *
-*     9 |                LBA MID                 |                             *
-*     __|________________________________________|                             *
-*     10|              LBA HIGH EXT              |                             *
-*     __|________________________________________|                             *
-*     11|                LBA HIGH                |                             *
-*     __|________________________________________|                             *
-*     12|                 DEVICE                 |                             *
-*     __|________________________________________|                             *
-*     13|                 STATUS                 |                             *
-*     __|________________________________________|                             *
-*                                                                              *
-*******************************************************************************/
-MV_U8 ata_return_descriptor[ATA_RETURN_DESCRIPTOR_LENGTH];
-
-MV_VOID sat_make_sense(MV_PVOID root_p, MV_Request *req, MV_U8 status,
-        MV_U8 error, MV_U64 *lba)
-{
-	pl_root *root = root_p;
-	core_extension *core = (core_extension *)root->core;
-
-	if ((req->Sense_Info_Buffer_Length == 0)
-		|| (req->Sense_Info_Buffer == NULL)) {
-
-		if (status & (ATA_STATUS_DF || ATA_STATUS_ERR))
-			req->Scsi_Status = REQ_STATUS_ERROR;
-		return;
-	}
-
-	if (status & ATA_STATUS_DF)
-		scsi_ata_check_condition(req,
-			SCSI_SK_HARDWARE_ERROR,
-			SCSI_ASC_INTERNAL_TARGET_FAILURE, 0);
-	else if (status & ATA_STATUS_ERR) {
-		if (error & ATA_ERR_UNC) {
-			scsi_ata_check_condition(req,
-				SCSI_SK_MEDIUM_ERROR,
-				SCSI_ASC_UNRECOVERED_READ_ERROR, 0);
-		} else if (error & ATA_ERR_MC) {
-			scsi_ata_check_condition(req,
-				SCSI_SK_UNIT_ATTENTION,
-				SCSI_ASC_MEDIA_CHANGED, 0);
-		} else if (error & ATA_ERR_IDNF) {
-			scsi_ata_check_condition(req,
-				SCSI_SK_ILLEGAL_REQUEST,
-				SCSI_ASC_LBA_OUT_OF_RANGE, 0);
-		} else if (error & ATA_ERR_MCR) {
-			scsi_ata_check_condition(req,
-				SCSI_SK_UNIT_ATTENTION,
-				SCSI_ASC_OPERATOR_MEDIUM_REMOVAL_REQUEST, 0x01);
-		} else if (error & ATA_ERR_NM) {
-			scsi_ata_check_condition(req,
-				SCSI_SK_NOT_READY,
-				SCSI_ASC_MEDIUM_NOT_PRESENT, 0);
-		} else if (error & ATA_ERR_ICRC) {
-			scsi_ata_check_condition(req,
-				SCSI_SK_ABORTED_COMMAND,
-				SCSI_ASC_SCSI_PARITY_ERROR, 0x3);
-		} else if (error & ATA_ERR_ABRT) {
-			scsi_ata_check_condition(req,
-				SCSI_SK_ABORTED_COMMAND,
-				SCSI_ASC_NO_ASC, 0);
-		} else {
-			return;
-		}
-	} else {
-		return;
-	}
-
-	req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-}
-
-MV_BOOLEAN atapi_categorize_cdb(MV_Request *req)
-{
-	req->Cmd_Flag |= CMD_FLAG_PACKET;
-
-	/* for atapi, we supports all commands, just pass to device */
-	if (req->Cdb[0] != SCSI_CMD_MARVELL_SPECIFIC) {
-		if((req->Req_Type == REQ_TYPE_CORE)&& (req->Cdb[0]== SCSI_CMD_INQUIRY))
-			req->Cmd_Flag &= ~CMD_FLAG_PACKET;
-		return MV_TRUE;
-	} else {
-		MV_DASSERT(req->Cdb[1] == CDB_CORE_MODULE);
-
-		switch (req->Cdb[2]) {
-		case CDB_CORE_IDENTIFY:
-		case CDB_CORE_SET_UDMA_MODE:
-		case CDB_CORE_SET_PIO_MODE:
-		case CDB_CORE_SOFT_RESET_1:
-		case CDB_CORE_SOFT_RESET_0:
-			if ((req->Cdb[2]==CDB_CORE_SOFT_RESET_1)
-				|| (req->Cdb[2]==CDB_CORE_SOFT_RESET_0))
-				req->Cmd_Flag |= CMD_FLAG_SOFT_RESET;
-			return MV_TRUE;
-
-		default:
-			return MV_FALSE;
-
-		}
-	}
-}
-
-MV_BOOLEAN sat_categorize_cdb(pl_root *root, MV_Request *req)
-{
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-
-	if (ctx->type == CORE_CONTEXT_TYPE_ORG_REQ)
-		return MV_TRUE;
-
-	/* Clear these flags first. */
-	req->Cmd_Flag &= ~CMD_FLAG_PACKET;
-	req->Cmd_Flag &= ~CMD_FLAG_NCQ;
-	req->Cmd_Flag &= ~CMD_FLAG_48BIT;
-	req->Cmd_Flag &= ~CMD_FLAG_SOFT_RESET;
-
-	if (IS_ATAPI(device)) {
-		return atapi_categorize_cdb(req);
-	}
-
-	if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED)
-		req->Cmd_Flag |= CMD_FLAG_48BIT;
-
-	switch (req->Cdb[0]) {
-	case SCSI_CMD_READ_6:
-	case SCSI_CMD_READ_10:
-	case SCSI_CMD_READ_16:
-	case SCSI_CMD_WRITE_6:
-	case SCSI_CMD_WRITE_10:
-	case SCSI_CMD_VERIFY_10:
-	case SCSI_CMD_VERIFY_16:
-	case SCSI_CMD_WRITE_16:
-		/*
-		 * CMD_FLAG_DATA_IN
-		 * CMD_FLAG_DMA
-		 */
-		if (SCSI_IS_READ(req->Cdb[0]))
-			req->Cmd_Flag |= CMD_FLAG_DATA_IN;
-
-		if (SCSI_IS_READ(req->Cdb[0]) || SCSI_IS_WRITE(req->Cdb[0]))
-			req->Cmd_Flag |= CMD_FLAG_DMA;
-
-		if (device->capability & DEVICE_CAPABILITY_NCQ_SUPPORTED) {
-			if (!CORE_IS_EH_REQ(ctx) &&
-				(device->base.queue_depth > 1) &&
-				(SCSI_IS_READ(req->Cdb[0]) ||
-				SCSI_IS_WRITE(req->Cdb[0]))) {
-					req->Cmd_Flag |= CMD_FLAG_NCQ;
-			}
-		}
-
-		return MV_TRUE;
-
-	case SCSI_CMD_INQUIRY:
-	case SCSI_CMD_READ_CAPACITY_10:
-	case SCSI_CMD_READ_CAPACITY_16:
-	case SCSI_CMD_START_STOP_UNIT:
-	case SCSI_CMD_FORMAT_UNIT:
-	case SCSI_CMD_LOG_SENSE:
-	case SCSI_CMD_REQUEST_SENSE:
-	case SCSI_CMD_SND_DIAG:
-	case SCSI_CMD_TEST_UNIT_READY:
-	case SCSI_CMD_MODE_SELECT_6:
-	case SCSI_CMD_MODE_SELECT_10:
-	case SCSI_CMD_SYNCHRONIZE_CACHE_10:
-	case SCSI_CMD_REASSIGN_BLOCKS:
-	case SCSI_CMD_ATA_PASSTHRU_12:
-	case SCSI_CMD_ATA_PASSTHRU_16:
-		return MV_TRUE;
-
-	case SCSI_CMD_MARVELL_SPECIFIC:
-	{
-		MV_ASSERT(req->Cdb[1] == CDB_CORE_MODULE);
-
-		switch (req->Cdb[2]) {
-		case CDB_CORE_IDENTIFY:
-		case CDB_CORE_READ_LOG_EXT:
-		case CDB_CORE_PM_READ_REG:
-		case CDB_CORE_PM_WRITE_REG:
-			req->Cmd_Flag |= CMD_FLAG_DATA_IN;
-			return MV_TRUE;
-
-		case CDB_CORE_SOFT_RESET_1:
-		case CDB_CORE_SOFT_RESET_0:
-			req->Cmd_Flag |= CMD_FLAG_SOFT_RESET;
-			return MV_TRUE;
-
-		case CDB_CORE_SET_UDMA_MODE:
-		case CDB_CORE_SET_PIO_MODE:
-		case CDB_CORE_ENABLE_WRITE_CACHE:
-		case CDB_CORE_DISABLE_WRITE_CACHE:
-		case CDB_CORE_SET_FEATURE_SPINUP:
-		case CDB_CORE_ENABLE_SMART:
-		case CDB_CORE_DISABLE_SMART:
-		case CDB_CORE_SMART_RETURN_STATUS:
-		case CDB_CORE_ENABLE_READ_AHEAD:
-		case CDB_CORE_DISABLE_READ_AHEAD:
-		case CDB_CORE_SHUTDOWN:
-		case CDB_CORE_OS_SMART_CMD:
-		case CDB_CORE_ATA_SLEEP:
-		case CDB_CORE_ATA_IDLE:
-		case CDB_CORE_ATA_STANDBY:
-		case CDB_CORE_ATA_IDLE_IMMEDIATE:
-		case CDB_CORE_ATA_STANDBY_IMMEDIATE:
-			return MV_TRUE;
-
-		default:
-			return MV_FALSE;
-		}
-	}
-	case APICDB0_PD:
-		switch (req->Cdb[1]) {
-		case APICDB1_PD_SETSETTING:
-			switch (req->Cdb[4]) {
-				case APICDB4_PD_SET_WRITE_CACHE_OFF:
-				case APICDB4_PD_SET_WRITE_CACHE_ON:
-				case APICDB4_PD_SET_SMART_OFF:
-				case APICDB4_PD_SET_SMART_ON:
-					return MV_TRUE;
-				default:
-					return MV_FALSE;
-			}
-			break;
-		case APICDB1_PD_GETSTATUS:
-			switch (req->Cdb[4]) {
-			case APICDB4_PD_SMART_RETURN_STATUS:
-				return MV_TRUE;
-			default:
-				return MV_FALSE;
-			}
-			break;
-		default:
-			return MV_FALSE;
-		}
-		break;
-	default:
-		CORE_DPRINT(("unknown request: 0x%x.\n", req->Cdb[0]));
-		return MV_FALSE;
-	}
-}
-
-/*************************************************************************
-***                SAT - SCSI to ATA Translation Functions             ***
-***                                                                    ***
-**************************************************************************/
-
-/***************************************************************************
-* scsi_ata_check_condition
-* Purpose: Send Check Condition when request is illegal
-*
-***************************************************************************/
-void scsi_ata_check_condition(MV_Request *req, MV_U8 sense_key,
-	MV_U8 sense_code, MV_U8 sense_qualifier)
-{
-	 req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-	 if (req->Sense_Info_Buffer) {
-		 ((MV_PU8)req->Sense_Info_Buffer)[0] = 0x70; /* As SPC-4, set Response Code to 70h, or SCSI layer didn't know to set down error disk */
-		((MV_PU8)req->Sense_Info_Buffer)[2] = sense_key;
-		/* additional sense length */
-		((MV_PU8)req->Sense_Info_Buffer)[7] = 0x0a;
-		/* additional sense code */
-		((MV_PU8)req->Sense_Info_Buffer)[12] = sense_code;
-                /* additional sense code qualifier*/
-                ((MV_PU8)req->Sense_Info_Buffer)[13] = sense_qualifier;
-	 }
-}
-
-/***************************************************************************
-* scsi_ata_fill_lba_cdb6
-* Purpose: Fill LBA Cdb (6) fields with the proper req->Cdb bytes
-*
-***************************************************************************/
-void scsi_ata_fill_lba_cdb6(MV_Request *req, ata_taskfile *taskfile)
-{
-	taskfile->lba_low = req->Cdb[3];
-	taskfile->lba_mid = req->Cdb[2];
-	taskfile->lba_high = req->Cdb[1] & 0x1F;
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-}
-
-/***************************************************************************
-* scsi_ata_fill_lba_cdb10
-* Purpose: Fill LBA Cdb (10) fields with the proper req->Cdb bytes
-*
-***************************************************************************/
-void scsi_ata_fill_lba_cdb10(MV_Request *req, ata_taskfile *taskfile)
-{
-	taskfile->lba_low = req->Cdb[5];
-	taskfile->lba_mid = req->Cdb[4];
-	taskfile->lba_high = req->Cdb[3];
-	taskfile->lba_low_exp = req->Cdb[2];
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-}
-
-/***************************************************************************
-* scsi_ata_fill_lba_cdb16
-* Purpose: Fill LBA Cdb (16) fields with the proper req->Cdb bytes
-*
-***************************************************************************/
-void scsi_ata_fill_lba_cdb16(MV_Request *req, ata_taskfile *taskfile)
-{
-	taskfile->lba_low = req->Cdb[9];
-	taskfile->lba_mid = req->Cdb[8];
-	taskfile->lba_high = req->Cdb[7];
-	taskfile->lba_low_exp = req->Cdb[6];
-	taskfile->lba_mid_exp = req->Cdb[5];
-	taskfile->lba_high_exp = req->Cdb[4];
-}
-
-/***************************************************************************
-* scsi_ata_fill_data_field
-* Purpose: Fill data field with bytes that are swaped within a word
-*
-***************************************************************************/
-MV_VOID scsi_ata_fill_data_field(MV_U8 *des, MV_U8 *src, MV_U32 len)
-{
-	MV_U32 i;
-	MV_U32 max_len = len >> 1;
-
-	for (i = 0; i < max_len; i++) {
-		((MV_U16 *)des)[i] = MV_SWAP_16(((MV_U16 *)src)[i]);
-		((MV_U16 *)des)[i] = MV_LE16_TO_CPU(((MV_U16 *)des)[i]);
-	}
-
-	if (len & 1) {
-		/* ATA data is WORD accessible */
-		/* Length should never be odd  */
-		MV_ASSERT(MV_FALSE);
-		des[(i << 1)+ 1] = 0;
-	}
-}
-
-/***************************************************************************
-* scsi_ata_fill_format_taskfile
-* Purpose: Format Unit cmd translation
-*
-***************************************************************************/
-void scsi_ata_fill_format_taskfile(domain_device *device, MV_U8 ata_cmd,
-	MV_U32 lba_count, MV_U32 lba_low, MV_U32 lba_high,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = ata_cmd;
-	taskfile->features = 0;
-	taskfile->feature_exp = 0;
-
-	if(ata_cmd == ATA_CMD_WRITE_DMA || ata_cmd == ATA_CMD_VERIFY) {
-		taskfile->sector_count = (MV_U8)(lba_count & 0xFF);
-		taskfile->lba_low = (MV_U8)(lba_low&0xFF);
-		taskfile->lba_mid = (MV_U8)(lba_low>>8) & 0xFF;
-		taskfile->lba_high = (MV_U8)(lba_low>>16) & 0xFF;
-		taskfile->device = ((MV_U8)(lba_low>>24) & 0xF ) | 0x40;
-
-                taskfile->sector_count_exp = 0;
-		taskfile->lba_low_exp = 0;
-		taskfile->lba_mid_exp = 0;
-		taskfile->lba_high_exp = 0;
-
-	} else if (ata_cmd == ATA_CMD_WRITE_DMA_EXT ||
-		ata_cmd == ATA_CMD_VERIFY_EXT) {
-		taskfile->sector_count = (MV_U8)(lba_count & 0xFF);
-		taskfile->sector_count_exp = (MV_U8)((lba_count >> 8) & 0xFF);
-		taskfile->lba_low = (MV_U8)(lba_low&0xFF);
-		taskfile->lba_mid = (MV_U8)(lba_low>>8) & 0xFF;
-		taskfile->lba_high = (MV_U8)(lba_low>>16) & 0xFF;
-		taskfile->lba_low_exp = (MV_U8)(lba_low>>24) & 0xFF;
-		taskfile->lba_mid_exp = (MV_U8)(lba_high&0xFF);
-		taskfile->lba_high_exp = (MV_U8)((lba_high>>8)&0xFF);
-		taskfile->device = 0x40;
-	}
-	device->total_formatted_lba_count += lba_count;
-}
-
-MV_Request *sat_get_org_req(MV_Request *req)
-{
-        core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-
-        if (ctx->type != CORE_CONTEXT_TYPE_ORG_REQ)
-                return NULL;
-
-        return ctx->u.org.org_req;
-}
-
-MV_Request *sat_clear_org_req(MV_Request *req)
-{
-        core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-        MV_Request *org_req = ctx->u.org.org_req;
-
-        MV_ASSERT(ctx->type == CORE_CONTEXT_TYPE_ORG_REQ);
-
-        ctx->type = CORE_CONTEXT_TYPE_NONE;
-        ctx->u.org.org_req = NULL;
-
-        return org_req;
-}
-
-void sat_copy_request(MV_Request *req1, MV_Request *req2)
-{
-	core_context    *ctx1;
-        core_context    *ctx2;
-
-        if (req1 == NULL || req2 == NULL) {
-                MV_ASSERT(MV_FALSE);
-                return;
-        }
-
-	ctx1 = (core_context *)req1->Context[MODULE_CORE];
-        ctx2 = (core_context *)req2->Context[MODULE_CORE];
-
-        if (ctx1 == NULL || ctx2 == NULL) {
-                MV_ASSERT(MV_FALSE);
-                return;
-        }
-
-        ctx1->error_info        = ctx2->error_info;
-        ctx1->handler           = ctx2->handler;
-        ctx1->req_type          = ctx2->req_type;
-		ctx1->req_flag			= ctx2->req_flag;
-
-        MV_CopyMemory(req1->Cdb, req2->Cdb, sizeof(req1->Cdb));
-
-        req1->Cmd_Flag          = req2->Cmd_Flag;
-        req1->Device_Id         = req2->Device_Id;
-        req1->LBA               = req2->LBA;
-        req1->Org_Req           = req2->Org_Req;
-        req1->Req_Flag          = req2->Req_Flag;
-        req1->Sector_Count      = req2->Sector_Count;
-        req1->Tag               = req2->Tag;
-        req1->Time_Out          = req2->Time_Out;
-
-        req1->pRaid_Request     = NULL;
-        req1->Scratch_Buffer    = NULL;
-}
-
-/*
-   sat_replicate_req
-
-   Creates a new copy of the request for use in translation. Original request
-   is perserved through the orq_req pointer in the context.
-*/
-MV_Request *sat_replicate_req(pl_root *root,
-			MV_Request *req,
-			MV_U32 new_buff_size,
-			MV_ReqCompletion completion)
-{
-	domain_device   *device;
-	core_context    *curr_ctx;
-	core_context    *new_ctx;
-	MV_Request      *new_req;
-	MV_U32          buff_size;
-	MV_PVOID        org_buf_ptr, new_buf_ptr;
-
-	curr_ctx = (core_context *)req->Context[MODULE_CORE];
-	device = (domain_device *)get_device_by_id(root->lib_dev,
-	req->Device_Id);
-
-	/* Previously allocated already */
-	if (curr_ctx->type == CORE_CONTEXT_TYPE_ORG_REQ) {
-		MV_ASSERT(MV_FALSE);
-		return req;
-	}
-
-	org_buf_ptr = core_map_data_buffer(req);
-	if (org_buf_ptr == NULL && new_buff_size != 0) {
-		CORE_DPRINT(("Request wanted data buffer size of %d "\
-		"but has NULL data buffer\n", new_buff_size));
-		CORE_DPRINT(("CDB %02x %02x %02x %02x %02x %02x\n", req->Cdb[0],\
-		req->Cdb[1], req->Cdb[2], req->Cdb[3], req->Cdb[4],\
-		req->Cdb[5]));
-		new_buff_size = 0;
-	}
-
-	MV_DASSERT(new_buff_size <= SCRATCH_BUFFER_SIZE);
-
-	new_req = get_intl_req_resource(root, new_buff_size);
-
-	if (new_req == NULL) {
-		core_unmap_data_buffer(req);
-		return NULL;
-	}
-
-	sat_copy_request(new_req, req);
-
-	MV_LIST_HEAD_INIT(&new_req->Queue_Pointer);
-
-	if (new_buff_size != 0) {
-		new_buf_ptr = core_map_data_buffer(new_req);
-		buff_size = MV_MIN(new_req->Data_Transfer_Length,
-		req->Data_Transfer_Length);
-		MV_CopyMemory(new_buf_ptr, org_buf_ptr, buff_size);
-		core_unmap_data_buffer(new_req);
-	}
-
-	new_req->Completion = completion;
-	new_ctx = (core_context *)new_req->Context[MODULE_CORE];
-	new_ctx->type = CORE_CONTEXT_TYPE_ORG_REQ;
-	new_ctx->u.org.org_req = req;
-
-	core_unmap_data_buffer(req);
-	return new_req;
-}
-
-MV_U8 scsi_ata_format_unit_translation(domain_device *device, MV_Request *req);
-/***************************************************************************
-* scsi_ata_format_unit_callback
-* Purpose: Format Unit cmd translation
-*
-***************************************************************************/
-MV_U8 scsi_ata_format_unit_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, req->Device_Id);
-	MV_U32 total_lba_count = device->max_lba.parts.low + 1;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		org_req->Scsi_Status = req->Scsi_Status;
-		return MV_TRUE;
-	}
-
-	switch (device->state) {
-	case DEVICE_STATE_FORMAT_WRITE:
-		if (total_lba_count ==
-			device->total_formatted_lba_count) {
-
-			device->state = DEVICE_STATE_FORMAT_VERIFY;
-			device->total_formatted_lba_count = 0;
-		}
-		break;
-	case DEVICE_STATE_FORMAT_VERIFY:
-		if (total_lba_count == device->total_formatted_lba_count) {
-			device->state = DEVICE_STATE_FORMAT_DONE;
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return MV_TRUE;
-		}
-		break;
-	case DEVICE_STATE_FORMAT_DONE:
-	default:
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		return MV_TRUE;
-	}
-
-	return MV_FALSE;
-}
-
-void scsi_ata_format_unit_fill_taskfile(domain_device *device, MV_Request *req,
-	ata_taskfile *taskfile)
-{
-	MV_U8 ata_cmd = 0;
-	MV_U32 lba_count = 0;
-	MV_U32 total_lba_count;
-	MV_Request *org_req = sat_get_org_req(req);
-	core_context *org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-
-	if (org_ctx->req_state != FORMAT_UNIT_STARTED) {
-		device->state = DEVICE_STATE_FORMAT_WRITE;
-		org_ctx->req_state = FORMAT_UNIT_STARTED;
-	}
-
-	if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED)
-		ata_cmd = (device->state == DEVICE_STATE_FORMAT_WRITE) ?
-		ATA_CMD_WRITE_DMA_EXT : ATA_CMD_VERIFY_EXT;
-	else
-		ata_cmd = (device->state == DEVICE_STATE_FORMAT_WRITE) ?
-		ATA_CMD_WRITE_DMA : ATA_CMD_VERIFY;
-
-	total_lba_count = device->max_lba.parts.low + 1;
-
-	if (LBA_BLOCK_COUNT < (total_lba_count - device->total_formatted_lba_count))
-		lba_count = LBA_BLOCK_COUNT;
-	else
-		lba_count = total_lba_count - device->total_formatted_lba_count;
-
-	scsi_ata_fill_format_taskfile(device, ata_cmd, 0, 0, lba_count, taskfile);
-	device->total_formatted_lba_count += lba_count;
-}
-
-/***************************************************************************
-* scsi_ata_format_unit_translation
-* Purpose: Format Unit cmd translation
-*
-***************************************************************************/
-MV_U8 scsi_ata_format_unit_translation(domain_device *device, MV_Request *req)
-{
-	pl_root *root = device->base.root;
-	MV_Request *new_req;
-
-	MV_U8 defect_list = 0;
-	MV_U8 cmp_list = 0;
-	MV_U8 fmt_data = 0;
-
-	defect_list = req->Cdb[1] & 0x7;
-	cmp_list = req->Cdb[1] & 0x8;
-
-	if (defect_list != 0 || defect_list != 0x6 ||
-	(cmp_list != 0 && fmt_data != 0) || req->Cdb[2] != 0 ||
-	req->Cdb[3] != 0 || req->Cdb[4] != 0 ) {
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-				SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-}
-
-/***************************************************************************
-* scsi_ata_inquiry_callback
-* Purpose: Handles the Inquiry data after ATA_CMD_IDENTIFY is sent
-*
-***************************************************************************/
-MV_VOID sata_parse_identify_data(domain_device *device,
-                                 ata_identify_data *identify_data);
-MV_U64 sata_create_wwn(ata_identify_data *identify_data);
-
-MV_VOID scsi_ata_inquiry_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	MV_U8 MV_INQUIRY_VPD_PAGE0_DATA[7] =
-		{0x00, 0x00, 0x00, 0x03, 0x00, 0x80, 0x83};
-	MV_U8 MV_INQUIRY_VPD_PAGE83_DATA[16] =
-		{0x00, 0x83, 0x00, 0x0C, 0x01, 0x02, 0x00, 0x08,
-		0x00, 0x50, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-
-	ata_identify_data *id_data;
-	MV_U32 i;
-	MV_U32 tmp_len=0;
-	MV_PU8 org_buf_ptr;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		org_req->Scsi_Status = req->Scsi_Status;
-		return;
-	}
-
-	org_buf_ptr = (MV_PU8)core_map_data_buffer(org_req);
-	id_data = (ata_identify_data *)core_map_data_buffer(req);
-
-	if (org_req->Cdb[1] & CDB_INQUIRY_EVPD) {
-		switch(org_req->Cdb[2]) {
-		case 0x00:
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-			tmp_len = MV_MIN(org_req->Data_Transfer_Length,
-				VPD_PAGE0_VIRTUALD_SIZE);
-			MV_CopyMemory(org_buf_ptr,
-				MV_INQUIRY_VPD_PAGE0_VIRTUALD_DATA,
-				tmp_len);
-			} else {
-				tmp_len = MV_MIN(org_req->Data_Transfer_Length,
-					sizeof(MV_INQUIRY_VPD_PAGE0_DATA));
-				MV_CopyMemory(org_buf_ptr,
-					MV_INQUIRY_VPD_PAGE0_DATA,
-					tmp_len);
-			}
-			break;
-		case 0x80:
-			/* 4-23 bytes hold the serial number of the device.*/
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-				tmp_len = MV_MIN(org_req->Data_Transfer_Length,
-					VPD_PAGE80_VIRTUALD_SIZE);
-				MV_CopyMemory(org_buf_ptr,
-					MV_INQUIRY_VPD_PAGE80_VIRTUALD_DATA,
-					tmp_len);
-			} else {
-				scsi_ata_fill_data_field(
-				&device->serial_number[0],
-				&id_data->serial_number[0],
-				sizeof(device->serial_number));
-
-				if (org_req->Data_Transfer_Length >= 4) {
-				tmp_len = MV_MIN(
-					(org_req->Data_Transfer_Length
-					- 4),
-					20);
-				org_buf_ptr[1] = 0x80;
-				org_buf_ptr[3] = (MV_U8)tmp_len;
-				scsi_ata_fill_data_field(
-					&org_buf_ptr[4],
-					&id_data->serial_number[0],
-					tmp_len);
-				tmp_len +=4;
-				}
-			}
-			break;
-		case 0x83:
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-				tmp_len = MV_MIN(org_req->Data_Transfer_Length,
-					VPD_PAGE83_VIRTUALD_SIZE);
-				/*Logical Unit should have unique name*/
-				MV_INQUIRY_VPD_PAGE83_VIRTUALD_DATA[15] = (MV_U8)(req->Device_Id >> 8);
-				MV_INQUIRY_VPD_PAGE83_VIRTUALD_DATA[16] = (MV_U8)req->Device_Id;
-				MV_CopyMemory(org_buf_ptr,
-				MV_INQUIRY_VPD_PAGE83_VIRTUALD_DATA,
-				tmp_len);
-			} else {
-				tmp_len = MV_MIN(org_req->Data_Transfer_Length,
-					sizeof(MV_INQUIRY_VPD_PAGE83_DATA));
-				MV_INQUIRY_VPD_PAGE83_DATA[14] = (MV_U8)((req->Device_Id >> 8) & 0xFF);
-				MV_INQUIRY_VPD_PAGE83_DATA[15] = (MV_U8)(req->Device_Id & 0xFF);
-				MV_CopyMemory(org_buf_ptr,
-					MV_INQUIRY_VPD_PAGE83_DATA,
-					tmp_len);
-			}
-			break;
-		default:
-			scsi_ata_check_condition(org_req,
-			SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-
-			core_unmap_data_buffer(org_req);
-			core_unmap_data_buffer(req);
-			return;
-		}
-
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		org_req->Data_Transfer_Length = tmp_len;
-
-	} else {
-		/* Standard inquiry */
-		if (org_req->Cdb[2] != 0) {
-			/*
-			 * PAGE CODE field must be zero when EVPD is zero for a
-			 * valid request. sense key as ILLEGAL REQUEST and
-			 * additional sense code as INVALID FIELD IN CDB
-			 */
-			scsi_ata_check_condition(org_req, SCSI_SK_ILLEGAL_REQUEST,
-				SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-			core_unmap_data_buffer(org_req);
-			core_unmap_data_buffer(req);
-			return;
-		}
-
-		if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-			tmp_len =  MV_MIN(org_req->Data_Transfer_Length,
-				VIRTUALD_INQUIRY_DATA_SIZE);
-			MV_CopyMemory(org_buf_ptr,
-				MV_INQUIRY_VIRTUALD_DATA,
-				tmp_len);
-			org_req->Data_Transfer_Length = tmp_len;
-			core_unmap_data_buffer(org_req);
-			core_unmap_data_buffer(req);
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			return;
-		}
-
-		sata_parse_identify_data(device, id_data);
-		tmp_len =  MV_MIN(org_req->Data_Transfer_Length,
-			STANDARD_INQUIRY_LENGTH);
-		org_req->Data_Transfer_Length = tmp_len;
-
-		if (tmp_len >= 8) {
-			org_buf_ptr[0] = (IS_ATAPI(device)) ? 0x5 : 0;
-			org_buf_ptr[1] = (IS_ATAPI(device)) ? MV_BIT(7) : 0;
-			org_buf_ptr[2] = 0x05;      /* claim conformance to SPC-3 */
-			org_buf_ptr[3] = 0x02;      /* set RESPONSE DATA FORMAT to 2 */
-			org_buf_ptr[4] = (MV_U8)tmp_len - 5;
-			org_buf_ptr[6] = 0x0;
-			org_buf_ptr[7] = 0x13;      /* Tagged Queuing */
-		}
-
-		if (tmp_len >= 16)
-			MV_CopyMemory(&org_buf_ptr[8], "ATA     ", 8);
-		if (tmp_len >= 32)
-			scsi_ata_fill_data_field(&org_buf_ptr[16],
-				&id_data->model_number[0], 16);
-
-		if (tmp_len >= 36)
-			scsi_ata_fill_data_field(&org_buf_ptr[32],
-				&id_data->firmware_revision[0], 4);
-
-		if (tmp_len >= 42)
-			MV_CopyMemory(&org_buf_ptr[36], "MVSATA", 6);
-
-		/*
-		* 0x00A0 SAM 5
-		* 0x0460 SPC 4
-		* 0x04C0 SBC 3
-		* 0x1EC0 SAT 2
-		*/
-		if (tmp_len >= 66) {
-			org_buf_ptr[58] = 0x00;
-			org_buf_ptr[59] = 0xA0;
-			org_buf_ptr[60] = 0x04;
-			org_buf_ptr[61] = 0x60;
-			org_buf_ptr[62] = 0x04;
-			org_buf_ptr[63] = 0xC0;
-			org_buf_ptr[64] = 0x1E;
-			org_buf_ptr[65] = 0xC0;
-		}
-
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-	}
-
-	core_unmap_data_buffer(req);
-	core_unmap_data_buffer(org_req);
-}
-
-/***************************************************************************
-* scsi_ata_inquiry_translation
-* Purpose: Translate Inquiry SCSI command and send ATA_CMD_IDENTIFY
-*
-***************************************************************************/
-void scsi_ata_inquiry_fill_taskfile(MV_Request *req, ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_IDENTIFY_ATA;
-	taskfile->features = 0;
-	taskfile->sector_count = 0;
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->device = 0;
-	taskfile->control = 0;
-	taskfile->feature_exp = 0;
-	taskfile->sector_count_exp = 0;
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-}
-
-/***************************************************************************
-* scsi_ata_inquiry_translation
-* Purpose: Translate Inquiry SCSI command and send ATA_CMD_IDENTIFY
-*
-***************************************************************************/
-MV_U8 scsi_ata_inquiry_translation(domain_device *device, MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	if (((req->Cdb[1] & 0x1) == 0) && (req->Cdb[2] != 0)) {
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-		SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	new_req = sat_replicate_req(root, req, 0x200,
-	scsi_ata_translation_callback);
-
-	if (new_req == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-/***************************************************************************
-* scsi_ata_read_write_translate_cdb
-* Purpose: Translate read/write SCSI CDB
-*
-***************************************************************************/
-void scsi_ata_read_write_fill_taskfile(MV_Request *req, MV_U8 tag,
-	ata_taskfile * taskfile)
-{
-	MV_U8 temp_sc;
-	MV_U8 temp_sc_exp;
-
-	switch(req->Cdb[0]) {
-	case SCSI_CMD_READ_6:
-	case SCSI_CMD_WRITE_6:
-		temp_sc = req->Cdb[4];
-		temp_sc_exp = 0;
-		scsi_ata_fill_lba_cdb6(req, taskfile);
-		break;
-	case SCSI_CMD_READ_10:
-	case SCSI_CMD_WRITE_10:
-		temp_sc = req->Cdb[8];
-		temp_sc_exp = req->Cdb[7];
-		scsi_ata_fill_lba_cdb10(req, taskfile);
-		break;
-	case SCSI_CMD_READ_16:
-	case SCSI_CMD_WRITE_16:
-		temp_sc = req->Cdb[13];
-		temp_sc_exp = req->Cdb[12];
-		scsi_ata_fill_lba_cdb16(req, taskfile);
-		break;
-	default:
-		return;
-	}
-
-	taskfile->device = MV_BIT(6);
-	taskfile->control = 0;
-
-	if (req->Cmd_Flag & CMD_FLAG_NCQ) {
-		taskfile->features = temp_sc;
-		taskfile->feature_exp = temp_sc_exp;
-		taskfile->sector_count = tag << 3;
-		taskfile->sector_count_exp = 0;
-
-		if (req->Cdb[0] == SCSI_CMD_READ_6 ||
-			req->Cdb[0] == SCSI_CMD_READ_10 ||
-			req->Cdb[0] == SCSI_CMD_READ_16)
-			taskfile->command = ATA_CMD_READ_FPDMA_QUEUED;
-		else
-			taskfile->command = ATA_CMD_WRITE_FPDMA_QUEUED;
-	} else if (req->Cmd_Flag & CMD_FLAG_48BIT) {
-		taskfile->features = 0;
-		taskfile->feature_exp = 0;
-		taskfile->sector_count = temp_sc;
-		taskfile->sector_count_exp = temp_sc_exp;
-		if (req->Cdb[0] == SCSI_CMD_READ_6 ||
-			req->Cdb[0] == SCSI_CMD_READ_10 ||
-			req->Cdb[0] == SCSI_CMD_READ_16)
-			taskfile->command = ATA_CMD_READ_DMA_EXT;
-		else
-			taskfile->command = ATA_CMD_WRITE_DMA_EXT;
-	} else {
-		taskfile->features = 0;
-		taskfile->feature_exp = 0;
-		taskfile->sector_count = temp_sc;
-		taskfile->sector_count_exp = 0;
-		/* ATA6: Device Lowbyte = LBA 27:24.*/
-		if ( (req->Cdb[0] == SCSI_CMD_READ_16 || req->Cdb[0] == SCSI_CMD_WRITE_16) ) {
-			taskfile->device |= (req->Cdb[6] & 0xF);
-			MV_DASSERT((req->Cdb[6]&0xF0) == 0);
-		} else if ( (req->Cdb[0] == SCSI_CMD_READ_10 || req->Cdb[0] == SCSI_CMD_WRITE_10) ) {
-			taskfile->device |= (req->Cdb[2] & 0xF);
-			MV_DASSERT((req->Cdb[2]&0xF0) == 0);
-		} else {
-			/*READ_6, WRITE_6, LBA 27:24 = 0*/
-		}
-
-		if (req->Cdb[0] == SCSI_CMD_READ_6 ||
-			req->Cdb[0] == SCSI_CMD_READ_10 ||
-			req->Cdb[0] == SCSI_CMD_READ_16)
-			taskfile->command = ATA_CMD_READ_DMA;
-		else
-			taskfile->command = ATA_CMD_WRITE_DMA;
-	}
-}
-
-/***************************************************************************
-* scsi_ata_read_capacity_callback
-* Purpose: Handles read capacity SCSI command callback data
-*
-***************************************************************************/
-void scsi_ata_read_capacity_callback(MV_PVOID root_p,
-	MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(root->lib_dev,
-							req->Device_Id);
-	ata_identify_data *identify_data;
-	MV_LBA  max_lba;
-	MV_U32  block_length;
-	MV_PU32  org_buf_ptr;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		org_req->Scsi_Status = req->Scsi_Status;
-		return;
-	}
-
-	identify_data = (ata_identify_data *)core_map_data_buffer(req);
-	org_buf_ptr = core_map_data_buffer(org_req);
-
-	/* Disk size */
-	if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED) {
-	device->max_lba.parts.low =
-		MV_LE32_TO_CPU(*((MV_PU32)&identify_data->max_lba[0]));
-		device->max_lba.parts.high =
-		MV_LE32_TO_CPU(*((MV_PU32)&identify_data->max_lba[2]));
-	} else {
-		device->max_lba.parts.low =
-		MV_LE32_TO_CPU(*((MV_PU32)&identify_data->user_addressable_sectors[0]));
-		device->max_lba.parts.high = 0;
-	}
-	/*
-	* The disk size as indicated by the ATA spec is the total addressable
-	* sectors on the drive; while Max LBA is the LBA of the last logical
-	* block on the drive
-	*/
-	device->max_lba = U64_SUBTRACT_U32(device->max_lba, 1);
-
-	max_lba = device->max_lba;
-	block_length = SECTOR_SIZE;
-
-	if (org_req->Cdb[0] == SCSI_CMD_READ_CAPACITY_10 &&
-			org_req->Data_Transfer_Length >= 8) {
-		/* check if max_lba exceeds the maximum value for Read Capacity 10 */
-		if (max_lba.parts.high != 0){
-			org_buf_ptr[0] = MV_CPU_TO_BE32(0xFFFFFFFF);
-		}else
-			org_buf_ptr[0] = MV_CPU_TO_BE32(max_lba.parts.low);
-		org_buf_ptr[1] = MV_CPU_TO_BE32(block_length);
-	} else if (org_req->Cdb[0] == SCSI_CMD_READ_CAPACITY_16 &&
-		org_req->Data_Transfer_Length >= 12) {
-		org_buf_ptr[0] = MV_CPU_TO_BE32(max_lba.parts.high);
-		org_buf_ptr[1] = MV_CPU_TO_BE32(max_lba.parts.low);
-		org_buf_ptr[2] = MV_CPU_TO_BE32(block_length);
-	}
-
-	core_unmap_data_buffer(req);
-	core_unmap_data_buffer(org_req);
-}
-
-void scsi_ata_read_capacity_fill_taskfile(MV_Request *req,
-	ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_IDENTIFY_ATA;
-	taskfile->features = 0;
-	taskfile->sector_count = 0;
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->device = 0;
-	taskfile->control = 0;
-	taskfile->feature_exp = 0;
-	taskfile->sector_count_exp = 0;
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-}
-
-/***************************************************************************
-* scsi_ata_read_capacity_translation
-* Purpose: Handles read capacity SCSI commands
-*
-***************************************************************************/
-MV_U8 scsi_ata_read_capacity_translation(domain_device *device, MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	if ((req->Cdb[2] | req->Cdb[3] | req->Cdb[4] | req->Cdb[5]) != 0) {
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	new_req = sat_replicate_req(root, req, 0x200,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-/***************************************************************************
-* scsi_ata_verify_translation
-* Purpose: Handles verify SCSI commands
-*
-***************************************************************************/
-void scsi_ata_verify_fill_taskfile(MV_Request *req, ata_taskfile *taskfile)
-{
-	MV_U8 tempSC, tempSC_exp;
-
-	switch(req->Cdb[0]) {
-	case SCSI_CMD_VERIFY_10:
-		tempSC = req->Cdb[8];
-		tempSC_exp = req->Cdb[7];
-		scsi_ata_fill_lba_cdb10(req, taskfile);
-		break;
-	case SCSI_CMD_VERIFY_16:
-		tempSC = req->Cdb[13];
-		tempSC_exp = req->Cdb[12];
-		scsi_ata_fill_lba_cdb16(req, taskfile);
-		break;
-	default:
-		return;
-	}
-
-	taskfile->device = MV_BIT(6);
-
-	if (req->Cmd_Flag & CMD_FLAG_48BIT) {
-		taskfile->sector_count = tempSC;
-		taskfile->sector_count_exp = tempSC_exp;
-		taskfile->command = ATA_CMD_VERIFY_EXT;
-	} else {
-		taskfile->sector_count = tempSC;
-                taskfile->sector_count_exp = 0;
-		/* ATA6: Device Lowbyte = LBA 27:24.*/
-		if (req->Cdb[0] == SCSI_CMD_VERIFY_16) {
-			taskfile->device |= (req->Cdb[6] & 0xF);
-			MV_DASSERT((req->Cdb[6]&0xF0) == 0);
-		}
-		else {
-			taskfile->device |= (req->Cdb[2] & 0xF) ;
-			MV_DASSERT((req->Cdb[2]&0xF0) == 0);
-		}
-		taskfile->command = ATA_CMD_VERIFY;
-	}
-	taskfile->features = 0;
-	taskfile->control = 0;
-	taskfile->feature_exp = 0;
-}
-
-
-void scsi_ata_sync_cache_fill_taskfile(domain_device *device, MV_Request *req,
-	ata_taskfile *taskfile)
-{
-	taskfile->device = MV_BIT(6);
-	switch (req->Cdb[0]){
-	case SCSI_CMD_SYNCHRONIZE_CACHE_10:
-		if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED)
-			taskfile->command = ATA_CMD_FLUSH_EXT;
-		else
-			taskfile->command = ATA_CMD_FLUSH;
-		break;
-	case SCSI_CMD_SYNCHRONIZE_CACHE_16:
-		taskfile->command = ATA_CMD_FLUSH_EXT;
-		break;
-	default:
-		scsi_ata_check_condition( req, SCSI_SK_ILLEGAL_REQUEST,
-				SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return;
-	}
-	taskfile->features = 0;
-	taskfile->sector_count = 0;
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->device = 0;
-	taskfile->control = 0;
-	taskfile->feature_exp = 0;
-	taskfile->sector_count_exp = 0;
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-}
-
-/***************************************************************************
-* scsi_ata_sync_cache_translation
-* Purpose: Syncronize cache 10/16
-*
-***************************************************************************/
-MV_U8 scsi_ata_sync_cache_translation(domain_device *device, MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	/* for SSD without support write_cache */
-	if (!(device->capability & DEVICE_CAPABILITY_WRITECACHE_SUPPORTED)) {
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED)
-		req->Cmd_Flag |= CMD_FLAG_48BIT;
-
-	if ((req->Cdb[1] & 0x2) !=  0) req->Scsi_Status = REQ_STATUS_SUCCESS;
-
-	new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-/***************************************************************************
-* scsi_ata_send_diag_callback
-* Purpose: handles callback
-*
-***************************************************************************/
-MV_U8 scsi_ata_send_diag_callback(MV_PVOID root_p,
-	MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	core_context *org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, req->Device_Id);
-
-	if ((req->Scsi_Status != REQ_STATUS_SUCCESS) ||
-		((req->Cdb[1] & 0x04) && (!((device->capability &
-		DEVICE_CAPABILITY_SMART_SELF_TEST_SUPPORTED) &&
-	(device->setting & DEVICE_SETTING_SMART_ENABLED))))) {
-		switch(req->Cdb[1] & 0xE0) {
-		case FOREGROUND_SHORT_SELF_TEST:
-		case FOREGROUND_EXTENDED_SELF_TEST:
-			scsi_ata_check_condition(org_req, SCSI_SK_HARDWARE_ERROR,
-				        SCSI_ASC_LOGICAL_UNIT_FAILURE, 0x03);
-			return MV_TRUE;
-		default:
-			org_req->Scsi_Status = req->Scsi_Status;
-			return MV_TRUE;
-		}
-		return MV_TRUE;
-	}
-
-	switch (org_ctx->req_state) {
-	case SEND_DIAGNOSTIC_SMART:
-	case SEND_DIAGNOSTIC_VERIFY_MAX:
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-		return MV_TRUE;
-
-	case SEND_DIAGNOSTIC_VERIFY_0:
-	case SEND_DIAGNOSTIC_VERIFY_MID:
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-		return MV_TRUE;
-	}
-
-	core_append_request(root, org_req);
-	return MV_FALSE;
-}
-
-MV_U8 scsi_ata_send_diag_verify_fill_req(domain_device *device,
-                                               MV_Request *req,
-                                               MV_U64 lba)
-{
-	if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED) {
-		req->Cdb[0] = SCSI_CMD_VERIFY_16;
-		req->Cdb[2] = (MV_U8)(lba.parts.high >> 24) & 0xFF; /* LBA */
-		req->Cdb[3] = (MV_U8)(lba.parts.high >> 16) & 0xFF;
-		req->Cdb[4] = (MV_U8)(lba.parts.high >> 8) & 0xFF;
-		req->Cdb[5] = (MV_U8)lba.parts.high & 0xFF;
-		req->Cdb[6] = (MV_U8)(lba.parts.low >> 24) & 0xFF;
-		req->Cdb[7] = (MV_U8)(lba.parts.low >> 16) & 0xFF;
-		req->Cdb[8] = (MV_U8)(lba.parts.low >> 8) & 0xFF;
-		req->Cdb[9] = (MV_U8)lba.parts.low & 0xFF;
-		req->Cdb[10] = 0; /* Sector Count */
-		req->Cdb[11] = 0;
-		req->Cdb[12] = 0;
-		req->Cdb[13] = 1;
-	} else {
-		req->Cdb[0] = SCSI_CMD_VERIFY_10;
-		req->Cdb[2] = (MV_U8)(lba.parts.low >> 24) & 0xFF;
-		req->Cdb[3] = (MV_U8)(lba.parts.low >> 16) & 0xFF;
-		req->Cdb[4] = (MV_U8)(lba.parts.low >> 8) & 0xFF;
-		req->Cdb[5] = (MV_U8)lba.parts.low & 0xFF;
-		req->Cdb[7] = 0; /* Sector Count */
-		req->Cdb[8] = 1;
-	}
-
-	return MV_TRUE;
-}
-
-void scsi_ata_send_diag_fill_taskfile(domain_device *device, MV_Request *req,
-	ata_taskfile *taskfile)
-{
-	pl_root *root = device->base.root;
-
-	if ((req->Cdb[1] & 0x04) && (device->capability &
-		DEVICE_CAPABILITY_SMART_SELF_TEST_SUPPORTED) &&
-		(device->setting & DEVICE_SETTING_SMART_ENABLED)) {
-		taskfile->lba_low = 129;
-	} else {
-		switch ((req->Cdb[1] & 0xE0) >> 5) {
-		case BACKGROUND_SHORT_SELF_TEST:
-			taskfile->lba_low = 1;
-			break;
-		case BACKGROUND_EXTENDED_SELF_TEST:
-			taskfile->lba_low = 2;
-			break;
-		case ABORT_BACKGROUND_SELF_TEST:
-			taskfile->lba_low = 127;
-			break;
-		case FOREGROUND_SHORT_SELF_TEST:
-			taskfile->lba_low = 129;
-			break;
-		case FOREGROUND_EXTENDED_SELF_TEST:
-			taskfile->lba_low = 130;
-			break;
-		default:
-			break;
-		}
-	}
-
-	taskfile->device = MV_BIT(6);
-	taskfile->lba_mid = 0x4F;
-	taskfile->lba_high = 0xC2;
-	taskfile->features = ATA_CMD_SMART_EXECUTE_OFFLINE;
-	taskfile->command = ATA_CMD_SMART;
-
-	taskfile->sector_count = 0;
-	taskfile->control = 0;
-	taskfile->feature_exp = 0;
-	taskfile->sector_count_exp = 0;
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-}
-
-/***************************************************************************
-* scsi_ata_send_diag_translation
-* Purpose: Sends Diagnostic cmd
-*
-***************************************************************************/
-MV_U8 scsi_ata_send_diag_translation(domain_device *device, MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_LBA lba;
-
-	/* CDB[1] checks if DevOffL and UnitOffL bits are set
-	  * CDB[3] & CDB[4] checks for parameter list length equal to 0.*/
-	if (((req->Cdb[1] & 0x03) != 0) || (req->Cdb[3] != 0) || (req->Cdb[4] != 0)) {
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-				SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-	req->Time_Out = 60;
-	switch (ctx->req_state) {
-	case SEND_DIAGNOSTIC_START:
-		if (req->Cdb[1] & 0x04) {
-			if (!((device->capability &
-				DEVICE_CAPABILITY_SMART_SELF_TEST_SUPPORTED) &&
-				(device->setting & DEVICE_SETTING_SMART_ENABLED))) {
-
-				/* Send 3 ATA_CMD_VERIFY commands and report
-				   back the result:
-
-				        1) Sector Count = 1, LBA = 0
-				        2) Sector Count = 1, LBA = max_lba
-				        3) Sector Count = 1, LBA = x,
-				                {x e Z | 0 < x < max_lba}
-
-				   If all 3 passes, then return success
-				   If any 3 fails, then return logical unit
-				   failure
-				*/
-				new_req = sat_replicate_req(root, req, 0,
-				                scsi_ata_translation_callback);
-
-				if (new_req == NULL)
-					return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-				ctx->req_state = SEND_DIAGNOSTIC_VERIFY_0;
-				lba.parts.low = 0;
-				lba.parts.high = 0;
-				scsi_ata_send_diag_verify_fill_req(device, req, lba);
-
-				core_append_request(root, new_req);
-				return MV_QUEUE_COMMAND_RESULT_REPLACED;
-			}
-		} else {
-			if (device->capability &
-				DEVICE_CAPABILITY_SMART_SELF_TEST_SUPPORTED) {
-				if (!(device->setting &
-					DEVICE_SETTING_SMART_ENABLED)) {
-					scsi_ata_check_condition(
-					req,
-					SCSI_SK_ABORTED_COMMAND,
-					SCSI_ASC_CONFIGURATION_FAILURE,
-					0x0B);
-					return MV_QUEUE_COMMAND_RESULT_FINISHED;
-				}
-			} else {
-				scsi_ata_check_condition(req,
-				SCSI_SK_ILLEGAL_REQUEST,
-				SCSI_ASC_INVALID_FEILD_IN_CDB,
-				0);
-				return MV_QUEUE_COMMAND_RESULT_FINISHED;
-			}
-		}
-
-		ctx->req_state = SEND_DIAGNOSTIC_SMART;
-		new_req = sat_replicate_req(root, req, 0,
-		                scsi_ata_translation_callback);
-
-		if (new_req == NULL)
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-		core_append_request(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case SEND_DIAGNOSTIC_VERIFY_0:
-		ctx->req_state = SEND_DIAGNOSTIC_VERIFY_MID;
-		new_req = sat_replicate_req(root, req, 0,
-		        scsi_ata_translation_callback);
-
-		if (new_req == NULL)
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-		lba = U64_DIVIDE_U32(device->max_lba, 2);
-		scsi_ata_send_diag_verify_fill_req(device, req, lba);
-		core_append_request(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case SEND_DIAGNOSTIC_VERIFY_MID:
-		ctx->req_state = SEND_DIAGNOSTIC_VERIFY_MAX;
-		new_req = sat_replicate_req(root, req, 0,
-		        scsi_ata_translation_callback);
-
-		if (new_req == NULL)
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-		lba = device->max_lba;
-		scsi_ata_send_diag_verify_fill_req(device, req, lba);
-		core_append_request(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case SEND_DIAGNOSTIC_SMART:
-	case SEND_DIAGNOSTIC_VERIFY_MAX:
-		MV_ASSERT(MV_FALSE);
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-	default:
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-}
-
-MV_U8 scsi_ata_start_stop_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *) req->Context[MODULE_CORE];
-	core_context *org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(root->lib_dev,
-	org_req->Device_Id);
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		switch (ctx->req_state) {
-			case START_STOP_IDLE_IMMEDIATE_SYNC:
-			case START_STOP_STANDBY_IMMEDIATE_SYNC:
-			case START_STOP_STANDBY_SYNC:
-				scsi_ata_check_condition(org_req,
-					SCSI_SK_ABORTED_COMMAND,
-					SCSI_ASC_CMD_SEQUENCE_ERROR, 0);
-				break;
-			case START_STOP_EJECT:
-				scsi_ata_check_condition(org_req,
-					SCSI_SK_ABORTED_COMMAND,
-					SCSI_ASC_MEDIA_LOAD_EJECT_FAILURE, 0);
-				break;
-			default:
-				break;
-		}
-		return MV_TRUE;
-	}
-
-	switch (org_ctx->req_state) {
-	case START_STOP_IDLE_IMMEDIATE_SYNC:
-	case START_STOP_STANDBY_IMMEDIATE_SYNC:
-	case START_STOP_STANDBY_SYNC:
-		core_append_request(root, org_req);
-		return MV_FALSE;
-
-	case START_STOP_ACTIVE:
-		return MV_TRUE;
-
-	case START_STOP_STANDBY_IMMEDIATE:
-	case START_STOP_STANDBY:
-		return MV_TRUE;
-
-	case START_STOP_IDLE_IMMEDIATE:
-	case START_STOP_EJECT:
-		return MV_TRUE;
-
-	default:
-		MV_ASSERT(MV_FALSE);
-		return MV_TRUE;
-	}
-}
-
-void scsi_ata_start_stop_fill_taskfile(domain_device *device, MV_Request *req,
-	ata_taskfile *taskfile)
-{
-	MV_Request *org_req = sat_get_org_req(req);
-	core_context *org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-
-	switch (org_ctx->req_state) {
-	case START_STOP_IDLE_IMMEDIATE_SYNC:
-	case START_STOP_STANDBY_IMMEDIATE_SYNC:
-	case START_STOP_STANDBY_SYNC:
-		taskfile->device = MV_BIT(6);
-		taskfile->lba_low = 0;
-		taskfile->lba_mid = 0;
-		taskfile->lba_high = 0;
-		taskfile->sector_count = 0;
-
-		taskfile->lba_low_exp = 0;
-		taskfile->lba_mid_exp = 0;
-		taskfile->lba_high_exp = 0;
-		taskfile->sector_count_exp = 0;
-
-		taskfile->features = 0;
-		taskfile->feature_exp = 0;
-		taskfile->control = 0;
-
-	if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED)
-		taskfile->command = ATA_CMD_FLUSH_EXT;
-	else
-		taskfile->command = ATA_CMD_FLUSH;
-		break;
-	case START_STOP_ACTIVE:
-		taskfile->device = MV_BIT(6);
-		taskfile->lba_low = 1; /* {x e Z | 0 < x < max_lba} */
-		taskfile->lba_mid = 0;
-		taskfile->lba_high = 0;
-		taskfile->sector_count = 1;
-
-		taskfile->lba_low_exp = 0;
-		taskfile->lba_mid_exp = 0;
-		taskfile->lba_high_exp = 0;
-		taskfile->sector_count_exp = 0;
-
-		taskfile->features = 0;
-		taskfile->feature_exp = 0;
-		taskfile->control = 0;
-
-	if (device->capability & DEVICE_CAPABILITY_48BIT_SUPPORTED)
-		taskfile->command = ATA_CMD_VERIFY_EXT;
-	else
-		taskfile->command = ATA_CMD_VERIFY;
-
-		break;
-	case START_STOP_EJECT:
-		taskfile->command = ATA_CMD_MEDIA_EJECT;
-		break;
-	default:
-		break;
-	}
-}
-
-/***************************************************************************
-* scsi_ata_start_stop_translation
-* Purpose: Start and Stop cmd translation
-*
-***************************************************************************/
-MV_U8 scsi_ata_start_stop_translation(domain_device *device, MV_Request *req)
-{
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	pl_root *root = device->base.root;
-	MV_Request *new_req=NULL;
-	MV_U8 power_condition = (req->Cdb[4] & 0xF0) >> 4;
-
-	switch (ctx->req_state) {
-	case START_STOP_START:
-		req->Time_Out = 60;
-		switch (power_condition) {
-		case 0x0:
-			switch ((req->Cdb[4]) & 0x03) {
-			case 0x00:
-				if ((req->Cdb[4]) & 0x04)
-					goto scsi_ata_start_stop_standby_immediate;
-				else if(!(device->capability & DEVICE_CAPABILITY_WRITECACHE_SUPPORTED))
-					goto scsi_ata_start_stop_standby_immediate;
-				else
-					ctx->req_state = START_STOP_STANDBY_IMMEDIATE_SYNC;
-				break;
-			case 0x01:
-				ctx->req_state = START_STOP_ACTIVE;
-				break;
-			case 0x02:
-				ctx->req_state = START_STOP_EJECT;
-				break;
-			case 0x03:
-				scsi_ata_check_condition(req,
-					SCSI_SK_ILLEGAL_REQUEST,
-					SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-				return MV_QUEUE_COMMAND_RESULT_FINISHED;
-			}
-			break;
-		case 0x1:
-			ctx->req_state = START_STOP_ACTIVE;
-			break;
-		case 0x2:
-			if ((req->Cdb[4]) & 0x04)
-				goto scsi_ata_start_stop_idle_immediate;
-			else
-				ctx->req_state = START_STOP_IDLE_IMMEDIATE_SYNC;
-			break;
-		case 0x3:
-			if ((req->Cdb[4]) & 0x04)
-				goto scsi_ata_start_stop_standby_immediate;
-			else
-				ctx->req_state = START_STOP_STANDBY_IMMEDIATE_SYNC;
-			break;
-		case 0xB:
-			if ((req->Cdb[4]) & 0x04)
-				goto scsi_ata_start_stop_standby;
-			else
-				ctx->req_state = START_STOP_STANDBY_SYNC;
-			break;
-		default:
-			scsi_ata_check_condition(req,
-				SCSI_SK_ILLEGAL_REQUEST,
-				SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		}
-
-		new_req = sat_replicate_req(root, req, 0,
-			scsi_ata_translation_callback);
-
-		if (new_req == NULL)
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-		core_append_request(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case START_STOP_IDLE_IMMEDIATE_SYNC:
-scsi_ata_start_stop_idle_immediate:
-		ctx->req_state = START_STOP_IDLE_IMMEDIATE;
-		new_req = sat_replicate_req(root, req, 0,
-			        scsi_ata_translation_callback);
-
-		if (new_req == NULL)
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-		new_req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-		new_req->Cdb[1] = CDB_CORE_MODULE;
-		new_req->Cdb[2] = CDB_CORE_ATA_IDLE_IMMEDIATE;
-
-		core_append_request(root, new_req);
-			return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case START_STOP_STANDBY_IMMEDIATE_SYNC:
-scsi_ata_start_stop_standby_immediate:
-		ctx->req_state = START_STOP_STANDBY_IMMEDIATE;
-		new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-		if (new_req == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-		new_req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-		new_req->Cdb[1] = CDB_CORE_MODULE;
-		new_req->Cdb[2] = CDB_CORE_ATA_STANDBY_IMMEDIATE;
-
-		core_append_request(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case START_STOP_STANDBY_SYNC:
-scsi_ata_start_stop_standby:
-		ctx->req_state = START_STOP_STANDBY;
-		new_req = sat_replicate_req(root, req, 0,
-			scsi_ata_translation_callback);
-
-		if (new_req == NULL)
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-		new_req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-		new_req->Cdb[1] = CDB_CORE_MODULE;
-		new_req->Cdb[2] = CDB_CORE_ATA_STANDBY;
-
-		core_append_request(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	default:
-		MV_ASSERT(MV_FALSE);
-		req->Scsi_Status = REQ_STATUS_ERROR;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-}
-
-/***************************************************************************
-* scsi_ata_test_unit_ready_callback
-* Purpose: Test Unit Ready cmd translation
-*
-***************************************************************************/
-void scsi_ata_test_unit_ready_callback(MV_PVOID root_p,
-	MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, org_req->Device_Id);
-	saved_fis *fis;
-	MV_U32 reg;
-	MV_U8 sector_count_reg;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		scsi_ata_check_condition(org_req, SCSI_SK_NOT_READY,
-		        SCSI_ASC_LOGICAL_UNIT_NOT_RESP_TO_SEL, 0);
-		return;
-	}
-
-	fis = (saved_fis *)ctx->received_fis;
-	if (fis == NULL) MV_ASSERT(MV_FALSE);
-	reg = fis->dw4;
-	sector_count_reg = (MV_U8)(reg & 0xff);
-
-	/*
-	ATA 8, Section 7.8
-
-	Sector Count result value -
-	00h - device is in Standby mode.
-	40h - device is in NV Cache Power Mode and the spindle is
-	      spun down or spinning down
-	41h - device is in NV Cache Power Mode and the spindle is
-	      spun up or spinning up
-	80h - device is in Idle mode.
-	FFh - device is in Active mode or Idle mode.
-	*/
-	switch (sector_count_reg) {
-	case 0x00:
-	/*
-	 * Device is in standby mode and thus the device is not ready.
-	 * We should return check status to indicate to the applications
-	 * that they need to send down a START STOP UNIT command to start
-	 * the device.
-	 */
-		scsi_ata_check_condition(org_req, SCSI_SK_NOT_READY,
-			SCSI_ASC_LUN_NOT_READY, 0x02);
-		return;
-	case 0x80:
-	case 0x40:
-	case 0x41:
-	case 0xFF:
-		break;
-	default:
-		CORE_DPRINT(("Unsupported sector count code 0x%x returned "\
-			"from drive\n", sector_count_reg));
-		break;
-	}
-
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-}
-
-void scsi_ata_test_unit_ready_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_PM_CHECK;
-	taskfile->device = MV_BIT(6);
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->features = 0;
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-/***************************************************************************
-* scsi_ata_test_unit_ready_translation
-* Purpose: Test Unit Ready cmd translation
-*
-***************************************************************************/
-MV_U8 scsi_ata_test_unit_ready_translation(domain_device *device,
-	MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	if (device->state == DEVICE_STATE_FORMAT_WRITE ||
-		device->state == DEVICE_STATE_FORMAT_VERIFY) {
-		scsi_ata_check_condition(req, SCSI_SK_NOT_READY,
-			SCSI_ASC_LUN_NOT_READY, 0x04);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL) return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	((core_context *)new_req->Context[MODULE_CORE])->req_flag |=
-		CORE_REQ_FLAG_NEED_D2H_FIS;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-void scsi_ata_request_sense_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, org_req->Device_Id);
-	saved_fis *fis;
-	MV_PU8 dest;
-	MV_U32 reg;
-	MV_U8 lba_mid, lba_high;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) return;
-
-	fis = (saved_fis *)ctx->received_fis;
-	if (fis == NULL) MV_ASSERT(MV_FALSE);
-	reg = fis->dw2;
-	lba_mid = (MV_U8)((reg >> 8) & 0xff);
-	lba_high = (MV_U8)((reg >> 16) & 0xff);
-
-	dest = (MV_PU8)core_map_data_buffer(org_req);
-
-	/* 4Fh if threshold not exceeded, F4h if threshold exceeded.
-	C2h if threshold not exceeded, 2Ch if threshold exceeded.
-	MRIE is set to 6h
-	DExcpt bit is set to 0
-	*/
-	if (lba_mid == 0xF4 || lba_high == 0x2C) {
-		scsi_ata_check_condition(org_req,
-		SCSI_ASC_FAILURE_PREDICTION_THRESHOLD_EXCEEDED,
-		SCSI_ASCQ_HIF_GENERAL_HD_FAILURE, 0);
-	} else {
-		req->Scsi_Status = REQ_STATUS_SUCCESS;
-	}
-
-	if (dest != NULL &&
-		org_req->Data_Transfer_Length >= 13) {     /*This added is for DTM*/
-		dest[0] = 0x70; /* Current */
-		dest[2] = 0x00; /* Sense Key*/
-		dest[7] = 0x00; /* additional sense len */
-		dest[12] = 0x00;/* additional sense code */
-	}
-
-	core_unmap_data_buffer(org_req);
-}
-
-void scsi_ata_request_sense_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->device = MV_BIT(6);
-	taskfile->lba_mid = 0x4F;
-	taskfile->lba_high = 0xC2;
-	taskfile->command = ATA_CMD_SMART;
-	taskfile->features = ATA_CMD_SMART_RETURN_STATUS;
-
-	taskfile->lba_low = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-/***************************************************************************
-* scsi_ata_request_sense_translation
-* Purpose: Request sense translation
-*
-***************************************************************************/
-MV_U8 scsi_ata_request_sense_translation(domain_device *device,
-	MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	if (!(device->setting & DEVICE_SETTING_SMART_ENABLED)) {
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-		SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (device->state == DEVICE_STATE_FORMAT_WRITE ||
-		device->state == DEVICE_STATE_FORMAT_VERIFY) {
-		scsi_ata_check_condition(req, SCSI_SK_NOT_READY,
-			SCSI_ASC_LUN_NOT_READY, 0x04);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL) return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	((core_context *)new_req->Context[MODULE_CORE])->req_flag |=
-		CORE_REQ_FLAG_NEED_D2H_FIS;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-void scsi_ata_log_sense_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, req->Device_Id);
-	saved_fis *fis;
-	MV_U32 reg;
-	MV_U8 lba_mid, lba_high;
-	MV_U32 length;
-	MV_PU8 buf_ptr;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) return;
-
-	length = MV_MIN(org_req->Data_Transfer_Length, 11);
-	buf_ptr = core_map_data_buffer(org_req);
-
-	if (buf_ptr == NULL || length == 0) {
-		core_unmap_data_buffer(org_req);
-		return;
-	}
-
-	fis = (saved_fis *)ctx->received_fis;
-	if (fis == NULL) MV_ASSERT(MV_FALSE);
-	reg = fis->dw2;
-
-	lba_mid = (MV_U8)((reg >> 8) & 0xff);
-	lba_high = (MV_U8)((reg >> 16) & 0xff);
-
-	buf_ptr[0] = INFORMATIONAL_EXCEPTIONS_LOG_PAGE;
-	buf_ptr[1] = 0; /* reserved */
-	buf_ptr[2] = 0;
-	buf_ptr[3] = 7;
-	buf_ptr[4] = 0;
-	buf_ptr[5] = 0; /* parameter code = 0*/
-	buf_ptr[6] = 0x03; /* DU=0,DS=0,TSD=0,ETC=0,TMC=0,LBIN=1,LP=1 */
-	buf_ptr[7] = 0x03; /* parameter length = 3 */
-	if (lba_mid == 0xF4 || lba_high == 0x2C) {
-		buf_ptr[8] = SCSI_ASC_FAILURE_PREDICTION_THRESHOLD_EXCEEDED;
-		buf_ptr[9] = SCSI_ASCQ_HIF_GENERAL_HD_FAILURE;
-	} else {
-		buf_ptr[8] = 0;
-		buf_ptr[9] = 0;
-	}
-	buf_ptr[10] = 38; /* MOST RECENT TEMPERATURE READING */
-
-	core_unmap_data_buffer(org_req);
-}
-
-void scsi_ata_log_sense_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->device = MV_BIT(6);
-	taskfile->lba_mid = 0x4F;
-	taskfile->lba_high = 0xC2;
-	taskfile->command = ATA_CMD_SMART;
-	taskfile->features = ATA_CMD_SMART_RETURN_STATUS;
-
-	taskfile->lba_low = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-MV_U8 scsi_ata_log_sense_translation(domain_device *device,
-	MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	if (!(device->setting & DEVICE_SETTING_SMART_ENABLED)) {
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-		SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (device->state == DEVICE_STATE_FORMAT_WRITE ||
-		device->state == DEVICE_STATE_FORMAT_VERIFY) {
-		scsi_ata_check_condition(req, SCSI_SK_NOT_READY,
-		SCSI_ASC_LUN_NOT_READY, 0x04);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	new_req = sat_replicate_req(root, req, 0,
-	scsi_ata_translation_callback);
-
-	if (new_req == NULL) return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	((core_context *)new_req->Context[MODULE_CORE])->req_flag |=
-		CORE_REQ_FLAG_NEED_D2H_FIS;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-MV_U8 scsi_ata_mode_select_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, req->Device_Id);
-	MV_U8 finished = MV_TRUE;
-	MV_PU8 data_buf;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		org_req->Scsi_Status = req->Scsi_Status;
-		return MV_TRUE;
-	}
-
-	data_buf = (MV_PU8)core_map_data_buffer(org_req);
-	switch (req->Cdb[2]) {
-	case CDB_CORE_ENABLE_WRITE_CACHE:
-		device->setting |= DEVICE_SETTING_WRITECACHE_ENABLED;
-		if (device->setting & DEVICE_SETTING_READ_LOOK_AHEAD) {
-			if (data_buf[12] & MV_BIT(5)) {
-				req->Cdb[2] = CDB_CORE_DISABLE_READ_AHEAD;
-				finished = MV_FALSE;
-			}
-		} else {
-			if (!(data_buf[12] & MV_BIT(5))) {
-				req->Cdb[2] = CDB_CORE_ENABLE_READ_AHEAD;
-				finished = MV_FALSE;
-			}
-		}
-		break;
-	case CDB_CORE_DISABLE_WRITE_CACHE:
-		device->setting &= ~DEVICE_SETTING_WRITECACHE_ENABLED;
-		if (device->setting & DEVICE_SETTING_READ_LOOK_AHEAD) {
-			if (data_buf[12] & MV_BIT(5)) {
-				req->Cdb[2] = CDB_CORE_DISABLE_READ_AHEAD;
-				finished = MV_FALSE;
-			}
-		} else {
-			if (!(data_buf[12] & MV_BIT(5))) {
-				req->Cdb[2] = CDB_CORE_ENABLE_READ_AHEAD;
-				finished = MV_FALSE;
-			}
-		}
-		break;
-	case CDB_CORE_ENABLE_READ_AHEAD:
-		device->setting &= ~DEVICE_SETTING_READ_LOOK_AHEAD;
-		break;
-	case CDB_CORE_DISABLE_READ_AHEAD:
-		device->setting |= DEVICE_SETTING_READ_LOOK_AHEAD;
-		break;
-	default:
-		break;
-	}
-
-	core_unmap_data_buffer(org_req);
-
-	if (finished == MV_FALSE)
-		return MV_FALSE;
-
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	return MV_TRUE;
-}
-
-void scsi_ata_mode_select_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = 0;
-	taskfile->device = MV_BIT(6);
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->features = 0;
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-MV_U8 scsi_ata_mode_select_translation(domain_device *device,
-        MV_Request *req)
-{
-	MV_U32 offset;
-	MV_PU8 data_buf;
-	MV_U32 length;
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-	MV_U8 func = 0xFF;
-
-	length = req->Data_Transfer_Length;
-	data_buf = core_map_data_buffer(req);
-	offset = 4 + data_buf[3];
-
-	data_buf = &data_buf[offset];
-	switch (data_buf[0] & 0x3f) {
-	case CACHE_MODE_PAGE:
-		if (data_buf[1] != 0x12) {
-			scsi_ata_check_condition(req,
-				SCSI_SK_ILLEGAL_REQUEST,
-				SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-			core_unmap_data_buffer(req);
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-		}
-
-		if (device->setting &
-			DEVICE_SETTING_WRITECACHE_ENABLED) {
-			if (!(data_buf[2] & MV_BIT(2)))
-				func = CDB_CORE_DISABLE_WRITE_CACHE;
-		} else {
-			if (data_buf[2] & MV_BIT(2))
-				func = CDB_CORE_ENABLE_WRITE_CACHE;
-		}
-
-		if (device->setting & DEVICE_SETTING_READ_LOOK_AHEAD
-			&& func == 0xFF) {
-			if (data_buf[12] & MV_BIT(5))
-				func = CDB_CORE_DISABLE_READ_AHEAD;
-		} else {
-			if (!(data_buf[12] & MV_BIT(5)))
-				func = CDB_CORE_ENABLE_READ_AHEAD;
-		}
-		break;
-	default:
-		scsi_ata_check_condition(req,
-		SCSI_SK_ILLEGAL_REQUEST,
-		SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-
-		core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (func != 0xFF) {
-		new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-		if (new_req == NULL) {
-			core_unmap_data_buffer(req);
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-		}
-
-		new_req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-		new_req->Cdb[1] = CDB_CORE_MODULE;
-		new_req->Cdb[2] = func;
-
-		core_unmap_data_buffer(req);
-		core_append_request(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-	}
-
-	core_unmap_data_buffer(req);
-	req->Scsi_Status = REQ_STATUS_SUCCESS;
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-MV_U8 scsi_ata_reassign_blocks_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_context *org_ctx = (core_context *)org_req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, req->Device_Id);
-
-	MV_U8 long_lba;
-	MV_U8 long_list;
-	MV_U32 list_length;
-	MV_U32 offset;
-	MV_PU8 buf_ptr;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		if (org_ctx->req_state & REASSIGN_BLOCKS_ERROR) {
-			switch (req->Cdb[0]) {
-			case SCSI_CMD_VERIFY_10:
-			case SCSI_CMD_VERIFY_16:
-			case SCSI_CMD_WRITE_10:
-			case SCSI_CMD_WRITE_16:
-			scsi_ata_check_condition(org_req,
-				SCSI_SK_MEDIUM_ERROR,
-				SCSI_ASC_UNRECOVERED_READ_ERROR, 0x04);
-				return MV_TRUE;
-			default:
-				MV_DASSERT(MV_FALSE);
-				return MV_TRUE;
-			}
-		} else {
-			switch (req->Cdb[0]) {
-			case SCSI_CMD_VERIFY_10:
-			case SCSI_CMD_VERIFY_16:
-				org_ctx->req_state |= REASSIGN_BLOCKS_ERROR;
-				goto scsi_ata_reassign_blocks_callback_end;
-
-			case SCSI_CMD_WRITE_10:
-			case SCSI_CMD_WRITE_16:
-			default:
-				MV_ASSERT(MV_FALSE);
-				return MV_TRUE;
-			}
-		}
-
-	}
-
-	buf_ptr = core_map_data_buffer(org_req);
-	long_list = org_req->Cdb[1] & 0x01;
-	long_lba = org_req->Cdb[1] & 0x02;
-
-	if (long_list)
-		list_length = (buf_ptr[0] << 24)
-		+ (buf_ptr[1] << 16)
-		+ (buf_ptr[2] << 8)
-		+ buf_ptr[3];
-	else
-		list_length = (buf_ptr[2] << 8) + buf_ptr[3];
-
-	if (long_lba)
-		offset = (org_ctx->req_state & 0x3FFFFFFF) << 3;
-	else
-		offset = (org_ctx->req_state & 0x3FFFFFFF) << 2;
-
-	core_unmap_data_buffer(org_req);
-
-	if (org_ctx->req_state & REASSIGN_BLOCKS_ERROR) {
-		switch (req->Cdb[0]) {
-		case SCSI_CMD_VERIFY_10:
-		case SCSI_CMD_VERIFY_16:
-			org_ctx->req_state &= ~REASSIGN_BLOCKS_ERROR;
-			if (list_length == offset)
-				return MV_TRUE;
-			else
-				goto scsi_ata_reassign_blocks_callback_end;
-			break;
-		case SCSI_CMD_WRITE_10:
-		case SCSI_CMD_WRITE_16:
-			goto scsi_ata_reassign_blocks_callback_end;
-		default:
-			MV_DASSERT(MV_FALSE);
-			return MV_TRUE;
-		}
-	} else {
-		switch (req->Cdb[0]) {
-		case SCSI_CMD_VERIFY_10:
-		case SCSI_CMD_VERIFY_16:
-			if (list_length == offset)
-				return MV_TRUE;
-			else
-				goto scsi_ata_reassign_blocks_callback_end;
-			break;
-		case SCSI_CMD_WRITE_10:
-		case SCSI_CMD_WRITE_16:
-		default:
-			MV_DASSERT(MV_FALSE);
-			return MV_TRUE;
-		}
-	}
-
-	scsi_ata_reassign_blocks_callback_end:
-	core_append_request(root, org_req);
-	return MV_FALSE;
-}
-
-void scsi_ata_reassign_blocks_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = 0;
-	taskfile->device = MV_BIT(6);
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->features = 0;
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-MV_U8 scsi_ata_reassign_blocks_translation(domain_device *device,
-        MV_Request *req)
-{
-	pl_root *root = device->base.root;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	MV_PU8 org_buf_ptr, new_buf_ptr;
-	MV_U32 buf_size = req->Data_Transfer_Length;
-	MV_U8 long_list = req->Cdb[1] & 0x01;
-	MV_U8 long_lba = req->Cdb[1] & 0x02;
-	MV_U32 list_length;
-	MV_U32 offset;
-	MV_Request *new_req;
-
-	/* defective LBA list containing one or more LBAs */
-	if ((!long_lba && buf_size < 8)
-		|| (long_lba && buf_size < 12)) {
-		scsi_ata_check_condition(req,
-		SCSI_SK_ILLEGAL_REQUEST,
-		SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	org_buf_ptr = core_map_data_buffer(req);
-
-	if (long_list)
-		list_length = (org_buf_ptr[0] << 24)
-		+ (org_buf_ptr[1] << 16)
-		+ (org_buf_ptr[2] << 8)
-		+ org_buf_ptr[3];
-	else
-		list_length = (org_buf_ptr[2] << 8) + org_buf_ptr[3];
-
-	/*
-	The DEFECT LIST LENGTH field does not include the parameter list
-	header length and is equal to either:
-
-	four times the number of LBAs, if the LONGLBA bit is set to zero; or
-	eight times the number of LBAs, if the LONGLBA bit is set to one.
-	*/
-
-	if ((!long_lba && (list_length & 0x03))
-		|| (long_lba && (list_length & 0x07))) {
-
-	scsi_ata_check_condition(req,
-			SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-		core_unmap_data_buffer(req);
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (long_lba)
-		offset = (ctx->req_state & 0x3FFFFFFF) << 3;
-	else
-		offset = (ctx->req_state & 0x3FFFFFFF) << 2;
-
-	org_buf_ptr = &org_buf_ptr[4 + offset];
-
-	if (!(ctx->req_state & REASSIGN_BLOCKS_ERROR)) {
-		/* if status is okay, then issue verify */
-		ctx->req_state++;
-		new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-		if (new_req == NULL) {
-			core_unmap_data_buffer(req);
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-		}
-
-		if (long_lba) {
-			new_req->Cdb[0] = SCSI_CMD_VERIFY_16;
-			new_req->Cdb[4] = org_buf_ptr[2];
-			new_req->Cdb[5] = org_buf_ptr[3];
-			new_req->Cdb[6] = org_buf_ptr[4];
-			new_req->Cdb[7] = org_buf_ptr[5];
-			new_req->Cdb[8] = org_buf_ptr[6];
-			new_req->Cdb[9] = org_buf_ptr[7];
-			new_req->Cdb[13] = 1;
-		} else {
-			new_req->Cdb[0] = SCSI_CMD_VERIFY_10;
-			new_req->Cdb[2] = org_buf_ptr[0];
-			new_req->Cdb[3] = org_buf_ptr[1];
-			new_req->Cdb[4] = org_buf_ptr[2];
-			new_req->Cdb[5] = org_buf_ptr[3];
-			new_req->Cdb[8] = 1;
-		}
-	} else {
-		/* if status is error, then issue write */
-		new_req = sat_replicate_req(root, req,
-			device->sector_size,
-			scsi_ata_translation_callback);
-
-		if (new_req == NULL) {
-			core_unmap_data_buffer(req);
-			return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-		}
-
-		new_buf_ptr = core_map_data_buffer(new_req);
-		MV_ZeroMemory(new_buf_ptr,
-		new_req->Data_Transfer_Length);
-		core_unmap_data_buffer(new_req);
-
-		if (long_lba) {
-			new_req->Cdb[0] = SCSI_CMD_WRITE_16;
-			new_req->Cdb[4] = org_buf_ptr[2];
-			new_req->Cdb[5] = org_buf_ptr[3];
-			new_req->Cdb[6] = org_buf_ptr[4];
-			new_req->Cdb[7] = org_buf_ptr[5];
-			new_req->Cdb[8] = org_buf_ptr[6];
-			new_req->Cdb[9] = org_buf_ptr[7];
-			new_req->Cdb[13] = 1;
-
-		} else {
-			new_req->Cdb[0] = SCSI_CMD_WRITE_10;
-			new_req->Cdb[2] = org_buf_ptr[0];
-			new_req->Cdb[3] = org_buf_ptr[1];
-			new_req->Cdb[4] = org_buf_ptr[2];
-			new_req->Cdb[5] = org_buf_ptr[3];
-			new_req->Cdb[8] = 1;
-		}
-	}
-
-	core_unmap_data_buffer(new_req);
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-void scsi_ata_soft_reset_fill_taskfile(MV_Request *req,
-        ata_taskfile* taskfile)
-{
-	if (req->Cdb[2] == CDB_CORE_SOFT_RESET_1)
-		taskfile->control = MV_BIT(2);
-	else
-		taskfile->control = 0;
-
-	taskfile->command = 0;
-	taskfile->device = MV_BIT(6);
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->features = 0;
-	taskfile->feature_exp = 0;
-}
-
-void scsi_atapi_core_identify_fill_taskfile(MV_Request *req,
-        ata_taskfile* taskfile)
-{
-	taskfile->command = ATA_CMD_IDENTIFY_ATAPI;
-	taskfile->device = MV_BIT(6);
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->features = 0;
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-
-void scsi_ata_core_identify_fill_taskfile(MV_Request *req,
-        ata_taskfile* taskfile)
-{
-	taskfile->command = ATA_CMD_IDENTIFY_ATA;
-	taskfile->device = MV_BIT(6);
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->features = 0;
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_set_udma_mode_fill_taskfile(domain_device *device,
-	MV_Request *req, ata_taskfile* taskfile)
-{
-	if (!IS_ATAPI(device)) {
-		/* Use UDMA mode */
-		MV_DASSERT(req->Cdb[4] == MV_FALSE);
-	}
-
-	taskfile->command = ATA_CMD_SET_FEATURES;
-	taskfile->features = ATA_CMD_SET_TRANSFER_MODE;
-	taskfile->device = MV_BIT(6);
-
-	if (req->Cdb[4] == MV_TRUE && !IS_ATAPI(device))
-		taskfile->sector_count = 0x20 | req->Cdb[3]; /* MDMA mode */
-	else
-		taskfile->sector_count = 0x40 | req->Cdb[3]; /* UDMA mode*/
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_set_pio_mode_fill_taskfile(MV_Request *req,
-        ata_taskfile* taskfile)
-{
-	taskfile->command = ATA_CMD_SET_FEATURES;
-	taskfile->features = ATA_CMD_SET_TRANSFER_MODE;
-	taskfile->sector_count = 0x08 | req->Cdb[3];
-	taskfile->device = MV_BIT(6);
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_write_cache_fill_taskfile(MV_Request *req,
-        ata_taskfile* taskfile)
-{
-	taskfile->command = ATA_CMD_SET_FEATURES;
-	taskfile->device = MV_BIT(6);
-
-	if (req->Cdb[2] == CDB_CORE_ENABLE_WRITE_CACHE)
-		taskfile->features = ATA_CMD_ENABLE_WRITE_CACHE;
-	else
-		taskfile->features = ATA_CMD_DISABLE_WRITE_CACHE;
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_pois_to_spinup_fill_taskfile(MV_Request *req,
-        ata_taskfile* taskfile)
-{
-	taskfile->command = ATA_CMD_SET_FEATURES;
-	taskfile->device = MV_BIT(6);
-
-	if (req->Cdb[2] == CDB_CORE_SET_FEATURE_SPINUP)
-		taskfile->features = ATA_CMD_SET_POIS_SPINUP;
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_enable_smart_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_SMART;
-	taskfile->device = MV_BIT(6);
-
-	if (req->Cdb[2] == CDB_CORE_ENABLE_SMART)
-		taskfile->features = ATA_CMD_ENABLE_SMART;
-	else
-		taskfile->features = ATA_CMD_DISABLE_SMART;
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0x4F;
-	taskfile->lba_high = 0xC2;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-MV_U8 scsi_ata_enable_smart_translation(domain_device *device,
-        MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-void scsi_ata_smart_return_status_callback(pl_root *root,
-        MV_Request *org_req, MV_Request *req)
-{
-	HD_SMART_Status *status;
-	MV_U32 reg, lba_mid, lba_high;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, org_req->Device_Id);
-	saved_fis *fis;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) return;
-
-	status = (HD_SMART_Status *)core_map_data_buffer(org_req);
-	if (status == NULL
-		|| org_req->Data_Transfer_Length == 0) {
-
-		core_unmap_data_buffer(org_req);
-		return;
-	}
-
-	fis = (saved_fis *)ctx->received_fis;
-	if (fis == NULL) MV_ASSERT(MV_FALSE);
-	reg = fis->dw2;
-
-	lba_mid = (MV_U8)((reg >> 8) & 0xff);
-	lba_high = (MV_U8)((reg >> 16) & 0xff);
-
-	if (lba_mid == 0xF4 && lba_high == 0x2C) {
-		status->SmartThresholdExceeded = MV_TRUE;
-	}
-	else if (lba_mid == 0x4F && lba_high == 0xC2) {
-		status->SmartThresholdExceeded = MV_FALSE;
-	}
-	else {
-		status->SmartThresholdExceeded = MV_FALSE;
-		CORE_DPRINT(("Invalid register value. LBA Mid:%x LBA High:%x\n",
-			lba_mid, lba_high));
-	}
-	core_unmap_data_buffer(org_req);
-}
-
-void scsi_ata_smart_return_status_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_SMART;
-	taskfile->features = ATA_CMD_SMART_RETURN_STATUS;
-	taskfile->device = MV_BIT(6);
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0x4F;
-	taskfile->lba_high = 0xC2;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-MV_U8 scsi_ata_smart_return_status_translation(domain_device *device,
-        MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	new_req = sat_replicate_req(root, req, 0,
-	scsi_ata_translation_callback);
-
-	if (new_req == NULL) return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	((core_context *)new_req->Context[MODULE_CORE])->req_flag |=
-		CORE_REQ_FLAG_NEED_D2H_FIS;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-#define BAD_SSD_DEVICE_MODEL    "Patriot Inferno 60GB SSD"
-extern MV_U8 gRunningMode;
-void scsi_ata_shudown_fill_taskfile(domain_device *device, MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	if (device->capability &
-	DEVICE_CAPABILITY_48BIT_SUPPORTED)
-		taskfile->command = ATA_CMD_FLUSH_EXT;
-	else
-		taskfile->command = ATA_CMD_FLUSH;
-	taskfile->features = 0;
-	taskfile->device = MV_BIT(6);
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_enable_read_ahead_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_SET_FEATURES;
-	taskfile->device = MV_BIT(6);
-
-	if (req->Cdb[2] == CDB_CORE_ENABLE_READ_AHEAD)
-		taskfile->features = ATA_CMD_ENABLE_READ_LOOK_AHEAD;
-	else
-		taskfile->features = ATA_CMD_DISABLE_READ_LOOK_AHEAD;
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_read_log_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_READ_LOG_EXT;
-	taskfile->device = MV_BIT(6);
-	taskfile->features = 0;
-
-	taskfile->lba_low = 0x10;       /* Read page 10 */
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 1;     /* Read 1 sector */
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_pm_read_reg_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_PM_READ;
-	taskfile->features = req->Cdb[4];
-	taskfile->device = req->Cdb[3];
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_pm_write_reg_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = ATA_CMD_PM_WRITE;
-	taskfile->features = req->Cdb[4];
-	taskfile->device = req->Cdb[3];
-
-	taskfile->lba_low = req->Cdb[5];
-	taskfile->lba_mid = req->Cdb[6];
-	taskfile->lba_high = req->Cdb[7];
-	taskfile->sector_count = req->Cdb[8];
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_os_smart_cmd_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_extension *core = (core_extension *)root->core;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device;
-	saved_fis *fis;
-	MV_U32 reg;
-	MV_U8 lba_high, lba_mid, status_reg, err_reg;
-
-	device = (domain_device *)get_device_by_id(root->lib_dev,
-		req->Device_Id);
-	req->Data_Buffer = NULL;
-	req->Data_Transfer_Length = 0;
-	ctx->buf_wrapper = NULL;
-	SGTable_Init(&req->SG_Table, 0);
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) return;
-
-	/* return identify device data as is */
-	if (org_req->Cdb[3] == ATA_CMD_IDENTIFY_ATA) return;
-
-	fis = (saved_fis *)ctx->received_fis;
-	if (fis == NULL) MV_ASSERT(MV_FALSE);
-	reg = fis->dw2;
-
-	lba_mid = (MV_U8)((reg >> 8) & 0xff);
-	lba_high = (MV_U8)((reg >> 16) & 0xff);
-
-	switch (org_req->Cdb[4]) {
-	case ATA_CMD_SMART_READ_DATA:
-	case ATA_CMD_SMART_READ_ATTRIBUTE_THRESHOLDS:
-	case ATA_CMD_SMART_ENABLE_ATTRIBUTE_AUTOSAVE:
-	case ATA_CMD_SMART_SAVE_ATTRIBUTE_VALUES:
-	case ATA_CMD_SMART_READ_LOG:
-	case ATA_CMD_SMART_WRITE_LOG:
-	case ATA_CMD_ENABLE_SMART:
-	case ATA_CMD_DISABLE_SMART:
-		break;
-
-	case ATA_CMD_SMART_EXECUTE_OFFLINE:
-		if (lba_mid == 0xF4 && lba_high == 0x2C) {
-			scsi_ata_check_condition(org_req,
-				SCSI_SK_ABORTED_COMMAND, SCSI_ASC_NO_ASC, 0);
-			org_req->Cdb[6] = 0xF4;
-			org_req->Cdb[7] = 0x2C;
-		}
-		break;
-	case ATA_CMD_SMART_RETURN_STATUS:
-		if (lba_mid == 0xF4 && lba_high == 0x2C) {
-			core_generate_event(core,
-				EVT_ID_HD_SMART_THRESHOLD_OVER,
-				device->base.id, SEVERITY_INFO,
-				0, NULL ,0);
-			org_req->Cdb[6] = 0xF4;
-			org_req->Cdb[7] = 0x2C;
-		}
-		break;
-	default:
-		MV_DASSERT(MV_FALSE);
-		break;
-	}
-}
-
-void scsi_ata_os_smart_cmd_fill_taskfile(MV_Request *req,
-        ata_taskfile *taskfile)
-{
-	taskfile->command = req->Cdb[3];
-	taskfile->features = req->Cdb[4];
-	taskfile->device = MV_BIT(6);
-
-	taskfile->lba_low = req->Cdb[5];
-	taskfile->lba_mid  = req->Cdb[6];
-	taskfile->lba_high = req->Cdb[7];
-	taskfile->sector_count = req->Cdb[8];
-
-	taskfile->lba_low_exp = req->Cdb[9];
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-MV_U8 scsi_ata_os_smart_cmd_translation(domain_device *device,
-        MV_Request *req)
-{
-	MV_Request *new_req;
-	pl_root *root = device->base.root;
-
-	if (req->Cdb[3] != ATA_CMD_SMART &&
-		req->Cdb[3] != ATA_CMD_IDENTIFY_ATA) {
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	if (req->Cdb[3] == ATA_CMD_SMART &&
-		(req->Cdb[4] < ATA_CMD_SMART_READ_DATA ||
-		req->Cdb[4] > ATA_CMD_SMART_RETURN_STATUS ||
-		req->Cdb[4] == 0xD7)) {
-		scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-			return MV_QUEUE_COMMAND_RESULT_FINISHED;
-	}
-
-	new_req = sat_replicate_req(root, req, 0,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL) return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	new_req->Data_Buffer = req->Data_Buffer;
-	new_req->Data_Transfer_Length = req->Data_Transfer_Length;
-	((core_context *)new_req->Context[MODULE_CORE])->buf_wrapper
-		= ((core_context *)req->Context[MODULE_CORE])->buf_wrapper;
-	((core_context *)new_req->Context[MODULE_CORE])->req_flag |=
-		CORE_REQ_FLAG_NEED_D2H_FIS;
-
-	if (req->Data_Transfer_Length > 0) {
-		MV_CopyPartialSGTable(
-			&new_req->SG_Table,
-			&req->SG_Table,
-			0, /* offset */
-			req->SG_Table.Byte_Count /* size */
-		);
-	}
-
-	if (req->Cdb[3] == ATA_CMD_IDENTIFY_ATA) {
-		new_req->Cdb[0] = SCSI_CMD_INQUIRY;
-		MV_ZeroMemory(&new_req->Cdb[1], sizeof(new_req->Cdb) - 1);
-	}
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-void
-scsi_ata_fill_taskfile_cmd(MV_Request *req,
-        ata_taskfile *taskfile, MV_U8 cmd)
-{
-	taskfile->command = cmd;
-	taskfile->features = 0;
-	taskfile->device = MV_BIT(6);
-
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_api_request_callback(MV_PVOID root_p,
-	MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = root_p;
-	core_extension *core = (core_extension *)root->core;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *dev = (domain_device *)get_device_by_id(root->lib_dev,
-	req->Device_Id);
-	saved_fis *fis;
-
-	HD_SMART_Status *status;
-	MV_U32 reg;
-	MV_U8 lba_mid, lba_high;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		if (org_req->Cdb[1] == APICDB1_PD_GETSTATUS &&
-			org_req->Cdb[4] == APICDB4_PD_SMART_RETURN_STATUS)
-			core_generate_event(core, EVT_ID_HD_SMART_POLLING_FAIL,
-				dev->base.id, SEVERITY_WARNING, 0, NULL ,0);
-		return;
-	}
-
-	fis = (saved_fis *)ctx->received_fis;
-	if (fis == NULL) MV_ASSERT(MV_FALSE);
-
-	switch (org_req->Cdb[1]) {
-	case APICDB1_PD_SETSETTING:
-		switch (org_req->Cdb[4]) {
-		case APICDB4_PD_SET_WRITE_CACHE_OFF:
-			dev->setting &= ~DEVICE_SETTING_WRITECACHE_ENABLED;
-			core_generate_event(core, EVT_ID_HD_CACHE_MODE_CHANGE,
-			dev->base.id, SEVERITY_INFO, 0, NULL ,0);
-			break;
-		case APICDB4_PD_SET_WRITE_CACHE_ON:
-			dev->setting |= DEVICE_SETTING_WRITECACHE_ENABLED;
-			core_generate_event(core, EVT_ID_HD_CACHE_MODE_CHANGE,
-			dev->base.id, SEVERITY_INFO, 0, NULL ,0);
-			break;
-		case APICDB4_PD_SET_SMART_OFF:
-			dev->setting &= ~DEVICE_SETTING_SMART_ENABLED;
-			break;
-		case APICDB4_PD_SET_SMART_ON:
-			dev->setting |= DEVICE_SETTING_SMART_ENABLED;
-			break;
-		default:
-			MV_ASSERT(MV_FALSE);
-			break;
-		}
-		break;
-
-	case APICDB1_PD_GETSTATUS:
-	switch (org_req->Cdb[4]) {
-	case APICDB4_PD_SMART_RETURN_STATUS:
-		reg = fis->dw2;
-		lba_mid = (MV_U8)((reg >> 8) & 0xff);
-		lba_high = (MV_U8)((reg >> 16) & 0xff);
-		status = (HD_SMART_Status *)core_map_data_buffer(org_req);
-		if (lba_mid == 0xF4 && lba_high == 0x2C) {
-			core_generate_event(core,
-				EVT_ID_HD_SMART_THRESHOLD_OVER,
-				dev->base.id, SEVERITY_WARNING,
-				0, NULL ,0);
-		} else {
-			if (status != NULL && org_req->Data_Transfer_Length != 0)
-				status->SmartThresholdExceeded = MV_FALSE;
-		}
-		core_unmap_data_buffer(org_req);
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-		break;
-
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-}
-
-MV_U8
-scsi_ata_api_request_translation(domain_device *dev,
-        MV_Request *req, MV_U8 cmd)
-{
-	MV_Request *new_req;
-	pl_root *root = dev->base.root;
-
-	new_req = sat_replicate_req(root, req, req->Data_Transfer_Length,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL)
-		return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	new_req->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-	new_req->Cdb[1] = CDB_CORE_MODULE;
-	new_req->Cdb[2] = cmd;
-
-	MV_ZeroMemory(&new_req->Cdb[3], sizeof(new_req->Cdb) - 3);
-	((core_context *)new_req->Context[MODULE_CORE])->req_flag |=
-		CORE_REQ_FLAG_NEED_D2H_FIS;
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-}
-
-void scsi_ata_ata_passthru_callback(MV_PVOID root_p,
-        MV_Request *org_req, MV_Request *req)
-{
-	pl_root *root = root_p;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *dev = (domain_device *)get_device_by_id(root->lib_dev,
-	req->Device_Id);
-	saved_fis *fis;
-	MV_U8 protocol, chk_cond;
-	MV_U32 reg;
-	MV_U32 length;
-
-	req->Data_Buffer = NULL;
-	req->Data_Transfer_Length = 0;
-	ctx->buf_wrapper = NULL;
-	SGTable_Init(&req->SG_Table, 0);
-
-	fis = (saved_fis *)ctx->received_fis;
-	if ((req->Scsi_Status != REQ_STATUS_SUCCESS) && (fis == NULL)) return;
-
-	if (fis == NULL) MV_ASSERT(MV_FALSE);
-	chk_cond = (org_req->Cdb[2] >> 5) & 0x01;
-
-	switch (org_req->Cdb[0]) {
-	case SCSI_CMD_ATA_PASSTHRU_12:
-		reg = fis->dw1;
-		org_req->Cdb[3] = (MV_U8)((reg >> 24) & 0xff);
-		org_req->Cdb[9] = (MV_U8)((reg >> 16) & 0xff);
-
-		reg = fis->dw2;
-		org_req->Cdb[5] = (MV_U8)(reg & 0xff);
-		org_req->Cdb[6] = (MV_U8)((reg >> 8) & 0xff);
-		org_req->Cdb[7] = (MV_U8)((reg >> 16) & 0xff);
-		org_req->Cdb[8] = (MV_U8)((reg >> 24) & 0xff);
-
-		reg = fis->dw4;
-		org_req->Cdb[4] = (MV_U8)(reg & 0xff);
-		org_req->Cdb[11] = (MV_U8)((reg >> 24) & 0xff);
-
-		break;
-	case SCSI_CMD_ATA_PASSTHRU_16:
-		reg = fis->dw1;
-		org_req->Cdb[4] = (MV_U8)((reg >> 24) & 0xff);
-		org_req->Cdb[14] = (MV_U8)((reg >> 16) & 0xff);
-
-		reg = fis->dw2;
-		org_req->Cdb[8] = (MV_U8)(reg & 0xff);
-		org_req->Cdb[10] = (MV_U8)((reg >> 8) & 0xff);
-		org_req->Cdb[12] = (MV_U8)((reg >> 16) & 0xff);
-		org_req->Cdb[13] = (MV_U8)((reg >> 24) & 0xff);
-
-		reg = fis->dw3;
-		org_req->Cdb[7] = (MV_U8)(reg & 0xff);
-		org_req->Cdb[9] = (MV_U8)((reg >> 8) & 0xff);
-		org_req->Cdb[11] = (MV_U8)((reg >> 16) & 0xff);
-		org_req->Cdb[3] = (MV_U8)((reg >> 24) & 0xff);
-
-		reg = fis->dw4;
-		org_req->Cdb[6] = (MV_U8)(reg & 0xff);
-		org_req->Cdb[5] = (MV_U8)((reg >> 8) & 0xff);
-		org_req->Cdb[15] = (MV_U8)((reg >> 24) & 0xff);
-
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-
-	if (chk_cond) {
-		if (org_req->Sense_Info_Buffer) {
-			((MV_PU8)org_req->Sense_Info_Buffer)[0] = 0x72;
-			((MV_PU8)org_req->Sense_Info_Buffer)[7] = 0x0E;
-			if (req->Scsi_Status == REQ_STATUS_SUCCESS) {
-				((MV_PU8)org_req->Sense_Info_Buffer)[1] = SCSI_SK_RECOVERED_ERROR;
-				((MV_PU8)org_req->Sense_Info_Buffer)[2] = SCSI_ASC_NO_ASC;
-				((MV_PU8)org_req->Sense_Info_Buffer)[3] = SCSI_ASCQ_ATA_PASSTHRU_INFO;
-				org_req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-			}
-		}
-
-		/* See ATA PASSTHRU STATUS RETURN DESCRIPTOR on top */
-		ata_return_descriptor[0] = 0x09;
-		ata_return_descriptor[1] = 0x0C;
-		if (org_req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_16)
-			ata_return_descriptor[2] = 0x01;
-		else
-			ata_return_descriptor[2] = 0;
-
-		reg = fis->dw1;
-
-		ata_return_descriptor[3] = (MV_U8)((reg >> 24) & 0xff);
-		ata_return_descriptor[13] = (MV_U8)((reg >> 16) & 0xff);
-
-		reg = fis->dw2;
-
-		ata_return_descriptor[7] = (MV_U8)(reg & 0xff);
-		ata_return_descriptor[9] = (MV_U8)((reg >> 8) & 0xff);
-		ata_return_descriptor[11] = (MV_U8)((reg >> 16) & 0xff);
-		ata_return_descriptor[12] = (MV_U8)((reg >> 24) & 0xff);
-
-		reg = fis->dw4;
-
-		ata_return_descriptor[5] = (MV_U8)(reg & 0xff);
-		if ((req->Scsi_Status == REQ_STATUS_SUCCESS)
-			&& (req->Cmd_Flag & CMD_FLAG_PIO)
-			&& (req->Cmd_Flag & CMD_FLAG_DATA_IN))
-			ata_return_descriptor[13] = (MV_U8)((reg >> 24) & 0xff);
-
-		if (req->Cmd_Flag & CMD_FLAG_48BIT) {
-			ata_return_descriptor[4] = (MV_U8)((reg >> 8) & 0xff);
-			reg = fis->dw3;
-			ata_return_descriptor[6] = (MV_U8)(reg & 0xff);
-			ata_return_descriptor[8] = (MV_U8)((reg >> 8) & 0xff);
-			ata_return_descriptor[10] = (MV_U8)((reg >> 16) & 0xff);
-		} else {
-			ata_return_descriptor[4] = 0;
-			ata_return_descriptor[6] = 0;
-			ata_return_descriptor[8] = 0;
-			ata_return_descriptor[10] = 0;
-		}
-		if (org_req->Sense_Info_Buffer_Length > 8)
-			MV_CopyMemory(&((MV_PU8)org_req->Sense_Info_Buffer)[8],
-				ata_return_descriptor,
-				MV_MIN(org_req->Sense_Info_Buffer_Length - 8, 14));
-	}
-}
-
-void scsi_ata_ata_passthru_12_fill_taskfile(MV_Request *req, MV_U8 tag,
-	ata_taskfile *taskfile)
-{
-	taskfile->command = req->Cdb[9];
-	taskfile->features = req->Cdb[3];
-	taskfile->device = req->Cdb[8];
-
-	taskfile->lba_low = req->Cdb[5];
-	taskfile->lba_mid = req->Cdb[6];
-	taskfile->lba_high = req->Cdb[7];
-	taskfile->sector_count = req->Cdb[4];
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = req->Cdb[11];
-
-	if (req->Cmd_Flag & CMD_FLAG_NCQ) {
-	/*For Read/Write FPDMA command by ATA PASS Through command,
-	  * replace the NCQ tag with ourselves to keep unique.*/
-		taskfile->sector_count = tag << 3;
-		taskfile->sector_count_exp = 0;
-	}
-}
-void scsi_ata_trim_request_fill_taskfile(MV_Request *req, ata_taskfile *taskfile)
-{
-	MV_ASSERT(!(req->Data_Transfer_Length%0x200));
-	taskfile->command = 0x06;
-	taskfile->features = 0x01;
-	taskfile->device = (MV_U8)MV_BIT(6);
-	taskfile->lba_low = 0;
-	taskfile->lba_mid = 0;
-	taskfile->lba_high = 0;
-	taskfile->sector_count =(MV_U8) (req->Data_Transfer_Length/0x200);
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-
-	taskfile->feature_exp = 0;
-	taskfile->control = 0;
-}
-
-void scsi_ata_ata_passthru_16_fill_taskfile(MV_Request *req, MV_U8 tag,
-	ata_taskfile *taskfile)
-{
-	taskfile->command = req->Cdb[14];
-	taskfile->features = req->Cdb[4];
-	taskfile->device = req->Cdb[13];
-
-	taskfile->lba_low = req->Cdb[8];
-	taskfile->lba_mid = req->Cdb[10];
-	taskfile->lba_high = req->Cdb[12];
-	taskfile->sector_count = req->Cdb[6];
-	taskfile->control = req->Cdb[15];
-
-	if (req->Cdb[1] & 0x01) {
-		taskfile->lba_low_exp = req->Cdb[7];
-		taskfile->lba_mid_exp = req->Cdb[9];
-		taskfile->lba_high_exp = req->Cdb[11];
-		taskfile->sector_count_exp = req->Cdb[5];
-		taskfile->feature_exp = req->Cdb[3];
-	} else {
-		taskfile->lba_low_exp = 0;
-		taskfile->lba_mid_exp = 0;
-		taskfile->lba_high_exp = 0;
-		taskfile->sector_count_exp = 0;
-		taskfile->feature_exp = 0;
-	}
-	if (req->Cmd_Flag & CMD_FLAG_NCQ) {
-	/*For Read/Write FPDMA command by ATA PASS Through command,
-	  * replace the NCQ tag with ourselves to keep unique.*/
-		taskfile->sector_count = tag << 3;
-		taskfile->sector_count_exp = 0;
-	}
-
-}
-
-/*
-   sat_replicate_req
-
-   Creates a new copy of the request for use in translation. Original request
-   is perserved through the orq_req pointer in the context.
-*/
-MV_Request *sat_replicate_req_for_ata_passthru(pl_root *root,
-			MV_Request *req,
-			MV_U32 new_buff_size,
-			MV_ReqCompletion completion)
-{
-	domain_device   *device;
-	core_context    *curr_ctx;
-	core_context    *new_ctx;
-	MV_Request      *new_req;
-	MV_U32          buff_size;
-	MV_PVOID        org_buf_ptr, new_buf_ptr;
-
-	curr_ctx = (core_context *)req->Context[MODULE_CORE];
-	device = (domain_device *)get_device_by_id(root->lib_dev,
-	req->Device_Id);
-
-	if (curr_ctx->type == CORE_CONTEXT_TYPE_ORG_REQ) {
-		MV_ASSERT(MV_FALSE);
-		return req;
-	}
-
-	new_req = get_intl_req_resource(root, new_buff_size);
-	if (new_req == NULL) {
-		return NULL;
-	}
-
-	sat_copy_request(new_req, req);
-
-	MV_LIST_HEAD_INIT(&new_req->Queue_Pointer);
-
-	new_req->Completion = completion;
-	new_ctx = (core_context *)new_req->Context[MODULE_CORE];
-	new_ctx->type = CORE_CONTEXT_TYPE_ORG_REQ;
-	new_ctx->u.org.org_req = req;
-
-	return new_req;
-}
-
-MV_U8 scsi_ata_ata_passthru_translation(domain_device *dev,
-        MV_Request *req)
-{
-	MV_Request *new_req;
-	core_context *new_ctx;
-	pl_root *root = dev->base.root;
-	domain_port *port = dev->base.port;
-	MV_U8 protocol, t_length, t_dir, byte, multi_rw, command;
-	MV_U32 length, tx_length = 0, cmd_flag = req->Cmd_Flag;
-	MV_PU8 buf_ptr;
-        MV_BOOLEAN data_out = MV_FALSE, data_in = MV_FALSE;
-
-	protocol = (req->Cdb[1] >> 1) & 0x0F;
-
-	switch (protocol) {
-	case ATA_PROTOCOL_HARD_RESET:
-		new_req = core_make_port_reset_req(root, port, dev,
-		        (MV_ReqCompletion)scsi_ata_translation_callback);
-
-		if (new_req == NULL) return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-		new_ctx = (core_context *)new_req->Context[MODULE_CORE];
-		new_ctx->type = CORE_CONTEXT_TYPE_ORG_REQ;
-		new_ctx->u.org.org_req = req;
-
-		core_append_request(root, new_req);
-		return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-	case ATA_PROTOCOL_SRST:
-		return (scsi_ata_api_request_translation(dev, req,
-			CDB_CORE_SOFT_RESET_1));
-	}
-
-	multi_rw = (req->Cdb[1] >> 5) & 0x7;
-	t_length = req->Cdb[2] & 0x3;
-	byte = (req->Cdb[2] >> 2) & 0x01;
-	t_dir = (req->Cdb[2] >> 3) & 0x1; /* 0: data out, 1: data in*/
-
-	if (req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_12) {
-		command = req->Cdb[9];
-		if (command == ATA_CMD_IDENTIFY_ATA && req->Cdb[4] == 0)
-			req->Cdb[4] = 1;
-	} else {
-		command = req->Cdb[14];
-		if (req->Cdb[1] & 0x01)
-			cmd_flag |= CMD_FLAG_48BIT;
-		else
-			cmd_flag &= ~CMD_FLAG_48BIT;
-		if (command == ATA_CMD_IDENTIFY_ATA && req->Cdb[6] == 0)
-			req->Cdb[6] = 1;
-	}
-
-	if (multi_rw != 0 && !IS_ATA_MULTIPLE_READ_WRITE(command))
-		goto ata_passthru_translation_error;
-
-	if (t_length != 0) {
-		if (t_dir == 0)
-			data_out = MV_TRUE;
-		else
-			data_in = MV_TRUE;
-	}
-
-	if (t_length == 0x0) {
-		tx_length = 0x0;
-	}
-	/* Transfer length defined in Features */
-	else if (t_length == 0x1) {
-		if (req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_12) {
-			tx_length = req->Cdb[3];
-		}
-		else {
-			/* Extend bit */
-			if (req->Cdb[1] & 1) {
-				tx_length = (req->Cdb[3] << 8) | req->Cdb[4];
-			}
-			else {
-				tx_length = req->Cdb[4];
-			}
-		}
-	}
-	/* Transfer length defined in Sector Count */
-	else if (t_length == 0x2) {
-		if (req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_12) {
-			tx_length = req->Cdb[4];
-		}
-		else {
-			/* Extend bit */
-			if (req->Cdb[1] & 1) {
-				tx_length = (req->Cdb[5] << 8) | req->Cdb[6];
-			}
-			else {
-				tx_length = req->Cdb[6];
-			}
-		}
-	}
-	/* t_length == 0x3 means use the length defined in the
-	  * nexus transaction */
-	else {
-		tx_length = req->Data_Transfer_Length;
-	}
-	if (req->Cdb[14] == ATA_CMD_DOWNLOAD_MICROCODE) {
-		/* download micro code transfer sector count in sector and lba_low.*/
-		tx_length = (req->Cdb[8] << 8) | req->Cdb[6];
-	}
-	if (byte) {
-		tx_length *= dev->sector_size;
-	}
-
-	switch (protocol) {
-	case ATA_PROTOCOL_NON_DATA:
-		if (t_length != 0) goto ata_passthru_translation_error;
-		break;
-
-	case ATA_PROTOCOL_PIO_IN:
-		if (data_in == MV_FALSE) goto ata_passthru_translation_error;
-		cmd_flag |= (CMD_FLAG_PIO | CMD_FLAG_DATA_IN);
-		break;
-
-	case ATA_PROTOCOL_PIO_OUT:
-		if (data_out == MV_FALSE) goto ata_passthru_translation_error;
-		cmd_flag |= (CMD_FLAG_PIO | CMD_FLAG_DATA_OUT);
-		break;
-
-	case ATA_PROTOCOL_DMA:
-		cmd_flag |= CMD_FLAG_DMA;
-		break;
-	case ATA_PROTOCOL_DMA_QUEUED:
-		cmd_flag |= (CMD_FLAG_DMA | CMD_FLAG_TCQ);
-		break;
-
-	case ATA_PROTOCOL_DEVICE_DIAG:
-	case ATA_PROTOCOL_DEVICE_RESET:
-		break;
-
-	case ATA_PROTOCOL_UDMA_IN:
-		if (data_in == MV_FALSE) goto ata_passthru_translation_error;
-		cmd_flag |= CMD_FLAG_DMA;
-		break;
-
-	case ATA_PROTOCOL_UDMA_OUT:
-                if (data_out == MV_FALSE) goto ata_passthru_translation_error;
-		cmd_flag |= CMD_FLAG_DMA;
-		break;
-
-	case ATA_PROTOCOL_FPDMA:
-		cmd_flag |= (CMD_FLAG_DMA | CMD_FLAG_NCQ);
-		break;
-
-	case ATA_PROTOCOL_RTN_INFO:
-		if ((req->Sense_Info_Buffer)
-			&& (req->Sense_Info_Buffer_Length > 8)) {
-
-			((MV_PU8)req->Sense_Info_Buffer)[0] = 0x72;
-			((MV_PU8)req->Sense_Info_Buffer)[7] = 0x0E;
-
-			MV_CopyMemory(&((MV_PU8)req->Sense_Info_Buffer)[8],
-				ata_return_descriptor,
-				MV_MIN(req->Sense_Info_Buffer_Length - 8, 14));
-		}
-		req->Scsi_Status = REQ_STATUS_HAS_SENSE;
-		return MV_QUEUE_COMMAND_RESULT_FINISHED;
-
-	default:
-		CORE_DPRINT(("Invalid ATA PASSTHRU Protocol %d\n", protocol));
-		goto ata_passthru_translation_error;
-	}
-
-	new_req = sat_replicate_req_for_ata_passthru(root, req, 0,
-		scsi_ata_translation_callback);
-
-	if (new_req == NULL) return MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;
-
-	new_req->Cmd_Flag = cmd_flag;
-	((core_context *)new_req->Context[MODULE_CORE])->buf_wrapper =
-		((core_context *)req->Context[MODULE_CORE])->buf_wrapper;
-	((core_context *)new_req->Context[MODULE_CORE])->req_flag |=
-		CORE_REQ_FLAG_NEED_D2H_FIS;
-
-	switch (req->Cdb[0] == SCSI_CMD_ATA_PASSTHRU_16 ? req->Cdb[14] : req->Cdb[9]) {
-	case ATA_CMD_SEC_PASSWORD:
-	case ATA_CMD_SEC_UNLOCK:
-	case ATA_CMD_SEC_ERASE_UNIT:
-	case ATA_CMD_SEC_DISABLE_PASSWORD:
-		tx_length = req->Data_Transfer_Length;
-		break;
-	default:
-		break;
-	}
-	if (tx_length > 0) {
-		new_req->Data_Buffer = req->Data_Buffer;
-		MV_DASSERT(tx_length <= req->SG_Table.Byte_Count);
-		new_req->Data_Transfer_Length = tx_length;
-		MV_CopyPartialSGTable(
-			&new_req->SG_Table,
-			&req->SG_Table,
-			0, /* offset */
-			tx_length /* size */
-			);
-	}
-
-	core_append_request(root, new_req);
-	return MV_QUEUE_COMMAND_RESULT_REPLACED;
-
-ata_passthru_translation_error:
-	scsi_ata_check_condition(req, SCSI_SK_ILLEGAL_REQUEST,
-		SCSI_ASC_INVALID_FEILD_IN_CDB, 0);
-	return MV_QUEUE_COMMAND_RESULT_FINISHED;
-}
-
-void scsi_ata_atapi_packet_fill_taskfile(domain_device *device,
-	MV_Request *req, ata_taskfile *taskfile)
-{
-	taskfile->features = 0;
-	taskfile->feature_exp = 0;
-
-	if (!bad_atapi_device_model(device)) {
-		if (req->Cmd_Flag & CMD_FLAG_DMA)
-		taskfile->features |= MV_BIT(0);
-	} else {
-		if (SCSI_IS_READ(req->Cdb[0]))
-		taskfile->features |= MV_BIT(0);
-	}
-	/* Byte count low and byte count high */
-	if (req->Data_Transfer_Length > 0xFFFF) {
-		taskfile->lba_mid = 0xFF;
-		taskfile->lba_high = 0xFF;
-	} else {
-		taskfile->lba_mid =
-		(MV_U8)req->Data_Transfer_Length;
-		taskfile->lba_high =
-		(MV_U8)(req->Data_Transfer_Length >> 8);
-	}
-
-	taskfile->command = ATA_CMD_PACKET;
-	taskfile->control = 0;
-	taskfile->device = MV_BIT(6);
-
-	taskfile->lba_low = 0;
-	taskfile->sector_count = 0;
-
-	taskfile->lba_low_exp = 0;
-	taskfile->lba_mid_exp = 0;
-	taskfile->lba_high_exp = 0;
-	taskfile->sector_count_exp = 0;
-}
-
-MV_U8 scsi_ata_translation(pl_root *root, MV_Request *req)
-{
-	core_extension *core = (core_extension *)root->core;
-	core_context *ctx = (core_context *)req->Context[MODULE_CORE];
-	domain_device *device = (domain_device *)get_device_by_id(
-	root->lib_dev, req->Device_Id);
-	MV_U8 ret = MV_QUEUE_COMMAND_RESULT_PASSED;
-
-	if (IS_ATAPI(device))
-		return ret;
-
-	if (ctx->type == CORE_CONTEXT_TYPE_ORG_REQ)
-		return ret;
-
-	switch (req->Cdb[0]) {
-	case SCSI_CMD_INQUIRY:
-		ret = scsi_ata_inquiry_translation(device, req);
-		break;
-	case SCSI_CMD_READ_CAPACITY_10:
-	case SCSI_CMD_READ_CAPACITY_16:
-		ret = scsi_ata_read_capacity_translation(device, req);
-		break;
-	case SCSI_CMD_START_STOP_UNIT:
-		ret = scsi_ata_start_stop_translation(device, req);
-		break;
-	case SCSI_CMD_FORMAT_UNIT:
-		ret = scsi_ata_format_unit_translation(device, req);
-		break;
-	case SCSI_CMD_REQUEST_SENSE:
-		ret = scsi_ata_request_sense_translation(device, req);
-		break;
-	case SCSI_CMD_LOG_SENSE:
-		ret = scsi_ata_log_sense_translation(device, req);
-		break;
-	case SCSI_CMD_SND_DIAG:
-		ret = scsi_ata_send_diag_translation(device, req);
-		break;
-	case SCSI_CMD_TEST_UNIT_READY:
-		ret = scsi_ata_test_unit_ready_translation(device, req);
-		break;
-	case SCSI_CMD_MODE_SELECT_6:
-	case SCSI_CMD_MODE_SELECT_10:
-		ret = scsi_ata_mode_select_translation(device, req);
-		break;
-	case SCSI_CMD_SYNCHRONIZE_CACHE_10:
-		ret = scsi_ata_sync_cache_translation(device, req);
-		break;
-	case SCSI_CMD_REASSIGN_BLOCKS:
-		ret = scsi_ata_reassign_blocks_translation(device, req);
-		break;
-	case SCSI_CMD_ATA_PASSTHRU_12:
-	case SCSI_CMD_ATA_PASSTHRU_16:
-		ret = scsi_ata_ata_passthru_translation(device, req);
-		break;
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		if (req->Cdb[1] != CDB_CORE_MODULE)
-			MV_DASSERT(MV_FALSE);
-		switch (req->Cdb[2]) {
-			case CDB_CORE_ENABLE_SMART:
-			case CDB_CORE_DISABLE_SMART:
-			ret = scsi_ata_enable_smart_translation(device, req);
-			break;
-			case CDB_CORE_OS_SMART_CMD:
-			ret = scsi_ata_os_smart_cmd_translation(device, req);
-			break;
-			case CDB_CORE_SMART_RETURN_STATUS:
-			ret = scsi_ata_smart_return_status_translation(device, req);
-			break;
-		}
-		break;
-		case APICDB0_PD:
-			switch (req->Cdb[1]) {
-			case APICDB1_PD_SETSETTING:
-			switch (req->Cdb[4]) {
-				case APICDB4_PD_SET_WRITE_CACHE_OFF:
-				ret = scsi_ata_api_request_translation(device,
-				req, CDB_CORE_DISABLE_WRITE_CACHE);
-				break;
-
-			case APICDB4_PD_SET_WRITE_CACHE_ON:
-				ret = scsi_ata_api_request_translation(device,
-				req, CDB_CORE_ENABLE_WRITE_CACHE);
-				break;
-
-			case APICDB4_PD_SET_SMART_OFF:
-				ret = scsi_ata_api_request_translation(device,
-				req, CDB_CORE_DISABLE_SMART);
-				break;
-
-			case APICDB4_PD_SET_SMART_ON:
-				ret = scsi_ata_api_request_translation(device,
-				req, CDB_CORE_ENABLE_SMART);
-				break;
-
-			default:
-				CORE_DPRINT(("Unsupported API PD Setting %d\n",\
-				req->Cdb[4]));
-
-				if (req->Sense_Info_Buffer != NULL &&
-					req->Sense_Info_Buffer_Length != 0)
-
-				((MV_PU8)req->Sense_Info_Buffer)[0]
-				= ERR_INVALID_PARAMETER;
-
-				req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-				ret = MV_QUEUE_COMMAND_RESULT_FINISHED;
-				break;
-			}
-			break;
-		case APICDB1_PD_GETSTATUS:
-			switch (req->Cdb[4]) {
-			case APICDB4_PD_SMART_RETURN_STATUS:
-				ret = scsi_ata_api_request_translation(device,
-				req, CDB_CORE_SMART_RETURN_STATUS);
-				break;
-			default:
-				CORE_DPRINT(("Unsupported API PD "\
-				"Get Status %d\n", req->Cdb[4]));
-
-				if (req->Sense_Info_Buffer != NULL &&
-					req->Sense_Info_Buffer_Length != 0)
-
-				((MV_PU8)req->Sense_Info_Buffer)[0]
-					= ERR_INVALID_PARAMETER;
-
-				req->Scsi_Status = REQ_STATUS_ERROR_WITH_SENSE;
-				ret = MV_QUEUE_COMMAND_RESULT_FINISHED;
-				break;
-			}
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return ret;
-}
-
-MV_BOOLEAN ata_fill_taskfile(domain_device *device, MV_Request *req,
-	MV_U8 tag, ata_taskfile *taskfile)
-{
-	switch (req->Cdb[0]) {
-	case SCSI_CMD_FORMAT_UNIT:
-		scsi_ata_format_unit_fill_taskfile(device, req, taskfile);
-		break;
-	case SCSI_CMD_INQUIRY:
-		scsi_ata_inquiry_fill_taskfile(req, taskfile);
-		break;
-	case SCSI_CMD_READ_6:
-	case SCSI_CMD_WRITE_6:
-	case SCSI_CMD_READ_10:
-	case SCSI_CMD_WRITE_10:
-	case SCSI_CMD_READ_16:
-	case SCSI_CMD_WRITE_16:
-		scsi_ata_read_write_fill_taskfile(req, tag, taskfile);
-		break;
-	case SCSI_CMD_READ_CAPACITY_10:
-	case SCSI_CMD_READ_CAPACITY_16:
-		scsi_ata_read_capacity_fill_taskfile(req, taskfile);
-		break;
-	case SCSI_CMD_VERIFY_10:
-	case SCSI_CMD_VERIFY_16:
-		scsi_ata_verify_fill_taskfile( req, taskfile );
-		break;
-	case SCSI_CMD_SYNCHRONIZE_CACHE_10:
-	case SCSI_CMD_SYNCHRONIZE_CACHE_16:
-		scsi_ata_sync_cache_fill_taskfile(device, req, taskfile);
-		break;
-	case SCSI_CMD_START_STOP_UNIT:
-		scsi_ata_start_stop_fill_taskfile(device, req, taskfile);
-		break;
-	case SCSI_CMD_TEST_UNIT_READY:
-		scsi_ata_test_unit_ready_fill_taskfile(req, taskfile);
-		break;
-	case SCSI_CMD_REQUEST_SENSE:
-		scsi_ata_request_sense_fill_taskfile(req, taskfile);
-		break;
-	case SCSI_CMD_LOG_SENSE:
-		scsi_ata_log_sense_fill_taskfile(req, taskfile);
-		break;
-	case SCSI_CMD_SND_DIAG:
-		scsi_ata_send_diag_fill_taskfile(device, req, taskfile);
-		break;
-	case SCSI_CMD_MODE_SELECT_6:
-	case SCSI_CMD_MODE_SELECT_10:
-		scsi_ata_mode_select_fill_taskfile(req, taskfile);
-		break;
-	case SCSI_CMD_REASSIGN_BLOCKS:
-		scsi_ata_reassign_blocks_fill_taskfile(req, taskfile);
-		break;
-	case SCSI_CMD_MODE_SENSE_6:
-	case SCSI_CMD_MODE_SENSE_10:
-		break;
-	case SCSI_CMD_ATA_PASSTHRU_12:
-		scsi_ata_ata_passthru_12_fill_taskfile(req, tag, taskfile);
-		break;
-	case SCSI_CMD_ATA_PASSTHRU_16:
-		scsi_ata_ata_passthru_16_fill_taskfile(req, tag, taskfile);
-		break;
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		if ( req->Cdb[1]!=CDB_CORE_MODULE )
-			return MV_FALSE;
-		switch (req->Cdb[2]) {
-		case CDB_CORE_SOFT_RESET_0:
-		case CDB_CORE_SOFT_RESET_1:
-			scsi_ata_soft_reset_fill_taskfile(req, taskfile);
-			break;
-		case CDB_CORE_IDENTIFY:
-			scsi_ata_core_identify_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_SET_UDMA_MODE:
-			scsi_ata_set_udma_mode_fill_taskfile(device, req, taskfile);
-			break;
-
-		case CDB_CORE_SET_PIO_MODE:
-			scsi_ata_set_pio_mode_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_ENABLE_WRITE_CACHE:
-		case CDB_CORE_DISABLE_WRITE_CACHE:
-			scsi_ata_write_cache_fill_taskfile(req, taskfile);
-			break;
-		case CDB_CORE_SET_FEATURE_SPINUP:
-			scsi_ata_pois_to_spinup_fill_taskfile(req, taskfile);
-			break;
-		case CDB_CORE_ENABLE_SMART:
-		case CDB_CORE_DISABLE_SMART:
-			scsi_ata_enable_smart_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_SMART_RETURN_STATUS:
-			scsi_ata_smart_return_status_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_SHUTDOWN:
-			scsi_ata_shudown_fill_taskfile(device, req, taskfile);
-			break;
-		case CDB_CORE_ENABLE_READ_AHEAD:
-		case CDB_CORE_DISABLE_READ_AHEAD:
-			scsi_ata_enable_read_ahead_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_READ_LOG_EXT:
-			scsi_ata_read_log_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_PM_READ_REG:
-			scsi_ata_pm_read_reg_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_OS_SMART_CMD:
-			scsi_ata_os_smart_cmd_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_PM_WRITE_REG:
-			scsi_ata_pm_write_reg_fill_taskfile(req, taskfile);
-			break;
-
-		case CDB_CORE_ATA_IDLE:
-			scsi_ata_fill_taskfile_cmd(req, taskfile,
-			        ATA_CMD_IDLE);
-			break;
-
-		case CDB_CORE_ATA_STANDBY:
-			scsi_ata_fill_taskfile_cmd(req, taskfile,
-			        ATA_CMD_STANDBY);
-			break;
-
-		case CDB_CORE_ATA_IDLE_IMMEDIATE:
-			scsi_ata_fill_taskfile_cmd(req, taskfile,
-			        ATA_CMD_IDLE_IMMEDIATE);
-			break;
-
-		case CDB_CORE_ATA_STANDBY_IMMEDIATE:
-			scsi_ata_fill_taskfile_cmd(req, taskfile,
-			        ATA_CMD_STANDBY_IMMEDIATE);
-			break;
-
-		default:
-			return MV_FALSE;
-		}
-		break;
-		CORE_DPRINT(("Error: Unknown request: 0x%x.\n", req->Cdb[0]));
-
-	default:
-		return MV_FALSE;
-	}
-	return MV_TRUE;
-}
-
-#define MAX_NUM_BAD_ATAPI_DEVICE	8
-#define BAD_ATAPI_DEVICE_MODEL_0	"PIONEER DVR-213N"
-
-typedef struct bad_atapi_device_model
-{
-	MV_U8 model_number[40];
-} atapi_device_model;
-
-MV_BOOLEAN bad_atapi_device_model(domain_device *device)
-{
-	atapi_device_model bad_mode[8];
-	MV_U8 i;
-	MV_FillMemory(bad_mode[0].model_number, 40 * sizeof(MV_U8), ' ');
-	MV_CopyMemory(bad_mode[0].model_number, BAD_ATAPI_DEVICE_MODEL_0,
-		sizeof(BAD_ATAPI_DEVICE_MODEL_0));
-
-	for (i=0;i <MAX_NUM_BAD_ATAPI_DEVICE; i++){
-		if(MV_CompareMemory(device->model_number, bad_mode[i].model_number,
-			40*sizeof(MV_U8)))
-			continue;
-		else
-			break;
-	}
-
-	if(i >= MAX_NUM_BAD_ATAPI_DEVICE)
-		return MV_FALSE;
-	else
-		return MV_TRUE;
-
-}
-
-MV_BOOLEAN atapi_fill_taskfile(domain_device *device, MV_Request *req,
-	ata_taskfile *taskfile)
-{
-	switch (req->Cdb[0]) {
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		if ( req->Cdb[1]!=CDB_CORE_MODULE )
-			return MV_FALSE;
-
-	switch (req->Cdb[2]) {
-		case CDB_CORE_SOFT_RESET_0:
-		case CDB_CORE_SOFT_RESET_1:
-		scsi_ata_soft_reset_fill_taskfile(req, taskfile);
-		break;
-
-	case CDB_CORE_IDENTIFY:
-		scsi_ata_core_identify_fill_taskfile(req, taskfile);
-		break;
-
-	case CDB_CORE_SET_UDMA_MODE:
-		scsi_ata_set_udma_mode_fill_taskfile(device, req, taskfile);
-		break;
-
-	case CDB_CORE_SET_PIO_MODE:
-		scsi_ata_set_pio_mode_fill_taskfile(req, taskfile);
-		break;
-
-	case CDB_CORE_PM_READ_REG:
-		scsi_ata_pm_read_reg_fill_taskfile(req, taskfile);
-		break;
-
-	case CDB_CORE_PM_WRITE_REG:
-		scsi_ata_pm_write_reg_fill_taskfile(req, taskfile);
-		break;
-	case CDB_CORE_OS_SMART_CMD:
-	default:
-		return MV_FALSE;
-	}
-	break;
-
-	case SCSI_CMD_INQUIRY:
-		if(req->Req_Type == REQ_TYPE_CORE)
-			scsi_atapi_core_identify_fill_taskfile(req, taskfile);
-		else
-			scsi_ata_atapi_packet_fill_taskfile(device, req, taskfile);
-		break;
-
-	case SCSI_CMD_READ_6:
-	case SCSI_CMD_WRITE_6:
-	case SCSI_CMD_READ_10:
-	case SCSI_CMD_WRITE_10:
-	case SCSI_CMD_VERIFY_10:
-	case SCSI_CMD_READ_CAPACITY_10:
-	case SCSI_CMD_TEST_UNIT_READY:
-	case SCSI_CMD_MODE_SENSE_10:
-	case SCSI_CMD_MODE_SELECT_10:
-	case SCSI_CMD_PREVENT_MEDIUM_REMOVAL:
-	case SCSI_CMD_READ_TOC:
-	case SCSI_CMD_BLANK:
-	case SCSI_CMD_READ_DISC_INFO:
-	case SCSI_CMD_START_STOP_UNIT:
-	case SCSI_CMD_SYNCHRONIZE_CACHE_10:
-	case SCSI_CMD_REQUEST_SENSE:
-	default:
-		scsi_ata_atapi_packet_fill_taskfile(device, req, taskfile);
-		break;
-	}
-
-	return MV_TRUE;
-}
-
-MV_VOID scsi_ata_translation_callback(MV_PVOID root_p, MV_Request *req)
-{
-	pl_root         *root = (pl_root *)root_p;
-	core_extension  *core = (core_extension *)root->core;
-	MV_U8           finished = MV_TRUE;
-	MV_Request      *org_req = sat_clear_org_req(req);
-	MV_U32          length;
-
-	MV_ASSERT(org_req != NULL);
-
-	switch (org_req->Cdb[0]) {
-		case SCSI_CMD_FORMAT_UNIT:
-		finished = scsi_ata_format_unit_callback(root,
-		                org_req, req);
-		break;
-	case SCSI_CMD_INQUIRY:
-		scsi_ata_inquiry_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_READ_CAPACITY_10:
-	case SCSI_CMD_READ_CAPACITY_16:
-		scsi_ata_read_capacity_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_SND_DIAG:
-		finished = scsi_ata_send_diag_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_START_STOP_UNIT:
-		finished = scsi_ata_start_stop_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_TEST_UNIT_READY:
-		scsi_ata_test_unit_ready_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_REQUEST_SENSE:
-		scsi_ata_request_sense_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_LOG_SENSE:
-		scsi_ata_log_sense_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_MODE_SELECT_6:
-	case SCSI_CMD_MODE_SELECT_10:
-		scsi_ata_mode_select_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_REASSIGN_BLOCKS:
-		finished = scsi_ata_reassign_blocks_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_ATA_PASSTHRU_12:
-	case SCSI_CMD_ATA_PASSTHRU_16:
-		scsi_ata_ata_passthru_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_SYNCHRONIZE_CACHE_10:
-		break;
-	case APICDB0_PD:
-		scsi_ata_api_request_callback(root, org_req, req);
-		break;
-	case SCSI_CMD_MARVELL_SPECIFIC:
-		if (org_req->Cdb[1] != CDB_CORE_MODULE)
-			MV_DASSERT(MV_FALSE);
-
-		switch (org_req->Cdb[2]) {
-		case CDB_CORE_ENABLE_SMART:
-		case CDB_CORE_DISABLE_SMART:
-			break;
-		case CDB_CORE_OS_SMART_CMD:
-			scsi_ata_os_smart_cmd_callback(root, org_req, req);
-			break;
-		case CDB_CORE_SMART_RETURN_STATUS:
-			scsi_ata_smart_return_status_callback(root, org_req, req);
-			break;
-		default:
-			MV_ASSERT(MV_FALSE);
-			break;
-		}
-		break;
-	default:
-		MV_ASSERT(MV_FALSE);
-		break;
-	}
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS)
-		core_generate_error_event(core, req);
-
-	if (finished) {
-		if (org_req->Scsi_Status == REQ_STATUS_PENDING)
-			org_req->Scsi_Status = req->Scsi_Status;
-		core_queue_completed_req(core, org_req);
-	}
-}
-
-/*
- * Translate SCSI command to SATA FIS
- * The following SCSI command set is the minimum required.
- *		Standard Inquiry
- *		Read Capacity
- *		Test Unit Ready
- *		Start/Stop Unit
- *		Read 10
- *		Write 10
- *		Request Sense
- *		Mode Sense/Select
- */
-MV_VOID scsi_to_sata_fis(MV_Request *req, MV_PVOID fis_pool,
-	ata_taskfile *taskfile, MV_U8 pm_port)
-{
-	sata_fis_reg_h2d *fis = (sata_fis_reg_h2d *)fis_pool;
-
-	fis->fis_type = SATA_FIS_TYPE_REG_H2D;
-	fis->cmd_pm = pm_port & 0x0f;
-	if (!(req->Cmd_Flag & CMD_FLAG_SOFT_RESET))
-		fis->cmd_pm |= H2D_COMMAND_SET_FLAG;
-	fis->command = taskfile->command;
-	fis->features = taskfile->features;
-	fis->device = taskfile->device;
-	fis->control = taskfile->control;
-
-	fis->lba_low = taskfile->lba_low;
-	fis->lba_mid = taskfile->lba_mid;
-	fis->lba_high = taskfile->lba_high;
-	fis->sector_count = taskfile->sector_count;
-	fis->lba_low_exp = taskfile->lba_low_exp;
-	fis->lba_mid_exp = taskfile->lba_mid_exp;
-	fis->lba_high_exp = taskfile->lba_high_exp;
-	fis->features_exp = taskfile->feature_exp;
-	fis->sector_count_exp = taskfile->sector_count_exp;
-
-	fis->ICC = 0x0;
-	*((MV_PU32)&fis->reserved2[0]) = 0x0;
-}
--- a/drivers/scsi/vanir/core/scsi/core_sat.h
+++ /dev/null
@@ -1,76 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_SAT_H
-#define __CORE_SAT_H
-
-#include "mv_config.h"
-MV_BOOLEAN sat_categorize_cdb(pl_root *root, MV_Request *req);
-MV_U8 scsi_ata_translation(pl_root *root, MV_Request *req);
-MV_U8 sat_release_org_req(pl_root *root, MV_Request *req);
-MV_BOOLEAN ata_fill_taskfile(domain_device *device, MV_Request *req,
-	MV_U8 tag, ata_taskfile *taskfile);
-MV_BOOLEAN atapi_fill_taskfile(domain_device *device, MV_Request *req,
-	ata_taskfile *taskfile);
-MV_BOOLEAN passthru_fill_taskfile(MV_Request *req, ata_taskfile *taskfile);
-MV_VOID scsi_to_sata_fis(MV_Request *req, MV_PVOID fis_pool,
-	ata_taskfile *taskfile, MV_U8 pm_port);
-MV_VOID sat_make_sense(MV_PVOID root_p, MV_Request *req, MV_U8 status,
-        MV_U8 error, MV_U64 *lba);
-
-MV_Request *sat_get_org_req(MV_Request *req);
-MV_Request *sat_clear_org_req(MV_Request *req);
-
-/**************************************************************/
-/* buffer is sizeof mdPage_t */
-#define LOG_SENSE_WORK_BUFER_LEN 512
-
-/**************************************************************/
-/* Format Unit Scsi command translation
- */
-#define LBA_BLOCK_COUNT		256
-#define STANDARD_INQUIRY_LENGTH                 0x60
-#define ATA_RETURN_DESCRIPTOR_LENGTH            14
-#define MV_MAX_INTL_BUFFER_SIZE                 768
-
-enum _ATA_SEND_DIAGNOSTIC_STATE {
-        SEND_DIAGNOSTIC_START = 0,
-        SEND_DIAGNOSTIC_SMART,
-        SEND_DIAGNOSTIC_VERIFY_0,
-        SEND_DIAGNOSTIC_VERIFY_MID,
-        SEND_DIAGNOSTIC_VERIFY_MAX,
-        SEND_DIAGNOSTIC_FINISHED
-};
-
-enum _ATA_START_STOP_STATE {
-        START_STOP_START = 0,
-        START_STOP_ACTIVE,
-        START_STOP_IDLE_IMMEDIATE_SYNC,
-        START_STOP_IDLE_IMMEDIATE,
-        START_STOP_STANDBY_IMMEDIATE_SYNC,
-        START_STOP_STANDBY_IMMEDIATE,
-        START_STOP_STANDBY_SYNC,
-        START_STOP_STANDBY,
-        START_STOP_EJECT,
-        START_STOP_FINISHED
-};
-
-enum _ATA_REASSIGN_BLOCKS_STATE {
-        REASSIGN_BLOCKS_ERROR = MV_BIT(31),
-};
-
-enum _ATA_FORMAT_UNIT_STATE {
-        FORMAT_UNIT_STARTED = 1,
-};
-
-#endif /* __CORE_SAT_H */
--- a/drivers/scsi/vanir/core/scsi/core_ses.c
+++ /dev/null
@@ -1,669 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "core_header.h"
-#include "core_util.h"
-#include "core_error.h"
-
-/*
- [ ReceiveDiagnostic	]
- SES_PG_CONFIGURATION
- (ConfigurationPageHeader),
-	( EnclosureDescriptorHeader	+ EnclosureDescriptor +	TypeDescriptorHeader )
- SES_PG_DEVICE_ELEMENT_STATUS
- (DeviceElementStatusPage),
-	( DeviceElementStatusDescriptorProtocolEIP0	+ DeviceElementStatusDescriptorEIP0	+ (	SASPhyDescriptor...	) )	/
-	( DeviceElementStatusDescriptorProtocolEIP1	+ DeviceElementStatusDescriptorEIP1	+ (	SASPhyDescriptor...	) )
- SES_PG_ELEMENT_DESCRIPTOR
- (ElementDescriptorPage),
-	ElementDescriptor
- SES_PG_ENCLOSURE_STATUS
- (EnclosureStatusPage),
-	DeviceElementForEnclosureStatusPage	/ ArrayElementForEnclosureStatusPage
-
- [ SendDiagnostic ]
- SES_PG_ENCLOSURE_CONTROL
- (EnclosureControlPage),
-	DeviceElementForEnclosureControlPage / ArrayElementForEnclosureControlPage
-*/
-
-void core_expander_set_led(
-	IN core_extension *core,
-	IN domain_device *device,
-	IN MV_U8 flag
-	);
-
-MV_Request *ses_make_receive_diagnostic_request(domain_enclosure *enc,MV_U8 page_code,
-	MV_ReqCompletion completion);
-
-#define	ses_make_check_support_page_request(a, callback) (ses_make_receive_diagnostic_request(a,SES_PG_SUPPORTED_DIAGNOSTICS,callback))
-#define	ses_make_configuration_request(a,callback)		(ses_make_receive_diagnostic_request(a,SES_PG_CONFIGURATION,callback))
-#define	ses_make_element_status_request(a,callback)		(ses_make_receive_diagnostic_request(a,SES_PG_DEVICE_ELEMENT_STATUS,callback))
-#define	ses_make_element_descriptor_request(a,callback)	(ses_make_receive_diagnostic_request(a,SES_PG_ELEMENT_DESCRIPTOR,callback))
-#define	ses_make_enclosure_status_request(a)		(ses_make_receive_diagnostic_request(a,SES_PG_ENCLOSURE_STATUS,ses_get_status_callback))
-
-#define LIST_ALL_ASSOCIATED_EXPANDER_TO_ENCLOSURE(expander, enclosure) LIST_FOR_EACH_ENTRY_TYPE(expander,&enclosure->expander_list, domain_expander,enclosure_queue_pointer)
-#define LIST_ALL_ASSOCIATED_DEVICE_TO_EXPANDER(device, expander) LIST_FOR_EACH_ENTRY_TYPE(device, &expander->device_list, domain_device,base.exp_queue_pointer)
-void ses_parse_supported_page(domain_enclosure *enc,	PMV_Request	req)
-{
-	MV_U8 *response = (MV_PU8)core_map_data_buffer(req);
-
-	enc->supported_page_count = response[3];
-	if (enc->supported_page_count > 32)
-		enc->supported_page_count = 32;
-	MV_CopyMemory(enc->supported_page,&response[4],enc->supported_page_count);
-
-	core_unmap_data_buffer(req);
-}
-MV_BOOLEAN ses_check_supported_page(domain_enclosure *enc, MV_U8 page_code)
-{
-	MV_U8 i;
-	if(page_code == SES_PG_SUPPORTED_DIAGNOSTICS)
-		return MV_TRUE;
-	for(i = 0; i < enc->supported_page_count; i++){
-		if(enc->supported_page[i] == page_code)
-			return MV_TRUE;
-	}
-	return MV_FALSE;
-}
-void ses_assign_device_element_number(domain_enclosure *enc,
-	sas_phy_descriptor *sas_phy_descriptor, MV_U8 element_index)
-{
-	pl_root *root = enc->base.root;
-	domain_device *device = NULL;
-	domain_expander *expander = NULL;
-	MV_U8 i;
-	MV_U64 val64;
-
-	LIST_ALL_ASSOCIATED_EXPANDER_TO_ENCLOSURE(expander, enc){
-		LIST_ALL_ASSOCIATED_DEVICE_TO_EXPANDER(device, expander){
-			U64_ASSIGN(val64, MV_CPU_TO_BE64(device->sas_addr));
-			if(MV_Equals((MV_U8 *)&val64, sas_phy_descriptor->sas_address, 8)){
-				device->ses_element_index = element_index;
-				device->enclosure = enc;
-				break;
-			}
-		}
-	}
-}
-
-void ses_parse_element_status_request(domain_enclosure *enc,	PMV_Request	req)
-{
-	device_element_status_page *element_status_page;
-	device_element_status_descriptor *element_status_descriptor;
-	sas_phy_descriptor *phy_descriptor;
-	MV_U16 page_length;
-	MV_U8 i, element_count, descriptor_count;
-
-	element_status_page = (device_element_status_page *)core_map_data_buffer(req);
-	page_length = (element_status_page->page_length[0]<<8) + element_status_page->page_length[1];
-
-	if ( (page_length+4)> (MV_U16)(req->Data_Transfer_Length))
-	{
-		CORE_DPRINT(("failed, 0x%x scratch memory is needed.\n", (page_length+4)));
-                core_unmap_data_buffer(req);
-		return;
-	}
-	element_status_descriptor = (device_element_status_descriptor *) ((MV_PTR_INTEGER)element_status_page +
-		sizeof(device_element_status_page));
-
-	element_count=0;
-	while ((MV_PTR_INTEGER)element_status_descriptor < ((MV_PTR_INTEGER)element_status_page+ page_length + 4)) {
-		if (!element_status_descriptor->eip0.invalid) {
-                /* SAS protocol, Device/Array descriptors */
-			if ((element_status_descriptor->eip0.protocol_id == 0x06) &&
-				(element_status_descriptor->eip0.descriptor_type == 0)) {
-				if (element_status_descriptor->eip0.b_eip) { /* EIP1 */
-					phy_descriptor = (sas_phy_descriptor *)((MV_PTR_INTEGER)element_status_descriptor +
-															sizeof(device_element_status_descriptor_eip1));
-					descriptor_count = element_status_descriptor->eip1.phy_descriptor_count;
-				}
-                                else { /*	EIP0 */
-					phy_descriptor = (sas_phy_descriptor *)((MV_PTR_INTEGER)element_status_descriptor +
-															sizeof(device_element_status_descriptor_eip0));
-					descriptor_count = element_status_descriptor->eip0.phy_descriptor_count;
-				}
-
-                                for (i = 0; i < descriptor_count; i++) {
-					if (element_status_descriptor->eip0.b_eip)
-						ses_assign_device_element_number(enc,phy_descriptor,element_status_descriptor->eip1.element_index);
-					else
-						ses_assign_device_element_number(enc,phy_descriptor,element_count);
-				}
-			}
-		}
-		element_count++;
-		element_status_descriptor = (device_element_status_descriptor *) ((MV_PTR_INTEGER)element_status_descriptor +
-				element_status_descriptor->eip0.device_element_status_descriptor_length + 2);
-	}
-        core_unmap_data_buffer(req);
-}
-
-void ses_assign_device_overall_element_number(domain_enclosure *enc,
-	MV_U8 element_index,	MV_U8 type_overall_count,	MV_U8 element_type)
-{
-	pl_root *root =enc->base.root;
-	domain_base *base= NULL;
-	domain_device *device;
-	MV_U16 i;
-
-	for(i=0; i<MAX_ID; i++){
-		base = get_device_by_id(root->lib_dev, i);
-		if((base == NULL)||(base->type !=  BASE_TYPE_DOMAIN_DEVICE))
-			continue;
-		device = (domain_device *)base;
-		if((device->ses_element_index == element_index)&&
-				(device->enclosure == enc)){
-				device->ses_overall_element_index = element_index + type_overall_count;
-				device->ses_element_type = element_type;
-				break;
-		}
-	}
-}
-
-
-MV_BOOLEAN ses_find_repeat_enclosure(domain_enclosure *enc,
-	 enclosure_descriptor *enclosure_descriptor)
-{
-	pl_root *root = enc->base.root;
-	domain_base *base = NULL;
-	domain_enclosure *temp_enc = NULL;
-	MV_U16 i;
-
-	for (i=0; i<MAX_ID; i++){
-		base = get_device_by_id(root->lib_dev, i);
-		if(base == NULL)
-			continue;
-		if(base->type == BASE_TYPE_DOMAIN_ENCLOSURE){
-			MV_U64 enclosure_logical_id = *((MV_U64 *)(&enclosure_descriptor->enclosure_logical_id[0]));
-			temp_enc = (domain_enclosure *)base;
-			if((enc != temp_enc)&&
-				(!MV_CompareMemory(temp_enc->enclosure_logical_id,
-						enclosure_descriptor->enclosure_logical_id, 8))){
-				if (enclosure_logical_id.value == 0)
-					return MV_FALSE;
-
-				CORE_DPRINT(("duplicate enc %016llX.\n",(*(MV_U64 *)temp_enc->enclosure_logical_id)));
-				if((enc->base.parent)&&
-					(enc->base.parent->type == BASE_TYPE_DOMAIN_EXPANDER))
-					((domain_expander *)enc->base.parent)->enclosure = temp_enc;
-					List_AddTail(&((domain_expander *)enc->base.parent)->enclosure_queue_pointer, &temp_enc->expander_list);
-				return MV_TRUE;
-			}
-		}
-	}
-	return MV_FALSE;
-}
-
-MV_BOOLEAN ses_parse_configuration_request(
-	domain_enclosure *enc,
-	PMV_Request	req
-)
-{
-	configuration_page_header *config_page;
-	enclosure_descriptor_header *enc_descriptor_head;
-	enclosure_descriptor *enc_descriptor;
-	type_descriptor_header *type_descriptor_head;
-	MV_U16 page_length;
-	MV_U8 i, j, element_type_count, element_count;
-
-	config_page = (configuration_page_header *)core_map_data_buffer(req);
-
-	page_length = (config_page->page_length[0]<<8) + config_page->page_length[1];
-
-	if ((page_length + 4) > (MV_U16)(req->Data_Transfer_Length)) {
-		CORE_PRINT(("MakeSesConfigurationRequest failed, 0x%x scratch memory is needed.\n", (page_length+4)));
-                core_unmap_data_buffer(req);
-		return MV_TRUE;
-	}
-
-	enc_descriptor_head = (enclosure_descriptor_header *) ((MV_PTR_INTEGER)	config_page	+
-		sizeof(configuration_page_header));
-	/* total enclosure number =	primary	+ SubEnclosure = 1+	SubEnclosureCount*/
-	element_type_count=0;
-	for(i=0;i<=config_page->subenclosure_count;i++){
-		element_type_count+=enc_descriptor_head->number_of_element_types_supported;
-		enc_descriptor = (enclosure_descriptor *) ((MV_PTR_INTEGER)	enc_descriptor_head +
-									sizeof(enclosure_descriptor_header) );
-		if (ses_find_repeat_enclosure(enc, enc_descriptor)){
-                     core_unmap_data_buffer(req);
-			return MV_FALSE;
-		}
-		MV_CopyMemory(enc->enclosure_logical_id,
-			enc_descriptor->enclosure_logical_id,
-			8);
-		MV_CopyMemory(enc->vendor_id,
-			enc_descriptor->enclosure_vendor_id,
-			8);
-		MV_CopyMemory(enc->product_id,
-			enc_descriptor->product_id,
-			16);
-		MV_CopyMemory(enc->product_revision,
-			enc_descriptor->product_revision_level,
-			4);
-
-		enc_descriptor_head=	(enclosure_descriptor_header *) ((MV_PTR_INTEGER)enc_descriptor +
-			enc_descriptor_head->enclosure_descriptor_length);
-	}
-
-	type_descriptor_head = (type_descriptor_header *)((MV_PTR_INTEGER) enc_descriptor_head);
-	element_count=0;
-	for	(i = 0;	i <	element_type_count; i++){
-		if( (type_descriptor_head->element_type==SES_TYPE_DEVICE) ||
-			(type_descriptor_head->element_type==SES_TYPE_ARRAY_DEVICE) ){
-			for (j=0; j<type_descriptor_head->number_of_possible_elements; j++)
-				ses_assign_device_overall_element_number(enc,
-					j,
-					element_count,
-					type_descriptor_head->element_type);
-		}
-		element_count += type_descriptor_head->number_of_possible_elements;
-		type_descriptor_head = (type_descriptor_header *)((MV_PTR_INTEGER)type_descriptor_head +
-			sizeof(type_descriptor_header));
-	}
-
-	core_unmap_data_buffer(req);
-	return MV_TRUE;
-}
-
-MV_U8 find_ascii_number(MV_U8 *string, MV_U16 length)
-{
-	MV_U8 sum=0xff;
-	MV_U16 i;
-
-	for(i=0;i<length;i++)
-	{
-		if((*(string+i)<='9')&&(*(string+i)>='0'))
-		{
-			if(sum==0xff) sum=0;
-			sum=sum*10 + *(string+i) - '0';
-		}
-		else if(sum!=0xff)
-		{
-			break;
-		}
-	}
-	return sum;
-}
-
-void ses_assign_element_slot_number(
-	domain_enclosure *enc,
-	MV_U8 overall_element_index,
-	MV_U8 slot_number
-)
-{
-	pl_root *root = enc->base.root;
-	domain_base *base= NULL;
-	domain_device *device;
-	MV_U16 i;
-
-	for(i=0; i<MAX_ID; i++){
-		base = get_device_by_id(root->lib_dev, i);
-		if((base == NULL)||(base->type !=  BASE_TYPE_DOMAIN_DEVICE))
-			continue;
-		device = (domain_device *)base;
-		if((device->enclosure == enc)&&
-				(device->ses_overall_element_index == overall_element_index)){
-				device->ses_slot_number = slot_number;
-				break;
-		}
-	}
-
-}
-
-void ses_parse_element_descriptor_request(
-	domain_enclosure *enc,
-	PMV_Request	req
-)
-{
-	element_descriptor_page *ele_descriptor_page;
-	element_descriptor *ele_descriptor;
-	MV_U16 page_length, desc_page_length;
-	MV_U8 element_count, slot_number;
-
-	ele_descriptor_page = (element_descriptor_page *)core_map_data_buffer(req);
-	page_length = (ele_descriptor_page->page_length[0]<<8) + ele_descriptor_page->page_length[1];
-
-	if ( (page_length+4)> (MV_U16)(req->Data_Transfer_Length)){
-		CORE_DPRINT(("failed, 0x%x scratch memory is needed.\n", (page_length+4)));
-                core_unmap_data_buffer(req);
-		return;
-	}
-	ele_descriptor = (element_descriptor *) ((MV_PTR_INTEGER)ele_descriptor_page +
-		sizeof(element_descriptor_page));
-
-	element_count=0;
-	while((MV_PTR_INTEGER)ele_descriptor<	((MV_PTR_INTEGER)ele_descriptor_page+ page_length + 4))
-	{
-		desc_page_length=	(ele_descriptor->descriptor_length[0]<<8) + ele_descriptor->descriptor_length[1];
-		slot_number = find_ascii_number((MV_U8 *)((MV_PTR_INTEGER)ele_descriptor + 4),desc_page_length);
-		ses_assign_element_slot_number(enc, element_count,slot_number);
-		element_count++;
-		ele_descriptor = (element_descriptor *) ((MV_PTR_INTEGER)ele_descriptor +
-			desc_page_length + 4);
-	}
-
-	core_unmap_data_buffer(req);
-}
-
-
-void ses_internal_req_callback(MV_PVOID root_p, PMV_Request req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_base *base = NULL;
-	domain_enclosure *enc = NULL;
-
-	base = get_device_by_id(root->lib_dev, req->Device_Id);
-	if(base == NULL)
-		return;
-	MV_ASSERT(base != NULL);
-	enc = (domain_enclosure *)base;
-
-	if (req->Scsi_Status != REQ_STATUS_SUCCESS) {
-		core_handle_init_error(root, base, req);
-		return;
-	}
-	if(req->Cdb[0]==SCSI_CMD_RCV_DIAG_RSLT) {
-		switch(req->Cdb[2]){
-		case SES_PG_SUPPORTED_DIAGNOSTICS:
-			ses_parse_supported_page(enc, req);
-			enc->state = ENCLOSURE_CHECK_SUPPORT_PAGE_DONE;
-			break;
-		case SES_PG_DEVICE_ELEMENT_STATUS:
-			ses_parse_element_status_request(enc,req);
-			enc->state = ENCLOSURE_GET_DEVICE_ELEMENT_DONE;
-			break;
-		case SES_PG_CONFIGURATION:
-			if (ses_parse_configuration_request(enc, req))
-				enc->state = ENCLOSURE_GET_CONFIGUATION_DONE;
-			else{
-				core_init_entry_done(root, base->port, NULL);
-				pal_set_down_enclosure(root, enc);
-				return;
-			}
-			break;
-		case SES_PG_ELEMENT_DESCRIPTOR:
-			ses_parse_element_descriptor_request(enc, req);
-			enc->state = ENCLOSURE_GET_ELEMENT_DISCRIPTER_DONE;
-			break;
-		}
-		core_queue_init_entry(root, base, MV_FALSE);
-	}
-
-}
-
-
-MV_BOOLEAN ses_state_machine(MV_PVOID enc_p)
-{
-	domain_enclosure *enc = (domain_enclosure *)enc_p;
-	pl_root *root = enc->base.root;
-	domain_port *port = enc->base.port;
-	PMV_Request req = NULL;
-
-	CORE_DPRINT(("enclosure state: 0x%x\n",enc->state));
-	switch(enc->state){
-	case ENCLOSURE_INQUIRY_DONE:
-		req = ses_make_check_support_page_request(enc, ses_internal_req_callback);
-		break;
-	case ENCLOSURE_CHECK_SUPPORT_PAGE_DONE:
-		if(ses_check_supported_page(enc, SES_PG_DEVICE_ELEMENT_STATUS) ) {
-			req = ses_make_element_status_request(enc,ses_internal_req_callback);
-			break;
-		} else
-			enc->state = ENCLOSURE_GET_DEVICE_ELEMENT_DONE;
-	case ENCLOSURE_GET_DEVICE_ELEMENT_DONE:
-		if(ses_check_supported_page(enc, SES_PG_CONFIGURATION) ) {
-			req = ses_make_configuration_request(enc,ses_internal_req_callback);
-			break;
-		} else
-			enc->state = ENCLOSURE_GET_CONFIGUATION_DONE;
-	case ENCLOSURE_GET_CONFIGUATION_DONE:
-		if(ses_check_supported_page(enc, SES_PG_ELEMENT_DESCRIPTOR) ) {
-			req = ses_make_element_descriptor_request(enc,ses_internal_req_callback);
-			break;
-		} else
-			enc->state = ENCLOSURE_GET_ELEMENT_DISCRIPTER_DONE;
-	case ENCLOSURE_GET_ELEMENT_DISCRIPTER_DONE:
-		enc->state = ENCLOSURE_INIT_DONE;
-	case ENCLOSURE_INIT_DONE:
-	default:
-		core_init_entry_done(root, port, &enc->base);
-		return MV_TRUE;
-	}
-	if (req != NULL) {
-		core_append_init_request(root, req);
-		return MV_TRUE;
-	} else {
-		return MV_FALSE;
-	}
-}
-
-MV_Request *ses_write_control_diagnostic_command(domain_enclosure *enc, MV_Request *org_req);
-void ses_get_status_callback(MV_PVOID root_p, PMV_Request req)
-{
-	pl_root *root = (pl_root *)root_p;
-	enclosure_status_page *enc_status_page;
-	MV_U16 page_length;
-	core_context *ctx = req->Context[MODULE_CORE];
-	domain_enclosure *enc = (domain_enclosure *)get_device_by_id(
-		root->lib_dev, req->Device_Id);
-	MV_Request *new_req = NULL;
-
-	if(req->Scsi_Status != REQ_STATUS_SUCCESS)
-		return;
-
-	enc_status_page = (enclosure_status_page *)core_map_data_buffer(req);
-	page_length = (enc_status_page->page_length[0]<<8) + enc_status_page->page_length[1];
-
-	if ( (page_length+4)> (MV_U16)(req->Data_Transfer_Length)) {
-		CORE_PRINT(("failed, 0x%x scratch memory is needed.\n", (page_length+4)));
-                core_unmap_data_buffer(req);
-		return;
-	}
-	new_req = ses_write_control_diagnostic_command(enc, req);
-	if(new_req == NULL){
-		CORE_DPRINT(("no resource for internal request\n"));
-                core_unmap_data_buffer(req);
-		return;
-	}
-
-	core_unmap_data_buffer(req);
-	core_append_request(root,new_req);
-}
-
-MV_Request *ses_make_receive_diagnostic_request(domain_enclosure *enc,MV_U8 page_code,
-	MV_ReqCompletion completion)
-{
-	pl_root *root = enc->base.root;
-	MV_Request	*req = get_intl_req_resource(root,SES_SCRATCH_BUFFER_SIZE);
-	core_context *ctx = NULL;
-
-	if( req == NULL ){
-		CORE_DPRINT(("ERROR: No more free internal requests. Request aborted.\n"));
-		return NULL;
-	}
-
-	req->Tag =	0xac;
-	ctx = req->Context[MODULE_CORE];
-	ctx->handler = enc->base.handler;
-
-	req->Device_Id	= enc->base.id;
-
-	req->Cmd_Flag = CMD_FLAG_DATA_IN;
-	req->Completion = completion;
-	MV_DASSERT(req->Data_Buffer != NULL);
-	/* Prepare read	receive	diagnostic result */
-	req->Cdb[0] = SCSI_CMD_RCV_DIAG_RSLT;
-	req->Cdb[1] = 0x01; /* PCV */
-	req->Cdb[2] = page_code;
-	req->Cdb[3] = (MV_U8)((req->Data_Transfer_Length&0xff00)>>8);
-	req->Cdb[4] = (MV_U8)(req->Data_Transfer_Length&0xff);
-
-	return req;
-}
-
-void ses_fill_enclosure_element_status(domain_enclosure *enc,
-	MV_U8 overall_element_index, ses_enclosure_element *element_status)
-{
-	pl_root *root = enc->base.root;
-	domain_device *device = NULL;
-	domain_base *base = NULL;
-	MV_U16 i;
-
-	for(i=0; i<MAX_ID; i++){
-		base = get_device_by_id(root->lib_dev, i);
-		if((base == NULL)||(base->type !=  BASE_TYPE_DOMAIN_DEVICE))
-			continue;
-		device = (domain_device *)base;
-		if((device->enclosure == enc)&&
-			(device->ses_overall_element_index == overall_element_index)){
-			switch(device->ses_request_flag){
-			case LED_FLAG_REBUILD:
-				if (device->ses_element_type == SES_TYPE_DEVICE){
-					element_status->device_type.control.select = 1;
-					element_status->device_type.control.request_identify = 1;
-				}else if (device->ses_element_type == SES_TYPE_ARRAY_DEVICE){
-					element_status->array_type.control.select = 1;
-					element_status->array_type.control.request_rebuild_remap = 1;
-				}
-				break;
-
-			case LED_FLAG_HOT_SPARE:
-				if (device->ses_element_type == SES_TYPE_DEVICE){
-					element_status->device_type.control.select = 1;
-					element_status->device_type.control.request_identify = 1;
-				}else if (device->ses_element_type == SES_TYPE_ARRAY_DEVICE){
-					element_status->array_type.control.select = 1;
-					element_status->array_type.control.request_hotspare = 1;
-				}
-				break;
-
-			case LED_FLAG_FAIL_DRIVE:
-				if (device->ses_element_type == SES_TYPE_DEVICE){
-					element_status->device_type.control.select = 1;
-					element_status->device_type.control.request_fault = 1;
-				}else if (device->ses_element_type == SES_TYPE_ARRAY_DEVICE){
-					element_status->array_type.control.select = 1;
-					element_status->array_type.control.request_fault = 1;
-				}
-				break;
-			case LED_FLAG_HOT_SPARE_OFF:
-				if(device->ses_element_type == SES_TYPE_DEVICE){
-					element_status->device_type.control.select = 1;
-					element_status->device_type.control.request_identify = 0;
-				}else if(device->ses_element_type == SES_TYPE_ARRAY_DEVICE){
-					element_status->array_type.control.select = 1;
-					element_status->array_type.control.request_hotspare = 0;
-				}
-				break;
-			case LED_FLAG_OFF_ALL:
-				/* turn off all the lights that we currently control - if added more lights
-				 * in other sections, make sure to add them here for turning off */
-				if (device->ses_element_type == SES_TYPE_DEVICE){
-					element_status->device_type.control.select = 1;
-					element_status->device_type.control.request_identify = 0;
-					element_status->device_type.control.request_fault = 0;
-				}else if (device->ses_element_type == SES_TYPE_ARRAY_DEVICE){
-					element_status->array_type.control.select = 1;
-					element_status->array_type.control.request_identify = 0;
-					element_status->array_type.control.request_rebuild_remap = 0;
-					element_status->array_type.control.request_hotspare = 0;
-					element_status->array_type.control.request_fault = 0;
-				}
-				break;
-			}
-			break;
-		}
-	}
-}
-
-void ses_update_control_buffer(enclosure_control_page *control_page,
-	enclosure_status_page *status_page, MV_U16 page_length,
-	domain_enclosure *enc)
-{
-	MV_U8 element_count;
-	ses_enclosure_element *element_status;
-
-
-
-	element_status = (ses_enclosure_element *) ((MV_PTR_INTEGER)status_page +
-		sizeof(enclosure_status_page)+ sizeof(ses_enclosure_element));
-	element_count=0;
-	while((MV_PTR_INTEGER)element_status<	((MV_PTR_INTEGER)status_page+ page_length))
-	{
-		ses_fill_enclosure_element_status(enc, element_count, element_status);
-
-		element_count++;
-		element_status = (ses_enclosure_element *) ((MV_PTR_INTEGER)element_status +
-			sizeof(ses_enclosure_element));
-	}
-	MV_CopyMemory(control_page, status_page, page_length);
-}
-
-void ses_send_control_callback(MV_PVOID root_p, PMV_Request req)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_base *base = NULL;
-
-	base = get_device_by_id(root->lib_dev, req->Device_Id);
-	if(base == NULL){
-		CORE_PRINT(("enclosure has been removed\n"));
-		return;
-	}
-	if(req->Scsi_Status == REQ_STATUS_SUCCESS)
-		return;
-}
-MV_Request *ses_write_control_diagnostic_command(domain_enclosure *enc, MV_Request *org_req)
-{
-	pl_root *root = enc->base.root;
-	enclosure_status_page *enc_status_page;
-	enclosure_control_page *enc_control_page;
-	MV_U16 page_length;
-	PMV_Request	req=NULL;
-	core_context *ctx;
-
-	enc_status_page = (enclosure_status_page *)core_map_data_buffer(org_req);
-	page_length = (enc_status_page->page_length[0]<<8) + enc_status_page->page_length[1];
-
-	req = get_intl_req_resource(root, page_length+4);
-	if (req == NULL) {
-		CORE_DPRINT(("ERROR: No more free internal requests. Request aborted.\n"));
-                core_unmap_data_buffer(org_req);
-		return NULL;
-	}
-
-	enc_control_page = (enclosure_control_page *)core_map_data_buffer(req);
-	ses_update_control_buffer(enc_control_page, enc_status_page, page_length + 4, enc);
-
-	req->Tag = 0xac;
-
-	req->Device_Id	= enc->base.id;
-	ctx = req->Context[MODULE_CORE];
-	ctx->handler = enc->base.handler;
-
-	req->Cmd_Flag &= ~CMD_FLAG_DATA_IN;
-
-	req->Completion = (void(*)(MV_PVOID,PMV_Request))ses_send_control_callback;
-
-	/* Prepare send	diagnostic */
-	req->Cdb[0] = SCSI_CMD_SND_DIAG;
-	req->Cdb[1] = 0x10;  /* set PF bit to 1 */
-	req->Cdb[3] = (MV_U8)((req->Data_Transfer_Length&0xff00)>>8);
-	req->Cdb[4] = (MV_U8)(req->Data_Transfer_Length&0xff);
-
-	core_unmap_data_buffer(req);
-	core_unmap_data_buffer(org_req);
-
-	return req;
-
-}
--- a/drivers/scsi/vanir/core/scsi/core_ses.h
+++ /dev/null
@@ -1,424 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-/*
-[ ReceiveDiagnostic ]
-SES_PG_CONFIGURATION
-(ConfigurationPageHeader),
-    ( EnclosureDescriptorHeader + EnclosureDescriptor + TypeDescriptorHeader )
-
-SES_PG_DEVICE_ELEMENT_STATUS
-(DeviceElementStatusPage),
-    ( DeviceElementStatusDescriptorEIP0 + ( SASPhyDescriptor... ) ) /
-    ( DeviceElementStatusDescriptorEIP1 + ( SASPhyDescriptor... ) )
-
-SES_PG_ELEMENT_DESCRIPTOR
-(ElementDescriptorPage),
-    ElementDescriptor
-
-SES_PG_ENCLOSURE_STATUS
-(EnclosureStatusPage),
-    DeviceElementForEnclosureStatusPage / ArrayElementForEnclosureStatusPage
-
-
-
-
-[ SendDiagnostic ]
-SES_PG_ENCLOSURE_CONTROL
-(EnclosureControlPage),
-    DeviceElementForEnclosureControlPage / ArrayElementForEnclosureControlPage
-
-*/
-
-/* SES2 Page Code */
-#define SES_PG_SUPPORTED_DIAGNOSTICS      0x00
-#define SES_PG_CONFIGURATION              0x01
-#define SES_PG_ENCLOSURE_STATUS           0x02
-#define SES_PG_ENCLOSURE_CONTROL          0x02
-#define SES_PG_HELP_TEXT                  0x03
-#define SES_PG_STRING_IN                  0x04
-#define SES_PG_THRESHOLD_IN               0x05
-#define SES_PG_ELEMENT_DESCRIPTOR         0x07
-#define SES_PG_SHORT_ENCLOSURE_STATUS     0x08
-#define SES_PG_ENCLOSURE_BUSY             0x09
-#define SES_PG_DEVICE_ELEMENT_STATUS      0x0a
-#define SES_PG_SUBENCLOSURE_HELP_TEXT     0x0b
-#define SES_PG_SUBENCLOSURE_STRING_IN     0x0c
-#define SES_PG_SUPPORTED_SES_DIAGNOSTICS  0x0d
-#define SES_PG_VENDOR_SPECIFIC_SES_PAGE   0x10
-#define SES_PG_VENDOR_PAGEA0              0xa0
-
-/* Element Type */
-#define SES_TYPE_UNSPECIFIED         0x00
-#define SES_TYPE_DEVICE              0x01
-#define SES_TYPE_POWER_SUPPLY        0x02
-#define SES_TYPE_FAN                 0x03
-#define SES_TYPE_TEMPERATURE_SENSOR  0x04
-#define SES_TYPE_DOOR_LOCK           0x05
-#define SES_TYPE_SPEAKER             0x06
-#define SES_TYPE_ES_CONTROLLER       0x07
-#define SES_TYPE_SCC_CONTROLLER      0x08
-#define SES_TYPE_NONVOLATILE_CACHE   0x09
-#define SES_TYPE_UPS                 0x0B
-#define SES_TYPE_DISPLAY             0x0C
-#define SES_TYPE_KEYPAD              0x0D
-#define SES_TYPE_ENCLOSURE           0x0E
-#define SES_TYPE_SCSI_TRANSCEIVER    0x0F
-#define SES_TYPE_LANGUAGE            0x10
-#define SES_TYPE_COMM_PORT           0x11
-#define SES_TYPE_VOLTAGE_SENSOR      0x12
-#define SES_TYPE_CURRENT_SENSOR      0x13
-#define SES_TYPE_SCSI_TARGET_PORT    0x14
-#define SES_TYPE_SCSI_INITIATOR_PORT 0x15
-#define SES_TYPE_SIMPLE_SUBENCLOSURE 0x16
-#define SES_TYPE_ARRAY_DEVICE        0x17
-#define SES_TYPE_VENDOR_SPECIFIC     0x80
-
-
-	typedef struct _receive_diagnostic
-	{
-		MV_U8 operation_code;
-		MV_U8 pcv:1;
-		MV_U8 reserved:7;
-		MV_U8 page_code;
-		MV_U8 allocation_length[2];
-		MV_U8 control;
-	}receive_diagnostic;
-
-typedef struct _send_diagnostic
-{
-	MV_U8 operation_code;
-	MV_U8 unit_off_l:1;
-	MV_U8 dev_off_l:1;
-	MV_U8 self_test:1;
-	MV_U8 reserved:1;
-	MV_U8 pf:1;
-	MV_U8 self_test_code:3;
-	MV_U8 param_length[2];
-	MV_U8 control;
-}send_diagnostic;
-
-
-/* SES_PG_CONFIGURATION */
-typedef struct _configuration_page_header
-{
-	MV_U8 page_code;
-	MV_U8 subenclosure_count;
-	MV_U8 page_length[2];
-	MV_U8 generation_code[4];
-} configuration_page_header;
-
-typedef struct _enclosure_descriptor_header
-{
-	MV_U8 enclosure_service_processes_count:3;
-	MV_U8 reserved1:1;
-	MV_U8 relative_enclosure_service_process_id:3;
-	MV_U8 reserved2:1;
-	MV_U8 subenclosure_id;
-	MV_U8 number_of_element_types_supported;
-	MV_U8 enclosure_descriptor_length;
-
-} enclosure_descriptor_header;
-
-typedef struct _enclosure_descriptor
-{
-	MV_U8 enclosure_logical_id[8];
-	MV_U8 enclosure_vendor_id[8];
-	MV_U8 product_id[16];
-	MV_U8 product_revision_level[4];
-	MV_U8 vendor_specific;
-} enclosure_descriptor;
-
-typedef struct _type_descriptor_header
-{
-	MV_U8 element_type;
-	MV_U8 number_of_possible_elements;
-	MV_U8 subenclosure_id;
-	MV_U8 type_descriptor_text_length;
-} type_descriptor_header;
-
-
-/* SES_PG_DEVICE_ELEMENT_STATUS */
-typedef struct _device_element_status_page
-{
-	MV_U8 page_code;
-	MV_U8 reserved;
-	MV_U8 page_length[2];
-	MV_U8 generation_code[4];
-} device_element_status_page;
-
-typedef struct _device_element_status_descriptor_eip0
-{
-	MV_U8 protocol_id:4;
-	MV_U8 b_eip:1;
-	MV_U8 reserved1:2;
-	MV_U8 invalid:1;
-	MV_U8 device_element_status_descriptor_length;
-	MV_U8 phy_descriptor_count;
-	MV_U8 not_all_phys:1;
-	MV_U8 reserved2:5;
-	MV_U8 descriptor_type:2;
-} device_element_status_descriptor_eip0;
-
-typedef struct _device_element_status_descriptor_eip1
-{
-	MV_U8 protocol_id:4;
-	MV_U8 b_eip:1;
-	MV_U8 reserved1:2;
-	MV_U8 invalid:1;
-	MV_U8 device_element_status_descriptor_length;
-	MV_U8 reserved2;
-	MV_U8 element_index;
-	MV_U8 phy_descriptor_count;
-	MV_U8 not_all_phys:1;
-	MV_U8 reserved3:5;
-	MV_U8 descriptor_type:2;
-	MV_U8 reserved4;
-	MV_U8 bay_number;
-} device_element_status_descriptor_eip1;
-
-typedef union
-{
-	device_element_status_descriptor_eip0	eip0;
-	device_element_status_descriptor_eip1	eip1;
-}device_element_status_descriptor;
-
-typedef struct _sas_phy_descriptor
-{
-	MV_U8 reserved1:4;
-	MV_U8 device_type:3;
-	MV_U8 reserved2:1;
-	MV_U8 reserved3;
-	MV_U8 reserved4:1;
-	MV_U8 smp_initiator_port:1;
-	MV_U8 stp_initiator_port:1;
-	MV_U8 ssp_initiator_port:1;
-	MV_U8 reserved5:4;
-	MV_U8 reserved6:1;
-	MV_U8 smp_target_port:1;
-	MV_U8 stp_target_port:1;
-	MV_U8 ssp_target_port:1;
-	MV_U8 reserved7:4;
-	MV_U8 attached_sas_address[8];
-	MV_U8 sas_address[8];
-	MV_U8 phy_identifier;
-	MV_U8 reserved8[7];
-} sas_phy_descriptor;
-
-
-/* SES_PG_ELEMENT_DESCRIPTOR */
-typedef struct _element_descriptor_page
-{
-	MV_U8 page_code;
-	MV_U8 reserved1;
-	MV_U8 page_length[2];
-	MV_U8 generation_code[4];
-} element_descriptor_page;
-
-typedef struct _element_descriptor
-{
-	MV_U8 reserved1;
-	MV_U8 reserved2;
-	MV_U8 descriptor_length[2];
-	MV_U8 descriptor[1];
-} element_descriptor;
-
-
-/* SES_PG_ENCLOSURE_STATUS */
-typedef struct _overall_enclosure_status
-{
-	MV_U8 unrecoverable_condition:1;
-	MV_U8 critical_condition:1;
-	MV_U8 noncritical_condition:1;
-	MV_U8 information_condition:1;
-	MV_U8 invalid_operation_requested:1;
-	MV_U8 reserved1:3;
-} overall_enclosure_status;
-
-typedef struct _enclosure_status_page
-{
-	MV_U8 page_code;
-	overall_enclosure_status status;
-	MV_U8 page_length[2];
-	MV_U8 generation_code[4];
-} enclosure_status_page;
-
-typedef struct _device_element_for_enclosure_status_page
-{
-	MV_U8 element_status_code:4;
-	MV_U8 swap:1;
-	MV_U8 reserved1:1;
-	MV_U8 prdfail:1;
-	MV_U8 reserved2:1;
-
-	MV_U8 slot_address;
-
-	MV_U8 report:1;
-	MV_U8 ident:1;
-	MV_U8 rmv:1;
-	MV_U8 ready_to_insert:1;
-	MV_U8 enclosure_bypassed_b:1;
-	MV_U8 enclosure_bypassed_a:1;
-	MV_U8 do_not_remove:1;
-	MV_U8 app_client_bypassed_a:1;
-
-	MV_U8 device_bypassed_b:1;
-	MV_U8 device_bypassed_a:1;
-	MV_U8 bypassed_b:1;
-	MV_U8 bypassed_a:1;
-	MV_U8 device_off:1;
-	MV_U8 fault_reqstd:1;
-	MV_U8 fault_sensed:1;
-	MV_U8 app_client_bypassed_b:1;
-}device_element_for_enclosure_status_page;
-
-/* Element Status */
-enum
-{
-	SES_STATUS_UNSUPPORTED = 0x00,
-	SES_STATUS_OK,
-	SES_STATUS_CRITICAL,
-	SES_STATUS_NONCRITICAL,
-	SES_STATUS_UNRECOVERABLE,
-	SES_STATUS_NOTINSTALLED,
-	SES_STATUS_UNKNOWN,
-	SES_STATUS_NOTAVAILABLE,
-	SES_STATUS_RESERVED
-};
-
-
-typedef struct _array_element_for_enclosure_status_page
-{
-	MV_U8 status_code:4;
-	MV_U8 swap:1;
-	MV_U8 reserved1:1;
-	MV_U8 predicted_failure:1;
-	MV_U8 reserved2:1;
-
-	MV_U8 rebuild_remap_abort:1;
-	MV_U8 rebuild_remap:1;
-	MV_U8 in_failed_array:1;
-	MV_U8 in_critical_array:1;
-	MV_U8 consistency_check:1;
-	MV_U8 hot_spare:1;
-	MV_U8 reserved_device:1;
-	MV_U8 ok:1;
-
-	MV_U8 report:1;
-	MV_U8 identify:1;
-	MV_U8 rmv:1;
-	MV_U8 ready_to_insert:1;
-	MV_U8 enclosure_bypassed_b:1;
-	MV_U8 enclosure_bypassed_a:1;
-	MV_U8 do_not_remove:1;
-	MV_U8 app_bypassed_a:1;
-
-	MV_U8 device_bypassed_b:1;
-	MV_U8 device_bypassed_a:1;
-	MV_U8 bypassed_b:1;
-	MV_U8 bypassed_a:1;
-	MV_U8 device_off:1;
-	MV_U8 fault_requested:1;
-	MV_U8 fault_sensed:1;
-	MV_U8 app_bypassed_b:1;
-} array_element_for_enclosure_status_page;
-
-/* SES_PG_ENCLOSURE_CONTROL */
-typedef struct _enclosure_control_page
-{
-	MV_U8 page_code;
-	MV_U8 unrecoverable_condition:1;
-	MV_U8 critical_condition:1;
-	MV_U8 noncritical_condition:1;
-	MV_U8 information_condition:1;
-	MV_U8 reserved1:4;
-	MV_U8 page_length[2];
-	MV_U8 generation_code[4];
-} enclosure_control_page;
-
-typedef struct _device_element_for_enclosure_control_page
-{
-	MV_U8 reserved1:4;
-	MV_U8 reset_swap:1;
-	MV_U8 disable:1;
-	MV_U8 predicted_failure:1;
-	MV_U8 select:1;
-
-	MV_U8 reserved2;
-
-	MV_U8 reserved3:1;
-	MV_U8 request_identify:1;
-	MV_U8 request_remove:1;
-	MV_U8 request_insert:1;
-	MV_U8 reserved4:2;
-	MV_U8 do_not_remove:1;
-	MV_U8 active:1;
-
-	MV_U8 reserved5:2;
-	MV_U8 enable_bypass_b:1;
-	MV_U8 enable_bypass_a:1;
-	MV_U8 device_off:1;
-	MV_U8 request_fault:1;
-	MV_U8 reserved6:2;
-} device_element_for_enclosure_control_page;
-
-typedef struct _array_element_for_enclosure_control_page
-{
-	MV_U8 reserved1:4;
-	MV_U8 reset_swap:1;
-	MV_U8 pdisable:1;
-	MV_U8 predicted_failure:1;
-	MV_U8 select:1;
-
-	MV_U8 request_rebuild_remap_abort:1;
-	MV_U8 request_rebuild_remap:1;
-	MV_U8 request_in_failed_array:1;
-	MV_U8 request_in_critical_array:1;
-	MV_U8 request_consistency_check:1;
-	MV_U8 request_hotspare:1;
-	MV_U8 request_reserved_device:1;
-	MV_U8 request_ok:1;
-
-	MV_U8 reserved2:1;
-	MV_U8 request_identify:1;
-	MV_U8 request_remove:1;
-	MV_U8 request_insert:1;
-	MV_U8 reserved3:2;
-	MV_U8 do_not_remove:1;
-	MV_U8 active:1;
-
-	MV_U8 reserved4:2;
-	MV_U8 enable_bypass_b:1;
-	MV_U8 enable_bypass_a:1;
-	MV_U8 device_off:1;
-	MV_U8 request_fault:1;
-	MV_U8 reserved5:2;
-} array_element_for_enclosure_control_page;
-
-typedef union
-{
-	device_element_for_enclosure_status_page status;
-	device_element_for_enclosure_control_page control;
-}device_enclosure_element;
-
-typedef union
-{
-	array_element_for_enclosure_status_page status;
-	array_element_for_enclosure_control_page control;
-}array_enclosure_element;
-
-typedef union
-{
-	device_enclosure_element device_type;
-	array_enclosure_element array_type;
-}ses_enclosure_element;
--- a/drivers/scsi/vanir/hba_sm/hba_api.c
+++ /dev/null
@@ -1,381 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_include.h"
-
-#include "com_request_detail.h"
-#include "hba_api.h"
-#include "hba_exp.h"
-#include "hba_inter.h"
-
-#include "core_header.h"
-
-#define SMART_TAG  'gSMt'
-
-#define MvAllocatePool(Size)    \
-    hba_mem_alloc(Size, MV_FALSE)
-
-#define MvFreePool(Buffer, Size)    \
-    hba_mem_free(Buffer, Size, MV_FALSE)
-
-extern void Core_GetDeviceId(
-	MV_PVOID pModule,
-	MV_U16 begin_id,
-	PDevice_Index pDeviceIndex);
-
-#define SMART_STATUS_REQUEST_TIMER	100
-
-void HBA_SmartThresholdStatusCallback(MV_PVOID pModule, PMV_Request pMvReq)
-{
-	MV_U8 i = 0, nextDevice = 0;
-	get_device_id  func;
-	Device_Index DeviceIndex ;
-	PHD_SMART_Status_Request smart_buf;
-	PRAID_Feature praid_feature = (PRAID_Feature)pModule;
-	PHBA_Extension pHBA = (PHBA_Extension)praid_feature->pHBA;
-
-	void HBA_CheckSmartStatus (MV_PVOID ModulePointer, MV_PVOID temp);
-
-	nextDevice = (((MV_U16)pMvReq->Cdb[6]) << 8) | ((MV_U16)pMvReq->Cdb[5]);
-	nextDevice++;
-	{
-		func =  Core_GetDeviceId;
-	}
-	func(pHBA,nextDevice,&DeviceIndex);
-	while (!DeviceIndex.end) {
-			pMvReq->Cdb[0] = APICDB0_PD;
-			pMvReq->Cdb[1] = APICDB1_PD_GETSTATUS;
-			smart_buf = (PHD_SMART_Status_Request)pMvReq->Data_Buffer;
-			MV_ZeroMemory(&smart_buf->header, sizeof(RequestHeader));
-			smart_buf->header.startingIndexOrId = DeviceIndex.device_id;
-			smart_buf->header.requestType = REQUEST_BY_ID;
-			smart_buf->header.numRequested = 1;
-			MV_ZeroMemory(&smart_buf->hdSmartStatus, sizeof(HD_SMART_Status));
-			pMvReq->Data_Buffer = ( MV_PVOID )smart_buf;
-			pMvReq->Data_Transfer_Length = sizeof(HD_SMART_Status_Request);
-			pMvReq->Cdb[4] = APICDB4_PD_SMART_RETURN_STATUS;
-			pMvReq->Cdb[5] = (MV_U8)DeviceIndex.index;
-			pMvReq->Cdb[6] = (MV_U8)((DeviceIndex.index & 0xFF00) >> 8);
-			pMvReq->Device_Id = VIRTUAL_DEVICE_ID;
-
-			pMvReq->Scsi_Status = REQ_STATUS_PENDING;
-			pMvReq->Cmd_Flag = 0;
-			pMvReq->Cmd_Initiator = praid_feature;
-
-			praid_feature->pNextFunction( praid_feature->pNextExtension, pMvReq);
-			return;
-
-	}
-	if(pMvReq->Data_Buffer != NULL){
-		smart_buf = (PHD_SMART_Status_Request)pMvReq->Data_Buffer;
-		MvFreePool(smart_buf, sizeof(HD_SMART_Status_Request));
-		}
-	List_Add(&pMvReq->Queue_Pointer, &praid_feature->Internal_Request);
-	praid_feature->SMART_Status_Timer_Handle = Timer_AddRequest( pHBA, SMART_STATUS_REQUEST_TIMER, HBA_CheckSmartStatus , praid_feature, NULL);
-}
-
-
-void HBA_CheckSmartStatus (MV_PVOID pModule, MV_PVOID temp)
-{
-	MV_U16 id = 0;
-	get_device_id  func;
-	Device_Index DeviceIndex ;
-	PHD_SMART_Status_Request smart_buf;
-	PRAID_Feature praid_feature = (PRAID_Feature)pModule;
-	PHBA_Extension pHBA = (PHBA_Extension)praid_feature->pHBA;
-
-	{
-		func =  Core_GetDeviceId;
-	}
-	func(pHBA,id,&DeviceIndex);
-
-	while (!DeviceIndex.end) {
-		PMV_Request pMvReq = List_GetFirstEntry((&praid_feature->Internal_Request), MV_Request, Queue_Pointer);
-		if (pMvReq) {
-			pMvReq->Completion = HBA_SmartThresholdStatusCallback;
-			pMvReq->Cdb[0] = APICDB0_PD;
-			pMvReq->Cdb[1] = APICDB1_PD_GETSTATUS;
-			smart_buf = (PHD_SMART_Status_Request)MvAllocatePool(sizeof(HD_SMART_Status_Request));
-			if (smart_buf == NULL) {
-				MV_DPRINT(("Fail to get memory for HD_SMART_Status_Request!\n"));
-				return;
-			 }
-
-			MV_ZeroMemory(&smart_buf->header, sizeof(RequestHeader));
-			smart_buf->header.startingIndexOrId = DeviceIndex.device_id;
-			smart_buf->header.requestType = REQUEST_BY_ID;
-			smart_buf->header.numRequested = 1;
-			MV_ZeroMemory(&smart_buf->hdSmartStatus, sizeof(HD_SMART_Status));
-			pMvReq->Data_Buffer = ( MV_PVOID )smart_buf;
-			pMvReq->Data_Transfer_Length = sizeof(HD_SMART_Status_Request);
-			pMvReq->Cdb[4] = APICDB4_PD_SMART_RETURN_STATUS;
-			pMvReq->Cdb[5] = (MV_U8)DeviceIndex.index;
-			pMvReq->Cdb[6] = (MV_U8)((DeviceIndex.index & 0xFF00) >> 8);
-			pMvReq->Device_Id = VIRTUAL_DEVICE_ID;
-
-			pMvReq->Scsi_Status = REQ_STATUS_PENDING;
-			pMvReq->Cmd_Flag = 0;
-			pMvReq->Cmd_Initiator = praid_feature;
-
-			praid_feature->pNextFunction( praid_feature->pNextExtension, pMvReq);
-			return;
-		}
-	}
-	praid_feature->SMART_Status_Timer_Handle = Timer_AddRequest( pHBA, SMART_STATUS_REQUEST_TIMER, HBA_CheckSmartStatus , praid_feature, NULL);
-}
-
-
-void HBA_SmartOnCallback(MV_PVOID pModule, PMV_Request pMvReq)
-{
-	MV_U8 i = 0, nextDevice = 0;
-	get_device_id  func;
-	Device_Index DeviceIndex ;
-	PRAID_Feature praid_feature = (PRAID_Feature)pModule;
-	PHBA_Extension pHBA = (PHBA_Extension)praid_feature->pHBA;
-
-	nextDevice = (((MV_U16)pMvReq->Cdb[6]) << 8) | ((MV_U16)pMvReq->Cdb[5]);
-	nextDevice++;
-	func =  Core_GetDeviceId;
-	func(pHBA,nextDevice,&DeviceIndex );
-	while(!DeviceIndex.end){
-		pMvReq->Cdb[0] = APICDB0_PD;
-		pMvReq->Cdb[1] = APICDB1_PD_SETSETTING;
-		pMvReq->Cdb[2] = (MV_U8)DeviceIndex.device_id;
-		pMvReq->Cdb[3] = (MV_U8)((DeviceIndex.device_id & 0xFF00) >> 8);
-		pMvReq->Cdb[4] = APICDB4_PD_SET_SMART_ON;
-		pMvReq->Cdb[5] = (MV_U8)DeviceIndex.index;
-		pMvReq->Cdb[6] = (MV_U8)((DeviceIndex.index & 0xFF00) >> 8);
-		pMvReq->Device_Id = VIRTUAL_DEVICE_ID;
-
-		pMvReq->Scsi_Status = REQ_STATUS_PENDING;
-		pMvReq->Cmd_Flag = 0;
-		pMvReq->Cmd_Initiator = praid_feature;
-
-		praid_feature->pNextFunction( praid_feature->pNextExtension, pMvReq);
-		return;
-
-	}
-	 List_Add(&pMvReq->Queue_Pointer, &praid_feature->Internal_Request);
-}
-
-void hba_handle_set_smart(MV_PVOID pModule, PMV_Request pReq)
-{
-	get_device_id  func;
-	Device_Index DeviceIndex;
-	MV_U16 id = 0;
-	PAdapter_Config pAdapterConfig = NULL;
-	PMV_Request pTmpMvReq = NULL;
-	PRAID_Feature praid_feature = (PRAID_Feature)pModule;
-	PHBA_Extension pHBA = (PHBA_Extension)praid_feature->pHBA;
-
-	pAdapterConfig = (PAdapter_Config)pReq->Data_Buffer;
-	func =  Core_GetDeviceId;
-	func(pHBA,id,&DeviceIndex);
-
-	if (pAdapterConfig->PollSMARTStatus) {
-		if (praid_feature->SMART_Status_Timer_Handle != NO_CURRENT_TIMER) {
-				Timer_CancelRequest( pHBA, praid_feature->SMART_Status_Timer_Handle );
-		}
-		praid_feature->SMART_Status_Timer_Handle = NO_CURRENT_TIMER;
-		while(!DeviceIndex.end) {
-			pTmpMvReq = List_GetFirstEntry((&praid_feature->Internal_Request), MV_Request, Queue_Pointer);
-			if (pTmpMvReq) {
-				pTmpMvReq->Completion = HBA_SmartOnCallback;
-				pTmpMvReq->Cdb[0] = APICDB0_PD;
-				pTmpMvReq->Cdb[1] = APICDB1_PD_SETSETTING;
-				pTmpMvReq->Cdb[2] = (MV_U8)DeviceIndex.device_id;
-				pTmpMvReq->Cdb[3] = (MV_U8)((DeviceIndex.device_id & 0xFF00) >> 8);
-				pTmpMvReq->Cdb[4] = APICDB4_PD_SET_SMART_ON;
-				pTmpMvReq->Cdb[5] = (MV_U8)(DeviceIndex.index);
-				pTmpMvReq->Cdb[6] = (MV_U8)((DeviceIndex.index & 0xFF00) >> 8);
-				pTmpMvReq->Device_Id = VIRTUAL_DEVICE_ID;
-
-				pTmpMvReq->Scsi_Status = REQ_STATUS_PENDING;
-				pTmpMvReq->Cmd_Flag = 0;
-				pTmpMvReq->Cmd_Initiator = praid_feature;
-				praid_feature->pNextFunction( praid_feature->pNextExtension, pTmpMvReq);
-				break;
-			}
-		}
-		praid_feature->SMART_Status_Timer_Handle = Timer_AddRequest(pHBA, SMART_STATUS_REQUEST_TIMER,HBA_CheckSmartStatus, praid_feature, NULL);
-	} else {
-			if (praid_feature->SMART_Status_Timer_Handle != NO_CURRENT_TIMER)
-				Timer_CancelRequest( pHBA,praid_feature->SMART_Status_Timer_Handle );
-			praid_feature->SMART_Status_Timer_Handle = NO_CURRENT_TIMER;
-		}
-}
-
-void mvGetAdapterConfig( MV_PVOID This, PMV_Request pReq)
-{
-	HBA_Info_Page		HBA_Info_Param;
-	PRAID_Feature praid_feature = (PRAID_Feature)This;
-	PHBA_Extension pHBA = (PHBA_Extension)praid_feature->pHBA;
-	PAdapter_Config	pAdapterConfig = (PAdapter_Config)pReq->Data_Buffer;
-	PAdapter_Config_V2	pAdapterConfigV2 = NULL;
-
-	if ( pReq->Data_Transfer_Length>=sizeof(Adapter_Config_V2) )
-		pAdapterConfigV2 = (PAdapter_Config_V2)pAdapterConfig;
-
-	if ( mv_nvram_init_param(pHBA, &HBA_Info_Param) ) {
-		pAdapterConfigV2->InterruptCoalescing =
-				(HBA_Info_Param.HBA_Flag&HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY) ? MV_TRUE: MV_FALSE;
-		pAdapterConfigV2->PollSMARTStatus=
-				(HBA_Info_Param.HBA_Flag&HBA_FLAG_SMART_ON) ? MV_TRUE: MV_FALSE;
-		pAdapterConfigV2->AlarmOn =
-			(HBA_Info_Param.HBA_Flag & HBA_FLAG_ENABLE_BUZZER) ?
-				MV_TRUE : MV_FALSE;
-	} else {
-		pAdapterConfigV2->InterruptCoalescing = MV_FALSE;
-		if (praid_feature->SMART_Status_Timer_Handle != NO_CURRENT_TIMER)
-			pAdapterConfigV2->PollSMARTStatus = MV_TRUE;
-		else
-			pAdapterConfigV2->PollSMARTStatus = MV_FALSE;
-	}
-	if (pHBA->RunAsNonRAID)
-		pReq->Scsi_Status = REQ_STATUS_SUCCESS;
-	else
-		praid_feature->pNextFunction( praid_feature->pNextExtension, pReq );
-}
-
-void mvSetAdapterConfig( MV_PVOID This, PMV_Request pReq)
-{
-	HBA_Info_Page		HBA_Info_Param;
-	PRAID_Feature praid_feature = (PRAID_Feature)This;
-	PHBA_Extension pHBA = (PHBA_Extension)praid_feature->pHBA;
-	PAdapter_Config	pAdapterConfig = (PAdapter_Config)pReq->Data_Buffer;
-	PAdapter_Config_V2	pAdapterConfigV2 = NULL;
-	MV_BOOLEAN need_update = MV_FALSE;
-
-	if (pReq->Data_Transfer_Length>=sizeof(Adapter_Config_V2))
-		pAdapterConfigV2 = (PAdapter_Config_V2)pAdapterConfig;
-
-	if (mv_nvram_init_param(pHBA, &HBA_Info_Param)) {
-		if ( pAdapterConfigV2->InterruptCoalescing ) {
-			if ((HBA_Info_Param.HBA_Flag & HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY) == 0) {
-					HBA_Info_Param.HBA_Flag |= HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY;
-					need_update = MV_TRUE;
-				}
-			} else {
-				if (HBA_Info_Param.HBA_Flag & HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY) {
-					HBA_Info_Param.HBA_Flag &= ~HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY;
-					need_update = MV_TRUE;
-				}
-			}
-		if ( pAdapterConfigV2->PollSMARTStatus) {
-				if ((HBA_Info_Param.HBA_Flag & HBA_FLAG_SMART_ON) == 0) {
-					struct mod_notif_param param ={NULL,0,0,EVT_ID_SMART_FROM_OFF_TO_ON,0,SEVERITY_INFO,0,0,NULL,0};
-					HBA_Info_Param.HBA_Flag |= HBA_FLAG_SMART_ON;
-					HBA_ModuleNotification(pHBA,EVENT_LOG_GENERATED,&param);
-					need_update = MV_TRUE;
-				}
-			} else {
-				if (HBA_Info_Param.HBA_Flag & HBA_FLAG_SMART_ON) {
-					struct mod_notif_param param ={NULL,0,0,EVT_ID_SMART_FROM_ON_TO_OFF,0,SEVERITY_INFO,0,0,NULL,0};
-					HBA_Info_Param.HBA_Flag &= ~HBA_FLAG_SMART_ON;
-					HBA_ModuleNotification(pHBA, EVENT_LOG_GENERATED,&param);
-					need_update = MV_TRUE;
-				}
-			}
-		if (pAdapterConfigV2->AlarmOn == MV_TRUE) {
-			if ((HBA_Info_Param.HBA_Flag & HBA_FLAG_ENABLE_BUZZER) == 0) {
-				struct mod_notif_param param ={NULL,0,0,EVT_ID_ALARM_TURN_ON,0,SEVERITY_INFO,0,0,NULL,0};
-				HBA_Info_Param.HBA_Flag |= HBA_FLAG_ENABLE_BUZZER;
-				HBA_ModuleNotification(pHBA,EVENT_LOG_GENERATED,&param);
-				need_update = MV_TRUE;
-			}
-		} else {
-			if (HBA_Info_Param.HBA_Flag & HBA_FLAG_ENABLE_BUZZER) {
-				struct mod_notif_param param ={NULL,0,0,EVT_ID_ALARM_TURN_OFF,0,SEVERITY_INFO,0,0,NULL,0};
-				HBA_Info_Param.HBA_Flag &= ~HBA_FLAG_ENABLE_BUZZER;
-				HBA_ModuleNotification(pHBA, EVENT_LOG_GENERATED,&param);
-				need_update = MV_TRUE;
-			}
-		}
-		if (pAdapterConfigV2->SerialNo[0] != 0) {
-			MV_U32 i;
-			for(i=0; i<=20; i++)
-				HBA_Info_Param.Serial_Num[i] = pAdapterConfigV2->SerialNo[i];
-			need_update = MV_TRUE;
-		}
-
-		if (pAdapterConfigV2->ModelNumber[0] != 0) {
-			MV_U32 i;
-			for(i=0;i<=20;i++)
-				HBA_Info_Param.model_number[i] = pAdapterConfigV2->ModelNumber[i];
-			need_update = MV_TRUE;
-		}
-
-		if (need_update)
-			mvuiHBA_modify_param(pHBA,&HBA_Info_Param);
-	}
-
-	hba_handle_set_smart(praid_feature,pReq);
-	if(pHBA->RunAsNonRAID)
-		pReq->Scsi_Status = REQ_STATUS_SUCCESS;
-	else
-		praid_feature->pNextFunction( praid_feature->pNextExtension, pReq );
-
-}
-
-
-MV_U32 RAID_Feature_GetResourceQuota( MV_U16 maxIo)
-{
-	 MV_U32 size = 0;
-	if (maxIo==1)
-		size += sizeof(MV_SG_Entry) * MAX_SG_ENTRY_REDUCED * maxIo;
-	else
-		size += sizeof(MV_SG_Entry) * MAX_SG_ENTRY * maxIo;
-	size += maxIo * sizeof(MV_Request);
-	return size;
-}
-void RAID_Feature_Initialize(MV_PVOID This,MV_U16 maxIo)
-{
-	PRAID_Feature praid_feature = (PRAID_Feature)This;
-	PMV_Request pReq;
-	MV_U8 sgEntryCount;
-	MV_U16 i;
-	MV_PTR_INTEGER temp, tmpSG;
-
-	temp = (MV_PTR_INTEGER) This;
-	if (maxIo==1)
-		sgEntryCount = MAX_SG_ENTRY_REDUCED;
-	else
-		sgEntryCount = MAX_SG_ENTRY;
-	MV_LIST_HEAD_INIT(&praid_feature->Internal_Request);
-	tmpSG = temp;
-	temp = tmpSG + sizeof(MV_SG_Entry) * sgEntryCount * maxIo;
-	for ( i=0; i<maxIo; i++ ) {
-		pReq = (PMV_Request)temp;
-		MV_ZeroMemory(pReq, sizeof(MV_Request));
-		pReq->SG_Table.Entry_Ptr = (PMV_SG_Entry)tmpSG;
-		pReq->SG_Table.Max_Entry_Count = sgEntryCount;
-		List_AddTail(&pReq->Queue_Pointer, &praid_feature->Internal_Request);
-		temp += sizeof(MV_Request);
-		tmpSG += sizeof(MV_SG_Entry) * sgEntryCount;
-	}
-	return;
-}
-
-void RAID_Feature_SetSendFunction( MV_PVOID This,
-    MV_PVOID current_ext,
-    MV_PVOID next_ext,
-    MV_VOID (*next_function) (MV_PVOID, PMV_Request))
-{
-	PRAID_Feature praid_feature = (PRAID_Feature)This;
-	praid_feature->pUpperExtension = current_ext;
-	praid_feature->pNextExtension = next_ext;
-	praid_feature->pNextFunction = next_function;
-	praid_feature->pHBA = current_ext;
-	praid_feature->SMART_Status_Timer_Handle = NO_CURRENT_TIMER;
-	return;
-}
--- a/drivers/scsi/vanir/hba_sm/hba_api.h
+++ /dev/null
@@ -1,36 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef _HBA_API_H
-#define _HBA_API_H
-typedef struct _RAID_Feature
-{
-	List_Head Internal_Request;
-	MV_PVOID pHBA;
-	MV_PVOID pUpperExtension;
-	MV_PVOID pNextExtension;
-	MV_VOID (*pNextFunction) (MV_PVOID, PMV_Request);
-	MV_U16 SMART_Status_Timer_Handle;
-	MV_U8 reserved[2];
-
-} RAID_Feature, *PRAID_Feature;
-
-MV_U32 RAID_Feature_GetResourceQuota(MV_U16 maxIo);
-void RAID_Feature_Initialize(MV_PVOID This, MV_U16 maxIo);
-void RAID_Feature_SetSendFunction( MV_PVOID This,
-	MV_PVOID current_ext,
-	MV_PVOID next_ext,
-	MV_VOID (*next_function) (MV_PVOID, PMV_Request));
-void mvSetAdapterConfig( MV_PVOID This, PMV_Request pReq);
-void mvGetAdapterConfig( MV_PVOID This, PMV_Request pReq);
-#endif
--- a/drivers/scsi/vanir/hba_sm/mv_hba.h
+++ /dev/null
@@ -1,23 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_HBA_H__
-#define __MV_HBA_H__
-
-#define REQUEST_TIME_OUT				20
-
-#define MV_MAX_LUN_NUMBER               128
-#define VIRTUAL_DEVICE_ID            (MV_MAX_TARGET_NUMBER - 1)
-#define MV_MAX_HD_DEVICE_ID                   		MAX_DEVICE_SUPPORTED_PERFORMANCE
-
-#endif /*__MV_HBA_H__*/
--- a/drivers/scsi/vanir/include/com_dbg.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined(COMMON_DEBUG_H)
-#define COMMON_DEBUG_H
-
-/*
- *	Marvell Debug Interface
- *
- *	MACRO
- *		MV_DEBUG is defined in debug version not in release version.
- *
- *	Debug funtions:
- *		MV_PRINT:	print string in release and debug build.
- *		MV_DPRINT:	print string in debug build.
- *		MV_TRACE:	print string including file name, line number in release and debug build.
- *		MV_DTRACE:	print string including file name, line number in debug build.
- *		MV_ASSERT:	assert in release and debug build.
- *		MV_DASSERT: assert in debug build.
-  *		MV_WARNON: warn in debug build.
- */
-
-#include "com_define.h"
-/*
- *
- * Debug funtions
- *
- */
-#define MV_PRINT(format, arg...) 	ossw_printk(format,##arg);
-#define MV_ASSERT(_x_)  do{if (!(_x_)) MV_PRINT("ASSERT: function:%s, line:%d\n", __FUNCTION__, __LINE__);}while(0)
-#   define MV_TRACE(_x_)                                        \
-              do {                                              \
-                 MV_PRINT("%s(%d) ", __FILE__, __LINE__);       \
-                 MV_PRINT _x_;                                  \
-           } while(0)
-
-extern MV_U16 mv_debug_mode;
-#define MV_DPRINT(_x_)                do {\
-	if (mv_debug_mode & GENERAL_DEBUG_INFO) \
-	MV_PRINT _x_;\
-	} while (0)
-#define MV_DASSERT(x)	        do {\
-	if (mv_debug_mode & GENERAL_DEBUG_INFO) \
-	MV_ASSERT(x);\
-	} while (0)
-#define MV_DTRACE	        MV_DTRACE
-
-MV_BOOLEAN mvLogRegisterModule(MV_U8 moduleId, MV_U32 filterMask, char* name);
-MV_BOOLEAN mvLogSetModuleFilter(MV_U8 moduleId, MV_U32 filterMask);
-MV_U32 mvLogGetModuleFilter(MV_U8 moduleId);
-void mvLogMsg(MV_U8 moduleId, MV_U32 type, char* format, ...);
-
-#endif /* COMMON_DEBUG_H */
--- a/drivers/scsi/vanir/include/com_list.c
+++ /dev/null
@@ -1,374 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "com_define.h"
-#include "com_list.h"
-#include "com_dbg.h"
-/*
- * Insert a new entry between two known consecutive entries.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static MV_INLINE void __List_Add(List_Head *new_one,
-			      List_Head *prev,
-			      List_Head *next)
-{
-	if (unlikely(next->prev != prev)) {
-			MV_DPRINT(( "list_add corruption. next->prev should be "
-				"prev (0x%p), but was 0x%p. (next=0x%p).\n",
-				prev, next->prev, next));
-
-			MV_DPRINT(( "prev=0x%p, prev->next=0x%p,  prev->prev=0x%p"
-				"next=0x%p, next->next=0x%p, next->prev=0x%p.\n",
-				prev, prev->next, prev->prev, next, next->next, next->prev));
-
-		}
-		if (unlikely(prev->next != next)) {
-			MV_DPRINT(( "list_add corruption. prev->next should be "
-				"next (0x%p), but was 0x%p. (prev=0x%p).\n",
-				next, prev->next, prev));
-
-			MV_DPRINT(( "prev=0x%p, prev->next=0x%p,  prev->prev=0x%p,"
-				"next=0x%p, next->next=0x%p, next->prev=0x%p.\n",
-				prev, prev->next, prev->prev, next, next->next, next->prev));
-
-		}
-
-	next->prev = new_one;
-	new_one->next = next;
-	new_one->prev = prev;
-	prev->next = new_one;
-}
-
-/**
- * List_Add - add a new entry
- * @new_one: new entry to be added
- * @head: list head to add it after
- *
- * Insert a new entry after the specified head.
- * This is good for implementing stacks.
- */
-static MV_INLINE void List_Add(List_Head *new_one, List_Head *head)
-{
-	__List_Add(new_one, head, head->next);
-}
-
-static MV_INLINE void Counted_List_Add(List_Head *new_one, Counted_List_Head *head)
-{
-	List_Add(new_one, (List_Head *)head);
-	head->node_count++;
-}
-
-/**
- * List_AddTail - add a new entry
- * @new_one: new entry to be added
- * @head: list head to add it before
- *
- * Insert a new entry before the specified head.
- * This is useful for implementing queues.
- */
-static MV_INLINE void List_AddTail(List_Head *new_one, List_Head *head)
-{
-	__List_Add(new_one, head->prev, head);
-}
-
-static MV_INLINE void Counted_List_AddTail(List_Head *new_one, Counted_List_Head *head)
-{
-	List_AddTail(new_one, (List_Head *) head);
-	head->node_count++;
-}
-
-/*
- * Delete a list entry by making the prev/next entries
- * point to each other.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static MV_INLINE void __List_Del(List_Head * prev, List_Head * next)
-{
-	next->prev = prev;
-	prev->next = next;
-}
-
-/**
- * List_Del - deletes entry from list.
- * @entry: the element to delete from the list.
- * Note: List_Empty on entry does not return true after this, the entry is
- * in an undefined state.
- */
-static void List_Del(List_Head *entry)
-{
-	if(entry->prev && entry->prev){
-		if (unlikely(entry->prev->next != entry)) {
-                        MV_DASSERT(MV_FALSE);
-			MV_DPRINT(("list_del corruption. prev->next should be %p, "
-					"but was %p\n", entry, entry->prev->next));
-			MV_DPRINT(( "entry->next=%p, entry->next->next=%p,	entry->next->prev=%p.\n"
-					"entry->prev=%p, entry->prev->next=%p, entry->prev->prev=%p.\n",
-				entry->prev, entry->next->next, entry->next->prev, entry->prev, entry->prev->next, entry->prev->prev));
-
-		}
-		if (unlikely(entry->next->prev != entry)) {
-                        MV_DASSERT(MV_FALSE);
-			MV_DPRINT(( "list_del corruption. next->prev should be %p, "
-					"but was %p\n", entry, entry->next->prev));
-
-			MV_DPRINT(("entry->next=%p, entry->next->next=%p,  entry->next->prev=%p.\n"
-					"entry->prev=%p, entry->prev->next=%p, entry->prev->prev=%p.\n",
-				entry->next, entry->next->next, entry->next->prev, entry->prev, entry->prev->next, entry->prev->prev));
-
-		}
-	}
-
-	__List_Del(entry->prev, entry->next);
-	entry->next = NULL;
-	entry->prev = NULL;
-}
-
-static MV_INLINE void Counted_List_Del(List_Head *entry, Counted_List_Head *head)
-{
-	List_Del(entry);
-	head->node_count--;
-}
-
-
-/**
- * List_DelInit - deletes entry from list and reinitialize it.
- * @entry: the element to delete from the list.
- */
-static MV_INLINE void List_DelInit(List_Head *entry)
-{
-	__List_Del(entry->prev, entry->next);
-	MV_LIST_HEAD_INIT(entry);
-}
-
-/**
- * List_Move - delete from one list and add as another's head
- * @list: the entry to move
- * @head: the head that will precede our entry
- */
-static MV_INLINE void List_Move(List_Head *list, List_Head *head)
-{
-        __List_Del(list->prev, list->next);
-        List_Add(list, head);
-}
-
-/**
- * List_MoveTail - delete from one list and add as another's tail
- * @list: the entry to move
- * @head: the head that will follow our entry
- */
-static MV_INLINE void List_MoveTail(List_Head *list,
-				  List_Head *head)
-{
-        __List_Del(list->prev, list->next);
-        List_AddTail(list, head);
-}
-
-/**
- * List_Empty - tests whether a list is empty
- * @head: the list to test.
- */
-static MV_INLINE int List_Empty(const List_Head *head)
-{
-	return head->next == head;
-}
-
-static MV_INLINE int Counted_List_Empty(const Counted_List_Head *head)
-{
-	return (head->node_count == 0);
-}
-
-static MV_INLINE int List_GetCount(const List_Head *head)
-{
-	int i=0;
-	List_Head *pos;
-	LIST_FOR_EACH(pos, head) {
-		i++;
-	}
-	return i;
-}
-
-static MV_INLINE int Counted_List_GetCount(const Counted_List_Head *head, const MV_BOOLEAN traverse_list)
-{
-	int i=0;
-	List_Head *pos;
-
-	if (traverse_list) {
-		LIST_FOR_EACH(pos, head) {
-			i++;
-		}
-		return i;
-	}
-	else {
-		return head->node_count;
-	}
-}
-
-static MV_INLINE List_Head* List_GetFirst(List_Head *head)
-{
-	List_Head * one = NULL;
-	if ( List_Empty(head) ) return NULL;
-
-	one = head->next;
-	List_Del(one);
-	return one;
-}
-
-static MV_INLINE List_Head* Counted_List_GetFirst(Counted_List_Head *head)
-{
-	List_Head *one = NULL;
-	if ( Counted_List_Empty(head) ) return NULL;
-	one = head->next;
-	Counted_List_Del(one, head);
-	return one;
-}
-
-static MV_INLINE List_Head* List_GetLast(List_Head *head)
-{
-	List_Head * one = NULL;
-	if ( List_Empty(head) ) return NULL;
-
-	one = head->prev;
-	List_Del(one);
-	return one;
-}
-
-static MV_INLINE List_Head* Counted_List_GetLast(Counted_List_Head *head)
-{
-	List_Head * one = NULL;
-	if ( Counted_List_Empty(head) ) return NULL;
-
-	one = head->prev;
-	Counted_List_Del(one, head);
-	return one;
-}
-
-static MV_INLINE void __List_Splice(List_Head *list,
-	List_Head *head)
-{
-	List_Head *first = list->next;
-	List_Head *last = list->prev;
-	List_Head *at = head->next;
-
-	first->prev = head;
-	head->next = first;
-
-	last->next = at;
-	at->prev = last;
-}
-
-static MV_INLINE void __List_SpliceTail(List_Head *list,
-	List_Head *head)
-{
-	List_Head *first = list->next;
-	List_Head *last = list->prev;
-	List_Head *at = head->prev;
-
-	first->prev = at;
-	at->next = first;
-
-	last->next = head;
-	head->prev = last;
-}
-
-/**
- * List_Splice - join two lists
- * @list: the new list to add.
- * @head: the place to add it in the first list.
- */
-static MV_INLINE void List_Splice(List_Head *list, List_Head *head)
-{
-	if (!List_Empty(list))
-		__List_Splice(list, head);
-}
-
-/**
- * List_AddList - join two lists and reinitialise the emptied list.
- * @list: the new list to add.
- * @head: the place to add it in the first list.
- *
- * The list at @list is reinitialised
- */
-
-static MV_INLINE void List_AddList(List_Head *list,
-				 List_Head *head)
-{
-	if (!List_Empty(list)) {
-		__List_Splice(list, head);
-		MV_LIST_HEAD_INIT( list );
-	}
-}
-
-static MV_INLINE void List_AddCountedList(Counted_List_Head *list, List_Head *head)
-{
-	if (!Counted_List_Empty(list)) {
-		__List_Splice((List_Head *)list, head);
-		MV_COUNTED_LIST_HEAD_INIT( list );
-	}
-
-}
-
-static MV_INLINE void Counted_List_AddList(List_Head *list, Counted_List_Head *head)
-{
-	if (!List_Empty(list)) {
-		head->node_count += List_GetCount(list);
-		__List_Splice(list, (List_Head *) head);
-		MV_LIST_HEAD_INIT( list );
-	}
-}
-
-static MV_INLINE void Counted_List_AddCountedList(Counted_List_Head *list, Counted_List_Head *head)
-{
-	if (!Counted_List_Empty(list)) {
-		head->node_count += list->node_count;
-		__List_Splice((List_Head *)list, (List_Head *) head);
-		MV_COUNTED_LIST_HEAD_INIT( list );
-	}
-}
-
-static MV_INLINE void List_AddListTail(List_Head *list, List_Head *head)
-{
-	if (!List_Empty(list)) {
-		__List_SpliceTail(list, head);
-		MV_LIST_HEAD_INIT( list );
-	}
-}
-
-static MV_INLINE void List_AddCountedList_Tail(Counted_List_Head *list, List_Head *head)
-{
-	if (!Counted_List_Empty(list)) {
-		__List_SpliceTail((List_Head *) list, head);
-		MV_COUNTED_LIST_HEAD_INIT(list);
-	}
-}
-
-static MV_INLINE void Counted_List_AddList_Tail(List_Head *list, Counted_List_Head *head)
-{
-	if (!List_Empty(list)) {
-		head->node_count += List_GetCount(list);
-		__List_SpliceTail(list, (List_Head *) head);
-		MV_LIST_HEAD_INIT(list);
-	}
-}
-
-static MV_INLINE void Counted_List_AddCountedList_Tail(Counted_List_Head *list, Counted_List_Head *head)
-{
-	if (!Counted_List_Empty(list)) {
-		head->node_count += list->node_count;
-		__List_SpliceTail((List_Head *) list, (List_Head *) head);
-		MV_COUNTED_LIST_HEAD_INIT(list);
-	}
-}
--- a/drivers/scsi/vanir/include/com_list.h
+++ /dev/null
@@ -1,160 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined(COMMON_LIST_H)
-#define COMMON_LIST_H
-
-#include "com_define.h"
-
-/*
- * Simple doubly linked list implementation.
- *
- * Some of the internal functions ("__xxx") are useful when
- * manipulating whole lists rather than single entries, as
- * sometimes we already know the next/prev entries and we can
- * generate better code by using them directly rather than
- * using the generic single-entry routines.
- */
-
-
-/*
- *
- *
- * Data Structure
- *
- *
- */
-typedef struct _List_Head {
-	struct _List_Head *prev, *next;
-} List_Head, * PList_Head;
-
-typedef struct _Counted_List_Head {
-	struct _List_Head *prev, *next;
-	MV_U32 node_count;
-} Counted_List_Head, * PCounted_List_Head;
-
-/*
- *
- *
- * Exposed Functions
- *
- *
- */
-
-#define MV_LIST_HEAD(name) \
-	List_Head name = { &(name), &(name) }
-
-#define MV_LIST_HEAD_INIT(ptr) do { \
-	(ptr)->next = (ptr)->prev = (ptr); \
-} while (0)
-
-#define MV_COUNTED_LIST_HEAD_INIT(ptr) do { \
-	(ptr)->next = (ptr)->prev = (List_Head *)(ptr); \
-	(ptr)->node_count = 0; \
-} while (0)
-
-/**
- * LIST_ENTRY - get the struct for this entry
- * @ptr:	the &List_Head pointer.
- * @type:	the type of the struct this is embedded in.
- * @member:	the name of the list_struct within the struct.
- */
-
-#define CONTAINER_OF(ptr, type, member) 			\
-        ( (type *)( (char *)(ptr) - OFFSET_OF(type,member) ) )
-
-#define LIST_ENTRY(ptr, type, member) \
-	CONTAINER_OF(ptr, type, member)
-
-
-/**
- * LIST_FOR_EACH	-	iterate over a list
- * @pos:	the &List_Head to use as a loop counter.
- * @head:	the head for your list.
- */
-#define LIST_FOR_EACH(pos, head) \
-	for (pos = (head)->next; pos != (List_Head *)(head); pos = pos->next)
-
-/**
- * LIST_FOR_EACH_PREV	-	iterate over a list backwards
- * @pos:	the &List_Head to use as a loop counter.
- * @head:	the head for your list.
- */
-#define LIST_FOR_EACH_PREV(pos, head) \
-	for (pos = (head)->prev; pos != (List_Head *)(head); pos = pos->prev)
-
-/**
- * LIST_FOR_EACH_ENTRY	-	iterate over list of given type
- * @pos:	the type * to use as a loop counter.
- * @head:	the head for your list.
- * @member:	the name of the list_struct within the struct.
- */
-#define LIST_FOR_EACH_ENTRY(pos, head, member)				\
-	for (pos = LIST_ENTRY((head)->next, typeof(*pos), member);	\
-	     &pos->member != (List_Head *)(head); 	\
-	     pos = LIST_ENTRY(pos->member.next, typeof(*pos), member))
-
-/**
- * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
- * @pos:	the type * to use as a loop cursor.
- * @n:		another type * to use as temporary storage
- * @head:	the head for your list.
- * @member: the name of the list_struct within the struct.
- */
-#define LIST_FOR_EACH_ENTRY_SAFE(pos, n, head, member)			\
-			for (pos = LIST_ENTRY((head)->next, typeof(*pos), member),	\
-				n = LIST_ENTRY(pos->member.next, typeof(*pos), member); \
-				 &pos->member != (List_Head *) (head);					\
-				 pos = n, n = LIST_ENTRY(n->member.next, typeof(*n), member))
-
-
-
-/**
- * LIST_FOR_EACH_ENTRY_TYPE	-	iterate over list of given type
- * @pos:	the type * to use as a loop counter.
- * @head:	the head for your list.
- * @member:	the name of the list_struct within the struct.
- * @type:	the type of the struct this is embedded in.
-*/
-#define LIST_FOR_EACH_ENTRY_TYPE(pos, head, type, member)       \
-	for (pos = LIST_ENTRY((head)->next, type, member);	\
-	     &pos->member != (List_Head *) (head); 	                        \
-	     pos = LIST_ENTRY(pos->member.next, type, member))
-
-/**
- * LIST_FOR_EACH_ENTRY_PREV - iterate backwards over list of given type.
- * @pos:	the type * to use as a loop counter.
- * @head:	the head for your list.
- * @member:	the name of the list_struct within the struct.
- */
-#define LIST_FOR_EACH_ENTRY_PREV(pos, head, member)			\
-	for (pos = LIST_ENTRY((head)->prev, typeof(*pos), member);	\
-	     &pos->member != (List_Head *)(head); 	\
-	     pos = LIST_ENTRY(pos->member.prev, typeof(*pos), member))
-
-
-#include "com_list.c"
-
-#define List_GetFirstEntry(head, type, member)	\
-	LIST_ENTRY(List_GetFirst(head), type, member)
-
-#define Counted_List_GetFirstEntry(head, type, member) \
-	LIST_ENTRY(Counted_List_GetFirst(head), type, member)
-
-#define List_GetLastEntry(head, type, member)	\
-	LIST_ENTRY(List_GetLast(head), type, member)
-
-#define Counted_List_GetLastEntry(head, type, member) \
-	LIST_ENTRY(Counted_List_GetLast(head), type, member)
-
-#endif /* COMMON_LIST_H */
--- a/drivers/scsi/vanir/include/com_mod_mgmt.h
+++ /dev/null
@@ -1,107 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_MODULE_MGMT__
-#define __MV_MODULE_MGMT__
-
-#include "com_define.h"
-#include "com_type.h"
-#include "com_util.h"
-
-enum {
-	/* module status (module_descriptor) */
-	MV_MOD_VOID   = 0,
-	MV_MOD_UNINIT,
-	MV_MOD_REGISTERED,  /* module ops pointer registered */
-	MV_MOD_INITED,      /* resource assigned */
-	MV_MOD_FUNCTIONAL,
-	MV_MOD_STARTED,
-	MV_MOD_DEINIT,      /* extension released, be gone soon */
-	MV_MOD_GONE,
-};
-
-
-
-struct mv_mod_desc;
-
-
-struct mv_mod_res {
-	List_Head      res_entry;
-	MV_PHYSICAL_ADDR       bus_addr;
-	MV_PVOID               virt_addr;
-
-	MV_U32                 size;
-
-	MV_U16                 type;          /* enum Resource_Type */
-	MV_U16                 align;
-};
-
-typedef struct _Module_Interface
-{
-	MV_U8      module_id;
-	MV_U32     (*get_res_desc)(enum Resource_Type type, MV_U16 maxIo);
-	MV_VOID    (*module_initialize)(MV_PVOID extension,
-					MV_U32   size,
-					MV_U16   max_io);
-	MV_VOID    (*module_start)(MV_PVOID extension);
-	MV_VOID    (*module_stop)(MV_PVOID extension);
-	MV_VOID    (*module_notification)(MV_PVOID extension,
-					  enum Module_Event event,
-					  struct mod_notif_param *param);
-	MV_VOID    (*module_sendrequest)(MV_PVOID extension,
-					 PMV_Request pReq);
-	MV_VOID    (*module_reset)(MV_PVOID extension);
-	MV_VOID    (*module_monitor)(MV_PVOID extension);
-	MV_BOOLEAN (*module_service_isr)(MV_PVOID extension);
-} Module_Interface, *PModule_Interface;
-
-#define mv_module_ops _Module_Interface
-
-#define mv_set_mod_ops(_ops, _id, _get_res_desc, _init, _start,            \
-		       _stop, _send, _reset, _mon, _send_eh, _isr, _xor)   \
-           {                                                               \
-		   _ops->id                      = id;                     \
-		   _ops->get_res_desc            = _get_res_desc;          \
-		   _ops->module_initialize       = _init;                  \
-		   _ops->module_start            = _start;                 \
-		   _ops->module_stop             = _stop;                  \
-		   _ops->module_sendrequest      = _send;                  \
-		   _ops->module_reset            = _reset;                 \
-		   _ops->module_monitor          = _mon;                   \
-		   _ops->module_send_eh_request  = _send_eh;               \
-		   _ops->module_service_isr      = _isr;                   \
-		   _ops->module_send_xor_request = _xor;                   \
-	   }
-
-
-/* module descriptor */
-struct mv_mod_desc {
-	List_Head          mod_entry;      /* kept in a list */
-
-	struct mv_mod_desc         *parent;
-	struct mv_mod_desc         *child;
-
-	MV_U32                     extension_size;
-	MV_U8                      status;
-	MV_U8                      ref_count;
-	MV_U8                      module_id;
-	MV_U8                      res_entry;
-
-	MV_PVOID                   extension;      /* module extention */
-	struct mv_module_ops       *ops;           /* interface operations */
-
-	struct mv_adp_desc         *hba_desc;
-	List_Head           res_list;
-};
-
-#endif /* __MV_MODULE_MGMT__ */
--- a/drivers/scsi/vanir/include/com_nvram.h
+++ /dev/null
@@ -1,259 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined(COM_NVRAM_H)
-#define COM_NVRAM_H
-typedef union {
-    struct {
-        MV_U32 low;
-        MV_U32 high;
-    } parts;
-    MV_U8       b[8];
-    MV_U16      w[4];
-    MV_U32      d[2];
-} SAS_ADDR, *PSAS_ADDR;
-
-/* Generate  PHY tunning parameters */
-typedef struct _PHY_TUNING {
-	MV_U8	Trans_Emphasis_En:1;			/* 1 bit,  transmitter emphasis enable  */
-	MV_U8	Trans_Emphasis_Amp:4;		    	/* 4 bits, transmitter emphasis amplitude */
-	MV_U8	Reserved_2bit_1:3;				/* 3 bits, reserved space */
-         MV_U8	Trans_Amp:5;					/* 5 bits, transmitter amplitude */
-	MV_U8	Trans_Amp_Adjust:2;			/* 2 bits, transmitter amplitude adjust */
-	MV_U8	Reserved_2bit_2:1;				/* 1 bit, 	reserved space */
-	MV_U8	Reserved[2];						/* 2 bytes, reserved space */
-} PHY_TUNING, *PPHY_TUNING;
-
-typedef struct _FFE_CONTROL {
-	MV_U8	FFE_Capacitor_Select:4;			/* 4 bits,  FFE Capacitor Select  (value range 0~F)  */
-	MV_U8	FFE_Resistor_Select	:3;		    /* 3 bits,  FFE Resistor Select (value range 0~7) */
-	MV_U8	Reserved			:1;			/* 1 bit reserve*/
-} FFE_CONTROL, *pFFE_CONTROL;
-
-typedef struct _Mv_Phy_Status{
-	MV_U32	phy_id;
-	MV_U32	subtractive;
-	MV_U8	sas_address[8];
-	MV_U32	device_type;	//sata or sas
-	MV_U32	link_rate;
-}Mv_Phy_Status, *pMv_Phy_Status;
-
-
-/* HBA_FLAG_XX */
-#define HBA_FLAG_INT13_ENABLE				MV_BIT(0)	//int 13h enable/disable
-#define HBA_FLAG_SILENT_MODE_ENABLE			MV_BIT(1)	//silent mode enable/disable
-#define HBA_FLAG_ERROR_STOP					MV_BIT(2)	//if error then stop
-#define HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY	MV_BIT(3)	//if 1, enable interrupt coalescing, optimize CPU efficiency
-#define HBA_FLAG_AUTO_REBUILD_ON            MV_BIT(4) // auto rebuild on/off                                                   //XIN
-#define HBA_FLAG_SMART_ON					MV_BIT(6) // smart on/off
-#define HBA_FLAG_DISABLE_MOD_CONSOLIDATE	MV_BIT(7)	//if 1, disable module consolidation
-#define HBA_FLAG_ENABLE_BUZZER			MV_BIT(8)
-#define HBA_FLAG_SERIAL_CONSOLE_ENABLE			MV_BIT(9) //Bios enable or disable console redirection feature
-
-#define NVRAM_DATA_MAJOR_VERSION		0
-#define NVRAM_DATA_MINOR_VERSION		1
-
-/* for RAID_Feature */
-#define RAID_FEATURE_DISABLE_RAID5			MV_BIT(0)
-#define RAID_FEATURE_ENABLE_RAID			MV_BIT(1)
-
-/*
-	HBA_Info_Page is saved in Flash/NVRAM, total 256 bytes.
-	The data area is valid only Signature="MRVL".
-	If any member fills with 0xFF, the member is invalid.
-*/
-typedef struct _HBA_Info_Page{
-	// Dword 0
-	MV_U8     	Signature[4];                 	/* 4 bytes, structure signature,should be "MRVL" at first initial */
-
-	// Dword 1
-	MV_U8     	MinorRev;                 		/* 2 bytes, NVRAM data structure version */
-	MV_U8		MajorRev;
-	MV_U16    	Next_Page;					  	/* 2 bytes, For future data structure expansion, 0 is for NULL pointer and current page is the last page. */
-
-	// Dword 2
-	MV_U8     	Major;                   		/* 1 byte,  BIOS major version */
-	MV_U8     	Minor;                  		/* 1 byte,	BIOS minor version */
-	MV_U8     	OEM_Num;                     	/* 1 byte,  OEM number */
-	MV_U8     	Build_Num;                    	/* 1 byte,  Build number */
-
-	// Dword 3
-	MV_U8     	Page_Code;					  	/* 1 byte,  eg. 0 for the 1st page  */
-	MV_U8     	Max_PHY_Num;				  	/* 1 byte,   maximum PHY number */
-	MV_U8		RAID_Feature;					/* 1 byte,  RAID settings (see RAID_FEATURE_XX)
-															bit 0 - disable RAID 5 (default 1 = disabled)
-												*/
-	MV_U8		Reserved2;
-
-	// Dword 4
-	MV_U32     	HBA_Flag;                     	/* 4 bytes, should be 0x0000,0000 at first initial
-													HBA flag:  refers to HBA_FLAG_XX
-												*/
-	// Dword 5
-	MV_U32     	Boot_Device;					/* 4 bytes, select boot device */
-												/* for ata device, it is CRC of the serial number + model number. */
-												/* for sas device, it is CRC of sas address */
-												/* for VD, it is VD GUI */
-
-	// Dword 6-8
-	MV_U8		DSpinUpGroup;				/* spin up group */
-	MV_U8		DSpinUpTimer;				/* spin up timer */
-	MV_U8		Delay_Time;					/* delay time, default value = 5 second */
-       MV_U8           bbu_charge_threshold;
-       MV_U8           bbu_temp_lowerbound;
-       MV_U8           bbu_temp_upperbound;
-       MV_U16          bbu_volt_lowerbound;
-       MV_U16          bbu_volt_upperbound;
-	MV_U8		Reserved3[2];				  	/* 4 bytes, reserved	*/
-
-	// Dword 9-13
-	MV_U8     	Serial_Num[20];				  	/* 20 bytes, controller serial number */
-
-	// Dword 14-29
-	SAS_ADDR	SAS_Address[8];               /* 64 bytes, SAS address for each port */
-
-	// Dword 30-31
-	FFE_CONTROL  FFE_Control[8];			/* 8 bytes for vanir 8 port PHY FFE seeting
-										BIT 0~3 : FFE Capacitor select(value range 0~F)
-										BIT 4~6 : FFE Resistor select(value range 0~7)
-										BIT 7: reserve. */
-	//Dword 32 -33
-	MV_U8		Product_ID[8];			/* 8 bytes for vanir bios to differentiate VA6800m HBA and VA6400m HBA */
-
-	//Dword 34 -38
-	MV_U8		Reserved4[20];			/* 20 bytes, reserve space for future,initial as 0xFF */
-
-	//Dword 39 -43
-	MV_U8		  model_number[20];		 /* 20 bytes, Florence model name */
-
-	// Dword 44-45
-	MV_U8     	PHY_Rate[8];                  	/* 8 bytes,  0:  1.5G, 1: 3.0G, should be 0x01 at first initial */
-
-	// Dword 46-53
-	PHY_TUNING   PHY_Tuning[8];				/* 32 bytes, PHY tuning parameters for each PHY*/
-
-	// Dword 54-62
-	MV_U32     	Reserved5[7];                 	/* 9 dword, reserve space for future,initial as 0xFF */
-	MV_U8  		BGA_Rate;
-	MV_U8  		Sync_Rate;
-	MV_U8 		Init_Rate;
-	MV_U8  		Rebuild_Rate;
-	MV_U8  		Migration_Rate;
-	MV_U8  		Copyback_Rate;
-	MV_U8  		MP_Rate;
-	MV_U8     	Reserved7;
-	// Dword 63
-	MV_U8     	Reserved6[3];                 	/* 3 bytes, reserve space for future,initial as 0xFF */
-	MV_U8     	Check_Sum;                    	/* 1 byte,   checksum for this structure,Satisfy sum of every 8-bit value of this structure */
-}HBA_Info_Page, *pHBA_Info_Page;			/* total 256 bytes */
-
-#define FLASH_PARAM_SIZE 	(sizeof(HBA_Info_Page))
-#define ODIN_FLASH_SIZE		0x40000  				//.256k bytes
-#define PARAM_OFFSET		ODIN_FLASH_SIZE - 0x100 //.255k bytes
-
-// PD infomation Page
-#define FLASH_PD_INFO_PAGE_SIZE 	(sizeof(pd_info_page))
-#define PAGE_INTERVAL_DISTANCE		0x100
-
-#define PD_PAGE_PD_ID_INAVAILABLE 	0
-#define PD_PAGE_PD_ID_AVAILABLE 	1
-
-#define IS_PD_PAGE_PD_ID_AVAILABLE(flag) ((flag)==PD_PAGE_PD_ID_AVAILABLE)
-
-#define HBA_INFO_PAGE_CODE 0x00
-#define PD_INFO_PAGE_CODE 0x01
-
-#define PD_PAGE_PD_STATE_OFFLINE 0
-#define PD_PAGE_PD_STATE_ONLINE 1
-
-#define MAX_NUM_PD_PAGE	1
-
-#define PAGE_BUFFER_SIZE  (FLASH_PD_INFO_PAGE_SIZE+PAGE_INTERVAL_DISTANCE+FLASH_PARAM_SIZE)// total 0x1240 bytes(128 PDs); 0x2240 bytes(256 PDs)
-
-/* This number may not equal to MAX_DEVICE_SUPPORTED_PERFORMANCE */
-#define MAX_PD_IN_PD_PAGE_FLASH	128 // currently every PD page support 128 PD entry
-#define MAX_PD_IN_TOTAL_PD_PAGE		(MAX_PD_IN_PD_PAGE_FLASH * MAX_NUM_PD_PAGE)
-/*
-	PD_Info_Page is saved in Flash/NVRAM, currently total size is 0x1040 bytes.
-	The data area is valid only Signature="MRVL".
-	If any member fills with 0xFF, the member is invalid.
-*/
-
-typedef struct _Device_Index {
-	MV_U16	index;
-	MV_U16	device_id;
-	MV_BOOLEAN end;
-}Device_Index,*PDevice_Index;
-
-typedef void(*get_device_id) (MV_PVOID, MV_U16,PDevice_Index);
-
-typedef struct _pd_status_info {
-	MV_U16	pd_id;
-	MV_U8	status;
-	MV_U8	reserved;
-}pd_status_info,*p_pd_status_info;
-
-struct _pd_info {
-	// Dword 0-1
-	MV_U64	pd_guid;
-
-	// Dword 2
-	MV_U16	pd_id;
-	MV_U16	pd_scsi_id;
-
-	// Dword 3
-	MV_U8	status;
-	MV_U8	type;
-	MV_U8	cache_policy;
-	MV_U8	reserved1;
-
-	// Dword 4-7
-	MV_U8	reserved2[16];
-};
-
-typedef struct _page_header{
-	// Dword 0
-	MV_U8	signature[4];		/* 4 bytes, structure signature,should be "MRVL" at first initial */
-	// Dword 1
-	MV_U8	page_code;		/* 1 byte, page code , here should be 0x01  for PD info Page */
-	MV_U8	check_sum;		/* 1 byte,   checksum for this structure,Satisfy sum of every 8-bit value of this structure */
-	MV_U16	data_length; 		/* 2 byte, data length, indicates the size of invalid data besides page header */
-	// Dword 2
-	MV_U16	next_page;		/* 2 byte, next page  */
-	MV_U8	reserved[2];		/* 2 byte,   checksum for this structure,Satisfy sum of every 8-bit value of this structure */
-}page_header, *p_page_header;
-
-struct _pd_info_page{
-
-	page_header header;
-
-	MV_U8	reserved2[52];		/* 52 byte,   reserve space for future,initial as 0xFF */
-
-	struct _pd_info pd_info_data[MAX_PD_IN_PD_PAGE_FLASH]; /* MAX_PD_IN_PD_PAGE_FLASH*32 bytes, could save 128 PD data in flash */
-};
-
-typedef struct _pd_info pd_info, *p_pd_info;
-typedef struct _pd_info_page pd_info_page, *p_pd_info_page;
-
-extern MV_BOOLEAN mv_page_signature_check( MV_PU8 Signature );
-
-MV_BOOLEAN mv_nvram_init_param( MV_PVOID  This, pHBA_Info_Page pHBA_Info_Param );
-MV_BOOLEAN mv_nvram_moddesc_init_param( MV_PVOID This, pHBA_Info_Page pHBA_Info_Param);
-
-/* Caution: Calling this function, please do Read-Modify-Write.
- * Please call to get the original data first, then modify corresponding field,
- * Then you can call this function. */
-extern MV_BOOLEAN mvuiHBA_modify_param( MV_PVOID This, pHBA_Info_Page pHBA_Info_Param);
-extern MV_U8	mvCalculateChecksum(MV_PU8	Address, MV_U32 Size);
-extern MV_U8	mvVerifyChecksum(MV_PU8	Address, MV_U32 Size);
-#endif		/* COM_NVRAM_H */
--- a/drivers/scsi/vanir/include/com_scsi.h
+++ /dev/null
@@ -1,418 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_SCSI_H__
-#define __MV_COM_SCSI_H__
-
-/*
- * SCSI command
- */
-#define SCSI_CMD_INQUIRY                        0x12
-#define SCSI_CMD_START_STOP_UNIT                0x1B
-#define SCSI_CMD_TEST_UNIT_READY                0x00
-#define SCSI_CMD_RESERVE_6                      0x16
-#define SCSI_CMD_RELEASE_6                      0x17
-
-#define SCSI_CMD_READ_6                         0x08
-#define SCSI_CMD_READ_10                        0x28
-#define SCSI_CMD_READ_12                        0xA8
-#define SCSI_CMD_READ_16                        0x88
-#define SCSI_CMD_READ_LONG_10					0x3E
-
-#define SCSI_CMD_WRITE_6                        0x0A
-#define SCSI_CMD_WRITE_10                       0x2A
-#define SCSI_CMD_WRITE_12                       0xAA
-#define SCSI_CMD_WRITE_16                       0x8A
-#define SCSI_CMD_WRITE_LONG_10					0x3F
-
-#define SCSI_CMD_READ_CAPACITY_10               0x25
-#define SCSI_CMD_READ_CAPACITY_16               0x9E    /* 9Eh/10h */
-/* values for service action in */
-#define SCSI_CMD_SAI_READ_CAPACITY_16  			0x10
-
-#define SCSI_CMD_VERIFY_10                      0x2F
-#define SCSI_CMD_VERIFY_12                      0xAF
-#define SCSI_CMD_VERIFY_16                      0x8F
-
-#define SCSI_CMD_REQUEST_SENSE                  0x03
-#define SCSI_CMD_MODE_SENSE_6                   0x1A
-#define SCSI_CMD_MODE_SENSE_10                  0x5A
-#define SCSI_CMD_MODE_SELECT_6                  0x15
-#define SCSI_CMD_MODE_SELECT_10                 0x55
-
-#define SCSI_CMD_LOG_SELECT                     0x4C
-#define SCSI_CMD_LOG_SENSE                      0x4D
-
-#define SCSI_CMD_WRITE_VERIFY_10                0x2E
-#define SCSI_CMD_WRITE_VERIFY_12                0xAE
-#define SCSI_CMD_WRITE_VERIFY_16                0x8E
-#define SCSI_CMD_SYNCHRONIZE_CACHE_10           0x35
-#define SCSI_CMD_SYNCHRONIZE_CACHE_16			0x91
-
-#define SCSI_CMD_WRITE_SAME_10                  0x41
-#define SCSI_CMD_WRITE_SAME_16                  0x93
-
-#define SCSI_CMD_XDWRITE_10                     0x50
-#define SCSI_CMD_XPWRITE_10                     0x51
-#define SCSI_CMD_XDREAD_10                      0x52
-#define SCSI_CMD_XDWRITEREAD_10                 0x53
-
-#define SCSI_CMD_FORMAT_UNIT                    0x04
-
-#define SCSI_CMD_RCV_DIAG_RSLT                  0x1C
-#define SCSI_CMD_SND_DIAG                       0x1D
-#define SCSI_CMD_READ_DEFECT_DATA_10            0x37
-#define SCSI_CMD_REASSIGN_BLOCKS                0x07
-#define SCSI_CMD_ATA_PASSTHRU_12                0xA1
-#define SCSI_CMD_ATA_PASSTHRU_16                0x85
-#define SCSI_CMD_DEALLOCATED			0xEC
-	#define ATA_CMD_PM_CHECK 		0xE5
-#define IS_ATA_PASSTHRU_CMD(req,cmd)			\
-		(((req->Cdb[0]==SCSI_CMD_ATA_PASSTHRU_16) &&	\
-		(req->Cdb[14]==cmd))||		\
-		((req->Cdb[0]==SCSI_CMD_ATA_PASSTHRU_12) &&	\
-		(req->Cdb[9]==cmd)))
-
-
-#define IS_VU_CMD(req,cmd)			\
-		(((req->Cdb[0]== SCSI_CMD_ATA_PASSTHRU_16) &&	\
-		(req->Cdb[14]== SCSI_CMD_MARVELL_VENDOR_UNIQUE)   &&   \
-		(req->Cdb[4]== cmd))||		\
-		((req->Cdb[0]== SCSI_CMD_ATA_PASSTHRU_12) &&	\
-		(req->Cdb[9]== SCSI_CMD_MARVELL_VENDOR_UNIQUE) && \
-		(req->Cdb[3]== cmd)))
-
-/*	security commmand */
-#define ATA_CMD_SEC_PASSWORD			0xF1
-#define ATA_CMD_SEC_UNLOCK			0xF2
-#define ATA_CMD_SEC_ERASE_PRE			0xF3
-#define ATA_CMD_SEC_ERASE_UNIT			0xF4
-#define ATA_CMD_SEC_FREEZE_LOCK			0xF5
-#define ATA_CMD_SEC_DISABLE_PASSWORD		0xF6
-
-#define SCSI_CMD_PERSISTENT_RESERVE_IN			0x5E
-#define SCSI_CMD_PERSISTENT_RESERVE_OUT			0x5F
-
-/* MMC */
-#define SCSI_CMD_REPORT_LUN                     0xA0
-#define SCSI_CMD_PREVENT_MEDIUM_REMOVAL         0x1E
-#define SCSI_CMD_READ_SUB_CHANNEL               0x42
-#define SCSI_CMD_READ_TOC                       0x43
-#define SCSI_CMD_READ_DISC_STRUCTURE            0xAD
-#define SCSI_CMD_READ_CD                        0xBE
-#define SCSI_CMD_GET_EVENT_STATUS_NOTIFICATION  0x4A
-#define SCSI_CMD_BLANK                          0xA1
-#define SCSI_CMD_READ_DISC_INFO                 0x51
-
-/* SCSI Read/Write Buffer Command */
-#define SCSI_CMD_READ_BUFFER		0x3C
-#define SCSI_CMD_WRITE_BUFFER		0x3B
-
-#ifndef SMART_CMD
-#define SMART_CMD                               0xb0
-#endif /* SMART_CMD */
-
-#define SCSI_IS_READ(cmd)                       \
-           (((cmd) == SCSI_CMD_READ_6) ||       \
-	    ((cmd) == SCSI_CMD_READ_10)  ||     \
-            ((cmd) == SCSI_CMD_READ_12)  ||     \
-	    ((cmd) == SCSI_CMD_READ_16))
-
-#define SCSI_IS_WRITE(cmd)                      \
-           (((cmd) == SCSI_CMD_WRITE_6)  ||     \
-	    ((cmd) == SCSI_CMD_WRITE_10) ||     \
-	    ((cmd) == SCSI_CMD_WRITE_12) ||     \
-	    ((cmd) == SCSI_CMD_WRITE_16))
-
-#define SCSI_IS_MODE_SENSE(cmd)                 \
-           (((cmd) == SCSI_CMD_MODE_SENSE_6) || \
-	    ((cmd) == SCSI_CMD_MODE_SENSE_10))
-
-#define SCSI_IS_REQUEST_SENSE(cmd)              \
-           (((cmd) == SCSI_CMD_REQUEST_SENSE))
-
-#define SCSI_IS_VERIFY(cmd)                     \
-           (((cmd) == SCSI_CMD_VERIFY_10) ||    \
-	    ((cmd) == SCSI_CMD_VERIFY_16))
-
-#define SCSI_IS_READ_WRITE_VERIFY(cmd)			\
-		(SCSI_IS_READ(cmd) || SCSI_IS_WRITE(cmd) || SCSI_IS_VERIFY(cmd))
-#define SMP_CDB_USE_ADDRESS               0x01
-
-#define SCSI_CMD_MARVELL_SPECIFIC               0xE1
-#   define CDB_CORE_MODULE                      0x1
-#      define CDB_CORE_SOFT_RESET_1				0x1
-#      define CDB_CORE_SOFT_RESET_0				0x2
-#      define CDB_CORE_IDENTIFY                 0x3
-#      define CDB_CORE_SET_UDMA_MODE            0x4
-#      define CDB_CORE_SET_PIO_MODE             0x5
-#      define CDB_CORE_ENABLE_WRITE_CACHE       0x6
-#      define CDB_CORE_DISABLE_WRITE_CACHE      0x7
-#      define CDB_CORE_ENABLE_SMART             0x8
-#      define CDB_CORE_DISABLE_SMART            0x9
-#      define CDB_CORE_SMART_RETURN_STATUS      0xA
-#      define CDB_CORE_SHUTDOWN                 0xB
-#      define CDB_CORE_ENABLE_READ_AHEAD        0xC
-#      define CDB_CORE_DISABLE_READ_AHEAD       0xD
-#      define CDB_CORE_READ_LOG_EXT             0xE
-#      define CDB_CORE_TASK_MGMT                0xF
-#      define CDB_CORE_SMP                      0x10
-#      define CDB_CORE_PM_READ_REG				0x11
-#      define CDB_CORE_PM_WRITE_REG				0x12
-#	 define CDB_CORE_RESET_DEVICE				0x13
-#	 define CDB_CORE_RESET_PORT				0x14
-#      define CDB_CORE_OS_SMART_CMD				0x15
-
-#      define   CDB_CORE_ATA_IDENTIFY_ATA                            0x16
-#      define   CDB_CORE_ATA_IDENTIFY_ATAPI                         0x17
-#      define   CDB_CORE_ATA_SMART_READ_VALUES                 0x18
-#      define   CDB_CORE_ATA_SMART_READ_THRESHOLDS         0x19
-#      define   CDB_CORE_ATA_SMART_READ_LOG_SECTOR         0x1A
-#      define   CDB_CORE_ATA_SMART_WRITE_LOG_SECTOR       0x1B
-#      define   CDB_CORE_ATA_SMART_AUTO_OFFLINE                0x1C
-#      define   CDB_CORE_ATA_SMART_AUTOSAVE                       0x1D
-#      define   CDB_CORE_ATA_SMART_IMMEDIATE_OFFLINE      0x1E
-
-#      define  CDB_CORE_ATA_SLEEP                                 0x20
-#      define  CDB_CORE_ATA_IDLE                                   0x21
-#      define  CDB_CORE_ATA_STANDBY                            0x22
-#      define  CDB_CORE_ATA_IDLE_IMMEDIATE               0x23
-#      define  CDB_CORE_ATA_STANDBY_IMMEDIATE        0x24
-#      define  CDB_CORE_ATA_CHECK_POWER_MODE         0x25
-
-#      define CDB_CORE_SMP_VIRTUAL_DISCOVER          0x30
-#      define CDB_CORE_SMP_VIRTUAL_CONFIG_ROUTE      0x31
-#	define CDB_CORE_STP_VIRTUAL_PHY_RESET			0x32
-#	define CDB_CORE_STP_VIRTUAL_REPORT_SATA_PHY		0x33
-#	define CDB_CORE_SSP_VIRTUAL_PHY_RESET			0x34
-#	define CDB_CORE_SSP_VIRTUAL_REPORT_SATA_PHY		0x35
-#	define CDB_CORE_SMP_VIRTUAL_RESET_SATA_PHY		0x36
-#	define CDB_CORE_SMP_VIRTUAL_CLEAR_AFFILIATION_ALL	0x37
-
-#	define CDB_CORE_SET_FEATURE_SPINUP	0x40
-
-#define SCSI_CMD_MARVELL_VENDOR_UNIQUE         	0xFF
-#   define MARVELL_VU_CMD_CMD_PACKET_PHASE	0xFC
-#   define MARVELL_VU_CMD_DATA_TX_PHASE		0xFD
-#   define MARVELL_VU_CMD_ASYNC_NOTIFY          0xFE
-
-
-/* ANSI SCSI-3 Log Pages retrieved by LOG SENSE. */
-#define SUPPORTED_LPAGES                            0x00
-#define BUFFER_OVERRUN_LPAGE                        0x01
-#define WRITE_ERROR_COUNTER_LPAGE                   0x02
-#define READ_ERROR_COUNTER_LPAGE                    0x03
-#define READ_REVERSE_ERROR_COUNTER_LPAGE            0x04
-#define VERIFY_ERROR_COUNTER_LPAGE                  0x05
-#define NON_MEDIUM_ERROR_LPAGE                      0x06
-#define LAST_N_ERROR_LPAGE                          0x07
-#define FORMAT_STATUS_LPAGE                         0x08
-#define TEMPERATURE_LPAGE                           0x0d
-#define STARTSTOP_CYCLE_COUNTER_LPAGE               0x0e
-#define APPLICATION_CLIENT_LPAGE                    0x0f
-#define SELFTEST_RESULTS_LPAGE                      0x10
-#define BACKGROUND_RESULTS_LPAGE                    0x15   /* SBC-3 */
-#define IE_LPAGE                                    0x2f
-
-/* Seagate vendor specific log pages. */
-#define SEAGATE_CACHE_LPAGE                     0x37
-#define SEAGATE_FACTORY_LPAGE                 0x3e
-
-#define SCSI_IS_INTERNAL(cmd)        ((cmd) == SCSI_CMD_MARVELL_SPECIFIC)
-
-/*
- * SCSI status
- */
-#define SCSI_STATUS_GOOD                        0x00
-#define SCSI_STATUS_CHECK_CONDITION             0x02
-#define SCSI_STATUS_CONDITION_MET               0x04
-#define SCSI_STATUS_BUSY                        0x08
-#define SCSI_STATUS_INTERMEDIATE                0x10
-#define SCSI_STATUS_INTERMEDIATE_MET            0x14
-#define SCSI_STATUS_RESERVATION_CONFLICT        0x18
-#define SCSI_STATUS_FULL                        0x28
-#define SCSI_STATUS_ACA_ACTIVE                  0x30
-#define SCSI_STATUS_ABORTED                     0x40
-
-/*
- * SCSI sense key
- */
-#define SCSI_SK_NO_SENSE                        0x00
-#define SCSI_SK_RECOVERED_ERROR                 0x01
-#define SCSI_SK_NOT_READY                       0x02
-#define SCSI_SK_MEDIUM_ERROR                    0x03
-#define SCSI_SK_HARDWARE_ERROR                  0x04
-#define SCSI_SK_ILLEGAL_REQUEST                 0x05
-#define SCSI_SK_UNIT_ATTENTION                  0x06
-#define SCSI_SK_DATA_PROTECT                    0x07
-#define SCSI_SK_BLANK_CHECK                     0x08
-#define SCSI_SK_VENDOR_SPECIFIC                 0x09
-#define SCSI_SK_COPY_ABORTED                    0x0A
-#define SCSI_SK_ABORTED_COMMAND                 0x0B
-#define SCSI_SK_VOLUME_OVERFLOW                 0x0D
-#define SCSI_SK_MISCOMPARE                      0x0E
-/*
- * SCSI additional sense code
- */
-#define SCSI_ASC_NO_ASC                         0x00
-#define SCSI_ASC_LUN_NOT_READY                  0x04
-#define SCSI_ASC_LOGICAL_UNIT_NOT_RESP_TO_SEL	0x05
-#define SCSI_ASC_ECC_ERROR                      0x10
-#define SCSI_ASC_UNRECOVERED_READ_ERROR         0x11
-#define SCSI_ASC_ID_ADDR_MARK_NOT_FOUND         0x12
-#define SCSI_ASC_RECORD_NOT_FOUND               0x14
-#define SCSI_ASC_PARAMETER_LIST_LENGTH_ERROR	0x1A
-#define SCSI_ASC_INVALID_OPCODE                 0x20
-#define SCSI_ASC_LBA_OUT_OF_RANGE               0x21
-#define SCSI_ASC_INVALID_FEILD_IN_CDB           0x24
-#define SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED     0x25
-#define SCSI_ASC_INVALID_FIELD_IN_PARAMETER     0x26
-#define SCSI_ASC_WRITE_PROTECTED                0x27
-#define SCSI_ASC_MEDIA_CHANGED                  0x28
-
-#define SCSI_ASC_CMD_SEQUENCE_ERROR             0x2C
-#define SCSI_ASC_SAVING_PARAMETERS_NOT_SUPPORT  0x39
-#define SCSI_ASC_MEDIUM_NOT_PRESENT             0x3A
-#define SCSI_ASC_LOGICAL_UNIT_FAILURE           0x3E
-#define SCSI_ASC_INTERNAL_TARGET_FAILURE        0x44
-#define SCSI_ASC_SCSI_PARITY_ERROR              0x47
-#define SCSI_ASC_MISCOMPARE_DURING_VERIFY 			 0x1D
-#define SCSI_ASC_MEDIUM_FORMAT_CORRUPTED 	     0x31
-#define SCSI_ASC_MEDIA_LOAD_EJECT_FAILURE       0x53
-#define SCSI_ASC_SYSTEM_RESOURCE_FAILURE        0x55
-#define SCSI_ASC_OPERATOR_MEDIUM_REMOVAL_REQUEST 0x5A
-#define SCSI_ASC_FAILURE_PREDICTION_THRESHOLD_EXCEEDED	0x5D
-#define SCSI_ASC_CONFIGURATION_FAILURE          0x67
-
-#define SCSI_ADSENSE_NO_SENSE  0x98
-#define SCSI_ADSENSE_INVALID_CDB 0x99
-
-#define  SCSI_CMD_READ_DEFECT_DATA_10        0x37
-/*
- * SCSI additional sense code qualifier
- */
-#define SCSI_ASCQ_NO_ASCQ                       0x00
-#define SCSI_ASCQ_FORMAT_FAILED				0x01
-#define SCSI_ASCQ_INSUFFICIENT_RESERVATION_RESOURCES 0x02
-#define SCSI_ASCQ_INTERVENTION_REQUIRED         0x03
-#define SCSI_ASCQ_FORMAT_IN_PROGRESS            0x04
-#define SCSI_ASCQ_MAINTENANCE_IN_PROGRESS       0x80
-#define SCSI_ASCQ_HIF_GENERAL_HD_FAILURE		0x10
-#define SCSI_ASCQ_ATA_PASSTHRU_INFO             0x1D
-#define SCSI_ASCQ_INSUFFICIENT_RESERVATION_RESOURCES 0x02
-
-/* SCSI command CDB helper functions. */
-#define SCSI_CDB10_GET_LBA(cdb)                  \
-           ((MV_U32) (((MV_U32) cdb[2] << 24) |  \
-		      ((MV_U32) cdb[3] << 16) |  \
-		      ((MV_U32) cdb[4] << 8)  |  \
-		      (MV_U32) cdb[5]))
-
-#define SCSI_CDB10_SET_LBA(cdb, lba)             \
-           {                                     \
-              cdb[2] = (MV_U8)(lba >> 24);       \
-              cdb[3] = (MV_U8)(lba >> 16);       \
-              cdb[4] = (MV_U8)(lba >> 8);        \
-              cdb[5] = (MV_U8)lba;               \
-           }
-
-#define SCSI_CDB16_SET_LBA(cdb, lba)             \
-           {                                     \
-              cdb[2] = (MV_U8)(lba >> 56);       \
-              cdb[3] = (MV_U8)(lba >> 48);       \
-              cdb[4] = (MV_U8)(lba >> 40);       \
-              cdb[5] = (MV_U8)(lba >> 32);       \
-			  cdb[6] = (MV_U8)(lba >> 24);       \
-			  cdb[7] = (MV_U8)(lba >> 16);       \
-			  cdb[8] = (MV_U8)(lba >> 8);        \
-			  cdb[9] = (MV_U8)lba;               \
-           }
-
-#define SCSI_CDB10_GET_SECTOR(cdb)    ((cdb[7] << 8) | cdb[8])
-
-#define SCSI_CDB10_SET_SECTOR(cdb, sector)      \
-           {                                    \
-              cdb[7] = (MV_U8)(sector >> 8);    \
-              cdb[8] = (MV_U8)sector;           \
-           }
-
-#define SCSI_CDB16_SET_SECTOR(cdb, sector)      \
-           {                                    \
-              cdb[10] = (MV_U8)(sector >> 24);  \
-			  cdb[11] = (MV_U8)(sector >> 16);  \
-			  cdb[12] = (MV_U8)(sector >> 8);   \
-			  cdb[13] = (MV_U8)sector;          \
-           }
-
-#define MV_SCSI_RESPONSE_CODE                   0x70
-#define MV_SCSI_DIRECT_ACCESS_DEVICE            0x00
-
-typedef struct _MV_Sense_Data
-{
-	MV_U8 ErrorCode:7;
-	MV_U8 Valid:1;
-	MV_U8 SegmentNumber;
-	MV_U8 SenseKey:4;
-	MV_U8 Reserved:1;
-	MV_U8 IncorrectLength:1;
-	MV_U8 EndOfMedia:1;
-	MV_U8 FileMark:1;
-	MV_U8 Information[4];
-	MV_U8 AdditionalSenseLength;
-	MV_U8 CommandSpecificInformation[4];
-	MV_U8 AdditionalSenseCode;
-	MV_U8 AdditionalSenseCodeQualifier;
-	MV_U8 FieldReplaceableUnitCode;
-	MV_U8 SenseKeySpecific[3];
-}MV_Sense_Data, *PMV_Sense_Data;
-
-MV_VOID MV_SetSenseData(
-	IN PMV_Sense_Data pSense,
-	IN MV_U8 SenseKey,
-	IN MV_U8 AdditionalSenseCode,
-	IN MV_U8 ASCQ
-	);
-
-/* Virtual Device Inquiry Related */
-#define VIRTUALD_INQUIRY_DATA_SIZE		36
-#define VPD_PAGE0_VIRTUALD_SIZE			7
-#define VPD_PAGE80_VIRTUALD_SIZE		12
-#define VPD_PAGE83_VIRTUALD_SIZE		24
-
-extern MV_U8 BASEATTR MV_INQUIRY_VIRTUALD_DATA[];
-extern MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE0_VIRTUALD_DATA[];
-extern MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE80_VIRTUALD_DATA[];
-extern MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE83_VIRTUALD_DATA[];
-
-enum log_sense_page_code {
-        SUPPORTED_LOG_PAGES_LOG_PAGE            = 0x00,
-        WRITE_ERROR_COUNTER_LOG_PAGE            = 0x02,
-        READ_ERROR_COUNTER_LOG_PAGE             = 0x03,
-        READ_REVERSE_ERROR_COUNTER_LOG_PAGE     = 0x04,
-        VERIFY_ERROR_COUNTER_LOG_PAGE           = 0x05,
-        TEMPERATURE_LOG_PAGE                    = 0x0D,
-        SELF_TEST_RESULTS_LOG_PAGE              = 0x10,
-        INFORMATIONAL_EXCEPTIONS_LOG_PAGE       = 0x2F,
-};
-
-enum mode_sense_page_code {
-        DIRECT_ACCESS_BLOCK_DEVICE_MODE_PAGE    = 0x00,
-        RW_ERROR_RECOVERY_MODE_PAGE             = 0x01,
-        CACHE_MODE_PAGE                         = 0x08,
-        CONTROL_MODE_PAGE                       = 0x0A,
-        PORT_MODE_PAGE                          = 0x19,
-        INFORMATIONAL_EXCEPTIONS_CONTROL_MODE_PAGE = 0x1C,
-        ALL_MODE_PAGE                           = 0x3F,
-};
-
-#endif /*  __MV_COM_SCSI_H__ */
--- a/drivers/scsi/vanir/include/com_sgd.h
+++ /dev/null
@@ -1,375 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_SGD_H__
-#define __MV_COM_SGD_H__
-
-struct _sgd_tbl_t;
-struct _sgd_t;
-
-#define SGD_DOMAIN_MASK	0xF0000000L
-
-#define SGD_EOT			(1L<<27)	/* End of table */
-#define SGD_WIDE		(1L<<25)	/* 32 byte SG format */
-#define SGD_X64			(1L<<24)	/* the 2nd part of SGD_WIDE */
-#define SGD_NEXT_TBL	(1L<<23)	/* Next SG table format */
-#define SGD_VIRTUAL		(1L<<22)	/* Virtual SG format, either 32 or 64 bit is determined during compile time. */
-#define SGD_REFTBL		(1L<<21)	/* sg table reference format, either 32 or 64 bit is determined during compile time. */
-#define SGD_REFSGD		(1L<<20)	/* sg item reference format */
-#define SGD_VP			(1L<<19)	/* virtual and physical, not verified yet */
-#define SGD_VWOXCTX		(1L<<18)	/* virtual without translation context */
-#define SGD_PCTX		(1L<<17)	/* sgd_pctx_t, 64 bit only */
-
-typedef struct _sg_common_t
-{
-	MV_U32	dword1;
-	MV_U32	dword2;
-	MV_U32	dword3;
-	MV_U32	flags;	/* SGD_xxx */
-} sg_common_t;
-
-/*---------------------------------------------------------------------------*/
-
-typedef struct _sgd_t
-{
-	MV_U64	baseAddr;
-	MV_U32	flags;
-	MV_U32 size ;
-} sgd_t;
-
-
-typedef struct _sgd_v32_t
-{
-	MV_PVOID	vaddr;
-	MV_PVOID	xctx;
-	MV_U32	flags;
-	MV_U32 size ;
-} sgd_v32_t;
-
-/* sgd_v_t defines 32/64 bit virtual sgd without translation context */
-typedef struct _sgd_v_t
-{
-	union {
-		MV_PVOID	vaddr;
-		MV_U64		dummy;
-	} u;
-
-	MV_U32	flags;
-	MV_U32 size ;
-} sgd_v_t;
-
-typedef struct _sgd_v64_t
-{
-	union {
-		MV_PVOID	vaddr;
-		MV_U64		dummy;
-	} u1;
-
-	MV_U32	flags;
-	MV_U32 size ;
-
-	union {
-		MV_PVOID	xctx;
-		MV_U64		dummy;
-	} u2;
-	MV_U32	flagsEx;
-	MV_U32	rsvd;
-} sgd_v64_t;
-
-/*---------------------------------------------------------------------------*/
-
-typedef struct _sgd_ref32_t
-{
-	MV_PVOID	ref;
-	MV_U32		offset;
-
-	MV_U32	flags;
-	MV_U32 size ;
-} sgd_ref32_t;
-
-typedef struct _sgd_ref64_t
-{
-	union {
-		MV_PVOID	ref;
-		MV_U64		dummy;
-	} u;
-
-	MV_U32	flags;
-	MV_U32 size ;
-
-	MV_U32	offset;
-	MV_U32	rsvd1;
-
-	MV_U32	flagsEx;
-	MV_U32	rsvd2;
-} sgd_ref64_t;
-
-/*---------------------------------------------------------------------------*/
-
-typedef struct _sgd_nt_t
-{
-	union {
-		struct _sgd_tbl_t*	next;
-		MV_U64	dummy;
-	} u;
-	MV_U32	rsvd;
-	MV_U32	flags;	/* SGD_xxx */
-} sgd_nt_t;
-
-/*---------------------------------------------------------------------------*/
-
-typedef struct _sgd_vp_t
-{
-	MV_U64	baseAddr;
-
-	MV_U32	flags;
-	MV_U32 size ;
-	union {
-		MV_PVOID vaddr;
-		MV_U64   dummy;
-	} u;
-
-	MV_U32	flagsEx; /* SGD_X64 */
-	MV_U32	rsvd;
-} sgd_vp_t;
-
-/*---------------------------------------------------------------------------*/
-
-typedef struct _sgd_pctx_t
-{
-	MV_U64	baseAddr;
-	MV_U32	flags;
-	MV_U32 size ;
-	union {
-		MV_PVOID xctx;
-		MV_U64   dummy;
-	} u;
-
-	MV_U32	flagsEx;	/* SGD_X64 */
-	MV_U32	rsvd;
-} sgd_pctx_t;
-
-/*---------------------------------------------------------------------------*/
-
-typedef struct _sgd_tbl_t
-{
-	MV_U16 Max_Entry_Count;
-	MV_U16 Valid_Entry_Count;
-	MV_U8 Flag;
-	MV_U16 Occupy_Entry_Count;
-	MV_U32 Byte_Count;
-	sgd_t* Entry_Ptr;
-} sgd_tbl_t;
-
-#define sgd_table_init(sgdt,maxCnt,entries) do {	\
-	MV_ZeroMemory(sgdt,sizeof(sgd_tbl_t));		\
-	(sgdt)->Max_Entry_Count = (maxCnt);				\
-	(sgdt)->Entry_Ptr = (sgd_t*)(entries);			\
-} while(0)
-
-/*---------------------------------------------------------------------------*/
-
-#define sgd_inc(sgd) do {	\
-	if( (sgd)->flags & SGD_WIDE )					\
-		sgd = (sgd_t*)(((unsigned char*) (sgd)) + 32);	\
-	else sgd = (sgd_t*)(((unsigned char*) (sgd)) + 16);	\
-} while(0)
-
-#define sgd_get_vaddr(sgd,v) do {				\
-	if( (sgd)->flags & SGD_VIRTUAL ) {			\
-		if( (sgd)->flags & SGD_WIDE )			\
-			(v) = ((sgd_v64_t*)(sgd))->u1.vaddr;\
-		else (v) = ((sgd_v32_t*)(sgd))->vaddr;	\
-	}											\
-	else if( (sgd)->flags & SGD_VWOXCTX )		\
-		(v) = ((sgd_v_t*)sgd)->u.vaddr;			\
-	else if( (sgd)->flags & SGD_VP )			\
-		(v) = ((sgd_vp_t*)(sgd))->u.vaddr;		\
-	else										\
-		MV_ASSERT(MV_FALSE);					\
-} while(0)
-
-#define sgd_get_xctx(sgd,v) do {	\
-	if( (sgd)->flags & SGD_WIDE )	(v) = ((sgd_v64_t*)(sgd))->u2.xctx;	\
-	else (v) = ((sgd_v32_t*)(sgd))->xctx;	\
-} while(0)
-
-#define sgd_get_ref(sgd,_ref) do {	\
-	if( (sgd)->flags & SGD_WIDE ) (_ref) = ((sgd_ref64_t*)(sgd))->u.ref;	\
-	else (_ref) = ((sgd_ref32_t*)(sgd))->ref;	\
-} while(0)
-
-#define sgd_set_ref(sgd,_ref) do {	\
-	if( (sgd)->flags & SGD_WIDE ) ((sgd_ref64_t*)(sgd))->u.ref = (_ref);	\
-	else ((sgd_ref32_t*)(sgd))->ref = (_ref);	\
-} while(0)
-
-#define sgd_get_reftbl(sgd,reft) do {	\
-	if( (sgd)->flags & SGD_WIDE )		\
-		(reft) = (sgd_tbl_t*) (((sgd_ref64_t*)(sgd))->u.ref);	\
-	else (reft) = (sgd_tbl_t*)(((sgd_ref32_t*)(sgd))->ref);	\
-} while(0)
-
-#define sgd_get_refsgd(sgd,reft) do {	\
-	if( (sgd)->flags & SGD_WIDE )		\
-		(reft) = (sgd_t*) (((sgd_ref64_t*)(sgd))->u.ref);	\
-	else (reft) = (sgd_t*)(((sgd_ref32_t*)(sgd))->ref);	\
-} while(0)
-
-#define sgd_get_refoff(sgd,off) do {	\
-	if( (sgd)->flags & SGD_WIDE )	(off) = ((sgd_ref64_t*)(sgd))->offset;	\
-	else (off) = ((sgd_ref32_t*)(sgd))->offset;	\
-} while(0)
-
-#define sgd_set_refoff(sgd,off) do {	\
-	if( (sgd)->flags & SGD_WIDE )	((sgd_ref64_t*)(sgd))->offset = (off);	\
-	else ((sgd_ref32_t*)(sgd))->offset = (off);	\
-} while(0)
-
-#define sgd_get_nexttbl(sgd,n) do {	\
-	n = ((sgd_nt_t*)(sgd))->u.next;	\
-} while(0)
-
-#define sgd_mark_eot(sgd) \
-	((sgd)->flags |= SGD_EOT)
-
-#define sgd_clear_eot(sgd) \
-	((sgd)->flags &= ~SGD_EOT)
-
-#define sgd_eot(sgd)	\
-	((sgd)->flags & SGD_EOT)
-
-#define sgd_copy(sgdDst,sgdSrc) do {	\
-	*(sgdDst) = *(sgdSrc);	\
-	if( (sgdSrc)->flags & SGD_WIDE )	\
-		(sgdDst)[1] = (sgdSrc)[1];	\
-} while(0)
-
-#define sgd_getsz(sgd,sz) do {				\
-	(sz) = (sgd)->size;				\
-} while(0)
-
-#define sgd_setsz(sgd,sz) do {				\
-	(sgd)->size = (sz);				\
-} while(0)
-
-#define sgdt_get_lastsgd(sgdt,sgd) do {		\
-	(sgd) = &(sgdt)->Entry_Ptr[(sgdt)->Valid_Entry_Count];	\
-	(sgd)--;								\
-	if( (sgd)->flags & SGD_X64 ) (sgd)--;	\
-} while(0)
-
-/*---------------------------------------------------------------------------*/
-
-typedef int (*sgd_visitor_t)(sgd_t* sgd, MV_PVOID pContext);
-
-int sgd_table_walk(
-	sgd_tbl_t*		sgdt,
-	sgd_visitor_t	visitor,
-	MV_PVOID		ctx
-	);
-
-/*---------------------------------------------------------------------------*/
-
-typedef struct _sgd_iter_t
-{
-	sgd_t*	sgd;		/* current SG */
-	MV_U32	offset;		/* offset in the SG */
-	MV_U32	remainCnt;
-} sgd_iter_t;
-
-void  sgd_iter_init(
-	sgd_iter_t*	iter,
-	sgd_t*		sgd,
-	MV_U32		offset,
-	MV_U32		count
-	);
-
-int sgd_iter_get_next(
-	sgd_iter_t*	iter,
-	sgd_t*		sgd
-	);
-
-/*---------------------------------------------------------------------------*/
-
-void sgd_dump(sgd_t* sg, char* prefix);
-void sgdt_dump(sgd_tbl_t *SgTbl, char* prefix);
-
-/*---------------------------------------------------------------------------*/
-
-void sgdt_append(
-	sgd_tbl_t*	sgdt,
-	MV_U32		address,
-	MV_U32		addressHigh,
-	MV_U32		size
-	);
-
-void sgdt_append_pctx(
-	sgd_tbl_t*	sgdt,
-	MV_U32		address,
-	MV_U32		addressHigh,
-	MV_U32		size,
-	MV_PVOID	xctx
-	);
-
-int sgdt_append_virtual(
-	sgd_tbl_t* sgdt,
-	MV_PVOID virtual_address,
-	MV_PVOID translation_ctx,
-	MV_U32 size
-	);
-
-int sgdt_append_ref(
-	sgd_tbl_t*	sgdt,
-	MV_PVOID	ref,
-	MV_U32		offset,
-	MV_U32		size,
-	MV_BOOLEAN	refTbl
-	);
-
-int sgdt_append_vp(
-	sgd_tbl_t*	sgdt,
-	MV_PVOID	virtual_address,
-	MV_U32		size,
-	MV_U32		address,
-	MV_U32		addressHigh
-	);
-
-void
-sgdt_copy_partial(
-	sgd_tbl_t* sgdt,
-	sgd_t**	ppsgd,
-	MV_PU32	poff,
-	MV_U32	size
-	);
-
-void sgdt_append_sgd(
-	sgd_tbl_t*	sgdt,
-	sgd_t*		sgd
-	);
-
-#define sgdt_append_reftbl(sgdt,refSgdt,offset,size)	\
-	sgdt_append_ref(sgdt,refSgdt,offset,size,MV_TRUE)
-
-#define sgdt_append_refsgd(sgdt,refSgd,offset,size)	\
-	sgdt_append_ref(sgdt,refSgd,offset,size,MV_FALSE)
-
-/*---------------------------------------------------------------------------*/
-typedef MV_VOID (*sgd_to_prd_fn)(MV_PVOID prd_ctx, MV_U64 base_addr, MV_U32 size);
-int sgdt_prepare_hwprd(
-	MV_PVOID		pCore,
-	sgd_tbl_t*		pSource,
-	MV_PVOID		prd_ctx,
-	sgd_to_prd_fn		prd_fn
-	);
-#endif	/*__MV_COM_SGD_H__*/
--- a/drivers/scsi/vanir/include/com_tag.h
+++ /dev/null
@@ -1,44 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_TAG_H__
-#define __MV_COM_TAG_H__
-
-#include "com_define.h"
-
-typedef struct _Tag_Stack Tag_Stack, *PTag_Stack;
-
-#define FILO_TAG 0x00
-#define FIFO_TAG 0x01
-
-/* if TagStackType!=FIFO_TAG, use FILO, */
-/* if TagStackType==FIFO_TAG, use FIFO, PtrOut is the next tag to get */
-/*  and Top is the number of available tags in the stack */
-/* when use FIFO, get tag from PtrOut and free tag to (PtrOut+Top)%Size */
-struct _Tag_Stack
-{
-	MV_PU16  Stack;
-	MV_U16   Size;
-	MV_U16   Top;
-	MV_U16   PtrOut;
-	MV_U8    TagStackType;
-	MV_U8    Reserved[1];
-};
-
-MV_VOID Tag_Init(PTag_Stack pTagStack, MV_U16 size);
-MV_VOID Tag_Init_FIFO( PTag_Stack pTagStack, MV_U16 size );
-MV_U16 Tag_GetOne(PTag_Stack pTagStack) ;
-MV_VOID Tag_ReleaseOne(PTag_Stack pTagStack, MV_U16 tag);
-MV_BOOLEAN Tag_IsEmpty(PTag_Stack pTagStack);
-
-#endif /*  __MV_COM_TAG_H__ */
--- a/drivers/scsi/vanir/include/com_type.h
+++ /dev/null
@@ -1,289 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_TYPE_H__
-#define __MV_COM_TYPE_H__
-
-#include "com_define.h"
-#include "com_list.h"
-#include "mv_config.h"
-
-/*
- * Data Structure
- */
-#define MAX_CDB_SIZE                            32
-
-struct _MV_Request;
-typedef struct _MV_Request MV_Request, *PMV_Request;
-
-#define REQ_STATUS_SUCCESS                      0x0
-#define REQ_STATUS_NOT_READY                    0x1
-#define REQ_STATUS_MEDIA_ERROR                  0x2
-#define REQ_STATUS_BUSY                         0x3
-#define REQ_STATUS_INVALID_REQUEST              0x4
-#define REQ_STATUS_INVALID_PARAMETER            0x5
-#define REQ_STATUS_NO_DEVICE                    0x6
-/* Sense data structure is the SCSI "Fixed format sense datat" format. */
-#define REQ_STATUS_HAS_SENSE                    0x7
-#define REQ_STATUS_ERROR                        0x8
-#define REQ_STATUS_ERROR_WITH_SENSE             0x10
-#define REQ_STATUS_TIMEOUT                      0x11
-#define REQ_STATUS_DIF_GUARD_ERROR		0x12
-#define REQ_STATUS_DIF_REF_TAG_ERROR		0x13
-#define REQ_STATUS_DIF_APP_TAG_ERROR		0x14
-
-/* Request initiator must set the status to REQ_STATUS_PENDING. */
-#define REQ_STATUS_PENDING                      0x80
-#define REQ_STATUS_TIME_OUT				0x83
-
-
-/*
- * Don't change the order here.
- * Module_StartAll will start from big id to small id.
- * Make sure module_set setting matches the Module_Id
- * MODULE_HBA must be the first one. Refer to Module_AssignModuleExtension.
- * And HBA_GetNextModuleSendFunction has an assumption that the next level
- * has larger ID.
- */
-enum Module_Id
-{
-        MODULE_HBA = 0,
-        MODULE_CORE,
-        MAX_MODULE_NUMBER
-};
-#define MAX_POSSIBLE_MODULE_NUMBER              MAX_MODULE_NUMBER
-
-#include "com_sgd.h"
-
-typedef sgd_tbl_t MV_SG_Table, *PMV_SG_Table;
-typedef sgd_t MV_SG_Entry, *PMV_SG_Entry;
-
-/*
- * MV_Request is the general request type passed through different modules.
- * Must be 64 bit aligned.
- */
-
-#define DEV_ID_TO_TARGET_ID(_dev_id)    ((MV_U8)((_dev_id) & 0x00FF))
-#define DEV_ID_TO_LUN(_dev_id)                ((MV_U8) (((_dev_id) & 0xFF00) >> 8))
-#define __MAKE_DEV_ID(_target_id, _lun)   (((MV_U16)(_target_id)) | (((MV_U16)(_lun)) << 8))
-
-typedef void (*MV_ReqCompletion)(MV_PVOID,PMV_Request);
-
-struct _MV_Request {
-	List_Head pool_entry;
-	List_Head Queue_Pointer;
-
-	MV_PVOID cmd_table;
-	MV_PVOID sg_table;
-	MV_PHYSICAL_ADDR cmd_table_phy;
-	MV_PHYSICAL_ADDR sg_table_phy;
-
-	MV_PVOID Virtual_Buffer;
-	MV_U16 Device_Id;
-	MV_U16 Req_Flag;
-
-	MV_U8 Scsi_Status;
-	MV_U8 Tag;
-	MV_U16 Req_Type;
-	MV_PVOID Cmd_Initiator;           /* Which module(extension pointer)
-									creates this request. */
-	MV_U16 Reserved1;
-	MV_U8 Sense_Info_Buffer_Length;
-	MV_U8 NCQ_Tag;
-	MV_U32 Data_Transfer_Length;
-
-	MV_U8 lun[8];
-
-	MV_U16		EEDPFlags;
-	MV_U16		Reserved2[3];
-
-	MV_U8 Cdb[MAX_CDB_SIZE];
-	MV_PVOID Data_Buffer;
-	MV_PVOID Sense_Info_Buffer;
-
-	MV_SG_Table SG_Table;
-
-	MV_PVOID Org_Req;                /* The original request. */
-
-	/* Each module should only use Context to store module information. */
-	MV_PVOID Context[MAX_POSSIBLE_MODULE_NUMBER];
-
-	MV_PVOID Scratch_Buffer;          /* pointer to the scratch buffer
-										 that this request used */
-	MV_PVOID pRaid_Request;
-
-	MV_LBA LBA;
-	MV_U32 Sector_Count;
-	MV_U32 Cmd_Flag;
-
-	MV_U32 Time_Out;                  /* how many seconds we should wait
-					     before treating request as
-					     timed-out */
-	MV_U32 Splited_Count;
-
-	MV_PVOID Org_Req_Scmd;                /* The original scmd request from OS*/
-
-	MV_ReqCompletion	Completion; /* call back function */
-};
-
-#define MV_REQUEST_SIZE                   sizeof(MV_Request)
-/*
- * Request flag is the flag for the MV_Request data structure.
- */
-#define REQ_FLAG_LBA_VALID                MV_BIT(0)
-#define REQ_FLAG_CMD_FLAG_VALID           MV_BIT(1)
-#define REQ_FLAG_RETRY                    MV_BIT(2)
-#define REQ_FLAG_INTERNAL_SG              MV_BIT(3)
-#define REQ_FLAG_FLUSH                    MV_BIT(6)
-#define REQ_FLAG_CONSOLIDATE			  MV_BIT(8)
-#define REQ_FLAG_NO_CONSOLIDATE           MV_BIT(9)
-#define REQ_FLAG_EXTERNAL				  MV_BIT(10)
-#define REQ_FLAG_BYPASS_HYBRID            MV_BIT(12)
-#define REQ_FLAG_CONTINUE_ON_ERROR        MV_BIT(13)	/* Continue to handle the request even hit error. */
-#define REQ_FLAG_NO_ERROR_RECORD          MV_BIT(14)	/* Needn't record error. */
-#define REQ_FLAG_TRIM_CMD          MV_BIT(15)	/* Trim support by verify. */
-
-/*
- * Request Type is the type of MV_Request.
- */
-enum {
-	/* use a value other than 0, and now they're bit-mapped */
-	REQ_TYPE_OS       = 0x01,
-	REQ_TYPE_RAID     = 0x02,
-	REQ_TYPE_CACHE    = 0x04,
-	REQ_TYPE_INTERNAL = 0x08,
-	REQ_TYPE_SUBLD    = 0x10,
-	REQ_TYPE_SUBBGA   = 0x20,
-	REQ_TYPE_MP       = 0x40,
-	REQ_TYPE_DS		  = 0x80,
-	REQ_TYPE_CORE     = 0x100,
-};
-
-#define CMD_FLAG_NON_DATA                 MV_BIT(0)  /* 1-non data;
-							0-data command */
-#define CMD_FLAG_DMA                      MV_BIT(1)  /* 1-DMA */
-#define CMD_FLAG_PIO			  MV_BIT(2)  /* 1-PIO */
-#define CMD_FLAG_DATA_IN                  MV_BIT(3)  /* 1-host read data */
-#define CMD_FLAG_DATA_OUT                 MV_BIT(4)	 /* 1-host write data */
-
-#define CMD_FLAG_SMART                    MV_BIT(5)  /* 1-SMART command; 0-non SMART command*/
-#define CMD_FLAG_SMART_ATA_12       MV_BIT(6)  /* SMART ATA_12  */
-#define CMD_FLAG_SMART_ATA_16       MV_BIT(7)  /* SMART ATA_16; */
-#define CMD_FLAG_CACHE_OS_DATABUF	 MV_BIT(9)
-
-
-#define CMD_FLAG_CACHE_OS_DATABUF	  MV_BIT(9)
-/*
- * The last 16 bit only can be set by the target. Only core driver knows
- * the device characteristic.
- */
-#define CMD_FLAG_NCQ                      MV_BIT(16)
-#define CMD_FLAG_TCQ                      MV_BIT(17)
-#define CMD_FLAG_48BIT                    MV_BIT(18)
-#define CMD_FLAG_PACKET                   MV_BIT(19)  /* ATAPI packet cmd */
-
-#define CMD_FLAG_SCSI_PASS_THRU           MV_BIT(20)
-#define CMD_FLAG_ATA_PASS_THRU            MV_BIT(21)
-
-#define CMD_FLAG_SOFT_RESET               MV_BIT(22)
-
-typedef struct _MV_Target_ID_Map
-{
-	MV_U16   Device_Id;
-	MV_U8    Type;                    /* 0:LD, 1:Free Disk */
-	MV_U8    Reserved;
-} MV_Target_ID_Map, *PMV_Target_ID_Map;
-
-/* Resource type */
-enum Resource_Type
-{
-	RESOURCE_CACHED_MEMORY = 0,
-	RESOURCE_UNCACHED_MEMORY
-};
-
-/* Module event type */
-enum Module_Event
-{
-	EVENT_MODULE_ALL_STARTED = 0,
-	EVENT_DEVICE_ARRIVAL,
-	EVENT_DEVICE_REMOVAL,
-	EVENT_LOG_GENERATED,
-};
-
-/* Error_Handling_State */
-enum EH_State
-{
-	EH_NONE = 0,
-	EH_ABORT_REQUEST,
-	EH_LU_RESET,
-	EH_DEVICE_RESET,
-	EH_PORT_RESET,
-	EH_CHIP_RESET,
-	EH_SET_DISK_DOWN
-};
-
-typedef enum
-{
-	EH_REQ_NOP = 0,
-	EH_REQ_ABORT_REQUEST,
-	EH_REQ_HANDLE_TIMEOUT,
-	EH_REQ_RESET_BUS,
-	EH_REQ_RESET_CHANNEL,
-	EH_REQ_RESET_DEVICE,
-	EH_REQ_RESET_ADAPTER
-}eh_req_type_t;
-
-struct mod_notif_param {
-        MV_PVOID  p_param;
-        MV_U16    hi;
-        MV_U16    lo;
-
-        /* for event processing */
-        MV_U32    event_id;
-        MV_U16    dev_id;
-        MV_U8     severity_lvl;
-        MV_U8     param_count;
-	MV_U8	sense_length;
-	MV_PVOID p_sense;
-	MV_U16	tran_hex_bit;
-};
-
-/*
- * Exposed Functions
- */
-
-/*
- *
- * Miscellaneous Definitions
- *
- */
-/* Rounding */
-
-/* Packed */
-
-#define MV_MAX(x,y)        (((x) > (y)) ? (x) : (y))
-#define MV_MIN(x,y)        (((x) < (y)) ? (x) : (y))
-#define MV_MAX_U64(x, y)   ((((x).value) > ((y).value)) ? (x) : (y))
-#define MV_MIN_U64(x, y)   ((((x).value) < ((y).value)) ? (x) : (y))
-
-#define MV_MAX_U8          0xFF
-#define MV_MAX_U16         0xFFFF
-#define MV_MAX_U32         0xFFFFFFFFL
-
-#define ROUNDING_MASK(x, mask)  (((x)+(mask))&~(mask))
-#define ROUNDING(value, align)  ROUNDING_MASK(value,   \
-						 (typeof(value)) (align-1))
-#define OFFSET_OF(type, member) offsetof(type, member)
-#define SIZE_OF_POINTER (sizeof(void*))
-
-#endif /* __MV_COM_TYPE_H__ */
--- a/drivers/scsi/vanir/include/com_u64.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef _U64_H__
-#define _U64_H__
-
-#define U64_ASSIGN_SAFE(v1, v2)	\
-do{	int i; \
-	for (i=0; i<sizeof((v1)); i++)	\
-		((char*)&v1)[i] = ((char*)(v2))[i];	\
-}while(0)
-
-MV_U64 U64_ADD_U32(MV_U64 v64, MV_U32 v32);
-MV_U64 U64_SUBTRACT_U32(MV_U64 v64, MV_U32 v32);
-MV_U64 U64_MULTIPLY_U32(MV_U64 v64, MV_U32 v32);
-MV_U64 U64_DIVIDE_U32(MV_U64 v64, MV_U32 v32);
-MV_I32 U64_COMPARE_U32(MV_U64 v64, MV_U32 v32);
-MV_U32 U64_MOD_U32(MV_U64 v64, MV_U32 v32);
-
-MV_U64 U64_ADD_U64(MV_U64 v1, MV_U64 v2);
-MV_U64 U64_SUBTRACT_U64(MV_U64 v1, MV_U64 v2);
-MV_U32 U64_DIVIDE_U64(MV_U64 v1, MV_U64 v2);
-MV_I32 U64_COMPARE_U64(MV_U64 v1, MV_U64 v2);
-#define U64_SET_VALUE(v64, v32)	do { v64.value = v32; } while(0)
-#define U64_SET_MAX_VALUE(v64)	do { v64.parts.low = v64.parts.high = 0xFFFFFFFFL; } while(0);
-
-#endif
--- a/drivers/scsi/vanir/include/com_util.h
+++ /dev/null
@@ -1,232 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_UTIL_H__
-#define __MV_COM_UTIL_H__
-
-#include "com_define.h"
-#include "com_type.h"
-
-#define MV_ZeroMemory(buf, len)           ossw_memset(buf, 0, len)
-#define MV_FillMemory(buf, len, pattern)  ossw_memset(buf, pattern, len)
-#define MV_CopyMemory(dest, source, len)  ossw_memcpy(dest, source, len)
-#define MV_CompareMemory(buf0, buf1, len)  ossw_memcmp(buf0, buf1, len)
-
- /* ffz - find first zero in word. define in linux kernel bitops.h*/
-#define ffc(v)  ossw_ffz(v)
-#define _rotr(v, i)		ossw_rotr32(v, i)
-/*ffs - normally return from 1 to MSB, if not find set bit, return 0*/
-#define fc(v, i) (ossw_ffs(~(_rotr(v, i))) + i)
-
-static __inline int
-ffc64(MV_U64 v)
-{
-    int i;
-
-    if ((i = ffc(v.parts.low)) >= 0) {
-        return i;
-    }
-
-    if ((i = ffc(v.parts.high)) >= 0) {
-        return 32 + i;
-    }
-
-	return -1;
-}
-
-void MV_ZeroMvRequest(PMV_Request pReq);
-void MV_CopySGTable(PMV_SG_Table pTargetSGTable, PMV_SG_Table pSourceSGTable);
-/* offset and size are all byte count. */
-void MV_CopyPartialSGTable(PMV_SG_Table pTargetSGTable, PMV_SG_Table pSourceSGTable, MV_U32 offset, MV_U32 size);
-
-MV_BOOLEAN MV_Equals(MV_PU8 des, MV_PU8 src, MV_U32 len);
-
-#define	U64_ASSIGN(x,y)				  	((x).value = (y))
-#define	U64_ASSIGN_U64(x,y)			  	((x).value = (y).value)
-#define	U64_COMP_U64(x,y)			  	((x) == (y).value)
-#define U64_COMP_U64_VALUE(x,y)			((x).value == (y).value)
-#define U32_ASSIGN_U64(v64, v32)		((v64).value = (v32))
-#define	U64_SHIFT_LEFT(v64, v32)		((v64).value=(v64).value << (v32))
-#define	U64_SHIFT_RIGHT(v64, v32)		((v64).value=(v64).value >> (v32))
-#define U64_ZERO_VALUE(v64)				((v64).value = 0)
-
-#define MV_SWAP_32(x)                             \
-           (((MV_U32)((MV_U8)(x)))<<24 |          \
-            ((MV_U32)((MV_U8)((x)>>8)))<<16 |     \
-            ((MV_U32)((MV_U8)((x)>>16)))<<8 |     \
-            ((MV_U32)((MV_U8)((x)>>24))) )
-#define MV_SWAP_64(x)                             \
-           (((_MV_U64) (MV_SWAP_32((x).parts.low))) << 32 | \
-	    MV_SWAP_32((x).parts.high))
-#define MV_SWAP_16(x)                             \
-           (((MV_U16) ((MV_U8) (x))) << 8 |       \
-	    (MV_U16) ((MV_U8) ((x) >> 8)))
-
-#define MV_CPU_TO_LE16      ossw_cpu_to_le16
-#define MV_CPU_TO_LE32      ossw_cpu_to_le32
-#define MV_CPU_TO_LE64(x)   ossw_cpu_to_le64((x).value)
-#define MV_CPU_TO_BE16      ossw_cpu_to_be16
-#define MV_CPU_TO_BE32      ossw_cpu_to_be32
-#define MV_CPU_TO_BE64(x)   ossw_cpu_to_be64((x).value)
-
-#define MV_LE16_TO_CPU      ossw_le16_to_cpu
-#define MV_LE32_TO_CPU      ossw_le32_to_cpu
-#define MV_LE64_TO_CPU(x)   ossw_le64_to_cpu((x).value)
-#define MV_BE16_TO_CPU      ossw_be16_to_cpu
-#define MV_BE32_TO_CPU      ossw_be32_to_cpu
-#define MV_BE64_TO_CPU(x)   ossw_be64_to_cpu((x).value)
-
-/*
- * big endian bit-field structs that are larger than a single byte
- * need swapping
- */
-#ifdef __MV_BIG_ENDIAN__
-#define MV_CPU_TO_LE16_PTR(pu16)        \
-   *((MV_PU16)(pu16)) = MV_CPU_TO_LE16(*(MV_PU16) (pu16))
-#define MV_CPU_TO_LE32_PTR(pu32)        \
-   *((MV_PU32)(pu32)) = MV_CPU_TO_LE32(*(MV_PU32) (pu32))
-
-#define MV_LE16_TO_CPU_PTR(pu16)        \
-   *((MV_PU16)(pu16)) = MV_LE16_TO_CPU(*(MV_PU16) (pu16))
-#define MV_LE32_TO_CPU_PTR(pu32)        \
-   *((MV_PU32)(pu32)) = MV_LE32_TO_CPU(*(MV_PU32) (pu32))
-# else  /* __MV_BIG_ENDIAN__ */
-#define MV_CPU_TO_LE16_PTR(pu16)        /* Nothing */
-#define MV_CPU_TO_LE32_PTR(pu32)        /* Nothing */
-#define MV_LE16_TO_CPU_PTR(pu32)
-#define MV_LE32_TO_CPU_PTR(pu32)
-#endif /* __MV_BIG_ENDIAN__ */
-
-/* definitions - following macro names are used by RAID module
-   must keep consistent */
-#define CPU_TO_BIG_ENDIAN_16(x)        MV_CPU_TO_BE16(x)
-#define CPU_TO_BIG_ENDIAN_32(x)        MV_CPU_TO_BE32(x)
-#define CPU_TO_BIG_ENDIAN_64(x)        MV_CPU_TO_BE64(x)
-
-void SGTable_Init(
-    OUT PMV_SG_Table pSGTable,
-    IN MV_U8 flag
-    );
-
-void sgt_init(
-    IN MV_U16 max_io,
-    OUT PMV_SG_Table pSGTable,
-    IN MV_U8 flag
-    );
-
-#define SGTable_Append sgdt_append
-
-MV_BOOLEAN SGTable_Available(
-    IN PMV_SG_Table pSGTable
-    );
-
-void MV_InitializeTargetIDTable(
-    IN PMV_Target_ID_Map pMapTable
-    );
-
-MV_U16 MV_GetTargetID(
-	IN PMV_Target_ID_Map
-	pMapTable,IN MV_U8 deviceType
-	);
-
-MV_U16 MV_MapTargetID(
-    IN PMV_Target_ID_Map    pMapTable,
-    IN MV_U16                deviceId,
-    IN MV_U8                deviceType
-    );
-
-MV_U16 MV_MapToSpecificTargetID(
-	IN PMV_Target_ID_Map	pMapTable,
-	IN MV_U16				specificId,
-	IN MV_U16				deviceId,
-	IN MV_U8				deviceType
-	);
-
-MV_U16 MV_RemoveTargetID(
-    IN PMV_Target_ID_Map    pMapTable,
-    IN MV_U16                deviceId,
-    IN MV_U8                deviceType
-    );
-
-MV_U16 MV_GetMappedID(
-	IN PMV_Target_ID_Map	pMapTable,
-	IN MV_U16				deviceId,
-	IN MV_U8				deviceType
-	);
-
-void MV_DecodeReadWriteCDB(
-	IN MV_PU8 Cdb,
-	OUT MV_LBA *pLBA,
-	OUT MV_U32 *pSectorCount);
-
-void MV_CodeReadWriteCDB(
-	OUT MV_PU8	Cdb,
-	IN MV_LBA	lba,
-	IN MV_U32	sector,
-	IN MV_U8	operationCode	/* The CDB[0] */
-	);
-
-#define MV_SetLBAandSectorCount(pReq) do {								\
-	MV_DecodeReadWriteCDB(pReq->Cdb, &pReq->LBA, &pReq->Sector_Count);	\
-	pReq->Req_Flag |= REQ_FLAG_LBA_VALID;								\
-} while (0)
-
-void MV_DumpRequest(PMV_Request pReq, MV_BOOLEAN detail);
-void MV_DumpSGTable(PMV_SG_Table pSGTable);
-const char* MV_DumpSenseKey(MV_U8 sense);
-
-MV_U32 MV_CRC(
-	IN MV_PU8  pData,
-	IN MV_U16  len
-);
-MV_U32 MV_CRC_EXT(
-	IN	MV_U32		crc,
-	IN	MV_PU8		pData,
-	IN	MV_U32		len
-);
-
-#define MV_MOD_ADD(value, mod)                    \
-           do {                                   \
-              (value)++;                          \
-              if ((value) >= (mod))               \
-                 (value) = 0;                     \
-           } while (0);
-
-void MV_CHECK_OS_SG_TABLE(
-    IN PMV_SG_Table pSGTable
-    );
-
-/* used for endian-ness conversion */
-static inline MV_VOID mv_swap_bytes(MV_PVOID buf, MV_U32 len)
-{
-	MV_U32 i;
-	MV_U8  tmp, *p;
-
-	/* we expect len to be in multiples of 2 */
-	if (len & 0x1)
-		return;
-
-	p = (MV_U8 *) buf;
-	for (i = 0; i < len / 2; i++)
-	{
-		tmp = p[i];
-		p[i] = p[len - i - 1];
-		p[len - i - 1] = tmp;
-	}
-}
-
-MV_VOID init_target_id_map(MV_U16 *map_table, MV_U32 size);
-MV_U16 add_target_map(MV_U16 *map_table, MV_U16 device_id,MV_U16 max_id);
-MV_U16 remove_target_map(MV_U16 *map_table, MV_U16 target_id, MV_U16 max_id);
-
-#endif /*  __MV_COM_UTIL_H__ */
--- a/drivers/scsi/vanir/include/csmisas.h
+++ /dev/null
@@ -1,1162 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-/**************************************************************************
-
-Module Name:
-
-   CSMISAS.H
-
-
-Abstract:
-
-   This file contains constants and data structure definitions used by drivers
-   that support the Common Storage Management Interface specification for
-   SAS or SATA in either the Windows or Linux.
-
-   This should be considered as a reference implementation only.  Changes may
-   be necessary to accommodate a specific build environment or target OS.
-
-Revision History:
-
-   001  SEF   8/12/03  Initial release.
-   002  SEF   8/20/03  Cleanup to match documentation.
-   003  SEF   9/12/03  Additional cleanup, created combined header
-   004  SEF   9/23/03  Changed base types to match linux defaults
-                       Added RAID signature
-                       Added bControllerFlags to CSMI_SAS_CNTLR_CONFIG
-                       Changed CSMI_SAS_BEGIN_PACK to 8 for common structures
-                       Fixed other typos identified in first compilation test
-   005  SEF  10/03/03  Additions to match first version of CSMI document
-   006  SEF  10/14/03  Fixed typedef struct _CSMI_SAS_SMP_PASSTHRU_BUFFER
-                       Added defines for bConnectionRate
-   007  SEF  10/15/03  Added Firmware Download Control Code and support
-                       Added CSMI revision support
-   008  SEF  10/30/03  No functional change, just updated version to track
-                       spec changes
-   009  SEF  12/09/03  No functional change, just updated version to track
-                       spec changes
-   010  SEF   3/11/04  Fixed typedef struct CSMI_SAS_RAID_DRIVES to include the
-                       bFirmware member that is defined in the spec, but
-                       was missing in this file,
-                       added CC_CSMI_SAS_TASK_MANAGEMENT
-   011  SEF   4/02/04  No functional change, added comment line before
-                       CC_CSMI_SAS_TASK_MANAGEMENT
-   012  SEF   4/16/04  Added IOControllerNumber to linux header,
-                       Modified linux control codes to have upper word of
-                       0xCC77.... to indicate CSMI version 77
-                       Added bSignalClass to CC_CSMI_SET_PHY_INFO
-                       Added CC_CSMI_SAS_PHY_CONTROL support
-   013  SEF   5/14/04  Added CC_CSMI_SAS_GET_CONNECTOR_INFO support
-   014  SEF   5/24/04  No functional change, just updated version to track spec
-                       changes
-   015  SEF   6/16/04  changed bPinout to uPinout to reflect proper size,
-                       changed width of bLocation defines to reflect size
-   016  SEF   6/17/04  changed bLengthOfControls in CSMI_SAS_PHY_CONTROL
-                       to be proper size
-   017  SEF   9/17/04  added CSMI_SAS_SATA_PORT_SELECTOR,
-                       CSMI_SAS_LINK_VIRTUAL, CSMI_SAS_CON_NOT_PRESENT, and
-                       CSMI_SAS_CON_NOT_CONNECTED
-   018  SEF   9/20/04  added CSMI_SAS_PHY_USER_PATTERN,
-                       changed definition of CSMI_SAS_PHY_FIXED_PATTERN to not
-                       conflict with activate definition
-   019  SEF  12/06/04  added CSMI_SAS_GET_LOCATION
-                       added bSSPStatus to CSMI_SAS_SSP_PASSTHRU_STATUS
-                       structure
-
-**************************************************************************/
-
-#ifndef _CSMI_SAS_H_
-#define _CSMI_SAS_H_
-
-// CSMI Specification Revision, the intent is that all versions of the
-// specification will be backward compatible after the 1.00 release.
-// Major revision number, corresponds to xxxx. of CSMI specification
-// Minor revision number, corresponds to .xxxx of CSMI specification
-#define CSMI_MAJOR_REVISION   0
-#define CSMI_MINOR_REVISION   83
-
-/*************************************************************************/
-/* TARGET OS LINUX SPECIFIC CODE                                         */
-/*************************************************************************/
-
-// EDM #ifdef _linux
-#ifdef __KERNEL__
-
-
-// Linux base types
-
-#include <linux/types.h>
-
-// pack definition
-
-// EDM #define CSMI_SAS_BEGIN_PACK(x)    pack(x)
-// EDM #define CSMI_SAS_END_PACK         pack()
-
-// IOCTL Control Codes
-// (IoctlHeader.ControlCode)
-
-// Control Codes prior to 0.77
-
-// Control Codes requiring CSMI_ALL_SIGNATURE
-
-// #define CC_CSMI_SAS_GET_DRIVER_INFO    0x12345678
-// #define CC_CSMI_SAS_GET_CNTLR_CONFIG   0x23456781
-// #define CC_CSMI_SAS_GET_CNTLR_STATUS   0x34567812
-// #define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0x92345678
-
-// Control Codes requiring CSMI_RAID_SIGNATURE
-
-// #define CC_CSMI_SAS_GET_RAID_INFO      0x45678123
-// #define CC_CSMI_SAS_GET_RAID_CONFIG    0x56781234
-
-// Control Codes requiring CSMI_SAS_SIGNATURE
-
-// #define CC_CSMI_SAS_GET_PHY_INFO       0x67812345
-// #define CC_CSMI_SAS_SET_PHY_INFO       0x78123456
-// #define CC_CSMI_SAS_GET_LINK_ERRORS    0x81234567
-// #define CC_CSMI_SAS_SMP_PASSTHRU       0xA1234567
-// #define CC_CSMI_SAS_SSP_PASSTHRU       0xB1234567
-// #define CC_CSMI_SAS_STP_PASSTHRU       0xC1234567
-// #define CC_CSMI_SAS_GET_SATA_SIGNATURE 0xD1234567
-// #define CC_CSMI_SAS_GET_SCSI_ADDRESS   0xE1234567
-// #define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0xF1234567
-// #define CC_CSMI_SAS_TASK_MANAGEMENT    0xA2345678
-
-// Control Codes for 0.77 and later
-
-// Control Codes requiring CSMI_ALL_SIGNATURE
-
-#define CC_CSMI_SAS_GET_DRIVER_INFO    0xCC770001
-#define CC_CSMI_SAS_GET_CNTLR_CONFIG   0xCC770002
-#define CC_CSMI_SAS_GET_CNTLR_STATUS   0xCC770003
-#define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0xCC770004
-
-// Control Codes requiring CSMI_RAID_SIGNATURE
-
-#define CC_CSMI_SAS_GET_RAID_INFO      0xCC77000A
-#define CC_CSMI_SAS_GET_RAID_CONFIG    0xCC77000B
-
-// Control Codes requiring CSMI_SAS_SIGNATURE
-
-#define CC_CSMI_SAS_GET_PHY_INFO       0xCC770014
-#define CC_CSMI_SAS_SET_PHY_INFO       0xCC770015
-#define CC_CSMI_SAS_GET_LINK_ERRORS    0xCC770016
-#define CC_CSMI_SAS_SMP_PASSTHRU       0xCC770017
-#define CC_CSMI_SAS_SSP_PASSTHRU       0xCC770018
-#define CC_CSMI_SAS_STP_PASSTHRU       0xCC770019
-#define CC_CSMI_SAS_GET_SATA_SIGNATURE 0xCC770020
-#define CC_CSMI_SAS_GET_SCSI_ADDRESS   0xCC770021
-#define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0xCC770022
-#define CC_CSMI_SAS_TASK_MANAGEMENT    0xCC770023
-#define CC_CSMI_SAS_GET_CONNECTOR_INFO 0xCC770024
-#define CC_CSMI_SAS_GET_LOCATION       0xCC770025
-
-// Control Codes requiring CSMI_PHY_SIGNATURE
-
-#define CC_CSMI_SAS_PHY_CONTROL        0xCC77003C
-
-// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
-#pragma pack(8)
-
-// IOCTL_HEADER
-typedef struct _IOCTL_HEADER {
-	__u32 IOControllerNumber;
-	__u32 Length;
-	__u32 ReturnCode;
-	__u32 Timeout;
-	__u16 Direction;
-} IOCTL_HEADER, *PIOCTL_HEADER;
-
-// EDM #pragma CSMI_SAS_END_PACK
-#pragma pack()
-
-#endif
-
-#define __i8    char
-
-/*************************************************************************/
-/* TARGET OS NOT DEFINED ERROR                                           */
-/*************************************************************************/
-#if (!__KERNEL__)
-   #error "Unknown target OS."
-#endif
-
-/*************************************************************************/
-/* OS INDEPENDENT CODE                                                   */
-/*************************************************************************/
-
-/* * * * * * * * * * Class Independent IOCTL Constants * * * * * * * * * */
-
-// Return codes for all IOCTL's regardless of class
-// (IoctlHeader.ReturnCode)
-
-#define CSMI_SAS_STATUS_SUCCESS              0
-#define CSMI_SAS_STATUS_FAILED               1
-#define CSMI_SAS_STATUS_BAD_CNTL_CODE        2
-#define CSMI_SAS_STATUS_INVALID_PARAMETER    3
-#define CSMI_SAS_STATUS_WRITE_ATTEMPTED      4
-
-// Signature value
-// (IoctlHeader.Signature)
-
-#define CSMI_ALL_SIGNATURE    "CSMIALL"
-
-// Timeout value default of 60 seconds
-// (IoctlHeader.Timeout)
-
-#define CSMI_ALL_TIMEOUT      60
-
-//  Direction values for data flow on this IOCTL
-// (IoctlHeader.Direction, Linux only)
-#define CSMI_SAS_DATA_READ    0
-#define CSMI_SAS_DATA_WRITE   1
-
-// I/O Bus Types
-// ISA and EISA bus types are not supported
-// (bIoBusType)
-
-#define CSMI_SAS_BUS_TYPE_PCI       3
-#define CSMI_SAS_BUS_TYPE_PCMCIA    4
-
-// Controller Status
-// (uStatus)
-
-#define CSMI_SAS_CNTLR_STATUS_GOOD     1
-#define CSMI_SAS_CNTLR_STATUS_FAILED   2
-#define CSMI_SAS_CNTLR_STATUS_OFFLINE  3
-#define CSMI_SAS_CNTLR_STATUS_POWEROFF 4
-
-// Offline Status Reason
-// (uOfflineReason)
-
-#define CSMI_SAS_OFFLINE_REASON_NO_REASON             0
-#define CSMI_SAS_OFFLINE_REASON_INITIALIZING          1
-#define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_DEGRADED 2
-#define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_FAILURE  3
-
-// Controller Class
-// (bControllerClass)
-
-#define CSMI_SAS_CNTLR_CLASS_HBA    5
-
-// Controller Flag bits
-// (uControllerFlags)
-
-#define CSMI_SAS_CNTLR_SAS_HBA   0x00000001
-#define CSMI_SAS_CNTLR_SAS_RAID  0x00000002
-#define CSMI_SAS_CNTLR_SATA_HBA  0x00000004
-#define CSMI_SAS_CNTLR_SATA_RAID 0x00000008
-
-// for firmware download
-#define CSMI_SAS_CNTLR_FWD_SUPPORT  0x00010000
-#define CSMI_SAS_CNTLR_FWD_ONLINE   0x00020000
-#define CSMI_SAS_CNTLR_FWD_SRESET   0x00040000
-#define CSMI_SAS_CNTLR_FWD_HRESET   0x00080000
-#define CSMI_SAS_CNTLR_FWD_RROM     0x00100000
-
-// Download Flag bits
-// (uDownloadFlags)
-#define CSMI_SAS_FWD_VALIDATE       0x00000001
-#define CSMI_SAS_FWD_SOFT_RESET     0x00000002
-#define CSMI_SAS_FWD_HARD_RESET     0x00000004
-
-// Firmware Download Status
-// (usStatus)
-#define CSMI_SAS_FWD_SUCCESS        0
-#define CSMI_SAS_FWD_FAILED         1
-#define CSMI_SAS_FWD_USING_RROM     2
-#define CSMI_SAS_FWD_REJECT         3
-#define CSMI_SAS_FWD_DOWNREV        4
-
-// Firmware Download Severity
-// (usSeverity>
-#define CSMI_SAS_FWD_INFORMATION    0
-#define CSMI_SAS_FWD_WARNING        1
-#define CSMI_SAS_FWD_ERROR          2
-#define CSMI_SAS_FWD_FATAL          3
-
-/* * * * * * * * * * SAS RAID Class IOCTL Constants  * * * * * * * * */
-
-// Return codes for the RAID IOCTL's regardless of class
-// (IoctlHeader.ControlCode)
-
-#define CSMI_SAS_RAID_SET_OUT_OF_RANGE       1000
-
-// Signature value
-// (IoctlHeader.Signature)
-
-#define CSMI_RAID_SIGNATURE    "CSMIARY"
-
-// Timeout value default of 60 seconds
-// (IoctlHeader.Timeout)
-
-#define CSMI_RAID_TIMEOUT      60
-
-// RAID Types
-// (bRaidType)
-#define CSMI_SAS_RAID_TYPE_NONE     0
-#define CSMI_SAS_RAID_TYPE_0        1
-#define CSMI_SAS_RAID_TYPE_1        2
-#define CSMI_SAS_RAID_TYPE_10       3
-#define CSMI_SAS_RAID_TYPE_5        4
-#define CSMI_SAS_RAID_TYPE_15       5
-#define CSMI_SAS_RAID_TYPE_OTHER    255
-
-// RAID Status
-// (bStatus)
-#define CSMI_SAS_RAID_SET_STATUS_OK          0
-#define CSMI_SAS_RAID_SET_STATUS_DEGRADED    1
-#define CSMI_SAS_RAID_SET_STATUS_REBUILDING  2
-#define CSMI_SAS_RAID_SET_STATUS_FAILED      3
-#define CSMI_SAS_RAID_SET_STATUS_PARTIALLYOPTIMAL	4
-
-// RAID Drive Status
-// (bDriveStatus)
-#define CSMI_SAS_DRIVE_STATUS_OK          0
-#define CSMI_SAS_DRIVE_STATUS_REBUILDING  1
-#define CSMI_SAS_DRIVE_STATUS_FAILED      2
-#define CSMI_SAS_DRIVE_STATUS_DEGRADED    3
-
-// RAID Drive Usage
-// (bDriveUsage)
-#define CSMI_SAS_DRIVE_CONFIG_NOT_USED 0
-#define CSMI_SAS_DRIVE_CONFIG_MEMBER   1
-#define CSMI_SAS_DRIVE_CONFIG_SPARE    2
-
-/* * * * * * * * * * SAS HBA Class IOCTL Constants * * * * * * * * * */
-
-// Return codes for SAS IOCTL's
-// (IoctlHeader.ReturnCode)
-
-#define CSMI_SAS_PHY_INFO_CHANGED            CSMI_SAS_STATUS_SUCCESS
-#define CSMI_SAS_PHY_INFO_NOT_CHANGEABLE     2000
-#define CSMI_SAS_LINK_RATE_OUT_OF_RANGE      2001
-
-#define CSMI_SAS_PHY_DOES_NOT_EXIST          2002
-#define CSMI_SAS_PHY_DOES_NOT_MATCH_PORT     2003
-#define CSMI_SAS_PHY_CANNOT_BE_SELECTED      2004
-#define CSMI_SAS_SELECT_PHY_OR_PORT          2005
-#define CSMI_SAS_PORT_DOES_NOT_EXIST         2006
-#define CSMI_SAS_PORT_CANNOT_BE_SELECTED     2007
-#define CSMI_SAS_CONNECTION_FAILED           2008
-
-#define CSMI_SAS_NO_SATA_DEVICE              2009
-#define CSMI_SAS_NO_SATA_SIGNATURE           2010
-#define CSMI_SAS_SCSI_EMULATION              2011
-#define CSMI_SAS_NOT_AN_END_DEVICE           2012
-#define CSMI_SAS_NO_SCSI_ADDRESS             2013
-#define CSMI_SAS_NO_DEVICE_ADDRESS           2014
-
-// Signature value
-// (IoctlHeader.Signature)
-
-#define CSMI_SAS_SIGNATURE    "CSMISAS"
-
-// Timeout value default of 60 seconds
-// (IoctlHeader.Timeout)
-
-#define CSMI_SAS_TIMEOUT      60
-
-// Device types
-// (bDeviceType)
-
-#define CSMI_SAS_PHY_UNUSED               0x00
-#define CSMI_SAS_NO_DEVICE_ATTACHED       0x00
-#define CSMI_SAS_END_DEVICE               0x10
-#define CSMI_SAS_EDGE_EXPANDER_DEVICE     0x20
-#define CSMI_SAS_FANOUT_EXPANDER_DEVICE   0x30
-
-// Protocol options
-// (bInitiatorPortProtocol, bTargetPortProtocol)
-
-#define CSMI_SAS_PROTOCOL_SATA   0x01
-#define CSMI_SAS_PROTOCOL_SMP    0x02
-#define CSMI_SAS_PROTOCOL_STP    0x04
-#define CSMI_SAS_PROTOCOL_SSP    0x08
-
-// Negotiated and hardware link rates
-// (bNegotiatedLinkRate, bMinimumLinkRate, bMaximumLinkRate)
-
-#define CSMI_SAS_LINK_RATE_UNKNOWN  0x00
-#define CSMI_SAS_PHY_DISABLED       0x01
-#define CSMI_SAS_LINK_RATE_FAILED   0x02
-#define CSMI_SAS_SATA_SPINUP_HOLD   0x03
-#define CSMI_SAS_SATA_PORT_SELECTOR 0x04
-#define CSMI_SAS_LINK_RATE_1_5_GBPS 0x08
-#define CSMI_SAS_LINK_RATE_3_0_GBPS 0x09
-#define CSMI_SAS_LINK_VIRTUAL       0x10
-
-// Discover state
-// (bAutoDiscover)
-
-#define CSMI_SAS_DISCOVER_NOT_SUPPORTED   0x00
-#define CSMI_SAS_DISCOVER_NOT_STARTED     0x01
-#define CSMI_SAS_DISCOVER_IN_PROGRESS     0x02
-#define CSMI_SAS_DISCOVER_COMPLETE        0x03
-#define CSMI_SAS_DISCOVER_ERROR           0x04
-
-// Programmed link rates
-// (bMinimumLinkRate, bMaximumLinkRate)
-// (bProgrammedMinimumLinkRate, bProgrammedMaximumLinkRate)
-
-#define CSMI_SAS_PROGRAMMED_LINK_RATE_UNCHANGED 0x00
-#define CSMI_SAS_PROGRAMMED_LINK_RATE_1_5_GBPS  0x08
-#define CSMI_SAS_PROGRAMMED_LINK_RATE_3_0_GBPS  0x09
-
-// Link rate
-// (bNegotiatedLinkRate in CSMI_SAS_SET_PHY_INFO)
-
-#define CSMI_SAS_LINK_RATE_NEGOTIATE      0x00
-#define CSMI_SAS_LINK_RATE_PHY_DISABLED   0x01
-
-// Signal class
-// (bSignalClass in CSMI_SAS_SET_PHY_INFO)
-
-#define CSMI_SAS_SIGNAL_CLASS_UNKNOWN     0x00
-#define CSMI_SAS_SIGNAL_CLASS_DIRECT      0x01
-#define CSMI_SAS_SIGNAL_CLASS_SERVER      0x02
-#define CSMI_SAS_SIGNAL_CLASS_ENCLOSURE   0x03
-
-// Link error reset
-// (bResetCounts)
-
-#define CSMI_SAS_LINK_ERROR_DONT_RESET_COUNTS   0x00
-#define CSMI_SAS_LINK_ERROR_RESET_COUNTS        0x01
-
-// Phy identifier
-// (bPhyIdentifier)
-
-#define CSMI_SAS_USE_PORT_IDENTIFIER   0xFF
-
-// Port identifier
-// (bPortIdentifier)
-
-#define CSMI_SAS_IGNORE_PORT           0xFF
-
-// Programmed link rates
-// (bConnectionRate)
-
-#define CSMI_SAS_LINK_RATE_NEGOTIATED  0x00
-#define CSMI_SAS_LINK_RATE_1_5_GBPS    0x08
-#define CSMI_SAS_LINK_RATE_3_0_GBPS    0x09
-
-// Connection status
-// (bConnectionStatus)
-
-#define CSMI_SAS_OPEN_ACCEPT                          0
-#define CSMI_SAS_OPEN_REJECT_BAD_DESTINATION          1
-#define CSMI_SAS_OPEN_REJECT_RATE_NOT_SUPPORTED       2
-#define CSMI_SAS_OPEN_REJECT_NO_DESTINATION           3
-#define CSMI_SAS_OPEN_REJECT_PATHWAY_BLOCKED          4
-#define CSMI_SAS_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED   5
-#define CSMI_SAS_OPEN_REJECT_RESERVE_ABANDON          6
-#define CSMI_SAS_OPEN_REJECT_RESERVE_CONTINUE         7
-#define CSMI_SAS_OPEN_REJECT_RESERVE_INITIALIZE       8
-#define CSMI_SAS_OPEN_REJECT_RESERVE_STOP             9
-#define CSMI_SAS_OPEN_REJECT_RETRY                    10
-#define CSMI_SAS_OPEN_REJECT_STP_RESOURCES_BUSY       11
-#define CSMI_SAS_OPEN_REJECT_WRONG_DESTINATION        12
-
-// SSP Status
-// (bSSPStatus)
-
-#define CSMI_SAS_SSP_STATUS_UNKNOWN     0x00
-#define CSMI_SAS_SSP_STATUS_WAITING     0x01
-#define CSMI_SAS_SSP_STATUS_COMPLETED   0x02
-#define CSMI_SAS_SSP_STATUS_FATAL_ERROR 0x03
-#define CSMI_SAS_SSP_STATUS_RETRY       0x04
-#define CSMI_SAS_SSP_STATUS_NO_TAG      0x05
-
-// SSP Flags
-// (uFlags)
-
-#define CSMI_SAS_SSP_READ           0x00000001
-#define CSMI_SAS_SSP_WRITE          0x00000002
-#define CSMI_SAS_SSP_UNSPECIFIED    0x00000004
-
-#define CSMI_SAS_SSP_TASK_ATTRIBUTE_SIMPLE         0x00000000
-#define CSMI_SAS_SSP_TASK_ATTRIBUTE_HEAD_OF_QUEUE  0x00000010
-#define CSMI_SAS_SSP_TASK_ATTRIBUTE_ORDERED        0x00000020
-#define CSMI_SAS_SSP_TASK_ATTRIBUTE_ACA            0x00000040
-
-// SSP Data present
-// (bDataPresent)
-
-#define CSMI_SAS_SSP_NO_DATA_PRESENT         0x00
-#define CSMI_SAS_SSP_RESPONSE_DATA_PRESENT   0x01
-#define CSMI_SAS_SSP_SENSE_DATA_PRESENT      0x02
-
-// STP Flags
-// (uFlags)
-
-#define CSMI_SAS_STP_READ           0x00000001
-#define CSMI_SAS_STP_WRITE          0x00000002
-#define CSMI_SAS_STP_UNSPECIFIED    0x00000004
-#define CSMI_SAS_STP_PIO            0x00000010
-#define CSMI_SAS_STP_DMA            0x00000020
-#define CSMI_SAS_STP_PACKET         0x00000040
-#define CSMI_SAS_STP_DMA_QUEUED     0x00000080
-#define CSMI_SAS_STP_EXECUTE_DIAG   0x00000100
-#define CSMI_SAS_STP_RESET_DEVICE   0x00000200
-
-// Task Management Flags
-// (uFlags)
-
-#define CSMI_SAS_TASK_IU               0x00000001
-#define CSMI_SAS_HARD_RESET_SEQUENCE   0x00000002
-#define CSMI_SAS_SUPPRESS_RESULT       0x00000004
-
-// Task Management Functions
-// (bTaskManagement)
-
-#define CSMI_SAS_SSP_ABORT_TASK           0x01
-#define CSMI_SAS_SSP_ABORT_TASK_SET       0x02
-#define CSMI_SAS_SSP_CLEAR_TASK_SET       0x04
-#define CSMI_SAS_SSP_LOGICAL_UNIT_RESET   0x08
-#define CSMI_SAS_SSP_CLEAR_ACA            0x40
-#define CSMI_SAS_SSP_QUERY_TASK           0x80
-
-// Task Management Information
-// (uInformation)
-
-#define CSMI_SAS_SSP_TEST           1
-#define CSMI_SAS_SSP_EXCEEDED       2
-#define CSMI_SAS_SSP_DEMAND         3
-#define CSMI_SAS_SSP_TRIGGER        4
-
-// Connector Pinout Information
-// (uPinout)
-
-#define CSMI_SAS_CON_UNKNOWN              0x00000001
-#define CSMI_SAS_CON_SFF_8482             0x00000002
-#define CSMI_SAS_CON_SFF_8470_LANE_1      0x00000100
-#define CSMI_SAS_CON_SFF_8470_LANE_2      0x00000200
-#define CSMI_SAS_CON_SFF_8470_LANE_3      0x00000400
-#define CSMI_SAS_CON_SFF_8470_LANE_4      0x00000800
-#define CSMI_SAS_CON_SFF_8484_LANE_1      0x00010000
-#define CSMI_SAS_CON_SFF_8484_LANE_2      0x00020000
-#define CSMI_SAS_CON_SFF_8484_LANE_3      0x00040000
-#define CSMI_SAS_CON_SFF_8484_LANE_4      0x00080000
-
-// Connector Location Information
-// (bLocation)
-
-// same as uPinout above...
-// #define CSMI_SAS_CON_UNKNOWN              0x01
-#define CSMI_SAS_CON_INTERNAL             0x02
-#define CSMI_SAS_CON_EXTERNAL             0x04
-#define CSMI_SAS_CON_SWITCHABLE           0x08
-#define CSMI_SAS_CON_AUTO                 0x10
-#define CSMI_SAS_CON_NOT_PRESENT          0x20
-#define CSMI_SAS_CON_NOT_CONNECTED        0x80
-
-// Device location identification
-// (bIdentify)
-
-#define CSMI_SAS_LOCATE_UNKNOWN           0x00
-#define CSMI_SAS_LOCATE_FORCE_OFF         0x01
-#define CSMI_SAS_LOCATE_FORCE_ON          0x02
-
-// Location Valid flags
-// (uLocationFlags)
-
-#define CSMI_SAS_LOCATE_SAS_ADDRESS_VALID           0x00000001
-#define CSMI_SAS_LOCATE_SAS_LUN_VALID               0x00000002
-#define CSMI_SAS_LOCATE_ENCLOSURE_IDENTIFIER_VALID  0x00000004
-#define CSMI_SAS_LOCATE_ENCLOSURE_NAME_VALID        0x00000008
-#define CSMI_SAS_LOCATE_BAY_PREFIX_VALID            0x00000010
-#define CSMI_SAS_LOCATE_BAY_IDENTIFIER_VALID        0x00000020
-#define CSMI_SAS_LOCATE_LOCATION_STATE_VALID        0x00000040
-
-/* * * * * * * * SAS Phy Control Class IOCTL Constants * * * * * * * * */
-
-// Return codes for SAS Phy Control IOCTL's
-// (IoctlHeader.ReturnCode)
-
-// Signature value
-// (IoctlHeader.Signature)
-
-#define CSMI_PHY_SIGNATURE    "CSMIPHY"
-
-// Phy Control Functions
-// (bFunction)
-
-// values 0x00 to 0xFF are consistent in definition with the SMP PHY CONTROL
-// function defined in the SAS spec
-#define CSMI_SAS_PC_NOP                   0x00000000
-#define CSMI_SAS_PC_LINK_RESET            0x00000001
-#define CSMI_SAS_PC_HARD_RESET            0x00000002
-#define CSMI_SAS_PC_PHY_DISABLE           0x00000003
-// 0x04 to 0xFF reserved...
-#define CSMI_SAS_PC_GET_PHY_SETTINGS      0x00000100
-
-// Link Flags
-#define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001
-#define CSMI_SAS_PHY_UPDATE_SPINUP_RATE   0x00000002
-#define CSMI_SAS_PHY_AUTO_COMWAKE         0x00000004
-
-// Device Types for Phy Settings
-// (bType)
-#define CSMI_SAS_UNDEFINED 0x00
-#define CSMI_SAS_SATA      0x01
-#define CSMI_SAS_SAS       0x02
-
-// Transmitter Flags
-// (uTransmitterFlags)
-#define CSMI_SAS_PHY_PREEMPHASIS_DISABLED    0x00000001
-
-// Receiver Flags
-// (uReceiverFlags)
-#define CSMI_SAS_PHY_EQUALIZATION_DISABLED   0x00000001
-
-// Pattern Flags
-// (uPatternFlags)
-// #define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001
-#define CSMI_SAS_PHY_DISABLE_SCRAMBLING      0x00000002
-#define CSMI_SAS_PHY_DISABLE_ALIGN           0x00000004
-#define CSMI_SAS_PHY_DISABLE_SSC             0x00000008
-
-#define CSMI_SAS_PHY_FIXED_PATTERN           0x00000010
-#define CSMI_SAS_PHY_USER_PATTERN            0x00000020
-
-// Fixed Patterns
-// (bFixedPattern)
-#define CSMI_SAS_PHY_CJPAT                   0x00000001
-#define CSMI_SAS_PHY_ALIGN                   0x00000002
-
-// Type Flags
-// (bTypeFlags)
-#define CSMI_SAS_PHY_POSITIVE_DISPARITY      0x01
-#define CSMI_SAS_PHY_NEGATIVE_DISPARITY      0x02
-#define CSMI_SAS_PHY_CONTROL_CHARACTER       0x04
-
-// Miscellaneous
-#define SLOT_NUMBER_UNKNOWN   0xFFFF
-
-/*************************************************************************/
-/* DATA STRUCTURES                                                       */
-/*************************************************************************/
-
-/* * * * * * * * * * Class Independent Structures * * * * * * * * * */
-
-// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
-#pragma pack(8)
-
-// CC_CSMI_SAS_DRIVER_INFO
-
-typedef struct _CSMI_SAS_DRIVER_INFO {
-   __u8  szName[81];
-   __u8  szDescription[81];
-   __u16 usMajorRevision;
-   __u16 usMinorRevision;
-   __u16 usBuildRevision;
-   __u16 usReleaseRevision;
-   __u16 usCSMIMajorRevision;
-   __u16 usCSMIMinorRevision;
-} CSMI_SAS_DRIVER_INFO,
-  *PCSMI_SAS_DRIVER_INFO;
-
-typedef struct _CSMI_SAS_DRIVER_INFO_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_DRIVER_INFO Information;
-} CSMI_SAS_DRIVER_INFO_BUFFER,
-  *PCSMI_SAS_DRIVER_INFO_BUFFER;
-
-// CC_CSMI_SAS_CNTLR_CONFIGURATION
-
-typedef struct _CSMI_SAS_PCI_BUS_ADDRESS {
-   __u8  bBusNumber;
-   __u8  bDeviceNumber;
-   __u8  bFunctionNumber;
-   __u8  bReserved;
-} CSMI_SAS_PCI_BUS_ADDRESS,
-  *PCSMI_SAS_PCI_BUS_ADDRESS;
-
-typedef union _CSMI_SAS_IO_BUS_ADDRESS {
-   CSMI_SAS_PCI_BUS_ADDRESS PciAddress;
-   __u8  bReserved[32];
-} CSMI_SAS_IO_BUS_ADDRESS,
-  *PCSMI_SAS_IO_BUS_ADDRESS;
-
-typedef struct _CSMI_SAS_CNTLR_CONFIG {
-   __u32 uBaseIoAddress;
-   struct {
-      __u32 uLowPart;
-      __u32 uHighPart;
-   } BaseMemoryAddress;
-   __u32 uBoardID;
-   __u16 usSlotNumber;
-   __u8  bControllerClass;
-   __u8  bIoBusType;
-   CSMI_SAS_IO_BUS_ADDRESS BusAddress;
-   __u8  szSerialNumber[81];
-   __u16 usMajorRevision;
-   __u16 usMinorRevision;
-   __u16 usBuildRevision;
-   __u16 usReleaseRevision;
-   __u16 usBIOSMajorRevision;
-   __u16 usBIOSMinorRevision;
-   __u16 usBIOSBuildRevision;
-   __u16 usBIOSReleaseRevision;
-   __u32 uControllerFlags;
-   __u16 usRromMajorRevision;
-   __u16 usRromMinorRevision;
-   __u16 usRromBuildRevision;
-   __u16 usRromReleaseRevision;
-   __u16 usRromBIOSMajorRevision;
-   __u16 usRromBIOSMinorRevision;
-   __u16 usRromBIOSBuildRevision;
-   __u16 usRromBIOSReleaseRevision;
-   __u8  bReserved[7];
-} CSMI_SAS_CNTLR_CONFIG,
-  *PCSMI_SAS_CNTLR_CONFIG;
-
-typedef struct _CSMI_SAS_CNTLR_CONFIG_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_CNTLR_CONFIG Configuration;
-} CSMI_SAS_CNTLR_CONFIG_BUFFER,
-  *PCSMI_SAS_CNTLR_CONFIG_BUFFER;
-
-// CC_CSMI_SAS_CNTLR_STATUS
-
-typedef struct _CSMI_SAS_CNTLR_STATUS {
-   __u32 uStatus;
-   __u32 uOfflineReason;
-   __u8  bReserved[28];
-} CSMI_SAS_CNTLR_STATUS,
-  *PCSMI_SAS_CNTLR_STATUS;
-
-typedef struct _CSMI_SAS_CNTLR_STATUS_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_CNTLR_STATUS Status;
-} CSMI_SAS_CNTLR_STATUS_BUFFER,
-  *PCSMI_SAS_CNTLR_STATUS_BUFFER;
-
-// CC_CSMI_SAS_FIRMWARE_DOWNLOAD
-
-typedef struct _CSMI_SAS_FIRMWARE_DOWNLOAD {
-   __u32 uBufferLength;
-   __u32 uDownloadFlags;
-   __u8  bReserved[32];
-   __u16 usStatus;
-   __u16 usSeverity;
-} CSMI_SAS_FIRMWARE_DOWNLOAD,
-  *PCSMI_SAS_FIRMWARE_DOWNLOAD;
-
-typedef struct _CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_FIRMWARE_DOWNLOAD Information;
-   __u8  bDataBuffer[1];
-} CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER,
-  *PCSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER;
-
-// CC_CSMI_SAS_RAID_INFO
-
-typedef struct _CSMI_SAS_RAID_INFO {
-   __u32 uNumRaidSets;
-   __u32 uMaxDrivesPerSet;
-   __u8  bReserved[92];
-} CSMI_SAS_RAID_INFO,
-  *PCSMI_SAS_RAID_INFO;
-
-typedef struct _CSMI_SAS_RAID_INFO_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_RAID_INFO Information;
-} CSMI_SAS_RAID_INFO_BUFFER,
-  *PCSMI_SAS_RAID_INFO_BUFFER;
-
-// CC_CSMI_SAS_GET_RAID_CONFIG
-
-typedef struct _CSMI_SAS_RAID_DRIVES {
-   __u8  bModel[40];
-   __u8  bFirmware[8];
-   __u8  bSerialNumber[40];
-   __u8  bSASAddress[8];
-   __u8  bSASLun[8];
-   __u8  bDriveStatus;
-   __u8  bDriveUsage;
-   __u8  bReserved[30];
-} CSMI_SAS_RAID_DRIVES,
-   *PCSMI_SAS_RAID_DRIVES;
-
-typedef struct _CSMI_SAS_RAID_CONFIG {
-   __u32 uRaidSetIndex;
-   __u32 uCapacity;
-   __u32 uStripeSize;
-   __u8  bRaidType;
-   __u8  bStatus;
-   __u8  bInformation;
-   __u8  bDriveCount;
-   __u8  bReserved[20];
-   CSMI_SAS_RAID_DRIVES Drives[1];
-} CSMI_SAS_RAID_CONFIG,
-   *PCSMI_SAS_RAID_CONFIG;
-
-typedef struct _CSMI_SAS_RAID_CONFIG_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_RAID_CONFIG Configuration;
-} CSMI_SAS_RAID_CONFIG_BUFFER,
-  *PCSMI_SAS_RAID_CONFIG_BUFFER;
-
-
-/* * * * * * * * * * SAS HBA Class Structures * * * * * * * * * */
-
-// CC_CSMI_SAS_GET_PHY_INFO
-
-typedef struct _CSMI_SAS_IDENTIFY {
-   __u8  bDeviceType;
-   __u8  bRestricted;
-   __u8  bInitiatorPortProtocol;
-   __u8  bTargetPortProtocol;
-   __u8  bRestricted2[8];
-   __u8  bSASAddress[8];
-   __u8  bPhyIdentifier;
-   __u8  bSignalClass;
-   __u8  bReserved[6];
-} CSMI_SAS_IDENTIFY,
-  *PCSMI_SAS_IDENTIFY;
-
-typedef struct _CSMI_SAS_PHY_ENTITY {
-   CSMI_SAS_IDENTIFY Identify;
-   __u8  bPortIdentifier;
-   __u8  bNegotiatedLinkRate;
-   __u8  bMinimumLinkRate;
-   __u8  bMaximumLinkRate;
-   __u8  bPhyChangeCount;
-   __u8  bAutoDiscover;
-   __u8  bReserved[2];
-   CSMI_SAS_IDENTIFY Attached;
-} CSMI_SAS_PHY_ENTITY,
-  *PCSMI_SAS_PHY_ENTITY;
-
-typedef struct _CSMI_SAS_PHY_INFO {
-   __u8  bNumberOfPhys;
-   __u8  bReserved[3];
-   CSMI_SAS_PHY_ENTITY Phy[32];
-} CSMI_SAS_PHY_INFO,
-  *PCSMI_SAS_PHY_INFO;
-
-typedef struct _CSMI_SAS_PHY_INFO_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_PHY_INFO Information;
-} CSMI_SAS_PHY_INFO_BUFFER,
-  *PCSMI_SAS_PHY_INFO_BUFFER;
-
-// CC_CSMI_SAS_SET_PHY_INFO
-
-typedef struct _CSMI_SAS_SET_PHY_INFO {
-   __u8  bPhyIdentifier;
-   __u8  bNegotiatedLinkRate;
-   __u8  bProgrammedMinimumLinkRate;
-   __u8  bProgrammedMaximumLinkRate;
-   __u8  bSignalClass;
-   __u8  bReserved[3];
-} CSMI_SAS_SET_PHY_INFO,
-  *PCSMI_SAS_SET_PHY_INFO;
-
-typedef struct _CSMI_SAS_SET_PHY_INFO_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_SET_PHY_INFO Information;
-} CSMI_SAS_SET_PHY_INFO_BUFFER,
-  *PCSMI_SAS_SET_PHY_INFO_BUFFER;
-
-// CC_CSMI_SAS_GET_LINK_ERRORS
-
-typedef struct _CSMI_SAS_LINK_ERRORS {
-   __u8  bPhyIdentifier;
-   __u8  bResetCounts;
-   __u8  bReserved[2];
-   __u32 uInvalidDwordCount;
-   __u32 uRunningDisparityErrorCount;
-   __u32 uLossOfDwordSyncCount;
-   __u32 uPhyResetProblemCount;
-} CSMI_SAS_LINK_ERRORS,
-  *PCSMI_SAS_LINK_ERRORS;
-
-typedef struct _CSMI_SAS_LINK_ERRORS_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_LINK_ERRORS Information;
-} CSMI_SAS_LINK_ERRORS_BUFFER,
-  *PCSMI_SAS_LINK_ERRORS_BUFFER;
-
-// CC_CSMI_SAS_SMP_PASSTHRU
-
-typedef struct _CSMI_SAS_SMP_REQUEST {
-   __u8  bFrameType;
-   __u8  bFunction;
-   __u8  bReserved[2];
-   __u8  bAdditionalRequestBytes[1016];
-} CSMI_SAS_SMP_REQUEST,
-  *PCSMI_SAS_SMP_REQUEST;
-
-typedef struct _CSMI_SAS_SMP_RESPONSE {
-   __u8  bFrameType;
-   __u8  bFunction;
-   __u8  bFunctionResult;
-   __u8  bReserved;
-   __u8  bAdditionalResponseBytes[1016];
-} CSMI_SAS_SMP_RESPONSE,
-  *PCSMI_SAS_SMP_RESPONSE;
-
-typedef struct _CSMI_SAS_SMP_PASSTHRU {
-   __u8  bPhyIdentifier;
-   __u8  bPortIdentifier;
-   __u8  bConnectionRate;
-   __u8  bReserved;
-   __u8  bDestinationSASAddress[8];
-   __u32 uRequestLength;
-   CSMI_SAS_SMP_REQUEST Request;
-   __u8  bConnectionStatus;
-   __u8  bReserved2[3];
-   __u32 uResponseBytes;
-   CSMI_SAS_SMP_RESPONSE Response;
-} CSMI_SAS_SMP_PASSTHRU,
-  *PCSMI_SAS_SMP_PASSTHRU;
-
-typedef struct _CSMI_SAS_SMP_PASSTHRU_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_SMP_PASSTHRU Parameters;
-} CSMI_SAS_SMP_PASSTHRU_BUFFER,
-  *PCSMI_SAS_SMP_PASSTHRU_BUFFER;
-
-// CC_CSMI_SAS_SSP_PASSTHRU
-
-typedef struct _CSMI_SAS_SSP_PASSTHRU {
-   __u8  bPhyIdentifier;
-   __u8  bPortIdentifier;
-   __u8  bConnectionRate;
-   __u8  bReserved;
-   __u8  bDestinationSASAddress[8];
-   __u8  bLun[8];
-   __u8  bCDBLength;
-   __u8  bAdditionalCDBLength;
-   __u8  bReserved2[2];
-   __u8  bCDB[16];
-   __u32 uFlags;
-   __u8  bAdditionalCDB[24];
-   __u32 uDataLength;
-} CSMI_SAS_SSP_PASSTHRU,
-  *PCSMI_SAS_SSP_PASSTHRU;
-
-typedef struct _CSMI_SAS_SSP_PASSTHRU_STATUS {
-   __u8  bConnectionStatus;
-   __u8  bSSPStatus;
-   __u8  bReserved[2];
-   __u8  bDataPresent;
-   __u8  bStatus;
-   __u8  bResponseLength[2];
-   __u8  bResponse[256];
-   __u32 uDataBytes;
-} CSMI_SAS_SSP_PASSTHRU_STATUS,
-  *PCSMI_SAS_SSP_PASSTHRU_STATUS;
-
-typedef struct _CSMI_SAS_SSP_PASSTHRU_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_SSP_PASSTHRU Parameters;
-   CSMI_SAS_SSP_PASSTHRU_STATUS Status;
-   __u8  bDataBuffer[1];
-} CSMI_SAS_SSP_PASSTHRU_BUFFER,
-  *PCSMI_SAS_SSP_PASSTHRU_BUFFER;
-
-// CC_CSMI_SAS_STP_PASSTHRU
-
-typedef struct _CSMI_SAS_STP_PASSTHRU {
-   __u8  bPhyIdentifier;
-   __u8  bPortIdentifier;
-   __u8  bConnectionRate;
-   __u8  bReserved;
-   __u8  bDestinationSASAddress[8];
-   __u8  bReserved2[4];
-   __u8  bCommandFIS[20];
-   __u32 uFlags;
-   __u32 uDataLength;
-} CSMI_SAS_STP_PASSTHRU,
-  *PCSMI_SAS_STP_PASSTHRU;
-
-typedef struct _CSMI_SAS_STP_PASSTHRU_STATUS {
-   __u8  bConnectionStatus;
-   __u8  bReserved[3];
-   __u8  bStatusFIS[20];
-   __u32 uSCR[16];
-   __u32 uDataBytes;
-} CSMI_SAS_STP_PASSTHRU_STATUS,
-  *PCSMI_SAS_STP_PASSTHRU_STATUS;
-
-typedef struct _CSMI_SAS_STP_PASSTHRU_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_STP_PASSTHRU Parameters;
-   CSMI_SAS_STP_PASSTHRU_STATUS Status;
-   __u8  bDataBuffer[1];
-} CSMI_SAS_STP_PASSTHRU_BUFFER,
-  *PCSMI_SAS_STP_PASSTHRU_BUFFER;
-
-// CC_CSMI_SAS_GET_SATA_SIGNATURE
-
-typedef struct _CSMI_SAS_SATA_SIGNATURE {
-   __u8  bPhyIdentifier;
-   __u8  bReserved[3];
-   __u8  bSignatureFIS[20];
-} CSMI_SAS_SATA_SIGNATURE,
-  *PCSMI_SAS_SATA_SIGNATURE;
-
-typedef struct _CSMI_SAS_SATA_SIGNATURE_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_SATA_SIGNATURE Signature;
-} CSMI_SAS_SATA_SIGNATURE_BUFFER,
-  *PCSMI_SAS_SATA_SIGNATURE_BUFFER;
-
-// CC_CSMI_SAS_GET_SCSI_ADDRESS
-
-typedef struct _CSMI_SAS_GET_SCSI_ADDRESS_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   __u8  bSASAddress[8];
-   __u8  bSASLun[8];
-   __u8  bHostIndex;
-   __u8  bPathId;
-   __u8  bTargetId;
-   __u8  bLun;
-} CSMI_SAS_GET_SCSI_ADDRESS_BUFFER,
-   *PCSMI_SAS_GET_SCSI_ADDRESS_BUFFER;
-
-// CC_CSMI_SAS_GET_DEVICE_ADDRESS
-
-typedef struct _CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   __u8  bHostIndex;
-   __u8  bPathId;
-   __u8  bTargetId;
-   __u8  bLun;
-   __u8  bSASAddress[8];
-   __u8  bSASLun[8];
-} CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER,
-  *PCSMI_SAS_GET_DEVICE_ADDRESS_BUFFER;
-
-// CC_CSMI_SAS_TASK_MANAGEMENT
-
-typedef struct _CSMI_SAS_SSP_TASK_IU {
-   __u8  bHostIndex;
-   __u8  bPathId;
-   __u8  bTargetId;
-   __u8  bLun;
-   __u32 uFlags;
-   __u32 uQueueTag;
-   __u32 uReserved;
-   __u8  bTaskManagementFunction;
-   __u8  bReserved[7];
-   __u32 uInformation;
-} CSMI_SAS_SSP_TASK_IU,
-  *PCSMI_SAS_SSP_TASK_IU;
-
-typedef struct _CSMI_SAS_SSP_TASK_IU_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_SSP_TASK_IU Parameters;
-   CSMI_SAS_SSP_PASSTHRU_STATUS Status;
-} CSMI_SAS_SSP_TASK_IU_BUFFER,
-  *PCSMI_SAS_SSP_TASK_IU_BUFFER;
-
-// CC_CSMI_SAS_GET_CONNECTOR_INFO
-
-typedef struct _CSMI_SAS_GET_CONNECTOR_INFO {
-   __u32 uPinout;
-   __u8  bConnector[16];
-   __u8  bLocation;
-   __u8  bReserved[15];
-} CSMI_SAS_CONNECTOR_INFO,
-  *PCSMI_SAS_CONNECTOR_INFO;
-
-typedef struct _CSMI_SAS_CONNECTOR_INFO_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   CSMI_SAS_CONNECTOR_INFO Reference[32];
-} CSMI_SAS_CONNECTOR_INFO_BUFFER,
-  *PCSMI_SAS_CONNECTOR_INFO_BUFFER;
-
-// CC_CSMI_SAS_GET_LOCATION
-
-typedef struct _CSMI_SAS_LOCATION_IDENTIFIER {
-   __u32 bLocationFlags;
-   __u8  bSASAddress[8];
-   __u8  bSASLun[8];
-   __u8  bEnclosureIdentifier[8];
-   __u8  bEnclosureName[32];
-   __u8  bBayPrefix[32];
-   __u8  bBayIdentifier;
-   __u8  bLocationState;
-   __u8  bReserved[2];
-} CSMI_SAS_LOCATION_IDENTIFIER,
-  *PCSMI_SAS_LOCATION_IDENTIFIER;
-
-typedef struct _CSMI_SAS_GET_LOCATION_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   __u8  bHostIndex;
-   __u8  bPathId;
-   __u8  bTargetId;
-   __u8  bLun;
-   __u8  bIdentify;
-   __u8  bNumberOfLocationIdentifiers;
-   __u8  bLengthOfLocationIdentifier;
-   CSMI_SAS_LOCATION_IDENTIFIER Location[1];
-} CSMI_SAS_GET_LOCATION_BUFFER,
-  *PCSMI_SAS_GET_LOCATION_BUFFER;
-
-// CC_CSMI_SAS_PHY_CONTROL
-
-typedef struct _CSMI_SAS_CHARACTER {
-   __u8  bTypeFlags;
-   __u8  bValue;
-} CSMI_SAS_CHARACTER,
-  *PCSMI_SAS_CHARACTER;
-
-typedef struct _CSMI_SAS_PHY_CONTROL {
-   __u8  bType;
-   __u8  bRate;
-   __u8  bReserved[6];
-   __u32 uVendorUnique[8];
-   __u32 uTransmitterFlags;
-   __i8  bTransmitAmplitude;
-   __i8  bTransmitterPreemphasis;
-   __i8  bTransmitterSlewRate;
-   __i8  bTransmitterReserved[13];
-   __u8  bTransmitterVendorUnique[64];
-   __u32 uReceiverFlags;
-   __i8  bReceiverThreshold;
-   __i8  bReceiverEqualizationGain;
-   __i8  bReceiverReserved[14];
-   __u8  bReceiverVendorUnique[64];
-   __u32 uPatternFlags;
-   __u8  bFixedPattern;
-   __u8  bUserPatternLength;
-   __u8  bPatternReserved[6];
-   CSMI_SAS_CHARACTER UserPatternBuffer[16];
-} CSMI_SAS_PHY_CONTROL,
-  *PCSMI_SAS_PHY_CONTROL;
-
-typedef struct _CSMI_SAS_PHY_CONTROL_BUFFER {
-   IOCTL_HEADER IoctlHeader;
-   __u32 uFunction;
-   __u8  bPhyIdentifier;
-   __u16 usLengthOfControl;
-   __u8  bNumberOfControls;
-   __u8  bReserved[4];
-   __u32 uLinkFlags;
-   __u8  bSpinupRate;
-   __u8  bLinkReserved[7];
-   __u32 uVendorUnique[8];
-   CSMI_SAS_PHY_CONTROL Control[1];
-} CSMI_SAS_PHY_CONTROL_BUFFER,
-  *PCSMI_SAS_PHY_CONTROL_BUFFER;
-
-// EDM #pragma CSMI_SAS_END_PACK
-#pragma pack()
-
-#endif // _CSMI_SAS_H_
--- a/drivers/scsi/vanir/include/generic/com_adapter_struct.h
+++ /dev/null
@@ -1,213 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_ADAPTER_STRUCT_H__
-#define __MV_COM_ADAPTER_STRUCT_H__
-
-#include "com_define.h"
-
-#pragma pack(8)
-
-#define BASE_ADDRESS_MAX_NUM                    6
-
-/* The following Version definition is kept here for backward compatability. */
-/* Each fields are two bytes too big. */
-typedef struct _Version_Info
-{
-	 MV_U32        VerMajor;
-	 MV_U32        VerMinor;
-	 MV_U32        VerOEM;
-	 MV_U32        VerBuild;
-}Version_Info, *PVersion_Info;
-
-/* The following Version definition are copied from CIM_SoftwareIdentity class */
-typedef struct _Version_Info_CIM
-{
-	 MV_U16        MajorVersion;
-	 MV_U16        MinorVersion;
-	 MV_U16        RevisionNumber;
-	 MV_U16        BuildNumber;
-}Version_Info_CIM, *PVersion_Info_CIM;
-
-#define SUPPORT_LD_MODE_RAID0                   MV_BIT(0)
-#define SUPPORT_LD_MODE_RAID1                   MV_BIT(1)
-#define SUPPORT_LD_MODE_RAID10                  MV_BIT(2)
-#define SUPPORT_LD_MODE_RAID1E                  MV_BIT(3)
-#define SUPPORT_LD_MODE_RAID5                   MV_BIT(4)
-#define SUPPORT_LD_MODE_RAID6                   MV_BIT(5)
-#define SUPPORT_LD_MODE_RAID50                  MV_BIT(6)
-#define SUPPORT_LD_MODE_JBOD                    MV_BIT(7)
-#define SUPPORT_LD_MODE_RAID60                  MV_BIT(8)
-#define SUPPORT_LD_MODE_CROSS_SATA_SSD          MV_BIT(9)
-#define SUPPORT_LD_MODE_HYPPER_HDD_MIRROR       MV_BIT(10)
-
-#define FEATURE_BGA_REBUILD_SUPPORT             MV_BIT(0)
-#define FEATURE_BGA_BKINIT_SUPPORT              MV_BIT(1)
-#define FEATURE_BGA_SYNC_SUPPORT                MV_BIT(2)
-#define FEATURE_BGA_MIGRATION_SUPPORT           MV_BIT(3)
-#define FEATURE_BGA_MEDIAPATROL_SUPPORT         MV_BIT(4)
-#define FEATURE_BGA_FEINIT_SUPPORT              MV_BIT(5)
-#define FEATURE_BGA_COPY_BACK_SUPPORT           MV_BIT(6)
-#define FEATURE_PD_OF_SAME_TYPE_WHEN_CREATE_VD  MV_BIT(7) // PDs must of the same type when used to create VD or DG
-
-#define ADV_FEATURE_EVENT_WITH_SENSE_CODE       MV_BIT(0)
-#define ADV_FEATURE_BIG_STRIPE_SUPPORT	        MV_BIT(1)
-#define ADV_FEATURE_BIOS_OPTION_SUPPORT		    MV_BIT(2) // to inform API if support upload/download bios
-#define ADV_FEATURE_HAS_BBU		                MV_BIT(3)
-#define ADV_FEATURE_CONFIG_IN_FLASH		        MV_BIT(4)
-#define ADV_FEATURE_CPU_EFFICIENCY_SUPPORT      MV_BIT(5)  // to inform API if support optimized CPU efficiency
-#define ADV_FEATURE_NO_MUTIL_VD_PER_PD          MV_BIT(6)
-#define ADV_FEATURE_SPC_4_BUFFER                MV_BIT(7)
-#define ADV_FEATURE_SES_DIRECT                  MV_BIT(8)
-#define ADV_FEATURE_MODULE_CONSOLIDATE			MV_BIT(9)
-#define ADV_FEATURE_IMAGE_HEALTH                MV_BIT(10) // support Image health
-#define ADV_FEATURE_SATA_PHY_CTRL_BY_PORT       MV_BIT(11) // support SATA PHY Control, port base.
-#define ADV_FEATURE_CRYPTO_SUPPORT              MV_BIT(12) // AES encryption, port based.
-#define ADV_FEATURE_OS_TIME_SUPPORT	            MV_BIT(13) // OS time support
-#define ADV_FEATURE_NO_VD_WRITE_CACHE_SUPPORT   MV_BIT(14) // Magni not support VD write cache
-#define ADV_FEATURE_NO_VD_READ_CACHE_SUPPORT    MV_BIT(15) // Magni not support VD read cache
-#define ADV_FEATURE_NO_HD_SMART_SUPPORT         MV_BIT(16) // Magni not support HD smart
-#define ADV_FEATURE_NO_VD_ROUNDING_SUPPORT      MV_BIT(17) // Magni not support VD GB Rounding
-#define ADV_FEATURE_NO_HD_SETFREE_SUPPORT       MV_BIT(18) // Magni not support set free
-#define ADV_FEATURE_NO_HD_WRITE_CACHE_SUPPORT   MV_BIT(19) // Magni not support HD write cache
-#define ADV_FEATURE_NO_ENC_SUPPORT              MV_BIT(20) // Magni not support encloure
-#define ADV_FEATURE_NO_BGA_RATE_CHANGE          MV_BIT(21) // Magni lite support bga but can not change rate
-
-#define PCIE_SPEED_UNKNOWN                      0
-/* Gen I (2.5Gbps) */
-#define PCIE_SPEED_GEN_I                        1
-/* Gen II (5Gbps) */
-#define PCIE_SPEED_GEN_II                       2
-
-#define PORT_PHY_PD     		MV_BIT(6)
-#define PORT_PHY_DIS    		MV_BIT(5)
-#define PORT_PHY_LOCK   		MV_BIT(4)
-#define PORT_PHY_EN     		MV_BIT(3)
-#define PORT_PHY_SPD    		0x7
-#define PORT_PHY_SPD_G3 		3
-#define PORT_PHY_SPD_G2 		2
-#define PORT_PHY_SPD_G1 		1
-#define PORT_PHY_SPD_MAX        0       // Max speed of HBA supports.
-
-#define STRIPE_SIZE_16 			MV_BIT(0)	// 16K
-#define STRIPE_SIZE_32 			MV_BIT(1)	// 32K
-#define STRIPE_SIZE_64 			MV_BIT(2)	// 64K
-#define STRIPE_SIZE_128 		MV_BIT(3)	// 128K
-#define STRIPE_SIZE_256			MV_BIT(4)	// 256K
-#define STRIPE_SIZE_512 		MV_BIT(5)	// 512K
-#define STRIPE_SIZE_1024 		MV_BIT(6)	// 1024K
-#define STRIPE_SIZE_MASK		(0x7F)		// all above
-
-typedef struct _Adapter_Info
-{
-	Version_Info        DriverVersion;
-	Version_Info_CIM    BIOSVersion;
-	Version_Info_CIM    FirmwareVersion;
-	Version_Info_CIM    BootLoaderVersion;
-	MV_U64              Reserved1[1];     /* Reserve for firmware */
-
-	MV_U32              SystemIOBusNumber;
-	MV_U32              SlotNumber;
-
-	MV_U32              InterruptLevel;
-	MV_U32              InterruptVector;
-
-	MV_U16              VenID;
-	MV_U16              SubVenID;
-	MV_U16              DevID;
-	MV_U16              SubDevID;
-
-	MV_U8               PortCount;
-	MV_U8               PortSupportType;  /* SATA, SAS, PATA etc, use MV_BIT */
-	MV_U8               Features;         /* Feature bits.  See FEATURE_XXX */
-	MV_BOOLEAN          AlarmSupport;
-	MV_U8               RevisionID;       /* Chip revision */
-	MV_U8				MaxPDPerVD;
-	MV_U16              StripeSizeSupported;  // Supported stripe size.  See STRIPE_SIZE_XXX
-
-	MV_U32              AdvancedFeatures; /* Advanced feature bits.  See ADV_FEATURE_XXX */
-	MV_U8               MaxPDPerDG;
-	MV_U8               MaxVDPerDG;
-	MV_U8               MaxParityDisks;   /* Max parity disks for RAID6.  Multiply it by 2 for RAID60 */
-	MV_U8               MaxDiskGroup;
-
-	MV_U8               MaxTotalBlocks;
-	MV_U8               MaxBlockPerPD;
-	MV_U8               MaxHD;             /* Deprecated. Leave it here for backward compatibility.  New driver should use MaxHD_Ext */
-	MV_U8               MaxExpander;
-	MV_U8               MaxPM;
-	MV_U8               MaxLogicalDrive;
-	MV_U16              LogicalDriverMode;
-
-	MV_U8               WWN[8];            /* For future VDS use. */
-
-	MV_U16              MaxHD_Ext;		    /* Added to support max HD of 1024.  If it is 0, application should use MaxHD instead */
-	MV_U16              MaxBufferSize;		/* Max contiguous buffer size driver can handle in unit of 1024. Application based on this to allocate space in API */
-	MV_U16              MaxTotalBlocks_V2;	// For support 1024 and more blocks
-	MV_U8               MaxAESPort;
-	MV_U8               MaxHyperHdd;
-	MV_U8               Reserved3[12];
-	MV_U8               SerialNo[20];
-	MV_U8               PortSasAddress[16][8];  // SAS address of each port on the adapter
-	MV_U8               MaxSpeed;//Gen I (2.5Gbps)/Gen II (5Gbps)/
-	MV_U8               CurrentSpeed;//Gen I (2.5Gbps)/Gen II (5Gbps)/
-	MV_U8               MaxLinkWidth;//1x,2x,4x,8x
-	MV_U8               CurrentLinkWidth;//1x,2x,4x,8x
-	            // ADV_FEATURE_IMAGE_HEALTH ***
-	MV_BOOLEAN         img_health;         // AND all below image health state.
-	MV_BOOLEAN         autoload_img_health;
-	MV_BOOLEAN         boot_loader_img_health;
-	MV_BOOLEAN         firmware_img_health;
-	MV_BOOLEAN         boot_rom_img_health;    // func 0
-	MV_BOOLEAN         hba_info_img_health;
-	            // // ADV_FEATURE_IMAGE_HEALTH ###
-	MV_U8              Reserved4[2];        // pad
-	MV_U8              ModelNumber[20];
-} Adapter_Info, *PAdapter_Info;
-
-typedef struct _Adapter_Config_V2 {
-	MV_BOOLEAN      AlarmOn;
-	MV_BOOLEAN      AutoRebuildOn;
-	MV_U8           BGARate;
-	MV_BOOLEAN      PollSMARTStatus;
-	MV_U8           MediaPatrolRate;
-	MV_BOOLEAN      CopyBack;
-	MV_U8           SyncRate;				// syncronization rate (consistency check and fix)
-	MV_U8           InitRate;				// Initialization rate
-
-	MV_U8           RebuildRate;
-	MV_U8           MigrationRate;
-	MV_U8           CopybackRate;
-	MV_BOOLEAN      InterruptCoalescing;       // enable or disable
-	MV_BOOLEAN      ModuleConsolidate;
-	MV_BOOLEAN     v_atapi_disable;    // Virtual ATAPI disable. 0: enable/default; 1: disable
-	MV_U8          reserved0[2];       // pad MV_U8
-	MV_U8			port_phy_ctrl[8];  // Phy control of ports, ADV_FEATURE_SATA_PHY_CTRL_BY_PORT
-	MV_U8 		SerialNo[20];
-	MV_U8          ModelNumber[20];
-} Adapter_Config_V2, *PAdapter_Config_V2;
-
-/* To be backward compatible, keep the original Adapter_Config */
-typedef struct _Adapter_Config {
-	MV_BOOLEAN      AlarmOn;
-	MV_BOOLEAN      AutoRebuildOn;
-	MV_U8           BGARate;
-	MV_BOOLEAN      PollSMARTStatus;
-	MV_U8           MediaPatrolRate;
-	MV_BOOLEAN      CopyBack;
-	MV_U8           Reserved[2];
-} Adapter_Config, *PAdapter_Config;
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_array_struct.h
+++ /dev/null
@@ -1,128 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_ARRAY_STRUCT_H__
-#define __MV_COM_ARRAY_STRUCT_H__
-
-#include "com_raid_struct.h"
-#include "com_vd_struct.h"
-
-#define MAX_DG_SUPPORTED_API                    64
-
-#define DG_STATUS_FUNCTIONAL                    0
-#define DG_STATUS_PD_MISSING                    1
-#define DG_STATUS_PD_OFFLINE                    2
-
-#pragma pack(8)
-
-typedef struct _CreateOrModify_DG_Param
-{
-	MV_U16     DGID;                        // <=> InstanceID
-	MV_U8      Reserved1[2];
-	MV_U8      Name[LD_MAX_NAME_LENGTH];    // <=> ElementName.
-	MV_U8      RaidMode;                    // <=> Goal
-	MV_U8      SubVDCount;                  // for raid 10, 50, 60
-	MV_U8      NumParityDisk;               // for RAID 6
-	MV_U8      Reserved2[7];
-	MV_U16     StripeBlockSize;             // <=> Goal.UserDataStripeDepth (between API and driver, it is # of BlockSize)
-	MV_U64     Size;                        // <=> Size (in unit of BlockSize to/from driver)
-	MV_U32     BlockSize;                   // returned from driver (in byte)
-	MV_U8      InitializationOption;        // refer to INIT_XXXX
-	MV_U8      Reserved3[2];
-	MV_U8      PDCount;
-	MV_U16     PDIDs[MAX_HD_SUPPORTED_API]; // <=> InExtents[]
-	MV_U8      Reserved4[128];
-} CreateOrModify_DG_Param, * PCreateOrModify_DG_Param;
-
-typedef struct  _CreateOrModify_VD_Param
-{
-	MV_U16     VDID;                      // <=> DeviceID
-	MV_U16     DGID;                      // <=> InPool  (parent pool)
-	MV_U8      Name[LD_MAX_NAME_LENGTH];  // <=> ElementName
-	MV_U8      RaidMode;                  // <=> Goal
-	MV_U8      SubVDCount;                // for raid 10, 50, 60
-	MV_U8      NumParityDisk;             // for RAID 6
-	MV_U8      DGSlotNum;                 // Specify which DG slot the VD will be created upon. If set to 0xFF, driver will pick a slot with closest specified size.
-	MV_U8      Reserved1[6];
-	MV_U16     StripeBlockSize;           // <=> Goal.UserDataStripeDepth (between API and driver, it is # of BlockSize)
-	MV_U64     Size;                      // <=> Size (in unit of BlockSize to/from driver)
-
-	MV_U8      RoundingScheme;            // refer to ROUNDING_SCHEME_XXX
-	MV_U8      CachePolicy;               // refer to CACHEMODE_XXXX
-	MV_U8      InitializationOption;      //  refer to INIT_XXXX.
-	MV_U8      SectorCoefficient;         // (sector size) 1=>512 (default)
-	MV_U32     BlockSize;                 // used to calculate StripeBlockSize.
-	MV_U8      Reserved[256];
-} CreateOrModify_VD_Param, * PCreateOrModify_VD_Param;
-
-typedef struct _DG_Info
-{
-	MV_U16     DGID;                      // <=> InstanceID
-	MV_U8      Reserved1[2];
-	MV_U8      Name[LD_MAX_NAME_LENGTH];  // <=> ElementName
-	// other properties proprietary to Marvell
-	MV_U8      RaidMode;
-	MV_U8      SubVDCount;                // for raid 10, 50, 60
-	MV_U8      NumParityDisk;             // for RAID 6
-	MV_U8      AdapterID;
-
-	MV_U8      Reserved2[2];
-	MV_U16     StripeBlockSize;           // between RAIDAPI and driver, it is # of BlockSize
-	MV_U32     BlockSize;                 // disk block size
-
-	MV_U64     TotalManagedSpace;         // <=> TotalManagedSpace (in unit of BlockSize between API and driver)
-	MV_U64     RemainingManagedSpace;     // <=> RemainingManagedSpace in unit of BlockSize between API and driver)
-	MV_U64     SmallestAvailablePDSize;   // Available size of the smallest PD in this DG in unit of BlockSize between API and driver
-	MV_U8      Status;                    // OperationalStatus, refer to DG_STATUS_xxx
-	MV_U8      Reserved3[2];
-	MV_U8      PDCount;
-	MV_U16     PDIDs[MAX_HD_SUPPORTED_API];
-	MV_U8      Reserved4[3];
-	// VD slots are contiguous space in DG with existing VD on it or can be used to create VD.
-	// If VD created on empty slot does not use up all its slot space, the remaing space will be used to create
-	// another slot unless total slots number reaches MaxVDPerDG as defined in Adapter_Info. When total slots reaches
-	// it maximum number, VD created on the slot has to use up all its space.
-	MV_U8      VDSlotCount;						// current number of slots in DG
-	MV_U64     VDSlotSize[MAX_LD_SUPPORTED_API]; // size of each slot (including slot with VD)
-	MV_U16     VDIDs[MAX_LD_SUPPORTED_API];		 // VD ID corresponding to above slot. Entries with 0xFFFF means empty slot
-	MV_U8      Reserved5[3];
-	MV_U8      SparePDCount;
-	MV_U16     SparePDIDs[MAX_SPARE_PD_SUPPORTED_API];
-	MV_U16     BgaType;
-	MV_U8      BgaState;
-	MV_U8      Reserved6[25];
-} DG_Info, *PDG_Info;
-
-// Returning all PDs (and its status) that are not used by any DG on given adapter including spare, offline PD etc.
-typedef struct _PD_NotInAny_DG
-{
-	MV_U8      AdapterID;
-	MV_U8      Reserved1[1];
-	MV_U16     PDCount;
-	MV_U16     PDIDs[MAX_HD_SUPPORTED_API];
-	MV_U8      Status[MAX_HD_SUPPORTED_API];   // Status of the corresponding PD in PDIDs above.  Refer to HD_STATUS_XXX.
-	MV_U8      Reserved2[252];
-} PD_NotInAny_DG, *PPD_NotInAny_DG;
-
-typedef struct _DG_CONFIG
-{
-	MV_U16            DGID;
-	MV_BOOLEAN        WriteCacheOn;            // 1: enable write cache
-	MV_U8             Reserved;
-	MV_U8             Name[LD_MAX_NAME_LENGTH];  // DG Name
-	MV_U8             Reserved1[12];
-}DG_Config, *PDG_Config;
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_bbu_struct.h
+++ /dev/null
@@ -1,100 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_BBU_STRUCT_H__
-#define __MV_COM_BBU_STRUCT_H__
-
-#include "com_define.h"
-
-#pragma pack(8)
-
-/* battery status */
-#define BBU_STATUS_NOT_PRESENT          0
-#define BBU_STATUS_PRESENT              MV_BIT(0)
-#define BBU_STATUS_LOW_BATTERY          MV_BIT(1)
-#define BBU_STATUS_CHARGING             MV_BIT(2)
-#define BBU_STATUS_FULL_CHARGED         MV_BIT(3)
-#define BBU_STATUS_DISCHARGE            MV_BIT(4)
-#define BBU_STATUS_RELEARN              MV_BIT(5)
-#define BBU_STATUS_OVER_TEMP_WARNING    MV_BIT(6)
-#define BBU_STATUS_OVER_TEMP_ERROR      MV_BIT(7)
-#define BBU_STATUS_UNDER_TEMP_WARNING   MV_BIT(8)
-#define BBU_STATUS_UNDER_TEMP_ERROR     MV_BIT(9)
-#define BBU_STATUS_OVER_VOLT_WARNING    MV_BIT(10)
-#define BBU_STATUS_OVER_VOLT_ERROR      MV_BIT(11)
-#define BBU_STATUS_UNDER_VOLT_WARNING   MV_BIT(12)
-#define BBU_STATUS_UNDER_VOLT_ERROR     MV_BIT(13)
-#define BBU_STATUS_GREATER_LOWERBOUND	MV_BIT(14)
-#define BBU_STATUS_POWER_STOP_ALL	MV_BIT(15)
-
-#define BBU_NOT_PRESENT         0
-#define BBU_NORMAL                   1
-#define BBU_ABNORMAL               2
-
-#define BBU_SUPPORT_NONE                 0
-#define BBU_SUPPORT_SENSOR_TEMPERATURE   MV_BIT(0)
-#define BBU_SUPPORT_SENSOR_VOLTAGE       MV_BIT(1)
-#define BBU_SUPPORT_SENSOR_ECAPACITY     MV_BIT(2)
-#define BBU_SUPPORT_CHANGE_MAXEC         MV_BIT(3)
-#define BBU_SUPPORT_RELEARN              MV_BIT(4)
-
-#define BBU_SENSOR_NOTSUPPORT    0
-#define BBU_SENSOR_TEMPERATURE   MV_BIT(0)
-#define BBU_SENSOR_VOLTAGE       MV_BIT(1)
-#define BBU_SENSOR_ECAPACITY     MV_BIT(2)
-#define BBU_CHANGE_MAXEC         MV_BIT(3)
-#define BBU_SUPPORT_RELEARN      MV_BIT(4)
-
-typedef struct _BBU_Info
-{
-    //Total 64 Bytes
-    MV_U32          status;
-    MV_U32          prev_status;
-
-    MV_U16          voltage; /* unit is 1 mV */
-    MV_U16          supportMaxCapacity;
-    MV_U16          supportMinCapacity;
-    MV_U16          maxCapacity;
-
-    MV_U16          curCapacity;
-    MV_U16          time_to_empty;
-    MV_U16          time_to_full;
-    MV_U16          recharge_cycle;
-
-    MV_U16          featureSupport;
-    MV_I16          temperature; /*unit is 0.01 Celsius */
-    MV_U16           volt_lowerbound;
-    MV_U16           volt_upperbound;
-
-    MV_U8           temp_lowerbound;
-    MV_U8           temp_upperbound;
-    MV_U8           percentage;			// current percentage of barrtery capacity.
-    MV_U8           percent_to_charge;	// if percentage is lower than this number,it should begin to charge.
-    MV_U8           flags;
-    MV_U8           reserved1[3];
-
-    MV_U8           reserved2[24];
-} BBU_Info, *PBBU_Info;
-
-#define BBU_ACT_RELEARN          0
-#define BBU_ACT_FORCE_CHARGE     1
-#define BBU_ACT_FORCE_DISCHARGE  2
-#define BBU_ACT_STOP_ALL         3
-
-#define BBU_THRESHOLD_TYPE_CAPACITY        0
-#define BBU_THRESHOLD_TYPE_TEMPERATURE     1
-#define BBU_THRESHOLD_TYPE_VOLTAGE         2
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_dbg_struct.h
+++ /dev/null
@@ -1,80 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_DBG_STRUCT_H__
-#define __MV_COM_DBG_STRUCT_H__
-
-#include "com_define.h"
-
-#pragma pack(8)
-
-// Type of request for which the error should trigger.
-#define DBG_REQUEST_READ                        MV_BIT(0)
-#define DBG_REQUEST_WRITE                       MV_BIT(1)
-#define DBG_REQUEST_VERIFY                      MV_BIT(2)
-
-
-// The following data structure is dynamically allocated.  Depends on
-// NumSectors, the total size of the data structure should be
-// (8 + 4 + (SECTOR_LENGTH * NumSectors))
-// Where 8 is the size of LBA and 4 is the size of NumSectors itself.
-typedef struct _DBG_DATA
-{
-	MV_U64            LBA;
-	MV_U32            NumSectors;
-	MV_U8             Data[1];
-}DBG_Data, *PDBG_Data;
-
-typedef struct _DBG_HD
-{
-	MV_U64            LBA;
-	MV_U16            HDID;
-	MV_BOOLEAN     isUsed;
-	MV_U8             Reserved[5];
-}DBG_HD;
-
-typedef struct _DBG_FLASH
-{
-	MV_U32            OffSet;
-	MV_U16            NumBytes;
-	MV_U8             Data[1];
-}DBG_Flash, *PDBG_Flash;
-
-// Map to/from VD LBA to/from PD LBA
-typedef struct _DBG_MAP
-{
-	MV_U64            VD_LBA;
-	MV_U64            PD_LBA;
-	MV_U16            VDID;          // if 'mapDirection' is DBG_PD2VD, set it to 0xFFFF as input and driver will return the mapped VD ID
-	MV_U16            PDID;          // must specified in any case
-	MV_BOOLEAN        parity;        // [out](true or false) if 'mapDirection' is DBG_VD2PD, this tells if the specified PD is a parity disk or not.
-	MV_U8             mapDirection;  // DBG_VD2PD or DBG_PD2VD
-	MV_U8             Reserved[34];
-}DBG_Map, *PDBG_Map;
-
-typedef struct _DBG_Error_Injection
-{
-	MV_U64     LBA;
-	MV_U32     Count;
-	MV_U16     HDID;
-	MV_U8      Error_Status;
-	MV_U8      Request_Type;
-	MV_U8      Reserved[8];
-}DBG_Error_Injection, *PDBG_Error_Injection;
-
-#define DBG_VD2PD                               0
-#define DBG_PD2VD                               1
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_define.h
+++ /dev/null
@@ -1,178 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef COM_DEFINE_H
-#define COM_DEFINE_H
-
- #include "mv_os.h"
-
-/*
- *  This file defines Marvell OS independent primary data type for all OS.
- *
- *  We have macros to differentiate different CPU and OS.
- *
- *  CPU definitions:
- *  _CPU_X86_16B
- *  Specify 16bit x86 platform, this is used for BIOS and DOS utility.
- *  _CPU_X86_32B
- *  Specify 32bit x86 platform, this is used for most OS drivers.
- *  _CPU_IA_64B
- *  Specify 64bit IA64 platform, this is used for IA64 OS drivers.
- *  _CPU_AMD_64B
- *  Specify 64bit AMD64 platform, this is used for AMD64 OS drivers.
- *
- *  OS definitions:
- *  _OS_WINDOWS
- *  _OS_LINUX
- *  _OS_FREEBSD
- *  _OS_BIOS
- *  __QNXNTO__
- */
-
-#if !defined(IN)
-#   define IN
-#endif
-
-#if !defined(OUT)
-#   define OUT
-#endif
-
-#   define    BUFFER_PACKED               __attribute__((packed))
-
-#define MV_BIT(x)                         (1L << (x))
-
-#if !defined(NULL)
-#   define NULL 0
-#endif  /* NULL */
-
-#define MV_TRUE                           1
-#define MV_FALSE                          0
-#define MV_SUCCESS						  1
-#define MV_FAIL							  0
-
-typedef unsigned char  MV_BOOLEAN, *MV_PBOOLEAN;
-typedef unsigned char  MV_U8, *MV_PU8;
-typedef signed char  MV_I8, *MV_PI8;
-
-typedef unsigned short  MV_U16, *MV_PU16;
-typedef signed short  MV_I16, *MV_PI16;
-
-typedef void    MV_VOID, *MV_PVOID;
-typedef void            *MV_LPVOID;
-
-#   define BASEATTR
-
-typedef unsigned int MV_U32, *MV_PU32;
-typedef   signed int MV_I32, *MV_PI32;
-typedef unsigned long MV_ULONG, *MV_PULONG;
-typedef   signed long MV_ILONG, *MV_PILONG;
-typedef unsigned long long _MV_U64;
-typedef   signed long long _MV_I64;
-
-#   if defined(__KCONF_64BIT__)
-#      define _SUPPORT_64_BIT
-#   else
-#      ifdef _SUPPORT_64_BIT
-#         error Error 64_BIT CPU Macro
-#      endif
-#   endif /* defined(__KCONF_64BIT__) */
-
-/*
- * Primary Data Type
- */
-typedef union {
-        struct {
-#   if defined (__MV_LITTLE_ENDIAN__)
-            MV_U32 low;
-            MV_U32 high;
-#   elif defined (__MV_BIG_ENDIAN__)
-            MV_U32 high;
-            MV_U32 low;
-#   else
-#           error "undefined endianness"
-#   endif /* __MV_LITTLE_ENDIAN__ */
-        } parts;
-        _MV_U64 value;
-    } MV_U64, *PMV_U64, *MV_PU64;
-
-typedef _MV_U64 BUS_ADDRESS;
-
-/* PTR_INTEGER is necessary to convert between pointer and integer. */
-#if defined(_SUPPORT_64_BIT)
-   typedef _MV_U64 MV_PTR_INTEGER;
-#else
-   typedef MV_U32 MV_PTR_INTEGER;
-#endif /* defined(_SUPPORT_64_BIT) */
-
-#ifdef _SUPPORT_64_BIT
-#define _64_BIT_COMPILER     1
-#endif
-
-/* LBA is the logical block access */
-typedef MV_U64 MV_LBA;
-
-#if defined(_CPU_16B)
-    typedef MV_U32 MV_PHYSICAL_ADDR;
-#else
-    typedef MV_U64 MV_PHYSICAL_ADDR;
-#endif /* defined(_CPU_16B) */
-
-typedef MV_I32 MV_FILE_HANDLE;
-
-
-#include "com_product.h"
-
-#define hba_local_irq_disable() ossw_local_irq_disable()
-#define hba_local_irq_enable() ossw_local_irq_enable()
-#define hba_local_irq_save(flag) ossw_local_irq_save(&flag)
-#define hba_local_irq_restore(flag) ossw_local_irq_restore(&flag)
-
-/* expect pointers */
-#define OSSW_INIT_SPIN_LOCK(ext) ossw_init_spin_lock(ext)
-#define OSSW_SPIN_LOCK(ext)            ossw_spin_lock(ext)
-#define OSSW_SPIN_UNLOCK(ext)          ossw_spin_unlock(ext)
-#define OSSW_SPIN_LOCK_IRQ(ext)            ossw_spin_lock_irq(ext)
-#define OSSW_SPIN_UNLOCK_IRQ(ext)          ossw_spin_unlock_irq(ext)
-#define OSSW_SPIN_LOCK_IRQSAVE(ext, flag)          ossw_spin_lock_irq_save(ext, &flag)
-#define OSSW_SPIN_UNLOCK_IRQRESTORE(ext, flag)           ossw_spin_unlock_irq_restore(ext, &flag)
-#define OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP(ext, flag)          ossw_spin_lock_irq_save_spin_up(ext, &flag)
-#define OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(ext, flag)           ossw_spin_unlock_irq_restore_spin_up(ext, &flag)
-
-/* Delayed Execution Services */
-#define OSSW_INIT_TIMER(ptimer) ossw_init_timer(ptimer)
-
-#if !defined( likely )
-#define likely(x)		(x)
-#define unlikely(x)		(x)
-#endif
-
-#define GENERAL_DEBUG_INFO	MV_BIT(0)	/*For MV_DPRINT*/
-#define CORE_DEBUG_INFO		MV_BIT(1)	/*Core debug info: CORE_PRINT, CORE_EH_PRINT*/
-#define RAID_DEBUG_INFO		MV_BIT(2)	/*Raid debug info*/
-#define CACHE_DEBUG_INFO	MV_BIT(3)	/*Cache debug info*/
-#define CORE_FULL_DEBUG_INFO	(CORE_DEBUG_INFO | \
-							GENERAL_DEBUG_INFO) /*CORE_DPRINT, CORE_EH_PRINT, CORE_EVENT_PRINT*/
-#define RAID_FULL_DEBUG_INFO	(RAID_DEBUG_INFO | \
-							GENERAL_DEBUG_INFO)
-#define CACHE_FULL_DEBUG_INFO	(CACHE_DEBUG_INFO | \
-							GENERAL_DEBUG_INFO)
-
-#define sg_map(x)	hba_map_sg_to_buffer(x)
-#define sg_unmap(x)	hba_unmap_sg_to_buffer(x)
-
-#define time_is_expired(x) 	ossw_time_expired(x)
-#define EVENT_SET_DELAY_TIME(x, y) ((x) = ossw_set_expired_time(y))
-
-#define msi_enabled(x)	hba_msi_enabled(x)
-
-#endif /* COM_DEFINE_H */
--- a/drivers/scsi/vanir/include/generic/com_enc_struct.h
+++ /dev/null
@@ -1,383 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_ENC_STRUCT_H__
-#define __MV_COM_ENC_STRUCT_H__
-#include "com_physical_link.h"
-
-#define MAX_ENCLOSURE_API      32
-
-#pragma pack(8)
-
-// light types
-#define SGPIO_LED_ACTIVITY                      0
-#define SGPIO_LED_LOCATE                        1
-#define SGPIO_LED_ERROR                         2
-#define SGPIO_LED_REBUILD						3		/* for Supermicro backplanes */
-#define SGPIO_LED_HOT_SPARE                     4
-#define SGPIO_LED_REBUILD_MASK                  0x00000080
-#define SGPIO_LED_ERROR_MASK                    0x00000040
-#define SGPIO_LED_ALL                           0xff
-// light status - the following values are set according to hardware
-//       values, do not change unless necessary
-#define SGPIO_LED_LOW                           0
-#define SGPIO_LED_HIGH                          1
-#define SGPIO_LED_BLINK_A                       2
-#define SGPIO_LED_BLINK_INVRT_A                 3
-#define SGPIO_LED_BLINK_SOF                     4
-#define SGPIO_LED_BLINK_EOF                     5
-#define SGPIO_LED_BLINK_B                       6
-#define SGPIO_LED_BLINK_INVRT_B                 7
-// pre-set flags for RAID module to use
-#define LED_FLAG_REBUILD                      1
-#define LED_FLAG_HOT_SPARE                    2
-#define LED_FLAG_FAIL_DRIVE                   3
-#define LED_FLAG_HOT_SPARE_OFF                0x12
-#define LED_FLAG_OFF_ALL                      0xff
-#define LED_FLAG_ACT					4
-
-#define LED_FLAG_WORKING_CHECK                0x10
-#define LED_FLAG_REBUILD_OFF                  0x11
-#define LED_FLAG_FAIL_DRIVE_OFF               0x13
-
-
-//add as enclosure
-
-#define ENC_STATUS_NOT_EXIST        0
-#define ENC_STATUS_OK               1
-#define ENC_STATUS_UNSTABLE         2
-
-typedef struct _Enclosure_Info
-{
-	Link_Entity     Link;
-	MV_U8           AdapterID;
-	MV_U8           Status;           // Refer to ENC_STATUS_XXX
-	MV_U8           reserved1[2];
-	MV_U8           LogicalID[8+1];
-	MV_U8           VendorID[8+1];
-	MV_U8           ProductID[16+1];
-	MV_U8           RevisionLevel[4+1];
-	MV_U8			reserved2[3];
-	// If ExpanderCount > 0, the enclosure might have more than one parant, in this case
-	// Link.Parent.DevType will be set to DEVICE_TYPE_NONE and all other Parent fields are meaningless.
-	// To get all its parent info, use each of ExpanderIDs[] to find out its individual parent.
-	MV_U8			ExpanderCount;
-	MV_U16			ExpanderIDs[8];
-	MV_U8           path;
-	MV_U8           target;
-	MV_U8           lun;
-	MV_U8           slice;
-	MV_U8           reserved3[20];
-}Enclosure_Info, *PEnclosure_Info;
-
-#define MAX_ENCELEMENT      512
-#define ENC_COOLING_STOP 0
-
-typedef struct _EncCooling_Element
-{
-	MV_U16     curSpeed;
-	MV_U8      curSpeedcode;
-	MV_U8      reserved[5];
-} EncCooling_Element;
-
-typedef struct _EncPower_Element
-{
-	MV_U8      DCOverVoltage:1;
-	MV_U8      DCUnderVoltage:1;
-	MV_U8      DCOverCurrent:1;
-	MV_U8      hotSwap:1;
-	MV_U8      tempWarn:1;
-	MV_U8      reservedbit:3;
-	MV_U8      reserved[7];
-} EncPower_Element;
-
-typedef struct _EncTemperatureSensor_Element
-{
-	MV_U8      temperature;
-	MV_U8      OTFailure:1;
-	MV_U8      OTWarning:1;
-	MV_U8      UTFailure:1;
-	MV_U8      UTWarning:1;
-	MV_U8      reservedbit:4;
-	MV_U8      reserved[6];
-} EncTemperatureSensor_Element;
-
-typedef struct _EncDoorLock_Element
-{
-	MV_BOOLEAN       unlocked;
-	MV_U8            reserved[7];
-} EncDoorLock_Element;
-
-typedef struct _EncAudibleAlarm_Element
-{
-	MV_U8      mute:1;
-	MV_U8      remind:1;
-	MV_U8      reservedbit:6;
-	MV_U8      reserved[7];
-} EncAudibleAlarm_Element;
-
-#define ENC_DISPLAY_NOCHANGE            0
-#define ENC_DISPLAY_ENCCONTROL          1
-#define ENC_DISPLAY_CLIENT              2
-
-typedef struct _EncDisplay_Element
-{
-	MV_U8       character1;
-	MV_U8       character2;
-	MV_U8       mode;
-	MV_U8       reserved[5];
-} EncDisplay_Element;
-
-typedef struct _EncVoltageSensor_Element
-{
-	MV_U16     voltage;
-	MV_U8      warnOver:1;
-	MV_U8      warnUnder:1;
-	MV_U8      critOver:1;
-	MV_U8      critUnder:1;
-	MV_U8      reservedbit:4;
-	MV_U8      reserved[5];
-} EncVoltageSensor_Element;
-
-typedef struct _EncDevice_Element
-{
-	MV_U8      SlotAddress;
-	MV_U8      Report:1;
-	MV_U8      Ident:1;
-	MV_U8      Rmv:1;
-	MV_U8      ReadyToInst:1;
-	MV_U8      EncBypassedB:1;
-	MV_U8      EncBypassedA:1;
-	MV_U8      DoNotRemove:1;
-	MV_U8      AppClientBypassedA:1;
-
-	MV_U8      DeviceBypassedB:1;
-	MV_U8      DeviceBypassedA:1;
-	MV_U8      ByPassedB:1;
-	MV_U8      ByPassedA:1;
-	MV_U8      DeviceOff:1;
-	MV_U8      FaultReqstd:1;
-	MV_U8      FaultSensed:1;
-	MV_U8      AppClientBypassedB:1;
-	MV_U8      reserved[5];
-} EncDevice_Element;
-
-typedef struct _EncArrayDevice_Element
-	{
-	MV_U8      RrAbort:1;	         // Rebuild or Remap Abort
-	MV_U8      RebuildRemap:1;		// Rebuild or Remap
-	MV_U8      InFailedArray:1;
-	MV_U8      InCritArray:1;
-	MV_U8      ConsChk:1;
-	MV_U8      HotSpare:1;
-	MV_U8      RsvdDevice:1;
-	MV_U8      Ok:1;
-
-	MV_U8      Report:1;
-	MV_U8      Ident:1;
-	MV_U8      Rmv:1;
-	MV_U8      ReadyToInst:1;
-	MV_U8      EncBypassedB:1;
-	MV_U8      EncBypassedA:1;
-	MV_U8      DoNotRemove:1;
-	MV_U8      AppClientBypassedA:1;
-
-	MV_U8      DeviceBypassedB:1;
-	MV_U8      DeviceBypassedA:1;
-	MV_U8      ByPassedB:1;
-	MV_U8      ByPassedA:1;
-	MV_U8      DeviceOff:1;
-	MV_U8      FaultReqstd:1;
-	MV_U8      FaultSensed:1;
-	MV_U8      AppClientBypassedB:1;
-
-	MV_U8      reserved[5];
-} EncArrayDevice_Element;
-
-#define ENC_ELEMENTTYPE_UNKNOWN             0
-#define ENC_ELEMENTTYPE_DEVICE              1
-#define ENC_ELEMENTTYPE_POWERSUPPLY         2
-#define ENC_ELEMENTTYPE_COOLING             3
-#define ENC_ELEMENTTYPE_TEMPERATURE         4
-#define ENC_ELEMENTTYPE_DOORLOCK            5
-#define ENC_ELEMENTTYPE_AUDIBLEALARM        6
-#define ENC_ELEMENTTYPE_ENCSERVICE          7
-#define ENC_ELEMENTTYPE_SCCCONTROLLER       8
-#define ENC_ELEMENTTYPE_NONVOLATILECACHE    9
-#define ENC_ELEMENTTYPE_INVALIDOPERATION    10
-#define ENC_ELEMENTTYPE_UNINTERRPOWER       11
-#define ENC_ELEMENTTYPE_DISPLAY             12
-#define ENC_ELEMENTTYPE_KEYPAD              13
-#define ENC_ELEMENTTYPE_ENC                 14
-#define ENC_ELEMENTTYPE_SCSIPORT            15
-#define ENC_ELEMENTTYPE_LANGUAGE            16
-#define ENC_ELEMENTTYPE_COMMUNICATIONPORT   17
-#define ENC_ELEMENTTYPE_VOLTAGESENSOR       18
-#define ENC_ELEMENTTYPE_CURRENTSENSOR       19
-#define ENC_ELEMENTTYPE_SCSITARGETPORT      20
-#define ENC_ELEMENTTYPE_SCSIINITIATORPORT   21
-#define ENC_ELEMENTTYPE_SIMPLESUBENC        22
-#define ENC_ELEMENTTYPE_ARRAYDEVICE         23
-#define ENC_ELEMENTTYPE_SASEXP              24
-#define ENC_ELEMENTTYPE_SASCONNECTOR        25
-
-#define MV_SUPPORT_STATUS_ELEMENT_TYPE(type)	((type==ENC_ELEMENTTYPE_COOLING)||	\
-						(type==ENC_ELEMENTTYPE_DEVICE) || \
-						(type==ENC_ELEMENTTYPE_ARRAYDEVICE) || \
-						(type==ENC_ELEMENTTYPE_POWERSUPPLY) || \
-						(type==ENC_ELEMENTTYPE_TEMPERATURE) || \
-						(type==ENC_ELEMENTTYPE_DOORLOCK) || \
-						(type==ENC_ELEMENTTYPE_AUDIBLEALARM) || \
-						(type==ENC_ELEMENTTYPE_VOLTAGESENSOR) || \
-						(type==ENC_ELEMENTTYPE_ARRAYDEVICE) || \
-						(type==ENC_ELEMENTTYPE_DISPLAY))
-
-typedef struct _EncElementType_Info
-{
-	MV_U16                          enclosureID;
-	MV_U16                          magicID;
-	MV_U8                           type;
-	MV_U8		                    status;
-	MV_U8	                        elementID;
-	MV_U8                           reserved;
-	union {
-		EncDevice_Element               device;
-		EncArrayDevice_Element          arrayDevice;
-		EncCooling_Element              fan;
-		EncPower_Element                power;
-		EncTemperatureSensor_Element    temperatureSensor;
-		EncDoorLock_Element             doorLock;
-		EncAudibleAlarm_Element         alarm;
-		EncDisplay_Element              display;
-		EncVoltageSensor_Element        voltageSensor;
-		MV_U8                           unCode[8];
-	};
-} EncElementType_Info, *PEncElementType_Info;
-
-#define MV_SUPPORT_CONTROL_ELEMENT_TYPE(type)	((type==ENC_ELEMENTTYPE_COOLING)||	\
-									(type==ENC_ELEMENTTYPE_ARRAYDEVICE) || \
-									(type==ENC_ELEMENTTYPE_DEVICE))
-
-typedef struct _EncCooling_Control
-{
-	MV_U8   speedcode;
-	MV_U8   reserved[7];
-}EncCooling_Control,*PEncCooling_Control;
-
-typedef struct _EncDevice_Control
-{
-	MV_U8   LedOn;
-	MV_U8   reserved[7];
-}EncDevice_Control,*PEncDevice_Control;
-
-typedef struct _EncArrayDevice_Control
-{
-	MV_U8   LedOn;
-	MV_U8   reserved[7];
-}EncArrayDevice_Control,*PEncArrayDevice_Control;
-
-typedef struct _EncElementType_Control
-{
-	MV_U16                          enclosureID;
-	MV_U8                           type;
-	MV_U16                          magicID;
-	MV_U8                           control;
-	MV_U8	                        elementID;
-	MV_U8                           reserved;
-	union {
-		EncCooling_Control              fan;
-		EncDevice_Control               device;
-		EncArrayDevice_Control          arrayDevice;
-		MV_U8                           unCode[8];
-	};
-} EncElementType_Control, *PEncElementType_Control;
-
-typedef struct _DevElementStatusDescriptorEIP0
-{
-	MV_U8 config;
-	MV_U8 length;
-	MV_U8 infomantion[2];
-} DevElementStatusDescriptorEIP0, *PDevElementStatusDescriptorEIP0;
-
-typedef struct _DevElementStatusDescriptorEIP1
-{
-	MV_U8 config;
-	MV_U8 length;
-	MV_U8 reserved;
-	MV_U8 elementIndex;
-	MV_U8 infomantion[4];
-} DevElementStatusDescriptorEIP1, *PDevElementStatusDescriptorEIP1;
-
-typedef union
-{
-	DevElementStatusDescriptorEIP0 EIP0;
-	DevElementStatusDescriptorEIP1 EIP1;
-}DevElementStatusDescriptor, *PDevElementStatusDescriptor;
-
-typedef struct _DevElementStatusPage
-{
-	MV_U8                      PageCode;
-	MV_U8                      Reserved;
-	MV_U16                     PageLength;
-	MV_U8                      GenerationCode[4];
-	DevElementStatusDescriptor DeviceElementStatusDescriptor;
-	MV_U8                      Data[2032];
-} DevElementStatusPage, *PDevElementStatusPage;
-
-typedef struct _SasPhyDescriptor
-{
-	MV_U8 Reserved1:4;
-	MV_U8 DeviceType:3;
-	MV_U8 Reserved2:1;
-	MV_U8 Reserved3;
-	MV_U8 Reserved4:1;
-	MV_U8 SMPInitiatorPort:1;
-	MV_U8 STPInitiatorPort:1;
-	MV_U8 SSPInitiatorPort:1;
-	MV_U8 Reserved5:4;
-	MV_U8 Reserved6:1;
-	MV_U8 SMPTargetPort:1;
-	MV_U8 STPTargetPort:1;
-	MV_U8 SSPTargetPort:1;
-	MV_U8 Reserved7:4;
-	MV_U8 AttachedSASAddress[8];
-	MV_U8 SASAddress[8];
-	MV_U8 PhyIdentifier;
-	MV_U8 Reserved8[7];
-} SasPhyDescriptor, *PSasPhyDescriptor;
-
-#define HIGH_CRITICAL_THRESHOLD MV_BIT(0)
-#define HIGH_WARNING_THRESHOLD MV_BIT(1)
-#define LOW_CRITICAL_THRESHOLD MV_BIT(2)
-#define LOW_WARNING_THRESHOLD   MV_BIT(3)
-
-#define MV_ELEMENTTHRESHOLD_TYPE(type)	((type==ENC_ELEMENTTYPE_TEMPERATURE)||	\
-						(type==ENC_ELEMENTTYPE_VOLTAGESENSOR))
-
-typedef struct _EncElement_Config
-{
-	MV_U16    enclosureID;
-	MV_U16    magicID;
-	MV_U8     type;
-	MV_U8     status;
-	MV_U8	  elementID;
-	MV_U8     highCriticalThreshold;
-	MV_U8     highWarningThreshold;
-	MV_U8     lowCriticalThreshold;
-	MV_U8     lowWarningThreshold;
-	MV_U8	  reserved[5];
-} EncElement_Config, *PEncElement_Config;
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_error.h
+++ /dev/null
@@ -1,130 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __COM_ERROR_H__
-#define __COM_ERROR_H__
-
-#define ERR_GENERIC                              2
-#define ERR_RAID                                 50
-#define ERR_CORE                                 100
-#define ERR_API                                  150
-#define ERR_FLO									200
-#define ERR_AES                                 240
-#define ERR_NONE                                 0
-#define ERR_FAIL                                 1
-/* generic error */
-#define ERR_UNKNOWN                              (ERR_GENERIC + 1)
-#define ERR_NO_RESOURCE                          (ERR_GENERIC + 2)
-#define ERR_REQ_OUT_OF_RANGE                     (ERR_GENERIC + 3)
-#define ERR_INVALID_REQUEST                      (ERR_GENERIC + 4)
-#define ERR_INVALID_PARAMETER                    (ERR_GENERIC + 5)
-#define ERR_INVALID_LD_ID                        (ERR_GENERIC + 6)
-#define ERR_INVALID_HD_ID                        (ERR_GENERIC + 7)
-#define ERR_INVALID_EXP_ID                       (ERR_GENERIC + 8)
-#define ERR_INVALID_PM_ID                        (ERR_GENERIC + 9)
-#define ERR_INVALID_BLOCK_ID                     (ERR_GENERIC + 10)
-#define ERR_INVALID_ADAPTER_ID                   (ERR_GENERIC + 11)
-#define ERR_INVALID_RAID_MODE                    (ERR_GENERIC + 12)
-#define ERR_INVALID_ENC_ID                       (ERR_GENERIC + 13)
-#define ERR_INVALID_BU_ID                        (ERR_GENERIC + 14)
-#define ERR_INVALID_DG_ID                        (ERR_GENERIC + 15)
-#define ERR_INVALID_ENC_ELEMENT_ID               (ERR_GENERIC + 16)
-#define ERR_NOT_SUPPORTED                        (ERR_GENERIC + 17)
-#define ERR_DRIVER_SENSOR                        (ERR_GENERIC + 18)
-#define ERR_INVALID_KEY_PRESENT                  (ERR_GENERIC + 19)	// can not add key due to key present
-#define ERR_INVALID_KEY_ABSENT                   (ERR_GENERIC + 20)	// can not enable due to key absent
-#define ERR_COMMAND_PHASE_ERROR                  (ERR_GENERIC + 21) // Davinci diagnostic command phase error
-#define ERR_DATA_PHASE_ERROR                     (ERR_GENERIC + 22) // Davinci diagnostic data phase error
-#define ERR_STATUS_PHASE_ERROR                   (ERR_GENERIC + 23) // Davinci diagnostic status phase error
-#define ERR_STATUS_PHASE_PHASE_ERROR             (ERR_GENERIC + 24) // Davinci diagnostic status phase returns phase error
-#define ERR_STATUS_PHASE_CMD_ERROR               (ERR_GENERIC + 25) // Davinci diagnostic status phase returns command error
-#define ERR_INVALID_SSD_NUM                      (ERR_GENERIC + 26) // HyperHDD
-#define ERR_INVALID_ERASE_HDD                      (ERR_GENERIC + 27) // HyperHDD
-
-/* RAID errors */
-#define ERR_TARGET_IN_LD_FUNCTIONAL              (ERR_RAID + 1)
-#define ERR_TARGET_NO_ENOUGH_SPACE               (ERR_RAID + 2)
-#define ERR_HD_IS_NOT_SPARE                      (ERR_RAID + 3)
-#define ERR_HD_IS_SPARE                          (ERR_RAID + 4)
-#define ERR_HD_NOT_EXIST                         (ERR_RAID + 5)
-#define ERR_HD_IS_ASSIGNED_ALREADY               (ERR_RAID + 6)
-#define ERR_INVALID_HD_COUNT                     (ERR_RAID + 7)
-#define ERR_LD_NOT_READY                         (ERR_RAID + 8)
-#define ERR_LD_NOT_EXIST                         (ERR_RAID + 9)
-#define ERR_LD_IS_FUNCTIONAL                     (ERR_RAID + 10)
-#define ERR_HAS_BGA_IN_VD                        (ERR_RAID + 11)
-#define ERR_NO_BGA_ACTIVITY                      (ERR_RAID + 12)
-#define ERR_BGA_RUNNING                          (ERR_RAID + 13)
-#define ERR_RAID_NO_AVAILABLE_ID                 (ERR_RAID + 14)
-#define ERR_LD_NO_ATAPI                          (ERR_RAID + 15)
-#define ERR_INVALID_RAID6_PARITY_DISK_COUNT      (ERR_RAID + 16)
-#define ERR_INVALID_BLOCK_SIZE                   (ERR_RAID + 17)
-#define ERR_MIGRATION_NOT_NEED                   (ERR_RAID + 18)
-#define ERR_STRIPE_BLOCK_SIZE_MISMATCH           (ERR_RAID + 19)
-#define ERR_MIGRATION_NOT_SUPPORT                (ERR_RAID + 20)
-#define ERR_LD_NOT_FULLY_INITED                  (ERR_RAID + 21)
-#define ERR_LD_NAME_INVALID	                     (ERR_RAID + 22)
-#define ERR_HD_TYPE_MISMATCH                     (ERR_RAID + 23)
-#define ERR_HD_SECTOR_SIZE_MISMATCH              (ERR_RAID + 24)
-#define ERR_NO_LD_IN_DG                          (ERR_RAID + 25)
-#define ERR_HAS_LD_IN_DG                         (ERR_RAID + 26)
-#define ERR_NO_ROOM_FOR_SPARE					 (ERR_RAID + 27)
-#define ERR_SPARE_IS_IN_MULTI_DG				 (ERR_RAID + 28)
-#define ERR_DG_HAS_MISSING_PD					 (ERR_RAID + 29)
-#define ERR_LD_NOT_IMPORTABLE                    (ERR_RAID + 30)
-#define ERR_HAS_MIGRATION_ON_DG					 (ERR_RAID + 31)
-#define ERR_HAS_BGA_IN_DG				         (ERR_RAID + 32)
-#define ERR_HD_CANNOT_SET_DOWN                   (ERR_RAID + 33)
-#define ERR_HD_NOT_OFFLINE					     (ERR_RAID + 34)
-#define ERR_LD_STATUS_WRONG     			     (ERR_RAID + 35)
-#define ERR_LD_NOT_REPORTABLE                    (ERR_RAID + 36)
-
-/* API errors */
-#define ERR_INVALID_MATCH_ID                     (ERR_API + 1)
-#define ERR_INVALID_HDCOUNT                      (ERR_API + 2)
-#define ERR_INVALID_BGA_ACTION                   (ERR_API + 3)
-#define ERR_HD_IN_DIFF_CARD                      (ERR_API + 4)
-#define ERR_INVALID_FLASH_TYPE                   (ERR_API + 5)
-#define ERR_INVALID_FLASH_ACTION                 (ERR_API + 6)
-#define ERR_TOO_FEW_EVENT                        (ERR_API + 7)
-#define ERR_VD_HAS_RUNNING_OS                    (ERR_API + 8)
-#define ERR_DISK_HAS_RUNNING_OS                  (ERR_API + 9)
-#define ERR_COMMAND_NOT_SUPPORTED                (ERR_API + 10)
-#define ERR_MIGRATION_LIMIT	                     (ERR_API + 11)  // not used
-#define ERR_SGPIO_CONTROL_NOT_SUPPORTED			 (ERR_API + 12)
-#define ERR_COUNT_OUT_OF_RANGE      			 (ERR_API + 13)	 // internal error
-#define ERR_IOCTL_NO_RESOURCE                    (ERR_API + 14)
-#define ERR_INVALID_FILE                         (ERR_API + 15)
-#define ERR_INVALID_MICROCODE                    (ERR_API + 16)
-#define ERR_USER_NOT_FOUND 				(ERR_API+17)
-#define ERR_USER_NOT_INUSE   			(ERR_API+18)
-#define ERR_USER_INUSE		 			(ERR_API+19)
-#define ERR_DEVICE_IS_BUSY				(ERR_API+31)
-#define ERR_SHELL_CMD_FAIL				(ERR_API+32)
-#define ERR_LOAD_LOKI_API_FAIL			(ERR_API+33)
-#define ERR_INVALID_FLASH_DATA			(ERR_API+34)
-#define ERR_INVALID_FLASH_DESCRIPTOR	(ERR_API+35)
-
-/* AES error */
-#define ERR_ENTRY_OUT_OF_RANGE                  (ERR_AES + 1)
-#define ERR_PORT_OUT_OF_RANGE                   (ERR_AES + 2)
-#define ERR_INVALID_NUM_REQUESTED               (ERR_AES + 3)
-#define ERR_INVALID_REQUEST_TYPE                (ERR_AES + 4)
-#define ERR_INVALID_KEY_LENGTH                  (ERR_AES + 5)
-#define ERR_NOT_OFFLINE_DISK                    (ERR_AES + 6)
-#define ERR_KEY_MISMATCH                        (ERR_AES + 7)
-#define ERR_PASSWORD_MISMATCH                   (ERR_AES + 8)
-#define ERR_PORT_ID_NOT_FOUND                   (ERR_AES + 9)
-#define ERR_ENTRY_NO_KEY                        (ERR_AES + 10) // the specified entry has no key.
-
-#endif /*  __COM_ERROR_H__ */
--- a/drivers/scsi/vanir/include/generic/com_event_define.h
+++ /dev/null
@@ -1,496 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef COM_EVENT_DEFINE_H
-#define COM_EVENT_DEFINE_H
-
-/****************************************
- *         Perceived Severity
- ****************************************/
-
-#define SEVERITY_UNKNOWN    0
-#define SEVERITY_OTHER      1
-#define SEVERITY_INFO       2
-#define SEVERITY_WARNING    3  /* used when its appropriate to let the
-				  user decide if action is needed */
-#define SEVERITY_MINOR      4  /* indicate action is needed, but the
-				  situation is not serious at this time */
-#define SEVERITY_MAJOR      5  /* indicate action is needed NOW */
-#define SEVERITY_CRITICAL   6  /* indicate action is needed NOW and the
-				  scope is broad */
-#define SEVERITY_FATAL      7  /* indicate an error occurred, but it's too
-				  late to take remedial action */
-
-/****************************************
- *             Event Classes
- ****************************************/
-#define EVT_CLASS_ADAPTER   0
-#define EVT_CLASS_LD        1  /* Logical Drive */
-#define EVT_CLASS_HD        2  /* Hard Drive */
-#define EVT_CLASS_PM        3  /* Port Multplier */
-#define EVT_CLASS_EXPANDER  4
-#define EVT_CLASS_MDD       5
-#define EVT_CLASS_BSL       6  /* Bad Sector Lock */
-
-/********************************************************
- *                 Event Codes
- *
- *  !!!  When adding an EVT_CODE, Please put its severity level
- *  !!!  and suggested mesage string as comments.  This is the
- *  !!!  only place to document how 'Params' in 'DriverEvent'
- *  !!!  structure is to be used.
- *
- ********************************************************/
-/* Event code for EVT_CLASS_LD (Logical Drive) */
-#define EVT_CODE_LD_OFFLINE                0
-#define EVT_CODE_LD_ONLINE                 1
-#define EVT_CODE_LD_CREATE                 2
-#define EVT_CODE_LD_DELETE                 3
-#define EVT_CODE_LD_DEGRADE                4
-#define EVT_CODE_LD_PARTIALLYOPTIMAL       5
-#define EVT_CODE_LD_CACHE_MODE_CHANGE      6
-#define EVT_CODE_LD_FIXED                  7
-#define EVT_CODE_LD_FOUND_ERROR            8
-#define EVT_CODE_LD_IMPORTED               9
-#define EVT_CODE_LD_REPORTED                10
-#define EVT_CODE_LD_CONFLICTED              11
-#define EVT_CODE_LD_RESERVED4              12
-#define EVT_CODE_LD_RESERVED5              13
-#define EVT_CODE_LD_RESERVED6              14
-#define EVT_CODE_LD_RESERVED7              15
-#define EVT_CODE_LD_RESERVED8              16
-#define EVT_CODE_LD_RESERVED9              17
-#define EVT_CODE_LD_RESERVED10             18
-#define EVT_CODE_LD_RESERVED11             19
-/*
- *  NOTE: Don't change the following event code order in each event group!
- *      See raid_get_bga_event_id() for detail.
- */
-#define EVT_CODE_LD_CHECK_START            20
-#define EVT_CODE_LD_CHECK_RESTART          21
-#define EVT_CODE_LD_CHECK_PAUSE            22
-#define EVT_CODE_LD_CHECK_RESUME           23
-#define EVT_CODE_LD_CHECK_ABORT            24
-#define EVT_CODE_LD_CHECK_COMPLETE         25
-#define EVT_CODE_LD_CHECK_PROGRESS         26
-#define EVT_CODE_LD_CHECK_ERROR            27
-#define EVT_CODE_LD_CHECK_AUTO_PAUSED      28
-#define EVT_CODE_LD_CHECK_AUTO_RESUME      29
-
-#define EVT_CODE_LD_FIX_START              30
-#define EVT_CODE_LD_FIX_RESTART            31
-#define EVT_CODE_LD_FIX_PAUSE              32
-#define EVT_CODE_LD_FIX_RESUME             33
-#define EVT_CODE_LD_FIX_ABORT              34
-#define EVT_CODE_LD_FIX_COMPLETE           35
-#define EVT_CODE_LD_FIX_PROGRESS           36
-#define EVT_CODE_LD_FIX_ERROR              37
-#define EVT_CODE_LD_FIX_AUTO_PAUSED        38
-#define EVT_CODE_LD_FIX_AUTO_RESUME        39
-
-#define EVT_CODE_LD_INIT_QUICK_START       40
-#define EVT_CODE_LD_INIT_QUICK_RESTART     41
-#define EVT_CODE_LD_INIT_QUICK_PAUSE       42
-#define EVT_CODE_LD_INIT_QUICK_RESUME      43
-#define EVT_CODE_LD_INIT_QUICK_ABORT       44
-#define EVT_CODE_LD_INIT_QUICK_COMPLETE    45
-#define EVT_CODE_LD_INIT_QUICK_PROGRESS    46
-#define EVT_CODE_LD_INIT_QUICK_ERROR       47
-#define EVT_CODE_LD_INIT_QUICK_AUTO_PAUSED 48
-#define EVT_CODE_LD_INIT_QUICK_AUTO_RESUME 49
-
-#define EVT_CODE_LD_INIT_BACK_START        50
-#define EVT_CODE_LD_INIT_BACK_RESTART      51
-#define EVT_CODE_LD_INIT_BACK_PAUSE        52
-#define EVT_CODE_LD_INIT_BACK_RESUME       53
-#define EVT_CODE_LD_INIT_BACK_ABORT        54
-#define EVT_CODE_LD_INIT_BACK_COMPLETE     55
-#define EVT_CODE_LD_INIT_BACK_PROGRESS     56
-#define EVT_CODE_LD_INIT_BACK_ERROR        57
-#define EVT_CODE_LD_INIT_BACK_AUTO_PAUSED  58
-#define EVT_CODE_LD_INIT_BACK_AUTO_RESUME  59
-
-#define EVT_CODE_LD_INIT_FORE_START        60
-#define EVT_CODE_LD_INIT_FORE_RESTART      61
-#define EVT_CODE_LD_INIT_FORE_PAUSE        62
-#define EVT_CODE_LD_INIT_FORE_RESUME       63
-#define EVT_CODE_LD_INIT_FORE_ABORT        64
-#define EVT_CODE_LD_INIT_FORE_COMPLETE     65
-#define EVT_CODE_LD_INIT_FORE_PROGRESS     66
-#define EVT_CODE_LD_INIT_FORE_ERROR        67
-#define EVT_CODE_LD_INIT_FORE_AUTO_PAUSED  68
-#define EVT_CODE_LD_INIT_FORE_AUTO_RESUME  69
-
-
-#define EVT_CODE_LD_REBUILD_START          70
-#define EVT_CODE_LD_REBUILD_RESTART        71
-#define EVT_CODE_LD_REBUILD_PAUSE          72
-#define EVT_CODE_LD_REBUILD_RESUME         73
-#define EVT_CODE_LD_REBUILD_ABORT          74
-#define EVT_CODE_LD_REBUILD_COMPLETE       75
-#define EVT_CODE_LD_REBUILD_PROGRESS       76
-#define EVT_CODE_LD_REBUILD_ERROR          77
-#define EVT_CODE_LD_REBUILD_AUTO_PAUSED    78
-#define EVT_CODE_LD_REBUILD_AUTO_RESUME	   79
-
-#define EVT_CODE_LD_MIGRATION_START        80
-#define EVT_CODE_LD_MIGRATION_RESTART      81
-#define EVT_CODE_LD_MIGRATION_PAUSE        82
-#define EVT_CODE_LD_MIGRATION_RESUME       83
-#define EVT_CODE_LD_MIGRATION_ABORT        84
-#define EVT_CODE_LD_MIGRATION_COMPLETE     85
-#define EVT_CODE_LD_MIGRATION_PROGRESS     86
-#define EVT_CODE_LD_MIGRATION_ERROR        87
-#define EVT_CODE_LD_MIGRATION_AUTO_PAUSED  88
-#define EVT_CODE_LD_MIGRATION_AUTO_RESUME  89
-
-#define EVT_CODE_LD_COPYBACK_START          90
-#define EVT_CODE_LD_COPYBACK_RESTART        91
-#define EVT_CODE_LD_COPYBACK_PAUSE          92
-#define EVT_CODE_LD_COPYBACK_RESUME         93
-#define EVT_CODE_LD_COPYBACK_ABORT          94
-#define EVT_CODE_LD_COPYBACK_COMPLETE       95
-#define EVT_CODE_LD_COPYBACK_PROGRESS       96
-#define EVT_CODE_LD_COPYBACK_ERROR          97
-#define EVT_CODE_LD_COPYBACK_AUTO_PAUSED    98
-#define EVT_CODE_LD_COPYBACK_AUTO_RESUME	99
-
-
-/* event code for logging inconsistent LBA found in consistency check or synchronization fix */
-#define EVT_CODE_LD_INCONSISTENT_LBA       100
-
-/* only used in application */
-#define EVT_CODE_EVT_ERR                   0xffff
-#define EVT_CODE_SMART_FROM_OFF_TO_ON	   0  // SMART setting is changed from OFF-->ON
-#define EVT_CODE_SMART_FROM_ON_TO_OFF	   1  // SMART setting is changed from ON-->OFF
-#define EVT_CODE_ALARM_TURN_ON			   2
-#define EVT_CODE_ALARM_TURN_OFF			   3
-#define EVT_CODE_AUTO_REBUILD_ON		   4
-#define EVT_CODE_AUTO_REBUILD_OFF		   5
-#define EVT_CODE_HD_MP_RATE_CHANGE		   6
-#define EVT_CODE_COPY_BACK_ON			   7
-#define EVT_CODE_COPY_BACK_OFF			   8
-#define EVT_CODE_ADAPTER_FOUND			   9
-#define EVT_CODE_BBU_ECCERROR			   10
-#define EVT_CODE_ADAPTER_BBU_COUNT		   11
-#define EVT_CODE_ADAPTER_BBU_START		   12
-#define EVT_CODE_ADAPTER_BBU_FINISH		   13
-#define EVT_CODE_PAGE_ECC_ERROR			   14
-#define EVT_CODE_ADAPTER_MEMORY_SIZE_LACK	   15
-#define EVT_CODE_ADAPTER_REMOVED			   16
-#define EVT_CODE_ADAPTER_DETECTED			   17
-
-/*
- * Event code for EVT_CLASS_HD (Hard Disk)
- */
-#define EVT_CODE_HD_OFFLINE                0
-#define EVT_CODE_HD_ONLINE                 1
-#define EVT_CODE_HD_SETDOWN                2
-#define EVT_CODE_HD_TIMEOUT                3
-#define EVT_CODE_HD_RW_ERROR               4
-#define EVT_CODE_HD_SMART                  5
-#define EVT_CODE_HD_ERROR_FIXED            6
-#define EVT_CODE_HD_PLUG_IN                7
-#define EVT_CODE_HD_PLUG_OUT               8
-#define EVT_CODE_HD_ASSIGN_SPARE           9
-#define EVT_CODE_HD_REMOVE_SPARE           10
-#define EVT_CODE_HD_SMART_THRESHOLD_OVER   11
-#define EVT_CODE_HD_SMART_POLLING_FAIL	   12  // SMART polling failed on %s (Error %02x)
-#define EVT_CODE_BAD_BLOCK_TBL_80_FULL	   13  // Bad block table on PD %s is 80% full
-#define EVT_CODE_BAD_BLOCK_TBL_FULL	       14  // Bad block table on PD %s is full; Unable to log block %x
-#define EVT_CODE_BAD_BLOCK_REASSIGNED	   15  // Bad block reassigned on %s at %lx to %lx
-#define EVT_CODE_HD_CACHE_MODE_CHANGE	   16
-/*New event for HD media patrol.*/
-#define EVT_CODE_HD_MP_START			   17
-#define EVT_CODE_HD_MP_RESTART			   18
-#define EVT_CODE_HD_MP_PAUSE			   19
-#define EVT_CODE_HD_MP_RESUME              20
-#define EVT_CODE_HD_MP_ABORT               21
-#define EVT_CODE_HD_MP_COMPLETE            22
-#define EVT_CODE_HD_MP_PROGRESS            23
-#define EVT_CODE_HD_MP_ERROR               24
-#define EVT_CODE_HD_MP_AUTO_PAUSED         25
-#define EVT_CODE_HD_MP_AUTO_RESUME         26
-
-/*New event for HD (spare) data scrubbing.*/
-#define EVT_CODE_HD_DS_START			   27
-#define EVT_CODE_HD_DS_RESTART	           28
-#define EVT_CODE_HD_DS_PAUSE	           29
-#define EVT_CODE_HD_DS_RESUME              30
-#define EVT_CODE_HD_DS_ABORT               31
-#define EVT_CODE_HD_DS_COMPLETE            32
-#define EVT_CODE_HD_DS_PROGRESS            33
-#define EVT_CODE_HD_DS_AUTO_PAUSED		   34
-#define EVT_CODE_HD_DS_TERMINATE_IMMEDIATE 35
-
-/*event for sense code*/
-#define EVT_CODE_HD_SC_ERROR			36
-
-#define EVT_CODE_HD_RCT_ADD					37
-#define EVT_CODE_HD_RCT_REMOVE				38
-
-
-#define EVT_CODE_HD_SC_RECOVERED_ERROR   40
-#define EVT_CODE_HD_SC_NOT_READY   41
-#define EVT_CODE_HD_SC_MEDIUM_ERROR   42
-#define EVT_CODE_HD_SC_NO_SENSE   43
-#define EVT_CODE_HD_SC_ILLEGAL_REQUEST   44
-#define EVT_CODE_HD_SC_UNIT_ATTENTION    45
-#define EVT_CODE_HD_SC_DATA_PROTECT   46
-#define EVT_CODE_HD_SC_BLANK_CHECK   47
-#define EVT_CODE_HD_SC_COPY_ABORTED   48
-#define EVT_CODE_HD_SC_ABORTED_COMMAND   49
-#define EVT_CODE_HD_SC_VOLUME_OVERFLOW   50
-#define EVT_CODE_HD_SC_MISCOMPARE   51
-#define EVT_CODE_HD_SC_HARDWARE_ERROR 52
-#define EVT_CODE_HD_SC_VENDOR_SPECIFIC  53
-#define EVT_CODE_HD_SETFREE				54
-#define EVT_CODE_HD_OFF_PLAIN_DISK		55        // disk offline caused by plain disk on AES enabled port
-#define EVT_CODE_HD_OFF_CRYPTO_DISK		56        // disk offline caused by crypto disk on AES disable port
-#define EVT_CODE_HD_OFF_CIPHER_MISMATCH	57       // disk offline caused by cipher is mismatch between disk and port.
-
-/*
- * code for EVT_CLASS_MDD
- */
-#define EVT_CODE_MDD_ERROR                 0
-
-/*
- * Event code for EVT_CLASS_EXPANDER
- */
-#define EVT_CODE_EXPANDER_PLUG_IN        0
-#define EVT_CODE_EXPANDER_PLUG_OUT       1
-
-/**********************************
- *                Event IDs
- **********************************/
-/*
- * Event Id for EVT_CLASS_LD
- */
-#define _CLASS_LD(x)                (EVT_CLASS_LD << 16 | (x))
-
-#define EVT_ID_LD_OFFLINE            _CLASS_LD(EVT_CODE_LD_OFFLINE)
-#define EVT_ID_LD_ONLINE             _CLASS_LD(EVT_CODE_LD_ONLINE)
-#define EVT_ID_LD_CREATE             _CLASS_LD(EVT_CODE_LD_CREATE)
-#define EVT_ID_LD_DELETE             _CLASS_LD(EVT_CODE_LD_DELETE)
-#define EVT_ID_LD_DEGRADE            _CLASS_LD(EVT_CODE_LD_DEGRADE)
-#define EVT_ID_LD_PARTIALLYOPTIMAL   _CLASS_LD(EVT_CODE_LD_PARTIALLYOPTIMAL)
-#define EVT_ID_LD_CACHE_MODE_CHANGE  _CLASS_LD(EVT_CODE_LD_CACHE_MODE_CHANGE)
-#define EVT_ID_LD_FIXED              _CLASS_LD(EVT_CODE_LD_FIXED)
-#define EVT_ID_LD_FOUND_ERROR        _CLASS_LD(EVT_CODE_LD_FOUND_ERROR)
-#define EVT_ID_LD_IMPORTED	     _CLASS_LD(EVT_CODE_LD_IMPORTED)
-#define EVT_ID_LD_REPORTED	     _CLASS_LD(EVT_CODE_LD_REPORTED)
-#define EVT_ID_LD_CONFLICTED	     _CLASS_LD(EVT_CODE_LD_CONFLICTED)
-
-#define EVT_ID_LD_CHECK_START        _CLASS_LD(EVT_CODE_LD_CHECK_START)
-#define EVT_ID_LD_CHECK_RESTART      _CLASS_LD(EVT_CODE_LD_CHECK_RESTART)
-#define EVT_ID_LD_CHECK_PAUSE        _CLASS_LD(EVT_CODE_LD_CHECK_PAUSE)
-#define EVT_ID_LD_CHECK_RESUME       _CLASS_LD(EVT_CODE_LD_CHECK_RESUME)
-#define EVT_ID_LD_CHECK_ABORT        _CLASS_LD(EVT_CODE_LD_CHECK_ABORT)
-#define EVT_ID_LD_CHECK_COMPLETE     _CLASS_LD(EVT_CODE_LD_CHECK_COMPLETE)
-#define EVT_ID_LD_CHECK_PROGRESS     _CLASS_LD(EVT_CODE_LD_CHECK_PROGRESS)
-#define EVT_ID_LD_CHECK_ERROR        _CLASS_LD(EVT_CODE_LD_CHECK_ERROR)
-#define EVT_ID_LD_CHECK_AUTO_PAUSED  _CLASS_LD(EVT_CODE_LD_CHECK_AUTO_PAUSED)
-#define EVT_ID_LD_CHECK_AUTO_RESUME  _CLASS_LD(EVT_CODE_LD_CHECK_AUTO_RESUME)
-
-#define EVT_ID_LD_FIXED_START        _CLASS_LD(EVT_CODE_LD_FIX_START)
-#define EVT_ID_LD_FIXED_RESTART      _CLASS_LD(EVT_CODE_LD_FIX_RESTART)
-#define EVT_ID_LD_FIXED_PAUSE        _CLASS_LD(EVT_CODE_LD_FIX_PAUSE)
-#define EVT_ID_LD_FIXED_RESUME       _CLASS_LD(EVT_CODE_LD_FIX_RESUME)
-#define EVT_ID_LD_FIXED_ABORT        _CLASS_LD(EVT_CODE_LD_FIX_ABORT)
-#define EVT_ID_LD_FIXED_COMPLETE     _CLASS_LD(EVT_CODE_LD_FIX_COMPLETE)
-#define EVT_ID_LD_FIXED_PROGRESS     _CLASS_LD(EVT_CODE_LD_FIX_PROGRESS)
-#define EVT_ID_LD_FIXED_ERROR        _CLASS_LD(EVT_CODE_LD_FIX_ERROR)
-#define EVT_ID_LD_FIXED_AUTO_PAUSED  _CLASS_LD(EVT_CODE_LD_FIX_AUTO_PAUSED)
-#define EVT_ID_LD_FIXED_AUTO_RESUME  _CLASS_LD(EVT_CODE_LD_FIX_AUTO_RESUME)
-
-#define EVT_ID_LD_INIT_QUICK_START   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_START)
-#define EVT_ID_LD_INIT_QUICK_RESTART _CLASS_LD(EVT_CODE_LD_INIT_QUICK_RESTART)
-#define EVT_ID_LD_INIT_QUICK_PAUSE   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_PAUSE)
-#define EVT_ID_LD_INIT_QUICK_RESUME  _CLASS_LD(EVT_CODE_LD_INIT_QUICK_RESUME)
-#define EVT_ID_LD_INIT_QUICK_ABORT   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_ABORT)
-#define EVT_ID_LD_INIT_QUICK_COMPLETE _CLASS_LD(EVT_CODE_LD_INIT_QUICK_COMPLETE)
-#define EVT_ID_LD_INIT_QUICK_PROGRESS _CLASS_LD(EVT_CODE_LD_INIT_QUICK_PROGRESS)
-#define EVT_ID_LD_INIT_QUICK_ERROR   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_ERROR)
-#define EVT_ID_LD_INIT_QUICK_AUTO_PAUSED   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_AUTO_PAUSED)
-#define EVT_ID_LD_INIT_QUICK_AUTO_RESUME   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_AUTO_RESUME)
-
-#define EVT_ID_LD_INIT_BACK_START    _CLASS_LD(EVT_CODE_LD_INIT_BACK_START)
-#define EVT_ID_LD_INIT_BACK_RESTART  _CLASS_LD(EVT_CODE_LD_INIT_BACK_RESTART)
-#define EVT_ID_LD_INIT_BACK_PAUSE    _CLASS_LD(EVT_CODE_LD_INIT_BACK_PAUSE)
-#define EVT_ID_LD_INIT_BACK_RESUME   _CLASS_LD(EVT_CODE_LD_INIT_BACK_RESUME)
-#define EVT_ID_LD_INIT_BACK_ABORT    _CLASS_LD(EVT_CODE_LD_INIT_BACK_ABORT)
-#define EVT_ID_LD_INIT_BACK_COMPLETE _CLASS_LD(EVT_CODE_LD_INIT_BACK_COMPLETE)
-#define EVT_ID_LD_INIT_BACK_PROGRESS _CLASS_LD(EVT_CODE_LD_INIT_BACK_PROGRESS)
-#define EVT_ID_LD_INIT_BACK_ERROR    _CLASS_LD(EVT_CODE_LD_INIT_BACK_ERROR)
-#define EVT_ID_LD_INIT_BACK_AUTO_PAUSED   _CLASS_LD(EVT_CODE_LD_INIT_BACK_AUTO_PAUSED)
-#define EVT_ID_LD_INIT_BACK_AUTO_RESUME   _CLASS_LD(EVT_CODE_LD_INIT_BACK_AUTO_RESUME)
-
-
-#define EVT_ID_LD_INIT_FORE_START    _CLASS_LD(EVT_CODE_LD_INIT_FORE_START)
-#define EVT_ID_LD_INIT_FORE_RESTART  _CLASS_LD(EVT_CODE_LD_INIT_FORE_RESTART)
-#define EVT_ID_LD_INIT_FORE_PAUSE    _CLASS_LD(EVT_CODE_LD_INIT_FORE_PAUSE)
-#define EVT_ID_LD_INIT_FORE_RESUME   _CLASS_LD(EVT_CODE_LD_INIT_FORE_RESUME)
-#define EVT_ID_LD_INIT_FORE_ABORT    _CLASS_LD(EVT_CODE_LD_INIT_FORE_ABORT)
-#define EVT_ID_LD_INIT_FORE_COMPLETE _CLASS_LD(EVT_CODE_LD_INIT_FORE_COMPLETE)
-#define EVT_ID_LD_INIT_FORE_PROGRESS _CLASS_LD(EVT_CODE_LD_INIT_FORE_PROGRESS)
-#define EVT_ID_LD_INIT_FORE_ERROR    _CLASS_LD(EVT_CODE_LD_INIT_FORE_ERROR)
-#define EVT_ID_LD_INIT_FORE_AUTO_PAUSED  _CLASS_LD(EVT_CODE_LD_INIT_FORE_AUTO_PAUSED)
-#define EVT_ID_LD_INIT_FORE_AUTO_RESUME  _CLASS_LD(EVT_CODE_LD_INIT_FORE_AUTO_RESUME)
-
-#define EVT_ID_LD_REBUILD_START      _CLASS_LD(EVT_CODE_LD_REBUILD_START)
-#define EVT_ID_LD_REBUILD_RESTART    _CLASS_LD(EVT_CODE_LD_REBUILD_RESTART)
-#define EVT_ID_LD_REBUILD_PAUSE      _CLASS_LD(EVT_CODE_LD_REBUILD_PAUSE)
-#define EVT_ID_LD_REBUILD_RESUME     _CLASS_LD(EVT_CODE_LD_REBUILD_RESUME)
-#define EVT_ID_LD_REBUILD_ABORT      _CLASS_LD(EVT_CODE_LD_REBUILD_ABORT)
-#define EVT_ID_LD_REBUILD_COMPLETE   _CLASS_LD(EVT_CODE_LD_REBUILD_COMPLETE)
-#define EVT_ID_LD_REBUILD_PROGRESS   _CLASS_LD(EVT_CODE_LD_REBUILD_PROGRESS)
-#define EVT_ID_LD_REBUILD_ERROR      _CLASS_LD(EVT_CODE_LD_REBUILD_ERROR)
-#define EVT_ID_LD_REBUILD_AUTO_PAUSED _CLASS_LD(EVT_CODE_LD_REBUILD_AUTO_PAUSED)
-#define EVT_ID_LD_REBUILD_AUTO_RESUME _CLASS_LD(EVT_CODE_LD_REBUILD_AUTO_RESUME)
-
-#define EVT_ID_LD_MIGRATION_START    _CLASS_LD(EVT_CODE_LD_MIGRATION_START)
-#define EVT_ID_LD_MIGRATION_RESTART  _CLASS_LD(EVT_CODE_LD_MIGRATION_RESTART)
-#define EVT_ID_LD_MIGRATION_PAUSE    _CLASS_LD(EVT_CODE_LD_MIGRATION_PAUSE)
-#define EVT_ID_LD_MIGRATION_RESUME   _CLASS_LD(EVT_CODE_LD_MIGRATION_RESUME)
-#define EVT_ID_LD_MIGRATION_ABORT    _CLASS_LD(EVT_CODE_LD_MIGRATION_ABORT)
-#define EVT_ID_LD_MIGRATION_COMPLETE _CLASS_LD(EVT_CODE_LD_MIGRATION_COMPLETE)
-#define EVT_ID_LD_MIGRATION_PROGRESS _CLASS_LD(EVT_CODE_LD_MIGRATION_PROGRESS)
-#define EVT_ID_LD_MIGRATION_ERROR    _CLASS_LD(EVT_CODE_LD_MIGRATION_ERROR)
-#define EVT_ID_LD_MIGRATION_AUTO_PAUSED    _CLASS_LD(EVT_CODE_LD_MIGRATION_AUTO_PAUSED)
-#define EVT_ID_LD_MIGRATION_AUTO_RESUME    _CLASS_LD(EVT_CODE_LD_MIGRATION_AUTO_RESUME)
-
-#define EVT_ID_LD_COPYBACK_START      _CLASS_LD(EVT_CODE_LD_COPYBACK_START)
-#define EVT_ID_LD_COPYBACK_RESTART    _CLASS_LD(EVT_CODE_LD_COPYBACK_RESTART)
-#define EVT_ID_LD_COPYBACK_PAUSE      _CLASS_LD(EVT_CODE_LD_COPYBACK_PAUSE)
-#define EVT_ID_LD_COPYBACK_RESUME     _CLASS_LD(EVT_CODE_LD_COPYBACK_RESUME)
-#define EVT_ID_LD_COPYBACK_ABORT      _CLASS_LD(EVT_CODE_LD_COPYBACK_ABORT)
-#define EVT_ID_LD_COPYBACK_COMPLETE   _CLASS_LD(EVT_CODE_LD_COPYBACK_COMPLETE)
-#define EVT_ID_LD_COPYBACK_PROGRESS   _CLASS_LD(EVT_CODE_LD_COPYBACK_PROGRESS)
-#define EVT_ID_LD_COPYBACK_ERROR      _CLASS_LD(EVT_CODE_LD_COPYBACK_ERROR)
-#define EVT_ID_LD_COPYBACK_AUTO_PAUSED _CLASS_LD(EVT_CODE_LD_COPYBACK_AUTO_PAUSED)
-#define EVT_ID_LD_COPYBACK_AUTO_RESUME _CLASS_LD(EVT_CODE_LD_COPYBACK_AUTO_RESUME)
-
-
-#define EVT_ID_LD_INCONSISTENT_LBA   _CLASS_LD(EVT_CODE_LD_INCONSISTENT_LBA)
-
-/*
- * Event Id for EVT_CLASS_HD
- */
-#define _CLASS_HD(x)                    (EVT_CLASS_HD << 16 | (x))
-
-#define EVT_ID_HD_OFFLINE               _CLASS_HD(EVT_CODE_HD_OFFLINE)
-#define EVT_ID_HD_ONLINE                _CLASS_HD(EVT_CODE_HD_ONLINE)
-#define EVT_ID_HD_SETDOWN               _CLASS_HD(EVT_CODE_HD_SETDOWN)
-#define EVT_ID_HD_TIMEOUT               _CLASS_HD(EVT_CODE_HD_TIMEOUT)
-#define EVT_ID_HD_RW_ERROR              _CLASS_HD(EVT_CODE_HD_RW_ERROR)
-#define EVT_ID_HD_SMART                 _CLASS_HD(EVT_CODE_HD_SMART)
-#define EVT_ID_HD_ERROR_FIXED           _CLASS_HD(EVT_CODE_HD_ERROR_FIXED)
-#define EVT_ID_HD_PLUG_IN               _CLASS_HD(EVT_CODE_HD_PLUG_IN)
-#define EVT_ID_HD_PLUG_OUT              _CLASS_HD(EVT_CODE_HD_PLUG_OUT)
-#define EVT_ID_HD_ASSIGN_SPARE          _CLASS_HD(EVT_CODE_HD_ASSIGN_SPARE)
-#define EVT_ID_HD_REMOVE_SPARE          _CLASS_HD(EVT_CODE_HD_REMOVE_SPARE)
-#define EVT_ID_HD_SMART_THRESHOLD_OVER  _CLASS_HD(EVT_CODE_HD_SMART_THRESHOLD_OVER)
-#define EVT_ID_HD_SMART_POLLING_FAIL    _CLASS_HD(EVT_CODE_HD_SMART_POLLING_FAIL)
-#define EVT_ID_BAD_BLOCK_TBL_80_FULL    _CLASS_HD(EVT_CODE_BAD_BLOCK_TBL_80_FULL)
-#define EVT_ID_BAD_BLOCK_TBL_FULL       _CLASS_HD(EVT_CODE_BAD_BLOCK_TBL_FULL)
-#define EVT_ID_BAD_BLOCK_REASSIGNED     _CLASS_HD(EVT_CODE_BAD_BLOCK_REASSIGNED)
-#define EVT_ID_HD_CACHE_MODE_CHANGE		_CLASS_HD(EVT_CODE_HD_CACHE_MODE_CHANGE)
-
-#define EVT_ID_HD_MP_START				_CLASS_HD(EVT_CODE_HD_MP_START)
-#define EVT_ID_HD_MP_RESTART			_CLASS_HD(EVT_CODE_HD_MP_RESTART)
-#define EVT_ID_HD_MP_PAUSE				_CLASS_HD(EVT_CODE_HD_MP_PAUSE)
-#define EVT_ID_HD_MP_RESUME				_CLASS_HD(EVT_CODE_HD_MP_RESUME)
-#define EVT_ID_HD_MP_ABORT				_CLASS_HD(EVT_CODE_HD_MP_ABORT)
-#define EVT_ID_HD_MP_COMPLETE			_CLASS_HD(EVT_CODE_HD_MP_COMPLETE)
-#define EVT_ID_HD_MP_PROGRESS			_CLASS_HD(EVT_CODE_HD_MP_PROGRESS)
-#define EVT_ID_HD_MP_ERROR				_CLASS_HD(EVT_CODE_HD_MP_ERROR)
-#define EVT_ID_HD_MP_AUTO_PAUSED		_CLASS_HD(EVT_CODE_HD_MP_AUTO_PAUSED)
-#define EVT_ID_HD_MP_AUTO_RESUME		_CLASS_HD(EVT_CODE_HD_MP_AUTO_RESUME)
-
-/* Event Id for Data Scrub */
-#define EVT_ID_HD_DS_START				 _CLASS_HD(EVT_CODE_HD_DS_START)
-#define EVT_ID_HD_DS_RESTART			 _CLASS_HD(EVT_CODE_HD_DS_RESTART)
-#define EVT_ID_HD_DS_PAUSE				 _CLASS_HD(EVT_CODE_HD_DS_PAUSE)
-#define EVT_ID_HD_DS_RESUME				 _CLASS_HD(EVT_CODE_HD_DS_RESUME)
-#define EVT_ID_HD_DS_ABORT				 _CLASS_HD(EVT_CODE_HD_DS_ABORT)
-#define EVT_ID_HD_DS_COMPLETE			 _CLASS_HD(EVT_CODE_HD_DS_COMPLETE)
-#define EVT_ID_HD_DS_PROGRESS			 _CLASS_HD(EVT_CODE_HD_DS_PROGRESS)
-#define EVT_ID_HD_DS_AUTO_PAUSED		 _CLASS_HD(EVT_CODE_HD_DS_AUTO_PAUSED)
-#define EVT_ID_HD_DS_TERMINATE_IMMEDIATE _CLASS_HD(EVT_CODE_HD_DS_TERMINATE_IMMEDIATE)
-
-/* Event ID for sense code*/
-#define EVT_ID_HD_SC_ERROR				_CLASS_HD(EVT_CODE_HD_SC_ERROR)
-
-#define EVT_ID_HD_RCT_ADD				_CLASS_HD(EVT_CODE_HD_RCT_ADD)
-#define EVT_ID_HD_RCT_REMOVE			_CLASS_HD(EVT_CODE_HD_RCT_REMOVE)
-
-#define EVT_ID_HD_SC_NO_SENSE                   	  _CLASS_HD(EVT_CODE_HD_SC_NO_SENSE)
-#define EVT_ID_HD_SC_RECOVERED_ERROR  	 	_CLASS_HD(EVT_CODE_HD_SC_RECOVERED_ERROR)
-#define EVT_ID_HD_SC_NOT_READY   			_CLASS_HD(EVT_CODE_HD_SC_NOT_READY)
-#define EVT_ID_HD_SC_MEDIUM_ERROR  		 _CLASS_HD(EVT_CODE_HD_SC_MEDIUM_ERROR)
-#define EVT_ID_HD_SC_ILLEGAL_REQUEST   	_CLASS_HD(EVT_CODE_HD_SC_ILLEGAL_REQUEST)
-#define EVT_ID_HD_SC_UNIT_ATTENTION   	_CLASS_HD(EVT_CODE_HD_SC_UNIT_ATTENTION)
-#define EVT_ID_HD_SC_DATA_PROTECT  	 	_CLASS_HD(EVT_CODE_HD_SC_DATA_PROTECT)
-#define EVT_ID_HD_SC_BLANK_CHECK   		_CLASS_HD(EVT_CODE_HD_SC_BLANK_CHECK)
-#define EVT_ID_HD_SC_COPY_ABORTED   	_CLASS_HD(EVT_CODE_HD_SC_COPY_ABORTED)
-#define EVT_ID_HD_SC_ABORTED_COMMAND   _CLASS_HD(EVT_CODE_HD_SC_ABORTED_COMMAND)
-#define EVT_ID_HD_SC_VOLUME_OVERFLOW  _CLASS_HD(EVT_CODE_HD_SC_VOLUME_OVERFLOW)
-#define EVT_ID_HD_SC_MISCOMPARE  		 _CLASS_HD(EVT_CODE_HD_SC_MISCOMPARE)
-#define EVT_ID_HD_SC_HARDWARE_ERROR 		_CLASS_HD(EVT_CODE_HD_SC_HARDWARE_ERROR)
-#define EVT_ID_HD_SC_VENDOR_SPECIFIC  		_CLASS_HD(EVT_CODE_HD_SC_VENDOR_SPECIFIC)
-#define EVT_ID_HD_SETFREE					_CLASS_HD(EVT_CODE_HD_SETFREE)
-#define EVT_ID_HD_OFF_PLAIN_DISK					_CLASS_HD(EVT_CODE_HD_OFF_PLAIN_DISK)
-#define EVT_ID_HD_OFF_CRYPTO_DISK					_CLASS_HD(EVT_CODE_HD_OFF_CRYPTO_DISK)
-#define EVT_ID_HD_OFF_CIPHER_MISMATCH					_CLASS_HD(EVT_CODE_HD_OFF_CIPHER_MISMATCH)
-
-/*
- * Id for EVT_CLASS_MDD
- */
-
-#define _CLASS_MDD(x)                    (EVT_CLASS_MDD << 16 | (x))
-#define EVT_ID_MDD_ERROR                 _CLASS_MDD(EVT_CODE_MDD_ERROR)
-
-/*
- * Event Id for EVT_CLASS_EXPANDER
- */
-#define _CLASS_EXPANDER(x)               (EVT_CLASS_EXPANDER << 16 | (x))
-
-#define EVT_ID_EXPANDER_PLUG_IN          _CLASS_EXPANDER(EVT_CODE_EXPANDER_PLUG_IN)
-#define EVT_ID_EXPANDER_PLUG_OUT         _CLASS_EXPANDER(EVT_CODE_EXPANDER_PLUG_OUT)
-
-
-/*
- * Id for EVT_CLASS_ADAPTER
- */
-
-#define _CLASS_ADPT(x)                   (EVT_CLASS_ADAPTER << 16 | (x))
-#define EVT_ID_EVT_LOST                  _CLASS_ADPT(EVT_CODE_EVT_ERR)
-#define EVT_ID_SMART_FROM_OFF_TO_ON		 _CLASS_ADPT(EVT_CODE_SMART_FROM_OFF_TO_ON)
-#define EVT_ID_SMART_FROM_ON_TO_OFF		 _CLASS_ADPT(EVT_CODE_SMART_FROM_ON_TO_OFF)
-#define EVT_ID_ALARM_TURN_ON			 _CLASS_ADPT(EVT_CODE_ALARM_TURN_ON)
-#define EVT_ID_ALARM_TURN_OFF		     _CLASS_ADPT(EVT_CODE_ALARM_TURN_OFF)
-#define EVT_ID_AUTO_REBUILD_ON		     _CLASS_ADPT(EVT_CODE_AUTO_REBUILD_ON)
-#define EVT_ID_AUTO_REBUILD_OFF		     _CLASS_ADPT(EVT_CODE_AUTO_REBUILD_OFF)
-#define EVT_ID_HD_MP_RATE_CHANGE		 _CLASS_ADPT(EVT_CODE_HD_MP_RATE_CHANGE)
-#define EVT_ID_COPY_BACK_ON			     _CLASS_ADPT(EVT_CODE_COPY_BACK_ON)
-#define EVT_ID_COPY_BACK_OFF		     _CLASS_ADPT(EVT_CODE_COPY_BACK_OFF)
-#define EVT_ID_ADAPTER_FOUND			 _CLASS_ADPT(EVT_CODE_ADAPTER_FOUND)
-#define EVT_ID_ADAPTER_ECC_ERROR			 _CLASS_ADPT(EVT_CODE_BBU_ECCERROR)
-#define EVT_ID_ADAPTER_BBU_COUNT			 _CLASS_ADPT(EVT_CODE_ADAPTER_BBU_COUNT)
-#define EVT_ID_ADAPTER_BBU_START			 _CLASS_ADPT(EVT_CODE_ADAPTER_BBU_START)
-#define EVT_ID_ADAPTER_BBU_FINISH			 _CLASS_ADPT(EVT_CODE_ADAPTER_BBU_FINISH)
-#define EVT_ID_ADAPTER_PAGE_ECC_ERROR			 _CLASS_ADPT(EVT_CODE_PAGE_ECC_ERROR)
-#define EVT_ID_ADAPTER_MEMORY_SIZE_LACK		 _CLASS_ADPT(EVT_CODE_ADAPTER_MEMORY_SIZE_LACK)
-#define EVT_ID_ADAPTER_REMOVED			_CLASS_ADPT(EVT_CODE_ADAPTER_REMOVED)
-#define EVT_ID_ADAPTER_DETECTED			_CLASS_ADPT(EVT_CODE_ADAPTER_DETECTED)
-#endif /*  COM_EVENT_DEFINE_H */
--- a/drivers/scsi/vanir/include/generic/com_event_define_ext.h
+++ /dev/null
@@ -1,442 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef COM_EVENT_DEFINE_EXT_H
-#define COM_EVENT_DEFINE_EXT_H
-
-//=======================================
-//=======================================
-//                Event Classes
-//=======================================
-//=======================================
-
-#define    EVT_CLASS_SAS                7        // SAS, mainly for SAS topology
-#define    EVT_CLASS_ENCL               8        // Enclosure
-#define    EVT_CLASS_BAT                9       // Battery
-#define    EVT_CLASS_FLASH              10      // Flash memory
-#define    EVT_CLASS_CACHE              11      // Cache related
-#define    EVT_CLASS_MISC               12      // For other miscellenous events
-#define    EVT_CLASS_ARRAY              13      // Array
-#define    EVT_CLASS_SSD                14      // SSD
-
-//=============================================================
-//                    Event Codes
-//
-//    !!!  When adding an EVT_ID, Please put its severity level
-//  !!!  and suggested mesage string as comments.  This is the
-//  !!!  only place to document how 'Params' in 'DriverEvent'
-//  !!!  structure is to be used.
-//  !!!  Please refer to the EventMessages.doc to get details.
-//=============================================================
-
-//
-// Event code for EVT_CLASS_SAS (sas)
-//
-
-#define EVT_CODE_SAS_LOOP_DETECTED                0  //SAS Topology error: Loop detected
-#define EVT_CODE_SAS_UNADDR_DEVICE                1  //SAS Topology error: Unaddressable device
-#define EVT_CODE_SAS_MULTIPORT_SAME_ADDR          2  //SAS Topology error: Multiple ports to the same SAS address
-#define EVT_CODE_SAS_EXPANDER_ERR                 3  //SAS Topology error: Expander error
-#define EVT_CODE_SAS_SMP_TIMEOUT                  4  //SAS Topology error: SMP timeout
-#define EVT_CODE_SAS_OUT_OF_ROUTE_ENTRIES         5  //SAS Topology error: Out of route entries
-#define EVT_CODE_SAS_INDEX_NOT_FOUND              6  //SAS Topology error: Index not found
-#define EVT_CODE_SAS_SMP_FUNC_FAILED              7  //SAS Topology error: SMP function failed
-#define EVT_CODE_SAS_SMP_CRC_ERR                  8  //SAS Topology error: SMP CRC error
-#define EVT_CODE_SAS_MULTI_SUBTRACTIVE            9  //SAS Topology error: Multiple subtractive
-#define EVT_CODE_SAS_TABEL_TO_TABLE               10 //SAS Topology error: Table to Table
-#define EVT_CODE_SAS_MULTI_PATHS                  11 //SAS Topology error: Multiple paths
-#define EVT_CODE_SAS_WIDE_PORT_LOST_LINK_ON_PHY   12 //SAS wide port %d lost link on PHY %d
-#define EVT_CODE_SAS_WIDE_PORT_REST_LINK_ON_PHY   13 //SAS wide port %d restored link on PHY %d
-#define EVT_CODE_SAS_PHY_EXCEED_ERR_RATE          14 //SAS port %d, PHY %d has exceeded the allowed error rate
-#define EVT_CODE_SAS_SATA_MIX_NOT_SUPPORTED       15 //SAS/SATA mixing not supported in enclosure: PD %d disabled
-
-//
-// Event code for EVT_CLASS_ENCL (enclosure)
-//
-
-#define    EVT_CODE_ENCL_SES_DISCOVERED            0   // Enclosure(SES) discovered on %d
-#define    EVT_CODE_ENCL_SAFTE_DISCOVERED          1   // Enclosure(SAFTE) discovered on %d
-#define    EVT_CODE_ENCL_COMMUNICATION_LOST        2   // Enclosure %d communication lost
-#define    EVT_CODE_ENCL_COMMUNICATION_RESTORED    3   // Enclosure %d communication restored
-#define    EVT_CODE_ENCL_FAN_FAILED                4   // Enclosure %d fan %d failed
-#define    EVT_CODE_ENCL_FAN_INSERTED              5   // Enclosure %d fan %d inserted
-#define    EVT_CODE_ENCL_FAN_REMOVED               6   // Enclosure %d fan %d removed
-#define    EVT_CODE_ENCL_PS_FAILED                 7   // Enclosure %d power supply %d failed
-#define    EVT_CODE_ENCL_PS_INSERTED               8   // Enclosure %d power supply %d inserted
-#define    EVT_CODE_ENCL_PS_REMOVED                9   // Enclosure %d power supply %d removed
-#define    EVT_CODE_ENCL_SIM_FAILED                10  // Enclosure %d SIM %d failed
-#define    EVT_CODE_ENCL_SIM_INSERTED              11  // Enclosure %d SIM %d inserted
-#define    EVT_CODE_ENCL_SIM_REMOVED               12  // Enclosure %d SIM %d removed
-#define    EVT_CODE_ENCL_TEMP_SENSOR_BELOW_WARNING 13  // Enclosure %d temperature sensor %d below warning threshold
-#define    EVT_CODE_ENCL_TEMP_SENSOR_BELOW_ERR     14  // Enclosure %d temperature sensor %d below error threshold
-#define    EVT_CODE_ENCL_TEMP_SENSOR_ABOVE_WARNING 15  // Enclosure %d temperature sensor %d above warning threshold
-#define    EVT_CODE_ENCL_TEMP_SENSOR_ABOVE_ERR     16  // Enclosure %d temperature sensor %d above error threshold
-#define EVT_CODE_ENCL_SHUTDOWN                     17  // Enclosure %d shutdown
-#define EVT_CODE_ENCL_NOT_SUPPORTED                18  // Enclosure %d not supported; too many enclosures connected to port
-#define    EVT_CODE_ENCL_FW_MISMATCH               19  // Enclosure %d firmware mismatch
-#define    EVT_CODE_ENCL_SENSOR_BAD                20  // Enclosure %d sensor %d bad
-#define    EVT_CODE_ENCL_PHY_BAD                   21  // Enclosure %d phy %d bad
-#define    EVT_CODE_ENCL_IS_UNSTABLE               22  // Enclosure %d is unstable
-#define    EVT_CODE_ENCL_HW_ERR                    23  // Enclosure %d hardware error
-#define    EVT_CODE_ENCL_NOT_RESPONDING            24  // Enclosure %d not responding
-#define    EVT_CODE_ENCL_HOTPLUG_DETECTED          25  // Enclosure(SES) hotplug on %d was detected, but is not supported
-#define    EVT_CODE_ENCL_PS_SWITCHED_OFF           26  // Enclosure %d Power supply %d switched off
-#define    EVT_CODE_ENCL_PS_SWITCHED_ON            27  // Enclosure %d Power supply %d switched on
-#define    EVT_CODE_ENCL_PS_CABLE_REMOVED          28  // Enclosure %d Power supply %d cable removed
-#define    EVT_CODE_ENCL_PS_CABLE_INSERTED         29  // Enclosure %d Power supply %d cable inserted
-#define    EVT_CODE_ENCL_FAN_RETURN_TO_NORMAL      30  // Enclosure %d Fan %d returned to normal
-#define    EVT_CODE_ENCL_TEMP_RETURN_TO_NORMAL     31  // Enclosure %d Temperature %d returned to normal
-#define    EVT_CODE_ENCL_FW_DWLD_IN_PRGS           32  // Enclosure %d Firmware download in progress
-#define    EVT_CODE_ENCL_FW_DWLD_FAILED            33  // Enclosure %d Firmware download failed
-#define    EVT_CODE_ENCL_TEMP_SENSOR_DIFF_DETECTED 34  // Enclosure %d Temperature sensor %d differential detected
-#define    EVT_CODE_ENCL_FAN_SPEED_CHANGED         35  // Enclosure %d fan %d speed changed
-
-
-//
-// Event code for EVT_CLASS_BAT
-//
-
-#define EVT_CODE_BAT_PRESENT                       0    // Battery present
-#define EVT_CODE_BAT_NOT_PRESENT                   1   // Battery not present
-#define EVT_CODE_BAT_NEW_BAT_DETECTED              2   // New battery detected
-#define EVT_CODE_BAT_NEED_REPLACE                  3    // Battery needs to be replaced
-#define EVT_CODE_BAT_REPLACED                      4   // Battery has been replaced
-#define EVT_CODE_BAT_REMOVED                       5   // Battery is removed
-#define EVT_CODE_BAT_RELEARN_STARTED               6   // Battery relearn started
-#define EVT_CODE_BAT_RELEARN_IN_PGRS               7   // Battery relearn in progress
-#define EVT_CODE_BAT_RELEARN_COMPLETED             8   // Battery relearn completed
-#define EVT_CODE_BAT_RELEARN_TIMED_OUT             9   // Battery relearn timed out
-#define EVT_CODE_BAT_RELEARN_PENDING               10  // Battery relearn pending: Battery is under charge
-#define EVT_CODE_BAT_RELEARN_POSTPONED             11  // Battery relearn postponed
-#define EVT_CODE_BAT_START_IN_4_DAYS               12  // Battery relearn will start in 4 days
-#define EVT_CODE_BAT_START_IN_2_DAYS               13    // Battery relearn will start in 2 days
-#define EVT_CODE_BAT_START_IN_1_DAY                14    // Battery relearn will start in 1 days
-#define EVT_CODE_BAT_START_IN_5_HOURS              15    // Battery relearn will start in 5 hours
-#define EVT_CODE_BAT_DISCHARGING                   16  // Battery is discharging
-#define EVT_CODE_BAT_STARTED_CHARGING              17  // Battery started charging
-#define EVT_CODE_BAT_CHARGE_CMPLT                  18  // Battery completed charging
-#define EVT_CODE_BAT_CHARGER_PROBLEM_DETECTED      19  // Battery/charger problems detected
-#define EVT_CODE_BAT_CAPACITY_BELOW_THRESHOLD      20  // Battery capacity is below threshold
-#define EVT_CODE_BAT_CAPACITY_ABOVE_THRESHOLD      21  // Battery capacity is above threshold
-#define EVT_CODE_BAT_TEMP_IS_LOW                   22  // Battery temperature is low
-#define EVT_CODE_BAT_TEMP_IS_NORMAL                23    // Battery temperature back to normal
-#define EVT_CODE_BAT_TEMP_IS_HIGH                  24  // Battery temperature is high
-#define EVT_CODE_BAT_VOLTAGE_LOW                   25  // Battery voltage is low
-#define EVT_CODE_BAT_VOLTAGE_NORMAL                26  // Battery voltage back to normal
-#define EVT_CODE_BAT_VOLTAGE_HIGH                  27  // Battery voltage is high
-#define EVT_CODE_BAT_FORCE_WRITE_THROUGH           28  // Battery capacity is too low, force all VD to use write through mode
-#define EVT_CODE_BAT_SAFE_TO_USE_WRITE_BACK        29  // Battery capacity back to normal, VD is safe to use write back mode.
-
-
-
-//
-// Event code for EVT_CLASS_FLASH
-//
-
-#define EVT_CODE_FLASH_DWLDED_IMAGE_CORRUPTED       0    // Flash downloaded image corrupt
-#define EVT_CODE_FLASH_ERASE_ERR                    1   // Flash erase error
-#define EVT_CODE_FLASH_ERASE_TIMEOUT                2   // Flash timeout during erase
-#define EVT_CODE_FLASH_FLASH_ERR                    3    // Flash error
-#define EVT_CODE_FLASHING_IMAGE                     4    // Flashing image: %d
-#define EVT_CODE_FLASHING_NEW_IMAGE_DONE            5   // Flash of new firmware images complete
-#define EVT_CODE_FLASH_PROGRAMMING_ERR              6   // Flash programming error
-#define EVT_CODE_FLASH_PROGRAMMING_TIMEOUT          7   // Flash timeout during programming
-#define EVT_CODE_FLASH_UNKNOWN_CHIP_TYPE            8   // Flash chip type unknown
-#define EVT_CODE_FLASH_UNKNOWN_CMD_SET              9   // Flash command set unknown
-#define EVT_CODE_FLASH_VERIFY_FAILURE               10  // Flash verify failure
-#define EVT_CODE_NVRAM_CORRUPT                      11    // NVRAM is corrupt; reinitializing
-#define EVT_CODE_NVRAM_MISMACTH_OCCURED             12  // NVRAM mismatch occured
-#define EVT_CODE_NVRAM_RECONSTRUCTION_STARTED       13  // NVRAM reconstruction started    (for vili)
-#define EVT_CODE_NVRAM_RECONSTRUCTION_DONE          14  // NVRAM reconstruction done    (for vili)
-
-//
-// Event code for new Flash command (Loki and Frey)
-//
-#define EVT_CODE_FLASH_WRITE_ERR                    15 // Flash operation failed (for Loki and Frey)
-#define EVT_CODE_FLASH_READ_ERR                     16 // Flash operation failed (for Loki and Frey)
-#define EVT_CODE_FLASH_WRITE_IMAGE_SUCCEEDED        17
-#define EVT_CODE_FLASH_READ_IMAGE_SUCCEEDED         18
-#define EVT_CODE_FLASH_WRITE_IMAGE_FAILED           19
-#define EVT_CODE_FLASH_READ_IMAGE_FAILED            20
-#define EVT_CODE_FLASH_GENERATION_ERR               21 // generation error (for Loki and Frey)
-#define  EVT_CODE_FLASH_FATAL_GENERATION_ERR        22
-#define EVT_CODE_FLASH_HEADER_ERR                   23 // Header error in flash (for Loki and Frey)
-#define EVT_CODE_FLASH_DATA_ERR                     24 // Header error in flash (for Loki and Frey)
-#define EVT_CODE_FLASH_DATA_AND_HEADER_ERR          25 // Header error in flash (for Loki and Frey)
-
-//
-// Event code for EVT_CLASS_CACHE(Cache)
-//
-
-#define EVT_CODE_CACHE_NOT_RECV_FROM_TBBU           0    // Unable to recover cache data from TBBU
-#define EVT_CODE_CACHE_RECVD_FROM_TBBU              1   // Cache data recovered from TBBU successfully
-#define EVT_CODE_CACHE_CTRLER_CACHE_DISCARDED       2   // Controller cache discarded due to memory/battery problems
-#define EVT_CODE_CACHE_FAIL_RECV_DUETO_MISMATCH     3   // Unable to recover cache data due to configuration mismatch
-#define EVT_CODE_CACHE_DIRTY_DATA_DISCARDED         4    // Dirty cache data discarded by user
-#define EVT_CODE_CACHE_FLUSH_RATE_CHANGED           5   // Flush rate changed to %d seconds.
-
-
-//
-// Event code for EVT_CLASS_MISC
-//
-
-#define EVT_CODE_MISC_CONFIG_CLEARED                0    // Configuration cleared
-#define EVT_CODE_MISC_CHANGE_BACK_ACTIVITY_RATE     1    // Background activity rate changed to %d%%
-#define EVT_CODE_MISC_FATAL_FW_ERR                  2   // Fatal firmware error: %d
-#define EVT_CODE_MISC_FACTORY_DEFAULTS_RESTORED     3   // Factory defaults restored
-#define EVT_CODE_MISC_GET_HIBER_CMD                 4   // Hibernation command received from host
-#define EVT_CODE_MISC_MUTLI_BIT_ECC_ERR             5    // Multi-bit ECC error: count = %d, address = 0x%X, module ID = %d
-#define EVT_CODE_MISC_SINGLE_BIT_ECC_ERR            6   // Single-bit ECC error: count = %d
-#define EVT_CODE_MISC_GET_SHUTDOWN_CMD              7    // Shutdown command received from host
-#define EVT_CODE_MISC_TIME_ESTABLISHED              8    // Time established as %d; (%d seconds since power on)
-#define EVT_CODE_MISC_USER_ENTERED_DEBUGGER         9   // User entered firmware debugger
-#define EVT_CODE_MISC_FORMAT_COMPLETE               10    // Format complete on %d
-#define EVT_CODE_MISC_FORMAT_STARTED                11    // Format started on %d
-#define EVT_CODE_MISC_REASSIGN_WRITE_OP             12    // Reassign write operation on %d is %d
-#define EVT_CODE_MISC_UNEXPECTED_SENSE              13    // Unexpected sense: %d, CDB%d, Sense: %d
-#define EVT_CODE_MISC_REPLACED_MISSING              14    // Replaced missing as %d on array %d row %d
-#define EVT_CODE_MISC_NOT_A_CERTIFIED_DRIVE         15  // %d is not a certificated derive
-
-/* May put into other group???*/
-#define EVT_CODE_MISC_PD_MISSING_FROM_CONFIG_AT_BOOT    16    // PDs missing from configuration on boot
-#define EVT_CODE_MISC_VD_MISSING_DRIVES                 17  // VDs missing drives and will go offline at boot: %d
-#define EVT_CODE_MISC_VD_MISSING_AT_BOOT                18  // VDs missing at boot: %d
-#define EVT_CODE_MISC_PREVIOUS_CONFIG_MISSING_AT_BOOT   19  // Previous configuration completely missing at boot
-#define EVT_CODE_MISC_PD_TOO_SMALL_FOR_AUTOREBUILD      20  // PD too small to be used for auto-rebuild on %d.
-#define EVT_CODE_MISC_PD_TOO_SMALL_FOR_COPYBACK         21
-#define EVT_CODE_MISC_CHANGE_SYNC_RATE                  22    // Synchronize rate changed to %d%%
-#define EVT_CODE_MISC_CHANGE_INIT_RATE                  23    // Init rate changed to %d%%
-#define EVT_CODE_MISC_CHANGE_REBUILD_RATE               24    // Rebuild rate changed to %d%%
-#define EVT_CODE_MISC_CHANGE_MIGRATION_RATE             25    // Migration rate changed to %d%%
-#define EVT_CODE_MISC_CHANGE_COPYBACK_RATE              26    // Copyback rate changed to %d%%
-#define EVT_CODE_MISC_CHANGE_MP_RATE                    27    // Media Patrol rate changed to %d%%
-#define EVT_CODE_MISC_ALARM_MUTE                        28    // Adapter alarm set to mute
-//
-// Event code for EVT_CLASS_ARRAY
-//
-
-#define EVT_CODE_ARRAY_CREATE                            0
-#define EVT_CODE_ARRAY_DELETE                            1
-
-
-//=======================================
-//=======================================
-//                Event IDs
-//=======================================
-//=======================================
-
-//
-// Event id for EVT_CLASS_SAS
-//
-
-#define _CLASS_SAS(x)                (EVT_CLASS_SAS << 16 | (x))
-
-#define EVT_ID_SAS_LOOP_DETECTED                       _CLASS_SAS(EVT_CODESAS_LOOP_DETECTED)
-#define EVT_ID_SAS_UNADDR_DEVICE                       _CLASS_SAS(EVT_CODESAS_UNADDR_DEVICE)
-#define EVT_ID_SAS_MULTIPORT_SAME_ADDR                 _CLASS_SAS(EVT_CODESAS_MULTIPORT_SAME_ADDR)
-#define EVT_ID_SAS_EXPANDER_ERR                        _CLASS_SAS(EVT_CODESAS_EXPANDER_ERR)
-#define EVT_ID_SAS_SMP_TIMEOUT                         _CLASS_SAS(EVT_CODESAS_SMP_TIMEOUT)
-#define EVT_ID_SAS_OUT_OF_ROUTE_ENTRIES                _CLASS_SAS(EVT_CODESAS_OUT_OF_ROUTE_ENTRIES)
-#define EVT_ID_SAS_INDEX_NOT_FOUND                     _CLASS_SAS(EVT_CODESAS_INDEX_NOT_FOUND)
-#define EVT_ID_SAS_SMP_FUNC_FAILED                     _CLASS_SAS(EVT_CODESAS_SMP_FUNC_FAILED)
-#define EVT_ID_SAS_SMP_CRC_ERR                         _CLASS_SAS(EVT_CODESAS_SMP_CRC_ERR)
-#define EVT_ID_SAS_MULTI_SUBTRACTIVE                   _CLASS_SAS(EVT_CODESAS_MULTI_SUBTRACTIVE)
-#define EVT_ID_SAS_TABEL_TO_TABLE                      _CLASS_SAS(EVT_CODESAS_TABEL_TO_TABLE)
-#define EVT_ID_SAS_MULTI_PATHS                         _CLASS_SAS(EVT_CODESAS_MULTI_PATHS)
-#define EVT_ID_SAS_WIDE_PORT_LOST_LINK_ON_PHY          _CLASS_SAS(EVT_CODESAS_WIDE_PORT_LOST_LINK_ON_PHY)
-#define EVT_ID_SAS_WIDE_PORT_REST_LINK_ON_PHY          _CLASS_SAS(EVT_CODESAS_WIDE_PORT_REST_LINK_ON_PHY)
-#define EVT_ID_SAS_PHY_EXCEED_ERR_RATE                 _CLASS_SAS(EVT_CODESAS_PHY_EXCEED_ERR_RATE)
-#define EVT_ID_SAS_SATA_MIX_NOT_SUPPORTED              _CLASS_SAS(EVT_CODESAS_SATA_MIX_NOT_SUPPORTED)
-
-//
-// Event id for EVT_CLASS_ENCL (enclosure)
-//
-
-#define _CLASS_ENCL(x)                (EVT_CLASS_ENCL << 16 | (x))
-
-#define    EVT_ID_ENCL_SES_DISCOVERED                   _CLASS_ENCL(EVT_CODE_ENCL_SES_DISCOVERED)
-#define    EVT_ID_ENCL_SAFTE_DISCOVERED                 _CLASS_ENCL(EVT_CODE_ENCL_SAFTE_DISCOVERED)
-#define    EVT_ID_ENCL_COMMUNICATION_LOST               _CLASS_ENCL(EVT_CODE_ENCL_COMMUNICATION_LOST)
-#define    EVT_ID_ENCL_COMMUNICATION_RESTORED           _CLASS_ENCL(EVT_CODE_ENCL_COMMUNICATION_RESTORED)
-#define    EVT_ID_ENCL_FAN_FAILED                       _CLASS_ENCL(EVT_CODE_ENCL_FAN_FAILED)
-#define    EVT_ID_ENCL_FAN_INSERTED                     _CLASS_ENCL(EVT_CODE_ENCL_FAN_INSERTED)
-#define    EVT_ID_ENCL_FAN_REMOVED                      _CLASS_ENCL(EVT_CODE_ENCL_FAN_REMOVED)
-#define    EVT_ID_ENCL_PS_FAILED                        _CLASS_ENCL(EVT_CODE_ENCL_PS_FAILED)
-#define    EVT_ID_ENCL_PS_INSERTED                      _CLASS_ENCL(EVT_CODE_ENCL_PS_INSERTED)
-#define    EVT_ID_ENCL_PS_REMOVED                       _CLASS_ENCL(EVT_CODE_ENCL_PS_REMOVED)
-#define    EVT_ID_ENCL_SIM_FAILED                       _CLASS_ENCL(EVT_CODE_ENCL_SIM_FAILED)
-#define    EVT_ID_ENCL_SIM_INSERTED                     _CLASS_ENCL(EVT_CODE_ENCL_SIM_INSERTED)
-#define    EVT_ID_ENCL_SIM_REMOVED                      _CLASS_ENCL(EVT_CODE_ENCL_SIM_REMOVED)
-#define    EVT_ID_ENCL_TEMP_SENSOR_BELOW_WARNING        _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_BELOW_WARNING)
-#define    EVT_ID_ENCL_TEMP_SENSOR_BELOW_ERR            _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_BELOW_ERR)
-#define    EVT_ID_ENCL_TEMP_SENSOR_ABOVE_WARNING        _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_ABOVE_WARNING)
-#define    EVT_ID_ENCL_TEMP_SENSOR_ABOVE_ERR            _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_ABOVE_ERR)
-#define    EVT_ID_ENCL_SHUTDOWN                         _CLASS_ENCL(EVT_CODE_ENCL_SHUTDOWN)
-#define    EVT_ID_ENCL_NOT_SUPPORTED                    _CLASS_ENCL(EVT_CODE_ENCL_NOT_SUPPORTED)
-#define    EVT_ID_ENCL_FW_MISMATCH                      _CLASS_ENCL(EVT_CODE_ENCL_FW_MISMATCH)
-#define    EVT_ID_ENCL_SENSOR_BAD                       _CLASS_ENCL(EVT_CODE_ENCL_SENSOR_BAD)
-#define    EVT_ID_ENCL_PHY_BAD                          _CLASS_ENCL(EVT_CODE_ENCL_PHY_BAD)
-#define    EVT_ID_ENCL_IS_UNSTABLE                      _CLASS_ENCL(EVT_CODE_ENCL_IS_UNSTABLE)
-#define    EVT_ID_ENCL_HW_ERR                           _CLASS_ENCL(EVT_CODE_ENCL_HW_ERR)
-#define    EVT_ID_ENCL_NOT_RESPONDING                   _CLASS_ENCL(EVT_CODE_ENCL_NOT_RESPONDING)
-#define    EVT_ID_ENCL_HOTPLUG_DETECTED                 _CLASS_ENCL(EVT_CODE_ENCL_HOTPLUG_DETECTED)
-#define    EVT_ID_ENCL_PS_SWITCHED_OFF                  _CLASS_ENCL(EVT_CODE_ENCL_PS_SWITCHED_OFF    )
-#define    EVT_ID_ENCL_PS_SWITCHED_ON                   _CLASS_ENCL(EVT_CODE_ENCL_PS_SWITCHED_ON)
-#define    EVT_ID_ENCL_PS_CABLE_REMOVED                 _CLASS_ENCL(EVT_CODE_ENCL_PS_CABLE_REMOVED)
-#define    EVT_ID_ENCL_PS_CABLE_INSERTED                _CLASS_ENCL(EVT_CODE_ENCL_PS_CABLE_INSERTED)
-#define    EVT_ID_ENCL_FAN_RETURN_TO_NORMAL             _CLASS_ENCL(EVT_CODE_ENCL_FAN_RETURN_TO_NORMAL)
-#define    EVT_ID_ENCL_TEMP_RETURN_TO_NORMAL            _CLASS_ENCL(EVT_CODE_ENCL_TEMP_RETURN_TO_NORMAL)
-#define    EVT_ID_ENCL_FW_DWLD_IN_PRGS                  _CLASS_ENCL(EVT_CODE_ENCL_FW_DWLD_IN_PRGS    )
-#define    EVT_ID_ENCL_FW_DWLD_FAILED                   _CLASS_ENCL(EVT_CODE_ENCL_FW_DWLD_FAILED)
-#define    EVT_ID_ENCL_TEMP_SENSOR_DIFF_DETECTED        _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_DIFF_DETECTED)
-#define    EVT_ID_ENCL_FAN_SPEED_CHANGED                _CLASS_ENCL(EVT_CODE_ENCL_FAN_SPEED_CHANGED)
-
-//
-// Event id for EVT_CLASS_BAT
-//
-
-#define _CLASS_BAT(x)                (EVT_CLASS_BAT << 16 | (x))
-
-#define EVT_ID_BAT_PRESENT                             _CLASS_BAT(EVT_CODE_BAT_PRESENT)
-#define EVT_ID_BAT_NOT_PRESENT                         _CLASS_BAT(EVT_CODE_BAT_NOT_PRESENT)
-#define EVT_ID_BAT_NEW_BAT_DETECTED                    _CLASS_BAT(EVT_CODE_BAT_NEW_BAT_DETECTED)
-#define EVT_ID_BAT_REPLACED                            _CLASS_BAT(EVT_CODE_BAT_REPLACED)
-#define EVT_ID_BAT_TEMP_IS_HIGH                        _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_HIGH)
-#define EVT_ID_BAT_VOLTAGE_LOW                         _CLASS_BAT(EVT_CODE_BAT_VOLTAGE_LOW)
-#define EVT_ID_BAT_STARTED_CHARGING                    _CLASS_BAT(EVT_CODE_BAT_STARTED_CHARGING)
-#define EVT_ID_BAT_DISCHARGING                         _CLASS_BAT(EVT_CODE_BAT_DISCHARGING)
-#define EVT_ID_BAT_TEMP_IS_NORMAL                      _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_NORMAL)
-#define EVT_ID_BAT_NEED_REPLACE                        _CLASS_BAT(EVT_CODE_BAT_NEED_REPLACE)
-#define EVT_ID_BAT_RELEARN_STARTED                     _CLASS_BAT(EVT_CODE_BAT_RELEARN_STARTED)
-#define EVT_ID_BAT_RELEARN_IN_PGRS                     _CLASS_BAT(EVT_CODE_BAT_RELEARN_IN_PGRS)
-#define EVT_ID_BAT_RELEARN_COMPLETED                   _CLASS_BAT(EVT_CODE_BAT_RELEARN_COMPLETED)
-#define EVT_ID_BAT_RELEARN_TIMED_OUT                   _CLASS_BAT(EVT_CODE_BAT_RELEARN_TIMED_OUT)
-#define EVT_ID_BAT_RELEARN_PENDING                     _CLASS_BAT(EVT_CODE_BAT_RELEARN_PENDING)
-#define EVT_ID_BAT_RELEARN_POSTPONED                   _CLASS_BAT(EVT_CODE_BAT_RELEARN_POSTPONED)
-#define EVT_ID_BAT_START_IN_4_DAYS                     _CLASS_BAT(EVT_CODE_BAT_START_IN_4_DAYS)
-#define EVT_ID_BAT_START_IN_2_DAYS                     _CLASS_BAT(EVT_CODE_BAT_START_IN_2_DAYS)
-#define EVT_ID_BAT_START_IN_1_DAY                      _CLASS_BAT(EVT_CODE_BAT_START_IN_1_DAY)
-#define EVT_ID_BAT_START_IN_5_HOURS                    _CLASS_BAT(EVT_CODE_BAT_START_IN_5_HOURS)
-#define EVT_ID_BAT_REMOVED                             _CLASS_BAT(EVT_CODE_BAT_REMOVED)
-#define EVT_ID_BAT_CHARGE_CMPLT                        _CLASS_BAT(EVT_CODE_BAT_CHARGE_CMPLT)
-#define EVT_ID_BAT_CHARGER_PROBLEM_DETECTED            _CLASS_BAT(EVT_CODE_BAT_CHARGER_PROBLEM_DETECTED)
-#define EVT_ID_BAT_CAPACITY_BELOW_THRESHOLD            _CLASS_BAT(EVT_CODE_BAT_CAPACITY_BELOW_THRESHOLD)
-#define EVT_ID_BAT_CAPACITY_ABOVE_THRESHOLD            _CLASS_BAT(EVT_CODE_BAT_CAPACITY_ABOVE_THRESHOLD)
-#define EVT_ID_BAT_TEMP_IS_LOW                         _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_LOW)
-#define EVT_ID_BAT_TEMP_IS_NORMAL                      _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_NORMAL)
-#define EVT_ID_BAT_TEMP_IS_HIGH                        _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_HIGH)
-#define EVT_ID_BAT_VOLTAGE_LOW                         _CLASS_BAT(EVT_CODE_BAT_VOLTAGE_LOW)
-#define EVT_ID_BAT_VOLTAGE_NORMAL                      _CLASS_BAT(EVT_CODE_BAT_VOLTAGE_NORMAL)
-#define EVT_ID_BAT_VOLTAGE_HIGH                        _CLASS_BAT(EVT_CODE_BAT_VOLTAGE_HIGH)
-#define EVT_ID_BAT_FORCE_WRITE_THROUGH                 _CLASS_BAT(EVT_CODE_BAT_FORCE_WRITE_THROUGH)
-#define EVT_ID_BAT_SAFE_TO_USE_WRITE_BACK              _CLASS_BAT(EVT_CODE_BAT_SAFE_TO_USE_WRITE_BACK)
-
-
-//
-// Event id for EVT_CLASS_FLASH
-//
-#define _CLASS_FLASH(x)                (EVT_CLASS_FLASH << 16 | (x))
-
-#define EVT_ID_FLASH_DWLDED_IMAGE_CORRUPTED            _CLASS_FLASH(EVT_CODE_FLASH_DWLDED_IMAGE_CORRUPTED)
-#define EVT_ID_FLASH_ERASE_ERR                         _CLASS_FLASH(EVT_CODE_FLASH_ERASE_ERR)
-#define EVT_ID_FLASH_ERASE_TIMEOUT                     _CLASS_FLASH(EVT_CODE_FLASH_ERASE_TIMEOUT)
-#define EVT_ID_FLASH_FLASH_ERR                         _CLASS_FLASH(EVT_CODE_FLASH_FLASH_ERR)
-#define EVT_ID_FLASHING_IMAGE                          _CLASS_FLASH(EVT_CODE_FLASHING_IMAGE)
-#define EVT_ID_FLASHING_NEW_IMAGE_DONE                 _CLASS_FLASH(EVT_CODE_FLASHING_NEW_IMAGE_DONE)
-#define EVT_ID_FLASH_PROGRAMMING_ERR                   _CLASS_FLASH(EVT_CODE_FLASH_PROGRAMMING_ERR)
-#define EVT_ID_FLASH_PROGRAMMING_TIMEOUT               _CLASS_FLASH(EVT_CODE_FLASH_PROGRAMMING_TIMEOUT)
-#define EVT_ID_FLASH_UNKNOWN_CHIP_TYPE                 _CLASS_FLASH(EVT_CODE_FLASH_UNKNOWN_CHIP_TYPE)
-#define EVT_ID_FLASH_UNKNOWN_CMD_SET                   _CLASS_FLASH(EVT_CODE_FLASH_UNKNOWN_CMD_SET)
-#define EVT_ID_FLASH_VERIFY_FAILURE                    _CLASS_FLASH(EVT_CODE_FLASH_VERIFY_FAILURE)
-#define EVT_ID_NVRAM_CORRUPT                           _CLASS_FLASH(EVT_CODE_NVRAM_CORRUPT)
-#define EVT_ID_NVRAM_MISMACTH_OCCURED                  _CLASS_FLASH(EVT_CODE_NVRAM_MISMACTH_OCCURED)
-#define EVT_ID_NVRAM_RECONSTRUCTION_STARTED            _CLASS_FLASH(EVT_CODE_NVRAM_RECONSTRUCTION_STARTED)
-#define EVT_ID_NVRAM_RECONSTRUCTION_DONE               _CLASS_FLASH(EVT_CODE_NVRAM_RECONSTRUCTION_DONE)
-
-//
-// Event code for new Flash command (Loki and Frey)
-//
-#define EVT_ID_FLASH_WRITE_ERR                         _CLASS_FLASH(EVT_CODE_FLASH_WRITE_ERR)
-#define EVT_ID_FLASH_READ_ERR                          _CLASS_FLASH(EVT_CODE_FLASH_READ_ERR)
-#define EVT_ID_FLASH_WRITE_IMAGE_SUCCEEDED             _CLASS_FLASH(EVT_CODE_FLASH_WRITE_IMAGE_SUCCEEDED)
-#define EVT_ID_FLASH_READ_IMAGE_SUCCEEDED              _CLASS_FLASH(EVT_CODE_FLASH_READ_IMAGE_SUCCEEDED)
-#define EVT_ID_FLASH_WRITE_IMAGE_FAILED                _CLASS_FLASH(EVT_CODE_FLASH_WRITE_IMAGE_FAILED)
-#define EVT_ID_FLASH_READ_IMAGE_FAILED                 _CLASS_FLASH(EVT_CODE_FLASH_READ_IMAGE_FAILED)
-#define EVT_ID_FLASH_GENERATION_ERR                    _CLASS_FLASH(EVT_CODE_FLASH_GENERATION_ERR)
-#define EVT_ID_FLASH_FATAL_GENERATION_ERR              _CLASS_FLASH(EVT_CODE_FLASH_FATAL_GENERATION_ERR)
-#define EVT_ID_FLASH_HEADER_ERR                        _CLASS_FLASH(EVT_CODE_FLASH_HEADER_ERR)
-#define EVT_ID_FLASH_DATA_ERR                          _CLASS_FLASH(EVT_CODE_FLASH_DATA_ERR)
-#define EVT_ID_FLASH_DATA_AND_HEADER_ERR               _CLASS_FLASH(EVT_CODE_FLASH_DATA_AND_HEADER_ERR)
-
-// Event code for EVT_CLASS_CACHE(Cache)
-//
-
-#define _CLASS_CACHE(x)                (EVT_CLASS_CACHE << 16 | (x))
-
-#define EVT_ID_CACHE_NOT_RECV_FROM_TBBU            _CLASS_CACHE(EVT_CODE_CACHE_NOT_RECV_FROM_TBBU)
-#define EVT_ID_CACHE_RECVD_FROM_TBBU               _CLASS_CACHE(EVT_CODE_CACHE_RECVD_FROM_TBBU)
-#define EVT_ID_CACHE_CTRLER_CACHE_DISCARDED        _CLASS_CACHE(EVT_CODE_CACHE_CTRLER_CACHE_DISCARDED)
-#define EVT_ID_CACHE_FAIL_RECV_DUETO_MISMATCH      _CLASS_CACHE(EVT_CODE_CACHE_FAIL_RECV_DUETO_MISMATCH)
-#define EVT_ID_CACHE_DIRTY_DATA_DISCARDED          _CLASS_CACHE(EVT_CODE_CACHE_DIRTY_DATA_DISCARDED)
-#define EVT_ID_CACHE_FLUSH_RATE_CHANGED            _CLASS_CACHE(EVT_CODE_CACHE_FLUSH_RATE_CHANGED)
-
-
-//
-// Event code for EVT_CLASS_MISC
-//
-
-#define _CLASS_MISC(x)                (EVT_CLASS_MISC << 16 | (x))
-
-#define EVT_ID_MISC_CONFIG_CLEARED                   _CLASS_MISC(EVT_CODE_MISC_CONFIG_CLEARED)
-#define EVT_ID_MISC_CHANGE_BACK_ACTIVITY_RATE        _CLASS_MISC(EVT_CODE_MISC_CHANGE_BACK_ACTIVITY_RATE)
-#define EVT_ID_MISC_FATAL_FW_ERR                     _CLASS_MISC(EVT_CODE_MISC_FATAL_FW_ERR)
-#define EVT_ID_MISC_FACTORY_DEFAULTS_RESTORED        _CLASS_MISC(EVT_CODE_MISC_FACTORY_DEFAULTS_RESTORED)
-#define EVT_ID_MISC_GET_HIBER_CMD                    _CLASS_MISC(EVT_CODE_MISC_GET_HIBER_CMD)
-#define EVT_ID_MISC_MUTLI_BIT_ECC_ERR                _CLASS_MISC(EVT_CODE_MISC_MUTLI_BIT_ECC_ERR)
-#define EVT_ID_MISC_SINGLE_BIT_ECC_ERR               _CLASS_MISC(EVT_CODE_MISC_SINGLE_BIT_ECC_ERR)
-#define EVT_ID_MISC_GET_SHUTDOWN_CMD                 _CLASS_MISC(EVT_CODE_MISC_GET_SHUTDOWN_CMD)
-#define EVT_ID_MISC_TIME_ESTABLISHED                 _CLASS_MISC(EVT_CODE_MISC_TIME_ESTABLISHED)
-#define EVT_ID_MISC_USER_ENTERED_DEBUGGER            _CLASS_MISC(EVT_CODE_MISC_USER_ENTERED_DEBUGGER)
-#define EVT_ID_MISC_FORMAT_COMPLETE                  _CLASS_MISC(EVT_CODE_MISC_FORMAT_COMPLETE)
-#define EVT_ID_MISC_FORMAT_STARTED                   _CLASS_MISC(EVT_CODE_MISC_FORMAT_STARTED)
-#define EVT_ID_MISC_REASSIGN_WRITE_OP                _CLASS_MISC(EVT_CODE_MISC_REASSIGN_WRITE_OP)
-#define EVT_ID_MISC_UNEXPECTED_SENSE                 _CLASS_MISC(EVT_CODE_MISC_UNEXPECTED_SENSE)
-#define EVT_ID_MISC_REPLACED_MISSING                 _CLASS_MISC(EVT_CODE_MISC_REPLACED_MISSING)
-#define EVT_ID_MISC_NOT_A_CERTIFIED_DRIVE            _CLASS_MISC(EVT_CODE_MISC_NOT_A_CERTIFIED_DRIVE)
-
-/* May put into other group???*/
-#define EVT_ID_MISC_PD_MISSING_FROM_CONFIG_AT_BOOT   _CLASS_MISC(EVT_CODE_MISC_PD_MISSING_FROM_CONFIG_AT_BOOT)
-#define EVT_ID_MISC_VD_MISSING_DRIVES                _CLASS_MISC(EVT_CODE_MISC_VD_MISSING_DRIVES)
-#define EVT_ID_MISC_VD_MISSING_AT_BOOT               _CLASS_MISC(EVT_CODE_MISC_VD_MISSING_AT_BOOT)
-#define EVT_ID_MISC_PREVIOUS_CONFIG_MISSING_AT_BOOT  _CLASS_MISC(EVT_CODE_MISC_PREVIOUS_CONFIG_MISSING_AT_BOOT)
-#define EVT_ID_MISC_PD_TOO_SMALL_FOR_AUTOREBUILD     _CLASS_MISC(EVT_CODE_MISC_PD_TOO_SMALL_FOR_AUTOREBUILD)
-#define EVT_ID_MISC_PD_TOO_SMALL_FOR_COPYBACK        _CLASS_MISC(EVT_CODE_MISC_PD_TOO_SMALL_FOR_COPYBACK)
-
-#define EVT_ID_MISC_CHANGE_SYNC_RATE                 _CLASS_MISC(EVT_CODE_MISC_CHANGE_SYNC_RATE)
-#define EVT_ID_MISC_CHANGE_INIT_RATE                 _CLASS_MISC(EVT_CODE_MISC_CHANGE_INIT_RATE)
-#define EVT_ID_MISC_CHANGE_REBUILD_RATE              _CLASS_MISC(EVT_CODE_MISC_CHANGE_REBUILD_RATE)
-#define EVT_ID_MISC_CHANGE_MIGRATION_RATE            _CLASS_MISC(EVT_CODE_MISC_CHANGE_MIGRATION_RATE)
-#define EVT_ID_MISC_CHANGE_COPYBACK_RATE             _CLASS_MISC(EVT_CODE_MISC_CHANGE_COPYBACK_RATE)
-#define EVT_ID_MISC_CHANGE_MP_RATE                   _CLASS_MISC(EVT_CODE_MISC_CHANGE_MP_RATE)
-#define EVT_ID_MISC_ALARM_MUTE                       _CLASS_MISC(EVT_CODE_MISC_ALARM_MUTE)
-
-//
-// Event code for EVT_CLASS_ARRAY
-//
-
-#define _CLASS_ARRAY(x)                (EVT_CLASS_ARRAY << 16 | (x))
-
-#define EVT_ID_ARRAY_CREATE                    _CLASS_ARRAY(EVT_CODE_ARRAY_CREATE)
-#define EVT_ID_ARRAY_DELETE                    _CLASS_ARRAY(EVT_CODE_ARRAY_DELETE)
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_flash_struct.h
+++ /dev/null
@@ -1,35 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_FLASH_STRUCT_H__
-#define __MV_COM_FLASH_STRUCT_H__
-
-#define 	 FLASH_DOWNLOAD                 0xf0
-#define	 FLASH_UPLOAD                       0xf
-
-//for read/write flash test command
-#define	 FLASH_BYTE_WRITE			0
-#define 	 FLASH_BYTE_READ			1
-
-#define    FLASH_TYPE_CONFIG              0
-#define    FLASH_TYPE_BIN                    1
-#define    FLASH_TYPE_BIOS                  2
-#define    FLASH_TYPE_FIRMWARE         3
-#define    FLASH_TYPE_AUTOLOAD         4
-
-
-#define 	FLASH_ERASE_PAGE                      0x1  //Erase bios or PD page or hba info page
-#define	FLASH_PD_PAGE					1	// Erase PD page in flash memory but not in-uses PD id
-#define	FLASH_PD_PAGE_FORCE			254	// Force to erase the whole PD page even PD id is in-use. Used by manufacturing only!
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_passthrough_struct.h
+++ /dev/null
@@ -1,57 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_PASS_THROUGH_H__
-#define __MV_COM_PASS_THROUGH_H__
-#include "com_define.h"
-#define PASSTHROUGH_ECC_WRITE	1
-#define PASSTHROUGH_ECC_SIZE	2
-
-#define SECTOR_LENGTH                           512
-#define SECTOR_WRITE                            0
-#define SECTOR_READ                             1
-
-#define MAX_PASS_THRU_DATA_BUFFER_SIZE (SECTOR_LENGTH+128)
-
-#pragma pack(8)
-
-typedef struct {
- // We put Data_Buffer[] at the very beginning of this structure because SCSI commander did so.
- MV_U8    Data_Buffer[MAX_PASS_THRU_DATA_BUFFER_SIZE];  // set by driver if read, by application if write
- MV_U8    Reserved1[128];
- MV_U32   Data_Length; // set by driver if read, by application if write
- MV_U16   DevId;       // PD ID (used by application only)
- MV_U8    CDB_Type;    // define a CDB type for each CDB category (used by application only)
- MV_U8    Reserved2;
- MV_U32   lba;
- MV_U8    Reserved3[64];
-} PassThrough_Config, * PPassThorugh_Config;
-
-typedef struct {
- // The data structure is used in conjunction with APICDB0_PASS_THRU_CMD_SCSI_16 (see com_api.h)
- // when CDB[16] is required.
- MV_U8    CDB[16];	// CDB is embedded in data buffer
- MV_U32    buf[1];	// actually input/output data buffer
-} PassThrough_Config_16, * PPassThorugh_Config_16;
-
-typedef struct _Pass_Through_Cmd
-{
-	MV_U8 	cdb[16];
-	MV_U16 	data_length;
-	MV_U8	Reserved[2];	// pad 2 bytes for DWORD alignment.
-	MV_U8 	data[1];
-}Pass_Through_Cmd,*PPass_Through_Cmd;
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_pd_struct.h
+++ /dev/null
@@ -1,286 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_PD_STRUCT_H__
-#define __MV_COM_PD_STRUCT_H__
-
-#include "com_physical_link.h"
-
-//PD
-#define MAX_HD_SUPPORTED_API                    128
-#define MAX_BLOCK_PER_HD_SUPPORTED_API          16
-
-// Macros used for error injection.
-// Error status that should be returned upon encountering the specified LBA
-#define REQ_STATUS_MEDIA_ERROR                  0x2
-#define REQ_STATUS_HAS_SENSE                    0x7
-#define REQ_STATUS_ERROR                        0x8
-
-#define PD_INIT_STATUS_OK						0
-#define PD_INIT_STATUS_ERROR					MV_BIT(0) // for HD_Info InitStatus, set if there was ever a failure during init
-
-// Definition used for old driver.
-#define HD_TYPE_SATA                            MV_BIT(0)
-#define HD_TYPE_PATA                            MV_BIT(1)
-#define HD_TYPE_SAS                             MV_BIT(2)
-#define HD_TYPE_ATAPI                           MV_BIT(3)
-#define HD_TYPE_TAPE                            MV_BIT(4)
-#define HD_TYPE_SES                             MV_BIT(5)
-
-// Definition used for PD interface type as defined in DDF spec
-#define PD_INTERFACE_TYPE_UNKNOWN               0x0000
-#define PD_INTERFACE_TYPE_SCSI                  0x1000
-#define PD_INTERFACE_TYPE_SAS                   0x2000
-#define PD_INTERFACE_TYPE_SATA                  0x3000
-#define PD_INTERFACE_TYPE_FC                    0x4000
-
-// PD's Protocol/Connection type (used by new driver)
-#define DC_ATA                                  MV_BIT(0)
-#define DC_SCSI                                 MV_BIT(1)
-#define DC_SERIAL                               MV_BIT(2)
-#define DC_PARALLEL                             MV_BIT(3)
-#define DC_ATAPI                                MV_BIT(4)  // used by core driver to prepare FIS
-#define DC_SGPIO                                MV_BIT(5)
-
-// PD's Device type defined in SCSI-III specification (used by new driver)
-#define DT_DIRECT_ACCESS_BLOCK                  0x00
-#define DT_SEQ_ACCESS                           0x01
-#define DT_PRINTER                              0x02
-#define DT_PROCESSOR                            0x03
-#define DT_WRITE_ONCE                           0x04
-#define DT_CD_DVD                               0x05
-#define DT_OPTICAL_MEMORY                       0x07
-#define DT_MEDIA_CHANGER                        0x08
-#define DT_STORAGE_ARRAY_CTRL                   0x0C
-#define DT_ENCLOSURE                            0x0D
-// The following are defined by Marvell
-#define DT_EXPANDER                             0x20
-#define DT_PM                                   0x21
-
-#define HD_FEATURE_NCQ                          MV_BIT(0)
-#define HD_FEATURE_TCQ                          MV_BIT(1)
-#define HD_FEATURE_1_5G                         MV_BIT(2)
-#define HD_FEATURE_3G                           MV_BIT(3)
-#define HD_FEATURE_WRITE_CACHE                  MV_BIT(4)
-#define HD_FEATURE_48BITS                       MV_BIT(5)
-#define HD_FEATURE_SMART                        MV_BIT(6)
-#define HD_FEATURE_6G                           MV_BIT(7)
-#define HD_FEATURE_CRYPTO                       MV_BIT(8)
-#define HD_FEATURE_TRIM                       MV_BIT(9)
-
-#define HD_SPEED_1_5G                           1
-#define HD_SPEED_3G                             2
-#define HD_SPEED_6G                             3
-
-#define HD_AES_CRYPTO_DISK                      MV_BIT(0)
-#define HD_AES_KEY_MATCHED                      MV_BIT(1)
-
-#define HD_WIPE_MDD                             0
-#define HD_WIPE_FORCE                           1
-
-#define HD_DMA_NONE                             0
-#define HD_DMA_1                                1
-#define HD_DMA_2                                2
-#define HD_DMA_3                                3
-#define HD_DMA_4                                4
-#define HD_DMA_5                                5
-#define HD_DMA_6                                6
-#define HD_DMA_7                                7
-#define HD_DMA_8                                8
-#define HD_DMA_9                                9
-
-#define HD_PIO_NONE                             0
-#define HD_PIO_1                                1
-#define HD_PIO_2                                2
-#define HD_PIO_3                                3
-#define HD_PIO_4                                4
-#define HD_PIO_5                                5
-
-#define HD_XCQ_OFF                              0
-#define HD_NCQ_ON                               1
-#define HD_TCQ_ON                               2
-
-#define HD_SSD_TYPE_NOT_SSD                     0
-#define HD_SSD_TYPE_UNKNOWN_SSD                 1
-
-#pragma pack(8)
-
-typedef struct _HD_Info
-{
- Link_Entity     Link;             /* Including self DevID & DevType */
- MV_U8           AdapterID;
- MV_U8           InitStatus;       /* Refer to PD_INIT_STATUS_XXX */
- MV_U8           HDType;           /* HD_Type_xxx, replaced by new driver with ConnectionType & DeviceType */
- MV_U8           PIOMode;          /* Max PIO mode */
- MV_U8           MDMAMode;         /* Max MDMA mode */
- MV_U8           UDMAMode;         /* Max UDMA mode */
- MV_U8           ConnectionType;   /* DC_XXX, ConnectionType & DeviceType in new driver to replace HDType above */
- MV_U8           DeviceType;       /* DT_XXX */
-
- MV_U32          FeatureSupport;   /* Support 1.5G, 3G, TCQ, NCQ, and etc, MV_BIT related */
- MV_U8           Model[40];
- MV_U8           SerialNo[20];
- MV_U8           FWVersion[8];
- MV_U64          Size;             /* In unit of BlockSize between API and driver */
- MV_U8           WWN[8];           /* ATA/ATAPI-8 has such definitions for the identify buffer */
- MV_U8           CurrentPIOMode;   /* Current PIO mode */
- MV_U8           CurrentMDMAMode;  /* Current MDMA mode */
- MV_U8           CurrentUDMAMode;  /* Current UDMA mode */
- MV_U8           ElementIdx;       /* corresponding element index in enclosure */
- MV_U32          BlockSize;        /* Bytes in one sector/block, if 0, set it to be 512 */
-
- MV_U8           ActivityLEDStatus;
- MV_U8           LocateLEDStatus;
- MV_U8           ErrorLEDStatus;
- MV_U8           SesDeviceType;	   /* ENC_ELEMENTTYPE_DEVICE or ENC_ELEMENTTYPE_ARRAYDEVICE */
- MV_U32		 sata_signature;
- MV_U8           Reserved4[8];
- MV_U8		 HD_SSD_Type;
- MV_U8		 Reserved1[63];
-}HD_Info, *PHD_Info;
-
-typedef struct _HD_MBR_Info
-{
- MV_U8           HDCount;
- MV_U8           Reserved[7];
- MV_U16          HDIDs[MAX_HD_SUPPORTED_API];
- MV_BOOLEAN      hasMBR[MAX_HD_SUPPORTED_API];
-} HD_MBR_Info, *PHD_MBR_Info;
-
-
-typedef struct _HD_FreeSpaceInfo
-{
- MV_U16          ID;               /* ID should be unique*/
- MV_U8           AdapterID;
- MV_U8           reserved1;
- MV_U16          BlockSize;        /* Bytes in one sector/block, if 0, set it to be 512 */
- MV_U8           reserved2;
- MV_BOOLEAN      isFixed;
-
- MV_U64          Size;             /* In unit of BlockSize between API and driver */
-}HD_FreeSpaceInfo, *PHD_FreeSpaceInfo;
-
-typedef struct _HD_Block_Info
-{
- MV_U16          ID;               /* ID in the HD_Info*/
- MV_U8           Type;             /* Refer to DEVICE_TYPE_xxx */
- MV_U8           BlkCount;         /* The valid entry count of BlockIDs */
-                                   /* This field is added for supporting large block count */
-                                   /* If BlkCount==0, "0x00FF" means invalid entry of BlockIDs */
- MV_U8           Reserved1[4];
-
- /* Free is 0xff */
- MV_U16          BlockIDs[MAX_BLOCK_PER_HD_SUPPORTED_API];
-}HD_Block_Info, *PHD_Block_Info;
-
-
-typedef struct _HD_CONFIG
-{
- MV_BOOLEAN        WriteCacheOn; // 1: enable write cache
- MV_BOOLEAN        SMARTOn;      // 1: enable S.M.A.R.T
- MV_BOOLEAN        Online;       // 1: to set HD online
- MV_U8             DriveSpeed;   // For SATA & SAS.  HD_SPEED_1_5G, HD_SPEED_3G etc
- MV_U8             crypto;
- MV_U8             Reserved[1];
- MV_U16            HDID;
-}HD_Config, *PHD_Config;
-
-typedef struct  _HD_SMART_STATUS
-{
- MV_BOOLEAN        SmartThresholdExceeded;
- MV_U8             Reserved1;
- MV_U16            HDID;
- MV_U8             Reserved2[4];
-}HD_SMART_Status, *PHD_SMART_Status;
-
-typedef struct _HD_BGA_STATUS
-{
- MV_U16            HDID;
- MV_U16            Percentage;      /* xx% */
- MV_U8             Bga;             /* Refer to HD_BGA_TYPE_xxx */
- MV_U8             Status;          /* not used */
- MV_U8             BgaStatus;       /* Refer to HD_BGA_STATE_xxx */
- MV_U8             Reserved[57];
-}HD_BGA_Status, *PHD_BGA_Status;
-
-/*
- * RCT entry flag
- */
-/* request type related */
-#define EH_READ_VERIFY_REQ_ERROR                MV_BIT(0) /* Read or Read Verify request is failed. */
-#define EH_WRITE_REQ_ERROR                      MV_BIT(1) /* Write request is failed */
-/* error type related */
-#define EH_MEDIA_ERROR                          MV_BIT(3) /* Media Error or timeout */
-#define EH_LOGICAL_ERROR                        MV_BIT(4) /* Logical Error because of BGA activity. */
-/* other flag */
-#define EH_FIX_FAILURE                          MV_BIT(5) /* Ever tried to fix this error but failed */
-/* extra flag */
-#define EH_TEMPORARY_ERROR                      MV_BIT(7) /* Temporary error. Used when BGA rebuild write mark target disk up. */
-
-
-typedef struct _RCT_Record{
- MV_LBA  lba;
- MV_U32  sec;                       //sector count
- MV_U8   flag;
- MV_U8   rev[3];
-}RCT_Record, *PRCT_Record;
-
-#pragma pack()
-
-//PM
-#define MAX_PM_SUPPORTED_API                    8
-
-#pragma pack(8)
-
-typedef  struct _PM_Info{
- Link_Entity       Link;           /* Including self DevID & DevType */
- MV_U8             AdapterID;
- MV_U8             ProductRevision;
- MV_U8             PMSpecRevision; /* 10 means 1.0, 11 means 1.1 */
- MV_U8             NumberOfPorts;
- MV_U16            VendorId;
- MV_U16            DeviceId;
- MV_U8             Reserved1[8];
-}PM_Info, *PPM_Info;
-
-#pragma pack()
-
-#define MAX_EXPANDER_SUPPORTED_API              16
-
-#define EXP_SSP                                 MV_BIT(0)
-#define EXP_STP                                 MV_BIT(1)
-#define EXP_SMP                                 MV_BIT(2)
-
-#pragma pack(8)
-
-typedef struct _Exp_Info
-{
- Link_Entity       Link;            /* Including self DevID & DevType */
- MV_U8             AdapterID;
- MV_BOOLEAN        Configuring;
- MV_BOOLEAN        RouteTableConfigurable;
- MV_U8             PhyCount;
- MV_U16            ExpChangeCount;
- MV_U16            MaxRouteIndexes;
- MV_U8             VendorID[8+1];
- MV_U8             ProductID[16+1];
- MV_U8             ProductRev[4+1];
- MV_U8             ComponentVendorID[8+1];
- MV_U16            ComponentID;
- MV_U8             ComponentRevisionID;
- MV_U8             Reserved1[17];
-}Exp_Info, * PExp_Info;
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_physical_link.h
+++ /dev/null
@@ -1,59 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_PHYSICAL_LINK_H__
-#define __MV_COM_PHYSICAL_LINK_H__
-
-#include "com_define.h"
-
-//Physical Link
-#define DEVICE_TYPE_NONE                        0
-#define DEVICE_TYPE_HD                          1       //  DT_DIRECT_ACCESS_BLOCK
-#define DEVICE_TYPE_PM                          2
-#define DEVICE_TYPE_EXPANDER                    3		// DT_EXPANDER
-#define DEVICE_TYPE_TAPE						4		// DT_SEQ_ACCESS
-#define DEVICE_TYPE_PRINTER						5		// DT_PRINTER
-#define DEVICE_TYPE_PROCESSOR					6		// DT_PROCESSOR
-#define DEVICE_TYPE_WRITE_ONCE					7 		// DT_WRITE_ONCE
-#define DEVICE_TYPE_CD_DVD						8		// DT_CD_DVD
-#define DEVICE_TYPE_OPTICAL_MEMORY				9 		// DT_OPTICAL_MEMORY
-#define DEVICE_TYPE_MEDIA_CHANGER				10		// DT_MEDIA_CHANGER
-#define DEVICE_TYPE_ENCLOSURE					11		// DT_ENCLOSURE
-#define DEVICE_TYPE_I2C_ENCLOSURE				12
-#define DEVICE_TYPE_PORT                        0xFF	// DT_STORAGE_ARRAY_CTRL
-
-#define MAX_WIDEPORT_PHYS                       8
-
-#pragma pack(8)
-
-typedef struct _Link_Endpoint
-{
- MV_U16      DevID;
- MV_U8       DevType;         /* Refer to DEVICE_TYPE_xxx */
- MV_U8       PhyCnt;          /* Number of PHYs for this endpoint. Greater than 1 if it is wide port. */
- MV_U8       PhyID[MAX_WIDEPORT_PHYS];    /* Assuming wide port has max of 8 PHYs. */
- MV_U8       SAS_Address[8];  /* Filled with 0 if not SAS device. */
- MV_U16      EnclosureID;     // enclosure ID of this device if available, otherwise 0xFFFF
- MV_U8       Reserved[6];
-} Link_Endpoint, * PLink_Endpoint;
-
-typedef struct _Link_Entity
-{
- Link_Endpoint    Parent;
- MV_U8            Reserved[8];
- Link_Endpoint    Self;
-} Link_Entity,  *PLink_Entity;
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_product.h
+++ /dev/null
@@ -1,117 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef COM_PRODUCT_H
-#define COM_PRODUCT_H
-/* Product device id */
-#define VENDOR_ID					        0x11AB
-#define VENDOR_ID_EXT                       0x1B4B
-#define DEVICE_ID_ODIN                      0x6400
-#define DEVICE_ID_THORLITE_2S1P				0x6121
-#define DEVICE_ID_THORLITE_0S1P				0x6101
-#define DEVICE_ID_THORLITE_1S1P				0x6111
-#define DEVICE_ID_THOR_4S1P				    0x6141
-#define DEVICE_ID_THOR_4S1P_NEW				0x6145
-/* Revision ID starts from B1 */
-#define DEVICE_ID_THORLITE_2S1P_WITH_FLASH              0x6122
-
- /* Odin lite version */
-#define DEVICE_ID_6320					0x6320
-#define DEVICE_ID_6340					0x6340
-
-/* mule-board */
-#define DEVICE_ID_6440					0x6440
-
-/* Non-RAID Odin */
-#define DEVICE_ID_6445					0x6445
-
-/* mule-board */
-#define DEVICE_ID_6480					0x6480
-#define DEVICE_ID_6485					0x6485
-
-
-#define DEVICE_ID_8180					0x8180
-#define DEVICE_ID_8440					0x8440
-#define DEVICE_ID_8480					0x8480
-#define DEVICE_ID_8110					0x8110
-#define DEVICE_ID_8120					0x8120
-
-/* Magni B0 */
-#define DEVICE_ID_9123					0x9123
-#define DEVICE_ID_9122					0x9122
-#define DEVICE_ID_914D					0x914D
-
-/* Magni lite */
-#define DEVICE_ID_9182					0x9182
-#define DEVICE_ID_9172					0x9172
-#define DEVICE_ID_9181					0x9181
-#define DEVICE_ID_9171					0x9171
-#define DEVICE_ID_9192					0x9192
-#define DEVICE_ID_91A1					0x91A1
-
-/* Magni B1 */
-#define DEVICE_ID_9023					0x9023
-#define DEVICE_ID_90A3					0x90A3
-#define DEVICE_ID_9110					0x9110
-#define DEVICE_ID_9190					0x9190
-#define DEVICE_ID_9111					0x9111
-#define DEVICE_ID_9191					0x9191
-#define DEVICE_ID_9120					0x9120
-#define DEVICE_ID_91A0					0x91A0
-#define DEVICE_ID_9122					0x9122
-#define DEVICE_ID_91A2					0x91A2
-#define DEVICE_ID_9128					0x9128
-#define DEVICE_ID_91A8					0x91A8
-#define DEVICE_ID_9028					0x9028
-#define DEVICE_ID_90A8					0x90A8
-#define DEVICE_ID_91A3					0x91A3
-#define DEVICE_ID_9130					0x9130
-#define DEVICE_ID_91B0					0x91B0
-
-/* Magni-plus*/
-#define DEVICE_ID_9200					0x9200
-/* Vanir */
-#define DEVICE_ID_9480					0x9480
-#define DEVICE_ID_9485					0x9485
-
-/* Vanir Lite */
-#define DEVICE_ID_9440					0x9440
-#define DEVICE_ID_9445					0x9445
-
-/* Frey B1*/
-#define DEVICE_ID_9580                              0x9580
-
-/* Frey Plus */
-#define DEVICE_ID_9588                              0x9588
-
-#define IS_VANIR_CORE(core)  ((core->device_id == DEVICE_ID_9580) || (core->device_id == DEVICE_ID_9588))
-
-#define IS_VANIR_944X(core)  ((core->device_id == DEVICE_ID_9440)||(core->device_id == DEVICE_ID_9445))
-#define IS_VANIR_948X(core)  ((core->device_id == DEVICE_ID_9480)||(core->device_id == DEVICE_ID_9485))
-
-#define IS_VANIR_94X0(core)  ((core->device_id == DEVICE_ID_9480)||(core->device_id == DEVICE_ID_9440))
-#define IS_VANIR_94X5(core)  ((core->device_id == DEVICE_ID_9485)||(core->device_id == DEVICE_ID_9445))
-
-#define IS_VANIR(core)  ( IS_VANIR_944X(core)|| IS_VANIR_948X(core) || IS_VANIR_CORE(core))
-
-
-/* Florence */
-#define DEVICE_ID_948F					0x948F
-
-#define DEVICE_ID_UNKNOWN				0xFFFF
-
-/*for magni*/
-#define MAGNI_VENDORID                "Marvell"
-#define MAGNI_PRODUCTID               "9123-1b4b"
-#define MAGNI_PRODUCTID_II		"91xx Config"
-#endif
--- a/drivers/scsi/vanir/include/generic/com_raid_struct.h
+++ /dev/null
@@ -1,210 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_RAID_STRUCT_H__
-#define __MV_COM_RAID_STRUCT_H__
-
-#include "com_define.h"
-#include "com_pd_struct.h"
-
-#pragma pack(8)
-#define MAX_SPARE_PD_SUPPORTED_API				8
-#define MAX_BLOCK_SUPPORTED_API                 512
-
-#define MAX_BGA_RATE                            0xFA
-#define MAX_MEDIAPATROL_RATE                    0xFF
-
-#define CACHE_WRITEBACK_ENABLE                  0
-#define CACHE_WRITETHRU_ENABLE                  1
-#define CACHE_ADAPTIVE_ENABLE                   2
-#define CACHE_AUTO_ENABLE                       MV_BIT(3)
-#define CACHE_WRITE_POLICY_FILTER               (CACHE_WRITEBACK_ENABLE | \
-       CACHE_WRITETHRU_ENABLE | \
-       CACHE_ADAPTIVE_ENABLE | \
-       CACHE_AUTO_ENABLE)
-#define CACHE_LOOKAHEAD_ENABLE                  MV_BIT(2)
-
-
-/* Definition for MV_LD_State */
-#define LD_BGA_NONE                             0
-#define LD_BGA_REBUILD                          MV_BIT(0)
-#define LD_BGA_CONSISTENCY_FIX                  MV_BIT(1)
-#define LD_BGA_CONSISTENCY_CHECK                MV_BIT(2)
-#define LD_BGA_INIT_QUICK                       MV_BIT(3)
-#define LD_BGA_INIT_BACK                        MV_BIT(4)
-#define LD_BGA_MIGRATION                        MV_BIT(5)
-#define LD_BGA_INIT_FORE                        MV_BIT(6)
-#define LD_BGA_COPYBACK                         MV_BIT(7)
-#define LD_BGA_DEFECT_FIXING                    MV_BIT(8)        /* Don't need save to DDF */
-#define LD_BGA_MEDIA_PATROL                     MV_BIT(9)
-#define LD_BGA_MIGRATION_EXT                    MV_BIT(10)       /* Free -> RAID0 */
-
-#define LD_BGA_STATE_NONE                       0
-#define LD_BGA_STATE_RUNNING                    1
-#define LD_BGA_STATE_ABORTED                    2
-#define LD_BGA_STATE_PAUSED                     3
-#define LD_BGA_STATE_AUTOPAUSED                 4
-#define LD_BGA_STATE_INTERRUPTED                5
-#define LD_BGA_STATE_DDF_PENDING                MV_BIT(7)
-
-#define LD_MODE_FREE                            0x66
-#define LD_MODE_RAID0                           0x0
-#define LD_MODE_RAID1                           0x1
-#define LD_MODE_RAID5                           0x5
-#define LD_MODE_RAID6                           0x6
-#define LD_MODE_JBOD                            0x0f
-#define LD_MODE_RAID10                          0x10
-#define LD_MODE_RAID1E                          0x11
-#define LD_MODE_RAID50                          0x50
-#define LD_MODE_RAID60                          0x60
-#define LD_MODE_RAID_CROSS                      0x0a
-#define LD_MODE_RAID_HDD_MIRROR		            0x0b
-#define LD_MODE_UNKNOWN                         0xFF
-
-#define	LD_IS_HYPER_HDD(raid_mode)	((raid_mode == LD_MODE_RAID_CROSS) || (raid_mode == LD_MODE_RAID_HDD_MIRROR))
-
-#define REBUILD_VD 1
-#define REBUILD_DG 2
-
-typedef struct _Rebuild_Param
-{
-    MV_U16     ID;
-    MV_U8      RebuildType;
-    MV_U8      PDCount;
-    MV_U8      Reserved1[4];
-    MV_U16     PDIDs[MAX_HD_SUPPORTED_API];
-    MV_U8      Reserved2[64];
-} Rebuild_Param, * PRebuild_Param;
-
-typedef struct  _HD_RAID_STATUS
-{
- MV_U16            HDID;
- MV_U16            DGID;
- MV_U8             Status;         /* HD_STATUS_SPARE */
- MV_U8             Reserved[3];
-}HD_RAID_Status, *PHD_RAID_Status;
-
-typedef struct  _BSL{
- MV_U64            LBA;            /* Bad sector LBA for the HD. */
-
- MV_U32            Count;          /* How many serial bad sectors */
- MV_BOOLEAN        Flag;           /* Fake bad sector or not. */
- MV_U8             Reserved[3];
-}BSL,*PBSL;
-
-typedef struct _BLOCK_INFO
-{
- MV_U16            ID;
- MV_U16            HDID;           /* ID in the HD_Info */
- MV_U16            Flags;          /* Refer to BLOCK_XXX definition */
- MV_U16            LDID;           /* Belong to which LD */
-
- MV_U8             Status;         /* Refer to BLOCK_STATUS_XXX*/
- MV_U8             Reserved;
- MV_U16            BlockSize;      /* in bytes. if 0, BlockSize is 512 */
- MV_U32            ReservedSpaceForMigration; /* Space reserved for migration */
-
- MV_U64            StartLBA;       /* unit: 512 bytes */
- MV_U64            Size;           /* In unit of BlockSize between API and driver, including ReservedSpaceForMigration */
-}Block_Info, *PBlock_Info;
-
-#pragma pack()
-
-#define CONSISTENCYCHECK_ONLY                   0
-#define CONSISTENCYCHECK_FIX                    1
-
-#define INIT_QUICK                              0
-#define INIT_FULLFOREGROUND                     1
-#define INIT_FULLBACKGROUND                     2
-#define INIT_NONE                               3
-
-#define INIT_QUICK_WITHOUT_EVENT                0xf
-
-#define BGA_CONTROL_START                       0
-#define BGA_CONTROL_RESTART                     1
-#define BGA_CONTROL_PAUSE                       2
-#define BGA_CONTROL_RESUME                      3
-#define BGA_CONTROL_ABORT                       4
-#define BGA_CONTROL_COMPLETE                    5
-#define BGA_CONTROL_IN_PROCESS                  6
-#define BGA_CONTROL_TERMINATE_IMMEDIATE         7
-#define BGA_CONTROL_AUTO_PAUSE                  8
-#define BGA_CONTROL_CONTINUE					9
-
-#define ROUNDING_SCHEME_NONE                    0     /* no rounding */
-#define ROUNDING_SCHEME_1GB                     1     /* 1 GB rounding */
-#define ROUNDING_SCHEME_10GB                    2     /* 10 GB rounding */
-
-
-#define HD_STATUS_FREE                          MV_BIT(0)
-#define HD_STATUS_ASSIGNED                      MV_BIT(1)
-#define HD_STATUS_SPARE                         MV_BIT(2)
-#define HD_STATUS_OFFLINE                       MV_BIT(3)
-#define HD_STATUS_SMARTCHECKING                 MV_BIT(4)
-#define HD_STATUS_MP                            MV_BIT(5)
-#define HD_STATUS_DEDICATED_SPARE               MV_BIT(6)
-#define HD_STATUS_FOREIGN						MV_BIT(7)
-
-#define HD_BGA_STATE_NONE                       LD_BGA_STATE_NONE
-#define HD_BGA_STATE_RUNNING                    LD_BGA_STATE_RUNNING
-#define HD_BGA_STATE_ABORTED                    LD_BGA_STATE_ABORTED
-#define HD_BGA_STATE_PAUSED                     LD_BGA_STATE_PAUSED
-#define HD_BGA_STATE_AUTOPAUSED                 LD_BGA_STATE_AUTOPAUSED
-#define HD_BGA_STATE_PART_COMPLETE				6
-
-#define HD_BGA_TYPE_NONE                        0
-#define HD_BGA_TYPE_MP                          1
-#define HD_BGA_TYPE_DATASCRUB                   2
-
-#define PD_TYPE_PD_IN_VD                        MV_BIT(1)
-#define GLOBAL_SPARE_DISK                       MV_BIT(2)
-#define DEDICATED_SPARE_DISK                    MV_BIT(3)
-#define PD_TYPE_FOREIGN							MV_BIT(4)
-#define PD_TYPE_ENCLOSURE						MV_BIT(7)
-#define PD_TYPE_SSD								MV_BIT(6)
-
-
-#define PD_DDF_VALID                            MV_BIT(0)
-#define PD_DISK_VALID                           MV_BIT(1)
-#define PD_DDF_CLEAN                            MV_BIT(2)
-#define PD_NEED_UPDATE                          MV_BIT(3)
-#define PD_MBR_VALID                            MV_BIT(4)
-#define PD_NEED_FLUSH                           MV_BIT(5)
-#define PD_CLEAR_MBR                            MV_BIT(6)
-#define PD_RCT_NEED_UPDATE                      MV_BIT(7)
-#define PD_INIT_DDF_PROCESSING					MV_BIT(8)
-#define PD_NEED_UPDATE_DELETE_LD				MV_BIT(9)
-#define PD_NEED_SPIN_DOWN                       MV_BIT(10)
-
-#define PD_STATE_ONLINE                         MV_BIT(0)
-#define PD_STATE_FAILED                         MV_BIT(1)
-#define PD_STATE_REBUILDING                     MV_BIT(2)
-#define PD_STATE_TRANSITION                     MV_BIT(3)
-#define PD_STATE_SMART_ERROR                    MV_BIT(4)
-#define PD_STATE_READ_ERROR                     MV_BIT(5)
-#define PD_STATE_MISSING                        MV_BIT(6)
-#define PD_STATE_SPIN_DOWN						MV_BIT(7)
-
-#define HD_STATUS_SETONLINE                     0
-#define HD_STATUS_SETOFFLINE                    1
-#define HD_STATUS_FORCESETOFFLINE				2
-#define HD_STATUS_SETFREE						3
-#define HD_STATUS_INVALID                       0xFF
-
-#define BLOCK_INVALID                           0
-#define BLOCK_VALID                             MV_BIT(0)
-#define BLOCK_ASSIGNED                          MV_BIT(1)
-#define BLOCK_FLAG_REBUILDING                   MV_BIT(2)
-#define BLOCK_FLAG_TEMP_ASSIGN                  MV_BIT(3
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_request_detail.h
+++ /dev/null
@@ -1,144 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_REQUEST_DETAIL_H__
-#define __MV_COM_REQUEST_DETAIL_H__
-
-#include "com_pd_struct.h"
-#include "com_enc_struct.h"
-#include "com_vd_struct.h"
-#include "com_raid_struct.h"
-#include "com_array_struct.h"
-#include "com_adapter_struct.h"
-
-#pragma pack(8)
-
-typedef struct _HD_Info_Request
-{
-    RequestHeader header;
-    HD_Info  hdInfo[1];
-} HD_Info_Request, *PHD_Info_Request;
-
-typedef struct _HD_FreeSpaceInfo_Request
-{
-    RequestHeader header;
-    HD_FreeSpaceInfo  hdFreeSpaceInfo[1];
-} HD_FreeSpaceInfo_Request, *PHD_FreeSpaceInfo_Request;
-
-typedef struct _HD_Config_Request
-{
-    RequestHeader header;
-    HD_Config  hdConfig[1];
-} HD_Config_Request, *PHD_Config_Request;
-
-typedef struct _HD_SMART_Status_Request
-{
-    RequestHeader header;
-    HD_SMART_Status  hdSmartStatus[1];
-} HD_SMART_Status_Request, *PHD_SMART_Status_Request;
-
-typedef struct _HD_Block_Info_Request
-{
-    RequestHeader header;
-    HD_Block_Info  hdBlockInfo[1];
-} HD_Block_Info_Request, *PHD_Block_Info_Request;
-
-typedef struct _HD_RAID_Status_Request
-{
-    RequestHeader header;
-    HD_RAID_Status  hdRaidStatus[1];
-} HD_RAID_Status_Request, *PHD_RAID_Status_Request;
-
-typedef struct _HD_BGA_Status_Request
-{
-    RequestHeader header;
-    HD_BGA_Status  hdBgaStatus[1];
-} HD_BGA_Status_Request, *PHD_BGA_Status_Request;
-
-typedef struct _Block_Info_Request
-{
-    RequestHeader header;
-    Block_Info  blockInfo[1];
-} Block_Info_Request, *PBlock_Info_Request;
-
-typedef struct _LD_Info_Request
-{
-    RequestHeader header;
-    LD_Info  ldInfo[1];
-} LD_Info_Request, *PLD_Info_Request;
-
-typedef struct _LD_Status_Request
-{
-    RequestHeader header;
-    LD_Status  ldStatus[1];
-} LD_Status_Request, *PLD_Status_Request;
-
-typedef struct _LD_Config_Request
-{
-    RequestHeader header;
-    LD_Config  ldConfig[1];
-} LD_Config_Request, *PLD_Config_Request;
-
-typedef struct _DG_Info_Request
-{
-    RequestHeader header;
-    DG_Info  dgInfo[1];
-} DG_Info_Request, *PDG_Info_Request;
-
-typedef struct _DG_Config_Request
-{
-    RequestHeader header;
-    DG_Config  dgConfig[1];
-} DG_Config_Request, *PDG_Config_Request;
-
-typedef struct _RCT_Record_Request
-{
-    RequestHeader header;
-    RCT_Record  rctRecord[1];
-} RCT_Record_Request, *PRCT_Record_Request;
-
-/* Port Multiplexier */
-typedef struct _PM_Info_Request
-{
-    RequestHeader header;
-    PM_Info  pmInfo[1];
-} PM_Info_Request, *PPM_Info_Request;
-
-/* Expander */
-typedef struct _Exp_Info_Request
-{
-    RequestHeader header;
-    Exp_Info  expInfo[1];
-} Exp_Info_Request, *PExp_Info_Request;
-
-typedef struct _Enclosure_Info_Request
-{
-    RequestHeader header;
-    Enclosure_Info  encInfo[1];
-} Enclosure_Info_Request, *PEnclosure_Info_Request;
-
-typedef struct _EncElementType_Info_Request
-{
-    RequestHeader header;
-    EncElementType_Info  encEleTypeInfo[1];
-} EncElementType_Info_Request, *PEncElementType_Info_Request;
-
-typedef struct _EncElement_Config_Request
-{
-    RequestHeader header;
-    EncElement_Config  encEleConfig[1];
-} EncElement_Config_Request, *PEncElement_Config_Request;
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_request_header.h
+++ /dev/null
@@ -1,61 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_REQUEST_HEADER_H__
-#define __MV_COM_REQUEST_HEADER_H__
-
-#define NO_MORE_DATA                            0xFFFF
-
-#pragma pack(8)
-
-/****************************************/
-/* Start of variable size data request structures */
-/***************************************/
-#define REQUEST_BY_RANGE	1	/*  get a range of data by a given starting index and total number desired. */
-#define REQUEST_BY_ID		2	/*  get specific data by a given device ID. */
-
-typedef struct _RequestHeader
-{
-    MV_U8  version;			     /* Request header version; 0 for now. */
-    MV_U8  requestType;		     /* REQUEST_BY_ID or REQUEST_BY_RANGE */
-    MV_U16 startingIndexOrId;	     /* Starting index (in driver) of the data to be retrieved if requestType is REQUEST_BY_RANGE;
-								* otherwise this is the device ID of which its data is to be retrieved.  */
-    MV_U16 numRequested;		     /* Max number of data entries application expected driver to return starting from
-								* startingIndexOrId, Application based on this value to allocate data space.
-								* If requestType is REQUEST_BY_ID, numRequested should set to 1. */
-    MV_U16 numReturned;		     /* Actual number of data entries returned by driver. API might reduce this number
-								* by filtering out un-wanted entries. */
-    MV_U16 nextStartingIndex;	     /* Driver suggested next starting index.  If requestType is REQUEST_BY_RANGE and
-								* if there is no more data available after this one, set it to NO_MORE_DATA.
-								* If requestType is REQUEST_BY_ID, always set it to NO_MORE_DATA. */
-    MV_U8  reserved1[6];
-} RequestHeader, *PRequestHeader;
-
-typedef struct _Info_Request
-{
-    RequestHeader header;
-    MV_U8	      data[1];
-} Info_Request, *PInfo_Request;
-
-#define FillRequestHeader( pReq,  m_requestType,  m_startingIndexOrId,  m_numRequested)  \
-do \
-{  \
-	memset((pReq), 0,sizeof(RequestHeader));  \
-	(pReq)->requestType = (m_requestType);   \
-	(pReq)->startingIndexOrId= (m_startingIndexOrId);  \
-	(pReq)->numRequested = (m_numRequested);  \
-}while(0)
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/generic/com_struct.h
+++ /dev/null
@@ -1,45 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_STRUCT_H__
-#define __MV_COM_STRUCT_H__
-
-#include "com_define.h"
-
-#define GET_ALL                                 0xFF
-#define ID_UNKNOWN                              0x7F
-
-#define INVALID_ID                              0xFF
-#define UNDEFINED_ID                            0xFFFF
-
-
-#define MAX_NUM_ADAPTERS                        4
-
-#include "com_adapter_struct.h"
-
-#include "com_pd_struct.h"
-#include "com_enc_struct.h"
-
-#include "com_dbg_struct.h"
-#include "com_bbu_struct.h"
-
-#include "com_vd_struct.h"
-#include "com_array_struct.h"
-
-#include "com_passthrough_struct.h"
-#include "com_flash_struct.h"
-
-#include "com_request_header.h"
-#include "com_request_detail.h"
-
-#endif /*  __MV_COM_STRUCT_H__ */
--- a/drivers/scsi/vanir/include/generic/com_vd_struct.h
+++ /dev/null
@@ -1,137 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_VD_STRUCT_H__
-#define __MV_COM_VD_STRUCT_H__
-
-#include "com_raid_struct.h"
-
-#define MAX_LD_SUPPORTED_API                    32
-
-#define LD_MAX_NAME_LENGTH                      16
-
-#define LD_STATUS_FUNCTIONAL                    0
-#define LD_STATUS_DEGRADE                       1
-#define LD_STATUS_DELETED                       2
-#define LD_STATUS_MISSING                       3 /* LD missing in system. */
-#define LD_STATUS_OFFLINE                       4
-#define LD_STATUS_PARTIALLYOPTIMAL              5 /* r6 w/ 2 pd, 1 hd drops */
-#define LD_STATUS_FOREIGN                       6
-#define LD_STATUS_IMPORTABLE		            7
-#define LD_STATUS_NOT_IMPORTABLE	            8
-#define LD_STATUS_MIGRATION                     9
-#define LD_STATUS_REBUILDING			        10
-#define LD_STATUS_CONFLICTED		            11
-#define LD_STATUS_DEGRADE_PLUGIN		        12
-#define LD_STATUS_HYPER_UNINIT    		        13
-#define LD_STATUS_INVALID                       0xFF
-
-#ifndef MV_GUID_SIZE
-#define MV_GUID_SIZE                            8
-#endif /* MV_GUID_SIZE */
-
-#pragma pack(8)
-
-typedef struct _LD_Info
-{
- MV_U16            ID;
- MV_U8             Status;         /* Refer to LD_STATUS_xxx */
- MV_U8             BGAStatus;      /* Refer to LD_BGA_STATE_xxx */
- MV_U16            StripeBlockSize;/* between RAIDAPI and driver, it is # of BlockSize */
- MV_U8             RaidMode;
- MV_U8             HDCount;
-
- MV_U8             CacheMode;      /* Default is CacheMode_Default, see above */
- MV_U8             LD_GUID[MV_GUID_SIZE];
- MV_U8             SectorCoefficient; /* (sector size) 1=>512 (default), 2=>1024, 4=>2048, 8=>4096 */
- MV_U8             AdapterID;
- MV_U8             BlkCount;         /* The valid entry count of BlockIDs */
-                                     /* This field is added for supporting large block count */
-                                     /* If BlkCount==0, "0x00FF" means invalid entry of BlockIDs */
- MV_U16            time_hi;
- MV_U16            DGID;
-
- MV_U64            Size;           /* In unit of BlockSize between API and driver. */
-
- MV_U8             Name[LD_MAX_NAME_LENGTH];
-
- MV_U16            BlockIDs[MAX_HD_SUPPORTED_API];
-/*
- * According to BLOCK ID, to get the related HD ID, then WMRU can
- * draw the related graph like above.
- */
- MV_U8             SubLDCount;     /* for raid 10, 50,60 */
- MV_U8             NumParityDisk;  /* For RAID 6. */
- MV_U16            time_low;
- MV_U32            BlockSize;      /* in bytes. if 0, BlockSize is 512 */
-
-}LD_Info, *PLD_Info;
-
-typedef struct _Create_LD_Param
-{
- MV_U8             RaidMode;
- MV_U8             HDCount;
- MV_U8             RoundingScheme; /* please refer to the definitions of  ROUNDING_SCHEME_XXX. */
- MV_U8             SubLDCount;     /* for raid 10,50,60 */
- MV_U16            StripeBlockSize;/* between API and driver, it is # of BlockSize */
- MV_U8             NumParityDisk;  /* For RAID 6. */
- MV_U8             CachePolicy;    /* please refer to the definition of CACHEMODE_XXXX. */
-
- MV_U8             InitializationOption; /* please refer to the definitions of INIT_XXXX. */
- MV_U8             SectorCoefficient;    /* (sector size) 1=>512 (default), 2=>1024, 4=>2048, 8=>4096 */
- MV_U16            LDID;                 /* ID of the LD to be migrated or expanded */
- MV_U8             SpecifiedBlkSeq;      /* DG slot number, this is only used when DG is enforced */
- MV_U8             HypperWaterMark;
- MV_U8             Reserved2[1];
- MV_U8             ReservedForApp;	/* Reserved for application (CLI) */
-
- MV_U16            HDIDs[MAX_HD_SUPPORTED_API];    /* 32 */
- MV_U8             Name[LD_MAX_NAME_LENGTH];
-
- MV_U64            Size;           /* In unit of BlockSize between API and driver. API need to get the BlockSize for PD first and use it to set 'Size' */
-} Create_LD_Param, *PCreate_LD_Param;
-
-
-typedef struct _Hyper_Free_Info
-{
- MV_U16            ID;
- MV_U8             Reserved[6];
-
- MV_U64            HyperFreeSize;
-} Hyper_Free_Info, *PHyper_Free_Info;
-
-typedef struct _LD_STATUS
-{
- MV_U8            Status;          /* Refer to LD_STATUS_xxx */
- MV_U8            Bga;             /* Refer to LD_BGA_xxx */
- MV_U16           BgaPercentage;   /* xx% */
- MV_U8            BgaState;        /* Refer to LD_BGA_STATE_xxx */
- MV_U8            BgaExt;          /* Not used yet. Extention of Bga. */
- MV_U16           LDID;
-} LD_Status, *PLD_Status;
-
-typedef struct    _LD_Config
-{
- MV_U8            CacheMode;        /* See definition 4.4.1 CacheMode_xxx */
- MV_U8            HypperWaterMark;
- MV_BOOLEAN       AutoRebuildOn;    /* 1- AutoRebuild On */
- MV_U8            Status;
- MV_U16           LDID;
- MV_U8            Reserved2[2];
-
- MV_U8            Name[LD_MAX_NAME_LENGTH];
-}LD_Config, * PLD_Config;
-
-#pragma pack()
-
-#endif
--- a/drivers/scsi/vanir/include/icommon/com_api.h
+++ /dev/null
@@ -1,266 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef  __MV_COM_API_H__
-#define  __MV_COM_API_H__
-
-#define APICDB15_VARIABLE_SIZE_REQUEST			1
-
-/* CDB definitions */
-#define APICDB0_ADAPTER                        0xF0
-#define APICDB0_LD                             0xF1
-#define APICDB0_BLOCK                          0xF2
-#define APICDB0_PD                             0xF3
-#define APICDB0_EVENT                          0xF4
-#define APICDB0_DBG                            0xF5
-#define APICDB0_FLASH                          0xF6
-#define APICDB0_AES                            0xF7
-
-#define APICDB0_IOCONTROL		 			   0xF9
-#define APICDB0_PASS_THRU_CMD_SCSI			   0xFA
-#define APICDB0_PASS_THRU_CMD_ATA			   0xFB
-#define APICDB0_PASS_THRU_COMMON			   0xFD
-
-/* Pass through for CDB[16].  The actually CDB is in the first 16 bytes of the input buffer. */
-#define APICDB0_PASS_THRU_CMD_SCSI_16          0xFC
-
-#define APICDB0_EXTENSION                      0xFF		// reserved, used only when 0xF0 to 0xFE above are all used up!
-
-/* for IOCONTROL */
-#define APICDB1_GET_OS_DISK_INFO		0
-#define APICDB1_SET_OS_DISK_QUEUE_DEPTH	1
-
-/* for Adapter */
-#define APICDB1_ADAPTER_GETCOUNT               0
-#define APICDB1_ADAPTER_GETINFO                (APICDB1_ADAPTER_GETCOUNT + 1)
-#define APICDB1_ADAPTER_GETCONFIG              (APICDB1_ADAPTER_GETCOUNT + 2)
-#define APICDB1_ADAPTER_SETCONFIG              (APICDB1_ADAPTER_GETCOUNT + 3)
-#define APICDB1_ADAPTER_POWER_STATE_CHANGE     (APICDB1_ADAPTER_GETCOUNT + 4)
-#define APICDB1_ADAPTER_BBU_INFO               (APICDB1_ADAPTER_GETCOUNT + 5)
-#define APICDB1_ADAPTER_BBU_SET_THRESHOLD      (APICDB1_ADAPTER_GETCOUNT + 6)
-#define APICDB1_ADAPTER_BBU_POWER_CHANGE       (APICDB1_ADAPTER_GETCOUNT + 7)
-#define APICDB1_ADAPTER_AES_GETCONFIG          (APICDB1_ADAPTER_GETCOUNT + 8)
-#define APICDB1_ADAPTER_AES_SETCONFIG          (APICDB1_ADAPTER_GETCOUNT + 9)
-#define APICDB1_ADAPTER_BBU_SETSTATUS_DBG      (APICDB1_ADAPTER_GETCOUNT + 10)// only for test BBU function
-#define APICDB1_ADAPTER_MUTE                   (APICDB1_ADAPTER_GETCOUNT + 11)
-#define APICDB1_ADAPTER_ROOT_RESET             (APICDB1_ADAPTER_GETCOUNT + 12)
-#define APICDB1_ADAPTER_SET_HOST_BUFFER        (APICDB1_ADAPTER_GETCOUNT + 13)
-#define APICDB1_ADAPTER_MAX                    (APICDB1_ADAPTER_GETCOUNT + 14)
-
-#define APICDB1_ADAPTER_BBU_CHARGE_THRESHOLD   (APICDB1_ADAPTER_GETCOUNT + 6)
-
-#define APICDB2_ADAPTER_POWER_CHANGE_LEAVING_S0   0
-#define APICDB2_ADAPTER_POWER_CHANGE_ENTER_S0     1
-#define APICDB2_ADAPTER_POWER_CHANGE_SHUTDOWN     2
-
-/* for LD */
-#define APICDB1_LD_CREATE                      0
-#define APICDB1_LD_GETMAXSIZE                  (APICDB1_LD_CREATE + 1)
-#define APICDB1_LD_GETINFO                     (APICDB1_LD_CREATE + 2)
-#define APICDB1_LD_GETTARGETLDINFO             (APICDB1_LD_CREATE + 3)
-#define APICDB1_LD_DELETE                      (APICDB1_LD_CREATE + 4)
-#define APICDB1_LD_GETSTATUS                   (APICDB1_LD_CREATE + 5)
-#define APICDB1_LD_GETCONFIG                   (APICDB1_LD_CREATE + 6)
-#define APICDB1_LD_SETCONFIG                   (APICDB1_LD_CREATE + 7)
-#define APICDB1_LD_STARTREBUILD                (APICDB1_LD_CREATE + 8)	// single target rebuild on VD only (see APICDB1_LD_DG_STARTREBUILD)
-#define APICDB1_LD_STARTCONSISTENCYCHECK       (APICDB1_LD_CREATE + 9)
-#define APICDB1_LD_STARTINIT                   (APICDB1_LD_CREATE + 10)
-#define APICDB1_LD_STARTMIGRATION              (APICDB1_LD_CREATE + 11)
-#define APICDB1_LD_BGACONTROL                  (APICDB1_LD_CREATE + 12)
-#define APICDB1_LD_WIPEMDD                     (APICDB1_LD_CREATE + 13)
-#define APICDB1_LD_GETSPARESTATUS              (APICDB1_LD_CREATE + 14)
-#define APICDB1_LD_SETGLOBALSPARE              (APICDB1_LD_CREATE + 15)
-#define APICDB1_LD_SETLDSPARE                  (APICDB1_LD_CREATE + 16)
-#define APICDB1_LD_REMOVESPARE                 (APICDB1_LD_CREATE + 17)
-#define APICDB1_LD_HD_SETSTATUS                (APICDB1_LD_CREATE + 18)
-#define APICDB1_LD_SHUTDOWN                    (APICDB1_LD_CREATE + 19)
-#define APICDB1_LD_HD_FREE_SPACE_INFO          (APICDB1_LD_CREATE + 20)
-#define APICDB1_LD_HD_GETMBRINFO               (APICDB1_LD_CREATE + 21)
-#define APICDB1_LD_SIZEOF_MIGRATE_TARGET       (APICDB1_LD_CREATE + 22)
-#define APICDB1_LD_TARGET_LUN_TYPE			   (APICDB1_LD_CREATE + 23)
-#define APICDB1_LD_HD_START_MEDIAPATROL        (APICDB1_LD_CREATE + 24)
-#define APICDB1_LD_HD_RESERVED				   (APICDB1_LD_CREATE + 25)
-#define APICDB1_LD_HD_GET_RCT_COUNT            (APICDB1_LD_CREATE + 26)
-#define APICDB1_LD_HD_RCT_REPORT               (APICDB1_LD_CREATE + 27)
-#define APICDB1_LD_HD_START_DATASCRUB          (APICDB1_LD_CREATE + 28)
-#define APICDB1_LD_HD_BGACONTROL	           (APICDB1_LD_CREATE + 29)
-#define APICDB1_LD_HD_GETBGASTATUS             (APICDB1_LD_CREATE + 30)
-#define APICDB1_LD_CREATE_MODIFY_DG			   (APICDB1_LD_CREATE + 31)	// Create or modify Disk Group (DG)
-#define APICDB1_LD_CREATE_MODIFY_VD			   (APICDB1_LD_CREATE + 32)	// Create or modify VD using DG
-#define APICDB1_LD_DELETE_DG				   (APICDB1_LD_CREATE + 33)	// Delete DG
-#define APICDB1_LD_GET_DG_INFO				   (APICDB1_LD_CREATE + 34)	// Get DG info
-#define APICDB1_LD_DG_STARTREBUILD			   (APICDB1_LD_CREATE + 35) // Start rebuild on VD or DG with one or multiple target (see APICDB1_LD_STARTREBUILD)
-#define APICDB1_LD_DG_STARTCONSISTENCYCHECK    (APICDB1_LD_CREATE + 36) // Start sync on DG
-#define APICDB1_LD_DG_STARTINIT                (APICDB1_LD_CREATE + 37)	// Start init on DG
-#define APICDB1_LD_DG_STARTMIGRATION           (APICDB1_LD_CREATE + 38) // Start migration on DG
-#define APICDB1_LD_DG_BGACONTROL               (APICDB1_LD_CREATE + 39) // BGA control on DG
-#define APICDB1_LD_RESERVED1                   (APICDB1_LD_CREATE + 40) // Reserved, can be re-used!
-#define APICDB1_LD_SET_DG_SPARE                (APICDB1_LD_CREATE + 41)
-#define APICDB1_LD_DG_GETSETTING               (APICDB1_LD_CREATE + 42)
-#define APICDB1_LD_DG_SETSETTING               (APICDB1_LD_CREATE + 43)
-#define APICDB1_LD_COPYBACK                    (APICDB1_LD_CREATE + 44) // Currently internal used by RAID core
-#define APICDB1_LD_IMPORT                      (APICDB1_LD_CREATE + 45)
-#define APICDB1_LD_GET_WORKING_LD 		       (APICDB1_LD_CREATE + 46)
-#define APICDB1_LD_REPORTED_LD		           (APICDB1_LD_CREATE + 47) // used to report the LD to OS
-#define APICDB1_LD_GETCROSSINFO		           (APICDB1_LD_CREATE + 48)
-#define APICDB1_LD_GETHYPERFREEINFO            (APICDB1_LD_CREATE + 49)
-#define APICDB1_LD_MAX                         (APICDB1_LD_CREATE + 50)
-
-
-
-/* for PD */
-#define APICDB1_PD_GETHD_INFO                  0
-#define APICDB1_PD_GETEXPANDER_INFO            (APICDB1_PD_GETHD_INFO + 1)
-#define APICDB1_PD_GETPM_INFO                  (APICDB1_PD_GETHD_INFO + 2)
-#define APICDB1_PD_GETSETTING                  (APICDB1_PD_GETHD_INFO + 3)
-#define APICDB1_PD_SETSETTING                  (APICDB1_PD_GETHD_INFO + 4)
-#define APICDB1_PD_BSL_DUMP                    (APICDB1_PD_GETHD_INFO + 5)
-#define APICDB1_PD_GETENCLOSURE_INFO		   (APICDB1_PD_GETHD_INFO + 6)
-#define APICDB1_PD_RESERVED2				   (APICDB1_PD_GETHD_INFO + 7)	// not used
-#define APICDB1_PD_GETSTATUS                   (APICDB1_PD_GETHD_INFO + 8)
-#define APICDB1_PD_GETHD_INFO_EXT              (APICDB1_PD_GETHD_INFO + 9)	// APICDB1_PD_GETHD_INFO extension
-#define APICDB1_PD_VERIFY_DISK                 (APICDB1_PD_GETHD_INFO + 10)
-#define APICDB1_PD_FORMATUNIT_DISK             (APICDB1_PD_GETHD_INFO + 11)
-#define APICDB1_PD_GET_PERCENTAGE              (APICDB1_PD_GETHD_INFO + 12)
-#define APICDB1_PD_FORCE_ONLINE				   (APICDB1_PD_GETHD_INFO + 13) // cdb[2] is did;  force disk online that be offlined by AES protection method.
-#define APICDB1_PD_MAX                         (APICDB1_PD_GETHD_INFO + 14)
-
-/* Sub command for APICDB1_PD_SETSETTING */
-#define APICDB4_PD_SET_WRITE_CACHE_OFF         0
-#define APICDB4_PD_SET_WRITE_CACHE_ON          1
-#define APICDB4_PD_SET_SMART_OFF               2
-#define APICDB4_PD_SET_SMART_ON                3
-#define APICDB4_PD_SMART_RETURN_STATUS         4
-#define APICDB4_PD_SET_SPEED_3G				   5
-#define APICDB4_PD_SET_SPEED_1_5G			   6
-
-/* for Block */
-#define APICDB1_BLOCK_GETINFO                  0
-#define APICDB1_BLOCK_HD_BLOCKIDS              (APICDB1_BLOCK_GETINFO + 1)
-#define APICDB1_BLOCK_MAX                      (APICDB1_BLOCK_GETINFO + 2)
-
-/* for event */
-#define APICDB1_EVENT_GETEVENT                 0
-#define APICDB1_HOST_GETEVENT                  1
-#define APICDB1_EVENT_MAX                      (APICDB1_HOST_GETEVENT + 1)
-
-/* for DBG */
-#define APICDB1_DBG_PDWR                       0
-#define APICDB1_DBG_MAP						   (APICDB1_DBG_PDWR + 1)
-#define APICDB1_DBG_LDWR					   (APICDB1_DBG_PDWR + 2)
-#define APICDB1_DBG_ADD_RCT_ENTRY			   (APICDB1_DBG_PDWR + 3)
-#define APICDB1_DBG_REMOVE_RCT_ENTRY		   (APICDB1_DBG_PDWR + 4)
-#define APICDB1_DBG_REMOVE_ALL_RCT			   (APICDB1_DBG_PDWR + 5)
-#define APICDB1_DBG_ADD_CORE_ERROR			   (APICDB1_DBG_PDWR + 6)
-#define APICDB1_DBG_REMOVE_CORE_ERROR		   (APICDB1_DBG_PDWR + 7)
-#define APICDB1_DBG_REMOVE_ALL_CORE_ERROR	   (APICDB1_DBG_PDWR + 8)
-#define APICDB1_DBG_GET_CORE_ERROR		       (APICDB1_DBG_PDWR + 9)
-#define APICDB1_DBG_MAX						   (APICDB1_DBG_PDWR + 10)
-
-#define DBG_REQUEST_READ						MV_BIT(0)
-#define DBG_REQUEST_WRITE						MV_BIT(1)
-#define DBG_REQUEST_VERIFY						MV_BIT(2)
-
-/* for FLASH */
-#define APICDB1_FLASH_BIN                      0
-#define APICDB1_ERASE_FLASH	                   (APICDB1_FLASH_BIN + 1)
-#define APICDB1_TEST_FLASH                     (APICDB1_FLASH_BIN + 2)
-#define APICDB1_BUFFER_DETAIL_FLASH            (APICDB1_FLASH_BIN + 3)
-#define APICDB1_FLASH_MAX                      (APICDB1_FLASH_BIN + 4)
-
-/* for AES */
-#define APICDB1_AES_INFO          		0
-#define APICDB1_AES_SET_LINK		    (APICDB1_AES_INFO + 1)
-#define APICDB1_AES_CLEAR_LINK          (APICDB1_AES_INFO + 2)
-#define APICDB1_AES_GETPORTCONFIG		(APICDB1_AES_INFO + 3)
-#define APICDB1_AES_SETPORTCONFIG		(APICDB1_AES_INFO + 4)
-#define APICDB1_AES_GETENTRYCONFIG		(APICDB1_AES_INFO + 5)
-#define APICDB1_AES_SETENTRYCONFIG		(APICDB1_AES_INFO + 6)
-#define APICDB1_AES_VERIFY_KEY          (APICDB1_AES_INFO + 7)
-#define APICDB1_AES_CHANGE_PASSWORD     (APICDB1_AES_INFO + 8)
-
-/* for passthru commands
-	Cdb[0]: APICDB0_PASS_THRU_CMD_SCSI or APICDB0_PASS_THRU_CMD_ATA
-	Cdb[1]: APICDB1 (Data flow)
-	Cdb[2]: TargetID MSB
-	Cdb[3]: TargetID LSB
-	Cdb[4]-Cdb[15]: SCSI/ATA command is embedded here
-		SCSI command: SCSI command Cdb bytes is in the same order as the spec
-		ATA Command:
-			Features = pReq->Cdb[0];
-			Sector_Count = pReq->Cdb[1];
-			LBA_Low = pReq->Cdb[2];
-			LBA_Mid = pReq->Cdb[3];
-			LBA_High = pReq->Cdb[4];
-			Device = pReq->Cdb[5];
-			Command = pReq->Cdb[6];
-
-			if necessary:
-			Feature_Exp = pReq->Cdb[7];
-			Sector_Count_Exp = pReq->Cdb[8];
-			LBA_Low_Exp = pReq->Cdb[9];
-			LBA_Mid_Exp = pReq->Cdb[10];
-			LBA_High_Exp = pReq->Cdb[11];
-*/
-#define APICDB0_PASS_THRU_CMD_SCSI			      0xFA
-#define APICDB0_PASS_THRU_CMD_ATA				  0xFB
-
-#define APICDB1_SCSI_NON_DATA					  0x00
-#define APICDB1_SCSI_PIO_IN					  0x01 // goes with Read Long
-#define APICDB1_SCSI_PIO_OUT					  0x02 // goes with Write Long
-
-#define APICDB1_ATA_NON_DATA					  0x00
-#define APICDB1_ATA_PIO_IN						  0x01
-#define APICDB1_ATA_PIO_OUT				         0x02
-
-#define API_SCSI_CMD_RCV_DIAG_RSLT			  0x1C
-#define API_SCSI_CMD_SND_DIAG					  0x1D
-
-#define API_GENERIC						0xD1
-#define APICDB0_PHY                          		(API_GENERIC + 1)
-#define APICDB0_I2C 						(API_GENERIC + 2)
-#define APICDB0_NVSRAM					(API_GENERIC + 3)
-#define APICDB0_SGPIO 					(API_GENERIC + 4)
-#define APICDB0_BUZZER 					(API_GENERIC + 5)
-#define APICDB0_LED						(API_GENERIC + 6)
-#define APICDB0_BIST					(API_GENERIC + 7)
-
-#define APICDB1_PHY       					 0
-#define APICDB1_PHY_TEST		    		 (APICDB1_PHY + 1)
-#define APICDB1_PHY_STATUS		    		 (APICDB1_PHY + 2)
-#define APICDB1_PHY_CONFIG                      (APICDB1_PHY + 3)
-
-#define APICDB1_SGPIO               			0
-#define APICDB1_SGPIO_TEST                  	(APICDB1_SGPIO + 1)
-
-#define APICDB1_BUZZER 					0
-#define APICDB1_BUZZER_OFF				(APICDB1_BUZZER + 1)
-#define APICDB1_BUZZER_ON				(APICDB1_BUZZER + 2)
-#define APICDB1_BUZZER_MUTE				(APICDB1_BUZZER + 3)
-
-#define APICDB1_LED						0
-#define APICDB1_LED_ACT_OFF			(APICDB1_LED + 1)
-#define APICDB1_LED_ACT_ON				(APICDB1_LED + 2)
-#define APICDB1_LED_FLT_OFF			(APICDB1_LED + 3)
-#define APICDB1_LED_FLT_ON				(APICDB1_LED + 4)
-
-#define APICDB1_BIST      					0
-#define APICDB1_BIST_TEST		    	 	(APICDB1_BIST + 1)
-
-#define APICDB2_SSD_INIT 				0xF0
-#define APICDB2_SSD_SAFECODE_MODE	(APICDB2_SSD_INIT + 1)
-#define APICDB2_SSD_DO_RESET			(APICDB2_SSD_INIT + 2)
-#define APICDB2_SSD_NORMAL_MODE		(APICDB2_SSD_INIT + 3)
-#define APICDB2_SSD_DETECT_PHY_READY (APICDB2_SSD_INIT + 4)
-
-#endif /*  __MV_COM_API_H__ */
--- a/drivers/scsi/vanir/include/icommon/com_diagnostic.h
+++ /dev/null
@@ -1,77 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_DIAGNOSTIC_H__
-#define __MV_COM_DIAGNOSTIC_H__
-#ifndef COM_DEFINE_H //for magni not use include com_define to define MV_U32
-#include "com_define.h"
-#endif
-
-typedef struct _SendDiaCDB
-{
-	MV_U8 OperationCode;
-	MV_U8 UnitOffL:1;
-	MV_U8 DevOffL:1;
-	MV_U8 SelfTest:1;
-	MV_U8 Reserved:1;
-	MV_U8 PF:1;
-	MV_U8 SelfTestCode:3;
-	MV_U8 Reserved2;
-	MV_U8 ParamLength[2];
-	MV_U8 Control;
-}SendDiaCDB;
-
-typedef struct _ReceiveDiaCDB
-{
-	MV_U8 OperationCode;
-	MV_U8 PCV:1;
-	MV_U8 Reserved:7;
-	MV_U8 PageCode;
-	MV_U8 AllocationLength[2];
-	MV_U8 Control;
-}ReceiveDiaCDB;
-
-typedef struct _DianosticPage
-{
-	MV_U8    PageCode;
-	MV_U8    PageCodeSpec;
-	MV_U8    PageLength[2];
-	MV_U8    Parameters[1];
-}DianosticPage, *PDianosticPage;
-
-#define MV_DIAGNOSTIC_CDB_LENGTH   12
-#define MV_DIANOSTICPAGE_NONE_DATA  0
-
-#define SCSI_CMD_RECEIVE_DIAGNOSTIC_RESULTS   0x1c  //spc3r23 p97
-#define SCSI_CMD_SEND_DIAGNOSTIC              0x1d  //spc3r23 p97
-
-typedef struct _MVATAPIDiagnosticParameters
-{
-	MV_U8    cdbOffset;
-	MV_U8    senseOffset;
-	MV_U8    dataOffset;
-	MV_U8	 reserved;
-	MV_U8    cdb[16];
-	MV_U8    senseBuffer[32];
-	MV_U32   dataLength;
-	MV_U8    Data[1];
-}MVATAPIDiagParas, *PMVATAPIDiagParas;
-
-#define MV_API_SEND_PAGE                      0xe0
-#define MV_API_RECEV_PAGE                     0xe1
-
-typedef MVATAPIDiagParas send_diagnostic_page;
-typedef DianosticPage diagnostic_page;
-typedef MVATAPIDiagParas recv_diagnostic_page;
-
-#endif
--- a/drivers/scsi/vanir/include/icommon/com_event_struct.h
+++ /dev/null
@@ -1,71 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef COM_EVENT_DRIVER_H
-#define COM_EVENT_DRIVER_H
-
-#ifndef COM_DEFINE_H //for magni not use include com_define to define MV_U32
-#include "com_define.h"
-#endif
-
-#define MAX_EVENTS                      20
-#define MAX_EVENTS_WAITED	  	16
-#define MAX_EVENT_PARAMS                4
-#define MAX_EVENTS_RETURNED             6
-#define MAX_EVENT_SENSE_DATA_COUNT	30
-
-#pragma pack(8)
-
-typedef struct _DriverEvent
-{
-	MV_U32  TimeStamp;
-	MV_U32  SequenceNo; /* (contiguous in a single adapter) */
-	MV_U32  EventID;    /* 1st 16 bits - Event class */
-                        /* last 16 bits - Event code of this particula Event class */
-	MV_U8   Severity;
-	MV_U8   AdapterID; /*For LokiPlus, the byte will use to check whether event is vaild or not. If yes, it will be added to systme event log.*/
-	MV_U16  DeviceID;   /* Device ID relate to the event class (HD ID, LD ID etc) */
-	MV_U32  Params[MAX_EVENT_PARAMS]; /* Additional information if ABSOLUTELY necessary. */
-} DriverEvent, * PDriverEvent;
-
-typedef struct _EventRequest
-{
-	MV_U8        Count; /* [OUT] # of actual events returned */
-	MV_U8        Reserved[3];
-	DriverEvent  Events[MAX_EVENTS_RETURNED];
-} EventRequest, * PEventRequest;
-
-// Event support sense code
-typedef struct _DriverEvent_V2
-{
-    DriverEvent  Event;                /* same as the current one */
-    MV_U8        SenseDataLength;      /* actual length of SenseData.  Driver set it to 0 if no SenseData */
-    MV_U8        accurated;
-    MV_U8        SenseData[30];        /* (24+6) just for making this structure on 64-bits boundary */
-} DriverEvent_V2, * PDriverEvent_V2;
-
-typedef struct _EventRequest_V2
-{
-    MV_U8           Count; /* [OUT] # of actual events returned */
-    MV_U8           Reserved[3];
-    DriverEvent_V2  Events[MAX_EVENTS_RETURNED];
-} EventRequest_V2, * PEventRequest_V2;
-
-
-#define EVENTL0G_HEAD_SIGNATURE                "TLEM"
-#define EVENTLOG_HEAD_RESERVED_BYTES      16
-#define EVENTLOG_ENTRY_VALID                        0x00000001L
-
-#pragma pack()
-
-#endif /*  COM_EVENT_DRIVER_H */
--- a/drivers/scsi/vanir/include/icommon/com_extern.h
+++ /dev/null
@@ -1,45 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef  __MV_COM_EXTERN_H__
-#define  __MV_COM_EXTERN_H__
-
-#include "com_define.h"
-/* Target device type */
-#define TARGET_TYPE_LD                          	0
-#define TARGET_TYPE_FREE_PD                 	1
-
-#define DISK_TYPE_RAID					0
-#define DISK_TYPE_SATA					1
-#define DISK_TYPE_SAS					2
-
-// Giving TargetID and LUN, returns it Type and DeviceID.  If returned Type or DeviceID is 0xFF, not found.
-typedef struct    _TargetLunType
-{
- MV_U8            AdapterID;
- MV_U8            TargetID;
- MV_U8            Lun;
- MV_U8            Type;            // TARGET_TYPE_LD or TARGET_TYPE_FREE_PD
- MV_U16           DeviceID;        // LD ID or PD ID depends on Type
- MV_U8            Reserved[34];
-}TargetLunType, * PTargetLunType;
-
-typedef struct	_OS_disk_info
-{
-	MV_U8 		ataper_id;	/* ataper disk locates */
-	MV_U8 		disk_type;	/* RAID disk, SATA disk or SAS disk */
-	MV_U16		device_id;	/* contain target id and lun */
-	MV_U16		queue_depth;	/* queue depth support this disk */
-}OS_disk_info, *POS_disk_info;
-
-#endif
--- a/drivers/scsi/vanir/include/icommon/com_flash.h
+++ /dev/null
@@ -1,36 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_FLASH_H__
-#define __MV_COM_FLASH_H__
-
-#include "com_define.h"
-#include "com_event_struct.h"
-
-#define DRIVER_LENGTH                      1024*16
-
-#pragma pack(8)
-
-typedef struct _Flash_DriverData
-{
-	MV_U16            Size;
-	MV_U8             PageNumber;
-	MV_BOOLEAN        isLastPage;
-	MV_U16            Reserved[2];
-	MV_U8             Data[DRIVER_LENGTH];
-}
-Flash_DriveData, *PFlash_DriveData;
-
-#pragma pack()
-
-#endif /* __MV_COM_FLASH_H__ */
--- a/drivers/scsi/vanir/include/icommon/com_ioctl.h
+++ /dev/null
@@ -1,94 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_COM_IOCTL_H__
-#define __MV_COM_IOCTL_H__
-
-/* private IOCTL commands */
-#define MV_IOCTL_CHECK_DRIVER                                \
-	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
-                     0x900, METHOD_BUFFERED,                 \
-                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)
-
-/*
- * MV_IOCTL_LEAVING_S0 is a notification when the system is going
- * to leaving S0. This gives the driver a chance to do some house
- * keeping work before system really going to sleep.
- *
- * The MV_IOCTL_LEAVING_S0 will be translated to APICDB0_ADAPTER/
- * APICDB1_ADAPTER_POWER_STATE_CHANGE and passed down along the
- * module stack. A module shall handle this request if necessary.
- *
- * Upon this request, usually the Cache module shall flush all
- * cached data. And the RAID module shall auto-pause all background
- * activities.
- */
-#define MV_IOCTL_LEAVING_S0                                \
-	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
-                     0x901, METHOD_BUFFERED,                 \
-                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)
-
-/*
- * MV_IOCTL_REENTER_S0 is a notification when the system is going
- * to re-entering S0. This gives the driver a chance to resume
- * something when system wakes up.
- *
- * The MV_IOCTL_REENTER_S0 will be translated to APICDB0_ADAPTER/
- * APICDB1_ADAPTER_POWER_STATE_CHANGE (CDB2 is 1) and passed down
- * along the module stack.
- * A module shall handle this request if necessary.
- */
-#define MV_IOCTL_REENTER_S0                                \
-	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
-                     0x902, METHOD_BUFFERED,                 \
-                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)
-
-/* Used for notifying shutdown from dispatch */
-#define MV_IOCTL_SHUTDOWN                               \
-	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
-                     0x903, METHOD_BUFFERED,                 \
-                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)
-// private ioctrl for scsi trim
-#define MV_IOCTL_TRIM_SCSI                               \
-	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
-                     0x905, METHOD_BUFFERED,                 \
-                     FILE_WRITE_ACCESS)
-
-/* IOCTL signature */
-#define MV_IOCTL_DRIVER_SIGNATURE                "mv61xxsg"
-#define MV_IOCTL_DRIVER_SIGNATURE_LENGTH         8
-
-/* IOCTL command status */
-#define IOCTL_STATUS_SUCCESS                     0
-#define IOCTL_STATUS_INVALID_REQUEST             1
-#define IOCTL_STATUS_ERROR                       2
-
-#define API_BLOCK_IOCTL_DEFAULT_FUN	0x1981
-#define API_IOCTL_DEFAULT_FUN			0x00
-#define API_IOCTL_GET_VIRTURL_ID		(API_IOCTL_DEFAULT_FUN + 1)
-#define API_IOCTL_GET_HBA_COUNT		(API_IOCTL_DEFAULT_FUN + 2)
-#define API_IOCTL_LOOKUP_DEV			(API_IOCTL_DEFAULT_FUN + 3)
-#define API_IOCTL_CHECK_VIRT_DEV           (API_IOCTL_DEFAULT_FUN + 4)
-#define API_IOCTL_GET_ENC_ID               	(API_IOCTL_DEFAULT_FUN + 5)
-#define API_IOCTL_MAX                      		(API_IOCTL_DEFAULT_FUN + 6)
-
-#pragma pack(8)
-
-typedef struct _MV_IOCTL_BUFFER
-{
-	MV_U8          Data_Buffer[32];
-} MV_IOCTL_BUFFER, *PMV_IOCTL_BUFFER;
-
-#pragma pack()
-
-#endif /* __MV_COM_IOCTL_H__ */
--- a/drivers/scsi/vanir/lib/common/com_nvram.c
+++ /dev/null
@@ -1,488 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_include.h"
-#include "core_header.h"
-#include "core_spi.h"
-#include "com_nvram.h"
-#include "hba_inter.h"
-#include "hba_exp.h"
-
-#define SERIAL_NUM_SIG  "MRVL"
-
-static void Itoa(MV_PU8 buffer, MV_U16 data)
-{
-	MV_U16 ndig;
-	MV_U8 char_hex;
-	MV_U16 tmp, tmp_hex;
-	MV_U16 ttchar;
-
-	tmp=data; ndig=1;
-
-    while(tmp/16>0){
-		ndig++;
-		tmp/=16;
-    }
-
-    tmp=data;
-    while(ndig){
-		ttchar = tmp%16;
-		switch(ttchar){
-			case 10:
-				buffer[ndig-1] = 'a';
-				break;
-			case 11:
-				buffer[ndig-1] = 'b';
-				break;
-			case 12:
-				buffer[ndig-1] =  'c';
-				break;
-			case 13:
-				buffer[ndig-1] = 'd';
-				break;
-			case 14:
-				buffer[ndig-1] = 'e';
-				break;
-			case 15:
-				buffer[ndig-1] = 'f';
-				break;
-			default:
-				buffer[ndig-1] = (MV_U8)ttchar + '0';
-		}
-		//buffer[ndig-1] = char_hex;
-        tmp/=16;
-		ndig--;
-    }
-}
-
-MV_BOOLEAN mv_nvram_moddesc_init_param( MV_PVOID This, pHBA_Info_Page pHBA_Info_Param)
-{
-	MV_U32 	param_flash_addr=PARAM_OFFSET,i = 0;
-       core_extension	*core;
-	AdapterInfo	AI;
-	MV_BOOLEAN is_pre_init = MV_TRUE;
-	MV_U32 time;
-	MV_U16 temp;
-	MV_U8 buffer[10];
-	struct mod_notif_param param_bad = {NULL, 0, 0, EVT_ID_FLASH_FLASH_ERR, 0,  SEVERITY_WARNING, 0,0,NULL,0 };
-	struct mod_notif_param param = {NULL, 0, 0, EVT_ID_FLASH_ERASE_ERR, 0,  SEVERITY_WARNING, 0,0,NULL,0};
-	Controller_Infor Controller;
-	PHBA_Extension phba_ext=NULL;
-
-	if (!This)
-		return MV_FALSE;
-
-	if(!is_pre_init){
-		phba_ext = (PHBA_Extension)HBA_GetModuleExtension(This, MODULE_HBA);
-	}
-
-       if (is_pre_init){
-		 mv_hba_get_controller_pre(This, &Controller);
-	} else {
-		HBA_GetControllerInfor(This, &Controller);
-	}
-
-	AI.bar[5] = Controller.Base_Address[5];
-	AI.bar[2] = Controller.Base_Address[2];
-
-	if (-1 == OdinSPI_Init(&AI)) {
-		MV_PRINT("Init flash rom failed.\n");
-		return MV_FALSE;
-	}
-
-	/* step 1 read param from flash offset = 0x3FFF00 */
-	OdinSPI_ReadBuf( &AI, param_flash_addr, (MV_PU8)pHBA_Info_Param, FLASH_PARAM_SIZE);
-
-	/* step 2 check the signature first */
-	if(pHBA_Info_Param->Signature[0] == 'M'&& \
-	    pHBA_Info_Param->Signature[1] == 'R'&& \
-	    pHBA_Info_Param->Signature[2] == 'V'&& \
-	    pHBA_Info_Param->Signature[3] == 'L' && \
-	    (!mvVerifyChecksum((MV_PU8)pHBA_Info_Param,FLASH_PARAM_SIZE)))
-	{
-		if(pHBA_Info_Param->HBA_Flag == 0xFFFFFFFFL)
-		{
-			pHBA_Info_Param->HBA_Flag = 0;
-			pHBA_Info_Param->HBA_Flag |= HBA_FLAG_INT13_ENABLE;
-			pHBA_Info_Param->HBA_Flag &= ~HBA_FLAG_SILENT_MODE_ENABLE;
-			pHBA_Info_Param->HBA_Flag &= ~HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY;
-			pHBA_Info_Param->HBA_Flag |= HBA_FLAG_AUTO_REBUILD_ON;
-			pHBA_Info_Param->HBA_Flag &= ~ HBA_FLAG_SMART_ON;
-		}
-
-		if(pHBA_Info_Param->BGA_Rate == 0xff)
-			pHBA_Info_Param->BGA_Rate = 0x7D;
-		if(pHBA_Info_Param->Sync_Rate == 0xff)
-			pHBA_Info_Param->Sync_Rate = 0x7D;
-		if(pHBA_Info_Param->Init_Rate == 0xff)
-			pHBA_Info_Param->Init_Rate = 0x7D;
-		if(pHBA_Info_Param->Rebuild_Rate == 0xff)
-			pHBA_Info_Param->Rebuild_Rate = 0x7D;
-
-		for(i=0;i<8;i++)
-		{
-			if(pHBA_Info_Param->PHY_Rate[i]>0x2)
-				pHBA_Info_Param->PHY_Rate[i] = 0x2; /*6Gbps*/
-		}
-	}
-	else
-	{
-		MV_FillMemory((MV_PVOID)pHBA_Info_Param, FLASH_PARAM_SIZE, 0xFF);
-		pHBA_Info_Param->Signature[0] = 'M';
-		pHBA_Info_Param->Signature[1] = 'R';
-		pHBA_Info_Param->Signature[2] = 'V';
-		pHBA_Info_Param->Signature[3] = 'L';
-
-		// Set BIOS Version
-		pHBA_Info_Param->Minor = NVRAM_DATA_MAJOR_VERSION;
-		pHBA_Info_Param->Major = NVRAM_DATA_MINOR_VERSION;
-
-		// Set SAS address
-		for(i=0;i<MAX_NUMBER_IO_CHIP*MAX_PORT_PER_PL;i++) {
-			pHBA_Info_Param->SAS_Address[i].b[0]=  0x50;
-			pHBA_Info_Param->SAS_Address[i].b[1]=  0x05;
-			pHBA_Info_Param->SAS_Address[i].b[2]=  0x04;
-			pHBA_Info_Param->SAS_Address[i].b[3]=  0x30;
-			pHBA_Info_Param->SAS_Address[i].b[4]=  0x11;
-			pHBA_Info_Param->SAS_Address[i].b[5]=  0xab;
-			pHBA_Info_Param->SAS_Address[i].b[6]=  (MV_U8)(i/4);
-			pHBA_Info_Param->SAS_Address[i].b[7]=  0x00;
-		}
-
-		/* init phy link rate */
-		for(i=0;i<8;i++)
-		{
-			pHBA_Info_Param->PHY_Rate[i] = 0x2; /*Default is 6Gbps*/
-		}
-
-		MV_PRINT("pHBA_Info_Param->HBA_Flag = 0x%x \n",pHBA_Info_Param->HBA_Flag);
-
-		pHBA_Info_Param->BGA_Rate = 0x7D;
-		pHBA_Info_Param->Rebuild_Rate = 0x7D;
-		pHBA_Info_Param->Init_Rate = 0x7D;
-		pHBA_Info_Param->Sync_Rate = 0x7D;
-
-		/* init setting flags */
-		pHBA_Info_Param->HBA_Flag = 0;
-		pHBA_Info_Param->HBA_Flag |= HBA_FLAG_INT13_ENABLE;
-		pHBA_Info_Param->HBA_Flag &= ~HBA_FLAG_SILENT_MODE_ENABLE;
-		pHBA_Info_Param->HBA_Flag &= ~HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY;
-		pHBA_Info_Param->HBA_Flag |= HBA_FLAG_AUTO_REBUILD_ON;
-		pHBA_Info_Param->HBA_Flag &= ~ HBA_FLAG_SMART_ON;
-
-		MV_DPRINT(("Add serial number.\n"));
-		MV_CopyMemory((MV_PU8)(pHBA_Info_Param->Serial_Num), SERIAL_NUM_SIG , 4);
-		temp = (MV_U16)(Controller.Device_Id);
-		MV_DPRINT(("%x.\n",Controller.Device_Id));
-		Itoa(buffer,temp);
-		MV_CopyMemory((MV_PU8)(&(pHBA_Info_Param->Serial_Num[4])),buffer,4);
-		time = HBA_GetMillisecondInDay();
-		temp = (MV_U16)time;
-		Itoa(buffer,temp);
-		MV_CopyMemory((MV_PU8)(&(pHBA_Info_Param->Serial_Num[8])),buffer, 4);
-		temp=(MV_U16)(time>>16);
-		Itoa(buffer,temp);
-		MV_CopyMemory((MV_PU8)(&(pHBA_Info_Param->Serial_Num[12])),buffer, 4);
-		time = HBA_GetTimeInSecond();
-		temp = (MV_U16)time;
-		Itoa(buffer,temp);
-		MV_CopyMemory((MV_PU8)(&(pHBA_Info_Param->Serial_Num[16])),buffer, 4);
-
-		/* set next page of HBA info Page*/
-		pHBA_Info_Param->Next_Page = (MV_U16)(PAGE_INTERVAL_DISTANCE+FLASH_PD_INFO_PAGE_SIZE);
-
-		/* write to flash and save it now */
-		if(OdinSPI_SectErase( &AI, param_flash_addr) != -1) {
-			MV_DPRINT(("mv_nvram_init_param: FLASH ERASE SUCCESS!\n"));
-		}
-		else {
-			MV_DPRINT(("mv_nvram_init_param: FLASH ERASE FAILED!\n"));
-			if(phba_ext) {
-			phba_ext->FlashErase = 1;
-			if(phba_ext->State == DRIVER_STATUS_STARTED)
-				HBA_ModuleNotification(phba_ext, EVENT_LOG_GENERATED,&param);
-			}
-		}
-
-		pHBA_Info_Param->Check_Sum = 0;
-		pHBA_Info_Param->Check_Sum=mvCalculateChecksum((MV_PU8)pHBA_Info_Param,sizeof(HBA_Info_Page))
-			;
-		/* init the parameter in ram */
-		if(OdinSPI_WriteBuf( &AI, param_flash_addr, (MV_PU8)pHBA_Info_Param, FLASH_PARAM_SIZE) != -1) {
-			MV_DPRINT(("mv_nvram_init_param: FLASH RECOVER SUCCESS!\n"));
-		}
-		else {
-			MV_DPRINT(("mv_nvram_init_param: FLASH RECOVER FAILED!\n"));
-			if(phba_ext) {
-			phba_ext->FlashBad = 1;
-			if(phba_ext->State == DRIVER_STATUS_STARTED)
-				HBA_ModuleNotification(phba_ext, EVENT_LOG_GENERATED,&param_bad);
-			}
-		}
-	}
-
-	return MV_TRUE;
-}
-
-MV_BOOLEAN mv_nvram_init_param( MV_PVOID _phba_ext, pHBA_Info_Page pHBA_Info_Param)
-{
-	MV_U32 	param_flash_addr=PARAM_OFFSET,i = 0;
-	AdapterInfo	AI;
-	PHBA_Extension phba_ext = ( PHBA_Extension )_phba_ext;
-	MV_U32 time;
-	MV_U16 temp;
-	MV_U8 buffer[10];
-	struct mod_notif_param param_bad = {NULL, 0, 0, EVT_ID_FLASH_FLASH_ERR, 0,  SEVERITY_WARNING, 0,0,NULL,0 };
-	struct mod_notif_param param = {NULL, 0, 0, EVT_ID_FLASH_ERASE_ERR, 0,  SEVERITY_WARNING, 0,0,NULL,0};
-	Controller_Infor Controller;
-
-	if ( !phba_ext   )
-		return MV_FALSE;
-
-	HBA_GetControllerInfor( phba_ext, &Controller);
-
-	AI.bar[5] = Controller.Base_Address[5];
-	AI.bar[2] = Controller.Base_Address[2];
-
-	if (-1 == OdinSPI_Init(&AI)) {
-		MV_PRINT("Init flash rom failed.\n");
-		return MV_FALSE;
-	}
-
-	/* step 1 read param from flash offset = 0x3FFF00 */
-	OdinSPI_ReadBuf( &AI, param_flash_addr, (MV_PU8)pHBA_Info_Param, FLASH_PARAM_SIZE);
-
-	/* step 2 check the signature first */
-	if(pHBA_Info_Param->Signature[0] == 'M'&& \
-	    pHBA_Info_Param->Signature[1] == 'R'&& \
-	    pHBA_Info_Param->Signature[2] == 'V'&& \
-	    pHBA_Info_Param->Signature[3] == 'L' && \
-	    (!mvVerifyChecksum((MV_PU8)pHBA_Info_Param,FLASH_PARAM_SIZE)))
-	{
-		if(pHBA_Info_Param->HBA_Flag == 0xFFFFFFFFL)
-		{
-			pHBA_Info_Param->HBA_Flag = 0;
-			pHBA_Info_Param->HBA_Flag |= HBA_FLAG_INT13_ENABLE;
-			pHBA_Info_Param->HBA_Flag &= ~HBA_FLAG_SILENT_MODE_ENABLE;
-			pHBA_Info_Param->HBA_Flag &= ~HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY;
-			pHBA_Info_Param->HBA_Flag |= HBA_FLAG_AUTO_REBUILD_ON;
-			pHBA_Info_Param->HBA_Flag &= ~ HBA_FLAG_SMART_ON;
-			pHBA_Info_Param->HBA_Flag |= HBA_FLAG_ENABLE_BUZZER;
-		}
-
-		if(pHBA_Info_Param->BGA_Rate == 0xff)
-			pHBA_Info_Param->BGA_Rate = 0x7D;
-		if(pHBA_Info_Param->Sync_Rate == 0xff)
-			pHBA_Info_Param->Sync_Rate = 0x7D;
-		if(pHBA_Info_Param->Init_Rate == 0xff)
-			pHBA_Info_Param->Init_Rate = 0x7D;
-		if(pHBA_Info_Param->Rebuild_Rate == 0xff)
-			pHBA_Info_Param->Rebuild_Rate = 0x7D;
-		for(i=0;i<8;i++)
-		{
-			if(pHBA_Info_Param->PHY_Rate[i] >= 0x2)
-				pHBA_Info_Param->PHY_Rate[i] = 0x2; /*6Gbps*/
-		}
-	}
-	else
-	{
-		MV_FillMemory((MV_PVOID)pHBA_Info_Param, FLASH_PARAM_SIZE, 0xFF);
-		pHBA_Info_Param->Signature[0] = 'M';
-		pHBA_Info_Param->Signature[1] = 'R';
-		pHBA_Info_Param->Signature[2] = 'V';
-		pHBA_Info_Param->Signature[3] = 'L';
-
-		// Set BIOS Version
-		pHBA_Info_Param->Minor = NVRAM_DATA_MAJOR_VERSION;
-		pHBA_Info_Param->Major = NVRAM_DATA_MINOR_VERSION;
-
-		// Set SAS address
-		for(i=0;i<MAX_NUMBER_IO_CHIP*MAX_PORT_PER_PL;i++) {
-			pHBA_Info_Param->SAS_Address[i].b[0]=  0x50;
-			pHBA_Info_Param->SAS_Address[i].b[1]=  0x05;
-			pHBA_Info_Param->SAS_Address[i].b[2]=  0x04;
-			pHBA_Info_Param->SAS_Address[i].b[3]=  0x30;
-			pHBA_Info_Param->SAS_Address[i].b[4]=  0x11;
-			pHBA_Info_Param->SAS_Address[i].b[5]=  0xab;
-			pHBA_Info_Param->SAS_Address[i].b[6]=  (MV_U8)(i/4);
-			pHBA_Info_Param->SAS_Address[i].b[7]=  0x00;
-		}
-
-		/* init phy link rate */
-		for(i=0;i<8;i++)
-		{
-			pHBA_Info_Param->PHY_Rate[i] = 0x2; /*Default is 6Gbps*/
-		}
-
-		MV_PRINT("pHBA_Info_Param->HBA_Flag = 0x%x \n",pHBA_Info_Param->HBA_Flag);
-
-		/* init bga rate */
-		pHBA_Info_Param->BGA_Rate = 0x7D;
-
-		pHBA_Info_Param->Rebuild_Rate = 0x7D;
-		pHBA_Info_Param->Init_Rate = 0x7D;
-		pHBA_Info_Param->Sync_Rate = 0x7D;
-
-		/* init setting flags */
-		pHBA_Info_Param->HBA_Flag = 0;
-		pHBA_Info_Param->HBA_Flag |= HBA_FLAG_INT13_ENABLE;
-		pHBA_Info_Param->HBA_Flag &= ~HBA_FLAG_SILENT_MODE_ENABLE;
-		pHBA_Info_Param->HBA_Flag &= ~HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY;
-		pHBA_Info_Param->HBA_Flag |= HBA_FLAG_AUTO_REBUILD_ON;
-		pHBA_Info_Param->HBA_Flag &= ~ HBA_FLAG_SMART_ON;
-		pHBA_Info_Param->HBA_Flag |= HBA_FLAG_ENABLE_BUZZER;
-
-		MV_DPRINT(("Add serial number.\n"));
-		MV_CopyMemory((MV_PU8)(pHBA_Info_Param->Serial_Num), SERIAL_NUM_SIG , 4);
-
-		temp = (MV_U16)(Controller.Device_Id);
-		MV_DPRINT(("%x.\n",Controller.Device_Id));
-
-		Itoa(buffer,temp);
-		MV_CopyMemory((MV_PU8)(&(pHBA_Info_Param->Serial_Num[4])),buffer,4);
-		time = HBA_GetMillisecondInDay();
-		temp = (MV_U16)time;
-		Itoa(buffer,temp);
-		MV_CopyMemory((MV_PU8)(&(pHBA_Info_Param->Serial_Num[8])),buffer, 4);
-		temp=(MV_U16)(time>>16);
-		Itoa(buffer,temp);
-		MV_CopyMemory((MV_PU8)(&(pHBA_Info_Param->Serial_Num[12])),buffer, 4);
-		time = HBA_GetTimeInSecond();
-		temp = (MV_U16)time;
-		Itoa(buffer,temp);
-		MV_CopyMemory((MV_PU8)(&(pHBA_Info_Param->Serial_Num[16])),buffer, 4);
-
-		/* set next page of HBA info Page*/
-		pHBA_Info_Param->Next_Page = (MV_U16)(PAGE_INTERVAL_DISTANCE+FLASH_PD_INFO_PAGE_SIZE);
-
-		/* write to flash and save it now */
-		if(OdinSPI_SectErase( &AI, param_flash_addr) != -1) {
-			MV_DPRINT(("mv_nvram_init_param: FLASH ERASE SUCCESS!\n"));
-		}
-		else {
-			MV_DPRINT(("mv_nvram_init_param: FLASH ERASE FAILED!\n"));
-			if(phba_ext) {
-			phba_ext->FlashErase = 1;
-			if(phba_ext->State == DRIVER_STATUS_STARTED)
-				HBA_ModuleNotification(phba_ext, EVENT_LOG_GENERATED,&param);
-			}
-		}
-
-		pHBA_Info_Param->Check_Sum = 0;
-		pHBA_Info_Param->Check_Sum=mvCalculateChecksum((MV_PU8)pHBA_Info_Param,sizeof(HBA_Info_Page));
-
-		/* init the parameter in ram */
-		if(OdinSPI_WriteBuf( &AI, param_flash_addr, (MV_PU8)pHBA_Info_Param, FLASH_PARAM_SIZE) != -1) {
-			MV_DPRINT(("mv_nvram_init_param: FLASH RECOVER SUCCESS!\n"));
-		}
-		else {
-			MV_DPRINT(("mv_nvram_init_param: FLASH RECOVER FAILED!\n"));
-			if(phba_ext) {
-			phba_ext->FlashBad = 1;
-			if(phba_ext->State == DRIVER_STATUS_STARTED)
-				HBA_ModuleNotification(phba_ext, EVENT_LOG_GENERATED,&param_bad);
-			}
-		}
-	}
-
-	return MV_TRUE;
-}
-/* Caution: Calling this function, please do Read-Modify-Write.
- * Please call to get the original data first, then modify corresponding field,
- * Then you can call this function. */
-MV_BOOLEAN mvuiHBA_modify_param( MV_PVOID This, pHBA_Info_Page pHBA_Info_Param)
-{
-       core_extension *p_core_ext;
-	MV_U32	param_flash_addr = PARAM_OFFSET;
-	AdapterInfo				AI;
-	PHBA_Extension	pHBA = NULL;
-
-	if (!This)
-		return MV_FALSE;
-
-	pHBA = (PHBA_Extension)HBA_GetModuleExtension(This,MODULE_HBA);
-
-	AI.bar[5] = pHBA->Base_Address[5];
-	AI.bar[2] = pHBA->Base_Address[2];
-	if (-1 == OdinSPI_Init(&AI))
-		return MV_FALSE;
-
-	if ( pHBA_Info_Param->Signature[0]!= 'M'
-		|| pHBA_Info_Param->Signature[1]!= 'R'
-		|| pHBA_Info_Param->Signature[2]!= 'V'
-		|| pHBA_Info_Param->Signature[3]!= 'L' ) {
-		MV_DASSERT( MV_FALSE );
-		return MV_FALSE;
-	}
-
-	p_core_ext = HBA_GetModuleExtension(This, MODULE_CORE);
-	if( p_core_ext == NULL )
-		return MV_FALSE;
-
-	pHBA_Info_Param->Check_Sum = 0;
-	pHBA_Info_Param->Check_Sum=mvCalculateChecksum((MV_PU8)pHBA_Info_Param,sizeof(HBA_Info_Page));
-
-        if (core_rmw_write_flash(p_core_ext, PARAM_OFFSET,
-                (MV_PU8)pHBA_Info_Param, sizeof(HBA_Info_Page)) == MV_FALSE) {
-	        if(OdinSPI_SectErase( &AI, param_flash_addr) != -1) {
-		        MV_DPRINT(("mvuiHBA_modify_param: FLASH ERASE SUCCESS!\n"));
-	        } else {
-		        MV_DPRINT(("mvuiHBA_modify_param: FLASH ERASE FAILED!\n"));
-                        MV_DASSERT(MV_FALSE);
-	        }
-                OdinSPI_WriteBuf(&AI, param_flash_addr, (MV_PU8)pHBA_Info_Param,
-                        sizeof(HBA_Info_Page));
-        }
-
-	return MV_TRUE;
-}
-
-
-MV_U8	mvCalculateChecksum(MV_PU8	Address, MV_U32 Size)
-{
-	MV_U8 checkSum;
-	MV_U32 temp=0;
-       checkSum = 0;
-       for (temp = 0 ; temp < Size ; temp ++)
-       {
-                checkSum += Address[temp];
-       }
-
-       checkSum = (~checkSum) + 1;
-
-	return	checkSum;
-}
-
-MV_U8	mvVerifyChecksum(MV_PU8	Address, MV_U32 Size)
-{
-	MV_U8	checkSum=0;
-	MV_U32 	temp=0;
-       for (temp = 0 ; temp < Size ; temp ++)
-       {
-            checkSum += Address[temp];
-       }
-
-	return	checkSum;
-}
-
-MV_BOOLEAN mv_page_signature_check( MV_PU8 Signature )
-{
-	if(	Signature[0] == 'M'&& \
-		Signature[1] == 'R'&& \
-		Signature[2] == 'V'&& \
-		Signature[3] == 'L')
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-
-}
--- a/drivers/scsi/vanir/lib/common/com_scsi.c
+++ /dev/null
@@ -1,75 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "com_type.h"
-#include "com_define.h"
-#include "com_dbg.h"
-#include "com_scsi.h"
-#include "com_util.h"
-
-/* NODRV device is used to send controller commands.
- * Now we are using "Storage array controller device" as Microsoft recommended.
- * Peripheral Device Type: 03h Processor ( can be 3h or 0ch )
- * Peripheral Qualifier: 0h
- * Response Data Format: 2h ( must be 2 )
- * Version: 4h ( must be 4, 5 or 6 )
- * Only need support minimum 36 bytes inquiry data.
- * Must return EVPD 0x0, 0x83, 0x80 */
-
-	/* If VIRTUAL_DEVICE_TYPE==0x10, Device ID is SCSI\BridgeMARVELL_Virtual_Device__
-	 * If VIRTUAL_DEVICE_TYPE==0x0C, Device ID is SCSI\ArrayMARVELL_Virtual_Device__
-	 * If VIRTUAL_DEVICE_TYPE==0x03, Device ID is SCSI\ProcessorMARVELL_Virtual_Device__ */
-	#define VIRTUAL_DEVICE_TYPE	0x0C
-	/* Standard Inquiry Data for Virtual Device */
-	MV_U8 BASEATTR MV_INQUIRY_VIRTUALD_DATA[] = {
-					VIRTUAL_DEVICE_TYPE,0x00,0x04,0x02,0x20,0x00,0x00,0x00,//?Version should be 0x4 instead of 0x2.
-					'M', 'A', 'R', 'V', 'E', 'L', 'L', ' ',
-					'V', 'i', 'r', 't', 'u', 'a', 'l', ' ',
-					'D', 'e', 'v', 'i', 'c', 'e', ' ', ' ',
-					0x31,0x2E,0x30,0x30
-					};
-
-	/* EVPD Inquiry Page for Virtual Device */
-	MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE0_VIRTUALD_DATA[] = {
-		VIRTUAL_DEVICE_TYPE, 0x00, 0x00, 0x03, 0x00, 0x80, 0x83};
-
-	MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE80_VIRTUALD_DATA[] = {
-		VIRTUAL_DEVICE_TYPE, 0x80, 0x00, 0x08, 'V', ' ', 'D', 'e', 'v', 'i', 'c', 'e'};
-
-	MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE83_VIRTUALD_DATA[] = {
-		VIRTUAL_DEVICE_TYPE, 0x83, 0x00, 0x14, 0x02, 0x01, 0x00, 0x10,
-		'M',  'A',  'R',  'V',  'E',  'L',  'L',  ' ',	/* T10 Vendor Identification */
-		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01	/* Vendor Specific Identifier */
-	};
-
-MV_VOID MV_SetSenseData(
-	IN PMV_Sense_Data pSense,
-	IN MV_U8 SenseKey,
-	IN MV_U8 AdditionalSenseCode,
-	IN MV_U8 ASCQ
-	)
-{
-	/* The caller should make sure it's a valid sense buffer. */
-	MV_DASSERT( pSense!=NULL );
-
-	if ( pSense!=NULL ) {
-		MV_ZeroMemory(pSense, sizeof(MV_Sense_Data));
-
-		pSense->Valid = 0;
-		pSense->ErrorCode = MV_SCSI_RESPONSE_CODE;
-		pSense->SenseKey = SenseKey;
-		pSense->AdditionalSenseCode = AdditionalSenseCode;
-		pSense->AdditionalSenseCodeQualifier = ASCQ;
-		pSense->AdditionalSenseLength = sizeof(MV_Sense_Data) - 8;
-	}
-}
--- a/drivers/scsi/vanir/lib/common/com_sgd.c
+++ /dev/null
@@ -1,851 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "com_type.h"
-#include "com_define.h"
-#include "com_sgd.h"
-#include "com_u64.h"
-#include "com_dbg.h"
-#include "com_util.h"
-#include "hba_exp.h"
-
-#if defined(_64BPLATFORM) || defined(_64_SYS_)
-#define USES_64B_POINTER
-#endif
-
-int sg_iter_walk(
-	IN sgd_t* sgd,
-	IN MV_U32 offset,
-	IN MV_U32 count,
-	IN sgd_visitor_t visitor,
-	IN MV_PVOID context
-	)
-{
-	sgd_t	sg[2];
-	int		sg_cnt = 0;
-	MV_U32	sz;
-
-	sgd_getsz(sgd,sz);
-	while( sz <= offset )
-	{
-		offset -= sz;
-		MV_ASSERT( !sgd_eot(sgd) );
-
-		sg_cnt++;
-		sgd_inc(sgd);
-		sgd_getsz(sgd,sz);
-	}
-
-	while(1)
-	{
-		if( sgd->flags & (SGD_REFTBL|SGD_REFSGD) )
-		{
-			MV_U32 copy_count = sz - offset;
-			MV_U32 offRef;
-			sgd_tbl_t* refSgdt;
-			sgd_t* refSgd;
-
-			sgd_get_reftbl(sgd,refSgdt);
-			if( sgd->flags & SGD_REFTBL )
-				refSgd = refSgdt->Entry_Ptr;
-			else
-				refSgd = (sgd_t*) refSgdt;
-
-			sgd_get_refoff(sgd,offRef);
-
-			if( copy_count > count )
-				copy_count = count;
-
-			if( !sg_iter_walk(
-				refSgd,
-				offRef + offset,
-				copy_count,
-				visitor,
-				context ) )
-				return 0;
-			count -= copy_count;
-		}
-		else if( sgd->flags & SGD_NEXT_TBL )
-		{
-			MV_ASSERT( MV_FALSE );
-		}
-		else
-		{
-			sgd_copy( sg, sgd );
-
-			if( offset )
-			{
-				sg[0].baseAddr = U64_ADD_U32(sg[0].baseAddr,offset);
-
-				if( sgd->flags & SGD_VP )
-				{
-					((sgd_vp_t*)sg)->u.vaddr = ((MV_U8*) ((sgd_vp_t*)sg)->u.vaddr) +
-						offset;
-				}
-
-				if (sgd->flags & SGD_PCTX) {
-					((sgd_pctx_t *)sg)->rsvd += offset;
-				}
-
-				sg[0].size -= offset;
-			}
-
-			if( sg[0].size > count )
-				sg[0].size = count;
-
-			if( !visitor( sg, context ) )
-			{
-				return 0;
-			}
-
-			count -= sg[0].size;
-		}
-
-		sg_cnt++;
-
-		if( sgd_eot(sgd)
-			|| count==0 )
-		{
-			if(count){
-				MV_DPRINT(("count = %x.\n",count));
-				sgd_dump(sgd,"Check sg:");
-				MV_DUMP_SP();
-			}
-			MV_ASSERT( count == 0 );
-			break;
-		}
-		offset = 0;
-		sgd_inc(sgd);
-		sgd_getsz(sgd,sz);
-	}
-
-	return sg_cnt;
-}
-
-int sgd_table_walk(
-	sgd_tbl_t*		sgdt,
-	sgd_visitor_t	visitor,
-	MV_PVOID		ctx
-	)
-{
-	return sg_iter_walk(
-		sgdt->Entry_Ptr,
-		0,
-		sgdt->Byte_Count,
-		visitor,
-		ctx );
-}
-
-void  sgd_iter_init(
-	sgd_iter_t*	iter,
-	sgd_t*		sgd,
-	MV_U32		offset,
-	MV_U32		count
-	)
-{
-	MV_U32	sz;
-
-	sgd_getsz(sgd,sz);
-	while( sz <= offset )
-	{
-		offset -= sz;
-		MV_ASSERT( !sgd_eot(sgd) );
-		sgd_inc(sgd);
-		sgd_getsz(sgd,sz);
-	}
-
-	iter->sgd = sgd;
-	iter->offset = offset;
-	iter->remainCnt = count;
-}
-
-int sgd_iter_get_next(
-	sgd_iter_t*	iter,
-	sgd_t*		sgd
-	)
-{
-	MV_U32	sz;
-
-	if( iter->remainCnt == 0 )
-		return 0;
-
-	sgd_getsz(iter->sgd,sz);
-	while( iter->offset >= sz )
-	{
-		if( sgd_eot(iter->sgd) )
-		{
-			iter->remainCnt = 0;
-			return 0;
-		}
-
-		iter->offset -= sz;
-		sgd_inc(iter->sgd);
-		sgd_getsz(iter->sgd,sz);
-	}
-again:
-	if( iter->sgd->flags & (SGD_REFTBL|SGD_REFSGD) )
-	{
-		sgd_iter_t	sub_iter;
-		sgd_t*		refSgd;
-		sgd_tbl_t*	refSgdt;
-		MV_U32		sub_cnt = sz - iter->offset;
-		MV_U32		offRef;
-
-		if( sub_cnt > iter->remainCnt )
-			sub_cnt = iter->remainCnt;
-
-		sgd_get_reftbl(iter->sgd,refSgdt);
-
-		if( iter->sgd->flags & SGD_REFTBL )
-			refSgd = refSgdt->Entry_Ptr;
-		else
-			refSgd = (sgd_t*) refSgdt;
-
-		sgd_get_refoff(iter->sgd,offRef);
-
-		sgd_iter_init(
-			&sub_iter,
-			refSgd,
-			offRef + iter->offset,
-			sub_cnt );
-
-		if( !sgd_iter_get_next( &sub_iter, sgd ) )
-		{
-			if( sgd_eot(iter->sgd) )
-			{
-				iter->remainCnt = 0;
-				return 0;
-			}
-			sgd_inc(iter->sgd);
-			iter->offset = 0;
-			goto again;
-		}
-		else if( sgd->flags & SGD_NEXT_TBL )
-		{
-			MV_ASSERT( MV_FALSE );
-		}
-		else
-		{
-			sgd_getsz(sgd,sz);
-			if( sz > iter->remainCnt )
-				sgd_setsz(sgd,iter->remainCnt);
-
-			iter->offset += sz;
-			iter->remainCnt -= sz;
-		}
-
-		return 1;
-	}
-	else
-	{
-		sgd_copy( sgd, iter->sgd );
-
-		sgd->baseAddr = U64_ADD_U32(sgd->baseAddr,iter->offset);
-
-		if( sgd->flags & SGD_VP )
-		{
-			((sgd_vp_t*)sgd)->u.vaddr = ((MV_U8*) ((sgd_vp_t*)sgd)->u.vaddr) +
-				iter->offset;
-		}
-
-		if (sgd->flags & SGD_PCTX) {
-			((sgd_pctx_t *)sgd)->rsvd += iter->offset;
-		}
-
-		sz -= iter->offset;
-		sgd_setsz( sgd, sz );
-	}
-
-	if( sz > iter->remainCnt )
-	{
-		sgd_setsz( sgd, iter->remainCnt );
-		sz = iter->remainCnt;
-	}
-
-	iter->remainCnt -= sz;
-
-	if( sgd_eot(iter->sgd)
-		|| iter->remainCnt == 0 )
-	{
-		iter->remainCnt = 0;
-		return 1;
-	}
-
-	iter->offset = 0;
-	sgd_inc(iter->sgd);
-
-	return 1;
-}
-
-void sgd_dump(sgd_t* sg, char* prefix)
-{
-	MV_U32	sz;
-
-	sgd_getsz(sg,sz);
-
-	if( prefix )
-	{
-		MV_PRINT(prefix);
-	}
-
-	if( sg->flags & SGD_VIRTUAL )
-	{
-		MV_PVOID vaddr, xctx;
-
-		sgd_get_vaddr(sg,vaddr);
-		sgd_get_xctx(sg,xctx);
-
-		MV_PRINT( "\tV %p T %p %08x F %08x\n"
-			, vaddr
-			, xctx
-			, sz
-			, sg->flags );
-	}
-	else if( sg->flags & (SGD_REFTBL|SGD_REFSGD) )
-	{
-		MV_PVOID ref;
-		MV_U32	refOff;
-
-		sgd_get_ref(sg,ref);
-		sgd_get_refoff(sg,refOff);
-
-		MV_PRINT( "\tR %p O %08x %08x F %08x\n"
-			, ref
-			, refOff
-			, sz
-			, sg->flags );
-	}
-	else if( sg->flags & SGD_NEXT_TBL )
-	{
-		MV_PVOID nexttbl;
-
-		sgd_get_nexttbl(sg, nexttbl);
-
-		MV_PRINT( "\tN %p F %08x\n"
-			, nexttbl, sg->flags );
-
-	}
-	else if( sg->flags & SGD_VP )
-	{
-		sgd_vp_t* vp = (sgd_vp_t*) sg;
-		MV_PRINT( "\tX %08x_%08x %p F %08x\n"
-			, vp->baseAddr.parts.high
-			, vp->baseAddr.parts.low
-			, vp->u.vaddr
-			, sg->flags );
-	}
-	else if( sg->flags & SGD_VWOXCTX )
-	{
-		sgd_v_t* vp = (sgd_v_t*) sg;
-
-		MV_PRINT( "\tV %p T %p %08x F %08x\n"
-			, vp->u.vaddr
-			, (MV_PVOID)0
-			, sz
-			, sg->flags );
-	}
-	else if( sg->flags & SGD_PCTX )
-	{
-		sgd_pctx_t* p = (sgd_pctx_t*) sg;
-		MV_PRINT( "\tP %08x_%08x %08x F %08x X %p\n"
-			, p->baseAddr.parts.high, p->baseAddr.parts.low, p->size, p->flags
-			, p->u.xctx );
-	}
-	else
-	{
-		MV_PRINT( "\tP %08x_%08x %08x F %08x\n"
-		, sg->baseAddr.parts.high, sg->baseAddr.parts.low, sz, sg->flags );
-	}
-}
-
-void sgdl_dump(sgd_t* sg, char* prefix )
-{
-	while(1)
-	{
-		sgd_dump(sg,prefix);
-
-		if( sg->flags & SGD_REFTBL )
-		{
-			sgd_tbl_t* tbl;
-			sgd_get_reftbl(sg,tbl);
-			sgdl_dump( tbl->Entry_Ptr, "R " );
-		}
-		else if( sg->flags & SGD_REFSGD )
-		{
-			sgd_t* refsgd;
-			sgd_get_refsgd(sg,refsgd);
-			sgdl_dump( refsgd, "R " );
-		}
-
-		if( sgd_eot(sg) )
-			break;
-		sgd_inc(sg);
-	}
-}
-
-
-void sgdt_dump(sgd_tbl_t *SgTbl, char* prefix)
-{
-	sgd_t* sg = SgTbl->Entry_Ptr;
-
-	MV_PRINT( "%s %p %u of %u 0x%x bytes\n"
-		, prefix ? prefix : " "
-		, SgTbl
-		, SgTbl->Valid_Entry_Count
-		, SgTbl->Max_Entry_Count
-		, SgTbl->Byte_Count
-		);
-
-	if( !SgTbl->Valid_Entry_Count )
-		return;
-
-	while(1)
-	{
-
-		sgd_dump(sg,NULL);
-		if( sgd_eot(sg) )
-			break;
-		sgd_inc(sg);
-	}
-}
-
-void sgdt_clear_eot(
-	sgd_tbl_t*	sgdt
-	)
-{
-	if( sgdt->Valid_Entry_Count )
-	{
-		sgd_t* sgd;
-		sgdt_get_lastsgd(sgdt,sgd);
-
-		sgd_clear_eot(sgd);
-	}
-}
-
-void sgdt_append(
-	sgd_tbl_t*	sgdt,
-	MV_U32		address,
-	MV_U32		addressHigh,
-	MV_U32		size
-	)
-{
-	sgd_t* pSGEntry = &sgdt->Entry_Ptr[sgdt->Valid_Entry_Count];
-
-	MV_ASSERT( sgdt->Valid_Entry_Count+1<=sgdt->Max_Entry_Count );
-
-	sgdt_clear_eot(sgdt);
-
-	sgdt->Valid_Entry_Count += 1;
-	sgdt->Byte_Count += size;
-
-	pSGEntry->flags = 0;
-	pSGEntry->baseAddr.parts.low = address;
-	pSGEntry->baseAddr.parts.high = addressHigh;
-	pSGEntry->size = size;
-
-	sgd_mark_eot(pSGEntry);
-}
-
-void sgdt_append_pctx(
-	sgd_tbl_t*	sgdt,
-	MV_U32		address,
-	MV_U32		addressHigh,
-	MV_U32		size,
-	MV_PVOID	xctx
-	)
-{
-	sgd_pctx_t* pSGEntry = (sgd_pctx_t*) &sgdt->Entry_Ptr[sgdt->Valid_Entry_Count];
-	if((sgdt->Valid_Entry_Count+2) > sgdt->Max_Entry_Count){
-		MV_DPRINT(("Not enough sg resource, valid entry count=%d, max entry count=%d.\n",sgdt->Valid_Entry_Count, sgdt->Max_Entry_Count));
-	}
-	MV_ASSERT( sgdt->Valid_Entry_Count+2<=sgdt->Max_Entry_Count );
-	sgdt_clear_eot(sgdt);
-
-	sgdt->Valid_Entry_Count += 2;
-	sgdt->Byte_Count += size;
-
-	pSGEntry->flags = SGD_PCTX | SGD_WIDE | SGD_EOT;
-	pSGEntry->baseAddr.parts.low = address;
-	pSGEntry->baseAddr.parts.high = addressHigh;
-	pSGEntry->size = size;
-	pSGEntry->u.xctx = xctx;
-	pSGEntry->flagsEx = SGD_X64;
-	pSGEntry->rsvd = 0;
-}
-
-void sgdt_append_sgd(
-	sgd_tbl_t*	sgdt,
-	sgd_t*		sgd
-	)
-{
-	sgd_t*	pSGEntry = &sgdt->Entry_Ptr[sgdt->Valid_Entry_Count];
-	MV_U8	cnt = 1;
-	MV_U32	sgdsz;
-
-	sgd_getsz(sgd,sgdsz);
-
-	if( sgd->flags & SGD_WIDE )
-		cnt++;
-
-	MV_ASSERT( sgdt->Valid_Entry_Count+cnt<=sgdt->Max_Entry_Count );
-
-	sgdt_clear_eot(sgdt);
-	sgdt->Valid_Entry_Count += cnt;
-	sgdt->Byte_Count += sgdsz;
-
-	MV_CopyMemory( pSGEntry, sgd, sizeof(sgd_t) * cnt );
-
-	sgd_mark_eot(pSGEntry);
-}
-
-static int sgdt_append_virtual_wo_xctx(
-	sgd_tbl_t* sgdt,
-	MV_PVOID virtual_address,
-	MV_U32 size
-	)
-{
-	sgd_t* sg = &sgdt->Entry_Ptr[sgdt->Valid_Entry_Count];
-	sgd_v_t* vsg = (sgd_v_t*) sg;
-
-	MV_ASSERT( sgdt->Valid_Entry_Count+1<=sgdt->Max_Entry_Count );
-
-	if( sgdt->Valid_Entry_Count + 1 > sgdt->Max_Entry_Count )
-		return -1;
-
-	sgdt_clear_eot(sgdt);
-
-	vsg->flags = SGD_EOT | SGD_VWOXCTX;
-	vsg->size = size;
-	vsg->u.vaddr = virtual_address;
-
-	sgdt->Valid_Entry_Count++;
-	sgdt->Byte_Count += size;
-
-	return 0;
-}
-
-int sgdt_append_virtual(
-	sgd_tbl_t* sgdt,
-	MV_PVOID virtual_address,
-	MV_PVOID translation_ctx,
-	MV_U32 size
-	)
-{
-	sgd_t* sg;
-#ifdef USES_64B_POINTER
-	sgd_v64_t* vsg;
-#else
-	sgd_v32_t* vsg;
-#endif
-
-	if( translation_ctx == 0 )
-		return sgdt_append_virtual_wo_xctx(sgdt,virtual_address,size);
-
-	sg = &sgdt->Entry_Ptr[sgdt->Valid_Entry_Count];
-
-#ifdef USES_64B_POINTER
-	vsg = (sgd_v64_t*) sg;
-
-	MV_ASSERT( sgdt->Valid_Entry_Count+2<=sgdt->Max_Entry_Count );
-
-	if( sgdt->Valid_Entry_Count + 2 > sgdt->Max_Entry_Count )
-		return -1;
-
-	sgdt_clear_eot(sgdt);
-
-	vsg->u1.vaddr = virtual_address;
-	vsg->u2.xctx = translation_ctx;
-	vsg->flags = SGD_WIDE | SGD_VIRTUAL | SGD_EOT;
-	vsg->flagsEx = SGD_X64;
-	sgdt->Valid_Entry_Count++;
-#else
-	vsg = (sgd_v32_t*) sg;
-
-	MV_ASSERT( sgdt->Valid_Entry_Count+1<=sgdt->Max_Entry_Count );
-
-	if( sgdt->Valid_Entry_Count + 1 > sgdt->Max_Entry_Count )
-		return -1;
-
-	sgdt_clear_eot(sgdt);
-
-	vsg->vaddr = virtual_address;
-	vsg->xctx = translation_ctx;
-	vsg->flags = SGD_VIRTUAL | SGD_EOT;
-#endif	// !USES_64B_POINTER
-
-	vsg->size = size;
-
-	sgdt->Valid_Entry_Count++;
-	sgdt->Byte_Count += size;
-
-	return 0;
-}
-
-int sgdt_append_vp(
-	sgd_tbl_t*	sgdt,
-	MV_PVOID	virtual_address,
-	MV_U32		size,
-	MV_U32		address,
-	MV_U32		addressHigh
-	)
-{
-	sgd_vp_t* sg = (sgd_vp_t*) &sgdt->Entry_Ptr[sgdt->Valid_Entry_Count];
-	if((sgdt->Valid_Entry_Count+2) > sgdt->Max_Entry_Count){
-		MV_DPRINT(("No enough sg resource, valid entry count=%d, max entry count=%d in sgdt_append_vp.\n",sgdt->Valid_Entry_Count, sgdt->Max_Entry_Count));
-	}
-	MV_ASSERT( sgdt->Valid_Entry_Count+2<=sgdt->Max_Entry_Count );
-
-	if( sgdt->Valid_Entry_Count + 2 > sgdt->Max_Entry_Count )
-		return -1;
-
-	sgdt_clear_eot(sgdt);
-
-	sg->baseAddr.parts.low = address;
-	sg->baseAddr.parts.high = addressHigh;
-	sg->flags = SGD_VP | SGD_WIDE | SGD_EOT;
-	sg->size = size;
-
-	sg->u.vaddr = virtual_address;
-	sg->flagsEx = SGD_X64;
-
-	sgdt->Valid_Entry_Count += 2;
-	sgdt->Byte_Count += size;
-
-	return 0;
-}
-
-int sgdt_append_ref(
-	sgd_tbl_t*	sgdt,
-	MV_PVOID	ref,
-	MV_U32		offset,
-	MV_U32		size,
-	MV_BOOLEAN	refTbl
-	)
-{
-	sgd_t* sg;
-
-	if( sgdt->Valid_Entry_Count )
-	{
-		sgdt_get_lastsgd(sgdt,sg);
-
-		if( sg->flags&(SGD_REFTBL|SGD_REFSGD) )
-		{
-			MV_PVOID lastRef;
-			MV_U32 lastOffset;
-
-			sgd_get_ref(sg, lastRef);
-			sgd_get_refoff(sg, lastOffset);
-
-			if( lastRef == ref
-				&& lastOffset + sg->size == offset )
-			{
-				sg->size += size;
-				sgdt->Byte_Count += size;
-				return 0;
-			}
-		}
-	}
-
-	sg = &sgdt->Entry_Ptr[sgdt->Valid_Entry_Count];
-
-	{
-
-#ifdef USES_64B_POINTER
-	sgd_ref64_t* rsg = (sgd_ref64_t*) sg;
-	if((sgdt->Valid_Entry_Count+2) > sgdt->Max_Entry_Count){
-		MV_DPRINT(("No enough sg resource, valid entry count=%d, max entry count=%d in sgdt_append_ref.\n",sgdt->Valid_Entry_Count, sgdt->Max_Entry_Count));
-	}
-	MV_ASSERT( sgdt->Valid_Entry_Count+2<=sgdt->Max_Entry_Count );
-	if( sgdt->Valid_Entry_Count + 2 > sgdt->Max_Entry_Count )
-		return -1;
-	sgdt_clear_eot(sgdt);
-	rsg->u.ref = ref;
-	sgdt->Valid_Entry_Count++;
-	rsg->flags = SGD_WIDE | SGD_EOT | (refTbl ? SGD_REFTBL : SGD_REFSGD);
-	rsg->flagsEx = SGD_X64;
-#else
-
-	sgd_ref32_t* rsg = (sgd_ref32_t*) sg;
-	if((sgdt->Valid_Entry_Count+1) > sgdt->Max_Entry_Count){
-		MV_DPRINT(("No enough sg resource, valid entry count=%d, max entry count=%d in sgdt_append_ref.\n",sgdt->Valid_Entry_Count, sgdt->Max_Entry_Count));
-	}
-	MV_ASSERT( sgdt->Valid_Entry_Count+1<=sgdt->Max_Entry_Count );
-	if( sgdt->Valid_Entry_Count + 1 > sgdt->Max_Entry_Count )
-		return -1;
-	sgdt_clear_eot(sgdt);
-	rsg->ref = ref;
-	rsg->flags = SGD_EOT | (refTbl ? SGD_REFTBL : SGD_REFSGD);
-#endif
-
-	rsg->offset = offset;
-	rsg->size = size;
-
-	sgdt->Valid_Entry_Count++;
-	sgdt->Byte_Count += size;
-
-	}
-
-	return 0;
-}
-
-
-void
-sgdt_copy_partial(
-	sgd_tbl_t* sgdt,
-	sgd_t**	ppsgd,
-	MV_PU32	poff,
-	MV_U32	size
-	)
-{
-	MV_U32	sgdsz;
-	MV_U32	tmpSize;
-	sgd_t	sgd[2];
-
-	while( size )
-	{
-		sgd_getsz( *ppsgd, sgdsz );
-		MV_ASSERT( sgdsz > *poff );
-
-		tmpSize = MV_MIN( size, sgdsz - *poff );
-
-		if( sgdt )
-		{
-			sgd_copy( sgd, *ppsgd );
-
-			sgd_setsz( sgd, tmpSize );
-
-			if( *poff )
-			{
-				if( sgd->flags & (SGD_REFTBL|SGD_REFSGD) )
-				{
-					MV_U32 refoff;
-					sgd_get_refoff( sgd, refoff );
-					sgd_set_refoff( sgd, refoff+(*poff) );
-				}
-				else
-				{
-					sgd->baseAddr = U64_ADD_U32( sgd->baseAddr, (*poff) );
-					if( sgd->flags & SGD_VP )
-					{
-						sgd_vp_t* vp = (sgd_vp_t*) sgd;
-						vp->u.vaddr = ((MV_U8*)vp->u.vaddr) + (*poff);
-					}
-
-					if (sgd->flags & SGD_PCTX) {
-						sgd_pctx_t *pctx =
-							(sgd_pctx_t *)sgd;
-						pctx->rsvd += (*poff);
-					}
-				}
-			}
-
-			sgdt_append_sgd( sgdt, sgd );
-
-		}
-
-		if( size == sgdsz - *poff
-			|| tmpSize == sgdsz - *poff )
-		{
-			sgd_inc( *ppsgd );
-			(*poff) = 0;
-		}
-		else
-			(*poff) += tmpSize;
-
-		size -= tmpSize;
-	}
-}
-
-typedef struct _PRDTableWalkCtx
-{
-	MV_PVOID		pCore;
-	MV_PVOID		pPrd_context;
-	int				itemCnt;
-	sgd_to_prd_fn		sg_to_prd_fn;
-} PRDTableWalkCtx;
-
-static int PRDTablePrepareVisitor(sgd_t* sg, MV_PVOID _ctx)
-{
-	PRDTableWalkCtx* ctx = (PRDTableWalkCtx*) _ctx;
-
-
-	if( sg->flags & (SGD_VIRTUAL|SGD_VWOXCTX) )
-	{
-		MV_U32 totalSize, thisSize;
-		MV_PVOID vaddr;
-		MV_PVOID xctx;
-		MV_U64 paddr;
-
-		MV_ASSERT( 0 );
-		sgd_getsz( sg, totalSize );
-
-		if( sg->flags & SGD_VIRTUAL )
-		{
-			sgd_get_vaddr( sg, vaddr );
-			sgd_get_xctx( sg, xctx );
-		}
-		else
-		{
-			vaddr = ((sgd_v_t*)sg)->u.vaddr;
-			xctx = 0;
-		}
-
-		while( 1 )
-		{
-			thisSize = totalSize;
-
-			if( !HBA_ModuleGetPhysicalAddress(
-					ctx->pCore,
-					vaddr,
-					xctx,
-					&paddr,
-					&thisSize ) )
-				return 0;
-
-			ctx->itemCnt++;
-			ctx->sg_to_prd_fn(ctx->pPrd_context, paddr,thisSize);
-
-			totalSize -= thisSize;
-			if( totalSize == 0 )
-				break;
-
-			vaddr = (MV_PVOID)((MV_PU8) vaddr + thisSize);
-		}
-	}
-	else
-	{
-		ctx->itemCnt++;
-		ctx->sg_to_prd_fn(ctx->pPrd_context, sg->baseAddr,sg->size);
-
-	}
-	return 1;
-}
-
-int sgdt_prepare_hwprd(
-	MV_PVOID		pCore,
-	sgd_tbl_t*		pSource,
-	MV_PVOID		prd_ctx,
-	sgd_to_prd_fn		prd_fn
-	)
-{
-	PRDTableWalkCtx ctx;
-
-	ctx.pCore = pCore;
-	ctx.pPrd_context = prd_ctx;
-	ctx.itemCnt = 0;
-	ctx.sg_to_prd_fn = prd_fn;
-	if( !sgd_table_walk( pSource, PRDTablePrepareVisitor, &ctx) )
-		return 0;
-
-	return ctx.itemCnt;
-}
--- a/drivers/scsi/vanir/lib/common/com_tag.c
+++ /dev/null
@@ -1,84 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "com_define.h"
-#include "com_tag.h"
-#include "com_dbg.h"
-
-MV_VOID Tag_Init( PTag_Stack pTagStack, MV_U16 size )
-{
-	MV_U16 i;
-
-	MV_DASSERT( size == pTagStack->Size );
-
-	pTagStack->Top = size;
-	pTagStack->TagStackType = FILO_TAG;
-	pTagStack->PtrOut = 0;
-	for ( i=0; i<size; i++ )
-	{
-		pTagStack->Stack[i] = size-1-i;
-	}
-}
-
-MV_VOID Tag_Init_FIFO( PTag_Stack pTagStack, MV_U16 size )
-{
-	MV_U16 i;
-
-	MV_DASSERT( size == pTagStack->Size );
-
-	pTagStack->Top = size;
-	pTagStack->TagStackType = FIFO_TAG;
-	pTagStack->PtrOut = 0;
-	for ( i=0; i<size; i++ )
-	{
-			pTagStack->Stack[i] = i;
-	}
-}
-
-MV_U16 Tag_GetOne(PTag_Stack pTagStack)
-{
-	MV_U16 nTag;
-
-	MV_DASSERT( pTagStack->Top>0 );
-	if(pTagStack->TagStackType==FIFO_TAG)
-	{
-		nTag = pTagStack->Stack[pTagStack->PtrOut++];
-		if(pTagStack->PtrOut>=pTagStack->Size)
-			pTagStack->PtrOut=0;
-		pTagStack->Top--;
-		return nTag;
-	}
-	else
-		return pTagStack->Stack[--pTagStack->Top];
-}
-
-MV_VOID Tag_ReleaseOne(PTag_Stack pTagStack, MV_U16 tag)
-{
-	MV_DASSERT( pTagStack->Top<pTagStack->Size );
-	if(pTagStack->TagStackType==FIFO_TAG)
-	{
-		pTagStack->Stack[(pTagStack->PtrOut+pTagStack->Top)%pTagStack->Size] = tag;
-		pTagStack->Top++;
-	}
-	else
-		pTagStack->Stack[pTagStack->Top++] = tag;
-}
-
-MV_BOOLEAN Tag_IsEmpty(PTag_Stack pTagStack)
-{
-	if ( pTagStack->Top==0 )
-	{
-		return MV_TRUE;
-	}
-	return MV_FALSE;
-}
--- a/drivers/scsi/vanir/lib/common/com_u64.c
+++ /dev/null
@@ -1,140 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "com_define.h"
-#include "com_dbg.h"
-#include "com_u64.h"
-
-MV_U64 U64_ADD_U32(MV_U64 v64, MV_U32 v32)
-{
-#ifdef _64_BIT_COMPILER
-	v64.value += v32;
-#else
-	v64.parts.low += v32;
-	v64.parts.high = 0;
-#endif
-	return v64;
-}
-
-MV_U64 U64_SUBTRACT_U32(MV_U64 v64, MV_U32 v32)
-{
-#ifdef _64_BIT_COMPILER
-	v64.value -= v32;
-#else
-	v64.parts.low -= v32;
-	v64.parts.high = 0;
-#endif
-	return v64;
-}
-
-MV_U64 U64_MULTIPLY_U32(MV_U64 v64, MV_U32 v32)
-{
-#ifdef _64_BIT_COMPILER
-	v64.value *= v32;
-#else
-	v64.parts.low *= v32;
-	v64.parts.high = 0;
-#endif
-	return v64;
-}
-
-MV_U32 U64_MOD_U32(MV_U64 v64, MV_U32 v32)
-{
-	if(v32)
-		return ossw_u64_mod(v64.value, v32);
-	else {
-		MV_DPRINT(("Warning: divisor is zero in %s.\n", __FUNCTION__));
-		return	0;
-	}
-}
-
-MV_U64 U64_DIVIDE_U32(MV_U64 v64, MV_U32 v32)
-{
-	if(v32)
-		v64.value = ossw_u64_div(v64.value, v32);
-	else {
-		MV_DPRINT(("Warning: divisor is zero in %s.\n", __FUNCTION__));
-		v64.value = 0;
-	}
-
-	return v64;
-}
-
-MV_I32 U64_COMPARE_U32(MV_U64 v64, MV_U32 v32)
-{
-	if (v64.parts.high > 0)
-		return 1;
-	if (v64.parts.low > v32)
-		return 1;
-#ifdef _64_BIT_COMPILER
-	else if (v64.value == v32)
-#else
-	else if (v64.parts.low == v32)
-#endif
-		return 0;
-	else
-		return -1;
-}
-
-MV_U64 U64_ADD_U64(MV_U64 v1, MV_U64 v2)
-{
-#ifdef _64_BIT_COMPILER
-	v1.value += v2.value;
-#else
-	v1.parts.low += v2.parts.low;
-	v1.parts.high = 0;
-#endif
-	return v1;
-}
-
-MV_U64 U64_SUBTRACT_U64(MV_U64 v1, MV_U64 v2)
-{
-#ifdef _64_BIT_COMPILER
-	v1.value -= v2.value;
-#else
-	v1.parts.low -= v2.parts.low;
-	v1.parts.high = 0;
-#endif
-	return v1;
-}
-
-MV_U32 U64_DIVIDE_U64(MV_U64 v1, MV_U64 v2)
-{
-	MV_U32 ret = 0;
-	while (v1.value > v2.value) {
-		v1.value -= v2.value;
-		ret++;
-	}
-	return ret;
-}
-
-MV_I32 U64_COMPARE_U64(MV_U64 v1, MV_U64 v2)
-{
-#ifdef _64_BIT_COMPILER
-	if (v1.value > v2.value)
-		return 1;
-	else if (v1.value == v2.value)
-		return 0;
-	else
-		return -1;
-#else
-	if (v1.value > v2.value)
-		return 1;
-	else if (v1.value == v2.value)
-		return 0;
-	else
-		return -1;
-
-#endif
-
-}
--- a/drivers/scsi/vanir/lib/common/com_util.c
+++ /dev/null
@@ -1,569 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "com_define.h"
-#include "com_dbg.h"
-#include "com_scsi.h"
-#include "com_util.h"
-#include "com_u64.h"
-#include "hba_exp.h"
-#include "com_extern.h"
-void MV_ZeroMvRequest(PMV_Request pReq)
-{
-	PMV_SG_Entry pSGEntry;
-	MV_U16 maxEntryCount;
-	MV_PVOID pSenseBuffer;
-	List_Head list;
-
-	MV_DASSERT(pReq);
-	pSGEntry = pReq->SG_Table.Entry_Ptr;
-	maxEntryCount = pReq->SG_Table.Max_Entry_Count;
-	pSenseBuffer = pReq->Sense_Info_Buffer;
-	list = pReq->pool_entry;
-
-	MV_ZeroMemory(pReq, MV_REQUEST_SIZE);
-	pReq->pool_entry = list;
-	pReq->SG_Table.Entry_Ptr = pSGEntry;
-	pReq->SG_Table.Max_Entry_Count = maxEntryCount;
-	pReq->Sense_Info_Buffer = pSenseBuffer;
-}
-
-void MV_CopySGTable(PMV_SG_Table pTargetSGTable, PMV_SG_Table pSourceSGTable)
-{
-	MV_ASSERT(pTargetSGTable->Max_Entry_Count >= pSourceSGTable->Valid_Entry_Count);
-	pTargetSGTable->Valid_Entry_Count = pSourceSGTable->Valid_Entry_Count;
-	pTargetSGTable->Occupy_Entry_Count = pSourceSGTable->Occupy_Entry_Count;
-	pTargetSGTable->Flag = pSourceSGTable->Flag;
-	pTargetSGTable->Byte_Count = pSourceSGTable->Byte_Count;
-	MV_CopyMemory(pTargetSGTable->Entry_Ptr, pSourceSGTable->Entry_Ptr,
-					sizeof(MV_SG_Entry)*pTargetSGTable->Valid_Entry_Count);
-}
-
-void MV_CopyPartialSGTable(
-	OUT PMV_SG_Table pTargetSGTable,
-	IN PMV_SG_Table pSourceSGTable,
-	IN MV_U32 offset,
-	IN MV_U32 size
-	)
-{
-	MV_U16  count = pTargetSGTable->Max_Entry_Count;
-	sgd_t *entry = pTargetSGTable->Entry_Ptr;
-
-	MV_DASSERT( (count>0) && (entry!=NULL) );
-	sgd_table_init( pTargetSGTable, count, entry);
-	sgdt_append_reftbl(pTargetSGTable, pSourceSGTable, offset, size);
-}
-
-MV_BOOLEAN MV_Equals(
-	IN MV_PU8		des,
-	IN MV_PU8		src,
-	IN MV_U32		len
-)
-{
-	MV_U32 i;
-
-	for (i=0; i<len; i++) {
-		if (*des != *src)
-			return MV_FALSE;
-		des++;
-		src++;
-	}
-	return MV_TRUE;
-}
-/*
- * SG Table operation
- */
-void SGTable_Init(
-	OUT PMV_SG_Table pSGTable,
-	IN MV_U8 flag
-	)
-{
-	pSGTable->Valid_Entry_Count = 0;
-	pSGTable->Flag = flag;
-	pSGTable->Byte_Count = 0;
-	pSGTable->Occupy_Entry_Count = 0;
-}
-
-void sgt_init(
-       IN MV_U16 max_io,
-	OUT PMV_SG_Table pSGTable,
-	IN MV_U8 flag
-	)
-{
-	if (max_io == 1)
-		pSGTable->Max_Entry_Count = MAX_SG_ENTRY_REDUCED;
-	else
-		pSGTable->Max_Entry_Count = MAX_SG_ENTRY;
-
-	pSGTable->Valid_Entry_Count = 0;
-	pSGTable->Flag = flag;
-	pSGTable->Byte_Count = 0;
-	pSGTable->Occupy_Entry_Count = 0;
-}
-
-MV_BOOLEAN SGTable_Available(
-	IN PMV_SG_Table pSGTable
-	)
-{
-	return (pSGTable->Valid_Entry_Count < pSGTable->Max_Entry_Count);
-}
-
-void MV_InitializeTargetIDTable(
-	IN PMV_Target_ID_Map pMapTable
-	)
-{
-	MV_FillMemory((MV_PVOID)pMapTable, sizeof(MV_Target_ID_Map)*MV_MAX_TARGET_NUMBER, 0xFF);
-}
-
-MV_U16 MV_GetTargetID(IN PMV_Target_ID_Map	pMapTable,IN MV_U8 deviceType)
-{
-	MV_U16 i;
-	for (i=PORT_NUMBER; i < MV_MAX_TARGET_NUMBER; i++) {
-
-		if ( (pMapTable[i].Type==0xff) && (pMapTable[i].Device_Id==0xffff) ) {
-			return i;
-		}
-	}
-	return 0xffff;
-}
-
-MV_U16 MV_MapTargetID(
-	IN PMV_Target_ID_Map	pMapTable,
-	IN MV_U16				deviceId,
-	IN MV_U8				deviceType
-	)
-{
-	MV_U16 i=0xffff;
-
-	if(deviceType==TARGET_TYPE_FREE_PD){
-		if (pMapTable[deviceId].Type==0xFF) {	/* not mapped yet */
-			pMapTable[deviceId].Device_Id = deviceId;
-			pMapTable[deviceId].Type = deviceType;
-
-		} else{
-			i=MV_GetTargetID(pMapTable,deviceType);
-
-			pMapTable[i].Device_Id = deviceId;
-			pMapTable[i].Type = deviceType;
-			deviceId=i;
-		}
-		i=deviceId;
-	}else if(deviceType==TARGET_TYPE_LD){
-			for (i=PORT_NUMBER; i<MV_MAX_TARGET_NUMBER; i++) {
-				if (pMapTable[i].Type==0xFF) {	/* not mapped yet */
-					pMapTable[i].Device_Id = deviceId;
-					pMapTable[i].Type = deviceType;
-					break;
-					}
-			}
-	}
-
-	return i;
-}
-
-MV_U16 MV_MapToSpecificTargetID(
-	IN PMV_Target_ID_Map	pMapTable,
-	IN MV_U16				specificId,
-	IN MV_U16				deviceId,
-	IN MV_U8				deviceType
-	)
-{
-	/* first check if the device can be mapped to the specific ID */
-	if (specificId < MV_MAX_TARGET_NUMBER) {
-		if (pMapTable[specificId].Type==0xFF) {	/* not used yet */
-			pMapTable[specificId].Device_Id = deviceId;
-			pMapTable[specificId].Type = deviceType;
-			return specificId;
-		}
-	}
-	/* cannot mapped to the specific ID */
-	/* just map the device to first available ID */
-	return MV_MapTargetID(pMapTable, deviceId, deviceType);
-}
-
-MV_U16 MV_RemoveTargetID(
-	IN PMV_Target_ID_Map	pMapTable,
-	IN MV_U16				deviceId,
-	IN MV_U8				deviceType
-	)
-{
-	MV_U16 i;
-	for (i=0; i < MV_MAX_TARGET_NUMBER; i++) {
-		if ( (pMapTable[i].Type==deviceType) && (pMapTable[i].Device_Id==deviceId) ) {
-			pMapTable[i].Type = 0xFF;
-			pMapTable[i].Device_Id = 0xFFFF;
-			break;
-		}
-	}
-	if (i == MV_MAX_TARGET_NUMBER)
-		i = 0xFFFF;
-	return i;
-}
-
-MV_U16 MV_GetMappedID(
-	IN PMV_Target_ID_Map	pMapTable,
-	IN MV_U16				deviceId,
-	IN MV_U8				deviceType
-	)
-{
-	MV_U16 mappedID;
-
-	for (mappedID=0; mappedID<MV_MAX_TARGET_NUMBER; mappedID++) {
-		if ( (pMapTable[mappedID].Type==deviceType) && (pMapTable[mappedID].Device_Id==deviceId) ){
-			break;
-			}
-
-	}
-	if (mappedID >= MV_MAX_TARGET_NUMBER)
-		mappedID = 0xFFFF;
-	else {
-		MV_DASSERT(mappedID < MV_MAX_TARGET_NUMBER);
-		if (mappedID == VIRTUAL_DEVICE_ID) {
-			/* Device is on LUN 1 */
-			mappedID |= 0x0100;
-		}
-	}
-	return mappedID;
-}
-
-void MV_DecodeReadWriteCDB(
-	IN MV_PU8 Cdb,
-	OUT MV_LBA *pLBA,
-	OUT MV_U32 *pSectorCount)
-{
-	MV_LBA tmpLBA;
-	MV_U32 tmpSectorCount;
-
-	if ((!SCSI_IS_READ(Cdb[0])) &&
-	    (!SCSI_IS_WRITE(Cdb[0])) &&
-	    (!SCSI_IS_VERIFY(Cdb[0])))
-		return;
-
-	/* This is READ/WRITE command */
-	switch (Cdb[0]) {
-	case SCSI_CMD_READ_6:
-	case SCSI_CMD_WRITE_6:
-		tmpLBA.value = (MV_U32)((((MV_U32)(Cdb[1] & 0x1F))<<16) |
-					((MV_U32)Cdb[2]<<8) |
-					((MV_U32)Cdb[3]));
-		tmpSectorCount = (MV_U32)Cdb[4];
-		break;
-	case SCSI_CMD_READ_10:
-	case SCSI_CMD_WRITE_10:
-	case SCSI_CMD_VERIFY_10:
-		tmpLBA.value = (MV_U32)(((MV_U32)Cdb[2]<<24) |
-					((MV_U32)Cdb[3]<<16) |
-					((MV_U32)Cdb[4]<<8) |
-					((MV_U32)Cdb[5]));
-		tmpSectorCount = ((MV_U32)Cdb[7]<<8) | (MV_U32)Cdb[8];
-		break;
-	case SCSI_CMD_READ_12:
-	case SCSI_CMD_WRITE_12:
-		tmpLBA.value = (MV_U32)(((MV_U32)Cdb[2]<<24) |
-					((MV_U32)Cdb[3]<<16) |
-					((MV_U32)Cdb[4]<<8) |
-					((MV_U32)Cdb[5]));
-		tmpSectorCount = (MV_U32)(((MV_U32)Cdb[6]<<24) |
-					  ((MV_U32)Cdb[7]<<16) |
-					  ((MV_U32)Cdb[8]<<8) |
-					  ((MV_U32)Cdb[9]));
-		break;
-	case SCSI_CMD_READ_16:
-	case SCSI_CMD_WRITE_16:
-	case SCSI_CMD_VERIFY_16:
-		tmpLBA.parts.high = (MV_U32)(((MV_U32)Cdb[2]<<24) |
-				       ((MV_U32)Cdb[3]<<16) |
-				       ((MV_U32)Cdb[4]<<8) |
-				       ((MV_U32)Cdb[5]));
-		tmpLBA.parts.low = (MV_U32)(((MV_U32)Cdb[6]<<24) |
-				      ((MV_U32)Cdb[7]<<16) |
-				      ((MV_U32)Cdb[8]<<8) |
-				      ((MV_U32)Cdb[9]));
-
-		tmpSectorCount = (MV_U32)(((MV_U32)Cdb[10]<<24) |
-					  ((MV_U32)Cdb[11]<<16) |
-					  ((MV_U32)Cdb[12]<<8) |
-					  ((MV_U32)Cdb[13]));
-		break;
-	default:
-		MV_DPRINT(("Unsupported READ/WRITE command [%x]\n", Cdb[0]));
-		U64_SET_VALUE(tmpLBA, 0);
-		tmpSectorCount = 0;
-	}
-	*pLBA = tmpLBA;
-	*pSectorCount = tmpSectorCount;
-}
-
-void MV_CodeReadWriteCDB(
-	OUT MV_PU8	Cdb,
-	IN MV_LBA	lba,
-	IN MV_U32	sector,
-	IN MV_U8	operationCode	/* The CDB[0] */
-	)
-{
-	MV_DASSERT(
-		SCSI_IS_READ(operationCode)
-		|| SCSI_IS_WRITE(operationCode)
-		|| SCSI_IS_VERIFY(operationCode)
-		);
-
-	MV_ZeroMemory(Cdb, MAX_CDB_SIZE);
-	Cdb[0] = operationCode;
-
-	/* This is READ/WRITE command */
-	switch ( Cdb[0]) {
-	case SCSI_CMD_READ_6:
-	case SCSI_CMD_WRITE_6:
-		Cdb[1] = (MV_U8)(lba.value>>16);
-		Cdb[2] = (MV_U8)(lba.value>>8);
-		Cdb[3] = (MV_U8)lba.value;
-		Cdb[4] = (MV_U8)sector;
-		break;
-	case SCSI_CMD_READ_10:
-	case SCSI_CMD_WRITE_10:
-	case SCSI_CMD_VERIFY_10:
-		Cdb[2] = (MV_U8)(lba.value>>24);
-		Cdb[3] = (MV_U8)(lba.value>>16);
-		Cdb[4] = (MV_U8)(lba.value>>8);
-		Cdb[5] = (MV_U8)lba.value;
-		Cdb[7] = (MV_U8)(sector>>8);
-		Cdb[8] = (MV_U8)sector;
-		break;
-	case SCSI_CMD_READ_12:
-	case SCSI_CMD_WRITE_12:
-		Cdb[2] = (MV_U8)(lba.value>>24);
-		Cdb[3] = (MV_U8)(lba.value>>16);
-		Cdb[4] = (MV_U8)(lba.value>>8);
-		Cdb[5] = (MV_U8)lba.value;
-		Cdb[6] = (MV_U8)(sector>>24);
-		Cdb[7] = (MV_U8)(sector>>16);
-		Cdb[8] = (MV_U8)(sector>>8);
-		Cdb[9] = (MV_U8)sector;
-		break;
-	case SCSI_CMD_READ_16:
-	case SCSI_CMD_WRITE_16:
-	case SCSI_CMD_VERIFY_16:
-		Cdb[2] = (MV_U8)(lba.parts.high>>24);
-		Cdb[3] = (MV_U8)(lba.parts.high>>16);
-		Cdb[4] = (MV_U8)(lba.parts.high>>8);
-		Cdb[5] = (MV_U8)lba.parts.high;
-		Cdb[6] = (MV_U8)(lba.parts.low>>24);
-		Cdb[7] = (MV_U8)(lba.parts.low>>16);
-		Cdb[8] = (MV_U8)(lba.parts.low>>8);
-		Cdb[9] = (MV_U8)lba.parts.low;
-		Cdb[10] = (MV_U8)(sector>>24);
-		Cdb[11] = (MV_U8)(sector>>16);
-		Cdb[12] = (MV_U8)(sector>>8);
-		Cdb[13] = (MV_U8)sector;
-		break;
-	default:
-		MV_DPRINT(("Unsupported READ/WRITE command [%x]\n", Cdb[0]));
-		MV_ASSERT(0);
-	}
-}
-
-void MV_DumpRequest(PMV_Request pReq, MV_BOOLEAN detail)
-{
-	MV_DPRINT(("Device %d MV_Request: Cdb[%02x,%02x,%02x,%02x, %02x,%02x,%02x,%02x, %02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x].\n",
-		pReq->Device_Id,
-		pReq->Cdb[0],
-		pReq->Cdb[1],
-		pReq->Cdb[2],
-		pReq->Cdb[3],
-		pReq->Cdb[4],
-		pReq->Cdb[5],
-		pReq->Cdb[6],
-		pReq->Cdb[7],
-		pReq->Cdb[8],
-		pReq->Cdb[9],
-		pReq->Cdb[10],
-		pReq->Cdb[11],
-		pReq->Cdb[12],
-		pReq->Cdb[13],
-		pReq->Cdb[14],
-		pReq->Cdb[15]
-		));
-
-	if (detail) {
-		MV_DPRINT(("Req Flag=0x%x\n", pReq->Cmd_Flag));
-		MV_DPRINT(("Scsi_Status=0x%x\n", pReq->Scsi_Status));
-		MV_DPRINT(("Tag=0x%x\n", pReq->Tag));
-		MV_DPRINT(("Data_Transfer_Length=0x%x\n", pReq->Data_Transfer_Length));
-		MV_DPRINT(("Sense_Info_Buffer_Length=%d\n", pReq->Sense_Info_Buffer_Length));
-		MV_DPRINT(("Org_Req : %p\n", pReq->Org_Req));
-	}
-}
-
-void MV_DumpSGTable(PMV_SG_Table pSGTable)
-{
-	sgdt_dump(pSGTable, " ");
-}
-
-const char* MV_DumpSenseKey(MV_U8 sense)
-{
-	switch ( sense )
-	{
-		case SCSI_SK_NO_SENSE:
-			return "SCSI_SK_NO_SENSE";
-		case SCSI_SK_RECOVERED_ERROR:
-			return "SCSI_SK_RECOVERED_ERROR";
-		case SCSI_SK_NOT_READY:
-			return "SCSI_SK_NOT_READY";
-		case SCSI_SK_MEDIUM_ERROR:
-			return "SCSI_SK_MEDIUM_ERROR";
-		case SCSI_SK_HARDWARE_ERROR:
-			return "SCSI_SK_HARDWARE_ERROR";
-		case SCSI_SK_ILLEGAL_REQUEST:
-			return "SCSI_SK_ILLEGAL_REQUEST";
-		case SCSI_SK_UNIT_ATTENTION:
-			return "SCSI_SK_UNIT_ATTENTION";
-		case SCSI_SK_DATA_PROTECT:
-			return "SCSI_SK_DATA_PROTECT";
-		case SCSI_SK_BLANK_CHECK:
-			return "SCSI_SK_BLANK_CHECK";
-		case SCSI_SK_VENDOR_SPECIFIC:
-			return "SCSI_SK_VENDOR_SPECIFIC";
-		case SCSI_SK_COPY_ABORTED:
-			return "SCSI_SK_COPY_ABORTED";
-		case SCSI_SK_ABORTED_COMMAND:
-			return "SCSI_SK_ABORTED_COMMAND";
-		case SCSI_SK_VOLUME_OVERFLOW:
-			return "SCSI_SK_VOLUME_OVERFLOW";
-		case SCSI_SK_MISCOMPARE:
-			return "SCSI_SK_MISCOMPARE";
-		default:
-			MV_DPRINT(("Unknown sense key 0x%x.\n", sense));
-			return "Unknown sense key";
-	}
-}
-
-static MV_U32  BASEATTR crc_tab[] = {
-        0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
-        0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
-        0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
-        0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
-        0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
-        0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
-        0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
-        0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
-        0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
-        0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
-        0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
-        0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
-        0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
-        0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
-        0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
-        0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
-        0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
-        0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
-        0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
-        0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
-        0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
-        0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
-        0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
-        0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
-        0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
-        0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
-        0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
-        0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
-        0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
-        0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
-        0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
-        0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
-        0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
-        0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
-        0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
-        0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
-        0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
-        0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
-        0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
-        0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
-        0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
-        0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
-        0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
-        0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
-        0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
-        0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
-        0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
-        0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
-        0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
-        0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
-        0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
-        0x2d02ef8dL
-};
-
-/* Calculate CRC and generate PD_Reference number */
-MV_U32 MV_CRC(
-	IN	MV_PU8		pData,
-	IN	MV_U16		len
-)
-{
-	MV_U16 i;
-	MV_U32 crc = MV_MAX_U32;
-
-	for (i = 0;  i < len;  i ++) {
-		crc = crc_tab[(crc ^ pData[i]) & 0xff] ^ (crc >> 8);
-	}
-	return MV_CPU_TO_BE32(crc);
-}
-
-MV_U32 MV_CRC_EXT(
-	IN	MV_U32		crc,
-	IN	MV_PU8		pData,
-	IN	MV_U32		len
-)
-{
-	MV_U16 i;
-
-	for (i = 0;  i < len;  i ++) {
-		crc = crc_tab[(crc ^ pData[i]) & 0xff] ^ (crc >> 8);
-	}
-	return crc;
-}
-
-MV_VOID init_target_id_map(MV_U16 *map_table, MV_U32 size)
-{
-	MV_FillMemory(map_table, size, 0xFFFF);
-}
-
-MV_U16 get_available_target_id(MV_U16 *map_table, MV_U16 id)
-{
-	MV_U16 i;
-
-	for (i=0; i<id; i++) {
-		if (map_table[i] == 0xffff)
-			return i;
-	}
-	return id;
-
-}
-MV_U16 add_target_map(MV_U16 *map_table, MV_U16 device_id,MV_U16 max_id)
-{
-	MV_U16 target_id;
-
-	target_id=device_id;
-	if(target_id >= max_id)
-		return 0xFFFF;
-	map_table[target_id] = device_id;
-
-	return target_id;
-}
-
-MV_U16 remove_target_map(MV_U16 *map_table, MV_U16 target_id, MV_U16 max_id)
-{
-	if((target_id != 0xFFFF) && (target_id >= max_id))
-		return target_id;
-	MV_FillMemory(&map_table[target_id], sizeof(MV_U16), 0xFFFF);
-	return target_id;
-
-}
--- a/drivers/scsi/vanir/linux/hba_exp.c
+++ /dev/null
@@ -1,817 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "linux_main.h"
-#include "hba_mod.h"
-#include "linux_iface.h"
-#include "hba_timer.h"
-#include "hba_api.h"
-
-/*
- *
- * Other exposed functions
- *
- */
-
-MV_U32 MV_PCI_READ_DWORD(MV_PVOID This, MV_U8 reg)
-{
-	MV_U32 v;
-	PHBA_Extension p_hba = (PHBA_Extension)HBA_GetModuleExtension(This,MODULE_HBA);
-	MV_ASSERT( p_hba != NULL );
-	MV_PCI_READ_CONFIG_DWORD(p_hba, reg, &v);
-	return v;
-}
-
-MV_VOID  MV_PCI_WRITE_DWORD(MV_PVOID This, MV_U32 val, MV_U8 reg)
-{
-	PHBA_Extension p_hba = (PHBA_Extension)HBA_GetModuleExtension(This,MODULE_HBA);
-	MV_ASSERT( p_hba != NULL );
-	MV_PCI_WRITE_CONFIG_DWORD(p_hba, reg, val);
-	return;
-}
-
-/*
- * The extension is the calling module extension.
- *   It can be any module extension.
- */
-void HBA_ModuleStarted(MV_PVOID extension)
-{
-	struct mv_mod_desc *mod_desc = __ext_to_gen(extension)->desc;
-	struct hba_extension *hba;
-	struct mv_mod_desc *desc;
-	struct mv_adp_desc *hba_desc;
-	MV_DPRINT(( "start HBA_ModuleStarted addr %p, id %d.\n",mod_desc, mod_desc->module_id));
-	mod_desc->status = MV_MOD_STARTED;
-	desc = mod_desc;
-	while (desc->parent)
-		desc = desc->parent;
-	hba = (struct hba_extension *) desc->extension;
-	hba_desc = hba->desc->hba_desc;
-	if (__mv_is_mod_all_started(desc->hba_desc)) {
-		MV_DPRINT(( "all modules have been started.\n"));
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-		atomic_set(&hba_desc->hba_sync, 0);
-#else
-		complete(&hba_desc->cmpl);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
-		hba->State = DRIVER_STATUS_STARTED;
-		hba->desc->ops->module_notification(hba,
-						    EVENT_MODULE_ALL_STARTED,
-						    NULL);
-	} else {
-		if (mod_desc->parent && mod_desc->parent->parent)
-		{
-			MV_DPRINT(("start module %d.....\n",mod_desc->parent->module_id));
-			mod_desc->parent->ops->module_start(mod_desc->parent->extension);
-		}
-	}
-
-}
-
-void hba_map_sg_to_buffer(void *preq)
-{
-	struct scsi_cmnd *scmd =NULL;
-	struct scatterlist *sg =NULL;
-	PMV_Request        req =NULL;
-	void * virt_address;
-	unsigned long flags = 0;
-	unsigned int i = 0;
-
-	req  = (PMV_Request) preq;
-
-	if (REQ_TYPE_OS != req->Req_Type)
-		return;
-	scmd = (struct scsi_cmnd *) req->Org_Req_Scmd;
-	sg = (struct scatterlist *) mv_rq_bf(scmd);
-
-	if (mv_use_sg(scmd)) {
-		BUG_ON(!req->Data_Transfer_Length);
-		req->Data_Buffer = hba_mem_alloc(req->Data_Transfer_Length, MV_TRUE);
-		if (!req->Data_Buffer) {
-			MV_DPRINT(("can not allocate memory %x.\n", req->Data_Transfer_Length));
-		}
-		BUG_ON(!req->Data_Buffer);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
-		req->Data_Transfer_Length = 0;
-		for(i = 0; i < mv_use_sg(scmd); i++, sg++) {
-			local_irq_save(flags);
-			virt_address = map_sg_page(sg);
-			memcpy(req->Data_Buffer + req->Data_Transfer_Length ,\
-				 virt_address + sg->offset, sg->length);
-			kunmap_atomic(virt_address, KM_IRQ0);
-			req->Data_Transfer_Length += sg->length;
-			local_irq_restore(flags);
-		}
-#else
-		memset(req->Data_Buffer, 0, req->Data_Transfer_Length);
-		local_irq_save(flags);
-		if (scmd->sc_data_direction == DMA_TO_DEVICE)
-			sg_copy_to_buffer(scsi_sglist(scmd),  scsi_sg_count(scmd), req->Data_Buffer, req->Data_Transfer_Length);
-		local_irq_restore(flags);
-
-#endif
-	} else {
-	        req->Data_Buffer = mv_rq_bf(scmd);
-	}
-}
-
-void hba_unmap_sg_to_buffer(void *preq)
-{
-	struct scsi_cmnd *scmd = NULL;
-	struct scatterlist *sg = NULL;
-	PMV_Request        req = NULL;
-	unsigned long flags = 0;
-	void * virt_address;
-	unsigned long i = 0;
-
-	req  = (PMV_Request) preq;
-
-	if (REQ_TYPE_OS != req->Req_Type)
-		return;
-
-	scmd = (struct scsi_cmnd *) req->Org_Req_Scmd;
-	sg   = (struct scatterlist *) mv_rq_bf(scmd);
-
-	if (mv_use_sg(scmd)) {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
-		req->Data_Transfer_Length = 0;
-		for(i = 0; i < mv_use_sg(scmd); i++, sg++) {
-			local_irq_save(flags);
-			virt_address = map_sg_page(sg);
-			memcpy(virt_address + sg->offset,req->Data_Buffer
-				+ req->Data_Transfer_Length, sg->length);
-			kunmap_atomic(virt_address , KM_IRQ0);
-			req->Data_Transfer_Length += sg->length;
-			local_irq_restore(flags);
-		}
-#else
-
-		local_irq_save(flags);
-		if (scmd->sc_data_direction == DMA_FROM_DEVICE)
-			sg_copy_from_buffer(scsi_sglist(scmd),  scsi_sg_count(scmd), req->Data_Buffer, req->Data_Transfer_Length);
-		local_irq_restore(flags);
-#endif
-		hba_mem_free(req->Data_Buffer,req->Data_Transfer_Length, MV_TRUE);
-		req->Data_Buffer = mv_rq_bf(scmd);
-	}
-}
-
-MV_BOOLEAN hba_msi_enabled(void *ext)
-{
-	struct hba_extension *phba = (struct hba_extension *)HBA_GetModuleExtension(ext, MODULE_HBA);
-	return (phba->msi_enabled);
-}
-
-MV_PVOID HBA_GetModuleExtension(MV_PVOID ext, MV_U32 mod_id)
-{
-	struct mv_mod_desc *mod_desc;
-	struct mv_adp_desc *hba_desc ;
-
-	if(ext == NULL)
-		return	NULL;
-	mod_desc=(struct mv_mod_desc *)__ext_to_gen(ext)->desc;
-	BUG_ON(NULL == mod_desc);
-	hba_desc = mod_desc->hba_desc;
-
-	MV_ASSERT(mod_id<MAX_MODULE_NUMBER);
-	if (hba_desc !=NULL ) {
-		LIST_FOR_EACH_ENTRY(mod_desc, &hba_desc->online_module_list, mod_entry)
-		{
-			BUG_ON(NULL == mod_desc);
-			if (mod_desc->status != MV_MOD_GONE) {
-				if ((mod_desc->module_id == mod_id) && (mod_desc->extension)) {
-					MV_DASSERT(mod_desc->extension);
-					return mod_desc->extension;
-				}
-			}
-		}
-	}
-	return	NULL;
-}
-
-MV_BOOLEAN __is_scsi_cmd_simulated(MV_U8 cmd_type)
-{
-	switch (cmd_type)
-	{
-	case SCSI_CMD_INQUIRY:
-	case SCSI_CMD_READ_CAPACITY_10:
-	case SCSI_CMD_READ_CAPACITY_16:
-	case SCSI_CMD_SYNCHRONIZE_CACHE_10:
-	case SCSI_CMD_TEST_UNIT_READY:
-	case SCSI_CMD_REQUEST_SENSE:
-	case SCSI_CMD_RESERVE_6:
-	case SCSI_CMD_RELEASE_6:
-	case SCSI_CMD_REPORT_LUN:
-	case SCSI_CMD_MODE_SENSE_6:
-	case SCSI_CMD_MODE_SENSE_10:
-	case SCSI_CMD_MODE_SELECT_6:
-	case SCSI_CMD_MODE_SELECT_10:
-		return MV_TRUE;
-	default:
-		return MV_FALSE;
-	}
-}
-MV_BOOLEAN __is_scsi_cmd_rcv_snd_diag(MV_U8 cmd_type)
-{
-	switch (cmd_type){
-	case API_SCSI_CMD_RCV_DIAG_RSLT:
-	case API_SCSI_CMD_SND_DIAG	:
-		return  MV_TRUE;
-	default:
-		return MV_FALSE;
-	}
-}
-
-void HBARequestCallback(MV_PVOID This,PMV_Request pReq)
-{
-	struct hba_extension *phba = (struct hba_extension *)HBA_GetModuleExtension(This, MODULE_HBA);
-	struct scsi_cmnd *scmd = (struct scsi_cmnd *)pReq->Org_Req_Scmd;
-
-	mv_complete_request(phba, scmd, pReq);
-	phba->Io_Count--;
-	hba_req_cache_free(phba,pReq);
-}
-
-void HBA_GetControllerInfor(
-	IN MV_PVOID extension,
-	OUT PController_Infor pController
-	)
-{
-	pController->Base_Address = __ext_to_gen(extension)->desc->hba_desc->Base_Address;
-	pController->Vendor_Id = __ext_to_gen(extension)->desc->hba_desc->Vendor_Id;
-	pController->Device_Id = __ext_to_gen(extension)->desc->hba_desc->Device_Id;
-	pController->Revision_Id = __ext_to_gen(extension)->desc->hba_desc->Revision_Id;
-	pController->Pci_Device = __ext_to_gen(extension)->desc->hba_desc->dev;
-	pController->run_as_none_raid = __ext_to_gen(extension)->desc->hba_desc->RunAsNonRAID;
-}
-
- void mv_hba_get_controller_pre(
-	 IN MV_PVOID extension,
-	 OUT PController_Infor pController
-	 )
- {
-	 struct mv_adp_desc *hba_desc=(struct mv_adp_desc *)extension;
-	 pController->Base_Address = hba_desc->Base_Address;
-	 pController->Vendor_Id = hba_desc->Vendor_Id;
-	 pController->Device_Id = hba_desc->Device_Id;
-	 pController->Revision_Id = hba_desc->Revision_Id;
- }
-
-MV_U32 HBA_ModuleGetResourceQuota(enum Resource_Type type, MV_U16 maxIo)
-{
-	MV_U32 size = 0;
-
-	if (type == RESOURCE_CACHED_MEMORY) {
-		size = sizeof(HBA_Extension);
-
-		size += 8;
-		size = ROUNDING(size, 8);
-
-		size +=  RAID_Feature_GetResourceQuota(maxIo);
-		size = ROUNDING(size, 8);
-
-		size += Timer_GetResourceQuota(maxIo);
-		size = ROUNDING(size, 8);
-
-		size += sizeof(Driver_Event_Entry) * MAX_EVENTS;
-		size = ROUNDING(size, 8);
-		MV_ASSERT(size == ROUNDING(size, 8));
-
-		size += sizeof(struct mv_lu) * MV_MAX_ID;
-		size = ROUNDING(size, 8);
-		MV_ASSERT(size == ROUNDING(size, 8));
-	}
-	return size;
-}
-
-void core_disable_ints(void * ext);
-void core_enable_ints(void * ext);
-MV_BOOLEAN Core_InterruptCheckIRQ(MV_PVOID This);
-void Core_InterruptHandleIRQ(MV_PVOID This);
-static void run_tasklet(PHBA_Extension   phba)
-{
-	struct mv_mod_desc *core_desc;
-
-	int retval = MV_FALSE;
-
-	spin_lock_bh(&phba->desc->hba_desc->global_lock);
-	core_desc=__get_lowest_module(phba->desc->hba_desc);
-
-	retval = Core_InterruptCheckIRQ(core_desc->extension);
-       if(!retval)
-	goto out;
-
-	Core_InterruptHandleIRQ(core_desc->extension);
-
-out:
-	spin_unlock_bh(&phba->desc->hba_desc->global_lock);
-       core_enable_ints(core_desc->extension);
-
-}
-
-void HBA_ModuleInitialize(MV_PVOID ext,
-				 MV_U32   size,
-				 MV_U16   max_io)
-{
-	PHBA_Extension phba = (PHBA_Extension)ext;
-	MV_PTR_INTEGER temp = (MV_PTR_INTEGER)phba + sizeof(HBA_Extension);
-	MV_U32 i;
-	MV_U32 sg_num;
-	PDriver_Event_Entry pEvent = NULL;
-
-	phba->State    = DRIVER_STATUS_IDLE;
-	phba->Io_Count = 0;
-	phba->Ioctl_Io_Count = 0;
-	phba->Max_Io   = max_io;
-
-	init_completion(&phba->desc->hba_desc->cmpl);
-	init_completion(&phba->desc->hba_desc->ioctl_cmpl);
-
-	if (max_io > 1)
-		sg_num   = MAX_SG_ENTRY;
-	else
-		sg_num   = MAX_SG_ENTRY_REDUCED;
-
-	sg_num *= 2;
-	MV_DPRINT(("check struct _MV_Request  %x.\n",sizeof(struct _MV_Request)));
-
-	phba->max_sg_count = sg_num;
-	MV_DPRINT(("HBA allocate max sg count %d.\n",phba->max_sg_count));
-	hba_req_cache_create(phba);
-	if(!phba->mv_mempool){
-		MV_PRINT("allcate cache failed\n");
-		alloc_uncached_failed(HBA_GetModuleExtension( ext, MODULE_HBA ));
-		return;
-	}
-
-	tasklet_init(&phba->desc->hba_desc->mv_tasklet,
-			(void (*)(unsigned long))run_tasklet, (unsigned long)phba);
-	spin_lock_init(&phba->desc->hba_desc->tasklet_count_lock);
-
-	MV_LIST_HEAD_INIT(&phba->Stored_Events);
-	MV_LIST_HEAD_INIT(&phba->Free_Events);
-	phba->Num_Stored_Events = 0;
-	phba->SequenceNumber = 0;
-
-	MV_ASSERT(sizeof(Driver_Event_Entry) ==
-		  ROUNDING(sizeof(Driver_Event_Entry), 8));
-	temp = ROUNDING(((MV_PTR_INTEGER) temp), 8);
-
-	for (i = 0; i < MAX_EVENTS; i++) {
-		pEvent = (PDriver_Event_Entry) temp;
-		List_AddTail(&pEvent->Queue_Pointer, &phba->Free_Events);
-		temp += sizeof(Driver_Event_Entry);
-	}
-
-	for (i = 0; i < MV_MAX_TARGET_NUMBER; i++) {
-		phba->mv_unit[i].sdev = NULL;
-		phba->mv_unit[i].lun = 0xFFFF;
-		phba->mv_unit[i].id = i;
-		phba->mv_unit[i].target_id = 0xFFFF;
-	}
-
-	phba->p_raid_feature = (MV_PVOID)temp;
-	RAID_Feature_Initialize(phba->p_raid_feature , max_io);
-	temp += RAID_Feature_GetResourceQuota(max_io);
-	Timer_Initialize(phba, (MV_PU8)temp, max_io);
-
-}
-
-
-void HBA_ModuleShutdown(MV_PVOID extension)
-{
-	PHBA_Extension hba = (PHBA_Extension) extension;
-	struct mv_adp_desc *hba_desc = hba->desc->hba_desc;
-
-	if (DRIVER_STATUS_STARTED == hba->State) {
-		scsi_remove_host(hba_desc->hba_host);
-		hba_send_shutdown_req((MV_PVOID)hba);
-		while(hba->Io_Count)
-			HBA_SleepMillisecond(NULL,10);
-		free_irq(hba_desc->dev->irq, hba);
-
-		if (hba->msi_enabled)
-			pci_disable_msi(hba->desc->hba_desc->dev);
-
-		scsi_host_put(hba_desc->hba_host);
-		hba_desc->hba_host = NULL;
-	}
-
-	tasklet_kill(&hba_desc->mv_tasklet);
-	hba_req_cache_destroy(hba);
-	Timer_Stop(hba);
-
-	hba->State = DRIVER_STATUS_SHUTDOWN;
-}
-
-MV_BOOLEAN add_event(IN MV_PVOID extension,
-			    IN MV_U32 eventID,
-			    IN MV_U16 deviceID,
-			    IN MV_U8 severityLevel,
-			    IN MV_U8 param_cnt,
-			    IN MV_PU32 params,
-			    IN MV_U8 SenseLength,
-			    IN MV_PU8 psense,
-			    IN MV_U16 trans_bit)
-{
-	struct hba_extension * hba = (struct hba_extension *) extension;
-	PDriver_Event_Entry pEvent;
-	static MV_U32 local_time=0;
-
-	if (param_cnt > MAX_EVENT_PARAMS)
-		return MV_FALSE;
-
-	local_time = ossw_get_local_time();
-
-	if (List_Empty(&hba->Free_Events)) {
-		/* No free entry, we need to reuse the oldest entry from
-		 * Stored_Events.
-		 */
-		MV_ASSERT(!List_Empty(&hba->Stored_Events));
-		MV_ASSERT(hba->Num_Stored_Events == MAX_EVENTS);
-		pEvent = List_GetFirstEntry((&hba->Stored_Events), Driver_Event_Entry, Queue_Pointer);
-	} else {
-		pEvent = List_GetFirstEntry((&hba->Free_Events), Driver_Event_Entry, Queue_Pointer);
-		hba->Num_Stored_Events++;
-		MV_ASSERT(hba->Num_Stored_Events <= MAX_EVENTS);
-	}
-
-
-	pEvent->Event.Event.AdapterID = hba->desc->hba_desc->id;
-	pEvent->Event.Event.EventID = eventID;
-	pEvent->Event.Event.SequenceNo = hba->SequenceNumber++;
-	pEvent->Event.Event.Severity = severityLevel;
-	pEvent->Event.Event.DeviceID = deviceID;
-	pEvent->Event.Event.TimeStamp = local_time;
-
-	if (param_cnt > 0 && params != NULL)
-		MV_CopyMemory( (MV_PVOID)pEvent->Event.Event.Params, (MV_PVOID)params, param_cnt * 4 );
-	if(SenseLength>0&&psense!=NULL)
-	{
-		if(SenseLength>MAX_EVENT_SENSE_DATA_COUNT)
-			SenseLength=MAX_EVENT_SENSE_DATA_COUNT;
-		pEvent->Event.SenseDataLength=SenseLength;
-		MV_CopyMemory((MV_PVOID)pEvent->Event.SenseData, (MV_PVOID)psense, SenseLength);
-	}
-	else
-		pEvent->Event.SenseDataLength=0;
-
-	List_AddTail(&pEvent->Queue_Pointer, &hba->Stored_Events);
-	return MV_TRUE;
-}
-
-void get_event(MV_PVOID This, PMV_Request pReq)
-{
-	struct hba_extension * hba = (struct hba_extension *) This;
-	PEventRequest_V2 pEventReq = (PEventRequest_V2)pReq->Data_Buffer;
-	PDriver_Event_Entry pfirst_event;
-	MV_U8 count = 0;
-
-	pEventReq->Count = 0;
-
-	if ( hba->Num_Stored_Events > 0 )
-	{
-		MV_DASSERT( !List_Empty(&hba->Stored_Events) );
-		while (!List_Empty(&hba->Stored_Events) &&
-		       (count < MAX_EVENTS_RETURNED)) {
-			pfirst_event = List_GetFirstEntry((&hba->Stored_Events), Driver_Event_Entry, Queue_Pointer);
-			MV_CopyMemory(&pEventReq->Events[count],
-				      &pfirst_event->Event,
-				      sizeof(DriverEvent_V2));
-			hba->Num_Stored_Events--;
-			List_AddTail(&pfirst_event->Queue_Pointer,
-				      &hba->Free_Events );
-			count++;
-		}
-		pEventReq->Count = count;
-	}
-
-	pReq->Scsi_Status = REQ_STATUS_SUCCESS;
-	return;
-}
-
-void HBA_ModuleNotification(MV_PVOID This, enum Module_Event event, struct mod_notif_param *event_param)
-{
-	struct hba_extension * hba = (struct hba_extension *)HBA_GetModuleExtension(This, MODULE_HBA);
-
-	switch (event) {
-	case EVENT_LOG_GENERATED:
-		add_event(hba, event_param->event_id,
-			  event_param->dev_id, event_param->severity_lvl,
-			  event_param->param_count, (MV_PU32) event_param->p_param,
-			  event_param->sense_length, (MV_PU8)event_param->p_sense,
-			  event_param->tran_hex_bit);
-		break;
-	case EVENT_DEVICE_ARRIVAL:
-	case EVENT_DEVICE_REMOVAL:
-		if (hba->first_scan==0) {
-			hba_msg_insert(hba,
-				       event,
-				       (event_param == NULL)?0:(event_param->lo|((event_param->hi<<16)&0xffff0000)) );
-		}
-		break;
-
-	default:
-		break;
-	}
-}
-
-
-int HBA_GetResource(void *extension,
-		    enum Resource_Type type,
-		    MV_U32  size,
-		    Assigned_Uncached_Memory *dma_res)
-{
-	struct mv_mod_res *mod_res;
-	struct mv_mod_desc *mod_desc = __ext_to_gen(extension)->desc;
-	if(!mod_desc){
-		MV_DPRINT(("mod decript is destried.\n"));
-	}
-	mod_res = hba_mem_alloc(sizeof(struct mv_mod_res),MV_FALSE);
-	if (NULL == mod_res) {
-		MV_PRINT("unable to allocate memory for module %d resource management.\n", mod_desc->module_id);
-		return -1;
-	}
-
-	memset(mod_res, 0, sizeof(struct mv_mod_res));
-	mod_res->size = size;
-	mod_res->type = type;
-	switch (type) {
-	case RESOURCE_UNCACHED_MEMORY :
-		if (__alloc_consistent_mem(mod_res, mod_desc->hba_desc->dev)) {
-			MV_PRINT("unable to allocate 0x%x uncached mem.\n", size);
-			hba_mem_free(mod_res,sizeof(struct mv_mod_res),MV_FALSE);
-			return -1;
-		}
-		List_Add(&mod_res->res_entry, &mod_desc->res_list);
-		memset(mod_res->virt_addr, 0, size);
-		dma_res->Virtual_Address  = mod_res->virt_addr;
-		dma_res->Physical_Address = mod_res->bus_addr;
-		dma_res->Byte_Size        = size;
-		break;
-	case RESOURCE_CACHED_MEMORY :
-	default:
-		hba_mem_free(mod_res,sizeof(struct mv_mod_res),MV_FALSE);
-		MV_PRINT("unknown resource type %d.\n", type);
-		return -1;
-	}
-	return 0;
-}
-
-int hba_get_uncache_resource(void *extension,
-		    MV_U32  size,
-		    Assigned_Uncached_Memory *dma_res)
-{
-		return HBA_GetResource(extension, RESOURCE_UNCACHED_MEMORY, size,dma_res);
-}
-
-
-void alloc_uncached_failed(void *extension)
-{
-	struct mv_mod_desc *mod_desc = __ext_to_gen(extension)->desc;
-	mod_desc->hba_desc->alloc_uncahemem_failed = MV_TRUE;
-}
-
-void * os_malloc_mem(void *extension, MV_U32 size, MV_U8 mem_type, MV_U16 alignment, MV_PHYSICAL_ADDR *phy)
-{
-	Assigned_Uncached_Memory dma_res;
-	if(HBA_GetResource(extension, mem_type, size, &dma_res))
-		return NULL;
-	phy->value = dma_res.Physical_Address.value;
-	return dma_res.Virtual_Address;
-}
-
-MV_VOID
-HBA_GetNextModuleSendFunction(
-	IN MV_PVOID self_extension,
-	OUT MV_PVOID *next_extension,
-	OUT MV_VOID (**next_function)(MV_PVOID , PMV_Request)
-	)
-
- {
-	   *(next_extension) = __ext_to_gen(self_extension)->desc->child->extension;
-	   *(next_function) =  __ext_to_gen(self_extension)->desc->child->ops->module_sendrequest;
- }
-
-MV_VOID
-HBA_GetUpperModuleNotificationFunction(
-	IN MV_PVOID self_extension,
-	OUT MV_PVOID *upper_extension,
-	OUT MV_VOID (**upper_notificaton_function)(MV_PVOID,
-						   enum Module_Event,
-						   struct mod_notif_param *))
-{
-	*(upper_extension) = __ext_to_gen(self_extension)->desc->parent->extension;
-	*(upper_notificaton_function) = __ext_to_gen(self_extension)->desc->parent->ops->module_notification;
-}
-
-
-void hba_notify_upper_md(
-			IN MV_PVOID extension,
-			  enum Module_Event notifyEvent,
-			  MV_PVOID event_param)
-{
-	__ext_to_gen(extension)->desc->parent->ops->module_notification(
-                                            __ext_to_gen(extension)->desc->parent->extension,
-										notifyEvent,
-										event_param);
-}
-
-#ifndef CONFIG_X86_64
-#define ossw_mdelay(x) ((__builtin_constant_p(x) && (x)<5)? ossw_udelay((x)*1000):\
-	({unsigned long __ms=(x); while (__ms--) ossw_udelay(1000);}))
-#else
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))
-	#ifndef CONFIG_ARM
-#define ossw_mdelay(x) ((__builtin_constant_p(x) && (x)<5)? ossw_udelay((x)*1000):\
-	({unsigned long __ms=(x); while (__ms--){ if(__ms%2000) {touch_nmi_watchdog();touch_softlockup_watchdog();} ossw_udelay(1000);}}))
-	#else
-#define ossw_mdelay(x) ((__builtin_constant_p(x) && (x)<5)? ossw_udelay((x)*1000):\
-	({unsigned long __ms=(x); while (__ms--){ if(__ms%2000) {touch_nmi_watchdog();} ossw_udelay(1000);}}))
-	#endif
-
-#else
-#define ossw_mdelay(x) ((__builtin_constant_p(x) && (x)<5)? ossw_udelay((x)*1000):\
-	({unsigned long __ms=(x); while (__ms--){ if(__ms%2000) touch_nmi_watchdog(); ossw_udelay(1000);}}))
-#endif
-#endif
-
-static void mv_touch_nmi_watchdog(void)
-{
-#ifdef CONFIG_X86_64
-	touch_nmi_watchdog();
-#endif /* CONFIG_X86_64*/
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13)
-#ifndef CONFIG_ARM
-	touch_softlockup_watchdog();
-#endif
-#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13) */
-}
-
-void HBA_SleepMillisecond(MV_PVOID ext, MV_U32 msec)
-{
-	MV_U32 	tmp=0;
-	MV_U32	mod_msec=2000;
-	if (in_interrupt() || irqs_disabled()){
-		mv_touch_nmi_watchdog();
-		if (msec<=mod_msec)
-			ossw_mdelay(msec);
-		else {
-			for (tmp=0;tmp<msec/mod_msec;tmp++) {
-				ossw_mdelay(mod_msec);
-				mv_touch_nmi_watchdog();
-			}
-			if (msec%mod_msec)
-				ossw_mdelay(msec%mod_msec);
-		}
-		mv_touch_nmi_watchdog();
-	} else {
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout( msec );
-	}
-}
-
-MV_PVOID hba_mem_alloc(MV_U32 size,MV_BOOLEAN sg_use)
-{
-	MV_PVOID mem_pool;
-
-	if(sg_use){
-		if(size > (128*1024 -16))
-			WARN_ON(1);
-	}
-	if( (size <= 4*PAGE_SIZE)||(sg_use))
-		mem_pool = kmalloc(size,GFP_ATOMIC);
-	else if ((size > 4*PAGE_SIZE)&&(!in_interrupt())&&(!irqs_disabled()))
-		mem_pool = vmalloc(size);
-	else
-		mem_pool = kmalloc(size,GFP_ATOMIC);
-
-	return mem_pool;
-}
-
-MV_VOID hba_mem_free(MV_PVOID mem_pool, MV_U32 size,MV_BOOLEAN sg_use)
-{
-	if( (size <= 4*PAGE_SIZE)||(sg_use))
-		kfree(mem_pool);
-	else if( (size > 4*PAGE_SIZE)&&(!in_interrupt())&&(!irqs_disabled()))
-		vfree(mem_pool);
-	else
-		kfree(mem_pool);
-}
-
-void mvs_hexdump(u32 size, u8 *data, u32 baseaddr, const char *prefix)
-{
-	u32 i;
-	u32 run;
-	u32 offset;
-
-	offset = 0;
-	printk("%s : \n", prefix);
-	while (size) {
-		printk("%08X : ", baseaddr + offset);
-		if (size >= 16)
-			run = 16;
-		else
-			run = size;
-		size -= run;
-		for (i = 0; i < 16; i++) {
-			if (i < run)
-				printk("%02X ", (u32)data[i]);
-			else
-				printk("   ");
-		}
-		printk(": ");
-		for (i = 0; i < run; i++)
-			printk("%c",
-				isalnum(data[i]) ? data[i] : '.');
-		printk("\n");
-		data = &data[16];
-		offset += run;
-	}
-	printk("\n");
-}
-
-MV_BOOLEAN HBA_CheckIsFlorence(MV_PVOID ext)
-{
-	struct hba_extension *phba = (struct hba_extension *)HBA_GetModuleExtension(ext, MODULE_HBA);
-	MV_U16 device_id;
-	device_id = phba->Device_Id;
-	return (device_id == DEVICE_ID_948F ? MV_TRUE : MV_FALSE);
-}
-
-MV_U32 hba_parse_ata_protocol(struct scsi_cmnd *scmd)
-{
-	MV_U8 protocol = 0, t_length = 0, t_dir = 0;
-	MV_U32 cmd_flag =0;
-
-	protocol = (scmd->cmnd[1]>> 1) & 0x0F;
-	if(protocol== HRST || protocol==SRST){
-		return cmd_flag;
-	}
-
-	t_length = scmd->cmnd[2] & 0x03;
-	t_dir = (scmd->cmnd[2] >> 3) & 0x01;
-
-	if (t_length == 0){
-		cmd_flag = CMD_FLAG_NON_DATA;
-	}else {
-		if (t_dir == 0)
-			cmd_flag = CMD_FLAG_DATA_OUT;
-		else
-			cmd_flag = CMD_FLAG_DATA_IN;
-	}
-	switch (protocol) {
-	case NON_DATA:
-		cmd_flag |= CMD_FLAG_NON_DATA;
-		break;
-	case PIO_DATA_IN:
-		cmd_flag |= CMD_FLAG_PIO;
-		if (!(cmd_flag & CMD_FLAG_DATA_IN))
-			cmd_flag |= CMD_FLAG_DATA_IN;
-		break;
-	case PIO_DATA_OUT:
-		cmd_flag |= CMD_FLAG_PIO;
-		if (!(cmd_flag & CMD_FLAG_DATA_OUT))
-			cmd_flag |= CMD_FLAG_DATA_OUT;
-		break;
-	case DMA:
-		cmd_flag |= CMD_FLAG_DMA;
-		break;
-	case DMA_QUEUED:
-		cmd_flag |= (CMD_FLAG_DMA | CMD_FLAG_TCQ);
-		break;
-	case DEVICE_DIAGNOSTIC:
-	case DEVICE_RESET:
-		break;
-	case UDMA_DATA_IN:
-		cmd_flag |= CMD_FLAG_DMA;
-		if (!(cmd_flag & CMD_FLAG_DATA_IN))
-			cmd_flag |= CMD_FLAG_DATA_IN;
-		break;
-	case UDMA_DATA_OUT:
-		cmd_flag |= CMD_FLAG_DMA;
-		if (!(cmd_flag & CMD_FLAG_DATA_OUT))
-			cmd_flag |= CMD_FLAG_DATA_OUT;
-		break;
-	case FPDMA:
-		cmd_flag |= (CMD_FLAG_DMA | CMD_FLAG_NCQ);
-		break;
-	case RTN_INFO:
-		break;
-	default:
-		MV_PRINT("Unsupported ATA Protocol = 0x%x\n", protocol);
-		break;
-	}
-	return cmd_flag;
-}
--- a/drivers/scsi/vanir/linux/hba_exp.h
+++ /dev/null
@@ -1,234 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __HBA_EXPOSE_H__
-#define __HBA_EXPOSE_H__
-#include "hba_header.h"
-
-typedef struct _Assigned_Uncached_Memory
-{
-	MV_PVOID		Virtual_Address;
-	MV_PHYSICAL_ADDR	Physical_Address;
-	MV_U32			Byte_Size;
-	MV_U32			Reserved0;
-} Assigned_Uncached_Memory, *PAssigned_Uncached_Memory;
-
-typedef struct _Controller_Infor
-{
-	MV_LPVOID *Base_Address;
-	MV_PVOID Pci_Device;
-	MV_U16 Vendor_Id;
-	MV_U16 Device_Id;
-	MV_U8 Revision_Id;
-	MV_U8 run_as_none_raid;
-	MV_U8 Reserved[2];
-} Controller_Infor, *PController_Infor;
-
-typedef struct _SCSI_PASS_THROUGH_DIRECT {
-	unsigned short Length;
-	unsigned char  ScsiStatus;
-	unsigned char  PathId;
-	unsigned char  TargetId;
-	unsigned char  Lun;
-	unsigned char  CdbLength;
-	unsigned char  SenseInfoLength;
-	unsigned char  DataIn;
-	unsigned long  DataTransferLength;
-	unsigned long  TimeOutValue;
-	void __user    *DataBuffer;
-	unsigned long  SenseInfoOffset;
-	unsigned char  Cdb[16];
-}SCSI_PASS_THROUGH_DIRECT, *PSCSI_PASS_THROUGH_DIRECT,SCSI_REQUEST_BLOCK, *PSCSI_REQUEST_BLOCK;
-
-/*ATA Protocols*/
-enum _ATA_PROTOCOL {
-	HRST 			= 0x00,
-	SRST  			= 0x01,
-	BUS_IDLE 		= 0x02,
-	NON_DATA 		= 0x03,
-	PIO_DATA_IN 	= 0x04,
-	PIO_DATA_OUT 	= 0x05,
-	DMA			= 0x06,
-	DMA_QUEUED	= 0x07,
-	DEVICE_DIAGNOSTIC	= 0x08,
-	DEVICE_RESET		= 0x09,
-	UDMA_DATA_IN		= 0x0A,
-	UDMA_DATA_OUT	= 0x0B,
-	FPDMA				= 0x0C,
-	RTN_INFO			= 0x0F,
-};
-
-#include "com_event_struct.h"
-#include "com_event_define.h"
-#include "com_event_define_ext.h"
-#define MSG_QUEUE_DEPTH	2048
-
-typedef struct _Driver_Event_Entry
-{
-	List_Head Queue_Pointer;
-	DriverEvent_V2 Event;
-} Driver_Event_Entry, *PDriver_Event_Entry;
-
-MV_VOID
-HBA_GetNextModuleSendFunction(
-	IN MV_PVOID self_extension,
-	OUT MV_PVOID *next_extension,
-	OUT MV_VOID (**next_function)(MV_PVOID , PMV_Request)
-	);
-
-MV_VOID
-HBA_GetUpperModuleNotificationFunction(
-	IN MV_PVOID self_extension,
-	OUT MV_PVOID *upper_extension,
-	OUT MV_VOID (**upper_notificaton_function)(MV_PVOID,
-						   enum Module_Event,
-						   struct mod_notif_param *));
-
-void hba_notify_upper_md(
-			IN MV_PVOID extension,
-			  enum Module_Event notifyEvent,
-			  MV_PVOID event_param);
-
-
-#define HBA_SleepMicrosecond(_x, _y) ossw_udelay(_y)
-#define HBA_GetTimeInSecond          ossw_get_time_in_sec
-#define HBA_GetMillisecondInDay      ossw_get_msec_of_time
-
-MV_BOOLEAN HBA_CheckIsFlorence(MV_PVOID ext);
-
-/*read pci config space*/
-MV_U32 MV_PCI_READ_DWORD(MV_PVOID This, MV_U8 reg);
-MV_VOID  MV_PCI_WRITE_DWORD(MV_PVOID This, MV_U32 val, MV_U8 reg);
-void HBA_ModuleStarted(MV_PVOID extension);
-
-
-void HBA_GetControllerInfor(
-	IN MV_PVOID extension,
-	OUT PController_Infor pController
-	);
-
-
-/* map bus addr in sg entry into cpu addr (access via. Data_Buffer) */
-void hba_map_sg_to_buffer(void *preq);
-void hba_unmap_sg_to_buffer(void *preq);
-
-MV_BOOLEAN hba_msi_enabled(void *ext);
-
-static inline MV_BOOLEAN
-HBA_ModuleGetPhysicalAddress(MV_PVOID Module,
-			     MV_PVOID Virtual,
-			     MV_PVOID TranslationContext,
-			     MV_PU64 PhysicalAddress,
-			     MV_PU32 Length)
-{
-	panic("not supposed to be called.\n");
-	return MV_FALSE;
-};
-
-int HBA_GetResource(void *extension,
-		    enum Resource_Type type,
-		    MV_U32  size,
-		    Assigned_Uncached_Memory *dma_res);
-
-int hba_get_uncache_resource(void *extension,
-		    MV_U32  size,
-		    Assigned_Uncached_Memory *dma_res);
-
-void alloc_uncached_failed(void *extension);
-
-MV_PVOID HBA_GetModuleExtension(MV_PVOID ext, MV_U32 mod_id);
-
-MV_PVOID sgd_kmap(sgd_t  *sg);
-MV_VOID sgd_kunmap(sgd_t  *sg,MV_PVOID mapped_addr);
-
-MV_BOOLEAN __is_scsi_cmd_simulated(MV_U8 cmd_type);
-MV_BOOLEAN __is_scsi_cmd_rcv_snd_diag(MV_U8 cmd_type);
-
-void HBARequestCallback(MV_PVOID This,PMV_Request pReq);
-void HBA_SleepMillisecond(MV_PVOID ext, MV_U32 msec);
-void HBA_ModuleInitialize(MV_PVOID ext,
-				 MV_U32   size,
-				 MV_U16   max_io);
-void HBA_ModuleShutdown(MV_PVOID extension);
-void HBA_ModuleNotification(MV_PVOID This,
-			     enum Module_Event event,
-			     struct mod_notif_param *event_param);
-
-MV_U32 HBA_ModuleGetResourceQuota(enum Resource_Type type, MV_U16 maxIo);
-void HBA_ModuleStart(MV_PVOID extension);
-void HBA_ModuleSendRequest(MV_PVOID this, PMV_Request req);
-
-
-MV_U16 Timer_AddRequest(
-	IN MV_PVOID extension,
-	IN MV_U32 time_unit,
-	IN MV_VOID (*routine) (MV_PVOID, MV_PVOID),
-	IN MV_PVOID context1,
-	IN MV_PVOID context2
-	);
-
-MV_U16 Timer_AddSmallRequest(
-	IN MV_PVOID extension,
-	IN MV_U32 time_unit,
-	IN MV_VOID (*routine) (MV_PVOID, MV_PVOID),
-	IN MV_PVOID context1,
-	IN MV_PVOID context2
-	);
-
-void Timer_CancelRequest(
-	IN MV_PVOID extension,
-	IN MV_U16 request_index
-	);
-
-void Timer_CheckRequest(
-	IN MV_PVOID extension
-	);
-
-MV_U32 Timer_GetResourceQuota(MV_U16 maxIo);
-void Timer_Initialize(
-	IN  MV_PVOID This,
-	IN MV_PU8 pool,
-	IN MV_U16 max_io
-	);
-void Timer_Stop(MV_PVOID This);
-
-void * os_malloc_mem(void *extension, MV_U32 size, MV_U8 mem_type, MV_U16 alignment, MV_PHYSICAL_ADDR *phy);
-MV_VOID core_push_queues(MV_PVOID core_p);
-#define NO_CURRENT_TIMER		0xffff
-
-void mv_hba_get_controller_pre(
-	IN MV_PVOID extension,
-	OUT PController_Infor pController
-	);
-
-MV_BOOLEAN add_event(IN MV_PVOID extension,
-			    IN MV_U32 eventID,
-			    IN MV_U16 deviceID,
-			    IN MV_U8 severityLevel,
-			    IN MV_U8 param_cnt,
-			    IN MV_PU32 params,
-			    IN MV_U8 SenseLength,
-			    IN MV_PU8 psense,
-			    IN MV_U16 trans_bit);
-
-void get_event(MV_PVOID This, PMV_Request pReq);
-MV_PVOID hba_mem_alloc(MV_U32 size,MV_BOOLEAN sg_use);
-MV_VOID hba_mem_free(MV_PVOID mem_pool, MV_U32 size,MV_BOOLEAN sg_use);
-void mvs_hexdump(u32 size, u8 *data, u32 baseaddr, const char *prefix);
-
-MV_U32 hba_parse_ata_protocol(struct scsi_cmnd *scmd);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-extern unsigned int mv_prot_mask;
-#endif
-
-#endif
--- a/drivers/scsi/vanir/linux/hba_header.h
+++ /dev/null
@@ -1,32 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined(MV_INCLUDE_H)
-#define MV_INCLUDE_H
-#include "mv_config.h"
-#include "mv_os.h"
-#include "com_type.h"
-#include "com_u64.h"
-#include "com_util.h"
-#include "com_list.h"
-#include "com_dbg.h"
-#include "com_tag.h"
-#include "com_mod_mgmt.h"
-#include "com_struct.h"
-#include "com_scsi.h"
-#include "com_api.h"
-#include "com_extern.h"
-#include "hba_inter.h"
-#include "hba_exp.h"
-
-#endif /* MV_INCLUDE_H */
--- a/drivers/scsi/vanir/linux/hba_inter.h
+++ /dev/null
@@ -1,135 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef HBA_INTERNAL_H
-#define HBA_INTERNAL_H
-#include "hba_header.h"
-#include "com_tag.h"
-
-typedef struct _Timer_Request
-{
-	List_Head Queue_Pointer;
-	MV_PVOID Context1;
-	MV_PVOID Context2;
-	MV_PVOID Reserved0;
-	MV_VOID (*Routine) (MV_PVOID, MV_PVOID);
-	MV_BOOLEAN Valid;
-	MV_U8 Reserved1[7];
-	MV_U64 Time_Stamp;
-} Timer_Request, *PTimer_Request;
-
-
-typedef struct _Timer_Module
-{
-	PTimer_Request *Running_Requests;
-	MV_U16 Timer_Request_Number;
-	MV_U8 Reserved0[6];
-	Tag_Stack Tag_Pool;
-	MV_U64 Time_Stamp;
-} Timer_Module, *PTimer_Module;
-
-enum hba_info_flags {
-	MVF_MSI		= (1U << 0),	/* MSI is enabled */
-};
-
-/* Per logical unit */
-struct mv_lu
-{
-	MV_U16 id;
-	MV_U16 lun;
-	MV_U16 reserved0[2];
-	MV_U16 target_id;
-	struct scsi_device	*sdev;		/* attached SCSI device */
-};
-
-typedef struct hba_extension
-{
-	/* self-descriptor */
-	struct mv_mod_desc *desc;
-
-	void    *req_pool;
-	/* Device extention */
-	MV_PVOID Device_Extension;
-	/* System resource */
-	MV_LPVOID Base_Address[MAX_BASE_ADDRESS];
-	MV_U32 State;
-	MV_BOOLEAN Is_Dump;		/* Is OS during hibernation or crash dump? */
-	MV_U32 Io_Count;			/* Outstanding requests count */
-	MV_U32	hba_flags;
-
-	/* Adapter information */
-	MV_U8 Adapter_Bus_Number;
-	MV_U8 Adapter_Device_Number;
-	MV_U16 Vendor_Id;
-	MV_U16 Device_Id;
-	MV_U8 Revision_Id;
-	MV_U8 RunAsNonRAID;
-	MV_BOOLEAN msi_enabled;
-	MV_U8 reserved;
-	MV_U16 RaidMode;
-	MV_U16 Sub_Vendor_Id;
-	MV_U16 Sub_System_Id;
-
-	MV_U8 pcie_max_lnk_spd;	/* PCIe Max Supported Link Speed */
-	MV_U8 pcie_max_bus_wdth;	/* PCIe Max Supported Bus Width */
-	MV_U8 pcie_neg_lnk_spd;		/* PCIe Negotiated Link Speed */
-	MV_U8 pcie_neg_bus_wdth;	/* PCIe Negotiated Bus Width */
-
-	MV_U8 reserved1[2];
-	MV_U32 MvAdapterSignature;
-
-	/* Timer module */
-	Timer_Module TimerModule;
-	MV_PVOID			uncached_virtual;
-	MV_PHYSICAL_ADDR	uncached_physical;
-	MV_U32				uncached_quota;
-	MV_U32				scsiport_allocated_uncached;
-	MV_U16				Max_Io;
-	MV_U16				waiting_cb_cnt;
-
-	List_Head Waiting_Request;	/* MV_Request waiting queue */
-
-	MV_U32 max_sg_count;
-	mempool_t * mv_mempool;
-
-	 kmem_cache_t  *mv_request_cache;
-	 kmem_cache_t  *mv_request_sg_cache;
-
-	char cache_name[CACHE_NAME_LEN];
-	char sg_name[CACHE_NAME_LEN];
-
-	List_Head Stored_Events;
-	List_Head Free_Events;
-	MV_U32	SequenceNumber;
-	MV_U8 Num_Stored_Events;
-	MV_U8 Reserved2[3];
-
-	struct mv_lu mv_unit[MV_MAX_TARGET_NUMBER];
-
-	MV_U8 FlashBad;
-	MV_U8 FlashErase;
-	MV_U8 Ioctl_Io_Count;
-	MV_U8 first_scan;
-
-	MV_PVOID		pNextExtension;
-	MV_VOID 		(*pNextFunction)(MV_PVOID , PMV_Request);
-	MV_PVOID p_raid_feature;
-
-}HBA_Extension, *PHBA_Extension;
-
-#define DRIVER_STATUS_IDLE      1    /* The first status */
-#define DRIVER_STATUS_STARTING  2    /* Begin to start all modules */
-#define DRIVER_STATUS_STARTED   3    /* All modules are all settled. */
-#define DRIVER_STATUS_SHUTDOWN   4   /* All modules shutdown. */
-
-#endif /* HBA_INTERNAL_H */
--- a/drivers/scsi/vanir/linux/hba_mod.c
+++ /dev/null
@@ -1,657 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "hba_header.h"
-#include "linux_main.h"
-#include "linux_iface.h"
-#include "hba_mod.h"
-#include "hba_timer.h"
-#include "hba_api.h"
-
-static MV_LIST_HEAD(mv_online_adapter_list);
-
-int __mv_get_adapter_count(void)
-{
-	struct mv_adp_desc *p;
-	int i = 0;
-	LIST_FOR_EACH_ENTRY(p, &mv_online_adapter_list, hba_entry)
-	i++;
-
-	return i;
-}
-
-struct mv_adp_desc *__dev_to_desc(struct pci_dev *dev)
-{
-	struct mv_adp_desc *p;
-
-	LIST_FOR_EACH_ENTRY(p, &mv_online_adapter_list, hba_entry)
-	if (p->dev == dev)
-		return p;
-	return NULL;
-}
-
-MV_PVOID *mv_get_hba_extension(struct mv_adp_desc *hba_desc)
-{
-	struct mv_mod_desc *p;
-
-	LIST_FOR_EACH_ENTRY(p, &hba_desc->online_module_list, mod_entry)
-		if (MODULE_HBA == p->module_id)
-			return p->extension;
-	return NULL;
-}
-
-static inline void __mv_release_hba(struct mv_adp_desc *hba_desc)
-{
-	struct mv_mod_desc *mod_desc, *p;
-
-	LIST_FOR_EACH_ENTRY_SAFE(mod_desc,
-				p,
-				&hba_desc->online_module_list,
-				mod_entry) {
-		List_Del(&mod_desc->mod_entry);
-		hba_mem_free(mod_desc,sizeof(struct mv_mod_desc),MV_FALSE);
-	}
-
-	List_Del(&hba_desc->hba_entry);
-	hba_mem_free(hba_desc,sizeof(struct mv_adp_desc),MV_FALSE);
-}
-
-static struct mv_adp_desc *mv_hba_init_modmm(struct pci_dev *dev)
-{
-	struct mv_adp_desc *hba_desc;
-
-	hba_desc = hba_mem_alloc(sizeof(struct mv_adp_desc),MV_FALSE);
-	if (NULL == hba_desc) {
-		MV_PRINT("Unable to get memory at hba init.\n");
-		return NULL;
-	}
-	memset(hba_desc, 0, sizeof(struct mv_adp_desc));
-	hba_desc->dev = dev;
-	MV_LIST_HEAD_INIT(&hba_desc->online_module_list);
-	List_Add(&hba_desc->hba_entry, &mv_online_adapter_list);
-
-	return hba_desc;
-}
-
-static void mv_hba_release_modmm(struct pci_dev *dev)
-{
-	struct mv_adp_desc *hba_desc;
-
-	hba_desc = __dev_to_desc(dev);
-
-	if (hba_desc)
-		__mv_release_hba(hba_desc);
-	else
-		MV_PRINT("Weired! dev %p unassociated with any desc.\n", dev);
-}
-
-static inline struct mv_mod_desc *__alloc_mod_desc(void)
-{
-	struct mv_mod_desc *mod_desc;
-
-	mod_desc = hba_mem_alloc(sizeof(struct mv_mod_desc),MV_FALSE);
-	if (mod_desc)
-		memset(mod_desc, 0, sizeof(struct mv_mod_desc));
-	return mod_desc;
-}
-
-struct mv_module_ops *mv_hba_register_module(void)
-{
-	static struct mv_module_ops hba_module_interface = {
-		.module_id              = MODULE_HBA,
-		.get_res_desc           = HBA_ModuleGetResourceQuota,
-		.module_initialize      = HBA_ModuleInitialize,
-		.module_start           = HBA_ModuleStart,
-		.module_stop            = HBA_ModuleShutdown,
-		.module_notification    = HBA_ModuleNotification,
-		.module_sendrequest     = HBA_ModuleSendRequest,
-	};
-
-	return &hba_module_interface;
-}
-
-
-static int register_online_modules(struct mv_adp_desc *hba_desc)
-{
-	struct mv_mod_desc *mod_desc, *prev;
-	struct mv_module_ops *ops;
-
-	/*
-	 * iterate through online_module_list manually , from the lowest(CORE)
-	 * to the highest layer (HBA)
-	 */
-	hba_desc->running_mod_num = 0;
-
-	ops = mv_core_register_module();
-	if (NULL == ops) {
-		MV_PRINT("No core no life.\n");
-		return -1;
-	}
-	mod_desc = __alloc_mod_desc();
-	if (NULL == mod_desc)
-		goto disaster;
-
-	mod_desc->hba_desc	= hba_desc;
-	mod_desc->ops		= ops;
-	mod_desc->status	= MV_MOD_REGISTERED;
-	mod_desc->module_id = MODULE_CORE;
-	mod_desc->child 	= NULL;
-	List_Add(&mod_desc->mod_entry, &hba_desc->online_module_list);
-	hba_desc->running_mod_num++;
-
-	prev = mod_desc;
-	mod_desc = __alloc_mod_desc();
-	if (NULL == mod_desc)
-		goto disaster;
-
-	mod_desc->ops = mv_hba_register_module();
-	if (NULL == mod_desc->ops) {
-		MV_PRINT("No HBA no life.\n");
-		return -1;
-	}
-
-	mod_desc->hba_desc	= hba_desc;
-	mod_desc->status	= MV_MOD_REGISTERED;
-	mod_desc->module_id = MODULE_HBA;
-	mod_desc->child 	= prev;
-	mod_desc->parent	= NULL;
-	prev->parent		= mod_desc;
-	List_Add(&mod_desc->mod_entry, &hba_desc->online_module_list);
-	hba_desc->running_mod_num++;
-
-	return 0;
-disaster:
-	return -1;
-
-}
-
-
-static void __release_consistent_mem(struct mv_mod_res *mod_res,
-				     struct pci_dev *dev)
-{
-	dma_addr_t       dma_addr;
-	MV_PHYSICAL_ADDR phy_addr;
-
-	phy_addr = mod_res->bus_addr;
-	dma_addr = (dma_addr_t) (phy_addr.parts.low |
-				 ((u64) phy_addr.parts.high << 32));
-	pci_free_consistent(dev,
-			    mod_res->size,
-			    mod_res->virt_addr,
-			    dma_addr);
-}
-
-int __alloc_consistent_mem(struct mv_mod_res *mod_res,
-				  struct pci_dev *dev)
-{
-	unsigned long size;
-	dma_addr_t    dma_addr;
-	BUS_ADDRESS   bus_addr;
-	MV_PHYSICAL_ADDR phy_addr;
-
-	size = mod_res->size;
-	size = ROUNDING(size, 8);
-	mod_res->virt_addr = (MV_PVOID) pci_alloc_consistent(dev,
-							     size,
-							     &dma_addr);
-	if (NULL == mod_res->virt_addr) {
-		MV_DPRINT(("unable to alloc 0x%lx consistent mem.\n",
-		       size));
-		return -1;
-	}
-	memset(mod_res->virt_addr, 0, size);
-	bus_addr            = (BUS_ADDRESS) dma_addr;
-	phy_addr.parts.low  = LO_BUSADDR(bus_addr);
-	phy_addr.parts.high = HI_BUSADDR(bus_addr);
-	mod_res->bus_addr   = phy_addr;
-
-	return 0;
-}
-
-
-
-static void __release_resource(struct mv_adp_desc *hba_desc,
-			       struct mv_mod_desc *mod_desc)
-{
-	struct mv_mod_res *mod_res, *tmp;
-
-	LIST_FOR_EACH_ENTRY_SAFE(mod_res,
-				tmp,
-				&mod_desc->res_list,
-				res_entry) {
-		switch (mod_res->type) {
-		case RESOURCE_UNCACHED_MEMORY :
-			__release_consistent_mem(mod_res, hba_desc->dev);
-			break;
-		case RESOURCE_CACHED_MEMORY :
-			hba_mem_free(mod_res->virt_addr,mod_res->size,MV_FALSE);
-			break;
-		default:
-			MV_DPRINT(("res type %d unknown.\n",
-			       mod_res->type));
-			break;
-		}
-		List_Del(&mod_res->res_entry);
-		hba_mem_free(mod_res,sizeof(struct mv_mod_res),MV_FALSE);
-	}
-}
-
-static void __release_module_resource(struct mv_mod_desc *mod_desc)
-{
-	__release_resource(mod_desc->hba_desc, mod_desc);
-}
-
-static int __alloc_module_resource(struct mv_mod_desc *mod_desc,
-				   unsigned int max_io)
-{
-	struct mv_mod_res *mod_res = NULL;
-	unsigned int size = 0;
-
-	/*
-	 * alloc only cached mem at this stage, uncached mem will be alloc'ed
-	 * during mod init.
-	 */
-	MV_LIST_HEAD_INIT(&mod_desc->res_list);
-	mod_res = hba_mem_alloc(sizeof(struct mv_mod_res),MV_FALSE);
-	if (NULL == mod_res)
-		return -1;
-	memset(mod_res, 0, sizeof(sizeof(struct mv_mod_res)));
-	mod_desc->res_entry = 1;
-
-	size = mod_desc->ops->get_res_desc(RESOURCE_CACHED_MEMORY, max_io);
-	if (size) {
-		mod_res->virt_addr = hba_mem_alloc(size,MV_FALSE);
-		if (NULL == mod_res->virt_addr) {
-			hba_mem_free(mod_res,sizeof(struct mv_mod_res),MV_FALSE);
-			MV_DASSERT(MV_FALSE);
-			return -1;
-		}
-		memset(mod_res->virt_addr, 0, size);
-		mod_res->type                = RESOURCE_CACHED_MEMORY;
-		mod_res->size                = size;
-		mod_desc->extension          = mod_res->virt_addr;
-		mod_desc->extension_size     = size;
-		List_Add(&mod_res->res_entry, &mod_desc->res_list);
-	}
-	MV_DPRINT(("show module id[%d] cached size[0x%x], addr[0x%p].\n",mod_desc->module_id,size,mod_res->virt_addr));
-
-	return 0;
-}
-
-static void mv_release_module_resource(struct mv_adp_desc *hba_desc)
-{
-	struct mv_mod_desc *mod_desc;
-
-	LIST_FOR_EACH_ENTRY(mod_desc, &hba_desc->online_module_list,
-			    mod_entry) {
-		if (mod_desc->status == MV_MOD_INITED) {
-			__release_module_resource(mod_desc);
-			mod_desc->status = MV_MOD_REGISTERED;
-		}
-	}
-}
-
-static int mv_alloc_module_resource(struct mv_adp_desc *hba_desc)
-{
-	struct mv_mod_desc *mod_desc;
-	int ret;
-
-	LIST_FOR_EACH_ENTRY(mod_desc, &hba_desc->online_module_list,
-			    mod_entry) {
-		ret = __alloc_module_resource(mod_desc, hba_desc->max_io);
-		if (ret)
-			goto err_out;
-		mod_desc->status = MV_MOD_INITED;
-		__ext_to_gen(mod_desc->extension)->desc = mod_desc;
-	}
-	return 0;
-
-err_out:
-	MV_DPRINT(("error %d allocating resource for mod %d.\n",
-	       ret, mod_desc->module_id));
-	LIST_FOR_EACH_ENTRY(mod_desc, &hba_desc->online_module_list,
-			    mod_entry) {
-		if (mod_desc->status == MV_MOD_INITED) {
-			__release_module_resource(mod_desc);
-			mod_desc->status = MV_MOD_REGISTERED;
-		}
-	}
-	return -1;
-}
-
-struct mv_mod_desc * __get_lowest_module(struct mv_adp_desc *hba_desc)
-{
-	struct mv_mod_desc *p;
-
-	p = LIST_ENTRY(hba_desc->online_module_list.next,
-		       struct mv_mod_desc,
-		       mod_entry);
-
-	WARN_ON(NULL == p);
-	while (p) {
-		if (NULL == p->child)
-			break;
-		p = p->child;
-	}
-	return p;
-}
-
-struct mv_mod_desc * __get_highest_module(struct mv_adp_desc *hba_desc)
-{
-	struct mv_mod_desc *p;
-
-	p = LIST_ENTRY(hba_desc->online_module_list.next,
-		       struct mv_mod_desc,
-		       mod_entry);
-
-	WARN_ON(NULL == p);
-	while (p) {
-		if (NULL == p->parent)
-			break;
-		p = p->parent;
-	}
-	return p;
-}
-
-static void __map_pci_addr(struct pci_dev *dev, MV_PVOID *addr_array)
-{
-	int i;
-	resource_size_t addr;
-	resource_size_t range;
-
-	for (i = 0; i < MAX_BASE_ADDRESS; i++) {
-		addr  = pci_resource_start(dev, i);
-		range = pci_resource_len(dev, i);
-
-		if (pci_resource_flags(dev, i) & IORESOURCE_MEM){
-			addr_array[i] =(MV_PVOID) ioremap(addr, (unsigned long)range);
-		}
-		else{
-			addr_array[i] = (MV_PVOID)((unsigned long)addr);
-		}
-		MV_DPRINT(( "%s : BAR %d : %p.\n", mv_product_name,
-		       i, addr_array[i]));
-	}
-}
-
-static void __unmap_pci_addr(struct pci_dev *dev, MV_PVOID *addr_array)
-{
-	int i;
-
-	for (i = 0; i < MAX_BASE_ADDRESS; i++)
-		if (pci_resource_flags(dev, i) & IORESOURCE_MEM)
-                        iounmap(addr_array[i]);
-}
-
-int __mv_is_mod_all_started(struct mv_adp_desc *adp_desc)
-{
-	struct mv_mod_desc *mod_desc;
-
-	mod_desc = __get_lowest_module(adp_desc);
-
-	while (mod_desc) {
-		if (MV_MOD_STARTED != mod_desc->status)
-			return 0;
-
-		mod_desc = mod_desc->parent;
-	}
-	return 1;
-}
-
-static void __mv_save_hba_configuration(struct mv_adp_desc *hba_desc, void *hba_ext)
-{
-	u8 i;
-	PHBA_Extension phba = (PHBA_Extension)hba_ext;
-	phba->Vendor_Id = hba_desc->Vendor_Id;
-	phba->Device_Id = hba_desc->Device_Id ;
-	phba->Revision_Id = hba_desc->Revision_Id;
-	phba->Sub_Vendor_Id = hba_desc->Sub_Vendor_Id;
-	phba->Sub_System_Id = hba_desc->Sub_System_Id;
-	phba->pcie_max_lnk_spd = hba_desc->pcie_max_lnk_spd;
-	phba->pcie_max_bus_wdth = hba_desc->pcie_max_bus_wdth;
-	phba->pcie_neg_lnk_spd = hba_desc->pcie_neg_lnk_spd;
-	phba->pcie_neg_bus_wdth = hba_desc->pcie_neg_bus_wdth;
-	for (i = 0;i < MAX_BASE_ADDRESS; i++)
-		phba->Base_Address[i] = hba_desc->Base_Address[i];
-
-	MV_DPRINT(( "HBA device id 0x%x, RunAsNonRAID:%x.\n", phba->Device_Id, phba->RunAsNonRAID));
-
-}
-
-static void __hba_module_stop(struct mv_adp_desc *hba_desc)
-{
-	struct mv_mod_desc *mod_desc;
-
-	mod_desc = __get_highest_module(hba_desc);
-	if (NULL == mod_desc)
-		return;
-
-	while (mod_desc) {
-		if (MV_MOD_STARTED == mod_desc->status) {
-			mod_desc->ops->module_stop(mod_desc->extension);
-			mod_desc->status = MV_MOD_INITED;
-		}
-		mod_desc = mod_desc->child;
-	}
-}
-
-struct hba_extension *__mv_get_ext_from_adp_id(int id)
-{
-	struct mv_adp_desc *p;
-
-	LIST_FOR_EACH_ENTRY(p, &mv_online_adapter_list, hba_entry)
-		if (p->id == id)
-			return __get_highest_module(p)->extension;
-
-	return NULL;
-}
-
-extern MV_U8 enable_spin_up(MV_PVOID hba);
-
-int mv_hba_start(struct pci_dev *dev)
-{
-	struct mv_adp_desc *hba_desc;
-	struct mv_mod_desc *mod_desc;
-	struct hba_extension *hba;
-	unsigned long flags;
-	hba_desc = __dev_to_desc(dev);
-
-	if(NULL == (mod_desc = __get_highest_module(hba_desc)))
-		return -1;
-
-	mod_desc->ops->module_start(mod_desc->extension);
-	hba = (struct hba_extension *)mod_desc->extension;
-	if(hba_desc->hba_host == NULL){
-		MV_DPRINT(("Start highest module failed.\n"));
-		return	-1;
-	}
-
-	HBA_GetNextModuleSendFunction(hba, &hba->pNextExtension, &hba->pNextFunction);
-	RAID_Feature_SetSendFunction(hba->p_raid_feature, hba, hba->pNextExtension, hba->pNextFunction);
-
-	ossw_add_timer(&hba->desc->hba_desc->hba_timer,
-		TIMER_INTERVAL_OS, (void (*)(unsigned long))Timer_CheckRequest,(unsigned long)hba);
-
-	mod_desc = __get_lowest_module(hba_desc);
-	if (NULL == mod_desc)
-		return -1;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	atomic_set(&hba_desc->hba_sync, 1);
-#endif
-
-	mod_desc->ops->module_start(mod_desc->extension);
-
-	hba->desc->status = MV_MOD_STARTED;
-	HBA_ModuleStarted(hba);
-	hba_house_keeper_run();
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	if (0 == __hba_wait_for_atomic_timeout(&hba_desc->hba_sync, 1000 * HZ))
-		goto err_wait_cmpl;
-#else
-	if (0 == wait_for_completion_timeout(&hba_desc->cmpl, 1000 * HZ))
-		goto err_wait_cmpl;
-#endif
-
-	if (scsi_add_host(hba_desc->hba_host, &hba_desc->dev->dev))
-		goto err_wait_cmpl;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	if (mv_prot_mask) {
-			scsi_host_set_prot(hba_desc->hba_host, mv_prot_mask);
-	}
-#endif
-
-	if(!enable_spin_up(hba)) {
-		MV_PRINT("Start scsi_scan_host.\n");
-		scsi_scan_host(hba_desc->hba_host);
-		hba->first_scan = 0;
-	}
-
-	MV_DPRINT(("Finished Driver Initialization.\n"));
-
-	return 0;
-
-err_wait_cmpl:
-	MV_PRINT("Timeout waiting for module start.\n");
-	free_irq(hba_desc->dev->irq, hba);
-
-	return -1;
-}
-
-void mv_hba_stop(struct pci_dev *dev)
-{
-	struct mv_adp_desc *hba_desc;
-	MV_DPRINT(("mv_hba_stop: before hba_house_keeper_exit\n"));
-	hba_house_keeper_exit();
-
-	if (dev) {
-		hba_desc = __dev_to_desc(dev);
-		__hba_module_stop(hba_desc);
-	} else {
-		list_for_each_entry(hba_desc, &mv_online_adapter_list, hba_entry)
-			__hba_module_stop(hba_desc);
-	}
-}
-
-void mv_hba_release(struct pci_dev *dev)
-{
-	struct mv_adp_desc *hba_desc;
-
-	hba_desc = __dev_to_desc(dev);
-	MV_DPRINT(("mv_hba_release\n"));
-	if (hba_desc) {
-		__unmap_pci_addr(hba_desc->dev, hba_desc->Base_Address);
-		mv_release_module_resource(hba_desc);
-		mv_hba_release_modmm(hba_desc->dev);
-	}
-}
-
-int mv_hba_init(struct pci_dev *dev, MV_U32 max_io)
-{
-	struct mv_adp_desc *hba_desc;
-	struct mv_mod_desc *mod_desc;
-	PHBA_Extension phba = NULL ;
-	MV_U32 tmp1 = 0, tmp2 = 0;
-
-	int    dbg_ret = 0;
-	hba_desc = mv_hba_init_modmm(dev);
-	if (NULL == hba_desc)
-		goto ext_err_init;
-	hba_desc->dev = dev;
-	hba_desc->max_io = max_io;
-	hba_desc->id     = __mv_get_adapter_count() - 1;
-
-	if (pci_read_config_byte(hba_desc->dev,
-				 PCI_REVISION_ID,
-				 &hba_desc->Revision_Id)) {
-		MV_PRINT("%s : Failed to get hba's revision id.\n",
-		       mv_product_name);
-		goto ext_err_pci;
-	}
-
-	hba_desc->Vendor_Id = dev->vendor;
-	hba_desc->Device_Id = dev->device;
-	hba_desc->Sub_Vendor_Id = dev->subsystem_vendor;
-	hba_desc->Sub_System_Id = dev->subsystem_device;
-	MV_DPRINT(("original device id=%04X.\n",hba_desc->Device_Id));
-
-	if (hba_desc->Device_Id == DEVICE_ID_6440) {
-		if (hba_desc->Sub_System_Id == DEVICE_ID_6480)
-			hba_desc->Device_Id = DEVICE_ID_6480;
-	}
-	__map_pci_addr(dev, hba_desc->Base_Address);
-
-	pci_read_config_dword(dev, 0x7c, &tmp1);;
-	pci_read_config_dword(dev, 0x80, &tmp2);
-
-	hba_desc->pcie_max_lnk_spd = (MV_U8)(tmp1 & 0x0F);
-	hba_desc->pcie_max_bus_wdth = (MV_U8)((tmp1 >> 4) & 0x3F);
-	hba_desc->pcie_neg_lnk_spd = (MV_U8)((tmp2 >> 16) & 0x0F);
-	hba_desc->pcie_neg_bus_wdth = (MV_U8)((tmp2 >> 20) & 0x3F);
-
-	spin_lock_init(&hba_desc->global_lock);
-	spin_lock_init(&hba_desc->device_spin_up);
-
-	MV_DPRINT(( "HBA ext struct init'ed at %p.\n",hba_desc));
-
-	if (register_online_modules(hba_desc))
-		goto ext_err_modmm;
-
-	if (mv_alloc_module_resource(hba_desc))
-		goto ext_err_modmm;
-
-	mod_desc = __get_highest_module(hba_desc);
-	if (NULL == mod_desc)
-		goto ext_err_pci;
-	__mv_save_hba_configuration(hba_desc, mod_desc->extension);
-
-	phba=(PHBA_Extension)mod_desc->extension;
-
-	phba->RunAsNonRAID = 1;
-
-	hba_desc->RunAsNonRAID = phba->RunAsNonRAID;
-
-#ifdef CONFIG_PM
-	mod_desc =  __get_highest_module(hba_desc);
-	pci_set_drvdata(dev,mod_desc);
-#endif
-	mod_desc = __get_lowest_module(hba_desc);
-	if (NULL == mod_desc)
-		goto ext_err_pci;
-
-	hba_desc->alloc_uncahemem_failed = MV_FALSE;
-	while (mod_desc) {
-		if (MV_MOD_INITED != mod_desc->status)
-			continue;
-		mod_desc->ops->module_initialize(mod_desc->extension,
-						 mod_desc->extension_size,
-						 hba_desc->max_io);
-		if (hba_desc->alloc_uncahemem_failed)
-			goto ext_err_pci;
-		mod_desc = mod_desc->parent;
-	}
-
-	return 0;
-
-ext_err_pci:
-	++dbg_ret;
-	mv_release_module_resource(hba_desc);
-ext_err_modmm:
-	++dbg_ret;
-	mv_hba_release_modmm(dev);
-ext_err_init:
-        ++dbg_ret;
-	return dbg_ret;
-}
--- a/drivers/scsi/vanir/linux/hba_mod.h
+++ /dev/null
@@ -1,89 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MODULE_MANAGE_H__
-#define __MODULE_MANAGE_H__
-
-#include "hba_header.h"
-
-/* module management & hba module code */
-extern struct mv_module_ops *mv_core_register_module(void);
-extern struct mv_module_ops *mv_hba_register_module(void);
-
-/* adapter descriptor */
-struct mv_adp_desc {
-	List_Head hba_entry;
-	List_Head  online_module_list;
-	spinlock_t   global_lock;
-	spinlock_t   device_spin_up;
-
-	struct timer_list hba_timer;
-	struct pci_dev    *dev;
-	dev_t   dev_no;
-	struct cdev 	cdev;
-
-	struct Scsi_Host	*hba_host;
-	struct completion		cmpl;
-	struct completion		ioctl_cmpl;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	atomic_t				hba_sync;
-	atomic_t				hba_ioctl_sync;
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
-
-	struct tasklet_struct mv_tasklet;
-	atomic_t		tasklet_active_count;
-	spinlock_t	tasklet_count_lock;
-
-	/* adapter information */
-	MV_U8             Adapter_Bus_Number;
-	MV_U8             Adapter_Device_Number;
-	MV_U8             Revision_Id;
-	MV_U8             id;             /* multi-hba support, start from 0 */
-	MV_U8             running_mod_num;/* number of up & running modules */
-	MV_U8             RunAsNonRAID;
-	MV_U16            RaidMode;
-	MV_U16            Vendor_Id;
-	MV_U16            Device_Id;
-	MV_U16            Sub_System_Id;
-	MV_U16            Sub_Vendor_Id;
-
-	MV_U8		pcie_max_lnk_spd;	/* PCIe Max Supported Link Speed */
-	MV_U8		pcie_max_bus_wdth;	/* PCIe Max Supported Bus Width */
-	MV_U8		pcie_neg_lnk_spd;		/* PCIe Negotiated Link Speed */
-	MV_U8		pcie_neg_bus_wdth;	/* PCIe Negotiated Bus Width */
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-	unsigned int   pci_config_space[16];
-#endif
-	/* System resource */
-	MV_PVOID          Base_Address[ROUNDING(MAX_BASE_ADDRESS, 2)];
-	MV_U32            max_io;
-	MV_BOOLEAN    alloc_uncahemem_failed;
-
-};
-
-int  mv_hba_init(struct pci_dev *dev, MV_U32 max_io);
-void mv_hba_release(struct pci_dev *dev);
-void mv_hba_stop(struct pci_dev *dev);
-int  mv_hba_start(struct pci_dev *dev);
-MV_PVOID *mv_get_hba_extension(struct mv_adp_desc *hba_desc);
-int __mv_get_adapter_count(void);
-void raid_get_hba_page_info( MV_PVOID This);
-struct mv_mod_desc * __get_lowest_module(struct mv_adp_desc *hba_desc);
-struct mv_mod_desc * __get_highest_module(struct mv_adp_desc *hba_desc);
-int __mv_is_mod_all_started(struct mv_adp_desc *adp_desc);
-int __alloc_consistent_mem(struct mv_mod_res *mod_res,
-				  struct pci_dev *dev);
-
-#endif /* __MODULE_MANAGE_H__ */
--- a/drivers/scsi/vanir/linux/hba_priv.c
+++ /dev/null
@@ -1,256 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "hba_header.h"
-#include "hba_api.h"
-#include "hba_mod.h"
-#include "com_struct.h"
-#include "com_nvram.h"
-
- void Core_Flash_BIOS_Version(MV_PVOID extension,PMV_Request req);
-
-/* helper functions related to HBA_ModuleSendRequest */
-void mvGetAdapterInfo( MV_PVOID This, PMV_Request pReq )
-{
-	PHBA_Extension pHBA = (PHBA_Extension)This;
-	MV_PVOID pCore = HBA_GetModuleExtension(This,MODULE_CORE);
-	MV_U8 i;
-	HBA_Info_Page HBA_Info_Param;
-	PAdapter_Info pAdInfo;
-
-	pAdInfo = (PAdapter_Info)pReq->Data_Buffer;
-	MV_ZeroMemory(pAdInfo, sizeof(Adapter_Info));
-	pAdInfo->DriverVersion.VerMajor = VER_MAJOR;
-	pAdInfo->DriverVersion.VerMinor = VER_MINOR;
-	pAdInfo->DriverVersion.VerOEM = VER_OEM;
-	pAdInfo->DriverVersion.VerBuild = VER_BUILD;
-
-	pAdInfo->SystemIOBusNumber = pHBA->Adapter_Bus_Number;
-	pAdInfo->SlotNumber = pHBA->Adapter_Device_Number;
-	pAdInfo->VenID = pHBA->Vendor_Id;
-	pAdInfo->DevID = pHBA->Device_Id;
-	pAdInfo->SubDevID = pHBA->Sub_System_Id;
-	pAdInfo->SubVenID = pHBA->Sub_Vendor_Id;
-	pAdInfo->RevisionID = pHBA->Revision_Id;
-	pAdInfo->AdvancedFeatures|=ADV_FEATURE_EVENT_WITH_SENSE_CODE;
-	pAdInfo->AdvancedFeatures|=ADV_FEATURE_BIOS_OPTION_SUPPORT;
-	pAdInfo->AdvancedFeatures|=ADV_FEATURE_NO_MUTIL_VD_PER_PD;
-	pAdInfo->MaxBufferSize = 1;
-	if ( pHBA->Device_Id == DEVICE_ID_THORLITE_2S1P ||
-		pHBA->Device_Id == DEVICE_ID_THORLITE_2S1P_WITH_FLASH ) {
-		pAdInfo->PortCount = 3;
-		pAdInfo->PortSupportType = HD_TYPE_SATA | HD_TYPE_PATA;
-	} else if (pHBA->Device_Id == DEVICE_ID_THORLITE_0S1P) {
-		pAdInfo->PortCount = 1;
-		pAdInfo->PortSupportType = HD_TYPE_SATA | HD_TYPE_PATA;
-	} else if ((pHBA->Device_Id == DEVICE_ID_6440) ||
-			   (pHBA->Device_Id == DEVICE_ID_6445) ||
-			   (pHBA->Device_Id == DEVICE_ID_6340)||
-			   (pHBA->Device_Id == DEVICE_ID_9440) ||
-			   (pHBA->Device_Id == DEVICE_ID_9445)) {
-		pAdInfo->PortCount = 4;
-		pAdInfo->PortSupportType = HD_TYPE_SATA | HD_TYPE_SAS;
-	} else if ((pHBA->Device_Id == DEVICE_ID_6485) ||
-			(pHBA->Device_Id == DEVICE_ID_6480 )||
-                           (pHBA->Device_Id == DEVICE_ID_9480) ||
-                           (pHBA->Device_Id == DEVICE_ID_9485) ||
-                           (pHBA->Device_Id == DEVICE_ID_948F)) {
-		pAdInfo->PortCount = 8;
-		pAdInfo->PortSupportType = HD_TYPE_SATA | HD_TYPE_SAS;
-	} else if (pHBA->Device_Id == DEVICE_ID_6320) {
-		pAdInfo->PortCount = 2;
-		pAdInfo->PortSupportType = HD_TYPE_SATA | HD_TYPE_SAS;
-	} else {
-		pAdInfo->PortCount = 5;
-		pAdInfo->PortSupportType = HD_TYPE_SATA | HD_TYPE_SAS;
-	}
-
-	if(mv_nvram_init_param(pHBA, &HBA_Info_Param)) {
-		for(i=0;i<=19;i++)
-			pAdInfo->SerialNo[i] = HBA_Info_Param.Serial_Num[i];
-		for(i=0;i<=19;i++)
-			pAdInfo->ModelNumber[i] = HBA_Info_Param.model_number[i];
-	}
-	if(MAX_DEVICE_SUPPORTED_PERFORMANCE <= 0xFF)
-		pAdInfo->MaxHD = (MV_U8)MAX_DEVICE_SUPPORTED_PERFORMANCE;
-	else
-		pAdInfo->MaxHD_Ext = MAX_DEVICE_SUPPORTED_PERFORMANCE;
-	pAdInfo->MaxExpander = MAX_EXPANDER_SUPPORTED;
-	pAdInfo->MaxPM = MAX_PM_SUPPORTED;
-
-	pAdInfo->MaxSpeed = pHBA->pcie_max_lnk_spd;
-	pAdInfo->MaxLinkWidth = pHBA->pcie_max_bus_wdth;
-	pAdInfo->CurrentSpeed = pHBA->pcie_neg_lnk_spd;
-	pAdInfo->CurrentLinkWidth = pHBA->pcie_neg_bus_wdth;
-
-	pAdInfo->SystemIOBusNumber = pHBA->desc->hba_desc->dev->bus->number;
-	pAdInfo->SlotNumber  = PCI_SLOT(pHBA->desc->hba_desc->dev->devfn);
-	pAdInfo->InterruptLevel = pHBA->desc->hba_desc->dev->irq;
-	pAdInfo->InterruptVector = pHBA->desc->hba_desc->dev->irq;
-
-	Core_Flash_BIOS_Version(pCore,pReq);
-
-	pReq->Scsi_Status = REQ_STATUS_SUCCESS;
-}
-
-void HBA_ModuleSendRequest(MV_PVOID this, PMV_Request req)
-{
-	PHBA_Extension phba = (PHBA_Extension) this;
-
-	if (phba->RunAsNonRAID) {
-		switch (req->Cdb[0]) {
-		case APICDB0_ADAPTER:
-			if (req->Cdb[1] == APICDB1_ADAPTER_GETINFO) {
-				mvGetAdapterInfo(phba, req);
-				req->Completion(req->Cmd_Initiator, req);
-			} else if (req->Cdb[1] == APICDB1_ADAPTER_GETCONFIG) {
-				mvGetAdapterConfig(phba->p_raid_feature,req);
-				req->Completion(req->Cmd_Initiator, req);
-			} else if (req->Cdb[1] == APICDB1_ADAPTER_SETCONFIG) {
-				mvSetAdapterConfig(phba->p_raid_feature,req);
-				req->Completion(req->Cmd_Initiator, req);
-			} else {
-				req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-				req->Completion(req->Cmd_Initiator, req);
-			}
-			break;
-		case APICDB0_EVENT:
-			if (req->Cdb[1] == APICDB1_EVENT_GETEVENT)
-				get_event(phba, req);
-			else
-				req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-
-			req->Completion(req->Cmd_Initiator, req);
-			break;
-		case APICDB0_LD:
-		case APICDB0_BLOCK:
-			req->Scsi_Status = REQ_STATUS_SUCCESS;
-			req->Completion(req->Cmd_Initiator, req);
-			break;
-		case APICDB0_PD:
-		case APICDB0_FLASH:
-		case APICDB0_PASS_THRU_CMD_SCSI:
-		case APICDB0_PASS_THRU_CMD_ATA:
-		case API_SCSI_CMD_RCV_DIAG_RSLT:
-		case API_SCSI_CMD_SND_DIAG:
-			phba->desc->child->ops->module_sendrequest(
-				phba->desc->child->extension,req);
-			break;
-		case APICDB0_IOCONTROL:
-			if (req->Cdb[1] == APICDB1_GET_OS_DISK_INFO) {
-				phba->desc->child->ops->module_sendrequest(
-					phba->desc->child->extension,req);
-			}
-			break;
-		case SCSI_CMD_REPORT_LUN:
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-				req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-				req->Completion(req->Cmd_Initiator, req);
-			} else {
-				phba->desc->child->ops->module_sendrequest(
-				phba->desc->child->extension,req);
-			}
-
-			break;
-		case SCSI_CMD_REQUEST_SENSE:
-			if (req->Device_Id == VIRTUAL_DEVICE_ID) {
-				sg_map(req);
-				if (req->Sense_Info_Buffer!= NULL) {
-					((MV_PU8)req->Sense_Info_Buffer)[0] = 0x70;		/* Current */
-					((MV_PU8)req->Sense_Info_Buffer)[2] = 0x00;		/* Sense Key*/
-					((MV_PU8)req->Sense_Info_Buffer)[7] = 0x00;		/* additional sense length */
-					((MV_PU8)req->Sense_Info_Buffer)[12] = 0x00;	/* additional sense code */
-				}
-				sg_unmap(req);
-				req->Scsi_Status = REQ_STATUS_SUCCESS;
-				req->Completion(req->Cmd_Initiator, req);
-			} else {
-				phba->desc->child->ops->module_sendrequest(
-				phba->desc->child->extension,req);
-			}
-			break;
-		default:
-			phba->desc->child->ops->module_sendrequest(
-				phba->desc->child->extension,req);
-
-			break;
-		}
-	} else {
-		switch (req->Cdb[0]) {
-		case APICDB0_ADAPTER:
-			if (req->Cdb[1] == APICDB1_ADAPTER_GETINFO) {
-				mvGetAdapterInfo(phba, req);
-				req->Completion(req->Cmd_Initiator, req);
-			} else if (req->Cdb[1] == APICDB1_ADAPTER_GETCONFIG) {
-				mvGetAdapterConfig(phba->p_raid_feature,req);
-				req->Completion(req->Cmd_Initiator, req);
-			} else if (req->Cdb[1] == APICDB1_ADAPTER_SETCONFIG) {
-				mvSetAdapterConfig(phba->p_raid_feature,req);
-				req->Completion(req->Cmd_Initiator, req);
-			} else if (req->Cdb[1] == APICDB1_ADAPTER_POWER_STATE_CHANGE){
-				phba->desc->child->ops->module_sendrequest(
-				phba->desc->child->extension,req);
-			} else if (req->Cdb[1] == APICDB1_ADAPTER_MUTE) {
-				phba->desc->child->ops->module_sendrequest(
-				phba->desc->child->extension,req);
-			} else {
-				req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-				req->Completion(req->Cmd_Initiator, req);
-			}
-			break;
-		case APICDB0_EVENT:
-			if (req->Cdb[1] == APICDB1_EVENT_GETEVENT)
-				get_event(phba, req);
-			else
-				req->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-
-			req->Completion(req->Cmd_Initiator, req);
-			break;
-		default:
-			phba->desc->child->ops->module_sendrequest(
-				phba->desc->child->extension,req);
-			break;
-		}
-	}
-}
-
- MV_BOOLEAN mv_nvram_init_param( MV_PVOID This, pHBA_Info_Page pHBA_Info_Param);
-
- MV_U32 Core_ModuleGetResourceQuota(enum Resource_Type type, MV_U16 max_io);
- MV_VOID Core_ModuleInitialize(MV_PVOID module, MV_U32 size, MV_U16 max_io);
- MV_VOID Core_ModuleStart(MV_PVOID This);
- MV_VOID Core_ModuleShutdown(MV_PVOID core_p);
- MV_VOID Core_ModuleNotification(MV_PVOID core_p, enum Module_Event event,
-	 struct mod_notif_param *param);
- MV_VOID Core_ModuleSendRequest(MV_PVOID core_p, PMV_Request req);
- MV_VOID Core_ModuleReset(MV_PVOID core_p);
- MV_VOID Core_ModuleMonitor(MV_PVOID core_p);
- MV_BOOLEAN Core_InterruptCheckIRQ(MV_PVOID This);
-
-struct mv_module_ops *mv_core_register_module(void)
-{
-	static struct mv_module_ops __core_mod_ops = {
-		.module_id              = MODULE_CORE,
-		.get_res_desc           = Core_ModuleGetResourceQuota,
-		.module_initialize      = Core_ModuleInitialize,
-		.module_start           = Core_ModuleStart,
-		.module_stop            = Core_ModuleShutdown,
-		.module_notification    = Core_ModuleNotification,
-		.module_sendrequest     = Core_ModuleSendRequest,
-		.module_reset           = Core_ModuleReset,
-		.module_monitor         = Core_ModuleMonitor,
-		.module_service_isr 	= Core_InterruptCheckIRQ,
-	};
-
-	return &__core_mod_ops;
-}
--- a/drivers/scsi/vanir/linux/hba_timer.c
+++ /dev/null
@@ -1,478 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "hba_header.h"
-#include "hba_exp.h"
-#include "hba_mod.h"
-#include "hba_timer.h"
-
-#define KEEPER_SHIFT (HZ >> 1)
-
-static struct mv_hba_msg_queue mv_msg_queue;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-static struct task_struct *house_keeper_task = NULL;
-#endif
-
-static int shutdown = 0;
-static int __msg_queue_state;
-
-static inline int queue_state_get(void)
-{
-	return __msg_queue_state;
-}
-
-static inline void queue_state_set(int state)
-{
-	__msg_queue_state = state;
-}
-MV_U8 pal_set_down_disk_from_upper(void *ext, MV_U16 device_target_id, MV_U16 device_lun);
-MV_U8 pal_check_disk_exist(void *ext, MV_U16 device_target_id, MV_U16 device_lun);
-static void hba_proc_msg(struct mv_hba_msg *pmsg)
-{
-	PHBA_Extension phba;
-	struct scsi_device *psdev=NULL;
-	struct mv_adp_desc *hba_desc;
-	struct mv_lu *lu = NULL;
-	MV_U16 dev_id;
-	MV_U16 dev_lun = (MV_U16)(pmsg->param>>16)&0xffff;
-	unsigned long flags;
-
-	if (NULL == pmsg->data){
-		MV_DPRINT(( "__MV__ In hba_proc_msg pmsg->data == NULL return.\n"));
-		return;
-	}
-
-	phba = (PHBA_Extension) pmsg->data;
-	hba_desc= phba->desc->hba_desc;
-	dev_id = (MV_U16)pmsg->param;
-	dev_lun = (MV_U16)(pmsg->param>>16)&0xffff;
-	lu = mv_get_device_by_target_lun(phba, dev_id, dev_lun);
-	MV_DPRINT(( "__MV__ In hba_proc_msg.\n"));
-
-	MV_ASSERT(pmsg);
-	MV_ASSERT(phba->desc->hba_desc->hba_host);
-
-	switch (pmsg->msg) {
-	case EVENT_DEVICE_ARRIVAL:
-		if(lu == NULL)
-			lu = mv_get_avaiable_device(phba, dev_id, dev_lun);
-		if (lu == NULL){
-			MV_ASSERT(lu != NULL);
-			return;
-		}
-		if ( lu->sdev ) {
-			MV_DPRINT(( "__MV__ add scsi disk %d-%d-%d failed, it existed.\n", 0, dev_id, dev_lun));
-			break;
-		}
-		if (scsi_add_device(hba_desc->hba_host, 0, dev_id, dev_lun)) {
-			MV_DPRINT(( "__MV__ add scsi disk %d-%d-%d failed.\n", 0, dev_id, dev_lun));
-			if (hba_desc->RunAsNonRAID) {
-				spin_lock_irqsave(&hba_desc->global_lock, flags);
-				pal_set_down_disk_from_upper(phba, dev_id, dev_lun);
-				spin_unlock_irqrestore(&hba_desc->global_lock, flags);
-			}
-			else
-				MV_ASSERT(0);
-		} else {
-			MV_DPRINT(( "__MV__ add scsi disk %d-%d-%d.\n", 0, dev_id, dev_lun));
-		}
-		break;
-	case EVENT_DEVICE_REMOVAL:
-		if (lu == NULL){
-			MV_ASSERT(lu != NULL);
-			return;
-		}
-		psdev = lu->sdev;
-		if ( psdev ) {
-			if ( scsi_device_get(psdev) != 0 ) {
-				WARN_ON(1);
-				MV_DPRINT(("__MV__ no disk to remove %d-%d-%d\n", 0, psdev->id, psdev->lun));
-				psdev = NULL;
-			}
-		}
-		if ( psdev) {
-			MV_DPRINT((  "__MV__ remove scsi disk %d-%d-%d.\n", 0,psdev->id, psdev->lun));
-			scsi_remove_device(psdev);
-			scsi_device_put(psdev);
-		}
-		break;
-	default:
-		break;
-	}
-}
-MV_U8	need_rescan = MV_FALSE;
-void *rescan_hba=NULL;
-
-int	hba_scan_host(void)
-{
-	MV_U32 target=0, lun=0;
-	int res= 0;
-	struct mv_lu * lu=NULL;
-	PHBA_Extension phba;
-	unsigned long flags;
-	spin_lock_irqsave(&mv_msg_queue.lock, flags);
-	if ((need_rescan == MV_FALSE) || !rescan_hba) {
-		spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
-		return 0;
-	}
-	phba = (PHBA_Extension)rescan_hba;
-	need_rescan = MV_FALSE;
-	rescan_hba = NULL;
-	spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
-
-	if (!phba->RunAsNonRAID){
-		return 0;
-	}
-
-	MV_DPRINT(("start scan host.\n"));
-	for (target =0; target < MV_MAX_TARGET_NUMBER; target++) {
-		lu = mv_get_device_by_target_lun(phba, target, lun);
-		res = pal_check_disk_exist(phba, target, lun);
-		if (res && (!lu || !lu->sdev)){
-			MV_DPRINT(("device %d-%d has added.\n", target, lun));
-			hba_msg_insert(phba, EVENT_DEVICE_ARRIVAL, target | (lun << 16));
-		} else if (!res && (lu && lu->sdev)){
-			MV_DPRINT(("device %d-%d has gone.\n", target, lun));
-			hba_msg_insert(phba, EVENT_DEVICE_REMOVAL, target | (lun << 16));
-		}
-	}
-	MV_DPRINT(("finshed scan host.\n"));
-	return 0;
-}
-
-
-static void mv_proc_queue(void)
-{
-	struct mv_hba_msg *pmsg;
-	unsigned long flags;
-
-	queue_state_set(MSG_QUEUE_PROC);
-
-	while (1) {
-		MV_DPRINT((  "__MV__ process queue starts.\n"));
-		spin_lock_irqsave(&mv_msg_queue.lock, flags);
-		if (List_Empty(&mv_msg_queue.tasks)) {
-			queue_state_set(MSG_QUEUE_IDLE);
-			spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
-			MV_DPRINT((  "__MV__ process queue ends.\n"));
-			break;
-		}
-		pmsg = LIST_ENTRY(mv_msg_queue.tasks.next, struct mv_hba_msg, msg_list);
-		spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
-		if (NULL == pmsg) {
-			MV_DPRINT((   "__MV__ pmsg == NULL .\n"));
-			return;
-		}
-		hba_proc_msg(pmsg);
-		pmsg->data = NULL;
-
-		spin_lock_irqsave(&mv_msg_queue.lock, flags);
-		List_MoveTail(&pmsg->msg_list, &(mv_msg_queue.free));
-		spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
-		MV_DPRINT((  "__MV__ process queue ends.\n"));
-	}
-	hba_scan_host();
-}
-
-static inline MV_U32 hba_msg_queue_empty(void)
-{
-	return List_Empty(&(mv_msg_queue.tasks));
-}
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
-#ifdef TIMER_INITIALIZER
-#undef TIMER_INITIALIZER
-#endif
-#define TIMER_INITIALIZER(_function, _expires, _data) {		\
-		.function = (_function),		\
-		.expires = (_expires),			\
-		.data = (_data),				\
-		.base = NULL,					\
-		.magic = TIMER_MAGIC,		\
-	}
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static void mv_wq_handler(void *work)
-#else
-static void mv_wq_handler(struct work_struct *work)
-#endif
-{
-	if (hba_msg_queue_empty()) {
-		MV_DPRINT(("__MV__  msg queue is empty.\n"));
-		return;
-	} else if (!hba_msg_queue_empty() &&
-		MSG_QUEUE_IDLE == queue_state_get()) {
-		MV_DPRINT(("__MV__  msg queue isn't empty.\n"));
-		mv_proc_queue();
-	}
-}
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static DECLARE_WORK(mv_wq, mv_wq_handler,NULL);
-#else
-static DECLARE_WORK(mv_wq, mv_wq_handler);
-#endif
-
-static void hba_msg_queue_init(void)
-{
-	int i;
-
-	memset(&mv_msg_queue, 0, sizeof(sizeof(struct mv_hba_msg_queue)));
-	spin_lock_init(&mv_msg_queue.lock);
-
-	MV_LIST_HEAD_INIT(&(mv_msg_queue.free));
-	MV_LIST_HEAD_INIT(&(mv_msg_queue.tasks));
-
-	for (i = 0; i < MSG_QUEUE_DEPTH; i++) {
-		List_AddTail(&mv_msg_queue.msgs[i].msg_list,
-			      &mv_msg_queue.free);
-	}
-
-}
-
-void hba_house_keeper_init(void)
-{
-	hba_msg_queue_init();
-	queue_state_set(MSG_QUEUE_NO_START);
-}
-
-void hba_house_keeper_run(void)
-{
-	queue_state_set(MSG_QUEUE_IDLE);
-}
-
-void hba_house_keeper_exit(void)
-{
-	queue_state_set(MSG_QUEUE_NO_START);
-	flush_scheduled_work();
-	return ;
-}
-
-void hba_msg_insert(void *data, unsigned int msg, unsigned int param)
-{
-	struct mv_hba_msg *pmsg;
-	unsigned long flags;
-
-	MV_DPRINT(( "__MV__ msg insert  %d.\n", msg));
-	spin_lock_irqsave(&mv_msg_queue.lock, flags);
-	if (List_Empty(&mv_msg_queue.free)) {
-		MV_DPRINT(("-- MV -- Message queue is full.\n"));
-		need_rescan = MV_TRUE;
-		rescan_hba = data;
-		spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
-		return;
-	}
-
-	MV_DPRINT((   "__MV__ Message queue is not full.\n"));
-	pmsg = LIST_ENTRY(mv_msg_queue.free.next, struct mv_hba_msg, msg_list);
-	spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
-
-	pmsg->data = data;
-	pmsg->msg  = msg;
-
-	switch (msg) {
-	case EVENT_DEVICE_REMOVAL:
-	case EVENT_DEVICE_ARRIVAL:
-		pmsg->param = param;
-		break;
-	default:
-		pmsg->param = param;
-		break;
-	}
-
-	spin_lock_irqsave(&mv_msg_queue.lock, flags);
-	List_MoveTail(&pmsg->msg_list, &mv_msg_queue.tasks);
-	spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
-
-	schedule_work(&mv_wq);
-}
-
-MV_U16 Timer_GetRequestCount(MV_U16 maxIo)
-{
-	MV_U16 reqCount;
-
-	if (maxIo==1)
-		reqCount = MAX_DEVICE_SUPPORTED_PERFORMANCE;
-	else
-		reqCount = (MAX_DEVICE_SUPPORTED_PERFORMANCE + 1) * 2;
-	return reqCount;
-}
-
-MV_U32 Timer_GetResourceQuota(MV_U16 maxIo)
-{
-	MV_U32 sz;
-	MV_U16 reqCount;
-
-	reqCount = Timer_GetRequestCount(maxIo);
-	/* Memory for timer tag pool */
-	sz = ROUNDING((sizeof(MV_U16) * reqCount), 8);
-	/* Memory for timer request array */
-	sz += ROUNDING((sizeof(PTimer_Request) * reqCount), 8);
-	/* Memory for timer request */
-	sz += ROUNDING((sizeof(Timer_Request) * reqCount), 8);
-	return sz;
-}
-
-void Timer_Initialize(
-	IN  MV_PVOID This,
-	IN MV_PU8 pool,
-	IN MV_U16 max_io
-	)
-{
-	PHBA_Extension pHBA = (PHBA_Extension)This;
-	PTimer_Module	pTimer=(PTimer_Module)&pHBA->TimerModule;
-	MV_PTR_INTEGER temp = (MV_PTR_INTEGER)pool;
-	PTimer_Request pTimerReq;
-	MV_U16 i, reqCount;
-
-	ossw_init_timer(&pHBA->desc->hba_desc->hba_timer);
-
-	reqCount = Timer_GetRequestCount(max_io);
-	pTimer->Timer_Request_Number = reqCount;
-	MV_DPRINT(("Timer_Request_Number = %d.\n", pTimer->Timer_Request_Number));
-	/* allocate memory for timer request tag pool */
-	pTimer->Tag_Pool.Stack = (MV_PU16)temp;
-	pTimer->Tag_Pool.Size = reqCount;
-	temp += sizeof(MV_U16) * reqCount;
-	Tag_Init( &pTimer->Tag_Pool, reqCount );
-
-	U64_ZERO_VALUE(pTimer->Time_Stamp);
-	MV_ASSERT( sizeof(Timer_Request)==ROUNDING(sizeof(Timer_Request),8) );
-	/* allocate memory for timer request array */
-	pTimer->Running_Requests = (PTimer_Request *)temp;
-	temp += sizeof(PTimer_Request) * reqCount;
-	for (i = 0; i < reqCount; i++) {
-		pTimerReq = (PTimer_Request)temp;
-		U64_ZERO_VALUE(pTimerReq->Time_Stamp);
-		pTimer->Running_Requests[i] = pTimerReq;
-		temp += sizeof( Timer_Request );
-	}
-}
-
-void Timer_Stop(MV_PVOID This)
-{
-	PHBA_Extension pHBA = (PHBA_Extension)This;
-	ossw_del_timer(&pHBA->desc->hba_desc->hba_timer);
-}
-
-MV_U16 Timer_AddSmallRequest(
-	IN MV_PVOID extension,
-	IN MV_U32 time_unit,
-	IN MV_VOID (*routine) (MV_PVOID, MV_PVOID),
-	IN MV_PVOID context1,
-	IN MV_PVOID context2
-	)
-{
-	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(extension, MODULE_HBA);
-	PTimer_Module pTimer = &pHBA->TimerModule;
-	PTimer_Request pTimerReq;
-	MV_U16 index;
-
-	if (!Tag_IsEmpty( &pTimer->Tag_Pool )) {
-		index = Tag_GetOne( &pTimer->Tag_Pool );
-		pTimerReq = pTimer->Running_Requests[index];
-
-		pTimerReq->Valid = MV_TRUE;
-		pTimerReq->Context1 = context1;
-		pTimerReq->Context2 = context2;
-		pTimerReq->Routine = routine;
-		pTimerReq->Time_Stamp = U64_ADD_U32(pTimer->Time_Stamp,
-			time_unit * TIMER_INTERVAL_SMALL_UNIT );
-
-		return index;
-	}
-
-	MV_DASSERT( MV_FALSE );
-	return NO_CURRENT_TIMER;
-}
-
-MV_U16 Timer_AddRequest(
-	IN MV_PVOID extension,
-	IN MV_U32 time_unit,
-	IN MV_VOID (*routine) (MV_PVOID, MV_PVOID),
-	IN MV_PVOID context1,
-	IN MV_PVOID context2
-	)
-{
-	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(extension, MODULE_HBA);
-	PTimer_Module pTimer = &pHBA->TimerModule;
-	PTimer_Request pTimerReq;
-	MV_U16 index;
-
-	if (!Tag_IsEmpty( &pTimer->Tag_Pool)) {
-		index = (MV_U16)Tag_GetOne( &pTimer->Tag_Pool );
-		pTimerReq = pTimer->Running_Requests[index];
-
-		pTimerReq->Valid = MV_TRUE;
-		pTimerReq->Context1 = context1;
-		pTimerReq->Context2 = context2;
-		pTimerReq->Routine = routine;
-		pTimerReq->Time_Stamp = U64_ADD_U32(pTimer->Time_Stamp,
-			time_unit * TIMER_INTERVAL_LARGE_UNIT );
-		return index;
-	}
-
-	MV_DPRINT(("Timer_AddRequest: no enough timer slots \n"));
-	MV_DASSERT( MV_FALSE );
-	return NO_CURRENT_TIMER;
-}
-
-void Timer_CheckRequest(
-	IN MV_PVOID extension
-	)
-{
-	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(extension, MODULE_HBA);
-	PTimer_Module pTimer = &pHBA->TimerModule;
-	PTimer_Request pTimerReq;
-	MV_PVOID core = NULL;
-	MV_U16 i;
-
-	spin_lock_bh(&pHBA->desc->hba_desc->global_lock);
-	pTimer->Time_Stamp = U64_ADD_U32(pTimer->Time_Stamp, TIMER_INTERVAL_OS);
-	for (i=0; i<pTimer->Timer_Request_Number; i++) {
-		pTimerReq = pTimer->Running_Requests[i];
-		if (pTimerReq && pTimerReq->Valid && (pTimerReq->Time_Stamp.value <= pTimer->Time_Stamp.value)) {
-			MV_DASSERT( pTimerReq->Routine != NULL );
-			pTimerReq->Routine( pTimerReq->Context1, pTimerReq->Context2 );
-			if (pTimerReq->Valid) {
-				pTimerReq->Valid = MV_FALSE;
-				Tag_ReleaseOne( &pTimer->Tag_Pool, i );
-			}
-		}
-	}
-	core = (MV_PVOID)HBA_GetModuleExtension(extension, MODULE_CORE);
-	core_push_queues(core);
-	mod_timer(&pHBA->desc->hba_desc->hba_timer, jiffies + msecs_to_jiffies(TIMER_INTERVAL_OS));
-	spin_unlock_bh(&pHBA->desc->hba_desc->global_lock);
-}
-
-void Timer_CancelRequest(
-	IN MV_PVOID extension,
-	IN MV_U16 request_index
-	)
-{
-	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(extension, MODULE_HBA);
-	PTimer_Module pTimer = &pHBA->TimerModule;
-	PTimer_Request pTimerReq;
-
-	if (request_index < pTimer->Timer_Request_Number) {
-		pTimerReq = pTimer->Running_Requests[request_index];
-
-		if(pTimerReq->Valid && (pTimerReq->Time_Stamp.value >=  pTimer->Time_Stamp.value)) {
-			pTimerReq->Valid = MV_FALSE;
-			Tag_ReleaseOne( &pTimer->Tag_Pool, (MV_U16)request_index );
-		}
-	}
-}
--- a/drivers/scsi/vanir/linux/hba_timer.h
+++ /dev/null
@@ -1,62 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __HBA_TIMER_H__
-#define __HBA_TIMER_H__
-
-#include "com_tag.h"
-#include "hba_exp.h"
-
-enum _tag_hba_msg_state{
-	MSG_QUEUE_IDLE=0,
-	MSG_QUEUE_PROC,
-	MSG_QUEUE_NO_START
-};
-
-struct mv_hba_msg {
-	MV_PVOID data;
-	MV_U32   msg;
-	MV_U32   param;
-	List_Head msg_list;
-};
-
-struct mv_hba_msg_queue {
-	spinlock_t lock;
-	List_Head free;
-	List_Head tasks;
-	struct mv_hba_msg msgs[MSG_QUEUE_DEPTH];
-};
-
-enum {
-	HBA_TIMER_IDLE = 0,
-	HBA_TIMER_RUNNING,
-	HBA_TIMER_LEAVING,
-};
-void hba_house_keeper_init(void);
-void hba_house_keeper_run(void);
-void hba_house_keeper_exit(void);
-void hba_msg_insert(void *data, unsigned int msg, unsigned int param);
-void hba_init_timer(PMV_Request req);
-void hba_remove_timer(PMV_Request req);
-void hba_remove_timer_sync(PMV_Request req);
-void hba_add_timer(PMV_Request req, int timeout,
-		   MV_VOID (*function)(MV_PVOID data));
-extern struct mv_lu *mv_get_device_by_target_lun(struct hba_extension *hba, MV_U16  target_id, MV_U16 lun);
-extern struct mv_lu *mv_get_avaiable_device(struct hba_extension * hba, MV_U16 target_id, MV_U16 lun);
-extern MV_U16 get_id_by_targetid_lun(MV_PVOID ext, MV_U16 id,MV_U16 lun);
-
-#define TIMER_INTERVAL_OS		1000		/* millisecond */
-#define TIMER_INTERVAL_LARGE_UNIT	500		/* millisecond */
-#define TIMER_INTERVAL_SMALL_UNIT	100		/* millisecond */
-
-#endif /* __HBA_TIMER_H__ */
--- a/drivers/scsi/vanir/linux/linux_iface.c
+++ /dev/null
@@ -1,844 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include <linux/hdreg.h>
-#include "linux_main.h"
-#include "linux_iface.h"
-#include "hba_mod.h"
-#include <scsi/scsi_eh.h>
-
-#define SECTOR_SIZE 512
-#define HBA_REQ_TIMER_IOCTL (15)
-
-#define MV_DEVFS_NAME "mv"
-#define IOCTL_BUF_LEN (1024*1024)
-
-void ioctlcallback(MV_PVOID This, PMV_Request req)
-{
-	struct hba_extension *hba = (struct hba_extension *) This;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	atomic_set(&hba->desc->hba_desc->hba_ioctl_sync, 0);
-#else
-	complete(&hba->desc->hba_desc->ioctl_cmpl);
-#endif
-
-	hba_req_cache_free(hba,req);
-}
-
-int mv_linux_proc_info(struct Scsi_Host *pSHost, char *pBuffer,
-		       char **ppStart,off_t offset, int length, int inout)
-{
-	int len = 0;
-	int datalen = 0;
-	if (!pSHost || !pBuffer)
-		return (-ENOSYS);
-
-	if (inout == 1) {
-		return (-ENOSYS);
-	}
-
-	len = sprintf(pBuffer,"Marvell %s Driver , Version %s\n",
-		      mv_product_name, mv_version_linux);
-
-	datalen = len - offset;
-	if (datalen < 0) {
-		datalen = 0;
-		*ppStart = pBuffer + len;
-	} else {
-		*ppStart = pBuffer + offset;
-	}
-	return datalen;
-}
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
-typedef struct mutex  mutex_t;
-#else
-typedef struct semaphore  mutex_t;
-#define mutex_init(lock)  sema_init(lock, 1)
-#define mutex_lock(lock)  down(lock)
-#define mutex_unlock(lock)  up(lock)
-#endif
-
-static mutex_t  ioctl_index_mutex;
-
-void * kbuf_array[512] = {NULL,};
-unsigned char mvcdb[512][16];
-unsigned long kbuf_index[512/8] = {0,};
-
-static inline int mv_is_api_cmd(int cmd)
-{
-	return (cmd >= API_BLOCK_IOCTL_DEFAULT_FUN) && \
-		(cmd < API_BLOCK_IOCTL_DEFAULT_FUN + API_IOCTL_MAX );
-}
-
-/* ATA_16(0x85) SAT command and 0xec for Identify */
-char ata_ident[] = {0x85, 0x08, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0x00};
-
-/**
- *	id_to_string - Convert IDENTIFY DEVICE page into string
- *	@iden: IDENTIFY DEVICE results we will examine
- *	@s: string into which data is output
- *	@ofs: offset into identify device page
- *	@len: length of string to return. must be an even number.
- *
- *	The strings in the IDENTIFY DEVICE page are broken up into
- *	16-bit chunks.  Run through the string, and output each
- *	8-bit chunk linearly, regardless of platform.
- *
- */
-static void id_to_string(const u16 *iden, unsigned char *s,
-		   unsigned int ofs, unsigned int len)
-{
-	unsigned int c;
-	while (len > 0) {
-		c = iden[ofs] >> 8;
-		*s = c;
-		s++;
-
-		c = iden[ofs] & 0xff;
-		*s = c;
-		s++;
-
-		ofs++;
-		len -= 2;
-	}
-}
-static int io_get_identity(void *kbuf)
-{
-	char buf[40];
-	u16 *dst = kbuf;
-	unsigned int i,j;
-
-	if (!dst)
-		return -1;
-
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-        for (i = 0; i < 256; i++)
-                dst[i] = MV_LE16_TO_CPU(dst[i]);
-#endif
-
-	/*identify data -> model number: word 27-46*/
-	id_to_string(dst, buf, 27, 40);
-	memcpy(&dst[27], buf, 40);
-
-	/*identify data -> firmware revision: word 23-26*/
-	id_to_string(dst, buf, 23, 8);
-	memcpy(&dst[23], buf, 8);
-
-	/*identify data -> serial number: word 10-19*/
-	id_to_string(dst, buf, 10, 20);
-	memcpy(&dst[10], buf, 20);
-
-	return 0;
-}
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 12)
-
-/**
- * scsi_normalize_sense - normalize main elements from either fixed or
- *			descriptor sense data format into a common format.
- *
- * @sense_buffer:	byte array containing sense data returned by device
- * @sb_len:		number of valid bytes in sense_buffer
- * @sshdr:		pointer to instance of structure that common
- *			elements are written to.
- *
- * Notes:
- *	The "main elements" from sense data are: response_code, sense_key,
- *	asc, ascq and additional_length (only for descriptor format).
- *
- *	Typically this function can be called after a device has
- *	responded to a SCSI command with the CHECK_CONDITION status.
- *
- * Return value:
- *	1 if valid sense data information found, else 0;
- **/
-int scsi_normalize_sense(const u8 *sense_buffer, int sb_len,
-                         struct scsi_sense_hdr *sshdr)
-{
-	if (!sense_buffer || !sb_len)
-		return 0;
-
-	memset(sshdr, 0, sizeof(struct scsi_sense_hdr));
-
-	sshdr->response_code = (sense_buffer[0] & 0x7f);
-
-	if (!scsi_sense_valid(sshdr))
-		return 0;
-
-	if (sshdr->response_code >= 0x72) {
-		/*
-		 * descriptor format
-		 */
-		if (sb_len > 1)
-			sshdr->sense_key = (sense_buffer[1] & 0xf);
-		if (sb_len > 2)
-			sshdr->asc = sense_buffer[2];
-		if (sb_len > 3)
-			sshdr->ascq = sense_buffer[3];
-		if (sb_len > 7)
-			sshdr->additional_length = sense_buffer[7];
-	} else {
-		/*
-		 * fixed format
-		 */
-		if (sb_len > 2)
-			sshdr->sense_key = (sense_buffer[2] & 0xf);
-		if (sb_len > 7) {
-			sb_len = (sb_len < (sense_buffer[7] + 8)) ?
-					 sb_len : (sense_buffer[7] + 8);
-			if (sb_len > 12)
-				sshdr->asc = sense_buffer[12];
-			if (sb_len > 13)
-				sshdr->ascq = sense_buffer[13];
-		}
-	}
-
-	return 1;
-}
-#endif
-/**
- *	mv_ata_task_ioctl - Handler for HDIO_DRIVE_TASK ioctl
- *	@scsidev: Device to which we are issuing command
- *	@arg: User provided data for issuing command
- *
- *	LOCKING:
- *	Defined by the SCSI layer.  We don't really care.
- *
- *	RETURNS:
- *	Zero on success, negative errno on error.
- */
-int mv_ata_task_ioctl(struct scsi_device *scsidev, void __user *arg)
-{
-	int rc = 0;
-	u8 scsi_cmd[MAX_COMMAND_SIZE];
-	u8 args[7];
-	struct scsi_sense_hdr sshdr;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	struct scsi_request *sreq;
-#endif
-	if (arg == NULL)
-		return -EINVAL;
-
-	if (copy_from_user(args, arg, sizeof(args)))
-		return -EFAULT;
-
-	memset(scsi_cmd, 0, sizeof(scsi_cmd));
-	scsi_cmd[0]  = ATA_16;
-	scsi_cmd[1]  = (3 << 1); /* Non-data */
-	scsi_cmd[4]  = args[1];
-	scsi_cmd[6]  = args[2];
-	scsi_cmd[8]  = args[3];
-	scsi_cmd[10] = args[4];
-	scsi_cmd[12] = args[5];
-	scsi_cmd[14] = args[0];
-	#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	sreq = scsi_allocate_request(scsidev, GFP_KERNEL);
-	if (!sreq) {
-		rc= -EINTR;
-		scsi_release_request(sreq);
-		return rc;
-	}
-	sreq->sr_data_direction = DMA_NONE;
-	scsi_wait_req(sreq, scsi_cmd, NULL, 0, (10*HZ), 5);
-
-	/*
-	 * If there was an error condition, pass the info back to the user.
-	 */
-	rc = sreq->sr_result;
-#elif LINUX_VERSION_CODE >=KERNEL_VERSION(2, 6, 29)
-	if (scsi_execute_req(scsidev, scsi_cmd, DMA_NONE, NULL, 0, &sshdr,
-				     (10*HZ), 5,0))
-			rc = -EIO;
-
-
-#else
-	if (scsi_execute_req(scsidev, scsi_cmd, DMA_NONE, NULL, 0, &sshdr,
-			     (10*HZ), 5))
-		rc = -EIO;
-#endif
-
-	return rc;
-}
-/****************************************************************
-*  Name:   mv_ial_ht_ata_cmd
-*
-*  Description:    handles mv_sata ata IOCTL special drive command (HDIO_DRIVE_CMD)
-*
-*  Parameters:     scsidev - Device to which we are issuing command
-*                  arg     - User provided data for issuing command
-*
-*  Returns:        0 on success, otherwise of failure.
-*
-****************************************************************/
-static int mv_ial_ht_ata_cmd(struct scsi_device *scsidev, void __user *arg)
-{
-	int rc = 0;
-	u8 scsi_cmd[MAX_COMMAND_SIZE];
-	u8 args[4] , *argbuf = NULL, *sensebuf = NULL;
-	int argsize = 0;
-	enum dma_data_direction data_dir;
-	int cmd_result;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	struct scsi_request *sreq;
-#endif
-	if (arg == NULL)
-		return -EINVAL;
-
-	if (copy_from_user(args, arg, sizeof(args)))
-		return -EFAULT;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	sensebuf = kmalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);
-	if (sensebuf) {
-		memset(sensebuf, 0, SCSI_SENSE_BUFFERSIZE);
-	}
-#else
-	sensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);
-#endif
-
-	if (!sensebuf)
-		return -ENOMEM;
-
-	memset(scsi_cmd, 0, sizeof(scsi_cmd));
-	if (args[3]) {
-		argsize = SECTOR_SIZE * args[3];
-		argbuf = kmalloc(argsize, GFP_KERNEL);
-		if (argbuf == NULL) {
-			rc = -ENOMEM;
-			goto error;
-	}
-
-	scsi_cmd[1]  = (4 << 1); /* PIO Data-in */
-	scsi_cmd[2]  = 0x0e;
-	data_dir = DMA_FROM_DEVICE;
-	} else {
-		scsi_cmd[1]  = (3 << 1); /* Non-data */
-		scsi_cmd[2]  = 0x20;
-		data_dir = DMA_NONE;
-	}
-
-	scsi_cmd[0] = ATA_16;
-
-	scsi_cmd[4] = args[2];
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27)
-	if (args[0] == WIN_SMART) {
-#else
-	if (args[0] == ATA_CMD_SMART) {
-#endif
-		scsi_cmd[6]  = args[3];
-		scsi_cmd[8]  = args[1];
-		scsi_cmd[10] = 0x4f;
-		scsi_cmd[12] = 0xc2;
-	} else {
-		scsi_cmd[6]  = args[1];
-	}
-	scsi_cmd[14] = args[0];
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	sreq = scsi_allocate_request(scsidev, GFP_KERNEL);
-	if (!sreq) {
-		rc= -EINTR;
-		goto free_req;
-	}
-	sreq->sr_data_direction = data_dir;
-	scsi_wait_req(sreq, scsi_cmd, argbuf, argsize, (10*HZ), 5);
-
-	/*
-	 * If there was an error condition, pass the info back to the user.
-	 */
-	cmd_result = sreq->sr_result;
-	sensebuf = sreq->sr_sense_buffer;
-
-#elif LINUX_VERSION_CODE >=KERNEL_VERSION(2, 6, 29)
-	cmd_result = scsi_execute(scsidev, scsi_cmd, data_dir, argbuf, argsize,
-                                sensebuf, (10*HZ), 5, 0,0);
-#else
-	cmd_result = scsi_execute(scsidev, scsi_cmd, data_dir, argbuf, argsize,
-                                sensebuf, (10*HZ), 5, 0);
-#endif
-
-
-	if (driver_byte(cmd_result) == DRIVER_SENSE) {/* sense data available */
-		u8 *desc = sensebuf + 8;
-		cmd_result &= ~(0xFF<<24);
-		if (cmd_result & SAM_STAT_CHECK_CONDITION) {
-		struct scsi_sense_hdr sshdr;
-		scsi_normalize_sense(sensebuf, SCSI_SENSE_BUFFERSIZE,
-                                   &sshdr);
-		if (sshdr.sense_key==0 &&
-			sshdr.asc==0 && sshdr.ascq==0)
-			cmd_result &= ~SAM_STAT_CHECK_CONDITION;
-		}
-
-		/* Send userspace a few ATA registers (same as drivers/ide) */
-		if (sensebuf[0] == 0x72 &&     /* format is "descriptor" */
-			desc[0] == 0x09 ) {        /* code is "ATA Descriptor" */
-			args[0] = desc[13];    /* status */
-			args[1] = desc[3];     /* error */
-			args[2] = desc[5];     /* sector count (0:7) */
-			if (copy_to_user(arg, args, sizeof(args)))
-				rc = -EFAULT;
-		}
-	}
-
-	if (cmd_result) {
-		rc = -EIO;
-		goto free_req;
-	}
-
-	if ((argbuf) && copy_to_user(arg + sizeof(args), argbuf, argsize))
-		rc = -EFAULT;
-
-free_req:
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	scsi_release_request(sreq);
-#endif
-error:
-	if (sensebuf) kfree(sensebuf);
-	if (argbuf) kfree(argbuf);
-	return rc;
-}
-
-static int check_dma (__u8 ata_op)
-{
-	switch (ata_op) {
-		case ATA_CMD_READ_DMA_EXT:
-		case ATA_CMD_READ_FPDMA_QUEUED:
-		case ATA_CMD_WRITE_DMA_EXT:
-		case ATA_CMD_WRITE_FPDMA_QUEUED:
-		case ATA_CMD_READ_DMA:
-		case ATA_CMD_WRITE_DMA:
-			return SG_DMA;
-		default:
-			return SG_PIO;
-	}
-}
-unsigned char excute_taskfile(struct scsi_device *dev,ide_task_request_t *req_task,u8
- rw,char *argbuf,unsigned int buff_size)
-{
-	int rc = 0;
-	u8 scsi_cmd[MAX_COMMAND_SIZE];
-	u8 *sensebuf = NULL;
-	int argsize=0;
-	enum dma_data_direction data_dir;
-	int cmd_result;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	struct scsi_request *sreq;
-#endif
-	argsize=buff_size;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	sensebuf = kmalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);
-	if (sensebuf) {
-		memset(sensebuf, 0, SCSI_SENSE_BUFFERSIZE);
-	}
-#else
-	sensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);
-#endif
-	if (!sensebuf)
-		return -ENOMEM;
-
-	memset(scsi_cmd, 0, sizeof(scsi_cmd));
-
-	data_dir = DMA_FROM_DEVICE;
-	scsi_cmd[0] = ATA_16;
-	scsi_cmd[13] = 0x40;
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
-	scsi_cmd[14] = ((task_struct_t *)(&req_task->io_ports))->command;
-#else
-	scsi_cmd[14] = ((char *)(&req_task->io_ports))[7];
-#endif
-	if(check_dma(scsi_cmd[14])){
-		scsi_cmd[1] = argbuf ? SG_ATA_PROTO_DMA : SG_ATA_PROTO_NON_DATA;
-	} else {
-		scsi_cmd[1] = argbuf ? (rw ? SG_ATA_PROTO_PIO_OUT : SG_ATA_PROTO_PIO_IN) : SG_ATA_PROTO_NON_DATA;
-	}
-	scsi_cmd[ 2] = SG_CDB2_CHECK_COND;
-	if (argbuf) {
-		scsi_cmd[2] |= SG_CDB2_TLEN_NSECT | SG_CDB2_TLEN_SECTORS;
-		scsi_cmd[2] |= rw ? SG_CDB2_TDIR_TO_DEV : SG_CDB2_TDIR_FROM_DEV;
-	}
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	sreq = scsi_allocate_request(dev, GFP_KERNEL);
-	if (!sreq) {
-		rc= -EINTR;
-		goto free_req;
-	}
-	sreq->sr_data_direction = data_dir;
-	scsi_wait_req(sreq, scsi_cmd, argbuf, argsize, (10*HZ), 5);
-
-	/*
-	 * If there was an error condition, pass the info back to the user.
-	 */
-	cmd_result = sreq->sr_result;
-	sensebuf = sreq->sr_sense_buffer;
-
-#elif LINUX_VERSION_CODE >=KERNEL_VERSION(2, 6, 29)
-	cmd_result = scsi_execute(dev, scsi_cmd, data_dir, argbuf, argsize,
-                                sensebuf, (10*HZ), 5, 0,0);
-#else
-	cmd_result = scsi_execute(dev, scsi_cmd, data_dir, argbuf, argsize,
-                                sensebuf, (10*HZ), 5, 0);
-#endif
-
-	if (driver_byte(cmd_result) == DRIVER_SENSE) {/* sense data available */
-		u8 *desc = sensebuf + 8;
-		cmd_result &= ~(0xFF<<24);
-
-		if (cmd_result & SAM_STAT_CHECK_CONDITION) {
-		struct scsi_sense_hdr sshdr;
-		scsi_normalize_sense(sensebuf, SCSI_SENSE_BUFFERSIZE,
-                                   &sshdr);
-		if (sshdr.sense_key==0 &&
-			sshdr.asc==0 && sshdr.ascq==0)
-			cmd_result &= ~SAM_STAT_CHECK_CONDITION;
-		}
-	}
-
-	if (cmd_result) {
-		rc = EIO;
-		MV_PRINT("EIO=%d\n",-EIO);
-		goto free_req;
-	}
-
-free_req:
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-	scsi_release_request(sreq);
-#endif
-	if (sensebuf) kfree(sensebuf);
-	return rc;
-}
-u8 mv_do_taskfile_ioctl(struct scsi_device *dev,void __user *arg){
-	ide_task_request_t *req_task=NULL;
-	char __user *buf = (char __user *)arg;
-	u8 *outbuf	= NULL;
-	u8 *inbuf	= NULL;
-	int err		= 0;
-	int tasksize	= sizeof(ide_task_request_t);
-	int taskin	= 0;
-	int taskout	= 0;
-	int rw = SG_READ;
-
-	req_task = kzalloc(tasksize, GFP_KERNEL);
-	if (req_task == NULL) return -ENOMEM;
-	if (copy_from_user(req_task, buf, tasksize)) {
-		kfree(req_task);
-		return -EFAULT;
-	}
-
-	switch (req_task->req_cmd) {
-		case TASKFILE_CMD_REQ_OUT:
-		case TASKFILE_CMD_REQ_RAW_OUT:
-			rw         = SG_WRITE;
-			break;
-		case TASKFILE_CMD_REQ_IN:
-			break;
-	}
-	taskout = (int) req_task->out_size;
-	taskin  = (int) req_task->in_size;
-
-
-	if (taskout) {
-		int outtotal = tasksize;
-		outbuf = kzalloc(taskout, GFP_KERNEL);
-		if (outbuf == NULL) {
-			err = -ENOMEM;
-			goto abort;
-		}
-		if (copy_from_user(outbuf, buf + outtotal, taskout)) {
-			err = -EFAULT;
-			goto abort;
-		}
-	}
-
-	if (taskin) {
-		int intotal = tasksize + taskout;
-		inbuf = kzalloc(taskin, GFP_KERNEL);
-		if (inbuf == NULL) {
-			err = -ENOMEM;
-			goto abort;
-		}
-		if (copy_from_user(inbuf, buf + intotal, taskin)) {
-			err = -EFAULT;
-			goto abort;
-		}
-	}
-
-	switch(req_task->data_phase) {
-		case TASKFILE_DPHASE_PIO_OUT:
-			err = excute_taskfile(dev,req_task,rw,outbuf,taskout);
-			break;
-		default:
-			err = -EFAULT;
-			goto abort;
-	}
-	if (copy_to_user(buf, req_task, tasksize)) {
-		err = -EFAULT;
-		goto abort;
-	}
-	if (taskout) {
-		int outtotal = tasksize;
-		if (copy_to_user(buf + outtotal, outbuf, taskout)) {
-			err = -EFAULT;
-			goto abort;
-		}
-	}
-	if (taskin) {
-		int intotal = tasksize + taskout;
-		if (copy_to_user(buf + intotal, inbuf, taskin)) {
-			err = -EFAULT;
-			goto abort;
-		}
-	}
-abort:
-	kfree(req_task);
-	kfree(outbuf);
-	kfree(inbuf);
-
-	return err;
-}
-
-int mv_new_ioctl(struct scsi_device *dev, int cmd, void __user *arg)
-{
-	int error,writing = 0, length;
-	int console,nr_hba;
-	int nbit;
-	static int mutex_flag = 0;
-	void * kbuf = NULL;
-	int val = 0;
-	struct scsi_idlun idlun;
-	struct request *rq;
-	struct request_queue * q = dev->request_queue;
-	PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER psptdwb = NULL;
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
-	struct scsi_request *sreq;
-#endif
-
-	if(mutex_flag == 0){
-		mutex_init(&ioctl_index_mutex);
-		mutex_flag = 1;
-	}
-	switch (cmd){
-
-	case HDIO_GET_IDENTITY:
-		psptdwb = hba_mem_alloc(sizeof(*psptdwb),MV_FALSE);
-		if (!psptdwb)
-			return -ENOMEM;
-		psptdwb->sptd.DataTransferLength = 512;
-		psptdwb->sptd.DataBuffer = arg;
-		psptdwb->sptd.CdbLength = 16;
-		memcpy((void*)psptdwb->sptd.Cdb, ata_ident, 16);
-		goto fetch_data;
-
-	case HDIO_GET_32BIT:
-		if (copy_to_user(arg, &val, 1))
-			return -EFAULT;
-		return 0;
-	case HDIO_SET_32BIT:
-		val = (unsigned long)arg;
-		if (val != 0)
-			return -EINVAL;
-		return 0;
-	case HDIO_DRIVE_CMD:
-		if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
-			return -EACCES;
-
-		return mv_ial_ht_ata_cmd(dev, arg);
-
-	case HDIO_DRIVE_TASK:
-		if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
-			return -EACCES;
-		return mv_ata_task_ioctl(dev, arg);
-	case HDIO_DRIVE_TASKFILE:
-		return mv_do_taskfile_ioctl(dev,arg);
-
-	default:
-		break;
-	}
-
-	switch(cmd - API_BLOCK_IOCTL_DEFAULT_FUN){
-	case API_IOCTL_GET_VIRTURL_ID:
-		console = VIRTUAL_DEVICE_ID;
-		if (copy_to_user(((PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) arg)->sptd.DataBuffer,
-			(void *)&console,sizeof(int)))
-			return -EIO;
-		return 0;
-	case API_IOCTL_GET_HBA_COUNT:
-		nr_hba = __mv_get_adapter_count();
-		if (copy_to_user(((PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) arg)->sptd.DataBuffer,
-			(void *)&nr_hba,sizeof(unsigned int)))
-			return -EIO;
-		return 0;
-	case API_IOCTL_LOOKUP_DEV:
-		if(copy_from_user(&idlun, ((PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) arg)->sptd.DataBuffer,
-			sizeof(struct scsi_idlun)))
-			return -EIO;
-		if(dev->host->host_no != ((idlun.dev_id) >> 24))
-			return EFAULT;
-		return 0;
-	case API_IOCTL_CHECK_VIRT_DEV:
-		if( dev->id != VIRTUAL_DEVICE_ID)
-			return -EFAULT;
-		return 0;
-	case API_IOCTL_DEFAULT_FUN:
-		break;
-	default:
-		return -ENOTTY;
-	}
-
-	psptdwb = hba_mem_alloc(sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
-	if (!psptdwb)
-		return -ENOMEM;
-	error = copy_from_user(psptdwb, (void *)arg, sizeof(*psptdwb));
-	if (error) {
-		hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
-		return -EIO;
-	}
-fetch_data:
-	length = psptdwb->sptd.DataTransferLength;
-
-	if (length){
-		if(length > IOCTL_BUF_LEN || (kbuf = hba_mem_alloc(length,MV_TRUE)) == NULL ){
-			hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
-			return -ENOMEM;
-		}
-		if(copy_from_user(kbuf, psptdwb->sptd.DataBuffer, length)){
-			hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
-			hba_mem_free(kbuf,length,MV_TRUE);
-			return -EIO;
-		}
-
-		if (SCSI_IS_WRITE(psptdwb->sptd.Cdb[0]))
-			writing = 1;
-	}
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
-	rq = blk_get_request(q, writing ? WRITE : READ, GFP_KERNEL);
-	if (!rq) {
-		hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
-		return -ENOMEM;
-	}
-#else
-	sreq = scsi_allocate_request(dev, GFP_KERNEL);
-	if (!sreq) {
-		MV_PRINT("SCSI internal ioctl failed, no memory\n");
-		return -ENOMEM;
-	}
-	rq = sreq->sr_request;
-#endif
-
-	rq->cmd_len = psptdwb->sptd.CdbLength;
-	psptdwb->sptd.ScsiStatus = REQ_STATUS_PENDING;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
-	rq->cmd_type = REQ_TYPE_BLOCK_PC;
-	rq->tag = psptdwb->sptd.ScsiStatus;
-#else
-  #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
-	rq->flags |= REQ_BLOCK_PC;
-	rq->rq_status = psptdwb->sptd.ScsiStatus;
-  #else
-	rq->tag = psptdwb->sptd.ScsiStatus;
-  #endif
-#endif
-	rq->timeout = msecs_to_jiffies(psptdwb->sptd.TimeOutValue);
-	if(!rq->timeout)
-		rq->timeout = 60 * HZ;
-	memcpy(rq->cmd, psptdwb->sptd.Cdb, psptdwb->sptd.CdbLength);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
-	if(length && blk_rq_map_kern(q, rq,kbuf, length, __GFP_WAIT)){
-		error = -EIO;
-		goto out;
-	}
-	rq->retries = 1;
-#else
-	rq->data = kbuf;
-	rq->data_len = length;
-#endif
-
-	rq->sense = psptdwb->Sense_Buffer;
-	rq->sense_len = psptdwb->sptd.SenseInfoLength;
-
-
-
-	mutex_lock(&ioctl_index_mutex);
-	nbit = find_first_zero_bit((unsigned long*)kbuf_index,512);
-	if(nbit >= 512){
-		mutex_unlock(&ioctl_index_mutex);
-		error = -ENOSPC;
-		goto out;
-	}
-	__set_bit(nbit, kbuf_index);
-	mutex_unlock(&ioctl_index_mutex);
-
-	rq->errors= nbit + 1;
-	kbuf_array[nbit] = kbuf;
-	memcpy((void*)mvcdb[nbit],rq->cmd,16);
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
-	error = blk_execute_rq(q, NULL, rq, 0);
-#else
-	error = blk_execute_rq(q, NULL, rq);
-#endif
-
-#else
-	sreq->sr_data_direction = writing ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-	scsi_wait_req(sreq, rq->cmd, kbuf, length,  rq->timeout, 1);
-	memcpy(rq->sense,sreq->sr_sense_buffer,rq->sense_len);
-	if(sreq->sr_result)
-		error = -EIO;
-	else
-		error = sreq->sr_result;
-#endif/*#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)*/
-
-	mutex_lock(&ioctl_index_mutex);
-	__clear_bit(nbit,kbuf_index);
-	mutex_unlock(&ioctl_index_mutex);
-	kbuf_array[nbit] = NULL;
-	memset((void*)mvcdb[nbit],0x00,16);
-
-	if (length && (cmd == HDIO_GET_IDENTITY))
-		io_get_identity(kbuf);
-
-	if (error) {
-		if ( rq->sense_len && rq->sense && ((MV_PU8)rq->sense)[0]) {
-			MV_DPRINT(("%s has sense,rq->sense[0]=0x%x\n", __func__,((MV_PU8)rq->sense)[0]));
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19) || LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
-			if (rq->tag == REQ_STATUS_ERROR_WITH_SENSE)
-				error = rq->tag;
-#else
-			if(rq->rq_status == REQ_STATUS_ERROR_WITH_SENSE)
-				error = rq->rq_status;
-#endif
-		}
-	} else if (length && copy_to_user(psptdwb->sptd.DataBuffer,kbuf,length)) {
-                        error = -EIO;
-                        goto out;
-	}
-	if (mv_is_api_cmd(cmd) && copy_to_user((void*)arg,psptdwb,
-		sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER))){
-		error = -EIO;
-		goto out;
-	}
-
-out:
-	hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
-	hba_mem_free(kbuf, psptdwb->sptd.DataTransferLength,MV_TRUE);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
-	blk_put_request(rq);
-#else
-	scsi_release_request(sreq);
-#endif
-	return error;
-}
--- a/drivers/scsi/vanir/linux/linux_iface.h
+++ /dev/null
@@ -1,113 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-/*
- *
- *  Kernel/CLI interface
- *
- */
-
-#ifndef __MV_HBA_LINUX_INTERFACE__
-#define __MV_HBA_LINUX_INTERFACE__
-
-#include "hba_header.h"
-#include "com_ioctl.h"
-#include "com_adapter_struct.h"
-
-/*Request Structure.*/
-#define SENSE_INFO_BUFFER_SIZE		32
-#define MAX_COMMAND_SIZE		16
-
-/* DMA read write command */
-#define ATA_CMD_READ_DMA			0xC8	/* 24 bit DMA read */
-#define ATA_CMD_READ_DMA_QUEUED			0xC7	/* 24 bit TCQ DMA read */
-#define ATA_CMD_READ_DMA_EXT			0x25	/* 48 bit DMA read */
-#define ATA_CMD_READ_DMA_QUEUED_EXT		0x26	/* 48 bit TCQ DMA read */
-#define ATA_CMD_READ_FPDMA_QUEUED		0x60	/* NCQ DMA read: SATA only.* Always 48 bit */
-
-#define ATA_CMD_WRITE_DMA			0xCA
-#define ATA_CMD_WRITE_DMA_QUEUED		0xCC
-#define ATA_CMD_WRITE_DMA_EXT  			0x35
-#define ATA_CMD_WRITE_DMA_QUEUED_EXT		0x36
-#define ATA_CMD_WRITE_FPDMA_QUEUED		0x61
-
-#define ATA_CMD_READ_PIO			0x20
-#define ATA_CMD_READ_PIO_MULTIPLE               0xC4
-#define ATA_CMD_READ_PIO_EXT			0x24
-#define ATA_CMD_READ_PIO_MULTIPLE_EXT 		0x29
-#define ATA_CMD_WRITE_PIO			0x30
-#define ATA_CMD_WRITE_PIO_MULTIPLE              0xC5
-#define ATA_CMD_WRITE_PIO_EXT			0x34
-#define ATA_CMD_WRITE_PIO_MULTIPLE_EXT		0x39
-#define ATA_CMD_WRITE_PIO_MULTIPLE_FUA_EXT      0xCE
-
-#ifndef ATA_CMD_SMART
-#define ATA_CMD_SMART					0xB0
-#endif
-
-enum {
-	SG_CDB2_TLEN_NODATA	= 0 << 0,
-	SG_CDB2_TLEN_FEAT	= 1 << 0,
-	SG_CDB2_TLEN_NSECT	= 2 << 0,
-
-	SG_CDB2_TLEN_BYTES	= 0 << 2,
-	SG_CDB2_TLEN_SECTORS	= 1 << 2,
-
-	SG_CDB2_TDIR_TO_DEV	= 0 << 3,
-	SG_CDB2_TDIR_FROM_DEV	= 1 << 3,
-
-	SG_CDB2_CHECK_COND	= 1 << 5,
-};
-
-#define SG_READ			0
-#define SG_WRITE		1
-#define SG_PIO			0
-#define SG_DMA			1
-
-enum {
-	/*
-	 * These (redundantly) specify the category of the request
-	 */
-	TASKFILE_CMD_REQ_NODATA	= 0,	/* ide: IDE_DRIVE_TASK_NO_DATA */
-	TASKFILE_CMD_REQ_IN	= 2,	/* ide: IDE_DRIVE_TASK_IN */
-	TASKFILE_CMD_REQ_OUT	= 3,	/* ide: IDE_DRIVE_TASK_OUT */
-	TASKFILE_CMD_REQ_RAW_OUT= 4,	/* ide: IDE_DRIVE_TASK_RAW_WRITE */
-	/*
-	 * These specify the method of transfer (pio, dma, multi, ..)
-	 */
-	TASKFILE_DPHASE_NONE	= 0,	/* ide: TASKFILE_IN */
-	TASKFILE_DPHASE_PIO_IN	= 1,	/* ide: TASKFILE_IN */
-	TASKFILE_DPHASE_PIO_OUT	= 4,	/* ide: TASKFILE_OUT */
-};
-#define SG_ATA_LBA48		1
-#define SG_ATA_PROTO_NON_DATA	( 3 << 1)
-#define SG_ATA_PROTO_PIO_IN	( 4 << 1)
-#define SG_ATA_PROTO_PIO_OUT	( 5 << 1)
-#define SG_ATA_PROTO_DMA	( 6 << 1)
-#define SG_ATA_PROTO_UDMA_IN	(11 << 1)
-#define SG_ATA_PROTO_UDMA_OUT	(12 << 1)
-
-typedef struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER{
-	SCSI_PASS_THROUGH_DIRECT        sptd;
-	unsigned long                   Filler;
-	unsigned char                   Sense_Buffer[SENSE_INFO_BUFFER_SIZE];
-}SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER, *PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER;
-
-int mv_linux_proc_info(struct Scsi_Host *pSHost, char *pBuffer,
-		       char **ppStart,  off_t offset, int length, int inout);
-void IOHBARequestCallback(MV_PVOID This, PMV_Request pReq);
-struct hba_extension;
-int mv_register_chdev(struct hba_extension *hba);
-void mv_unregister_chdev(struct hba_extension *hba);
-
-#endif /* ifndef __MV_HBA_LINUX_INTERFACE__ */
--- a/drivers/scsi/vanir/linux/linux_main.c
+++ /dev/null
@@ -1,1422 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "linux_main.h"
-#include "hba_mod.h"
-#include "linux_iface.h"
-#include "hba_timer.h"
-#include "csmisas.h"
-
-static const struct pci_device_id mv_pci_ids[] = {
-	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_9480)},
-	{PCI_DEVICE(VENDOR_ID_EXT,DEVICE_ID_9480)},
-	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9485)},
-	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9440)},
-	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9445)},
-	{PCI_DEVICE(VENDOR_ID_EXT,DEVICE_ID_948F)},
-	{0}
-};
-
-
-/*
- *  cmd line parameters
- */
-static int mv_msi_enable;
-module_param(mv_msi_enable, int, 0);
-MODULE_PARM_DESC(mv_msi_enable, " Enable MSI Support for Marvell \
-	controllers (default=0)");
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12))
-
-/* notifier block to get notified on system shutdown/halt/reboot/down */
-static int mv_linux_halt(struct notifier_block *nb, unsigned long event,
-			 void *buf)
-{
-	switch (event) {
-	case SYS_RESTART:
-	case SYS_HALT:
-	case SYS_POWER_OFF:
-		MV_DPRINT(("%s assert!\n",__func__));
-		mv_hba_stop(NULL);
-		break;
-	default:
-		break;
-	}
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block mv_linux_notifier = {
-	mv_linux_halt, NULL, 0
-};
-#endif /*#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12))*/
-
-
-static int mv_probe(struct pci_dev *dev, const struct pci_device_id *id)
-{
-	unsigned int ret = PCIBIOS_SUCCESSFUL;
-	int err = 0;
-
-	ret = pci_enable_device(dev);
-	if (ret) {
-		MV_PRINT("%s : enable device failed.\n", mv_product_name);
-		return ret;
-	}
-
-	ret = pci_request_regions(dev, mv_driver_name);
-	if (ret)
-		goto err_req_region;
-
-	if ( !pci_set_dma_mask(dev, DMA_64BIT_MASK) ) {
-		ret = pci_set_consistent_dma_mask(dev, DMA_64BIT_MASK);
-		if (ret) {
-			ret = pci_set_consistent_dma_mask(dev,
-							  DMA_32BIT_MASK);
-			if (ret)
-				goto err_dma_mask;
-		}
-	} else {
-		ret = pci_set_dma_mask(dev, DMA_32BIT_MASK);
-		if (ret)
-			goto err_dma_mask;
-		ret = pci_set_consistent_dma_mask(dev, DMA_32BIT_MASK);
-		if (ret)
-			goto err_dma_mask;
-	}
-
-	pci_set_master(dev);
-
-	MV_PRINT("Marvell Storage Controller is found, using IRQ %d, driver version %s.\n",
-	       dev->irq, mv_version_linux);
-
-	MV_PRINT("Marvell Linux driver %s, driver version %s.\n",
-	      mv_driver_name, mv_version_linux);
-
-	MV_DPRINT(("Start mv_hba_init.\n"));
-
-	ret = mv_hba_init(dev, MV_MAX_IO);
-	if (ret) {
-		MV_DPRINT(( "Error no %d.\n", ret));
-		ret = -ENOMEM;
-		goto err_dma_mask;
-	}
-
-	MV_DPRINT(("Start mv_hba_start.\n"));
-
-	if (mv_hba_start(dev)) {
-		ret = -ENODEV;
-		goto err_mod_start;
-	}
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
-		if (__mv_get_adapter_count() == 1) {
-			register_reboot_notifier(&mv_linux_notifier);
-		}
-#endif
-
-	MV_DPRINT(("Finished mv_probe.\n"));
-
-	return 0;
-err_mod_start:
-	err++;
-	mv_hba_stop(dev);
-	mv_hba_release(dev);
-err_dma_mask:
-	err++;
-	pci_release_regions(dev);
-err_req_region:
-	err++;
-	pci_disable_device(dev);
-
-	MV_PRINT("%s : error counter %d.\n", mv_product_name, err);
-	return ret;
-}
-
-static void __devexit mv_remove(struct pci_dev *dev)
-{
-	mv_hba_stop(dev);
-	mv_hba_release(dev);
-	pci_release_regions(dev);
-	pci_disable_device(dev);
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12))
-	if (__mv_get_adapter_count() == 0) {
-		unregister_reboot_notifier(&mv_linux_notifier);
-	}
-#endif
-
-	MV_PRINT("%s : Marvell %s linux driver removed !\n", mv_product_name, mv_product_name);
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
-static void mv_shutdown(struct pci_dev * pdev)
-{
-	mv_hba_stop(NULL);
-}
-#endif
-
-void core_disable_ints(void * ext);
-void core_enable_ints(void * ext);
-MV_BOOLEAN core_check_int(void *ext);
-
-static irqreturn_t mv_hba_int_handler(void *dev_id)
-{
-	irqreturn_t retval = MV_FALSE;
-	struct hba_extension *hba = (struct hba_extension *) dev_id;
-
-	core_disable_ints(hba->desc->child->extension);
-
-	if (!hba->msi_enabled) {
-		retval = core_check_int(hba->desc->child->extension);
-		if (!retval) {
-			core_enable_ints(hba->desc->child->extension);
-			return IRQ_RETVAL(retval);
-		}
-	} else {
-		retval = MV_TRUE;
-	}
-	tasklet_schedule(&hba->desc->hba_desc->mv_tasklet);
-
-	return IRQ_RETVAL(retval);
-}
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
- irqreturn_t mv_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
-{
-	return mv_hba_int_handler(dev_id);
-}
-#else
- irqreturn_t mv_intr_handler(int irq, void *dev_id)
-{
-	return mv_hba_int_handler(dev_id);
-}
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19) */
-
-#ifdef CONFIG_PM
-int core_suspend (void *ext);
-int core_resume (void *ext);
-static int mv_suspend(struct pci_dev *pdev, pm_message_t state)
-{
-	struct hba_extension *ext;
-	struct mv_mod_desc *core_mod,*hba_mod = pci_get_drvdata(pdev);
-	struct mv_adp_desc *ioc = hba_mod->hba_desc;
-
-	BUG_ON(!ioc);
-	MV_PRINT("start  mv_suspend.\n");
-
-	ext = (struct hba_extension *)hba_mod->extension;
-	core_mod = __get_lowest_module(ioc);
-	core_suspend(core_mod->extension);
-	free_irq(ioc->dev->irq,ext);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
-	pci_save_state(pdev);
-#else
-	pci_save_state(pdev,ioc->pci_config_space);
-#endif
-	pci_disable_device(pdev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
-	pci_set_power_state(pdev,pci_choose_state(pdev,state));
-#else
-	pci_set_power_state(pdev,state);
-#endif
-
-	return 0;
-}
-
-static int mv_resume (struct pci_dev *pdev)
-{
-	int ret;
-	struct hba_extension *ext;
-	struct mv_mod_desc *core_mod,*hba_mod = pci_get_drvdata(pdev);
-	struct mv_adp_desc *ioc = hba_mod->hba_desc;
-
-	ext = (struct hba_extension *)hba_mod->extension;
-	core_mod = __get_lowest_module(ioc);
-	MV_PRINT("start  mv_resume.\n");
-
-	pci_set_power_state(pdev, PCI_D0);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
-	pci_enable_wake(pdev, PCI_D0, 0);
-	pci_restore_state(pdev);
-#else
-	pci_restore_state(pdev,ioc->pci_config_space);
-#endif
-	pci_set_master(pdev);
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 19)
-	ret = request_irq(ioc->dev->irq, mv_intr_handler, IRQF_SHARED,
-	                  mv_driver_name, ext);
-#else
-	ret = request_irq(ioc->dev->irq, mv_intr_handler, SA_SHIRQ,
-		mv_driver_name, ext);
-#endif
-	if (ret < 0) {
-	        MV_PRINT("request IRQ failed.\n");
-	        return -1;
-	}
-	if (core_resume(core_mod->extension)) {
-		MV_PRINT("mv_resume_core failed.\n");
-		return -1;
-	}
-
-	return 0;
-}
-#endif
-
-
-static struct pci_driver mv_pci_driver = {
-	.name     = mv_driver_name,
-	.id_table = mv_pci_ids,
-	.probe    = mv_probe,
-	.remove   = __devexit_p(mv_remove),
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
-	.shutdown = mv_shutdown,
-#endif
-#ifdef CONFIG_PM
-	.resume = mv_resume,
-	.suspend = mv_suspend,
-#endif
-};
-
-int hba_req_cache_create(MV_PVOID hba_ext)
-{
-	PHBA_Extension phba = (PHBA_Extension)hba_ext;
-	struct mv_adp_desc   *hba_desc=phba->desc->hba_desc;
-	sprintf(phba->cache_name,"%s%d%d","mv_request_",hba_desc->Device_Id, hba_desc->id);
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	phba->mv_request_cache = kmem_cache_create(phba->cache_name,sizeof(struct _MV_Request),
-			0, SLAB_HWCACHE_ALIGN, NULL);
-#else
-	phba->mv_request_cache = kmem_cache_create(phba->cache_name,sizeof(struct _MV_Request),
-			0, SLAB_HWCACHE_ALIGN, NULL,NULL);
-#endif
-	if(phba->mv_request_cache == NULL)
-		return -ENOMEM;
-	sprintf(phba->sg_name,"%s%d%d","mv_sgtable_",hba_desc->Device_Id, hba_desc->id);
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	phba->mv_request_sg_cache = kmem_cache_create(phba->sg_name,
-		phba->max_sg_count  * sizeof(MV_SG_Entry),
-			0,SLAB_HWCACHE_ALIGN, NULL);
-#else
-	phba->mv_request_sg_cache = kmem_cache_create(phba->sg_name,
-		phba->max_sg_count  * sizeof(MV_SG_Entry),
-			0,SLAB_HWCACHE_ALIGN, NULL,NULL);
-#endif
-	if(phba->mv_request_sg_cache == NULL) {
-		kmem_cache_destroy(phba->mv_request_cache);
-		return -ENOMEM;
-	}
-
-	phba->mv_mempool= mempool_create(2, mempool_alloc_slab,mempool_free_slab,
-		phba->mv_request_sg_cache);
-	if(!phba->mv_mempool){
-		kmem_cache_destroy(phba->mv_request_cache);
-		kmem_cache_destroy(phba->mv_request_sg_cache);
-		return -ENOMEM;
-	}
-	return 0;
-}
-
-PMV_Request hba_req_cache_alloc(MV_PVOID hba_ext)
-{
-	int max_sg = 0;
-	MV_SG_Entry * sgtable= NULL;
-	struct _MV_Request * req = NULL;
-	PHBA_Extension phba = (PHBA_Extension)hba_ext;
-
-	max_sg = phba->max_sg_count;
-	req = kmem_cache_alloc(phba->mv_request_cache, GFP_ATOMIC);
-	if (!req) {
-		MV_DPRINT(("cache alloc req failed.\n"));
-		return NULL;
-	}
-	memset(req,0x00,sizeof(struct _MV_Request));
-	sgtable =  mempool_alloc(phba->mv_mempool, GFP_ATOMIC);
-
-	if (sgtable) {
-		memset(sgtable, 0x00,sizeof(max_sg  * sizeof(MV_SG_Entry)));
-		req->SG_Table.Entry_Ptr= sgtable;
-		req->SG_Table.Max_Entry_Count = max_sg;
-	} else {
-		kmem_cache_free(phba->mv_request_cache,req);
-		return NULL;
-	}
-	MV_ZeroMvRequest(req);
-	return req;
-}
-
-void hba_req_cache_free(MV_PVOID hba_ext,PMV_Request req)
-{
-	PHBA_Extension phba = (PHBA_Extension)hba_ext;
-	mempool_free((void *)req->SG_Table.Entry_Ptr,phba->mv_mempool);
-	kmem_cache_free(phba->mv_request_cache,req);
-}
-
-void  hba_req_cache_destroy(MV_PVOID hba_ext)
-{
-	PHBA_Extension phba = (PHBA_Extension)hba_ext;
-	mempool_destroy(phba->mv_mempool);
-	kmem_cache_destroy(phba->mv_request_cache);
-	kmem_cache_destroy(phba->mv_request_sg_cache);
-}
-
-static void generate_sg_table(struct hba_extension *phba,
-			      struct scsi_cmnd *scmd,
-			      PMV_SG_Table sg_table)
-{
-	struct scatterlist *sg;
-	unsigned int sg_count = 0;
-	unsigned int length;
-	dma_addr_t busaddr = 0;
-	int i;
-
-	if (mv_rq_bf_l(scmd) > (mv_scmd_host(scmd)->max_sectors << 9)) {
-		MV_DPRINT(( "ERROR: request length exceeds "
-		"the maximum alowed value.\n"));
-	}
-
-	if (0 == mv_rq_bf_l(scmd))
-		return ;
-
-	if (mv_use_sg(scmd)) {
-		sg = (struct scatterlist *) mv_rq_bf(scmd);
-		if (MV_SCp(scmd)->mapped == 0){
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
-			sg_count = scsi_dma_map(scmd);
-#else
-			sg_count = pci_map_sg(phba->desc->hba_desc->dev,sg,mv_use_sg(scmd),
-			scsi_to_pci_dma_dir(scmd->sc_data_direction));
-#endif
-			if (sg_count != mv_use_sg(scmd)) {
-				MV_PRINT("WARNING sg_count(%d) != scmd->use_sg(%d)\n",
-				(unsigned int) sg_count, mv_use_sg(scmd));
-			}
-			MV_SCp(scmd)->mapped = 1;
-		}
-
-		for (i = 0; i < sg_count; i++) {
-			busaddr = sg_dma_address(&sg[i]);
-			length = sg_dma_len(&sg[i]);
-
-			sgdt_append_pctx(sg_table,LO_BUSADDR(busaddr), HI_BUSADDR(busaddr),
-			length,  sg + i);
-		}
-	} else {
-		if (MV_SCp(scmd)->mapped == 0) {
-			busaddr = dma_map_single(&phba->desc->hba_desc->dev->dev,mv_rq_bf(scmd),mv_rq_bf_l(scmd),
-			scsi_to_pci_dma_dir(scmd->sc_data_direction));
-			MV_SCp(scmd)->bus_address = busaddr;
-			MV_SCp(scmd)->mapped = 1;
-		}
-		sgdt_append_vp(sg_table,mv_rq_bf(scmd), mv_rq_bf_l(scmd),
-		LO_BUSADDR(busaddr),   HI_BUSADDR(busaddr));
-	}
-}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-#define MV_EEDPFLAGS_INC_PRI_REFTAG        (0x8000)
-#define MV_EEDPFLAGS_INC_SEC_REFTAG        (0x4000)
-#define MV_EEDPFLAGS_INC_PRI_APPTAG        (0x2000)
-#define MV_EEDPFLAGS_INC_SEC_APPTAG        (0x1000)
-
-#define MV_EEDPFLAGS_CHECK_REFTAG          (0x0400)
-#define MV_EEDPFLAGS_CHECK_APPTAG          (0x0200)
-#define MV_EEDPFLAGS_CHECK_GUARD           (0x0100)
-
-#define MV_EEDPFLAGS_PASSTHRU_REFTAG       (0x0008)
-
-#define MV_EEDPFLAGS_MASK_OP               (0x0007)
-#define MV_EEDPFLAGS_NOOP_OP               (0x0000)
-#define MV_EEDPFLAGS_CHECK_OP              (0x0001)
-#define MV_EEDPFLAGS_STRIP_OP              (0x0002)
-#define MV_EEDPFLAGS_CHECK_REMOVE_OP       (0x0003)
-#define MV_EEDPFLAGS_INSERT_OP             (0x0004)
-#define MV_EEDPFLAGS_REPLACE_OP            (0x0006)
-#define MV_EEDPFLAGS_CHECK_REGEN_OP        (0x0007)
-/**
- * mv_setup_eedp - setup MV request for EEDP transfer
- * @scmd: pointer to scsi command object
- * @pReq: pointer to the SCSI_IO reqest message frame
- *
- * Supporting protection type 1 and 3.
- *
- * Returns nothing
- */
-static void
-mv_setup_eedp(struct scsi_cmnd *scmd, PMV_Request pReq)
-{
-	MV_U16 eedp_flags;
-	unsigned char prot_op = scsi_get_prot_op(scmd);
-	unsigned char prot_type = scsi_get_prot_type(scmd);
-
-	if (prot_type == SCSI_PROT_DIF_TYPE0 ||
-	   prot_type == SCSI_PROT_DIF_TYPE2 ||
-	   prot_op == SCSI_PROT_NORMAL)
-		return;
-
-	if (prot_op ==  SCSI_PROT_READ_STRIP)
-		eedp_flags = MV_EEDPFLAGS_CHECK_REMOVE_OP;
-	else if (prot_op ==  SCSI_PROT_WRITE_INSERT)
-		eedp_flags = MV_EEDPFLAGS_INSERT_OP;
-	else
-		return;
-
-	switch (prot_type) {
-	case SCSI_PROT_DIF_TYPE1:
-
-		/*
-		* enable ref/guard checking
-		* auto increment ref tag
-		*/
-		pReq->EEDPFlags = eedp_flags |
-		    MV_EEDPFLAGS_INC_PRI_REFTAG |
-		    MV_EEDPFLAGS_CHECK_REFTAG |
-		    MV_EEDPFLAGS_CHECK_GUARD;
-		break;
-
-	case SCSI_PROT_DIF_TYPE3:
-
-		/*
-		* enable guard checking
-		*/
-		pReq->EEDPFlags = eedp_flags |
-		    MV_EEDPFLAGS_CHECK_GUARD;
-
-		break;
-	}
-}
-/**
- * mv_eedp_error_handling - return sense code for EEDP errors
- * @scmd: pointer to scsi command object
- * @ioc_status: ioc status
- *
- * Returns nothing
- */
-static void
-mv_eedp_error_handling(struct scsi_cmnd *scmd, MV_U8 req_status)
-{
-	return;
-}
-#endif
-
-void mv_complete_request(struct hba_extension *phba,
-				struct scsi_cmnd *scmd,
-				PMV_Request pReq)
-{
-	PMV_Sense_Data  senseBuffer = (PMV_Sense_Data)pReq->Sense_Info_Buffer;
-
-	if (mv_rq_bf_l(scmd)) {
-		if (MV_SCp(scmd)->mapped) {
-			if (mv_use_sg(scmd)) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
-				scsi_dma_unmap(scmd);
-#else
-				pci_unmap_sg(phba->desc->hba_desc->dev,
-					     mv_rq_bf(scmd),
-					     mv_use_sg(scmd),
-						scsi_to_pci_dma_dir(scmd->sc_data_direction));
-#endif
-			} else {
-				dma_unmap_single(&phba->desc->hba_desc->dev->dev,
-						 MV_SCp(scmd)->bus_address,
-						 mv_rq_bf_l(scmd),
-					scsi_to_pci_dma_dir(scmd->sc_data_direction));
-			}
-		}
-	}
-
-	switch (pReq->Scsi_Status) {
-	case REQ_STATUS_SUCCESS:
-		scmd->result = 0x00;
-		break;
-	case REQ_STATUS_MEDIA_ERROR:
-		scmd->result = (DID_BAD_TARGET << 16);
-		break;
-	case REQ_STATUS_BUSY:
-		scmd->result = (DID_BUS_BUSY << 16);
-		break;
-	case REQ_STATUS_NO_DEVICE:
-		scmd->result = (DID_NO_CONNECT << 16);
-		break;
-	case REQ_STATUS_HAS_SENSE:
-		scmd->result  = (DRIVER_SENSE << 24) | (DID_OK << 16) |
-			SAM_STAT_CHECK_CONDITION;
-
-		if (scmd->cmnd[0]== 0x85 || scmd->cmnd[0]== 0xa1)
-			break;
-
-		if (((MV_PU8) senseBuffer)[0] >= 0x72) {
-			MV_DPRINT(("MV Sense: response %x SK %s  "
-				  "ASC %x ASCQ %x.\n\n", ((MV_PU8) senseBuffer)[0],
-				MV_DumpSenseKey(((MV_PU8) senseBuffer)[1]),
-				((MV_PU8) senseBuffer)[2],((MV_PU8) senseBuffer)[3]));
-		} else {
-			MV_DPRINT(("MV Sense: response %x SK %s "
-				  "ASC %x ASCQ %x.\n\n", ((MV_PU8) senseBuffer)[0],
-				MV_DumpSenseKey(((MV_PU8) senseBuffer)[2]),
-				((MV_PU8) senseBuffer)[12],((MV_PU8) senseBuffer)[13]));
-		}
-		break;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	case REQ_STATUS_DIF_GUARD_ERROR:
-	case REQ_STATUS_DIF_REF_TAG_ERROR:
-	case REQ_STATUS_DIF_APP_TAG_ERROR:
-		mv_eedp_error_handling(scmd, pReq->Scsi_Status);
-		break;
-#endif
-	default:
-		scmd->result = DRIVER_INVALID << 24 | DID_ABORT << 16;
-		break;
-	}
-	if(scmd && scmd->scsi_done) {
-		scmd->scsi_done(scmd);
-	} else
-		MV_DPRINT(("scmd %p no scsi_done.\n",scmd));
-}
-
-static void hba_req_callback(MV_PVOID This, PMV_Request pReq)
-{
-	struct hba_extension *phba = (struct hba_extension *)This;
-	struct scsi_cmnd *scmd = (struct scsi_cmnd *)pReq->Org_Req_Scmd;
-
-	mv_complete_request(phba, scmd, pReq);
-	phba->Io_Count--;
-	hba_req_cache_free(phba,pReq);
-}
-
-
-static int scsi_cmd_to_req_conv(struct hba_extension *phba,
-				struct scsi_cmnd *scmd,
-				PMV_Request pReq)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	mv_setup_eedp(scmd, pReq);
-#endif
-	/*
-	 * Set three flags: CMD_FLAG_NON_DATA
-	 *                  CMD_FLAG_DATA_IN
-	 *                  CMD_FLAG_DMA
-	 * currently data in/out all go thru DMA
-	 */
-	pReq->Cmd_Flag = 0;
-	switch (scmd->sc_data_direction) {
-	case DMA_NONE:
-		break;
-	case DMA_FROM_DEVICE:
-		pReq->Cmd_Flag |= CMD_FLAG_DATA_IN;
-	case DMA_TO_DEVICE:
-		pReq->Cmd_Flag |= CMD_FLAG_DMA;
-		break;
-	case DMA_BIDIRECTIONAL :
-		MV_DPRINT(( " unexpected DMA_BIDIRECTIONAL.\n"));
-		break;
-	default:
-		break;
-	}
-
-	/* max CDB length set for 32 */
-	memset(pReq->Cdb, 0, MAX_CDB_SIZE);
-
-#if LINUX_VERSION_CODE >KERNEL_VERSION(2, 6, 27)
-	pReq->Time_Out = jiffies_to_msecs(scmd->request->timeout)/1000;
-#else
-	#if (LINUX_VERSION_CODE ==KERNEL_VERSION(2, 6, 27) && (IS_OPENSUSE_SLED_SLES))
-	pReq->Time_Out = jiffies_to_msecs(scmd->request->timeout)/1000;
-	#else
-	pReq->Time_Out = jiffies_to_msecs(scmd->timeout_per_command)/1000;
-	#endif
-#endif
-
-	switch (scmd->cmnd[0]) {
-	/* per smartctl, it sets SCSI_TIMEOUT_DEFAULT to 6 , but for captive mode, we extends to 60 HZs */
-	case SCSI_CMD_ATA_PASSTHRU_16:
-		if (scmd->cmnd[14] != ATA_CMD_PM_CHECK)
-			pReq->Time_Out = 60;
-		pReq->Cmd_Flag = hba_parse_ata_protocol(scmd);
-		break;
-	case SCSI_CMD_ATA_PASSTHRU_12:
-		if (scmd->cmnd[9] != ATA_CMD_PM_CHECK)
-			pReq->Time_Out = 60;
-		pReq->Cmd_Flag = hba_parse_ata_protocol(scmd);
-		break;
-	default:
-		break;
-	}
-	memcpy(pReq->Cdb, scmd->cmnd, scmd->cmd_len);
-
-	pReq->Data_Buffer = mv_rq_bf(scmd);
-	pReq->Data_Transfer_Length = mv_rq_bf_l(scmd);
-	pReq->Sense_Info_Buffer = scmd->sense_buffer;
-	pReq->Sense_Info_Buffer_Length = SCSI_SENSE_BUFFERSIZE;
-
-	SGTable_Init(&pReq->SG_Table, 0);
-	generate_sg_table(phba, scmd, &pReq->SG_Table);
-
-	MV_SetLBAandSectorCount(pReq);
-
-	pReq->Req_Type      = REQ_TYPE_OS;
-	pReq->Org_Req_Scmd       = scmd;
-	pReq->Tag           = scmd->tag;
-	pReq->Scsi_Status   = REQ_STATUS_PENDING;
-	pReq->Completion    = hba_req_callback;
-	pReq->Cmd_Initiator = phba;
-	pReq->Device_Id     = get_id_by_targetid_lun(phba, mv_scmd_target(scmd),
-						mv_scmd_lun(scmd));
-
-	return 0;
-}
-
-extern void * kbuf_array[512];
-static void hba_ioctl_req_callback(MV_PVOID This, PMV_Request pReq)
-{
-	struct hba_extension *phba = (struct hba_extension *)This;
-	struct scsi_cmnd *scmd = (struct scsi_cmnd *)pReq->Org_Req_Scmd;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
-/*openSUSE 11.1 SLES 11 SLED 11*/
-#if ((LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 27))&&(!IS_OPENSUSE_SLED_SLES))
-        /* Return this request to OS. */
-	scmd->eh_timeout.expires = jiffies + 1;
-	add_timer(&scmd->eh_timeout);
-#endif
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19) || LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
-	scmd->request->tag = pReq->Scsi_Status;
-#else
-	scmd->request->rq_status = pReq->Scsi_Status;
-#endif
-	scmd->request->sense = pReq->Sense_Info_Buffer;
-	scmd->request->sense_len = pReq->Sense_Info_Buffer_Length;
-	mv_complete_request(phba, scmd, pReq);
-	phba->Io_Count--;
-	hba_req_cache_free(phba,pReq);
-}
-
-static int scsi_ioctl_cmd_adjust(struct hba_extension *phba,
-                                struct scsi_cmnd *scmd,
-                                PMV_Request pReq)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
-#if ((LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 27))&&(!IS_OPENSUSE_SLED_SLES))
-	del_timer(&scmd->eh_timeout);
-#endif
-#endif
-	memcpy(pReq->Cdb,mvcdb[scmd->request->errors - 1],16);
-	if( __is_scsi_cmd_rcv_snd_diag(pReq->Cdb[0])) {
-		if((pReq->Cdb[1] ==0x01) ||(pReq->Cdb[1]==0x10)) {
-			if(pReq->Cdb[0] ==API_SCSI_CMD_RCV_DIAG_RSLT)
-				pReq->Cmd_Flag = CMD_FLAG_DATA_IN;
-			if(pReq->Cdb[0] ==API_SCSI_CMD_SND_DIAG  )
-				pReq->Cmd_Flag &= ~CMD_FLAG_DATA_IN;
-			goto bypass;
-		}
-	}
-	pReq->Data_Buffer = kbuf_array[scmd->request->errors - 1];
-bypass:
-	scmd->request->errors = 0;
-	pReq->Sense_Info_Buffer = scmd->request->sense;
-	pReq->Sense_Info_Buffer_Length = scmd->request->sense_len;
-	pReq->Req_Type = REQ_TYPE_INTERNAL;
-	pReq->Org_Req = pReq;
-	pReq->Completion =  hba_ioctl_req_callback;
-	return 0;
-}
-
-static void hba_shutdown_req_cb(MV_PVOID this, PMV_Request req)
-{
-	struct hba_extension *phba = (struct hba_extension *) this;
-
-	hba_req_cache_free(phba,req);
-	phba->Io_Count--;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	atomic_set(&phba->desc->hba_desc->hba_sync, 0);
-#else
-	complete(&phba->desc->hba_desc->cmpl);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
-}
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-int __hba_wait_for_atomic_timeout(atomic_t *atomic, unsigned long timeout)
-{
-	unsigned intv = HZ/20;
-
-	while (timeout) {
-		if (0 == atomic_read(atomic))
-			break;
-
-		if (timeout < intv)
-			intv = timeout;
-		set_current_state(TASK_INTERRUPTIBLE);
-		timeout -= (intv - schedule_timeout(intv));
-	}
-	return timeout;
-}
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
-
-void hba_send_shutdown_req(MV_PVOID extension)
-{
-	unsigned long flags;
-	PMV_Request pReq;
-	MV_U32 timeout=100;
-	struct hba_extension *phba = (struct hba_extension *)extension;
-
-	pReq = hba_req_cache_alloc(phba);
-	if (NULL == pReq) {
-		MV_PRINT("%s : cannot allocate memory for req.\n",
-		       mv_product_name);
-		return;
-	}
-
-	while (((phba->Io_Count) || (phba->Ioctl_Io_Count)) && timeout) {
-		//MV_DPRINT(("have running request, Io_Count = %d,, ioctl_count=%d, wait...\n",
-		//	phba->Io_Count,phba->Ioctl_Io_Count));
-		msleep(100);
-		timeout--;
-	}
-	//WARN_ON(phba->Io_Count != 0);
-	//WARN_ON(phba->Ioctl_Io_Count != 0);
-	pReq->Device_Id = VIRTUAL_DEVICE_ID;
-	pReq->Cmd_Initiator = phba;
-	pReq->Org_Req = pReq;
-	pReq->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-	pReq->Completion = hba_shutdown_req_cb;
-	{
-		MV_DPRINT(("Send SHUTDOWN request to CORE.\n"));
-		pReq->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
-		pReq->Cdb[1] = CDB_CORE_MODULE;
-		pReq->Cdb[2] = CDB_CORE_SHUTDOWN;
-		pReq->Req_Type = REQ_TYPE_OS;
-	}
-
-	spin_lock_irqsave(&phba->desc->hba_desc->global_lock, flags);
-	phba->Io_Count++;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	atomic_set(&phba->desc->hba_desc->hba_sync, 1);
-#endif
-	phba->desc->ops->module_sendrequest(phba->desc->extension, pReq);
-	spin_unlock_irqrestore(&phba->desc->hba_desc->global_lock, flags);
-
-	MV_DPRINT(("wait finished send_shutdown_req.\n"));
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	if (0 == __hba_wait_for_atomic_timeout(&phba->desc->hba_desc->hba_sync, 10 * HZ))
-		goto err_shutdown_req;
-#else
-	if(0 == wait_for_completion_timeout(&phba->desc->hba_desc->cmpl, 10 * HZ))
-		goto err_shutdown_req;
-#endif
-	MV_DPRINT(("finished send_shutdown_req.\n"));
-
-	return;
-err_shutdown_req:
-	MV_PRINT("hba_send_shutdown_req failed.\n");
-}
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 7)
-#if ((LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 27))&& (IS_OPENSUSE_SLED_SLES))
-static enum blk_eh_timer_return mv_linux_timed_out(struct scsi_cmnd *cmd)
-{
-	MV_BOOLEAN ret = MV_TRUE;
-	return (ret)?BLK_EH_RESET_TIMER:BLK_EH_NOT_HANDLED;
-
-}
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
-static enum scsi_eh_timer_return mv_linux_timed_out(struct scsi_cmnd *cmd)
-{
-	MV_BOOLEAN ret = MV_TRUE;
-	return (ret)?EH_RESET_TIMER:EH_NOT_HANDLED;
-
-}
-#else
-static enum blk_eh_timer_return mv_linux_timed_out(struct scsi_cmnd *cmd)
-{
-	MV_BOOLEAN ret = MV_TRUE;
-	return (ret)?BLK_EH_RESET_TIMER:BLK_EH_NOT_HANDLED;
-
-}
-#endif
-#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 7) */
-
-void dump_scsi_cmd(const char * prefix, struct scsi_cmnd * scmd)
-{
-	int i = 0;
-	MV_PRINT("%s dump cdb[",prefix);
-	for(i = 0; i < 16; i++)
-		MV_PRINT("0x%02x ", scmd->cmnd[i]);
-	MV_PRINT("]\n");
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
-static int mv_linux_queue_command_lck(struct scsi_cmnd *scmd,
-				  void (*done) (struct scsi_cmnd *))
-#else
-static int mv_linux_queue_command(struct scsi_cmnd *scmd,
-				  void (*done) (struct scsi_cmnd *))
-#endif
-{
-	struct Scsi_Host *host = mv_scmd_host(scmd);
-	struct hba_extension *hba = *((struct hba_extension * *) host->hostdata);
-	PMV_Request req;
-	unsigned long flags;
-
-	if (done == NULL) {
-		MV_PRINT( ": in queuecommand, done function can't be NULL\n");
-		return 0;
-	}
-
-	scmd->result = 0;
-	scmd->scsi_done = done;
-	MV_SCp(scmd)->bus_address = 0;
-	MV_SCp(scmd)->mapped = 0;
-	MV_SCp(scmd)->map_atomic = 0;
-
-	if (mv_scmd_channel(scmd)) {
-		scmd->result = DID_BAD_TARGET << 16;
-		goto done;
-	}
-
-	/*
-	 * Get mv_request resource and translate the scsi_cmnd request
-	 * to mv_request.
-	 */
-	req = hba_req_cache_alloc(hba);
-
-	if (req == NULL) {
-		return SCSI_MLQUEUE_HOST_BUSY;
-	}
-
-	if (scsi_cmd_to_req_conv(hba, scmd, req)) {
-		MV_DPRINT(( "ERROR - Translation from OS Request failed.\n"));
-		hba_req_callback(hba, req);
-		return 0;
-	}
-
-	if(scmd->request->errors)
-		scsi_ioctl_cmd_adjust(hba,scmd,req);
-
-	spin_unlock_irq(host->host_lock);
-	spin_lock_bh(&hba->desc->hba_desc->global_lock);
-
-	hba->Io_Count++;
-
-	MV_ASSERT(hba->State == DRIVER_STATUS_STARTED);
-
-	hba->desc->ops->module_sendrequest(hba->desc->extension, req);
-
-	{
-		MV_PVOID core = (MV_PVOID)HBA_GetModuleExtension(hba, MODULE_CORE);
-		core_push_queues(core);
-	}
-
-	spin_unlock_bh(&hba->desc->hba_desc->global_lock);
-	spin_lock_irq(host->host_lock);
-	return 0;
-done:
-        scmd->scsi_done(scmd);
-        return 0;
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
-static DEF_SCSI_QCMD(mv_linux_queue_command)
-#endif
-
-static int mv_linux_reset (struct scsi_cmnd *scmd)
-{
-	MV_PRINT("__MV__ reset handler %p.\n", scmd);
-	return FAILED;
-}
-
-struct mv_lu *mv_get_avaiable_device(struct hba_extension *hba, MV_U16  target_id, MV_U16 lun)
-{
-	MV_U16 id=0;
-	struct mv_lu * lu=NULL;
-	for (id =0; id < MV_MAX_TARGET_NUMBER; id++) {
-		lu = &hba->mv_unit[id];
-		if (lu && (lu->sdev == NULL) && (lu->lun == 0xFFFF)&& (lu->target_id == 0xFFFF)) {
-			return lu;
-		}
-	}
-	MV_PRINT("invalid target id %d, lun %d.\n",target_id, lun);
-	return NULL;
-}
-
-static int mv_scsi_slave_alloc(struct scsi_device *sdev)
-{
-	struct hba_extension *hba = *((struct hba_extension * *) sdev->host->hostdata);
-	struct mv_lu * lu = mv_get_avaiable_device (hba, sdev->id, sdev->lun);
-	MV_U16 base_id;
-	if(lu == NULL)
-		return -1;
-
-	lu->sdev = sdev;
-	lu->lun = sdev->lun;
-	lu->target_id = sdev->id;
-	base_id = get_id_by_targetid_lun(hba, sdev->id, sdev->lun);
-	if (base_id == 0xFFFF) {
-		MV_DPRINT(("device %d-%d is not exist.\n", sdev->id, sdev->lun));
-		return -1;
-	}
-	sdev->scsi_level=SCSI_SPC_2;
-	return 0;
-}
-
-struct mv_lu *mv_get_device_by_target_lun(struct hba_extension *hba, MV_U16  target_id, MV_U16 lun)
-{
-	MV_U16 id=0;
-	struct mv_lu * lu=NULL;
-	for (id =0; id < MV_MAX_TARGET_NUMBER; id++) {
-		lu = &hba->mv_unit[id];
-		if (lu && lu->sdev && (lu->lun == lun) && (lu->target_id == target_id)) {
-			return lu;
-		}
-	}
-	return NULL;
-}
-
-static void mv_scsi_slave_destroy(struct scsi_device *sdev)
-{
-	struct hba_extension *hba = *((struct hba_extension * *) sdev->host->hostdata);
-	struct mv_lu *lu = mv_get_device_by_target_lun (hba, sdev->id, sdev->lun);
-	if(lu == NULL)
-		return;
-	lu->sdev = NULL;
-	lu->lun = 0xFFFF;
-	lu->target_id = 0xFFFF;
-	return;
-}
-
-static void hba_send_ioctl_cb(MV_PVOID this, PMV_Request req)
-{
-	struct hba_extension *phba = (struct hba_extension *) this;
-
-	hba_req_cache_free(phba,req);
-	phba->Io_Count--;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	atomic_set(&phba->desc->hba_desc->hba_sync, 0);
-#else
-	complete(&phba->desc->hba_desc->cmpl);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
-}
-
-void hba_send_internal_ioctl(struct scsi_device *sdev, MV_PVOID extension, MV_PVOID buffer, MV_U8 cdb1)
-{
-	unsigned long flags;
-	PMV_Request pReq;
-	struct hba_extension *phba = (struct hba_extension *)extension;
-
-	pReq = hba_req_cache_alloc(phba);
-	if (NULL == pReq) {
-		MV_PRINT("%s : cannot allocate memory for req.\n",
-		       mv_product_name);
-		return;
-	}
-
-	if ((phba->Io_Count) || (phba->Ioctl_Io_Count)) {
-		msleep(100);
-	}
-	WARN_ON(phba->Ioctl_Io_Count != 0);
-	pReq->Device_Id = VIRTUAL_DEVICE_ID;
-	pReq->Cmd_Initiator = phba;
-	pReq->Org_Req = pReq;
-	pReq->Data_Buffer = buffer;
-	pReq->Data_Transfer_Length = sizeof(OS_disk_info);
-	pReq->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
-	pReq->Completion = hba_send_ioctl_cb;
-	pReq->Cdb[0] = APICDB0_IOCONTROL;
-	pReq->Cdb[1] = cdb1;
-	pReq->Cdb[2] = sdev->id;
-	pReq->Cdb[3] = sdev->lun;
-	pReq->Req_Type = REQ_TYPE_INTERNAL;
-
-	init_completion(&phba->desc->hba_desc->cmpl);
-	spin_lock_irqsave(&phba->desc->hba_desc->global_lock, flags);
-	phba->Io_Count++;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	atomic_set(&phba->desc->hba_desc->hba_sync, 1);
-#endif
-	phba->desc->ops->module_sendrequest(phba->desc->extension, pReq);
-	spin_unlock_irqrestore(&phba->desc->hba_desc->global_lock, flags);
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-	if (0 == __hba_wait_for_atomic_timeout(&phba->desc->hba_desc->hba_sync, 10 * HZ))
-		goto err_get_hdinfo_req;
-#else
-	if(0 == wait_for_completion_timeout(&phba->desc->hba_desc->cmpl, 10 * HZ))
-		goto err_get_hdinfo_req;
-#endif
-	MV_DPRINT(("finished io control.\n"));
-	return;
-
-err_get_hdinfo_req:
-	MV_PRINT("io control req failed.\n");
-}
-
-static int mv_scsi_slave_configure(struct scsi_device *sdev)
-{
-	struct hba_extension *hba = *((struct hba_extension * *) sdev->host->hostdata);
-	OS_disk_info disk_info;
-	int dev_qth = 1;
-
-	MV_ZeroMemory(&disk_info, sizeof(OS_disk_info));
-	if (hba->RunAsNonRAID) {
-		hba_send_internal_ioctl(sdev, hba, &disk_info, APICDB1_GET_OS_DISK_INFO);
-		if (disk_info.queue_depth)
-			dev_qth = disk_info.queue_depth;
-
-		if (disk_info.disk_type != DISK_TYPE_SATA)
-			sdev->allow_restart = 1;
-	} else
-		dev_qth = MV_MAX_REQUEST_PER_LUN;
-
-	if (sdev->tagged_supported)
-		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev),
-					dev_qth);
-	else {
-		scsi_adjust_queue_depth(sdev, 0, 1);
-		dev_qth = 1;
-	}
-
-	return 0;
-}
-
-#if  LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32))
-static int mv_change_queue_depth(struct scsi_device *sdev, int new_depth, int reason)
-#else
-static int mv_change_queue_depth(struct scsi_device *sdev, int new_depth)
-#endif
-{
-	struct hba_extension *hba = *((struct hba_extension * *) sdev->host->hostdata);
-	OS_disk_info disk_info;
-	int res = 0, dev_qth = 1;
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32))
-	if (reason != SCSI_QDEPTH_DEFAULT)
-		return -EOPNOTSUPP;
-#endif
-
-	MV_ZeroMemory(&disk_info, sizeof(OS_disk_info));
-	if (hba->RunAsNonRAID) {
-		hba_send_internal_ioctl(sdev, hba, &disk_info, APICDB1_GET_OS_DISK_INFO);
-		if (disk_info.queue_depth)
-			dev_qth = disk_info.queue_depth;
-	} else
-		dev_qth = MV_MAX_REQUEST_PER_LUN;
-	if(new_depth > MAX_REQUEST_PER_LUN_PERFORMANCE)
-		return dev_qth;
-	res=new_depth;
-	if (sdev->tagged_supported) {
-		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), res);
-	} else {
-		scsi_adjust_queue_depth(sdev, 0, 1);
-		res = 1;
-	}
-
-	return res;
-}
-
-static int mv_change_queue_type(struct scsi_device *scsi_dev, int qt)
-{
-	if (!scsi_dev->tagged_supported)
-		return 0;
-
-	scsi_deactivate_tcq(scsi_dev, 1);
-
-	scsi_set_tag_type(scsi_dev, qt);
-	scsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);
-
-	return qt;
-}
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-struct class_device_attribute *mvs_host_attrs[];
-#else
-struct device_attribute *mvs_host_attrs[];
-#endif
-
-static struct scsi_host_template mv_driver_template = {
-	.module                      =  THIS_MODULE,
-	.name                        =  "Marvell Storage Controller",
-	.proc_name                   =  mv_driver_name,
-	.proc_info                   =  mv_linux_proc_info,
-	.queuecommand                =  mv_linux_queue_command,
-	.eh_host_reset_handler       =  mv_linux_reset,
-	.slave_alloc                = mv_scsi_slave_alloc,
-	.slave_configure         = mv_scsi_slave_configure,
-	.slave_destroy            = mv_scsi_slave_destroy,
-#if  LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
-	.change_queue_depth	= mv_change_queue_depth,
-	.change_queue_type 	= mv_change_queue_type,
-#endif
-#if  LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 7) && \
-	LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
-	.eh_timed_out                =  mv_linux_timed_out,
-#endif
-	.can_queue                   =  MV_MAX_REQUEST_DEPTH,
-	.this_id                     =  MV_SHT_THIS_ID,
-	.max_sectors                 =  (MV_MAX_TRANSFER_SIZE >> 9),
-	.sg_tablesize                =  MV_MAX_SG_ENTRY,
-	.cmd_per_lun                 =  MV_MAX_REQUEST_PER_LUN,
-	.use_clustering              =  MV_SHT_USE_CLUSTERING,
-	.emulated                    =  MV_SHT_EMULATED,
-	.ioctl                       =  mv_new_ioctl,
-	.shost_attrs		= mvs_host_attrs,
-};
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 15)
-static struct scsi_transport_template mv_transport_template = {
-	.eh_timed_out   =  mv_linux_timed_out,
-};
-#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 16) */
-
-void HBA_ModuleStart(MV_PVOID extension)
-{
-	struct Scsi_Host *host = NULL;
-	struct hba_extension *hba;
-	struct mv_adp_desc *hba_desc;
-	int ret;
-
-	hba = (struct hba_extension *) extension;
-	hba_desc = hba->desc->hba_desc;
-	host = scsi_host_alloc(&mv_driver_template, sizeof(void *));
-	if (NULL == host) {
-		MV_PRINT("%s : Unable to allocate a scsi host.\n",
-		       mv_product_name);
-		goto err_out;
-	}
-
-	*((MV_PVOID *) host->hostdata) = extension;
-	hba_desc->hba_host = host;
-	host->irq          = hba_desc->dev->irq;
-	host->max_id       = MV_MAX_TARGET_NUMBER;
-	host->max_lun      = MV_MAX_LUN_NUMBER;
-	host->max_channel  = 0;
-	host->max_cmd_len  = 16;
-
-	if ((hba->Max_Io) && (hba->Max_Io < MV_MAX_REQUEST_DEPTH)){
-		host->can_queue = 1;
-	}
-
-	MV_DPRINT(("HBA queue command = %d.\n", host->can_queue));
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 15)
-	host->transportt   = &mv_transport_template;
-#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 16) */
-
-	hba->msi_enabled = mv_msi_enable;
-
-	if (hba->msi_enabled)
-		pci_enable_msi(hba->desc->hba_desc->dev);
-
-	MV_DPRINT(( "start install request_irq.\n"));
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 19)
-	ret = request_irq(hba_desc->dev->irq, mv_intr_handler, IRQF_SHARED,
-			  mv_driver_name, hba);
-#else
-	ret = request_irq(hba_desc->dev->irq, mv_intr_handler, SA_SHIRQ,
-			  mv_driver_name, hba);
-#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 19) */
-	if (ret < 0) {
-		MV_PRINT("%s : Error upon requesting IRQ %d.\n",
-		       mv_product_name, hba_desc->dev->irq);
-		goto  err_request_irq;
-	}
-	MV_DPRINT(("request_irq has been installed.\n"));
-
-	return ;
-
-err_request_irq:
-	scsi_host_put(host);
-	hba_desc->hba_host = NULL;
-err_out:
-	return;
-}
-
-#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-static ssize_t
-mvs_show_driver_version(struct class_device *cdev,  char *buffer)
-{
-#else
-static ssize_t
-mvs_show_driver_version(struct device *cdev, struct device_attribute *attr,  char *buffer)
-{
-#endif
-	return snprintf(buffer, PAGE_SIZE, "%s\n", mv_version_linux);
-}
-
-#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-static CLASS_DEVICE_ATTR(driver_version,
-			 S_IRUGO,
-			 mvs_show_driver_version,
-			 NULL);
-#else
-static DEVICE_ATTR(driver_version,
-			 S_IRUGO,
-			 mvs_show_driver_version,
-			 NULL);
-#endif
-
-#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-static ssize_t mvs_show_host_can_queue(struct class_device *cdev, char *buffer)
-{
-#else
-static ssize_t mvs_show_host_can_queue(struct device *cdev, struct device_attribute *attr, char *buffer)
-{
-#endif
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct hba_extension *hba = *((struct hba_extension * *) shost->hostdata);
-	struct mv_adp_desc *hba_desc;
-	hba_desc = hba->desc->hba_desc;
-	return snprintf(buffer, PAGE_SIZE, "%d\n", hba_desc->hba_host->can_queue);
-}
-
-#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-static ssize_t
-mvs_store_host_can_queue(struct class_device *cdev,  const char *buffer, size_t size)
-{
-#else
-static ssize_t
-mvs_store_host_can_queue(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t size)
-{
-#endif
-	struct Scsi_Host *shost = class_to_shost(cdev);
-	struct hba_extension *hba = *((struct hba_extension * *) shost->hostdata);
-	struct mv_adp_desc *hba_desc;
-	int val = 0;
-
-	hba_desc = hba->desc->hba_desc;
-	if (buffer == NULL)
-		return size;
-
-	if (sscanf(buffer, "%d", &val) != 1)
-		return -EINVAL;
-
-	if(val > MAX_REQUEST_NUMBER_PERFORMANCE - 2){
-		printk( "can_queue %d exceeds max vaule:%d\n",  val, MV_MAX_REQUEST_DEPTH);
-		hba_desc->hba_host->can_queue = MV_MAX_REQUEST_DEPTH;
-		return strlen(buffer);
-	} else if (val < 1){
-		printk( "can_queue legal value is >= 1\n");
-		hba_desc->hba_host->can_queue = 1;
-		return strlen(buffer);
-	} else
-		hba_desc->hba_host->can_queue = val;
-	printk( "set host can queue to %d \n",  hba_desc->hba_host->can_queue);
-	return strlen(buffer);
-}
-
-#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-static CLASS_DEVICE_ATTR(host_can_queue,
-			 S_IRUGO|S_IWUSR,
-			 mvs_show_host_can_queue,
-			 mvs_store_host_can_queue);
-#else
-static DEVICE_ATTR(host_can_queue, S_IRUGO|S_IWUSR,
-			 mvs_show_host_can_queue,
-			 mvs_store_host_can_queue);
-#endif
-
-MV_U16 mv_debug_mode = 0; /*CORE_FULL_DEBUG_INFO;*/
-#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-static ssize_t mvs_show_debug_mode(struct class_device *cdev, char *buffer)
-{
-#else
-static ssize_t mvs_show_debug_mode(struct device *cdev, struct device_attribute *attr, char *buffer)
-{
-#endif
-	return snprintf(buffer, PAGE_SIZE, "0x%x\n", mv_debug_mode);
-}
-
-#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-static ssize_t
-mvs_store_debug_mode(struct class_device *cdev,  const char *buffer, size_t size)
-{
-#else
-static ssize_t
-mvs_store_debug_mode(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t size)
-{
-#endif
-
-	int val = 0;
-
-	if (buffer == NULL)
-		return size;
-
-	if (sscanf(buffer, "0x%x", &val) != 1) {
-		printk( "Input invalid debug mode, please input hexadecimal number:0x0~0xf.\n");
-		return -EINVAL;
-	}
-
-	mv_debug_mode = val;
-	if(mv_debug_mode > 0xF){
-		printk( "Invalid debug mode, close all debug info!\n");
-		mv_debug_mode = 0x0;
-		return strlen(buffer);
-	} else
-		printk( "set debug mode to 0x%x\n",  mv_debug_mode);
-	return strlen(buffer);
-}
-
-#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-static CLASS_DEVICE_ATTR(debug_mode,
-			 S_IRUGO|S_IWUSR,
-			 mvs_show_debug_mode,
-			 mvs_store_debug_mode);
-#else
-static DEVICE_ATTR(debug_mode, S_IRUGO|S_IWUSR,
-			 mvs_show_debug_mode,
-			 mvs_store_debug_mode);
-#endif
-
-#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-struct class_device_attribute *mvs_host_attrs[] = {
-	&class_device_attr_driver_version,
-	&class_device_attr_host_can_queue,
-	&class_device_attr_debug_mode,
-	NULL,
-};
-#else
-struct device_attribute *mvs_host_attrs[] = {
-	&dev_attr_driver_version,
-	&dev_attr_host_can_queue,
-	&dev_attr_debug_mode,
-	NULL,
-};
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-unsigned int mv_prot_mask =  SHOST_DIF_TYPE1_PROTECTION |SHOST_DIF_TYPE3_PROTECTION;
-module_param(mv_prot_mask, uint, 0);
-MODULE_PARM_DESC(mv_prot_mask, "host protection mask");
-#endif
-
-static int __init sas_hba_init(void)
-{
-	hba_house_keeper_init();
-	return pci_register_driver(&mv_pci_driver);
-}
-
-static void __exit sas_hba_exit(void)
-{
-	pci_unregister_driver(&mv_pci_driver);
-	MV_DPRINT(("sas_hba_exit: before hba_house_keeper_exit\n"));
-	hba_house_keeper_exit();
-}
-
-MODULE_AUTHOR ("Marvell Technolog Group Ltd.");
-MODULE_DESCRIPTION ("Marvell SAS hba driver");
-
-MODULE_LICENSE("GPL");
-
-MODULE_VERSION(mv_version_linux);
-MODULE_DEVICE_TABLE(pci, mv_pci_ids);
-module_init(sas_hba_init);
-module_exit(sas_hba_exit);
--- a/drivers/scsi/vanir/linux/linux_main.h
+++ /dev/null
@@ -1,77 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef _LINUX_MAIN_H
-#define _LINUX_MAIN_H
-
-#include "hba_header.h"
-
-#define __mv_get_ext_from_host(phost) \
-          (((HBA_Extension **) (phost)->hostdata)[0])
-
-/* for communication with OS/SCSI mid layer only */
-enum {
-	MV_MAX_REQUEST_DEPTH		 = MAX_REQUEST_NUMBER_PERFORMANCE - 2,
-	MV_MAX_IO                = MAX_REQUEST_NUMBER_PERFORMANCE,
-	MV_MAX_REQUEST_PER_LUN   = MAX_REQUEST_PER_LUN_PERFORMANCE,
-	MV_MAX_SG_ENTRY          = SG_ALL,
-	MV_MAX_IOCTL_REQUEST = 30,
-	MV_SHT_USE_CLUSTERING    = ENABLE_CLUSTERING,
-	MV_SHT_EMULATED          = 0,
-	MV_SHT_THIS_ID           = -1,
-};
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-#define mv_scmd_host(cmd)    cmd->device->host
-#define mv_scmd_channel(cmd) cmd->device->channel
-#define mv_scmd_target(cmd)  cmd->device->id
-#define mv_scmd_lun(cmd)     cmd->device->lun
-#else
-#define mv_scmd_host(cmd)    cmd->host
-#define mv_scmd_channel(cmd) cmd->channel
-#define mv_scmd_target(cmd)  cmd->target
-#define mv_scmd_lun(cmd)     cmd->lun
-#endif
-
-#define LO_BUSADDR(x) ((MV_U32)(x))
-#define HI_BUSADDR(x) (MV_U32)(sizeof(BUS_ADDRESS)>4? (u64)(x) >> 32 : 0)
-
-struct _MV_SCP {
-	MV_U16           mapped;
-	MV_U16           map_atomic;
-	BUS_ADDRESS bus_address;
-};
-
-#define MV_SCp(cmd) ((struct _MV_SCP *)(&((struct scsi_cmnd *)cmd)->SCp))
-
-#ifndef scsi_to_pci_dma_dir
-#define scsi_to_pci_dma_dir(scsi_dir) ((int)(scsi_dir))
-#endif
-
-void  hba_req_cache_destroy(MV_PVOID hba_ext);
-int hba_req_cache_create(MV_PVOID hba_ext);
-PMV_Request hba_req_cache_alloc(MV_PVOID hba_ext);
-void hba_req_cache_free(MV_PVOID hba_ext,PMV_Request req) ;
-void mv_complete_request(struct hba_extension *phba,
-				struct scsi_cmnd *scmd,
-				PMV_Request pReq);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
-int __hba_wait_for_atomic_timeout(atomic_t *atomic, unsigned long timeout);
-#endif
-
-extern void * kbuf_array[512];
-extern unsigned char mvcdb[512][16];
-extern int mv_new_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
-void hba_send_shutdown_req(MV_PVOID);
-
-#endif /*_LINUX_MAIN_H*/
--- a/drivers/scsi/vanir/linux/mv_os.c
+++ /dev/null
@@ -1,437 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_os.h"
-#include "hba_mod.h"
-
-/* os timer function */
-void ossw_init_timer(struct timer_list *timer)
-{
-	timer->function = NULL;
-	init_timer(timer);
-}
-
-u8 ossw_add_timer(struct timer_list *timer,
-		    u32 msec,
-		    void (*function)(unsigned long),
-		    unsigned long data)
-{
-	u64 jif;
-
-	if(timer_pending(timer))
-		del_timer(timer);
-
-	timer->function = function;
-	timer->data     = data;
-
-	jif = (u64) (msec * HZ);
-	do_div(jif, 1000);		   /* wait in unit of second */
-	timer->expires = jiffies + 1 + jif;
-
-	add_timer(timer);
-	return	0;
-}
-
-
-void ossw_del_timer(struct timer_list *timer)
-{
-	if (timer->function)
-		del_timer(timer);
-	timer->function = NULL;
-}
-
-int ossw_time_expired(unsigned long time_value)
-{
-	return (time_before(time_value, jiffies));
-}
-
-unsigned long ossw_set_expired_time(u32 msec)
-{
-	return (jiffies + msecs_to_jiffies(msec));
-}
-
-/* os spin lock function */
-void  ossw_local_irq_save(unsigned long *flags){ unsigned long save_flag;local_irq_save(save_flag); *flags = save_flag; }
-void ossw_local_irq_restore(unsigned long *flags){unsigned long save_flag = *flags;local_irq_restore(save_flag);}
-void  ossw_local_irq_disable(void){ local_irq_disable();}
-void ossw_local_irq_enable(void){local_irq_enable();}
-/* expect pointers */
-void ossw_init_spin_lock(void *ext)
-{
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->global_lock;
-	spin_lock_init(plock);
-}
-
-
-void ossw_spin_lock(void *ext)
-{
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->global_lock;
-	spin_lock(plock);
-}
-
-void ossw_spin_unlock(void *ext)
-{
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->global_lock;
-	spin_unlock(plock);
-}
-
-void ossw_spin_lock_irq(void *ext)
-{
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->global_lock;
-	spin_lock_irq(plock);
-}
-
-void ossw_spin_unlock_irq(void *ext)
-{
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->global_lock;
-	spin_unlock_irq(plock);
-}
-
-void ossw_spin_lock_irq_save(void *ext, unsigned long *flags)
-{
-	unsigned long save_flag;
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->global_lock;
-	spin_lock_irqsave(plock, save_flag);
-	*flags = save_flag;
-}
-
-void ossw_spin_unlock_irq_restore(void *ext, unsigned long *flags)
-{
-	unsigned long save_flag = *flags;
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->global_lock;
-	spin_unlock_irqrestore(plock, save_flag);
-}
-
-void ossw_spin_lock_irq_save_spin_up(void *ext, unsigned long *flags)
-{
-	unsigned long save_flag;
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->device_spin_up;
-	spin_lock_irqsave(plock, save_flag);
-	*flags = save_flag;
-}
-
-void ossw_spin_unlock_irq_restore_spin_up(void *ext, unsigned long *flags)
-{
-	unsigned long save_flag = *flags;
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
-	spinlock_t *plock = &hba_desc->device_spin_up;
-	spin_unlock_irqrestore(plock, save_flag);
-}
-
-/* os get time function */
-u32 ossw_get_time_in_sec(void)
-{
-	struct timeval tv;
-
-	do_gettimeofday(&tv);
-	return (u32) tv.tv_sec;
-}
-
-u32 ossw_get_msec_of_time(void)
-{
-	struct timeval tv;
-
-	do_gettimeofday(&tv);
-	return (u32) tv.tv_usec*1000*1000;
-}
-
-/*kernel time.h:extern struct timezone sys_tz;*/
-extern struct timezone sys_tz;
-u32 ossw_get_local_time(void)
-{
-	static MV_U32 utc_time=0,local_time=0;
-	utc_time=ossw_get_time_in_sec();
-	local_time = (u32)(utc_time - (sys_tz.tz_minuteswest * 60));
-	return local_time;
-}
-
-/* os bit endian function */
-u16 ossw_cpu_to_le16(u16 x)  	{ return cpu_to_le16(x);}
-u32 ossw_cpu_to_le32(u32 x)	{ return cpu_to_le32(x);}
-u64 ossw_cpu_to_le64(u64 x)   	{ return cpu_to_le64(x);}
-u16 ossw_cpu_to_be16(u16 x)      	{ return cpu_to_be16(x);}
-u32 ossw_cpu_to_be32(u32 x)	{ return cpu_to_be32(x);}
-u64 ossw_cpu_to_be64(u64 x)   	{ return cpu_to_be64(x);}
-
-u16 ossw_le16_to_cpu(u16 x)      	{ return le16_to_cpu(x);}
-u32 ossw_le32_to_cpu(u32 x)      	{ return le32_to_cpu(x);}
-u64 ossw_le64_to_cpu(u64 x)      	{ return le64_to_cpu(x);}
-u16 ossw_be16_to_cpu(u16 x)      	{ return be16_to_cpu(x);}
-u32 ossw_be32_to_cpu(u32 x)      	{ return be32_to_cpu(x);}
-u64 ossw_be64_to_cpu(u64 x)      	{ return be64_to_cpu(x);}
-
-/* os map sg address function */
-void *ossw_kmap(void  *sg)
-{
-#ifndef CONFIG_ARM
-	struct scatterlist *ksg = (struct scatterlist *)sg;
-	void *kvaddr = NULL;
-
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-	kvaddr = page_address(ksg->page);
-	if (!kvaddr)
-#endif
-		kvaddr = map_sg_page(ksg);
-	kvaddr += ksg->offset;
-	return kvaddr;
-#else
-	BUG_ON(1);
-#endif
-}
-
-void ossw_kunmap(void  *sg, void *mapped_addr)
-{
-#ifndef CONFIG_ARM
-	struct scatterlist *ksg = (struct scatterlist *)sg;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-	void *kvaddr = NULL;
-	kvaddr = page_address(ksg->page);
-	if (!kvaddr)
-#endif
-	kunmap_atomic(mapped_addr - ksg->offset, KM_IRQ0);
-#else
-	BUG_ON(1);
-#endif
-}
-
-void *ossw_kmap_sec(void  *sg)
-{
-#ifndef CONFIG_ARM
-	struct scatterlist *ksg = (struct scatterlist *)sg;
-	void *kvaddr = NULL;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-	kvaddr = page_address(ksg->page);
-	if (!kvaddr)
-#endif
-		kvaddr = map_sg_page_sec(ksg);
-	kvaddr += ksg->offset;
-	return kvaddr;
-#else
-	BUG_ON(1);
-#endif
-}
-
-void ossw_kunmap_sec(void  *sg, void *mapped_addr)
-{
-#ifndef CONFIG_ARM
-	struct scatterlist *ksg = (struct scatterlist *)sg;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-	void *kvaddr = NULL;
-	kvaddr = page_address(ksg->page);
-	if (!kvaddr)
-#endif
-	kunmap_atomic(mapped_addr - ksg->offset, KM_IRQ1);
-#else
-	BUG_ON(1);
-#endif
-}
-
-struct pci_pool *ossw_pci_pool_create( char *name, void *ext ,
-	size_t size, size_t align, size_t alloc)
-{
-
-	struct pci_dev *dev;
-	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
-	MV_DASSERT(mod_desc);
-	dev = mod_desc->hba_desc->dev;
-	sprintf(name,"%s%d",name,mod_desc->hba_desc->id);
-	return pci_pool_create(name, dev, size, align, alloc);
-}
-
-void ossw_pci_pool_destroy(struct pci_pool * pool)
-{
-	pci_pool_destroy(pool);
-}
-
-void *ossw_pci_pool_alloc(struct pci_pool *pool, u64 *dma_handle)
-{
-	return pci_pool_alloc(pool, GFP_ATOMIC, (dma_addr_t *)dma_handle);
-}
-
-void ossw_pci_pool_free(struct pci_pool *pool, void *vaddr, u64 addr)
-{
-	pci_pool_free(pool, vaddr, addr);
-}
-
-void * ossw_kmem_cache_create(const char *name, size_t size,
-		size_t align, unsigned long flags)
-{
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	return (void *)kmem_cache_create(name, size, align, flags, NULL);
-#else
-	return (void *)kmem_cache_create(name, size, align, flags, NULL, NULL);
-#endif
-}
-
-void * ossw_kmem_cache_alloc( void * cachep, u32 flags)
-{
-	kmem_cache_t  *cache = (kmem_cache_t *)cachep;
-	return kmem_cache_alloc(cache, (gfp_t)flags);
-}
-
-void ossw_kmem_cache_free(void *cachep, void *objp)
-{
-	kmem_cache_t  *cache = (kmem_cache_t *)cachep;
-	kmem_cache_free(cache, objp);
-}
-
-void ossw_kmem_cache_distroy(void *cachep)
-{
-	kmem_cache_t  *cache = (kmem_cache_t *)cachep;
-	kmem_cache_destroy(cache);
-}
-
-unsigned long ossw_virt_to_phys(void *address)
-{
-	return virt_to_phys(address);
-}
-
-void * ossw_phys_to_virt(unsigned long address)
-{
-	return phys_to_virt(address);
-}
-
-/* os u64 div function */
-u64 ossw_u64_div(u64 n, u64 base)
-{
-	do_div(n, (unsigned int)base);
-	return n;
-}
-
-u64 ossw_u64_mod(u64 n, u64 base)
-{
-	return do_div(n, (unsigned int)base);
-}
-
-
-/* bit operation */
-u32 ossw_rotr32(u32 v, int count)
-{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
-	return ror32(v, count);
-#else
-	return (v << count) | (v >> (32 - count));
-#endif
-}
-
- /*ffs - normally return from 1 to MSB, if not find set bit, return 0*/
-int ossw_ffz(unsigned long v)	{return (ffs(~v)-1);}
-int ossw_ffs(unsigned long v)	{return (ffs(v)-1);}
-
-void *ossw_memcpy(void *dest, const void *source, size_t len) { return memcpy(dest, source, len);}
-void *ossw_memset(void *buf, int pattern, size_t len) {return memset(buf, pattern, len);}
-int ossw_memcmp(const void *buf0, const void *buf1, size_t len) {return memcmp(buf0, buf1, len); }
-
-
-/* os read pci config function */
-int MV_PCI_READ_CONFIG_DWORD(void * ext, u32 offset, u32 *ptr)	{return pci_read_config_dword(__ext_to_gen(ext)->desc->hba_desc->dev, offset, ptr);}
-int MV_PCI_READ_CONFIG_WORD(void * ext, u32 offset, u16 *ptr)	{return pci_read_config_word(__ext_to_gen(ext)->desc->hba_desc->dev, offset, ptr);}
-int MV_PCI_READ_CONFIG_BYTE(void * ext, u32 offset, u8 *ptr) 		{return  pci_read_config_byte(__ext_to_gen(ext)->desc->hba_desc->dev, offset, ptr);}
-int MV_PCI_WRITE_CONFIG_DWORD(void *ext, u32 offset, u32 val)	{return  pci_write_config_dword(__ext_to_gen(ext)->desc->hba_desc->dev, offset, val);}
-int MV_PCI_WRITE_CONFIG_WORD(void *ext, u32 offset, u16 val) 	{return pci_write_config_word(__ext_to_gen(ext)->desc->hba_desc->dev, offset, val);}
-int MV_PCI_WRITE_CONFIG_BYTE(void *ext, u32 offset, u8 val)		{return pci_write_config_byte(__ext_to_gen(ext)->desc->hba_desc->dev, offset, val);}
-
-/* System dependent macro for flushing CPU write cache */
-void MV_CPU_WRITE_BUFFER_FLUSH(void) 	{smp_wmb();}
-void MV_CPU_READ_BUFFER_FLUSH(void)  	{smp_rmb();}
-void MV_CPU_BUFFER_FLUSH(void)       			{smp_mb();}
-
-/* register read write: memory io */
-void MV_REG_WRITE_BYTE(void *base, u32 offset, u8 val)		{writeb(val, base + offset);}
-void MV_REG_WRITE_WORD(void *base, u32 offset, u16 val)	{writew(val, base + offset);}
-void MV_REG_WRITE_DWORD(void *base, u32 offset, u32 val)   {writel(val, base + offset);}
-
-u8 		MV_REG_READ_BYTE(void *base, u32 offset)			{return readb(base + offset);}
-u16 		MV_REG_READ_WORD(void *base, u32 offset)			{return readw(base + offset);}
-u32 		MV_REG_READ_DWORD(void *base, u32 offset)		{return readl(base + offset);}
-
-/* register read write: port io */
-void	MV_IO_WRITE_BYTE(void *base, u32 offset, u8 val)	{outb(val, (unsigned)(MV_PTR_INTEGER)(base + offset));}
-void MV_IO_WRITE_WORD(void *base, u32 offset, u16 val)    {outw(val, (unsigned)(MV_PTR_INTEGER)(base + offset));}
-void MV_IO_WRITE_DWORD(void *base, u32 offset, u32 val)    {outl(val, (unsigned)(MV_PTR_INTEGER)(base + offset));}
-
-u8	MV_IO_READ_BYTE(void *base, u32 offset)	{return inb((unsigned)(MV_PTR_INTEGER)(base + offset));}
-u16	MV_IO_READ_WORD(void *base, u32 offset)	{return inw((unsigned)(MV_PTR_INTEGER)(base + offset));}
-u32 	MV_IO_READ_DWORD(void *base, u32 offset)	{return inl((unsigned)(MV_PTR_INTEGER)(base + offset));}
-
-
-/* os print function */
-int  ossw_printk(char *fmt, ...)
-{
-	va_list args;
-	static char buf[1024];
-
-	va_start(args, fmt);
-	vsnprintf(buf, sizeof(buf), fmt, args);
-	va_end(args);
-	return printk("%s",  buf);
-}
-
-#ifdef _SUPPORT_64_BIT
-void MV_DUMP_SP(void)
-{
-	printk("THREAD_SIZE= %d,PID =%d.\n", (unsigned int)THREAD_SIZE,(unsigned int)current->tgid);
-	dump_stack();
-}
-
-#else
-void MV_DUMP_SP(void )
-{
-	unsigned long sp;
-#ifdef CONFIG_X86
-	__asm__ __volatile__("andl %%esp,%0" :"=r" (sp) : "0" (THREAD_SIZE - 1));
-	printk("SP = %ld ,THREAD_SIZE= %d,PID =%d.\n",sp, (unsigned int)THREAD_SIZE,(unsigned int)current->tgid);
-#elif defined(CONFIG_PPC)
-	__asm__ __volatile__("mr %0, 1":"=r"(sp));
-	printk("SP = %ld ,THREAD_SIZE= %d,PID =%d.\n",sp, (unsigned int)THREAD_SIZE,(unsigned int)current->tgid);
-#elif defined(CONFIG_ARM)
-
-#else
-#error "Please add the corresponding stack retrieval info."
-#endif
-	dump_stack();
-}
-#endif
-
-
-/* Sleeping is disallowed if any of these macroes evalute as true*/
-void MV_DUMP_CTX(void)
-{
-	if( in_irq())
-		printk("Present process is in hard IRQ context.\n");
-	if(in_softirq())
-		printk("Present process is in soft IRQ(BH) context.\n");
-	if( in_interrupt())
-		 printk("Present process is in hard/soft IRQ context.\n");
-	if(in_atomic())
-		 printk("Present process is  in preemption-disabled context .\n");
-}
--- a/drivers/scsi/vanir/linux/mv_os.h
+++ /dev/null
@@ -1,310 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __LINUX_OS_H__
-#define __LINUX_OS_H__
-
-#ifndef LINUX_VERSION_CODE
-#   include <linux/version.h>
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)) && (!defined AUTOCONF_INCLUDED)
-#   include <linux/config.h>
-#endif
-
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/timer.h>
-#include <linux/time.h>
-#include <linux/reboot.h>
-#include <linux/ioport.h>
-#include <linux/delay.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <linux/cdev.h>
-#include <linux/spinlock.h>
-#include <linux/pci.h>
-#include <linux/completion.h>
-#include <linux/blkdev.h>
-#include <linux/vmalloc.h>
-#include <linux/kthread.h>
-
-#include <linux/device.h>
-#include <linux/nmi.h>
-
-#include <linux/slab.h>
-#include <linux/mempool.h>
-#include <linux/ctype.h>
-#include "linux/hdreg.h"
-
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/div64.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi_tcq.h>
-#include <scsi/scsi_transport.h>
-#include <scsi/scsi_ioctl.h>
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
-#include <scsi/scsi_request.h>
-#endif
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
-#include <linux/freezer.h>
-#endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,6))
-	#include <linux/moduleparam.h>
-	#endif
-#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 7) */
-
-/* OS specific flags */
-
-
-#ifndef NULL
-#   define NULL 0
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
-#define PCI_D0 0
-#include <linux/suspend.h>
-typedef u32 pm_message_t;
-
-static inline int try_to_freeze(unsigned long refrigerator_flags)
-{
-        if (unlikely(current->flags & PF_FREEZE)) {
-               refrigerator(refrigerator_flags);
-                return 1;
-        } else
-             return 0;
-}
-#endif
-
-#define MV_INLINE inline
-#define CDB_INQUIRY_EVPD    1
-
-/* If VER_BUILD ,the 4th bit is 0 */
-#if (VER_BUILD < 1000)
-#define NUM_TO_STRING(num1, num2, num3, num4) # num1"."# num2"."# num3".""0"# num4
-#else
-#define NUM_TO_STRING(num1, num2, num3, num4) # num1"."# num2"."# num3"."# num4
-#endif
-#define VER_VAR_TO_STRING(major, minor, oem, build) NUM_TO_STRING(major, \
-								  minor, \
-								  oem,   \
-								  build)
-
-#define mv_version_linux   VER_VAR_TO_STRING(VER_MAJOR, VER_MINOR,       \
-					     VER_OEM, VER_BUILD) VER_TEST
-
-#ifndef TRUE
-#define TRUE 	1
-#define FALSE	0
-#endif
-
-#ifdef CONFIG_64BIT
-#   define __KCONF_64BIT__
-#endif /* CONFIG_64BIT */
-
-#if defined(__LITTLE_ENDIAN)
-#   define __MV_LITTLE_ENDIAN__  1
-#elif defined(__BIG_ENDIAN)
-#   define __MV_BIG_ENDIAN__     1
-#else
-#   error "error in endianness"
-#endif
-
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-#   define __MV_LITTLE_ENDIAN_BITFIELD__   1
-#elif defined(__BIG_ENDIAN_BITFIELD)
-#   define __MV_BIG_ENDIAN_BITFIELD__      1
-#else
-#   error "error in endianness"
-#endif
-
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
-#define mv_use_sg(cmd)	cmd->use_sg
-#define mv_rq_bf(cmd)	cmd->request_buffer
-#define mv_rq_bf_l(cmd)	cmd->request_bufflen
-#else
-#define mv_use_sg(cmd)	scsi_sg_count(cmd)
-#define mv_rq_bf(cmd)	scsi_sglist(cmd)
-#define mv_rq_bf_l(cmd)	scsi_bufflen(cmd)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-#define map_sg_page(sg)		kmap_atomic(sg->page, KM_IRQ0)
-#define map_sg_page_sec(sg)		kmap_atomic(sg->page, KM_IRQ1)
-#else
-#define map_sg_page(sg)		kmap_atomic(sg_page(sg), KM_IRQ0)
-#define map_sg_page_sec(sg)		kmap_atomic(sg_page(sg), KM_IRQ1)
-#endif
-
-
-struct gen_module_desc {
-/* Must the first */
-	struct mv_mod_desc *desc;
-};
-#define __ext_to_gen(_ext)       ((struct gen_module_desc *) (_ext))
-
-
-/* os timer function */
-void ossw_init_timer(struct timer_list *timer);
-u8 ossw_add_timer(struct timer_list *timer,
-		    u32 msec,
-		    void (*function)(unsigned long),
-		    unsigned long data);
-void ossw_del_timer(struct timer_list *timer);
-
-int ossw_time_expired(unsigned long time_value);
-unsigned long ossw_set_expired_time(u32 msec);
-
-/* os spin lock function */
-void  ossw_local_irq_save(unsigned long *flags);
-void ossw_local_irq_restore(unsigned long *flags);
-void  ossw_local_irq_disable(void);
-void ossw_local_irq_enable(void);
-
-/* expect pointers */
-void ossw_init_spin_lock(void *ext);
-void ossw_spin_lock(void *ext);
-void ossw_spin_unlock(void *ext);
-void ossw_spin_lock_irq(void *ext);
-void ossw_spin_unlock_irq(void *ext);
-void ossw_spin_lock_irq_save(void *ext, unsigned long *flags);
-void ossw_spin_unlock_irq_restore(void *ext, unsigned long *flags);
-void ossw_spin_lock_irq_save_spin_up(void *ext, unsigned long *flags);
-void ossw_spin_unlock_irq_restore_spin_up(void *ext, unsigned long *flags);
-
-/* os get time function */
-u32 ossw_get_time_in_sec(void);
-u32 ossw_get_msec_of_time(void);
-u32 ossw_get_local_time(void);
-
-/* os kmem_cache */
-#define MV_ATOMIC GFP_ATOMIC
-
-struct pci_pool *ossw_pci_pool_create(char *name, void *ext,
-	size_t size, size_t align, size_t alloc);
-void ossw_pci_pool_destroy(struct pci_pool * pool);
-void *ossw_pci_pool_alloc(struct pci_pool *pool, u64 *dma_handle);
-void ossw_pci_pool_free(struct pci_pool *pool, void *vaddr, u64 addr);
-
-
-void * ossw_kmem_cache_create(const char *, size_t, size_t, unsigned long);
-void * ossw_kmem_cache_alloc( void *, unsigned);
-void ossw_kmem_cache_free(void *, void *);
-void ossw_kmem_cache_distroy(void *);
-
-unsigned long ossw_virt_to_phys(void *);
-void * ossw_phys_to_virt(unsigned long address);
-
-
-/* os bit endian function */
-u16 ossw_cpu_to_le16(u16 x);
-u32 ossw_cpu_to_le32(u32 x);
-u64 ossw_cpu_to_le64(u64 x);
-u16 ossw_cpu_to_be16(u16 x);
-u32 ossw_cpu_to_be32(u32 x);
-u64 ossw_cpu_to_be64(u64 x);
-
-u16 ossw_le16_to_cpu(u16 x);
-u32 ossw_le32_to_cpu(u32 x);
-u64 ossw_le64_to_cpu(u64 x) ;
-u16 ossw_be16_to_cpu(u16 x);
-u32 ossw_be32_to_cpu(u32 x);
-u64 ossw_be64_to_cpu(u64 x) ;
-
-/* os map sg address function */
-void *ossw_kmap(void  *sg);
-void ossw_kunmap(void  *sg, void *mapped_addr);
-void *ossw_kmap_sec(void  *sg);
-void ossw_kunmap_sec(void  *sg, void *mapped_addr);
-
-/* MISC Services */
-#define ossw_udelay(x) udelay(x)
-
-/* os u64 div function */
-u64 ossw_u64_div(u64 n, u64 base);
-u64 ossw_u64_mod(u64 n, u64 base);
-
-
-/* bit operation */
-u32 ossw_rotr32(u32 v, int count);
-
-int ossw_ffz(unsigned long v);
-int ossw_ffs(unsigned long v);
-
-void *ossw_memcpy(void *dest, const void *source, size_t len) ;
-void *ossw_memset(void *buf, int patten, size_t len) ;
-int ossw_memcmp(const void *buf0, const void *buf1, size_t len) ;
-
-/* os read pci config function */
-int MV_PCI_READ_CONFIG_DWORD(void * ext, u32 offset, u32 *ptr);
-int MV_PCI_READ_CONFIG_WORD(void * ext, u32 offset, u16 *ptr);
-int MV_PCI_READ_CONFIG_BYTE(void * ext, u32 offset, u8 *ptr);
-int MV_PCI_WRITE_CONFIG_DWORD(void *ext, u32 offset, u32 val);
-int MV_PCI_WRITE_CONFIG_WORD(void *ext, u32 offset, u16 val);
-int MV_PCI_WRITE_CONFIG_BYTE(void *ext, u32 offset, u8 val);
-
-/* System dependent macro for flushing CPU write cache */
-void MV_CPU_WRITE_BUFFER_FLUSH(void);
-void MV_CPU_READ_BUFFER_FLUSH(void);
-void MV_CPU_BUFFER_FLUSH(void);
-
-/* register read write: memory io */
-void MV_REG_WRITE_BYTE(void *base, u32 offset, u8 val);
-void MV_REG_WRITE_WORD(void *base, u32 offset, u16 val);
-void MV_REG_WRITE_DWORD(void *base, u32 offset, u32 val);
-
-u8 		MV_REG_READ_BYTE(void *base, u32 offset);
-u16 		MV_REG_READ_WORD(void *base, u32 offset)	;
-u32 		MV_REG_READ_DWORD(void *base, u32 offset);
-
-/* register read write: port io */
-void	MV_IO_WRITE_BYTE(void *base, u32 offset, u8 val);
-void MV_IO_WRITE_WORD(void *base, u32 offset, u16 val) ;
-void MV_IO_WRITE_DWORD(void *base, u32 offset, u32 val) ;
-
-u8	MV_IO_READ_BYTE(void *base, u32 offset);
-u16	MV_IO_READ_WORD(void *base, u32 offset);
-u32 	MV_IO_READ_DWORD(void *base, u32 offset);
-
-int  ossw_printk(char *fmt, ...);
-
-void MV_DUMP_SP(void);
-void MV_DUMP_CTX(void);
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
-#ifdef _SUPPORT_64_BIT
-	typedef u64 resource_size_t;
- #else
-	typedef u32 resource_size_t;
-#endif
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
-typedef struct kmem_cache kmem_cache_t;
-#endif
-
-#endif /* LINUX_OS_H */
--- a/drivers/scsi/vanir/mv_conf.mk
+++ /dev/null
@@ -1 +0,0 @@
-SUPPORT_VANIR=y
--- a/drivers/scsi/vanir/mv_config.h
+++ /dev/null
@@ -1,17 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined(MV_CONFIGURATION_H)
-#define MV_CONFIGURATION_H
-#include "mv_config_vanir.h"
-#endif /* MV_CONFIGURATION_H */
--- a/drivers/scsi/vanir/mv_config_vanir.h
+++ /dev/null
@@ -1,35 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_CONFIG_VANIR_H__
-#define __MV_CONFIG_VANIR_H__
-
-#define VANIR_PRODUCT
-
-/* driver configuration */
-#define mv_driver_name   "mv94xx"
-#define mv_product_name  "VANIR"
-
-#define VER_MAJOR           4
-#define VER_MINOR        0
-#define VER_OEM        	0
-#define VER_BUILD        1531
-#define VER_TEST         "N"
-
-#define PORT_NUMBER 8
-
-#include "mv_product_vanir.h"
-#include "mv_hba.h"
-#include "mv_linux.h"
-
-#endif/*__MV_CONFIG_VANIR_H__*/
--- a/drivers/scsi/vanir/mv_include.h
+++ /dev/null
@@ -1,32 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#if !defined(MV_INCLUDE_H)
-#define MV_INCLUDE_H
-#include "mv_config.h"
-#include "mv_os.h"
-
-#include "com_type.h"
-#include "com_u64.h"
-#include "com_util.h"
-#include "com_list.h"
-#include "com_dbg.h"
-#include "com_scsi.h"
-#include "com_api.h"
-#include "com_extern.h"
-#include "com_struct.h"
-#include "com_ioctl.h"
-
-#include "hba_exp.h"
-
-#endif /* MV_INCLUDE_H */
--- a/drivers/scsi/vanir/mv_linux.h
+++ /dev/null
@@ -1,24 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_LINUX_H__
-#define __MV_LINUX_H__
-
-#define CACHE_NAME_LEN 			32
-
-/*Max ID report to OS: HD+Enclosure+PM+virtual device*/
-#define MV_MAX_ID                                      \
-        (MV_MAX_TARGET_NUMBER + MAX_EXPANDER_SUPPORTED + \
-         MAX_PM_SUPPORTED + 1)/*reserved 1 ID for virtual device ID*/
-
-#endif /* __MV_LINUX_H__ */
--- a/drivers/scsi/vanir/patch.kbuild
+++ /dev/null
@@ -1,10 +0,0 @@
---- scsi/Makefile	2009-10-15 23:03:27.153059900 -0400
-+++ scsi_new/Makefile	2009-10-15 23:11:29.673495100 -0400
-@@ -48,6 +48,7 @@
- obj-$(CONFIG_A2091_SCSI)	+= a2091.o	wd33c93.o
- obj-$(CONFIG_GVP11_SCSI)	+= gvp11.o	wd33c93.o
- obj-$(CONFIG_MVME147_SCSI)	+= mvme147.o	wd33c93.o
-+obj-$(CONFIG_SCSI_MV_94xx)	+= mv/
- obj-$(CONFIG_SGIWD93_SCSI)	+= sgiwd93.o	wd33c93.o
- obj-$(CONFIG_ATARI_SCSI)	+= atari_scsi.o
- obj-$(CONFIG_MAC_SCSI)		+= mac_scsi.o
--- a/drivers/scsi/vanir/patch.sh
+++ /dev/null
@@ -1,87 +0,0 @@
-#!/bin/sh
-. ./mv_conf.mk
-subtxt(){
-
-    if [ ! -f "$1" ] || [ ! -w "$1" ]; then
-	echo "File does not exist or is not writable."
-	exit 1
-    fi
-
-    if [ "$2" = "a" ];then
-        if [ "$SUPPORT_THOR" = "y"  ];then
-
-            grep SCSI_MV_61xx "$1" >/dev/null 2>&1
-	    if [ "$?" = "0" ];then
-	        cat "$1"
-                return
-	    fi
-
-            sed -e '/if SCSI_LOWLEVEL && SCSI/{
-                    a\
-config SCSI_MV_61xx\
-	tristate "Marvell Storage Controller 6121/6122/6141/6145"\
-	depends on SCSI && BLK_DEV_SD\
-	help\
-		Provides support for Marvell 61xx Storage Controller series.\n
-}' "$1"
-
-        elif [ "$SUPPORT_VANIR" = "y" ]; then
-
-            grep SCSI_MV_94xx "$1" >/dev/null 2>&1
-            if [ "$?" = "0" ];then
-            cat "$1"
-               return
-            fi
-
-            sed -e '/if SCSI_LOWLEVEL && SCSI/{
-                    a\
-config SCSI_MV_94xx\
-	tristate "Marvell Storage Controller 9180/9480"\
-	depends on SCSI && BLK_DEV_SD\
-	help\
-		Provides support for Marvell 94xx Storage Controller series.\n
-}' "$1"
-
-        elif [ "$SUPPORT_ODIN" = "y" ]; then
-            grep SCSI_MV_64xx "$1" >/dev/null 2>&1
-            if [ "$?" = "0" ];then
-            cat "$1"
-               return
-            fi
-
-            sed -e '/if SCSI_LOWLEVEL && SCSI/{
-                    a\
-config SCSI_MV_64xx\
-	tristate "Marvell Storage Controller 6430/6320/6440/6445/6480/6485"\
-	depends on SCSI && BLK_DEV_SD\
-	help\
-		Provides support for Marvell 64xx Storage Controller series.\n
-}' "$1"
-        else
-	   echo "Cannot find the specified product, define mv_conf.mk."
-	   exit 1
-        fi
-    else
-        if [ "$SUPPORT_THOR" = "y"  ];then
-            sed -e '/SCSI_MV_61xx/,+5 d' "$1"
-        elif [ "$SUPPORT_VANIR" = "y"  ];then
-            sed -e '/SCSI_MV_94xx/,+5 d' "$1"
-        elif [ "$SUPPORT_ODIN" = "y"  ];then
-            sed -e '/SCSI_MV_64xx/,+5 d' "$1"
-        else
-	   echo "Cannot find the specified product, define mv_conf.mk."
-	   exit 1
-        fi
-    fi
-}
-
-# $1 is supposed to be the $KERNEL_SRC/drivers/scsi
-if [ ! -d "$1" ];then
-    echo "Cannot find the specified directory."
-    exit 1
-fi
-
-cd "$1"
-subtxt Kconfig $2 > Kconfig.new
-mv Kconfig Kconfig.orig
-mv Kconfig.new Kconfig
--- a/drivers/scsi/vanir/product/vanir/core_cpu.h
+++ /dev/null
@@ -1,91 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_CPU_H
-#define __CORE_CPU_H
-
-#include "mv_config.h"
-
-#define MV_PCI_BAR                              2
-#define FLASH_BAR_NUMBER                        2
-#define MV_PCI_BAR_IO                           2
-
-enum cpu_regs {
-	CPU_MAIN_INT_CAUSE_REG        = 0x10200,
-	_CPU_MAIN_IRQ_MASK_REG        = 0x10204,
-	_CPU_MAIN_FIQ_MASK_REG        = 0x10208,
-	_CPU_ENPOINT_MASK_REG         = 0x1020C,
-	CPU_MAIN_IRQ_MASK_REG         = _CPU_ENPOINT_MASK_REG,
-};
-
-enum cpu_regs_bits {
-	/* CPU_MAIN_INT_CAUSE_REG (R10200H) bits */
-	INT_MAP_PCIE_ERR            = (1U << 31),
-	INT_MAP_I2O_ERR             = (1U << 30),
-	INT_MAP_COM_ERR             = (1U << 29),
-	INT_MAP_PCIE_LNKUP          = (1U << 28),
-	INT_MAP_SGPIO               = (1U << 25),
-	INT_MAP_TWSI                = (1U << 24),
-	INT_MAP_PFLASH              = (1U << 23),
-	INT_MAP_UART                = (1U << 22),
-	INT_MAP_GPIO_TEST           = (1U << 21),
-	INT_MAP_CPU_CRTL            = (1U << 20),
-	INT_MAP_BRIDGE            = (INT_MAP_CPU_CRTL),
-	INT_MAP_SASINTB             = (1U << 19),
-	INT_MAP_SASINTA             = (1U << 18),
-	INT_MAP_SAS                 = (INT_MAP_SASINTA | INT_MAP_SASINTB),
-	INT_MAP_XOR_2_3             = (1U << 17),
-	INT_MAP_XOR_0_1             = (1U << 16),
-	INT_MAP_XOR                 = (INT_MAP_XOR_0_1 | INT_MAP_XOR_2_3),
-	INT_MAP_DL_CPU2PCIE3        = (1U << 15),
-	INT_MAP_DL_CPU2PCIE2        = (1U << 14),
-	INT_MAP_DL_CPU2PCIE1        = (1U << 13),
-	INT_MAP_DL_CPU2PCIE0        = (1U << 12),
-	INT_MAP_DL_PCIE32CPU        = (1U << 11),
-	INT_MAP_DL_PCIE22CPU        = (1U << 10),
-	INT_MAP_DL_PCIE12CPU        = (1U << 9),
-	INT_MAP_DL_PCIE02CPU        = (1U << 8),
-	INT_MAP_COM3OUT             = (1U << 7),
-	INT_MAP_COM2OUT             = (1U << 6),
-	INT_MAP_COM1OUT             = (1U << 5),
-	INT_MAP_COM0OUT             = (1U << 4),
-	INT_MAP_COM3IN              = (1U << 3),
-	INT_MAP_COM2IN              = (1U << 2),
-	INT_MAP_COM1IN              = (1U << 1),
-	INT_MAP_COM0IN              = (1U << 0),
-	INT_MAP_COM3INT             = (INT_MAP_COM3IN | INT_MAP_COM_ERR),
-	INT_MAP_COM2INT             = (INT_MAP_COM2IN | INT_MAP_COM_ERR),
-	INT_MAP_COM1INT             = (INT_MAP_COM1IN | INT_MAP_COM_ERR),
-	INT_MAP_COM0INT             = (INT_MAP_COM0IN | INT_MAP_COM_ERR),
-	INT_MAP_COMINT              = (INT_MAP_COM0INT | INT_MAP_COM1INT
-	                             | INT_MAP_COM2INT | INT_MAP_COM3INT),
-	INT_MAP_MU                  = (INT_MAP_DL_PCIE02CPU | INT_MAP_COM0INT),
-};
-
-enum xbar_address_map {
-	INTRFC_PCIEA            = 0x00,
-	INTRFC_SRAM             = 0x01,
-	INTRFC_DDR_CS0          = 0x02,
-	INTRFC_PBSRAM           = 0x03,
-	INTRFC_PCIE1            = 0x04,
-	INTRFC_DDR_CS1          = 0x06,
-	INTRFC_PCIE2            = 0x08,
-	INTRFC_DDR_CS2          = 0x0A,
-	INTRFC_PCIE3            = 0x0C,
-	INTRFC_DDR_CS3          = 0x0E,
-	INTRFC_CORE_DMA          = (INTRFC_DDR_CS3),
-};
-
-#define CS_INTRFC_CORE_DMA 0
-
-#endif /* __CORE_CPU_H */
--- a/drivers/scsi/vanir/product/vanir/core_hal.c
+++ /dev/null
@@ -1,681 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_internal.h"
-#include "core_hal.h"
-#include "core_manager.h"
-#include "core_protocol.h"
-#include "core_util.h"
-#include "hba_inter.h"
-#include "core_error.h"
-
-extern MV_VOID prot_process_cmpl_req(pl_root *root, MV_Request *req);
-MV_VOID mv_set_sas_addr(MV_PVOID root_p, MV_PVOID phy_p, MV_PU8 sas_addr)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_phy *phy = (domain_phy *)phy_p;
-	MV_U64 val64;
-
-	MV_CopyMemory(&val64.value, sas_addr, 8);
-
-	WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ID_FRAME4);
-	WRITE_PORT_CONFIG_DATA(root, phy, val64.parts.high);
-
-	WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ID_FRAME3);
-	WRITE_PORT_CONFIG_DATA(root, phy, val64.parts.low);
-}
-
-MV_VOID mv_set_dev_info(MV_PVOID root_p, MV_PVOID phy_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_phy *phy = (domain_phy *)phy_p;
-	MV_U32 reg;
-
-	WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ID_FRAME5);
-	reg = READ_PORT_CONFIG_DATA(root, phy);
-	reg &= 0xffffff00;
-	reg |= phy->asic_id;
-	WRITE_PORT_CONFIG_DATA(root, phy, reg);
-
-	reg = (SAS_END_DEV<<4) + ((PORT_DEV_STP_INIT|PORT_DEV_SMP_INIT|PORT_DEV_SSP_INIT)<<8);
-	WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ID_FRAME0);
-	WRITE_PORT_CONFIG_DATA(root, phy, reg);
-}
-
-MV_VOID mv_reset_phy(MV_PVOID root_p, MV_U8 logic_phy_map, MV_BOOLEAN hard_reset)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_phy *phy;
-	MV_U32 reg;
-	MV_U32 i;
-       MV_U32 phy_irq_mask = 0;
-	MV_U8 init = MV_FALSE;
-	MV_U32 phyrdy_wait_time = 0;
-
-       core_disable_ints(root->core);
-	for (i = 0; i < root->phy_num; i++) {
-		if (!(logic_phy_map & MV_BIT(i)))
-			continue;
-
-		phy = &root->phy[i];
-
-		if (init == MV_FALSE) {
-			phy_irq_mask = phy->phy_irq_mask;
-			init = MV_TRUE;
-		}
-		MV_ASSERT(phy_irq_mask == phy->phy_irq_mask);
-
-                 phy->phy_irq_mask &= ~(IRQ_PHY_RDY_CHNG_MASK | IRQ_PHY_RDY_CHNG_1_TO_0);
-                /* disable interrupt */
-                WRITE_PORT_IRQ_MASK(root, phy, phy->phy_irq_mask);
-
-		WRITE_PORT_VSR_ADDR(root, phy, VSR_IRQ_MASK);
-		reg = READ_PORT_VSR_DATA(root, phy);
-		reg &= ~VSR_IRQ_PHY_TIMEOUT;
-		WRITE_PORT_VSR_DATA(root, phy, reg);
-
-		core_sleep_millisecond(root->core, 10);
-
-		/* reset */
-		reg = READ_PORT_PHY_CONTROL(root, phy);
-		if (hard_reset)
-			reg |= SCTRL_PHY_HARD_RESET_SEQ;
-		else
-			reg |= SCTRL_STP_LINK_LAYER_RESET;
-
-		if (((core_extension *)(root->core))->revision_id != VANIR_C2_REV)
-			reg |= (SCTRL_STP_LINK_LAYER_RESET | SCTRL_SSP_LINK_LAYER_RESET);
-
-		WRITE_PORT_PHY_CONTROL(root, phy, reg);
-	}
-
-	/* Polling for phy ready after OOB */
-	phyrdy_wait_time = 100;
-	while ((phyrdy_wait_time>0) && logic_phy_map) {
-		for (i = 0; i < root->phy_num; i++) {
-			if (!(logic_phy_map & MV_BIT(i)))
-				continue;
-			phy = &root->phy[i];
-
-			if (mv_is_phy_ready(root, phy) ||
-				(phyrdy_wait_time == 1))
-			{
-				WRITE_PORT_IRQ_STAT(root, phy, \
-					(IRQ_PHY_RDY_CHNG_MASK | IRQ_PHY_RDY_CHNG_1_TO_0));
-
-				WRITE_PORT_VSR_ADDR(root, phy, VSR_IRQ_STATUS);
-				WRITE_PORT_VSR_DATA(root, phy, VSR_IRQ_PHY_TIMEOUT);
-
-				/* enable phy interrupt */
-				phy->phy_irq_mask = phy_irq_mask;
-				WRITE_PORT_IRQ_MASK(root, phy, phy->phy_irq_mask);
-				logic_phy_map &= ~(MV_BIT(i));
-			}
-		}
-		core_sleep_millisecond(root->core, 10);
-		phyrdy_wait_time--;
-	}
-        core_enable_ints(root->core);
-}
-
-MV_VOID hal_clear_srs_irq(MV_PVOID root_p, MV_U32 set, MV_BOOLEAN clear_all)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_U32 reg;
-
-	if (clear_all == MV_TRUE) {
-		reg = READ_SRS_IRQ_STAT(root, 0);
-		if (reg) {
-			WRITE_SRS_IRQ_STAT(root, 0, reg);
-		}
-		reg = READ_SRS_IRQ_STAT(root, 32);
-		if (reg) {
-			WRITE_SRS_IRQ_STAT(root, 32, reg);
-		}
-	} else {
-		reg = READ_SRS_IRQ_STAT(root, set);
-		if (reg & MV_BIT(set % 32)) {
-			CORE_DPRINT(("register set 0x%x was stopped.\n", set));
-			WRITE_SRS_IRQ_STAT(root, set, MV_BIT(set % 32));
-		}
-	}
-}
-
-MV_VOID hal_enable_register_set(MV_PVOID root_p, MV_PVOID base_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	domain_base *base = (domain_base *)base_p;
-	domain_device *dev;
-	MV_U32 reg;
-
-	if (base->type == BASE_TYPE_DOMAIN_DEVICE) {
-		dev = (domain_device *)base;
-		if (IS_STP_OR_SATA(dev) && (dev->register_set != NO_REGISTER_SET)) {
-			hal_clear_srs_irq(root, dev->register_set, MV_FALSE);
-		}
-	}
-
-	reg = MV_REG_READ_DWORD(root->mmio_base, COMMON_IRQ_STAT);
-	reg |= INT_CMD_ISSUE_STOPPED;
-	MV_REG_WRITE_DWORD(root->mmio_base, COMMON_IRQ_STAT, reg);
-
-	reg = MV_REG_READ_DWORD(root->mmio_base, COMMON_CONTROL);
-	reg |= 0xff00;
-	MV_REG_WRITE_DWORD(root->mmio_base, COMMON_CONTROL, reg);
-}
-
-MV_VOID hal_disable_io_chip(MV_PVOID root_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_LPVOID mmio = root->mmio_base;
-	MV_U32 tmp;
-
-        /* disable CMD/CMPL_Q/RESP mode */
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CONTROL);
-	tmp &= ~CONTROL_EN_CMD_ISSUE;
-	tmp &= ~CONTROL_RSPNS_RCV_EN;
-        /* tmp &= ~CONTROL_CMD_CMPLT_IRQ_MD; */
-	MV_REG_WRITE_DWORD(mmio, COMMON_CONTROL, tmp);
-
-        /* disable interrupt */
-	tmp = 0;
-	MV_REG_WRITE_DWORD(mmio, COMMON_IRQ_MASK, tmp);
-}
-
-void core_disable_ints(void *ext)
-{
-    core_extension *core = (core_extension *)ext;
-
-    MV_REG_WRITE_DWORD(core->mmio_base, CPU_MAIN_IRQ_MASK_REG, 0);
-}
-
-void core_enable_ints(void *ext)
-{
-    core_extension *core = (core_extension *)ext;
-
-    MV_REG_WRITE_DWORD(core->mmio_base, CPU_MAIN_IRQ_MASK_REG, core->irq_mask);
-}
-MV_BOOLEAN core_check_int(void *ext)
-{
-	core_extension *core = (core_extension *)ext;
-	MV_U32 main_irq;
-	pl_root *root;
-
-	main_irq = MV_REG_READ_DWORD(core->mmio_base, CPU_MAIN_INT_CAUSE_REG);
-	main_irq = main_irq & core->irq_mask;
-	if (main_irq == 0) return(MV_FALSE);
-	return MV_TRUE;
-}
-MV_BOOLEAN core_clear_int(core_extension *core)
-{
-	MV_U32 main_irq;
-	pl_root *root;
-
-	main_irq = MV_REG_READ_DWORD(core->mmio_base, CPU_MAIN_INT_CAUSE_REG);
-	main_irq = main_irq & core->irq_mask;
-	if (main_irq == 0) return(MV_FALSE);
-
-	core->main_irq |= main_irq;
-
-	if (main_irq & INT_MAP_SAS) {
-		if (main_irq & INT_MAP_SASINTA) {
-			root = &core->roots[0];
-			io_chip_clear_int(root);
-		}
-		if (main_irq & INT_MAP_SASINTB) {
-			root = &core->roots[1];
-			io_chip_clear_int(root);
-		}
-	}
-
-	if (main_irq)
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-}
-
-MV_VOID core_handle_int(core_extension *core)
-{
-	pl_root *root;
-
-	/* handle io chip interrupt */
-	if (core->main_irq & INT_MAP_SAS) {
-		if (core->main_irq & INT_MAP_SASINTA) {
-			root = &core->roots[0];
-			io_chip_handle_int(root);
-		}
-		if (core->main_irq & INT_MAP_SASINTB) {
-			root = &core->roots[1];
-			io_chip_handle_int(root);
-		}
-
-	}
-	core->main_irq = 0;
-}
-
-MV_BOOLEAN sata_is_register_set_stopped(MV_PVOID root_p, MV_U8 set)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_U32 reg_set_irq_stat;
-	reg_set_irq_stat = READ_SRS_IRQ_STAT(root, set);
-
-	if (reg_set_irq_stat & MV_BIT(set))
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-}
-
-MV_U8 sata_get_register_set(MV_PVOID root_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_LPVOID mmio = root->mmio_base;
-	MV_U32 tmp, reg;
-
-	int i;
-	i = ffc64(root->sata_reg_set);
-	if (i >= 32) {
-		root->sata_reg_set.parts.high |= MV_BIT(i - 32);
-		WRITE_REGISTER_SET_ENABLE(root, i, root->sata_reg_set.parts.high);
-
-		return (MV_U8) i;
-	}
-	else if (i >= 0) {
-		root->sata_reg_set.parts.low |= MV_BIT(i);
-		WRITE_REGISTER_SET_ENABLE(root, i, root->sata_reg_set.parts.low);
-
-		return (MV_U8) i;
-	}
-
-	return NO_REGISTER_SET;
-}
-
-void sata_free_register_set(MV_PVOID root_p, MV_U8 set)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_LPVOID mmio = root->mmio_base;
-	MV_U32 reg, tmp;
-
-	if (set < 32) {
-		root->sata_reg_set.parts.low &= ~MV_BIT(set);
-		WRITE_REGISTER_SET_ENABLE(root, set, root->sata_reg_set.parts.low);
-	}
-	else {
-		root->sata_reg_set.parts.high &= ~MV_BIT(set - 32);
-		WRITE_REGISTER_SET_ENABLE(root, set, root->sata_reg_set.parts.high);
-	}
-	hal_clear_srs_irq(root, set, MV_FALSE);
-}
-MV_U8	exp_check_plugging_finished(pl_root *root, domain_port *port);
-
-MV_VOID io_chip_clear_int(pl_root *root)
-{
-	MV_U32 irq = MV_REG_READ_DWORD(root->mmio_base, COMMON_IRQ_STAT);
-	domain_phy *phy;
-	MV_U8 i;
-	MV_U32 reg, cmpl_wp;
-
-	root->comm_irq |= irq;
-
-	/* for completion queue interrupt INT_CMD_CMPL_MASK */
-	if (root->comm_irq & INT_CMD_CMPL_MASK )
-		MV_REG_WRITE_DWORD(root->mmio_base, COMMON_IRQ_STAT, INT_CMD_CMPL_MASK);
-
-	if (root->comm_irq & INT_PRD_BC_ERR ) {
-		CORE_EVENT_PRINT(("Find PRD BC error, COMMON_IRQ_STAT: 0x%08x\n", irq));
-		MV_REG_WRITE_DWORD(root->mmio_base, COMMON_IRQ_STAT, INT_PRD_BC_ERR);
-		MV_REG_READ_DWORD(root->mmio_base, COMMON_IRQ_STAT);
-	}
-
-	if (root->comm_irq & (INT_PORT_MASK|INT_PHY_MASK)) {
-		/* for port interrupt and PHY interrupt */
-		for (i = 0; i < root->phy_num; i++) {
-			phy = &root->phy[i];
-			if (hal_has_phy_int(root->comm_irq, phy)) {
-				/* clear PORT interrupt status */
-				reg = READ_PORT_IRQ_STAT(root, phy);
-				CORE_EVENT_PRINT(("phy %d READ_PORT_IRQ_STAT: 0x%08x\n", phy->id,reg));
-				phy->irq_status |= reg & phy->phy_irq_mask;
-				WRITE_PORT_IRQ_STAT(root, phy, reg);
-				/* Read back IRQ status register */
-				READ_PORT_IRQ_STAT(root, phy);
-				/* clear PHY interrupt status */
-				WRITE_PORT_VSR_ADDR(root, phy, VSR_IRQ_STATUS);
-				reg = READ_PORT_VSR_DATA(root, phy);
-				if (reg & VSR_IRQ_PHY_TIMEOUT) {
-					CORE_EVENT_PRINT(("READ_PORT_VSR_DATA: 0x%08x\n", reg));
-					WRITE_PORT_VSR_DATA(root, phy, VSR_IRQ_PHY_TIMEOUT);
-				}
-
-				CORE_EVENT_PRINT(("phy %d irq_status = 0x%x.\n", phy->id, phy->irq_status));
-			}
-		}
-	}
-}
-
-MV_VOID io_chip_handle_port_int(pl_root *root)
-{
-	domain_phy *phy;
-	MV_U8 i;
-	MV_U32 port_irq;
-
-	for (i=0; i<root->phy_num; i++) {
-		phy = &root->phy[i];
-		if (!hal_has_phy_int(root->comm_irq, phy))
-			continue;
-
-		port_irq = phy->irq_status;
-		root->comm_irq = hal_remove_phy_int(root->comm_irq, phy);
-		CORE_EVENT_PRINT(("phy %d irq_status %08X.\n", phy->id, port_irq));
-
-		if (port_irq & IRQ_UNASSOC_FIS_RCVD_MASK ||
-			port_irq & IRQ_SIG_FIS_RCVD_MASK) {
-			if ((phy->type == PORT_TYPE_SATA) && (phy->port))
-				sata_port_notify_event(phy->port, port_irq);
-			phy->irq_status &=
-				~(IRQ_UNASSOC_FIS_RCVD_MASK | IRQ_SIG_FIS_RCVD_MASK);
-		}
-
-		if (port_irq & (IRQ_PHY_RDY_CHNG_MASK|IRQ_PHY_RDY_CHNG_1_TO_0)) {
-			pal_notify_event(root, i, PL_EVENT_PHY_CHANGE);
-		}
-
-		if (port_irq & IRQ_STP_SATA_PHY_DEC_ERR_MASK) {
-			CORE_EVENT_PRINT(("PHY decoding error for root %p phy %d\n",\
-				root, phy->id));
-			phy->irq_status &= ~IRQ_STP_SATA_PHY_DEC_ERR_MASK;
-		}
-
-		if (port_irq & IRQ_ASYNC_NTFCN_RCVD_MASK) {
-			CORE_EVENT_PRINT(("PHY asynchronous notification for root %p phy %d\n",\
-				root, phy->id));
-			pal_notify_event(root, i, PL_EVENT_ASYNC_NOTIFY);
-			phy->irq_status &= ~IRQ_ASYNC_NTFCN_RCVD_MASK;
-		}
-
-		if (port_irq & IRQ_BRDCST_CHNG_RCVD_MASK) {
-			pal_notify_event(root, i, PL_EVENT_BROADCAST_CHANGE);
-			phy->irq_status &= ~IRQ_BRDCST_CHNG_RCVD_MASK;
-		}
-	}
-}
-
-MV_VOID sata_handle_non_spcfc_ncq_err(pl_root *root, MV_U8 register_set)
-{
-	domain_device *device;
-	MV_Request *req;
-	core_context *ctx;
-	struct _error_context *err_ctx;
-	MV_U16 i;
-	MV_U32 params[MAX_EVENT_PARAMS];
-
-	device = get_device_by_register_set(root, register_set);
-	if (device) {
-		io_chip_handle_cmpl_queue_int(root);
-
-		err_ctx = &device->base.err_ctx;
-		mv_cancel_timer(root->core, &device->base);
-
-		if (!List_Empty(&err_ctx->sent_req_list)) {
-			req = LIST_ENTRY(
-				(&err_ctx->sent_req_list)->next, MV_Request, Queue_Pointer);
-			ctx = (core_context *)req->Context[MODULE_CORE];
-
-			if (sata_is_register_set_stopped(root, device->register_set)) {
-				CORE_EH_PRINT(("Register set %d is disabled\n", device->register_set));
-				device->base.cmd_issue_stopped = MV_TRUE;
-			}
-
-			/* reset that command slot */
-			prot_reset_slot(root, &device->base, ctx->slot, req);
-
-			if (CORE_IS_EH_REQ(ctx) || CORE_IS_INIT_REQ(ctx)) {
-				/* Set timeout for EH and INIT req let EH Handler handle request */
-				req->Scsi_Status = REQ_STATUS_TIMEOUT;
-				core_queue_completed_req(root->core, req);
-			} else {
-				/* treat it as media error */
-				req->Scsi_Status = REQ_STATUS_ERROR;
-				core_queue_error_req(root, req, MV_TRUE);
-			}
-		}
-	}
-}
-
-MV_VOID io_chip_handle_non_spcfc_ncq_err(pl_root *root)
-{
-	MV_U32 err_0, err_1;
-	MV_U8 i;
-
-	err_0 = MV_REG_READ_DWORD(root->mmio_base, COMMON_NON_SPEC_NCQ_ERR0);
-	err_1 = MV_REG_READ_DWORD(root->mmio_base, COMMON_NON_SPEC_NCQ_ERR1);
-
-	for (i=0; i<32; i++) {
-		if (err_0 & MV_BIT(i)) {
-			sata_handle_non_spcfc_ncq_err(root, i);
-		}
-
-		if (err_1 & MV_BIT(i)) {
-			sata_handle_non_spcfc_ncq_err(root, (i+32));
-		}
-	}
-
-	MV_REG_WRITE_DWORD(root->mmio_base, COMMON_NON_SPEC_NCQ_ERR0, err_0);
-	MV_REG_WRITE_DWORD(root->mmio_base, COMMON_NON_SPEC_NCQ_ERR1, err_1);
-}
-
-MV_VOID io_chip_handle_cmpl_queue_int(MV_PVOID root_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_Request *req=NULL;
-	core_context *ctx=NULL;
-	MV_PU32 cmpl_q; /* points to the completion entry zero */
-	MV_U32 cmpl_entry;
-	MV_U16 cmpl_wp; /* the completion write pointer */
-	MV_U16 i, slot;
-	struct _domain_base *base;
-
-	cmpl_q = root->cmpl_q;
-	cmpl_wp = (MV_U16) MV_LE32_TO_CPU(*(MV_U32 *)root->cmpl_wp)&0xfff;
-
-	i = root->last_cmpl_q; /* last_cmpl_q is handled. will start from the next. */
-	root->last_cmpl_q = cmpl_wp;
-	if (i == root->last_cmpl_q)	/* no new entry */
-		return;
-
-	if (root->last_cmpl_q == 0xfff) /* write pointer is not updated yet */
-		return;
-
-	while (i != root->last_cmpl_q) {
-		i++;
-		if (i >= root->cmpl_q_size)
-			i = 0;
-
-		cmpl_entry = MV_LE32_TO_CPU(cmpl_q[i]);
-		if (cmpl_entry & RXQ_ATTN) {
-			continue;
-		}
-
-		slot = (MV_U16)(cmpl_entry & 0xfff);
-		if(slot >= root->slot_count_support){
-			CORE_DPRINT(("finished  slot %x exceed max slot %x.\n",slot, root->slot_count_support));
-			continue;
-		}
-		req = root->running_req[slot];
-		if (req == NULL) {
-			CORE_EH_PRINT(("attention: "\
-				"cannot find corresponding req on slot 0x%x\n", \
-				slot));
-			continue;
-		}
-		ctx = req->Context[MODULE_CORE];
-
-		base = (struct _domain_base *)get_device_by_id(
-				root->lib_dev, req->Device_Id);
-		if (base == NULL) {
-			MV_ASSERT(MV_FALSE);
-		}
-
-		/*
-		 * process_command:
-		 * 1. if success, return REQ_STATUS_SUCCESS
-		 * 2. if final error like disk is gone, return REQ_STATUS_NO_DEVICE
-		 * 3. if want to do error handling,
-		 *    set ctx->error_info with EH_INFO_NEED_RETRY
-		 *    and also set the Scsi_Status properly to
-		 *    a. REQ_STATUS_HAS_SENSE if has sense
-		 *    b. for timeout, the status should be REQ_STATUS_TIMEOUT
-		 *    c. REQ_STATUS_ERROR for all other error
-		 */
-		((command_handler *)ctx->handler)->process_command(
-			root, base, &cmpl_entry, root->cmd_table_wrapper[slot].vir, req);
-
-		MV_DASSERT((req->Scsi_Status == REQ_STATUS_SUCCESS)
-			|| (req->Scsi_Status == REQ_STATUS_TIMEOUT)
-			|| (req->Scsi_Status == REQ_STATUS_NO_DEVICE)
-			|| (req->Scsi_Status == REQ_STATUS_HAS_SENSE)
-			|| (req->Scsi_Status == REQ_STATUS_ERROR)
-			|| (req->Scsi_Status == REQ_STATUS_BUSY));
-
-		prot_process_cmpl_req(root, req);
-	}
-}
-
-MV_VOID io_chip_handle_int(pl_root *root)
-{
-	if (root->comm_irq & INT_CMD_CMPL) {
-		io_chip_handle_cmpl_queue_int(root);
-	}
-
-	if (root->comm_irq & (INT_PORT_MASK|INT_PHY_MASK)) {
-		io_chip_handle_port_int(root);
-	}
-
-	if (root->comm_irq & INT_NON_SPCFC_NCQ_ERR) {
-		io_chip_handle_non_spcfc_ncq_err(root);
-	}
-
-	root->comm_irq = 0;
-	return ;
-}
-
-MV_U16 prot_set_up_sg_table(MV_PVOID root_p, MV_Request *req, MV_PVOID sg_wrapper_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	core_extension *core = (core_extension *)root->core;
-	hw_buf_wrapper *sg_wrapper = (hw_buf_wrapper *)sg_wrapper_p;
-	MV_U16 consumed = 0;
-
-	if (req->SG_Table.Valid_Entry_Count > 0) {
-		MV_DASSERT(req->Data_Transfer_Length > 0);
-		MV_DASSERT(req->SG_Table.Byte_Count == req->Data_Transfer_Length);
-		consumed = (MV_U16) core_prepare_hwprd(root->core,
-			&req->SG_Table, sg_wrapper->vir);
-
-		if (consumed == 0) {
-			CORE_DPRINT( ("Run out of PRD entry.\n") );
-			MV_ASSERT( MV_FALSE );
-		}
-
-		if (req->Cmd_Flag & CMD_FLAG_DATA_IN) {
-			prd_t* prd;
-			MV_PHYSICAL_ADDR dma;
-			core_extension *core = (core_extension *)root->core;
-			MV_U32 dw2 = 0;
-
-			MV_ASSERT(consumed <= (core->hw_sg_entry_count - 2));
-
-			prd = ((prd_t *)sg_wrapper->vir)+consumed;
-			prd->baseAddr_low =
-				MV_CPU_TO_LE32(core->trash_bucket_dma.parts.low);
-			prd->baseAddr_high =
-				MV_CPU_TO_LE32(core->trash_bucket_dma.parts.high);
-			dw2 = TRASH_BUCKET_SIZE;
-			dw2 &= ~PRD_CHAIN_BIT;
-			dw2 |= INTRFC_PCIEA<<PRD_IF_SELECT_SHIFT;
-
-			prd->size = MV_CPU_TO_LE32(dw2);
-
-			dma = U64_ADD_U32(sg_wrapper->phy, (consumed * sizeof(prd_t)));
-
-			prd++;
-			prd->baseAddr_low = MV_CPU_TO_LE32(dma.parts.low);
-			prd->baseAddr_high = MV_CPU_TO_LE32(dma.parts.high);
-			dw2 = 2;
-			dw2 |= PRD_CHAIN_BIT;
-			dw2 |= INTRFC_PCIEA<<PRD_IF_SELECT_SHIFT;
-			prd->size = MV_CPU_TO_LE32(dw2);
-			consumed += 2;
-		}
-	} else {
-		MV_DASSERT(req->Data_Transfer_Length == 0);
-	}
-
-	return consumed;
-}
-MV_VOID core_fill_prd(MV_PVOID prd_ctx, MV_U64 bass_addr, MV_U32 size)
-{
-	prd_context *ctx = (prd_context *)prd_ctx;
-	MV_U32 dw2 = 0;
-
-	MV_ASSERT(ctx->avail);
-
-	dw2 = size;
-	dw2 &= ~PRD_CHAIN_BIT;
-
-	ctx->prd->baseAddr_low = MV_CPU_TO_LE32(bass_addr.parts.low);
-	ctx->prd->baseAddr_high = MV_CPU_TO_LE32(bass_addr.parts.high);
-	dw2 |= INTRFC_PCIEA<<PRD_IF_SELECT_SHIFT;
-	ctx->prd->size = MV_CPU_TO_LE32(dw2);
-	ctx->prd++;
-       MV_ASSERT(ctx->avail > 0);
-	ctx->avail--;
-
-}
-
-int core_prepare_hwprd(MV_PVOID core, sgd_tbl_t * source, MV_PVOID prd)
-{
-	prd_context ctx;
-
-	ctx.prd = (prd_t *)prd;
-	ctx.avail = ((core_extension *)core)->hw_sg_entry_count;
-	return sgdt_prepare_hwprd((core), (source), (&ctx),
-	core_fill_prd);
-
-}
-
-MV_VOID
-core_alarm_enable_register(MV_PVOID core_p)
-{
-	MV_U32 reg;
-	core_extension *core = (core_extension *) core_p;
-
-	reg = MV_REG_READ_DWORD(core->mmio_base, TEST_PIN_OUTPUT_ENABLE);
-	MV_REG_WRITE_DWORD(core->mmio_base, TEST_PIN_OUTPUT_ENABLE, reg | TEST_PIN_BUZZER);
-}
-
-MV_VOID
-core_alarm_set_register(MV_PVOID core_p, MV_U8 value)
-{
-	MV_U32 reg;
-	core_extension *core = (core_extension *) core_p;
-
-	reg = MV_REG_READ_DWORD(core->mmio_base, TEST_PIN_OUTPUT_VALUE);
-
-	if (value == MV_TRUE)
-		reg |= TEST_PIN_BUZZER;
-	else
-		reg &= ~TEST_PIN_BUZZER;
-
-	MV_REG_WRITE_DWORD(core->mmio_base, TEST_PIN_OUTPUT_VALUE, reg);
-}
--- a/drivers/scsi/vanir/product/vanir/core_hal.h
+++ /dev/null
@@ -1,939 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __CORE_HAL_H
-#define __CORE_HAL_H
-
-#include "mv_config.h"
-#include "core_type.h"
-#include "core_discover.h"
-#include "core_cpu.h"
-
-#define MAX_NUMBER_IO_CHIP                      2 /* how many io chips per hardware */
-#define MAX_REGISTER_SET_PER_IO_CHIP            64
-#define MAX_PORT_PER_PL                         4
-#define MAX_PHY_PER_PL                          4
-#define CORE_MAX_REQUEST_NUMBER                 2000 /* per io chip */
-
-
-typedef enum _VANIR_REVISION_ID {
-	VANIR_A0_REV		= 0xA0,
-	VANIR_B0_REV		= 0x01,
-	VANIR_C0_REV		= 0x02,
-	VANIR_C1_REV		= 0x03,
-	VANIR_C2_REV		= 0xC2,
-} VANIR_REVISION_ID;
-/*
-  ========================================================================
-chip registers
-  ========================================================================
-*/
-#define MV_IO_CHIP_REGISTER_BASE                                     0x20000
-#define MV_IO_CHIP_REGISTER_RANGE                                    0x04000
-
-enum vanir_common_regs {
-	/* SATA/SAS port common registers */
-	COMMON_PORT_IMPLEMENT        = 0x9C,  /* port implement register */
-	COMMON_PORT_TYPE        = 0xa0,  /* port type register */
-	COMMON_CONFIG           = 0x100, /* configuration register */
-	COMMON_CONTROL          = 0x104, /* control register */
-	COMMON_LST_ADDR         = 0x108, /* command list DMA addr */
-	COMMON_LST_ADDR_HI      = 0x10c, /* command list DMA addr hi */
-	COMMON_FIS_ADDR         = 0x110, /* FIS rx buf addr */
-	COMMON_FIS_ADDR_HI      = 0x114, /* FIS rx buf addr hi */
-
-	COMMON_SATA_REG_SET0    = 0x0118, /* SATA/STP Register Set 0 */
-	COMMON_SATA_REG_SET1    = 0x011c, /* SATA/STP Register Set 1 */
-
-	COMMON_DELV_Q_CONFIG    = 0x120, /* delivery queue configuration */
-	COMMON_DELV_Q_ADDR      = 0x124, /* delivery queue base address */
-	COMMON_DELV_Q_ADDR_HI   = 0x128, /* delivery queue base address hi */
-	COMMON_DELV_Q_WR_PTR    = 0x12c, /* delivery queue write pointer */
-	COMMON_DELV_Q_RD_PTR    = 0x130, /* delivery queue read pointer */
-	COMMON_CMPL_Q_CONFIG    = 0x134, /* completion queue configuration */
-	COMMON_CMPL_Q_ADDR      = 0x138, /* completion queue base address */
-	COMMON_CMPL_Q_ADDR_HI   = 0x13c, /* completion queue base address hi */
-	COMMON_CMPL_Q_WR_PTR    = 0x140, /* completion queue write pointer */
-	COMMON_CMPL_Q_RD_PTR    = 0x144, /* completion queue read pointer */
-
-	COMMON_COAL_CONFIG      = 0x148, /* interrupt coalescing config */
-	COMMON_COAL_TIMEOUT     = 0x14c, /* interrupt coalescing time wait */
-	COMMON_IRQ_STAT         = 0x150, /* interrupt status */
-	COMMON_IRQ_MASK         = 0x154, /* interrupt enable/disable mask */
-
-	COMMON_SRS_IRQ_STAT0    = 0x0158, /* SRS interrupt status 0 */
-	COMMON_SRS_IRQ_MASK0    = 0x015c, /* SRS intr enable/disable mask 0 */
-	COMMON_SRS_IRQ_STAT1    = 0x0160, /* SRS interrupt status 1*/
-	COMMON_SRS_IRQ_MASK1    = 0x0164, /* SRS intr enable/disable mask 1*/
-
-	COMMON_NON_SPEC_NCQ_ERR0= 0x0168, /* Non Specific NCQ Error 0 */
-	COMMON_NON_SPEC_NCQ_ERR1= 0x016c, /* Non Specific NCQ Error 1 */
-
-	COMMON_CMD_ADDR         = 0x0170, /* Command Address Port */
-	COMMON_CMD_DATA         = 0x0174, /* Command Data Port */
-
-	/* Port interrupt status/mask register set $i (0x180/0x184-0x1b8/0x1bc) */
-	COMMON_PORT_IRQ_STAT0   = 0x0180,
-	COMMON_PORT_IRQ_MASK0   = 0x0184,
-
-	COMMON_PORT_ALL_IRQ_STAT   = 0x01c0, /* All Port interrupt status */
-	COMMON_PORT_ALL_IRQ_MASK   = 0x01c4, /* All Port interrupt enable/disable mask */
-
-	COMMON_STP_CLR_AFFILIATION_DIS0= 0x01c8, /* STP Clear Affiliation Disable 0 */
-	COMMON_STP_CLR_AFFILIATION_DIS1= 0x01cc, /* STP Clear Affiliation Disable 1 */
-
-	/* port serial control/status register set $i (0x1d0-0x1ec) */
-	COMMON_PORT_PHY_CONTROL0  = 0x01d0,
-	COMMON_PORT_ALL_PHY_CONTROL=0x01f0, /* All port serial status/control */
-
-	/* port config address/data regsiter set $i (0x200/0x204 - 0x238/0x23c) */
-	COMMON_PORT_CONFIG_ADDR0  = 0x0200,
-	COMMON_PORT_CONFIG_DATA0  = 0x0204,
-	COMMON_PORT_ALL_CONFIG_ADDR  = 0x0240, /* All Port config address */
-	COMMON_PORT_ALL_CONFIG_DATA  = 0x0244, /* All Port config data */
-
-	/* port vendor specific address/data register set $i (0x250/0x254-0x268/0x26c) */
-	COMMON_PORT_VSR_ADDR0      = 0x0250,
-	COMMON_PORT_VSR_DATA0      = 0x0254,
-	COMMON_PORT_ALL_VSR_ADDR   = 0x0290, /* All port Vendor Specific Register addr */
-	COMMON_PORT_ALL_VSR_DATA   = 0x0294, /* All port Vendor Specific Register Data */
-};
-
-/* these registers are accessed through port vendor specific address/data registers */
-enum sas_sata_phy_regs {
-    GENERATION_1_SETTING        = 0x118,
-    GENERATION_1_2_SETTING      = 0x11C,
-    GENERATION_2_3_SETTING      = 0x120,
-    GENERATION_3_4_SETTING      = 0x124,
-};
-
-enum vanir_common_regs_bits {
-	/* COMMON_PORT_TYPE */
-	PORT_AUTO_DET_EN        = (0xFFU << 8),
-	PORT_SAS_SATA_MODE      = (0xFFU << 0),
-
-	/* COMMON_CONFIG register bits */
-	CONFIG_CMD_TBL_BE       = (1U << 0),
-	CONFIG_OPEN_ADDR_BE     = (1U << 1),
-	CONFIG_RSPNS_FRAME_BE   = (1U << 2),
-	CONFIG_DATA_BE          = (1U << 3),
-	CONFIG_SAS_SATA_RST     = (1U << 5),
-	CONFIG_STP_STOP_ON_ERR	= (1U << 25),
-
-	/* COMMON_PHY_CTRL register definition */
-	PHY_PHY_DSBL            = (0xFU << 12),
-	PHY_PWR_OFF             = (0xFU << 24),
-
-	/* COMMON_CONTROL : port control/status bits (R104h) */
-	CONTROL_EN_CMD_ISSUE        = (1U << 0),
-	CONTROL_RESET_CMD_ISSUE     = (1U << 1),
-	CONTROL_ERR_STOP_CMD_ISSUE  = (1U << 3),
-	CONTROL_FIS_RCV_EN          = (1U << 4),
-	CONTROL_CMD_CMPL_SELF_CLEAR = (1U << 5),
-	CONTROL_EN_SATA_RETRY       = (1U << 6),
-	CONTROL_RSPNS_RCV_EN        = (1U << 7),
-
-
-	CONTROL_EN_PORT_XMT_START   = 12,
-
-	/* COMMON_DELV_Q_CONFIG (R120h) bits */
-	DELV_QUEUE_SIZE_MASK        = (0xFFFU << 0),
-	DELV_QUEUE_ENABLE           = (1U << 16),
-
-	/* COMMON_CMPL_Q_CONFIG (R134h) bits */
-	CMPL_QUEUE_SIZE_MASK        = (0xFFFU << 0),
-	CMPL_QUEUE_ENABLE           = (1U << 16),
-	CMPL_QUEUE_DSBL_ATTN_POST	= (1U << 17),
-
-	/* COMMON_COAL_CONFIG (R148h) bits */
-	INT_COAL_COUNT_MASK      = (0x1FFU << 0),
-	INT_COAL_ENABLE          = (1U << 16),
-
-	/* COMMON_COAL_TIMEOUT (R14Ch) bits */
-	COAL_TIMER_MASK          = (0xFFFFU << 0),
-	COAL_TIMER_UNIT_1MS      = (1U << 16),   /* 6.67 ns if set to 0 */
-
-	/* COMMON_IRQ_STAT/MASK (R150h) bits */
-	INT_CMD_CMPL               = (1U << 0),
-	INT_CMD_CMPL_MASK          = (1U << 0),
-	INT_CMD_ISSUE_STOPPED      = (1U << 1),
-	INT_SRS                    = (1U << 3),
-
-	INT_PORT_MASK_OFFSET       = 8,
-	INT_PORT_MASK              = (0xFF << INT_PORT_MASK_OFFSET),
-	INT_PHY_MASK_OFFSET        = 4,
-	INT_PHY_MASK               = (0x0F << INT_PHY_MASK_OFFSET),
-	INT_PORT_STOP_MASK_OFFSET  = 16,
-	INT_PORT_STOP_MASK         = (0xFF << INT_PORT_STOP_MASK_OFFSET),
-
-	INT_NON_SPCFC_NCQ_ERR	   = (1U << 25),
-
-	INT_MEM_PAR_ERR            = (1U << 26),
-	INT_DMA_PEX_TO			= (1U << 27),
-	INT_PRD_BC_ERR			= (1U << 28),
-
-	/* COMMON_PORT_IRQ_STAT/MASK (R160h) bits */
-	IRQ_PHY_RDY_CHNG_MASK         = (1U << 0),
-	IRQ_HRD_RES_DONE_MASK         = (1U << 1),
-	IRQ_PHY_ID_DONE_MASK          = (1U << 2),
-	IRQ_PHY_ID_FAIL_MASK          = (1U << 3),
-	IRQ_PHY_ID_TIMEOUT            = (1U << 4),
-	IRQ_HARD_RESET_RCVD_MASK      = (1U << 5),
-	IRQ_PORT_SEL_PRESENT_MASK     = (1U << 6),
-	IRQ_COMWAKE_RCVD_MASK         = (1U << 7),
-	IRQ_BRDCST_CHNG_RCVD_MASK     = (1U << 8),
-	IRQ_UNKNOWN_TAG_ERR           = (1U << 9),
-	IRQ_IU_TOO_SHRT_ERR           = (1U << 10),
-	IRQ_IU_TOO_LNG_ERR            = (1U << 11),
-	IRQ_PHY_RDY_CHNG_1_TO_0       = (1U << 12),
-	IRQ_SIG_FIS_RCVD_MASK         = (1U << 16),
-	IRQ_BIST_ACTVT_FIS_RCVD_MASK  = (1U << 17),
-	IRQ_ASYNC_NTFCN_RCVD_MASK     = (1U << 18),
-	IRQ_UNASSOC_FIS_RCVD_MASK     = (1U << 19),
-	IRQ_STP_SATA_RX_ERR_MASK      = (1U << 20),
-	IRQ_STP_SATA_TX_ERR_MASK      = (1U << 21),
-	IRQ_STP_SATA_CRC_ERR_MASK     = (1U << 22),
-	IRQ_STP_SATA_DCDR_ERR_MASK    = (1U << 23),
-	IRQ_STP_SATA_PHY_DEC_ERR_MASK = (1U << 24),
-	IRQ_STP_SATA_SYNC_ERR_MASK    = (1U << 25),
-
-	/* common port serial control/status (R180h) bits */
-	SCTRL_STP_LINK_LAYER_RESET        = (1 << 0),
-	SCTRL_PHY_HARD_RESET_SEQ          = (1 << 1),
-	SCTRL_PHY_BRDCST_CHNG_NOTIFY      = (1 << 2),
-	SCTRL_SSP_LINK_LAYER_RESET        = (1 << 3),
-	SCTRL_MIN_SPP_PHYS_LINK_RATE_MASK = (0xF << 8),
-	SCTRL_MAX_SPP_PHYS_LINK_RATE_MASK = (0xF << 12),
-	SCTRL_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET = 16,
-	SCTRL_NEG_SPP_PHYS_LINK_RATE_MASK = (0xF << SCTRL_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET),
-	SCTRL_PHY_READY_MASK              = (1 << 20),
-};
-
-
-/* COMMON_DELV_Q_RD_PTR bits */
-typedef struct _REG_COMMON_DELV_Q_RD_PTR
-{
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-	MV_U32   Reserved:20;
-	MV_U32   DELV_QUEUE_RD_PTR:12;
-#else
-	MV_U32   DELV_QUEUE_RD_PTR:12;
-	MV_U32   Reserved:20;
-#endif /* __MV_BIG_ENDIAN_BITFIELD__ */
-} REG_COMMON_DELV_Q_RD_PTR, *PREG_COMMON_DELV_Q_RD_PTR;
-
-
-/* COMMON_CMPL_Q_WR_PTR bits */
-typedef struct _REG_COMMON_CMPL_Q_WR_PTR
-{
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-	MV_U32   Reserved:20;
-	MV_U32   CMPLN_QUEUE_WRT_PTR:12;
-#else
-	MV_U32   CMPLN_QUEUE_WRT_PTR:12;
-	MV_U32   Reserved:20;
-#endif /* __MV_BIG_ENDIAN_BITFIELD__ */
-} REG_COMMON_CMPL_Q_WR_PTR, *PREG_COMMON_CMPL_Q_WR_PTR;
-
-/* sas/sata command port registers */
-enum cmd_regs {
-	/* cmd pl timer */
-	CMD_PL_TIMER = 0x138,
-
-	/* cmd port layer timer 1 */
-	CMD_PORT_LAYER_TIMER1 = 0x1E0,
-
-        /* link timer */
-        CMD_LINK_TIMER = 0x1E4,
-
-	/* cmd port active register $i ((0x300-0x3ff) */
-	CMD_PORT_ACTIVE0  = 0x300,
-
-	/* SATA register set $i (0x800-0x8ff) task file data register */
-	CMD_SATA_TFDATA0  = 0x800,
-
-	/* SATA register set $i (0xa00-0xaff) association reg */
-	CMD_SATA_ASSOC0   = 0xa00,
-};
-
-/* sas/sata configuration port registers */
-enum config_regs {
-	CONFIG_SATA_CONTROL    = 0x18, /* port SATA control register */
-	CONFIG_PHY_CONTROL     = 0x1c, /* port phy control register */
-
-	CONFIG_SATA_SIG0       = 0x20, /* port SATA signature FIS(Byte 0-3) */
-	CONFIG_SATA_SIG1       = 0x24, /* port SATA signature FIS(Byte 4-7) */
-	CONFIG_SATA_SIG2       = 0x28, /* port SATA signature FIS(Byte 8-11) */
-	CONFIG_SATA_SIG3       = 0x2c, /* port SATA signature FIS(Byte 12-15)*/
-	CONFIG_R_ERR_COUNT     = 0x30, /* port R_ERR count register */
-	CONFIG_CRC_ERR_COUNT   = 0x34, /* port CRC error count register */
-	CONFIG_WIDE_PORT       = 0x38, /* port wide participating register */
-
-	CONFIG_CRN_CNT_INFO0   = 0x80, /* port current connection info register 0*/
-	CONFIG_CRN_CNT_INFO1   = 0x84, /* port current connection info register 1*/
-	CONFIG_CRN_CNT_INFO2   = 0x88, /* port current connection info register 2*/
-	CONFIG_ID_FRAME0       = 0x100, /* Port device ID frame register 0, DEV Info*/
-	CONFIG_ID_FRAME1       = 0x104, /* Port device ID frame register 1*/
-	CONFIG_ID_FRAME2       = 0x108, /* Port device ID frame register 2*/
-	CONFIG_ID_FRAME3       = 0x10c, /* Port device ID frame register 3, SAS Address lo*/
-	CONFIG_ID_FRAME4       = 0x110, /* Port device ID frame register 4, SAS Address hi*/
-	CONFIG_ID_FRAME5       = 0x114, /* Port device ID frame register 5, Phy Id*/
-	CONFIG_ID_FRAME6       = 0x118, /* Port device ID frame register 6*/
-	CONFIG_ATT_ID_FRAME0   = 0x11c, /* attached device ID frame register 0*/
-	CONFIG_ATT_ID_FRAME1   = 0x120, /* attached device ID frame register 1*/
-	CONFIG_ATT_ID_FRAME2   = 0x124, /* attached device ID frame register 2*/
-	CONFIG_ATT_ID_FRAME3   = 0x128, /* attached device ID frame register 3*/
-	CONFIG_ATT_ID_FRAME4   = 0x12c, /* attached device ID frame register 4*/
-	CONFIG_ATT_ID_FRAME5   = 0x130, /* attached device ID frame register 5*/
-	CONFIG_ATT_ID_FRAME6   = 0x134, /* attached device ID frame register 6*/
-};
-
-enum config_regs_bits {
-	/* CONFIG_DEV_INFO/CONFIG_ATT_DEV_INFO (0x00) bits */
-	PORT_DEV_TYPE_MASK     = (0x7U << 0),
-	PORT_DEV_INIT_MASK     = (0x7U << 9),
-	PORT_DEV_TRGT_MASK     = (0x7U << 17),
-
-	PORT_DEV_SMP_INIT      = (1U << 9),
-	PORT_DEV_STP_INIT      = (1U << 10),
-	PORT_DEV_SSP_INIT      = (1U << 11),
-	PORT_DEV_SMP_TRGT      = (1U << 17),
-	PORT_DEV_STP_TRGT      = (1U << 18),
-	PORT_DEV_SSP_TRGT      = (1U << 19),
-
-	PORT_PHY_ID_MASK       = (0xFFU << 24),
-
-	/* CONFIG_PHY_STATUS (0x1c) bits */
-	PORT_PHY_OOB_DTCTD	   = (1U << 0),
-	PORT_PHY_DW_SYNC	   = (1U << 1),
-	PORT_PHY_RDY		   = (1U << 2),
-	PORT_PHY_NGTD_SPEED	   = (1U << 4),
-	PORT_PHY_IMP_CAL_DONE  = (1U << 5),
-	PORT_PHY_KVCO		   = (0x7U << 6),
-	PORT_PHY_PLL_LOCK	   = (1U << 9),
-	PORT_PHY_PLL_CAL_DONE  = (1U << 10),
-	PORT_PHY_RXIMP		   = (0xFU << 11),
-	PORT_PHY_TXIMP		   = (0xFU << 15),
-
-	/* CONFIG_WIDE_PORT (0x38) bits */
-	WIDE_PORT_PHY_MASK     = (0xF << 0), /* phy map in a wide port */
-};
-
-/* Power Mode PM_CNTRL/PMODE */
-#define PMODE_PARTIAL      0x10
-#define PMODE_SLUMBER      0x01
-
-/* CONFIG_R_ERR_COUNT/CONFIG_CRC_ERR_COUNT bits */
-#define ERR_COUNT_MASK      0x0ffff
-
-/* sas/sata vendor specific port registers */
-enum vsr_regs {
-	VSR_IRQ_STATUS      = 0x00,
-	VSR_IRQ_MASK        = 0x04,
-	VSR_PHY_CONFIG      = 0x08,
-	VSR_PHY_STATUS      = 0x0c,
-
-	VSR_PHY_MODE_REG_1	= 0x064,
-	VSR_PHY_FFE_CONTROL	= 0x10C,
-	VSR_PHY_DFE_UPDATE_CRTL	= 0x110,
-	VSR_REF_CLOCK_CRTL	= 0x1A0,
-};
-
-enum vsr_reg_bits {
-	/* VSR_IRQ_STATUS bits */
-	VSR_IRQ_PHY_TIMEOUT     = (1U << 10),
-
-	/* VSR_PHY_STATUS bits */
-	VSR_PHY_STATUS_MASK     = 0x3f0000,
-	VSR_PHY_STATUS_IDLE     = 0x00,
-	VSR_PHY_STATUS_SAS_RDY  = 0x10,
-	VSR_PHY_STATUS_HR_RDY   = 0x1d,
-};
-
-enum mv_pci_regs {
-	MV_PCI_REG_CMD      = 0x04,
-	MV_PCI_REG_DEV_CTRL = 0x78,
-	MV_PCI_REG_MSI_CTRL = 0x50,
-
-	MV_PCI_REG_ADDRESS_BASE = 0x8000,
-
-	CORE_NVSRAM_MAPPING_BASE = 0x0,
-	MV_PCI_REG_WIN0_CTRL = (MV_PCI_REG_ADDRESS_BASE + 0x420),
-	MV_PCI_REG_WIN0_BASE = (MV_PCI_REG_ADDRESS_BASE + 0x424),
-        MV_PCI_REG_WIN0_REMAP = (MV_PCI_REG_ADDRESS_BASE + 0x428),
-
-	MV_PCI_REG_INT_CAUSE = (MV_PCI_REG_ADDRESS_BASE + 0x600),
-	MV_PCI_REG_INT_ENABLE = (MV_PCI_REG_ADDRESS_BASE + 0x604),
-};
-
-enum mv_pci_regs_bits {
-	/* MV_PCI_REG_MSI_CTRL bits */
-	MV_PCI_MSI_EN       = (1 << 16),
-
-	/* MV_PCI_REG_DEV_CTRL bits */
-	MV_PCI_IO_EN        = (1 << 0),
-	MV_PCI_MEM_EN       = (1 << 1),
-	MV_PCI_BM_EN        = (1 << 2),    /* enable bus master */
-	MV_PCI_INT_DIS      = (1 << 10),   /* disable INTx for MSI_EN */
-	MV_PCI_DEV_EN       = MV_PCI_IO_EN | MV_PCI_MEM_EN | MV_PCI_BM_EN,
-	MV_PCI_RD_REQ_SIZE  = 0x2000,
-	MV_PCI_RD_REQ_MASK  = 0x00007000,
-};
-
-enum mv_sgpio_regs{
-	SGPIO_REG_BASE    = 0xc200, /* SGPIO register start */
-};
-
-enum mv_i2c_regs{
-	I2C_SOFTWARE_CONTROL_A = 0xc51c,
-	I2C_HARDWARE_CONTROL_A = 0xc520,
-	I2C_STATUS_DATA_A      = 0xc524,
-
-	I2C_SOFTWARE_CONTROL_B = 0xc61c,
-	I2C_HARDWARE_CONTROL_B = 0xc620,
-	I2C_STATUS_DATA_B      = 0xc624,
-
-	I2C_SOFTWARE_CONTROL_C = 0xc71c,
-	I2C_HARDWARE_CONTROL_C = 0xc720,
-	I2C_STATUS_DATA_C      = 0xc724,
-
-};
-
-enum mv_spi_regs{
-	ODIN_SPI_CTRL_REG = 0xc800,
-	ODIN_SPI_ADDR_REG = 0xc804,
-	ODIN_SPI_WR_DATA_REG	= 0xc808,
-	ODIN_SPI_RD_DATA_REG = 0xc80c,
-};
-enum mv_spi_reg_bit{
-	SPI_CTRL_READ = MV_BIT( 2 ),
-	SPI_CTRL_AddrValid = MV_BIT( 1 ),
-	SPI_CTRL_SpiStart = MV_BIT( 0 ),
-};
-
-/* for buzzer */
-enum test_pin_regs {
-	TEST_PIN_OUTPUT_VALUE = 0x10068,
-	TEST_PIN_OUTPUT_ENABLE = 0x1006C,
-	TEST_PIN_BUZZER		= MV_BIT(2),
-};
-
-
-/*
-  ========================================================================
-	Software data structures/macros
-  ========================================================================
-*/
-
-#define MAX_SSP_RESP_SENSE_SIZE      sizeof(MV_Sense_Data)
-#define MAX_SMP_RESP_SIZE			 1016
-
-/*
- * Hardware related format. Never change their size. Must follow hardware
- * specification.
- */
-enum _mv_command_header_bit_ops {
-	CH_BIST=  (1UL << 4),
-	CH_ATAPI = (1UL << 5),
-	CH_FPDMA = (1UL << 6),
-	CH_RESET = (1UL << 7),
-	CH_PI_PRESENT = (1UL <<8),
-	CH_SSP_TP_RETRY = (1UL << 9),
-	CH_SSP_VERIFY_DATA_LEN = ( 1UL <<10),
-	CH_SSP_FIRST_BURST = (1UL << 11),
-	CH_SSP_PASS_THRU = (1UL << 12),
-
-	CH_SSP_FRAME_TYPE_SHIFT = 13,
-	CH_PRD_TABLE_LEN_SHIFT = 16,
-
-	CH_PM_PORT_MASK = 0xf,
-
-	CH_FRAME_LEN_MASK = 0xff,
-	CH_LEAVE_AFFILIATION_OPEN_SHIFT = 9,
-	CH_MAX_SIMULTANEOUS_CONNECTIONS_SHIFT = 12,
-	CH_MAX_RSP_FRMAE_LEN_MASK = 0x1ff,
-
-	XBAR_CT_CS_SHIFT = 0,
-	XBAR_OAF_CS_SHIFT = 4,
-	XBAR_SB_CS_SHIFT = 0,
-	XBAR_PRD_CS_SHIFT = 4,
-
-	PI_BLK_INDX_FLDS_PRNST = (1UL << 13),
-	PI_KEY_TAG_FLDS_PRNST = (1UL << 14),
-	PI_T10_FLDS_PRNST = (1UL << 15),
-};
-/* for command list */
-typedef struct _mv_command_header
-{
-	MV_U32   ctrl_nprd;
-	MV_U16 frame_len;
-	MV_U16 max_rsp_frame_len;
-
-	MV_U16 tag;
-	MV_U16 target_tag;
-/* DWORD 3 */
-	MV_U32   data_xfer_len;         /* in bytes */
-/* DWORD 4-5*/
-	_MV_U64  table_addr;
-/* DWORD 6-7*/
-	_MV_U64  open_addr_frame_addr;
-/* DWORD 8-9*/
-	_MV_U64  status_buff_addr;
-	_MV_U64  prd_table_addr;
-
-	MV_U16	 interface_select;
-	MV_U16	 pir_fmt;
-	MV_U32	 reserved[3];
-} mv_command_header;
-
-/* SSP_SSPFrameType */
-#define FRAME_TYPE_COMMAND         0x00
-#define FRAME_TYPE_TASK            0x01
-#define FRAME_TYPE_XFER_RDY         0x04 /* Target mode */
-#define FRAME_TYPE_RESPONSE         0x05 /* Target mode */
-#define FRAME_TYPE_RD_DATA         0x06 /* Target mode */
-#define FRAME_TYPE_RD_DATA_RESPONSE   0x07 /* Target mode, read data after response frame */
-/* Tag */
-#define SSP_I_HEADR_TAG_MASK      0xfe00   /* lower 9 bits from HW command slot */
-#define SSP_T_HEADR_TAG_MASK      0xffff
-#define STP_HEADR_TAG_MASK         0x001f   /* NCQ uses lower 5 bits  */
-/* TargetTag */
-#define SSP_T_HEADR_TGTTAG_MASK      0xfe00   /* lower 9 bits from HW command slot */
-
-/* for command table */
-/* SSP frame header */
-typedef struct _ssp_frame_header
-{
-	MV_U8   frame_type;
-	MV_U8   hashed_dest_sas_addr[3];
-	MV_U8   reserved1;
-	MV_U8   hashed_src_sas_addr[3];
-	MV_U8   reserved2[2];
-	MV_U8 _ssp_c_t_r;
-	MV_U8 _ssp_n_f;
-	MV_U8   reserved5[4];
-	MV_U16  tag;         /* command tag */
-	MV_U16  target_tag;      /* Target Port Transfer Tag, for target to tag multiple XFER_RDY */
-	MV_U32  data_offset;
-}ssp_frame_header;
-
-/* SSP Command UI */
-typedef struct _ssp_command_iu
-{
-	MV_U8   lun[8];
-	MV_U8   reserved1;
-	MV_U8 _c_iu_ta_fb;
-	MV_U8 reserved3;
-	MV_U8 _c_iu_e_cdb_len;
-	MV_U8   cdb[16];
-}ssp_command_iu;
-
-/* SSP TASK UI */
-typedef struct _ssp_task_iu
-{
-	MV_U8   lun[8];
-	MV_U8   reserved1[2];
-	MV_U8   task_function;
-	MV_U8   reserved2;
-	MV_U16  tag;
-	MV_U8   reserved3[14];
-}ssp_task_iu;
-
-/* SSP XFER_RDY UI */
-typedef struct _ssp_xferrdy_iu
-{
-	MV_U32   data_offset;
-	MV_U32   data_len;
-	MV_U8    reserved3[4];
-}ssp_xferrdy_iu;
-
-/* SSP RESPONSE UI */
-typedef struct _ssp_response_iu
-{
-	MV_U8   reserved1[10];
-	MV_U8  data_pres;
-	MV_U8   status;
-	MV_U32  reserved3;
-	MV_U32  sense_data_len;
-	MV_U32  resp_data_len;
-	MV_U8   data[MAX_SSP_RESP_SENSE_SIZE];
-}ssp_response_iu;
-
-/* DataPres */
-#define NO_SENSE_RESPONSE   0x0
-#define RESPONSE_ONLY      0x1
-#define SENSE_ONLY         0x2
-#define RESERVED         0x3
-
-/* SSP Protection Information Record */
-typedef struct _protect_info_record
-{
-#ifdef __MV_BIG_ENDIAN_BITFIELD__
-	/*DWORD 0*/
-	MV_U32 USR_DT_SZ:12;
-	MV_U32 reserved2:6;
-	MV_U32 SKIP_EN:1;
-	MV_U32 reserved1:5;
-	MV_U32 PRD_DATA_INCL_T10:1;
-	MV_U32 INCR_LBAT:1;
-	MV_U32 INCR_LBRT:1;
-	MV_U32 CHK_DSBL_MD:1;
-	MV_U32 T10_CHK_EN:1;
-	MV_U32 T10_RPLC_EN:1;
-	MV_U32 T10_RMV_EN:1;
-	MV_U32 T10_INSRT_EN:1;
-	/*DWORD 1,2*/
-	MV_U32 LBRT_CHK_VAL;      /* Logical Block Reference Tag */
-	MV_U32 LBRT_GEN_VAL;      /* Logical Block Reference Tag Gen Value*/
-	/*DWORD 3*/
-	MV_U32 LBAT_CHK_MASK:16;	/* Logical Block Application Tag Check Mask*/
-	MV_U32 LBAT_CHK_VAL:16;      /* Logical Block Application Tag Check Value*/
-	/*DWORD 4*/
-	MV_U32 T10_RPLC_MSK:8;	/*T10 Replace Mask*/
-	MV_U32 T10_CHK_MSK:8;	/*T10 Check Mask*/
-	MV_U32 LBAT_GEN_VAL:16;      /* Logical Block Application Tag Gen Value*/
-	/*DWORD 5,6*/
-	MV_U32 reserved0[2]; /*DW5 and DW6 not required when SKIP_EN is reset.*/
-#else
-	/*DWORD 0*/
-	MV_U32 T10_INSRT_EN:1;
-	MV_U32 T10_RMV_EN:1;
-	MV_U32 T10_RPLC_EN:1;
-	MV_U32 T10_CHK_EN:1;
-	MV_U32 CHK_DSBL_MD:1;
-	MV_U32 INCR_LBRT:1;
-	MV_U32 INCR_LBAT:1;
-	MV_U32 PRD_DATA_INCL_T10:1;
-	MV_U32 reserved1:5;
-	MV_U32 SKIP_EN:1;
-	MV_U32 reserved2:6;
-	MV_U32 USR_DT_SZ:12;
-	/*DWORD 1,2*/
-	MV_U32 LBRT_CHK_VAL;      /* Logical Block Reference Tag */
-	MV_U32 LBRT_GEN_VAL;      /* Logical Block Reference Tag Gen Value*/
-	/*DWORD 3*/
-	MV_U32 LBAT_CHK_VAL:16;      /* Logical Block Application Tag Check Value*/
-	MV_U32 LBAT_CHK_MASK:16;	/* Logical Block Application Tag Check Mask*/
-	/*DWORD 4*/
-	MV_U32 LBAT_GEN_VAL:16;      /* Logical Block Application Tag Gen Value*/
-	MV_U32 T10_CHK_MSK:8;	/*T10 Check Mask*/
-	MV_U32 T10_RPLC_MSK:8;	/*T10 Replace Mask*/
-	/*DWORD 5,6*/
-	MV_U32 reserved0[2]; /*DW5 and DW6 not required when SKIP_EN is reset.*/
-#endif /* __MV_BIG_ENDIAN_BITFIELD__ */
-}protect_info_record;
-
-
-/* SSP Command Table */
-typedef struct _mv_ssp_command_table
-{
-	ssp_frame_header frame_header;
-	union
-	{
-		struct {
-			ssp_command_iu command_iu;
-			protect_info_record pir;
-		} command;
-		ssp_task_iu task;
-		ssp_xferrdy_iu xfer_rdy;
-		ssp_response_iu response;
-	} data;
-} mv_ssp_command_table;
-
-/* SATA STP Command Table */
-typedef struct _mv_sata_stp_command_table
-{
-	MV_U8   fis[64];                        /* Command FIS */
-	MV_U8   atapi_cdb[32];                     /* ATAPI CDB */
-} mv_sata_stp_command_table;
-
-#define OF_MODE_SHIFT 7
-#define OF_MODE_TARGET 0x0
-#define OF_MODE_INITIATOR 0x1
-#define OF_PROT_TYPE_SHIFT 4
-/* Open Address Frame */
-typedef struct _open_addr_frame
-{
-	MV_U8   frame_control; /* frame, protocol, initiator etc. */
-	MV_U8   connection_rate;   /* connection rate, feature etc. */
-	MV_U8   connect_tag[2];
-	MV_U8   dest_sas_addr[8];
-/* HW will generate Byte 12 after... */
-	MV_U8   src_sas_addr[8];
-	MV_U8   src_zone_grp;
-	MV_U8   blocked_count;
-	MV_U8   awt[2];
-	MV_U8   cmp_features2[4];
-	MV_U32  first_burst_size;      /* for hardware use*/
-}open_addr_frame;
-
-/* Protocol */
-#define PROTOCOL_SMP      0x0
-#define PROTOCOL_SSP      0x1
-#define PROTOCOL_STP      0x2
-
-enum _mv_error_record_info_type_ {
-	BFFR_PERR      = (1UL << 0),
-	WD_TMR_TO_ERR  = (1UL << 1),
-	CREDIT_TO_ERR  = (1UL << 2),
-	WRONG_DEST_ERR = (1UL << 3),
-
-	CNCTN_RT_NT_SPRTD_ERR = (1UL << 4),
-	PRTCL_NOT_SPRTD_ERR   = (1UL << 5),
-
-	BAD_DEST_ERR   = (1UL << 6),
-	BRK_RCVD_ERR   = (1UL << 7),
-	STP_RSRCS_BSY_ERR = (1UL << 8),
-
-	NO_DEST_ERR = (1UL << 9),
-	PTH_BLKD_ERR = (1UL << 10),
-
-	OPEN_TMOUT_ERR = (1UL << 11),
-	CNCTN_CLSD_ERR = (1UL << 12),
-	ACK_NAK_TO     = (1UL << 13),
-	NAK_ERR        = (1UL << 14),
-	INTRLCK_ERR    = (1UL << 15),
-	DATA_OVR_UNDR_FLW_ERR = (1UL << 16),
-	Reserved1      = (1UL << 17),
-
-	UNEXP_XFER_RDY_ERR = (1UL << 18),
-	XFR_RDY_OFFST_ERR  = (1UL << 19),
-	RD_DATA_OFFST_ERR  = (1UL << 20),
-
-	TX_STOPPED_EARLY   = (1UL << 22),
-
-	R_ERR     = (1UL << 23),
-	TFILE_ERR = (1UL << 24),
-	SYNC_ERR  = (1UL << 25),
-
-	DMAT_RCVD = (1UL << 26),
-	UNKNWN_FIS_ERR = (1UL << 27),
-	RTRY_LMT_ERR  = (1UL << 28),
-	RESP_BFFR_OFLW = (1UL << 29),
-
-	PI_ERR  = (1UL << 30),
-	CMD_ISS_STPD = (1UL << 31),
-
-	USR_BLK_NM_MASK = 0xfff,
-
-	/* Protection information */
-	REF_CHK_ERR = (1UL << 12),
-	APP_CHK_ERR = (1UL << 13),
-	GRD_CHK_ERR =  (1UL << 14),
-
-	SLOT_BSY_ERR = (1UL << 31),
-};
-/* Error Information Record */
-typedef struct _err_info_record
-{
-	MV_U32 err_info_field_1;
-	MV_U32 err_info_field_2;
-}err_info_record;
-
-
-/* Status Buffer */
-typedef struct _status_buffer
-{
-	err_info_record err_info;
-	union
-	{
-		struct _ssp_response_iu ssp_resp;
-		MV_U8   smp_resp[MAX_SMP_RESP_SIZE];
-	} data;
-}status_buffer;
-
-#define MAX_RESPONSE_FRAME_LENGTH \
-	(MV_MAX(sizeof(struct _ssp_response_iu), MAX_SMP_RESP_SIZE))
-
-
-
-/* Command Table */
-typedef struct _mv_command_table
-{
-	open_addr_frame   open_address_frame;
-	status_buffer	  status_buff;
-
-	union
-	{
-		mv_ssp_command_table ssp_cmd_table;
-		mv_smp_command_table smp_cmd_table;
-		mv_sata_stp_command_table stp_cmd_table;
-	} table;
-} mv_command_table;
-
-enum sas_rx_tx_ring_bits {
-/* RX (completion) ring bits */
-	RXQ_RSPNS_GOOD		= (1U << 23),	/* Response good */
-	RXQ_SLOT_RST_CMPLT	= (1U << 21),	/* Slot reset complete */
-	RXQ_CMD_RCVD		= (1U << 20),	/* target cmd received */
-	RXQ_ATTN		= (1U << 19),	/* attention */
-	RXQ_RSPNS_XFRD		= (1U << 18),	/* response frame xfer'd */
-	RXQ_ERR_RCRD_XFRD	= (1U << 17),	/* err info rec xfer'd */
-	RXQ_CMD_CMPLT		= (1U << 16),	/* cmd complete */
-	RXQ_SLOT_MASK		= 0xfff,	/* slot number */
-
-/* TX (delivery) ring bits */
-	TXQ_MODE_I              = (1UL << 28),
-	TXQ_CMD_SSP             = (1UL << 29),
-	TXQ_CMD_SMP             = (2UL << 29),
-	TXQ_CMD_STP             = (3UL << 29),
-
-	TXQ_PHY_SHIFT  = 12,
-	TXQ_REGSET_SHIFT = 20,
-	TXQ_PRIORITY_SHIFT = 27,
-};
-
-#define CMD_SSP         0x01
-#define CMD_SMP         0x02
-#define CMD_STP         0x03
-#define CMD_SSP_TGT      0x04
-#define CMD_SLOT_RESET   0x07
-
-enum prd_slt_chain_bit{
-	PRD_CHAIN_BIT = (1UL<<24),
-	PRD_IF_SELECT_BIT = (0xFUL<<28),
-
-	PRD_IF_SELECT_SHIFT = 28,
-};
-
-/*prd table for vanir 3 DW*/
-typedef struct _prd_t
-{
-	MV_U32	baseAddr_low;
-	MV_U32  baseAddr_high;
-	/*DW3: IF select, chain and size*/
-	MV_U32 size;
-
-} prd_t;
-
-typedef struct _prd_context
-{
-	prd_t * prd;
-	MV_U16 avail;
-	MV_U16 reserved;
-}prd_context;
-/*
-  ========================================================================
-	Accessor macros and functions
-  ========================================================================
-*/
-#define READ_PORT_IRQ_STAT(root, phy) \
-   (MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_IRQ_STAT0 + (phy->asic_id * 8)))
-
-#define WRITE_PORT_IRQ_STAT(root, phy, tmp) \
-   (MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_IRQ_STAT0 + (phy->asic_id * 8), tmp))
-
-#define READ_PORT_IRQ_MASK(root, phy) \
-   (MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_IRQ_MASK0 + (phy->asic_id * 8)))
-
-#define WRITE_PORT_IRQ_MASK(root, phy, tmp) \
-   (MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_IRQ_MASK0 + (phy->asic_id * 8), tmp))
-
-#define READ_PORT_PHY_CONTROL(root, phy) \
-   (MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_PHY_CONTROL0 + (phy->asic_id * 4)))
-
-#define WRITE_PORT_PHY_CONTROL(root, phy, tmp) \
-   (MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_PHY_CONTROL0 + (phy->asic_id * 4), tmp))
-
-#define READ_PORT_VSR_DATA(root, phy) \
-   (MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_VSR_DATA0 + (phy->asic_id * 8)))
-
-#define WRITE_PORT_VSR_DATA(root, phy, tmp) \
-   (MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_VSR_DATA0 + (phy->asic_id * 8), tmp))
-
-#define WRITE_PORT_VSR_ADDR(root, phy, tmp) \
-   (MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_VSR_ADDR0 + (phy->asic_id * 8), tmp))
-
-#define READ_PORT_CONFIG_DATA(root, phy) \
-   (MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_CONFIG_DATA0 + (phy->asic_id * 8)))
-
-#define WRITE_PORT_CONFIG_DATA(root, phy, tmp) \
-   (MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_CONFIG_DATA0 + (phy->asic_id * 8), tmp))
-
-#define WRITE_PORT_CONFIG_ADDR(root, phy, tmp) \
-   (MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_CONFIG_ADDR0 + (phy->asic_id * 8), tmp))
-
-#define READ_REGISTER_SET_ENABLE(root, i) \
-	MV_REG_READ_DWORD(root->mmio_base,(((i) > 31) ? COMMON_SATA_REG_SET1 : COMMON_SATA_REG_SET0))
-
-#define WRITE_REGISTER_SET_ENABLE(root, i, tmp) \
-	MV_REG_WRITE_DWORD(root->mmio_base, (((i) > 31) ? COMMON_SATA_REG_SET1 : COMMON_SATA_REG_SET0), tmp)
-
-#define READ_SRS_IRQ_STAT(root, i) \
-	MV_REG_READ_DWORD(root->mmio_base, (((i)>31) ? COMMON_SRS_IRQ_STAT1 : COMMON_SRS_IRQ_STAT0))
-
-#define WRITE_SRS_IRQ_STAT(root, i, tmp) \
-	MV_REG_WRITE_DWORD(root->mmio_base, (((i)>31) ? COMMON_SRS_IRQ_STAT1 : COMMON_SRS_IRQ_STAT0), tmp)
-
-MV_VOID mv_set_dev_info(MV_PVOID root_p, MV_PVOID phy_p);
-MV_VOID mv_set_sas_addr(MV_PVOID root_p, MV_PVOID phy_p, MV_PU8 sas_addr);
-MV_VOID mv_reset_phy(MV_PVOID root_p, MV_U8 logic_phy_map, MV_BOOLEAN hard_reset);
-
-MV_VOID hal_clear_srs_irq(MV_PVOID root_p, MV_U32 set, MV_BOOLEAN clear_all);
-MV_VOID hal_enable_register_set(MV_PVOID root_p, MV_PVOID base_p);
-MV_BOOLEAN sata_is_register_set_stopped(MV_PVOID root_p, MV_U8 set);
-
-MV_VOID hal_disable_io_chip(MV_PVOID root_p);
-
-#define hal_has_phy_int(common_irq, phy)	\
-	(common_irq & \
-		(MV_BIT(phy->asic_id + INT_PORT_MASK_OFFSET) \
-		| MV_BIT(phy->asic_id + INT_PHY_MASK_OFFSET)))
-
-
-#define hal_remove_phy_int(common_irq, phy)	\
-	(common_irq & \
-		~(MV_BIT(phy->asic_id + INT_PORT_MASK_OFFSET) \
-			| MV_BIT(phy->asic_id + INT_PHY_MASK_OFFSET)))
-
-#define mv_is_phy_ready(root, phy) \
-               (READ_PORT_PHY_CONTROL(root, phy) & SCTRL_PHY_READY_MASK)
-
-#define get_phy_link_rate(phy_status)	(MV_U8)\
-	(((phy_status&SCTRL_NEG_SPP_PHYS_LINK_RATE_MASK) >> \
-	SCTRL_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET) + SAS_LINK_RATE_1_5_GBPS)
-
-#define mv_sgpio_write_register(mmio, reg, value)		\
-	 MV_REG_WRITE_DWORD(mmio, SGPIO_REG_BASE+reg, value)
-
-#define mv_sgpio_read_register(mmio, reg, value)		\
-	 value = MV_REG_READ_DWORD(mmio, SGPIO_REG_BASE+reg)
-
-enum command_handler_defs
-{
-	HANDLER_SSP = 0,
-	HANDLER_SATA,
-	HANDLER_SATA_PORT,
-	HANDLER_STP,
-	HANDLER_PM,
-	HANDLER_SMP,
-	HANDLER_ENC,
-	HANDLER_API,
-	HANDLER_I2C,
-	MAX_NUMBER_HANDLER
-};
-
-int core_prepare_hwprd(MV_PVOID core, sgd_tbl_t * source, MV_PVOID prd);
-
-MV_U8 sata_get_register_set(MV_PVOID root_p);
-MV_VOID sata_free_register_set(MV_PVOID root_p, MV_U8 set);
-MV_VOID io_chip_handle_cmpl_queue_int(MV_PVOID root_p);
-MV_U16 prot_set_up_sg_table(MV_PVOID root_p, MV_Request *req, MV_PVOID sg_wrapper_p);
-MV_VOID core_fill_prd(MV_PVOID prd_ctx, MV_U64 bass_addr, MV_U32 size);
-#define mv_reset_stp(x, y)
-
-MV_VOID core_alarm_enable_register(MV_PVOID core_p);
-MV_VOID core_alarm_set_register(MV_PVOID core_p, MV_U8 value);
-MV_VOID core_dump_common_reg(void *root_p);
-
-#endif /* __CORE_HAL_H */
--- a/drivers/scsi/vanir/product/vanir/core_init.c
+++ /dev/null
@@ -1,753 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "mv_config.h"
-#include "core_init.h"
-#include "core_type.h"
-#include "core_hal.h"
-#include "core_util.h"
-#include "core_manager.h"
-
-#include "core_sas.h"
-#include "core_sata.h"
-#include "core_error.h"
-#include "core_expander.h"
-#include "core_console.h"
-
-extern void core_handle_init_queue(core_extension *core, MV_BOOLEAN single);
-extern void core_handle_waiting_queue(core_extension *core);
-
-MV_VOID io_chip_init_registers(pl_root *root);
-
-void update_phy_info(pl_root *root, domain_phy *phy);
-void update_port_phy_map(pl_root *root, domain_phy *phy);
-
-void set_phy_tuning(pl_root *root, domain_phy *phy, PHY_TUNING phy_tuning)
-{
-	core_extension *core = root->core;
-	MV_U32 tmp, setting_0 = 0, setting_1 = 0;
-	MV_U8 i;
-
-	/* Remap information for B0 chip:
-	*
-	* R0Ch -> R118h[15:0] (Adapted DFE F3 - F5 coefficient)
-	* R0Dh -> R118h[31:16] (Generation 1 Setting 0)
-	* R0Eh -> R11Ch[15:0]  (Generation 1 Setting 1)
-	* R0Fh -> R11Ch[31:16] (Generation 2 Setting 0)
-	* R10h -> R120h[15:0]  (Generation 2 Setting 1)
-	* R11h -> R120h[31:16] (Generation 3 Setting 0)
-	* R12h -> R124h[15:0]  (Generation 3 Setting 1)
-	* R13h -> R124h[31:16] (Generation 4 Setting 0 (Reserved))
-	*/
-
-	/* A0 has a different set of registers */
-	if (core->revision_id == VANIR_A0_REV) return;
-
-	for (i = 0; i < 3; i++) {
-		/* loop 3 times, set Gen 1, Gen 2, Gen 3 */
-		switch (i) {
-		case 0:
-			setting_0 = GENERATION_1_SETTING;
-			setting_1 = GENERATION_1_2_SETTING;
-			break;
-		case 1:
-			setting_0 = GENERATION_1_2_SETTING;
-			setting_1 = GENERATION_2_3_SETTING;
-			break;
-		case 2:
-			setting_0 = GENERATION_2_3_SETTING;
-			setting_1 = GENERATION_3_4_SETTING;
-			break;
-		}
-
-		/* Set:
-		*
-		*   Transmitter Emphasis Enable
-		*   Transmitter Emphasis Amplitude
-		*   Transmitter Amplitude
-		*/
-		WRITE_PORT_VSR_ADDR(root, phy, setting_0);
-		tmp = READ_PORT_VSR_DATA(root, phy);
-		tmp &= ~(0xFBE << 16);
-		tmp |= (((phy_tuning.Trans_Emphasis_En << 11) |
-		(phy_tuning.Trans_Emphasis_Amp << 7) |
-		(phy_tuning.Trans_Amp << 1)) << 16);
-		WRITE_PORT_VSR_DATA(root, phy, tmp);
-
-		/* Set Transmitter Amplitude Adjust */
-		WRITE_PORT_VSR_ADDR(root, phy, setting_1);
-		tmp = READ_PORT_VSR_DATA(root, phy);
-		tmp &= ~(0xC000);
-		tmp |= (phy_tuning.Trans_Amp_Adjust << 14);
-		WRITE_PORT_VSR_DATA(root, phy, tmp);
-	}
-}
-
-MV_VOID set_phy_ffe_tuning(pl_root *root, domain_phy *phy, FFE_CONTROL ffe)
-{
-	core_extension *core = (core_extension *)root->core;
-	MV_U32 tmp;
-
-	if ((core->revision_id == VANIR_A0_REV) ||
-		(core->revision_id == VANIR_B0_REV)) return;
-
-	/* FFE Resistor and Capacitor */
-	/* R10Ch DFE Resolution Control/Squelch and FFE Setting
-	 *
-	 * FFE_FORCE            [7]
-	 * FFE_RES_SEL          [6:4]
-	 * FFE_CAP_SEL          [3:0]
-	 */
-	WRITE_PORT_VSR_ADDR(root, phy, VSR_PHY_FFE_CONTROL);
-	tmp = READ_PORT_VSR_DATA(root, phy);
-	tmp &= ~0xFF;
-
-	/* Read from HBA_Info_Page */
-	tmp |= ((0x1 << 7) |
-		(ffe.FFE_Resistor_Select << 4) |
-		(ffe.FFE_Capacitor_Select << 0));
-
-	WRITE_PORT_VSR_DATA(root, phy, tmp);
-
-	/* R064h PHY Mode Register 1
-	 *
-	 * DFE_DIS		18
-	 */
-	WRITE_PORT_VSR_ADDR(root, phy, VSR_REF_CLOCK_CRTL);
-	tmp = READ_PORT_VSR_DATA(root, phy);
-	tmp &= ~0x40001;
-
-	tmp |= (0 << 18);
-	WRITE_PORT_VSR_DATA(root, phy, tmp);
-
-	/* R110h DFE F0-F1 Coefficient Control/DFE Update Control
-	 *
-	 * DFE_UPDATE_EN        [11:6]
-	 * DFE_FX_FORCE         [5:0]
-	 */
-	WRITE_PORT_VSR_ADDR(root, phy, VSR_PHY_DFE_UPDATE_CRTL);
-	tmp = READ_PORT_VSR_DATA(root, phy);
-	tmp &= ~0xFFF;
-
-	tmp |= ((0x3F << 6) | (0x0 << 0));
-	WRITE_PORT_VSR_DATA(root, phy, tmp);
-
-	/* R1A0h Interface and Digital Reference Clock Control/Reserved_50h
-	 *
-	 * FFE_TRAIN_EN         3
-	 */
-	WRITE_PORT_VSR_ADDR(root, phy, VSR_REF_CLOCK_CRTL);
-	tmp = READ_PORT_VSR_DATA(root, phy);
-	tmp &= ~0x8;
-
-	tmp |= (0 << 3);
-	WRITE_PORT_VSR_DATA(root, phy, tmp);
-}
-
-MV_VOID set_phy_rate(pl_root *root, domain_phy *phy, MV_U8 rate)
-{
-	MV_U32 tmp;
-
-	WRITE_PORT_VSR_ADDR(root, phy, VSR_PHY_CONFIG);
-	tmp = READ_PORT_VSR_DATA(root, phy);
-	tmp &= 0x80000F;
-	/*bit 18:4 for phy rate config. 		(1.5Gbps, 3Gbps, 6Gbps).*/
-	/*Bit18:15:	Tx Requested Logical Link Rate(Multiplexing)(0000,	1000b, 1001b)
-	* Bit14:9:	Tx Supported Physical Link Rates	(110000b, 111100b, 111111b)
-	* Bit8: 		Parity bit to ensure bit14:8 is odd (1, 0, 1)
-	* Bit7: 		SNW3 supported				(0, 0, 1)
-	* Bit6:4		Support speed List				(001b, 011b, 111b)
-	*/
-
-	switch(rate) {
-	case 0x0:
-		tmp |= 0x0000611eL; /* support 1.5Gbps */
-		break;
-	case 0x1:
-		tmp |= 0x0004783eL; /* support 1.5,3.0Gbps */
-		break;
-	case 0x2:
-	default:
-		tmp |= 0x0004fffeL; /* support 1.5,3.0Gbps,6.0Gbps */
-		break;
-	}
-	WRITE_PORT_VSR_DATA(root, phy, tmp);
-}
-
-
-MV_VOID core_dump_common_reg(void *root_p)
-{
-	pl_root *root = (pl_root *)root_p;
-	MV_LPVOID mmio = root->mmio_base;
-	MV_U8 i;
-	MV_DPRINT(("COMMON_PORT_IMPLEMENT(0x9C)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_PORT_IMPLEMENT)));
-	MV_DPRINT(("COMMON_PORT_TYPE(0xA0)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_PORT_TYPE)));
-	MV_DPRINT(("COMMON_CONFIG(0x100)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_CONFIG)));
-	MV_DPRINT(("COMMON_CONTROL(0x104)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_CONTROL)));
-	MV_DPRINT(("COMMON_LST_ADDR(0x108)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_LST_ADDR)));
-	MV_DPRINT(("COMMON_LST_ADDR_HI(0x10C)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_LST_ADDR_HI)));
-	MV_DPRINT(("COMMON_FIS_ADDR(0x110)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_FIS_ADDR)));
-	MV_DPRINT(("COMMON_FIS_ADDR_HI(0x114)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_FIS_ADDR_HI)));
-	MV_DPRINT(("COMMON_SATA_REG_SET0(0x118)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_SATA_REG_SET0)));
-	MV_DPRINT(("COMMON_SATA_REG_SET1(0x11C)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_SATA_REG_SET1)));
-	MV_DPRINT(("COMMON_DELV_Q_CONFIG(0x120)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_DELV_Q_CONFIG)));
-	MV_DPRINT(("COMMON_DELV_Q_ADDR(0x124)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_DELV_Q_ADDR)));
-	MV_DPRINT(("COMMON_DELV_Q_ADDR_HI(0x128)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_DELV_Q_ADDR_HI)));
-	MV_DPRINT(("COMMON_DELV_Q_WR_PTR(0x12C)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_DELV_Q_WR_PTR)));
-	MV_DPRINT(("COMMON_DELV_Q_RD_PTR(0x130)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_DELV_Q_RD_PTR)));
-	MV_DPRINT(("COMMON_CMPL_Q_CONFIG(0x134)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_CMPL_Q_CONFIG)));
-	MV_DPRINT(("COMMON_CMPL_Q_ADDR(0x138)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_CMPL_Q_ADDR)));
-	MV_DPRINT(("COMMON_CMPL_Q_ADDR_HI(0x13C)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_CMPL_Q_ADDR_HI)));
-	MV_DPRINT(("COMMON_CMPL_Q_WR_PTR(0x140)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_CMPL_Q_WR_PTR)));
-	MV_DPRINT(("COMMON_CMPL_Q_RD_PTR(0x144)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_CMPL_Q_RD_PTR)));
-
-	MV_DPRINT(("COMMON_IRQ_STAT(0x150)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_IRQ_STAT)));
-	MV_DPRINT(("COMMON_IRQ_MASK(0x154)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_IRQ_MASK)));
-	MV_DPRINT(("COMMON_SRS_IRQ_STAT0(0x158)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_SRS_IRQ_STAT0)));
-	MV_DPRINT(("COMMON_SRS_IRQ_MASK0(0x15C)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_SRS_IRQ_MASK0)));
-	MV_DPRINT(("COMMON_SRS_IRQ_STAT1(0x160)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_SRS_IRQ_STAT1)));
-	MV_DPRINT(("COMMON_SRS_IRQ_MASK1(0x164)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_SRS_IRQ_MASK1)));
-	MV_DPRINT(("COMMON_NON_SPEC_NCQ_ERR0(0x168)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_NON_SPEC_NCQ_ERR0)));
-	MV_DPRINT(("COMMON_NON_SPEC_NCQ_ERR1(0x16C)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_NON_SPEC_NCQ_ERR1)));
-	MV_DPRINT(("COMMON_PORT_ALL_IRQ_STAT(0x1C0)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_PORT_ALL_IRQ_STAT)));
-	MV_DPRINT(("COMMON_PORT_ALL_PHY_CONTROL(0x1F0)=%08X.\n", MV_REG_READ_DWORD(mmio, COMMON_PORT_ALL_PHY_CONTROL)));
-
-	for (i = 0; i < 4; i++) {
-		MV_DPRINT(("phy %d READ_PORT_IRQ_STAT(0x%03X): 0x%08x\n", i, COMMON_PORT_IRQ_STAT0 + (i * 8), MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_IRQ_STAT0 + (i * 8))));
-		MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_VSR_ADDR0 + (i * 8), VSR_IRQ_STATUS);
-		MV_DPRINT(("phy %d VSR_IRQ_STATUS: 0x%08x\n", i, MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_VSR_DATA0 + (i * 8))));
-		MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_VSR_ADDR0 + (i * 8), VSR_PHY_CONFIG);
-		MV_DPRINT(("phy %d VSR_PHY_CONFIG: 0x%08x\n", i, MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_VSR_DATA0 + (i * 8))));
-		MV_REG_WRITE_DWORD(root->mmio_base, COMMON_PORT_VSR_ADDR0 + (i * 8), VSR_PHY_STATUS);
-		MV_DPRINT(("phy %d VSR_PHY_STATUS: 0x%08x\n", i, MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_VSR_DATA0 + (i * 8))));
-
-	}
-	for (i = 0; i < 4; i++) {
-		MV_DPRINT(("phy %d COMMON_PORT_IRQ_MASK0(0x%03X): 0x%08x\n", i, COMMON_PORT_IRQ_MASK0 + (i * 8), MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_IRQ_MASK0 + (i * 8))));
-	}
-
-	for (i = 0; i < 4; i++) {
-		MV_DPRINT(("phy %d COMMON_PORT_PHY_CONTROL0(0x%03X): 0x%08x\n", i, COMMON_PORT_PHY_CONTROL0 + (i * 4), MV_REG_READ_DWORD(root->mmio_base, COMMON_PORT_PHY_CONTROL0 + (i * 4))));
-	}
-}
-
-
-MV_VOID io_chip_init_registers(pl_root *root)
-{
-	MV_LPVOID mmio;
-	MV_U8 i,j;
-	MV_U32 tmp;
-	MV_U32 loop =0;
-	HBA_Info_Page hba_info_param;
-	MV_BOOLEAN hba_info_valid = MV_FALSE;
-	MV_U32 temp;
-	domain_phy *phy;
-	_MV_U64 u64_sas_addr;
-	MV_U8 def_sas_addr[8] = {0x50,0x05,0x04,0x30,0x11,0xab,0x00,0x00};
-	MV_U8 *sas_addr = (void*)&u64_sas_addr;
-	core_extension *core = (core_extension *)root->core;
-
-	def_sas_addr[7] = (MV_U8)root->base_phy_num;
-
-	MV_CopyMemory(sas_addr, def_sas_addr, sizeof(u64_sas_addr) );
-	mmio = root->mmio_base;
-	core_set_chip_options(root);
-
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CONFIG);
-	tmp |= CONFIG_SAS_SATA_RST;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CONFIG, tmp);
-	core_sleep_millisecond(core, 250);
-
-	/* fix 1.5G by pll */
-	if (core->revision_id == VANIR_A0_REV) {
-		MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_ADDR, 0x00000104);
-		MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_DATA, 0x00018080);
-	}
-	/* disable phy until sas address is set*/
-	MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_ADDR, VSR_PHY_CONFIG);
-	if (core->revision_id == VANIR_A0_REV || core->revision_id == VANIR_B0_REV)
-		/* set 6G/3G/1.5G, multiplexing, without SSC */
-		MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_DATA, 0x0084d4fe);
-	else
-		/* set 6G/3G/1.5G, multiplexing, with and without SSC */
-		MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_DATA, 0x0084fffe);
-
-	if (core->revision_id == VANIR_B0_REV) {
-		MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_ADDR,0x00000144);
-		MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_DATA,0x08001006);
-		MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_ADDR,0x000001b4);
-		MV_REG_WRITE_DWORD(mmio, COMMON_PORT_ALL_VSR_DATA,0x0000705f);
-	}
-
-	/* reset control */
-	MV_REG_WRITE_DWORD(mmio, COMMON_CONTROL, 0);
-
-	/* enable retry 127 times */
-        MV_REG_WRITE_DWORD(mmio, COMMON_CMD_ADDR, 0x128);
-        tmp = MV_REG_READ_DWORD(mmio, COMMON_CMD_DATA);
-        tmp &=~0xffff;
-        if ((core->revision_id == VANIR_A0_REV)
-                || (core->revision_id == VANIR_B0_REV)
-                || (core->revision_id == VANIR_C0_REV)) {
-                tmp |= 0x007f;
-        } else {
-                tmp |= 0x7f7f;
-        }
-        MV_REG_WRITE_DWORD(mmio, COMMON_CMD_DATA, tmp);
-
-	/* extend open frame timeout to max */
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_ADDR, 0x124);
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CMD_DATA);
-	tmp &=~0xffff;
-	tmp |=0x3fff;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_DATA, tmp);
-
-	/* multiplexing mark  b16 src_zone_grp, b8-14 open retry timer, b15 open retry enable*/
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_ADDR, 0x134);
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CMD_DATA);
-	tmp &=0xFFFF00FF;
-	tmp |=0x00028200;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_DATA, tmp);
-
-	/* set max connection time to 64 us*/
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_ADDR, 0x138);
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_DATA, 0x003f003f);
-
-	/* set WDTIMEOUT to 550 ms */
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_ADDR, 0x13c);
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_DATA, 0x7a0000); /* up with PLL */
-
-	/* not to halt for different port op during wideport link change */
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_ADDR, 0x1a4);
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_DATA, 0xffefbf7d);
-
-	if(mv_nvram_init_param(
-		HBA_GetModuleExtension((root->core), MODULE_HBA),
-		&hba_info_param)) {
-		hba_info_valid = MV_TRUE;
-	}
-
-	if (hba_info_valid) {
-		for (i = 0; i < root->phy_num; i++) {
-			phy = &root->phy[i];
-			temp = (MV_U32)(*(MV_PU32)&
-				hba_info_param.PHY_Tuning[root->base_phy_num+i]);
-			if (temp == 0xFFFFFFFFL){
-                                switch(core->revision_id) {
-				case VANIR_A0_REV:
-				case VANIR_B0_REV:
-				case VANIR_C0_REV:
-				case VANIR_C1_REV:
-				case VANIR_C2_REV:
-				default:
-				        hba_info_param.PHY_Tuning[root->base_phy_num+i].Trans_Emphasis_Amp = 0x6;
-				        hba_info_param.PHY_Tuning[root->base_phy_num+i].Trans_Amp = 0x1A;
-				        hba_info_param.PHY_Tuning[root->base_phy_num+i].Trans_Amp_Adjust = 0x3;
-				        break;
-				}
-			}
-
-			temp = (MV_U8)(*(MV_PU8)&
-				hba_info_param.FFE_Control[root->base_phy_num+i]);
-			if (temp == 0xFFL) {
-				switch(core->revision_id) {
-				case VANIR_C0_REV:
-				case VANIR_C1_REV:
-				case VANIR_C2_REV:
-					hba_info_param.FFE_Control[root->base_phy_num+i].FFE_Resistor_Select = 0x7;
-					hba_info_param.FFE_Control[root->base_phy_num+i].FFE_Capacitor_Select = 0xC;
-					break;
-				case VANIR_A0_REV:
-				case VANIR_B0_REV:
-				default:
-					hba_info_param.FFE_Control[root->base_phy_num+i].FFE_Resistor_Select = 0x7;
-					hba_info_param.FFE_Control[root->base_phy_num+i].FFE_Capacitor_Select = 0x7;
-					break;
-				}
-			}
-
-			temp = (MV_U8)(*(MV_PU8)&
-				hba_info_param.PHY_Rate[root->base_phy_num+i]);
-			if (temp == 0xFFL)
-				hba_info_param.PHY_Rate[root->base_phy_num+i] = 0x2; /*set default phy_rate = 6Gbps*/
-
-			set_phy_tuning( root, phy,
-				hba_info_param.PHY_Tuning[root->base_phy_num+i]);
-			set_phy_ffe_tuning(root, phy,
-				hba_info_param.FFE_Control[root->base_phy_num+i]);
-			set_phy_rate(root, phy,
-				hba_info_param.PHY_Rate[root->base_phy_num+i]);
-		}
-	}
-
-	for (i=0; i<root->phy_num; i++) {
-		phy = &root->phy[i];
-
-		/* Set Phy Id */
-		mv_set_dev_info(root, phy);
-
-		/* Set SAS Addr */
-		if (hba_info_valid) {
-			for (j=0; j<8; j++) {
-				sas_addr[j] = hba_info_param.SAS_Address[root->base_phy_num+i].b[j];
-			}
-		}
-		if ((U64_COMPARE_U32((*(MV_U64 *)sas_addr), 0) == 0) ||
-			(U64_COMP_U64(0xffffffffffffffffULL, (*(MV_U64 *)sas_addr)))) {
-			U64_ASSIGN((*(MV_U64 *)sas_addr), 0x0000ab1130040550ULL);
-		}
-		mv_set_sas_addr(root, phy, sas_addr);
-
-		if (core->revision_id == VANIR_A0_REV) {
-			WRITE_PORT_VSR_ADDR(root, phy, 0x000001b4);
-			WRITE_PORT_VSR_DATA(root, phy, 0x8300ffc1);
-		}
-
-		WRITE_PORT_VSR_ADDR(root, phy, VSR_PHY_CONFIG);
-		tmp = READ_PORT_VSR_DATA(root, phy);
-		tmp |= MV_BIT(0);
-		WRITE_PORT_VSR_DATA(root, phy, tmp & 0xfd7fffff); /* enable phy */
-
-		if (core->revision_id == VANIR_B0_REV) {
-			WRITE_PORT_VSR_ADDR(root, phy,0x00000144);
-			WRITE_PORT_VSR_DATA(root, phy,0x08001006);
-			WRITE_PORT_VSR_ADDR(root, phy,0x000001b4);
-			WRITE_PORT_VSR_DATA(root, phy,0x0000705f);
-		}
-	}
-
-       if (HBA_CheckIsFlorence(root->core))
-                core_sleep_millisecond(root->core, 400);
-       else
-                core_sleep_millisecond(root->core, 100);
-
-	for (i = 0; i < root->phy_num; i++) {
-		phy = &root->phy[i];
-
-		/* reset irq */
-		tmp = READ_PORT_IRQ_STAT(root, phy);
-		WRITE_PORT_IRQ_STAT(root, phy, tmp);
-
-		/* enable phy change interrupt and broadcast change */
-		tmp = IRQ_PHY_RDY_CHNG_MASK | IRQ_BRDCST_CHNG_RCVD_MASK |
-			IRQ_UNASSOC_FIS_RCVD_MASK | IRQ_SIG_FIS_RCVD_MASK |
-			IRQ_ASYNC_NTFCN_RCVD_MASK | IRQ_PHY_RDY_CHNG_1_TO_0;
-                phy->phy_irq_mask = tmp;
-		WRITE_PORT_IRQ_MASK(root, phy, tmp);
-
-	}
-
-	/* reset CMD queue */
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CONTROL);
-	tmp |= CONTROL_RESET_CMD_ISSUE;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CONTROL, tmp);
-
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CONFIG);
-	tmp |= CONFIG_CMD_TBL_BE | CONFIG_DATA_BE;
-	tmp &= ~CONFIG_OPEN_ADDR_BE;
-	tmp |= CONFIG_RSPNS_FRAME_BE;
-	tmp |= CONFIG_STP_STOP_ON_ERR;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CONFIG, tmp);
-	CORE_DPRINT(("COMMON_CONFIG (default) = 0x%x\n", tmp));
-
-	/* assign command list address */
-	MV_REG_WRITE_DWORD(mmio, COMMON_LST_ADDR, root->cmd_list_dma.parts.low);
-	MV_REG_WRITE_DWORD(mmio, COMMON_LST_ADDR_HI,
-		root->cmd_list_dma.parts.high);
-
-	/* assign FIS address */
-	MV_REG_WRITE_DWORD(mmio, COMMON_FIS_ADDR, root->rx_fis_dma.parts.low);
-	MV_REG_WRITE_DWORD(mmio, COMMON_FIS_ADDR_HI,
-		root->rx_fis_dma.parts.high);
-
-	/* assign delivery queue address */
-	tmp = 0;
-	MV_REG_WRITE_DWORD(mmio, COMMON_DELV_Q_CONFIG, tmp);
-	tmp = DELV_QUEUE_SIZE_MASK & root->delv_q_size;
-	tmp |= DELV_QUEUE_ENABLE;
-	MV_REG_WRITE_DWORD(mmio, COMMON_DELV_Q_CONFIG, tmp);
-	MV_REG_WRITE_DWORD(mmio, COMMON_DELV_Q_ADDR, root->delv_q_dma.parts.low);
-	MV_REG_WRITE_DWORD(mmio, COMMON_DELV_Q_ADDR_HI,
-		root->delv_q_dma.parts.high);
-
-	/* write in a default value for completion queue pointer in memory */
-	tmp = 0xFFF;
-	MV_CopyMemory( root->cmpl_wp, &tmp, 4 );
-
-	/* assign completion queue address */
-	tmp = 0;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMPL_Q_CONFIG, tmp);
-	tmp =  CMPL_QUEUE_SIZE_MASK & root->cmpl_q_size;
-	tmp |= CMPL_QUEUE_ENABLE;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMPL_Q_CONFIG, tmp);
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMPL_Q_ADDR, root->cmpl_wp_dma.parts.low);
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMPL_Q_ADDR_HI,
-		root->cmpl_wp_dma.parts.high);
-
-	if (hba_info_valid) {
-		if (hba_info_param.HBA_Flag & HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY) {
-			tmp = 0;
-			/* ((PREG_COMMON_COAL_CONFIG)&tmp)->INT_COAL_COUNT=1; */
-			if ( root->slot_count_support > 0x1ff )
-				tmp =  INT_COAL_COUNT_MASK & 0x1ff;
-			else
-				tmp =  INT_COAL_COUNT_MASK & root->slot_count_support;
-			tmp |= INT_COAL_ENABLE;
-
-			MV_REG_WRITE_DWORD(mmio, COMMON_COAL_CONFIG, tmp);
-			tmp = 0x10400;
-			MV_REG_WRITE_DWORD(mmio, COMMON_COAL_TIMEOUT, tmp);
-		} else {
-			tmp = 0;
-			if ( root->slot_count_support>0x1ff )
-				tmp =  INT_COAL_COUNT_MASK & 0x1ff;
-			else
-				tmp =  INT_COAL_COUNT_MASK & root->slot_count_support;
-			tmp |= INT_COAL_ENABLE;
-
-			MV_REG_WRITE_DWORD(mmio, COMMON_COAL_CONFIG, tmp);
-			tmp = 0x1000;
-			MV_REG_WRITE_DWORD(mmio, COMMON_COAL_TIMEOUT, tmp);
-		}
-	}
-
-	/* enable CMD/CMPL_Q/RESP mode */
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CONTROL);
-	tmp |= CONTROL_EN_CMD_ISSUE|CONTROL_EN_SATA_RETRY;
-
-	tmp |= CONTROL_FIS_RCV_EN;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CONTROL, tmp);
-
-	/* enable completion queue interrupt */
-	tmp = (INT_PORT_MASK | INT_CMD_CMPL );
-	tmp |= INT_NON_SPCFC_NCQ_ERR;
-	tmp |= INT_PHY_MASK;
-	root->comm_irq_mask = tmp;
-	MV_REG_WRITE_DWORD(mmio, COMMON_IRQ_MASK, tmp);
-
-	MV_REG_WRITE_DWORD(root->mmio_base,
-		COMMON_CMD_ADDR, CMD_PL_TIMER);
-        tmp = 0x003F003F;
-	MV_REG_WRITE_DWORD(root->mmio_base, COMMON_CMD_DATA, tmp);
-
-        /* extent SMP link timeout value to max to fix smp request waterdog timeout */
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_ADDR, CMD_LINK_TIMER);
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CMD_DATA);
-	tmp |= 0xFFFF0000;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_DATA, tmp);
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_ADDR, 0x1BC);
-	tmp = MV_REG_READ_DWORD(mmio, COMMON_CMD_DATA);
-	tmp |= 0x00000200;
-	MV_REG_WRITE_DWORD(mmio, COMMON_CMD_DATA, tmp);
-}
-
-void update_phy_info(pl_root *root, domain_phy *phy)
-{
-	MV_LPVOID mmio = root->mmio_base;
-	MV_U32 reg;
-
-	WRITE_PORT_VSR_ADDR(root, phy, VSR_PHY_STATUS);
-	reg = READ_PORT_VSR_DATA(root, phy);
-	reg = (MV_U8)((reg & VSR_PHY_STATUS_MASK) >> 16) & 0xff;
-	switch(reg)
-	{
-	case VSR_PHY_STATUS_SAS_RDY:
-		phy->type = PORT_TYPE_SAS;
-		break;
-	case VSR_PHY_STATUS_HR_RDY:
-	default:
-		phy->type = PORT_TYPE_SATA;
-		break;
-	}
-
-	WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ID_FRAME5);
-	reg = READ_PORT_CONFIG_DATA(root, phy);
-	phy->dev_info = (reg & 0xff) << 24; /* Phy ID */
-	WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ID_FRAME0);
-	reg = READ_PORT_CONFIG_DATA(root, phy);
-	/* 10000008 type(28..30), Target(16..19), Init(8..11) */
-	phy->dev_info |= ((reg & 0x70) >> 4) +
-		((reg & 0x0f000000) >> 8) +
-		((reg & 0x0f0000) >> 8);
-
-	WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ID_FRAME4);
-	phy->dev_sas_addr.parts.low =
-		CPU_TO_BIG_ENDIAN_32(READ_PORT_CONFIG_DATA(root, phy));
-
-	WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ID_FRAME3);
-	phy->dev_sas_addr.parts.high =
-		CPU_TO_BIG_ENDIAN_32(READ_PORT_CONFIG_DATA(root, phy));
-
-	phy->phy_status =
-		READ_PORT_PHY_CONTROL(root, phy);
-
-	if (phy->phy_status & SCTRL_PHY_READY_MASK)
-	{
-		if (phy->type & PORT_TYPE_SAS)
-		{
-			WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ATT_ID_FRAME5);
-			reg = READ_PORT_CONFIG_DATA(root, phy);
-			phy->att_dev_info = (reg & 0xff) << 24; /* phy id */
-
-			WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ATT_ID_FRAME0);
-			reg = READ_PORT_CONFIG_DATA(root, phy);
-			/* 10000008 type(28..30), Target(16..19), Init(8..11) */
-			phy->att_dev_info |= ((reg & 0x70) >> 4) +
-				((reg & 0x0f000000) >> 8) +
-				((reg & 0x0f0000) >> 8);
-
-			WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ATT_ID_FRAME4);
-			phy->att_dev_sas_addr.parts.low =
-				MV_BE32_TO_CPU(READ_PORT_CONFIG_DATA(root, phy));
-
-			WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_ATT_ID_FRAME3);
-			phy->att_dev_sas_addr.parts.high =
-				MV_BE32_TO_CPU(READ_PORT_CONFIG_DATA(root, phy));
-			/* SAS address is stored as BE, so ... */
-			phy->att_dev_sas_addr.parts.low = MV_CPU_TO_LE32(phy->att_dev_sas_addr.parts.low);
-			phy->att_dev_sas_addr.parts.high = MV_CPU_TO_LE32(phy->att_dev_sas_addr.parts.high);
-		} else {
-			phy->att_dev_info = 0;
-			phy->att_dev_sas_addr.parts.low = 0;
-			phy->att_dev_sas_addr.parts.high = 0;
-		}
-
-		WRITE_PORT_CONFIG_ADDR(root, phy, CONFIG_PHY_CONTROL);
-		WRITE_PORT_CONFIG_DATA(root, phy, 0x04);
-	}
-
-	phy->irq_status |= READ_PORT_IRQ_STAT(root, phy);
-
-	WRITE_PORT_VSR_ADDR(root, phy, VSR_IRQ_STATUS);
-	reg = READ_PORT_VSR_DATA(root, phy);
-	if (reg & VSR_IRQ_PHY_TIMEOUT) {
-		WRITE_PORT_VSR_DATA(root, phy, VSR_IRQ_PHY_TIMEOUT);
-		CORE_DPRINT(("Has VSR_IRQ_PHY TIMEOUT: %08X.\n",reg));
-		WRITE_PORT_VSR_ADDR(root, phy, VSR_PHY_STATUS);
-		reg = READ_PORT_VSR_DATA(root, phy);
-		reg = (MV_U8)((reg >> 16) & 0x3f);
-		CORE_EVENT_PRINT(("PHY State Machine Timeout. "\
-				  "PHY Status 0x%x.\n", reg));
-	}
-
-	CORE_EVENT_PRINT(("phy %d irq_status = 0x%x.\n", \
-		phy->id, phy->irq_status));
-}
-
-
-#define mv_enable_msi(_core)                                               \
-{                                                               \
-             MV_U32 temp;                                                  \
-             temp = MV_PCI_READ_DWORD(_core, MV_PCI_REG_CMD);        \
-             temp |= MV_PCI_INT_DIS;                                       \
-             MV_PCI_WRITE_DWORD(_core, temp, MV_PCI_REG_CMD);        \
-             temp = MV_PCI_READ_DWORD(_core, MV_PCI_REG_MSI_CTRL);   \
-             temp |= MV_PCI_MSI_EN;                                        \
-             MV_PCI_WRITE_DWORD(_core, temp, MV_PCI_REG_MSI_CTRL);  \
-}
-
-
-
-
-MV_VOID controller_init(core_extension *core)
-{
-	MV_LPVOID mmio = core->mmio_base;
-	MV_U32 tmp;
-
-	tmp = MV_PCI_READ_DWORD(core, MV_PCI_REG_CMD);
-	tmp |= MV_PCI_DEV_EN;
-	MV_PCI_WRITE_DWORD(core, tmp, MV_PCI_REG_CMD);
-
-	core->irq_mask = INT_MAP_SAS;
-       core->irq_mask |= INT_MAP_XOR;
-
-	if (msi_enabled(core))
-		mv_enable_msi(core);
-
-	MV_REG_WRITE_DWORD(mmio, CPU_MAIN_IRQ_MASK_REG, core->irq_mask);
-
-        /* clear PCIe error registers to 0 */
-        MV_REG_WRITE_DWORD(core->mmio_base, 0x14000, 0x2013);
-        MV_REG_WRITE_DWORD(core->mmio_base, 0x14004, 0xFFFF);
-        MV_REG_WRITE_DWORD(core->mmio_base, 0x14004, 0x0000);
-
-	if (IS_VANIR(core) || core->device_id == 0x948F) {
-		tmp = MV_PCI_READ_DWORD(core, MV_PCI_REG_DEV_CTRL);
-		if ((tmp & MV_PCI_RD_REQ_MASK) > MV_PCI_RD_REQ_SIZE) {
-			tmp &= ~MV_PCI_RD_REQ_MASK;
-			tmp |= MV_PCI_RD_REQ_SIZE;
-			MV_PCI_WRITE_DWORD(core, tmp, MV_PCI_REG_DEV_CTRL);
-		}
-	}
-}
-
-void core_set_cmd_header_selector(mv_command_header *cmd_header)
-{
-	cmd_header->interface_select = CS_INTRFC_CORE_DMA;
-}
-
-void map_phy_id(pl_root *root) {}
-
-MV_BOOLEAN core_reset_controller(core_extension *core){return MV_TRUE;}
-
-extern MV_BOOLEAN ses_state_machine( MV_PVOID enc_p );
-MV_VOID core_init_handlers(core_extension *core)
-{
-
-	core->handlers[HANDLER_SATA].init_handler = sata_device_state_machine;
-	core->handlers[HANDLER_SATA].verify_command = sata_verify_command;
-	core->handlers[HANDLER_SATA].prepare_command = sata_prepare_command;
-	core->handlers[HANDLER_SATA].send_command = sata_send_command;
-	core->handlers[HANDLER_SATA].process_command = sata_process_command;
-	core->handlers[HANDLER_SATA].error_handler = sata_error_handler;
-
-	core->handlers[HANDLER_SATA_PORT].init_handler = sata_port_state_machine;
-
-	core->handlers[HANDLER_PM].init_handler = pm_state_machine;
-	core->handlers[HANDLER_PM].verify_command = pm_verify_command;
-	core->handlers[HANDLER_PM].prepare_command = pm_prepare_command;
-	core->handlers[HANDLER_PM].send_command = pm_send_command;
-	core->handlers[HANDLER_PM].process_command = pm_process_command;
-	core->handlers[HANDLER_PM].error_handler = NULL;
-
-	core->handlers[HANDLER_SSP].init_handler = sas_init_state_machine;
-	core->handlers[HANDLER_SSP].verify_command = ssp_verify_command;
-	core->handlers[HANDLER_SSP].prepare_command = ssp_prepare_command;
-	core->handlers[HANDLER_SSP].send_command = ssp_send_command;
-	core->handlers[HANDLER_SSP].process_command = ssp_process_command;
-	core->handlers[HANDLER_SSP].error_handler = ssp_error_handler;
-
-	core->handlers[HANDLER_SMP].init_handler = exp_state_machine;
-	core->handlers[HANDLER_SMP].verify_command = smp_verify_command;
-	core->handlers[HANDLER_SMP].prepare_command = smp_prepare_command;
-	core->handlers[HANDLER_SMP].send_command = smp_send_command;
-	core->handlers[HANDLER_SMP].process_command = smp_process_command;
-	core->handlers[HANDLER_SMP].error_handler = NULL;
-
-	core->handlers[HANDLER_STP].init_handler = sata_device_state_machine;
-	core->handlers[HANDLER_STP].verify_command = sata_verify_command;
-	core->handlers[HANDLER_STP].prepare_command = stp_prepare_command;
-	core->handlers[HANDLER_STP].send_command = sata_send_command;
-	core->handlers[HANDLER_STP].process_command = stp_process_command;
-	core->handlers[HANDLER_STP].error_handler = sata_error_handler;
-
-	core->handlers[HANDLER_ENC].init_handler = ses_state_machine;
-	core->handlers[HANDLER_ENC].verify_command = ssp_verify_command;
-	core->handlers[HANDLER_ENC].prepare_command = ssp_prepare_command;
-	core->handlers[HANDLER_ENC].send_command = ssp_send_command;
-	core->handlers[HANDLER_ENC].process_command = ssp_process_command;
-	core->handlers[HANDLER_ENC].error_handler = NULL;
-
-	core->handlers[HANDLER_API].verify_command = api_verify_command;
-
-}
--- a/drivers/scsi/vanir/product/vanir/core_spi.c
+++ /dev/null
@@ -1,1096 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#include "core_header.h"
-#include "spi_hal.h"
-#include "core_spi.h"
-#include "core_util.h"
-
-static MV_U8           SPICmd[16];
-
-MV_U8   ATMEL_SPI_CMD[16] =
-{
-    0x06, 0x04, 0x05, 0x01, 0x03, 0x02, 0x52, 0x62, 0x15
-};
-MV_U8   MXIC_SPI_CMD[16] =
-{
-    0x06, 0x04, 0x05, 0x01, 0x03, 0x02, 0x20, 0x60, 0x90
-};
-MV_U8   WINBOND_SPI_CMD[16] =
-{
-    0x06, 0x04, 0x05, 0x01, 0x03, 0x02, 0xD8, 0xC7, 0xAB
-};
-
-MV_U8   ATMEL_SPI_CMD_41A_021[16] =
-{
-/* 0 		1	2	 3	   4      5 	    6	    7   	8      9      10       11*/
-    0x06, 0x04, 0x05, 0x01, 0x03, 0x02, 0xD8, 0x60, 0x9F, 0x36, 0x39, 0x3C
-};
-
-MV_U8	EON_F20_SPI_CMD[16] =
-{
-	0x06, 0x04, 0x05, 0x01, 0x03, 0x02, 0x20, 0x60, 0x90
-};
-
-MV_U8   SST_SPI_CMD[16] =
-{
-/* 0 		1	2	 3	   4      5 	    6	    7   	8      9      10       11 */
-    0x06, 0x04, 0x05, 0x01, 0x03, 0xAD,  0xD8 , 0xC7, 0xAB, 0x01, 0x50, 0x01
-};
-
-#if defined( SPIRegR32 )
-#undef SPIRegR32
-#endif
-#if defined( SPIRegW32 )
-#undef SPIRegW32
-#endif
-
-#define SPIRegR32       FMemR32
-#define SPIRegW32       FMemW32
-
-/**********************************************************************************/
-MV_U32
-SPI_Cmd
-(
-    MV_U8   cmd
-)
-{
-    if( cmd >= sizeof( SPICmd ) )
-        return -1;
-    return SPICmd[cmd];
-}
-/**********************************************************************************/
-int
-OdinSPI_WaitDataReady
-(
-    AdapterInfo *pAI,
-    MV_U32         timeout
-)
-{
-
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  i, dwTmp;
-
-    for( i=0; i<timeout; i++ ) {
-	dwTmp = SPIRegR32( BarAdr, ODIN_SPI_CTRL_REG );
-       if( !( dwTmp & SPI_CTRL_SpiStart ) ) {
-            return 0;
-       }
-       DelayUSec( 10 );
-    }
-    SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-
-    return -1;
-}
-
-
-
-
-int
-OdinSPI_WaitCmdIssued
-(
-    AdapterInfo *pAI
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  i, dwTmp;
-
-    for( i=0; i<3000; i++ ) {
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_CTRL_REG );
-		if( !( dwTmp & SPI_CTRL_SpiStart ) )
-        {
-            return 0;
-        }
-        DelayUSec( 20 );
-    }
-
-    return -1;
-}
-
-#define OdinSPI_BuildCmd SPI_BuildCmd
-
-int
-SPI_BuildCmd
-(
-	MV_PVOID	BarAdr,
-    MV_U32      *dwCmd,
-    MV_U8       cmd,
-    MV_U8       read,
-    MV_U8       length,
-    MV_U32      addr
-)
-
-{
-    MV_U32  dwTmp;
-
-    SPIRegW32( BarAdr, ODIN_SPI_CTRL_REG, 0 );
-    dwTmp = ( ( MV_U32 )cmd << 8 )|( (MV_U32)length << 4 );
-    if( read )
-    {
-        dwTmp|= SPI_CTRL_READ;
-    }
-    if (addr != MV_MAX_U32)
-	{
-		SPIRegW32( BarAdr, ODIN_SPI_ADDR_REG, ( addr & 0x0003FFFF ) );
-		dwTmp|=SPI_CTRL_AddrValid;
-	}
-
-	*dwCmd = dwTmp;
-    return 0;
-}
-
-int
-OdinSPI_IssueCmd
-(
-    AdapterInfo *pAI,
-    MV_U32      cmd
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    int     retry;
-
-    for( retry=0; retry<1; retry++ )
-    {
-        SPIRegW32( BarAdr, ODIN_SPI_CTRL_REG, cmd | SPI_CTRL_SpiStart );
-	}
-
-    return 0;
-}
-int
-OdinSPI_RDSR
-(
-    AdapterInfo *pAI,
-    MV_U8       *sr
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-				(MV_U8)SPI_Cmd( SPI_INS_RDSR ),
-                  1,
-                  1,
-                  -1 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-        dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-
-		*sr = (MV_U8)dwTmp;
-        return 0;
-    }
-    else
-    {
-        SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-    }
-    return -1;
-}
-
-
-int
-OdinSPI_EWSR
-(
-    AdapterInfo *pAI
-)
-{
-    MV_U32  dwTmp;
-	MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-
-
-		OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_UPTSEC ),
-                  0,
-                  0,
-                  -1 );
-
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 ==OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-		return 0;
-    }
-    SPI_DBG( ( "line: %d\n", __LINE__ ) );
-    return -1;
-}
-
-
-int
-OdinSPI_WRSR
-(
-    AdapterInfo *pAI
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32 dwTmp;
-    MV_U8 status=0xFF;
-
-    if (0!=OdinSPI_RDSR( pAI, &status ))
-        return -1;
-
-    if((status & 0x1C) == 0){
-		return 0;
-    }
-
-    if (0  !=OdinSPI_EWSR( pAI )){
-	SPI_DBG(("Can not enable write satatus.\n"));
-        return -1;
-    }
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_WRSR),
-                  0,
-                  1,
-                  -1);
-
-	SPIRegW32( BarAdr, ODIN_SPI_WR_DATA_REG, (MV_U32)(status & (~ 0x1C)));
-
-    OdinSPI_IssueCmd( pAI, dwTmp );
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-        return 0;
-    }
-    else
-    {
-        SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-    }
-    return -1;
-}
-
-
-
-
-
-int
-OdinSPI_PollSR
-(
-    AdapterInfo *pAI,
-    MV_U8       mask,
-    MV_U8       bit,
-    MV_U32      timeout
-)
-{
-    MV_U32  i;
-    MV_U8   sr;
-
-    for( i=0; i<timeout; i++ ) {
-        if( 0 == OdinSPI_RDSR( pAI, &sr ) )
-        {
-            if( ( sr & mask )==bit )
-                return 0;
-        }
-        else
-            SPI_DBG( ( "%d\n", __LINE__ ) );
-        DelayUSec( 20 );
-    }
-
-    SPI_DBG( ( "%d\n", __LINE__ ) );
-    return -1;
-}
-
-int
-OdinSPI_WREN
-(
-    AdapterInfo *pAI
-)
-{
-    MV_U32  dwTmp;
-	MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-
-		OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_WREN ),
-                  0,
-                  0,
-                  -1 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0!=OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-        return -1;
-    }
-    if( 0 == OdinSPI_PollSR( pAI, 0x03, 0x02, 300000 ) )
-    {
-        return 0;
-    }
-    SPI_DBG( ( "%d\n", __LINE__ ) );
-    return -1;
-}
-
-int
-OdinSPI_WRDI
-(
-    AdapterInfo *pAI
-)
-{
-    MV_U32 dwTmp;
-	MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-
-		OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_WRDI ),
-                  0,
-                  0,
-                  -1 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    OdinSPI_WaitDataReady( pAI, 10000 );
-    if( 0 == OdinSPI_PollSR( pAI, 0x03, 0, 300000 ) )
-    {
-        return 0;
-    }
-    SPI_DBG( ( "%d\n", __LINE__ ) );
-    return -1;
-}
-
-int
-OdinSPI_RDPT
-(
-    AdapterInfo *pAI,
-    MV_U32      addr,
-    MV_U8       *Data
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32   dwTmp;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_RDPT ),
-                  1,
-                  1,
-                  addr );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-		*Data = (MV_U8)dwTmp;
-        return 0;
-    }
-    else
-    {
-        SPI_DBG( ( " SPI_RDPT timeout\n"  ) );
-    }
-    return -1;
-}
-
-
-
-int
-OdinSPI_SectUnprotect
-(
-    AdapterInfo *pAI,
-    MV_U32      addr
-)
-{
-    MV_U32 dwTmp;
-    MV_U8 protect_sect=0xFF;
-	MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-
-    if(-1 ==OdinSPI_RDPT(pAI, addr, &protect_sect))
-    {
-	return -1;
-    }
-
-    if(protect_sect==0)
-	return 0;
-
-    if( -1 == OdinSPI_WREN( pAI ) )
-        return -1;
-
-		OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_UPTSEC),
-                  0,
-                  0,
-                  addr );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-    if( 0!=OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-        return -1;
-    }
-    if( 0 == OdinSPI_PollSR( pAI, 0x03, 0, 300000 ) )
-    {
-        return 0;
-    }
-    SPI_DBG( ( "error SPI_SectUnprotect \n" ) );
-    return -1;
-}
-
-int
-OdinSPI_SectErase
-(
-    AdapterInfo *pAI,
-    MV_U32      addr
-)
-{
-    MV_U32  dwTmp;
-	MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-
-    if(pAI->FlashID==SST25VF040B )
-    {
-      if(-1 == OdinSPI_WRSR(pAI))
-      {
-        SPI_DBG(("SPI_WRSR error.\n"));
-        return -1;
-      }
-    }
-
-    if( -1 == OdinSPI_WREN( pAI ) )
-        return -1;
-
-   if((pAI->FlashID==AT25DF041A) || (pAI->FlashID==AT25DF021)) {
-
-	   if(-1 == OdinSPI_SectUnprotect(pAI, addr))
-	   {
-			SPI_DBG(("Un protect error.\n"));
-			return -1;
-	    }
-   }
-
-		OdinSPI_BuildCmd( BarAdr, &dwTmp,
-	                  (MV_U8)SPI_Cmd( SPI_INS_SERASE ),
-                  0,
-                  0,
-                  addr );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-    if( 0!=OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-        return -1;
-    }
-    if( 0 == OdinSPI_PollSR( pAI, 0x03, 0, 300000 ) )
-    {
-        return 0;
-    }
-    SPI_DBG( ( "error OdinSPI_SectErase\n" ) );
-    return -1;
-}
-
-int
-OdinSPI_ChipErase
-(
-    AdapterInfo *pAI
-)
-{
-    MV_U32 dwTmp;
-	MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-
-    if( -1 == OdinSPI_WREN( pAI ) )
-        return -1;
-
-		OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_CERASE ),
-                  0,
-                  0,
-                  -1 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0!=OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-        return -1;
-    }
-    if( 0 == OdinSPI_PollSR( pAI, 0x03, 0, 300000 ) )
-    {
-        return 0;
-    }
-    SPI_DBG( ( "%d\n", __LINE__ ) );
-    return -1;
-}
-int
-OdinSPI_Write_autoinc
-(
-    AdapterInfo *pAI,
-    MV_I32      Addr,
-    MV_U16      Data,
-    MV_U32      Count
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp=0;
-
-    if (Count>4)
-        Count = 4;
-
-	SPIRegW32( BarAdr, ODIN_SPI_WR_DATA_REG, Data );
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_PROG ),
-                  0,
-                  (MV_U8)Count,
-                 Addr );
-
-    OdinSPI_IssueCmd( pAI, dwTmp );
-    if( 0 != OdinSPI_WaitDataReady( pAI, 10000  ) )
-    {
-        SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-        return -1;
-    }
-
-
-    if( 0 != OdinSPI_PollSR( pAI, 0x01, 0, 5000 ) )
-    {
-       SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-        return -1;
-    }
-
-    return 0;
-}
-
-
-int
-OdinSPI_Write_SST
-(
-    AdapterInfo *pAI,
-    MV_I32      Addr,
-    MV_U8*      Data,
-    MV_U32      Count
-)
-{
-	MV_U32 i=0;
-	MV_U16 dwTmp;
-
-	if (0  !=OdinSPI_WREN( pAI ))
-			return -1;
-
-	MV_CopyMemory( &dwTmp, &Data[0], 2);
-	if(OdinSPI_Write_autoinc(pAI, Addr, dwTmp, 2)){
-		SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-		return -1;
-	}
-
-	for(i=2; i<Count; i+=2){
-		MV_CopyMemory( &dwTmp, &Data[i], 2);
-		if(OdinSPI_Write_autoinc(pAI, -1L, dwTmp, 2)){
-			SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-			return -1;
-		}
-	}
-
-	if(0 != OdinSPI_WRDI(pAI)){
-		SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-		return -1;
-	}
-
-	return 0;
-
-
-}
-
-int
-OdinSPI_Write
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U32      Data
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp=0;
-    if(pAI->FlashID	==	SST25VF040B ){
-	return OdinSPI_Write_SST(pAI, Addr, (MV_U8 *)(&Data), 4);
-    }
-
-    OdinSPI_WREN( pAI );
-
-	SPIRegW32( BarAdr, ODIN_SPI_WR_DATA_REG, Data );
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_PROG ),
-                  0,
-                  4,
-                  Addr );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 != OdinSPI_WaitDataReady( pAI, 10000  ) )
-    {
-        SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-        return -1;
-    }
-    if( 0 == OdinSPI_PollSR( pAI, 0x01, 0, 5000 ) )
-    {
-        return 0;
-    }
-    SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-    return -1;
-}
-
-int
-OdinSPI_WriteBuf
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U8       *Data,
-    MV_U32      Count
-)
-{
-    MV_U32  i;
-
-    for( i=0; i<Count; i+=4 )
-    {
-        if( -1 == OdinSPI_Write( pAI, Addr + i, *(MV_U32*)&Data[i] ) )
-        {
-            SPI_DBG( ( "Write failed at %5.5x\n", Addr+i ) );
-            return -1;
-        }
-    }
-    return 0;
-}
-
-int
-OdinSPI_Read
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U8       *Data,
-    MV_U8       Size
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  i, dwTmp;
-
-    if( Size > 4 )
-        Size = 4;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)SPI_Cmd( SPI_INS_READ ),
-                  1,
-                  Size,
-                  Addr );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-
-		for( i=0; i<Size; i++ )
-        {
-            Data[i] = ((MV_U8*)&dwTmp)[i];
-        }
-        return 0;
-    }
-    else
-    {
-        SPI_DBG( ( "%d timeout\n", __LINE__ ) );
-    }
-    return -1;
-}
-
-int
-OdinSPI_ReadBuf
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U8       *Data,
-    MV_U32      Count
-)
-{
-    MV_U32      i, j;
-    MV_U32      tmpAddr, tmpData, AddrEnd;
-    MV_U8       *u8 = (MV_U8*)Data;
-
-    AddrEnd = Addr + Count;
-    tmpAddr = ALIGN( Addr, 4 );
-    j = ( Addr & ( MV_BIT( 2 ) - 1 ) );
-    if( j > 0 )
-    {
-        OdinSPI_Read( pAI, tmpAddr, (MV_U8*)&tmpData, 4 );
-
-        for( i=j; i<4; i++ )
-        {
-            *u8++ = ((MV_U8*)&tmpData)[i];
-        }
-
-        tmpAddr+= 4;
-    }
-    j = ALIGN( AddrEnd, 4 );
-    for(; tmpAddr < j; tmpAddr+=4 )
-    {
-        if (OdinSPI_Read(pAI, tmpAddr, (MV_U8*)&tmpData, 4) == -1) {
-            SPI_DBG( ( "Read failed at %5.5x\n", tmpAddr ) );
-            return -1;
-        }
-        *((MV_U32*)u8) = tmpData;
-        u8+= 4;
-    }
-    if( tmpAddr < AddrEnd )
-    {
-        OdinSPI_Read( pAI, tmpAddr, (MV_U8*)&tmpData, 4 );
-        Count = AddrEnd - tmpAddr;
-        for( i=0; i<Count; i++ )
-        {
-            *u8++ = ( (MV_U8*)&tmpData )[i];
-        }
-    }
-
-    return 0;
-}
-
-int
-OdinSPI_RMWBuf
-(
-    AdapterInfo *pAI,
-    MV_U32      Addr,
-    MV_U8       *Data,
-    MV_U32      Count,
-    MV_U8       *Buf
-)
-{
-MV_U32  tmpAddr;
-MV_U32  SecSize;
-MV_U32  i, StartOfSec;
-
-    SecSize = pAI->FlashSectSize;
-    tmpAddr = ALIGN( Addr, SecSize );
-    while( Count > 0 )
-    {
-        StartOfSec = ( Addr - tmpAddr );
-        if( ( StartOfSec>0 ) || ( Count<SecSize ) )
-            OdinSPI_ReadBuf( pAI, tmpAddr, Buf, SecSize );
-        if( 0!=OdinSPI_SectErase( pAI, tmpAddr ) )
-            return -1;
-        for( i=StartOfSec; Count>0 && i<SecSize; i++ )
-        {
-            Buf[i] = *Data++;
-            Count--;
-        }
-        if( 0!=OdinSPI_WriteBuf( pAI, tmpAddr, Buf, SecSize ) )
-            return -1;
-        Addr+= (SecSize - StartOfSec);
-        tmpAddr+= SecSize;
-    }
-
-    return 0;
-}
-
-int
-OdinSPI_SSTIdentify
-(
-    AdapterInfo *pAI
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp=0;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  SST_SPI_CMD[SPI_INS_RDID],
-                  1,
-                  2,
-                  0 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-
-        switch( dwTmp )
-        {
-            case 0x8DBF:
-               pAI->FlashID = SST25VF040B;
-                pAI->FlashSize = 256L * 1024;
-                pAI->FlashSectSize = 64L * 1024;
-                return 0;
-        }
-    }
-
-    return -1;
-}
-
-
-int
-OdinSPI_AtmelIdentify
-(
-    AdapterInfo *pAI
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  ATMEL_SPI_CMD[SPI_INS_RDID],
-                  1,
-                  2,
-                  0 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-
-		switch( dwTmp )
-        {
-            case 0x631f:
-                pAI->FlashID = AT25F2048;
-                pAI->FlashSize = 256L * 1024;
-                pAI->FlashSectSize = 64L * 1024;
-                return 0;
-        }
-    }
-
-    return -1;
-}
-
-int
-OdinSPI_AtmelIdentify_41A_021
-(
-    AdapterInfo *pAI
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  (MV_U8)ATMEL_SPI_CMD_41A_021[SPI_INS_RDID],
-                  1,
-                  2,
-                  -1 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-
-		switch( dwTmp )
-       {
-            case 0x441f:
-                pAI->FlashID = AT25DF041A;
-                pAI->FlashSize = 256L * 1024;
-                pAI->FlashSectSize = 64L * 1024;
-		    return 0;
-            case 0x431f:
-                pAI->FlashID = AT25DF021;
-                pAI->FlashSize = 256L * 1024;
-                pAI->FlashSectSize = 64L * 1024;
-				return 0;
-		case 0x9d7f:
-			pAI->FlashID = PM25LD010;
-                pAI->FlashSize = 256L * 1024;
-                pAI->FlashSectSize = 64L * 1024;
-                return 0;
-        }
-    }
-
-    return -1;
-}
-
-int
-OdinSPI_WinbondIdentify
-(
-    AdapterInfo *pAI
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  WINBOND_SPI_CMD[SPI_INS_RDID],
-                  1,
-                  2,
-                  0 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-
-		switch( dwTmp )
-        {
-            case 0x1212:
-                pAI->FlashID = W25X40;
-                pAI->FlashSize = 256L * 1024;
-                pAI->FlashSectSize = 64L * 1024;
-                return 0;
-        }
-    }
-
-    return -1;
-}
-
-int
-OdinSPI_MxicIdentify
-(
-    AdapterInfo *pAI
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  MXIC_SPI_CMD[SPI_INS_RDID],
-                  1,
-                  2,
-                  0 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-		switch( dwTmp )
-        {
-            case 0x11C2:
-                pAI->FlashID = MX25L2005;
-                pAI->FlashSize = 256L * 1024;
-                pAI->FlashSectSize = 4L * 1024;
-                return 0;
-        }
-    }
-
-    return -1;
-}
-
-int
-OdinSPI_EONIdentify_F20
-(
-	AdapterInfo *pAI
-)
-{
-    MV_PVOID  BarAdr = pAI->bar[FLASH_BAR_NUMBER];
-    MV_U32  dwTmp;
-
-	OdinSPI_BuildCmd( BarAdr, &dwTmp,
-                  EON_F20_SPI_CMD[SPI_INS_RDID],
-                  1,
-                  2,
-                  0 );
-    OdinSPI_IssueCmd( pAI, dwTmp );
-
-    if( 0 == OdinSPI_WaitDataReady( pAI, 10000 ) )
-    {
-
-		dwTmp = SPIRegR32( BarAdr, ODIN_SPI_RD_DATA_REG );
-
-		switch( dwTmp )
-        {
-            case 0x111C:
-                pAI->FlashID = EN25F20;
-                pAI->FlashSize = 256L * 1024;
-                pAI->FlashSectSize = 4L * 1024;
-                return 0;
-        }
-    }
-
-    return -1;
-
-}
-
-int
-OdinSPI_Init
-(
-    AdapterInfo *pAI
-)
-{
-    MV_U32  i;
-    MV_U8   *pSPIVendor;
-
-    pSPIVendor = NULL;
-    if( 0 == OdinSPI_AtmelIdentify( pAI ) )
-    {
-        pSPIVendor = ATMEL_SPI_CMD;
-    }
-    else if( 0 == OdinSPI_MxicIdentify( pAI ) )
-    {
-        pSPIVendor = MXIC_SPI_CMD;
-    }
-	else if ( 0 == OdinSPI_AtmelIdentify_41A_021( pAI) ) {
-		  pSPIVendor = ATMEL_SPI_CMD_41A_021;
-	}
-	else if( 0 == OdinSPI_WinbondIdentify( pAI ) )
-	{
-		pSPIVendor = WINBOND_SPI_CMD;
-	}
-	else if( 0 == OdinSPI_SSTIdentify( pAI ) )
-	{
-		pSPIVendor = SST_SPI_CMD;
-	}
-	else if( 0 == OdinSPI_EONIdentify_F20( pAI ) )
-	{
-		pSPIVendor = EON_F20_SPI_CMD;
-	}
-	else
-	{
-		pSPIVendor = ATMEL_SPI_CMD;
-	}
-
-    if( pSPIVendor )
-    {
-        for( i=0; i<sizeof( SPICmd ); i++ )
-        {
-            SPICmd[i] = pSPIVendor[i];
-        }
-        return 0;
-    }
-
-    return -1;
-}
-
-int
-InitHBAInfo
-(
-    HBA_Info_Main *pHBAInfo
-)
-{
-    int i;
-    MV_U8 *pU8;
-
-    pU8 = (MV_U8*)pHBAInfo;
-    for( i=0; i<sizeof( HBA_Info_Main ); i++ )
-        pU8[i] = 0xFF;
-    MV_CopyMemory( pHBAInfo->signature, "MRVL", 4 );
-
-    return 0;
-}
-
-int
-GetHBAInfoChksum
-(
-    HBA_Info_Main *pHBAInfo
-)
-{
-    MV_U32  i;
-    MV_U8   *pU8, cs;
-
-    cs = 0;
-
-    pU8 = (MV_U8*)pHBAInfo;
-    for( i=0; i<sizeof( HBA_Info_Main ); i++ )
-    {
-        cs+= pU8[i];
-    }
-    return cs;
-}
-
-int
-LoadHBAInfo
-(
-    AdapterInfo *pAI,
-    HBA_Info_Main *pHBAInfo
-)
-{
-    if( 0!=OdinSPI_ReadBuf( pAI,
-                            pAI->FlashSize-sizeof( HBA_Info_Main ),
-                            (MV_U8*)pHBAInfo,
-                            sizeof( HBA_Info_Main ) ) )
-    {
-        return -1;
-    }
-    if( 0!=GetHBAInfoChksum( pHBAInfo ) )
-    {
-        InitHBAInfo( pHBAInfo );
-        return -1;
-    }
-    return 0;
-}
--- a/drivers/scsi/vanir/product/vanir/mv_product_vanir.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// ============================================================================
-//
-//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
-//
-//  This computer program contains confidential and proprietary information,
-//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
-//  form,  or by any means electronic, mechanical, photo-optical, or  other-
-//  wise, and  may NOT  be translated  into  another  language  without  the
-//  express written permission from Marvell Corporation.
-//
-// ============================================================================
-// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
-// ============================================================================
-#ifndef __MV_PRODUCT_VANIR_H__
-#define __MV_PRODUCT_VANIR_H__
-
-#define TRASH_BUCKET_SIZE 0x400  // 1k
-
-/* driver capabilities */
-#define MAX_BASE_ADDRESS                6
-#define MV_MAX_TRANSFER_SIZE            (4*1024*1024)
-#define MAX_SG_ENTRY                    130
-#define MAX_SG_ENTRY_REDUCED            16
-#define MV_MAX_PHYSICAL_BREAK           (MAX_SG_ENTRY - 1)
-
-#define MAX_REQUEST_NUMBER_PERFORMANCE	    4096
-#define MAX_REQUEST_PER_LUN_PERFORMANCE		128
-#define MV_MAX_TARGET_NUMBER            128
-#define MAX_EXPANDER_SUPPORTED		      10
-
-/* hardware capabilities */
-#define MAX_PM_SUPPORTED                      8
-#define MAX_BLOCK_PER_HD_SUPPORTED            8
-#define MAX_DEVICE_SUPPORTED_WHQL             8
-#define MAX_DEVICE_SUPPORTED_PERFORMANCE      MV_MAX_TARGET_NUMBER
-#define MAX_DEVICE_SUPPORTED_RAID             64
-
-#endif/*__MV_PRODUCT_VANIR_H__*/
--- a/drivers/scsi/vanir/readme
+++ /dev/null
@@ -1,130 +0,0 @@
-   Marvell 61xx/64xx Controller Linux Open Source Driver
- ---------------------------------------------------------
-
-1. Introduction
-2. Build driver
-3. Build the driver into kernel
-4. Note
----------------------------------------
-
-1. Introduction
----------------
-
-    This is the partial linux kernel driver source code for Marvell SATA
-controllers. Current version of the source only supports 2.6 kernel.
-
-
-2. Build driver
----------------
-
-    2.1 Make sure kernel source/headers is ready.
-
-        Depending on your need, you may want to build a driver for the running
-    kernel of your host machine, or you might want to build drivers for other
-    versions of kernel. In both cases, you should have the source code of the
-    kernel installed. For example, you should launch yast and install the
-    'kernel-source' package if you're using SuSE Linux (including SLED/SLES ).
-
-        To build the module, you also should know where the kernel source is.
-    For SuSE Linux and Red Hat, the source to the running kernel can be found
-    at /lib/modules/`uname -r`/build. If you want to build driver for a
-    customized kernel, make sure your user account have the access to the
-    source.
-
-    2.2 Build the driver
-
-	If you're building driver for a kernel other than the running one, you
-    should let driver source know the path to the kernel source before issuing
-    make. You have two ways of issuing make command:
-
-        1) Set the shell environment variable 'KERNEL_SRC' to the path to
-           kernel source for which you want to build the driver. Suppose the
-           source is located at /usr/src/linux, then execute the following
-           command:
-
-            # export KERNEL_SRC=/usr/src/linux
-            # make
-
-        2) Specify the KERNEL_SRC in the invocation of make command:
-
-            # make KERNEL_SRC=/usr/src/linux
-
-           Watching the sources being compiled, and when it stops, you're done.
-
-        Note :
-           Make sure the kernel source is properly prepared for external module
-           building. Execute 'make modules_prepare' in the kernel source
-	   directory if you haven't done so.
-
-    2.3 Install the driver.
-
-        If the module is named as mv61xx.ko,to install the driver, you type:
-
-            # insmod mv61xx.ko
-
-        If the module is named as mv64xx.ko,to install the driver, you type:
-
-				# insmod mv64xx.ko
-
-3. Build the driver into kernel
--------------------------------
-
-    3.1 Make sure you have the complete kernel source installed.
-
-        To patch a kernel tree, you'll need the complete source to the linux
-    kernel. Also you'll need to verify that you have the write permission on
-    the source directory.
-
-
-    3.2 Patch the source.
-
-        Change working directory to the driver source code, type:*
-	     # export KERNEL_SRC=/usr/src/linux
-            # make $KERNEL_SRC kbuild
-
-        You should substitute '/usr/src/linux' with the absolute path to the
-        kernel source directory.
-
-        You can always rewind the patch by using the following command:
-
-				# make $KERNEL_SRC ukbuild
-
-    3.3 Build the kernel
-
-        Now you can start kernel configuration process, follow the normal kernel
-    building process, which varies on different linux distributions and is not
-    covered here. then you can configure the driver into kernel during the
-    kernel configuration process (e.g. "make menuconfig").
-
-        Below is an example to make and install a kernel with the driver built-in:
-		# export KERNEL_SRC=/usr/src/linux
-        # cd /usr/src/linux
-        # make mrproper
-        # make menuconfig
-
-        Select "Device Drivers --->" and press enter.
-        Select "SCSI device support", then press 'Y' to make it built-in.
-        Select "SCSI disk support" then press 'Y' to make it build-in.
-        Select "SCSI low-level drivers --->" and press enter.
-
-        Select "Marvell Storage Controller 9180/9480" and press 'Y'.
-        or
-        Select "Marvell Storage Controller 6320/6340/6440/6450/6480" and press 'Y'.
-
-        Exit and save the kernel configuration.
-        # make dep
-				# make clean
-				# make bzImage
-				# make modules
-        # make modules_install
-        # make install
-
-        Now mv94xx/mv64xx driver will be built into kernel image. Note that
-    mv94xx/mv64xx driver depends on SCSI and SCSI disk support, so you should
-    also build them as part of the kernel ( not as modules ). Then you can
-    reboot from the new kernel.
-
-4. Note
--------
-
-* We've tested the patch successfully against kernel 2.6.16 and upward.
--- a/drivers/scsi/vanir/readme.arm
+++ /dev/null
@@ -1,32 +0,0 @@
-Marvell mv94xx driver for ARMADAXP
-
-========================================================================================
-
-1. Module-mode
-1) Modify driver's Makefile, change kernel source directory to current kernel source path.
-   Makefile:
-	ifeq ("arm", "$(ARCH)")
-		KERNEL_SRC=xxxx   eg:/root/armadaxp/linux-2.6.35.9
-	endif
-2) Cross-compile driver
-	a) Add "xxx/cross/bin" path to $PATH
-	b) Build driver mv94xx.ko by running "make ARCH=arm CROSS_COMPILE=arm-mv7-linux-gnueabi-"
-3) Copy mv94xx.ko to armadapxp os and run "insmod mv94xx.ko" to load the driver.
-
-
-2. Build-in-kernel-mode
-
-1) Patch mv94xx driver to kernel
-	a) Add "xxx/cross/bin" path to $PATH, "export ARCH=arm", "export CROSS_COMPILE=arm-mv7-linux-gnueabi-"
-	b) Under mv94xx driver source code directory, run "make kbuild".
-
-2) Re-build kernel image
-	a) cd to kernel directory. run make menuconfig, select "Device Drivers -->SCSI device support
-	   --> SCSI low-level drivers-->Marvell Storage Controller 9180/9480"
-	b) make uImage
-
-3) Load and boot from the kernel image, mv94xx driver will be loaded automatically.
-
-4) Notes:
-	a) If boot with mv94xx driver built-in and devices attached, the OS drive's partition won't be /dev/sda1, then we need change "boot_args_root" value under uboot command line.
-	b) It also supports to boot from the OS drive attached on Marvell mv94xx controller.
--- a/drivers/scsi/vanir/readme.vmware
+++ /dev/null
@@ -1,13 +0,0 @@
-This driver is for vmware ESX4.0, use VMware ESX4.0 DDK to build the driver.
-Two build script files for build the driver.
-build_esx4_raid is for raid driver.
-build_esx4_no_raid is for none raid driver.
-please copy all the code to following folder before compiling the code.
-/opt/vmware/ddk/src/vmkdrivers/src26/drivers/scsi/mv94xx
-please use correct CLI tool to work with this driver, and CLI tool should be
-built under 64bit Linux OS, and then work at vmware system.
-
-unresolved issue:
-1. SCSI device can not be removed from host with hot plug out and delete raid,
-   reboot is needed after raid creation and removing.
-2. Dual card are not supported yet for raid driver, especially with create/delete raid.
