From 331d3f34e9db3baa8855fbf10dda5beec266f695 Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Tue, 16 Oct 2012 18:23:57 +0200
Subject: [PATCH 407/609] - Updated mv_hal/neta* and relevant interfaces to
 latest shared version

Change-Id: I4f3c0103020e2cde8ec4915563e9af26828b7892

Signed-off-by: Seif Mazareeb <seif@marvell.com>
---
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c |    4 +-
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.c       | 2784 --------------------
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.h       | 1143 --------
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpBridge.c |  728 -----
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpCt.c     | 1514 -----------
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h   |  223 --
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFdb.c    |  309 ---
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFib.c    |  718 -----
 arch/arm/plat-armada/mv_hal/neta/pnc/mvPncRxq.c    |  412 +++
 9 files changed, 415 insertions(+), 7420 deletions(-)
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/neta/bm/mvBm.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/neta/bm/mvBm.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/neta/bm/mvBmRegs.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/neta/gbe/mvEthRegs.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/neta/gbe/mvHwf.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpBridge.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpCt.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFdb.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFib.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/neta/pmt/mvPmt.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/neta/pmt/mvPmt.h
 create mode 100755 arch/arm/plat-armada/mv_hal/neta/pnc/mvPncRxq.c

--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c
@@ -82,6 +82,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "bm/mvBm.h"
 #include "pnc/mvTcam.h"
 
+#define KERN_INFO
+
 static void mvEthRegPrint(MV_U32 reg_addr, char *reg_name)
 {
 	mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", reg_name, reg_addr, MV_REG_READ(reg_addr));
@@ -784,7 +786,7 @@ void mvNetaCpuDump(int port, int cpu, in
 			mvOsPrintf("       ");
 	regVal >>= 1;
 	}
-	mvOsPrintf("\n");
+		mvOsPrintf(KERN_INFO "\n");
 }
 
 #ifdef CONFIG_MV_PON
--- a/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.c
+++ /dev/null
@@ -1,2784 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-/*******************************************************************************
-* mvNfp.c - Marvell Network Fast Processing
-*
-* DESCRIPTION:
-*
-*       Supported Features:
-*       - OS independent.
-*
-*******************************************************************************/
-
-/* includes */
-#include "mvOs.h"
-#include "mv802_3.h"
-#include "mvDebug.h"
-#include "gbe/mvEthRegs.h"
-#include "gbe/mvNetaRegs.h"
-#include "gbe/mvNeta.h"
-#include "mvNfp.h"
-
-/* Set Debug Level */
-MV_U32 nfpDebugLevel;
-
-MV_U32 nfp_ports[NFP_MAX_PORTS];
-
-NFP_IF_MAP *nfp_if_map[NFP_DEV_HASH_SZ];
-NFP_IF_MAP *nfp_if_real_map[NFP_MAX_PORTS][NFP_MAX_SWITCH_GROUPS];
-
-unsigned int nfp_jhash_iv;
-
-#if (CONFIG_MV_ETH_NFP_DEF == 0)
-static int nfpMode = MV_NFP_DISABLED;
-#else
-static int nfpMode = CONFIG_MV_ETH_NFP_MODE_DEF;
-#endif
-static int nfpFreeExtPort = MV_ETH_MAX_PORTS;
-static NFP_STATS nfp_stats[NFP_MAX_PORTS];
-
-#ifdef NFP_CLASSIFY
-MV_NFP_CLASSIFY_MODE classifyMode[MV_NFP_CLASSIFY_FEATURES];
-MV_NFP_CLASSIFY_POLICY exactPolicy[MV_NFP_CLASSIFY_FEATURES];
-MV_NFP_CLASSIFY_POLICY prioPolicy = MV_NFP_CLASSIFY_POLICY_HIGHEST;
-#endif /* NFP_CLASSIFY */
-
-#ifdef NFP_STAT
-#define NFP_INC(p, s) nfp_stats[p].s++;
-#else
-#define NFP_INC(p, s)
-#endif
-
-/*
- * Init
- */
-MV_VOID _INIT mvNfpInit(MV_VOID)
-{
-	int i;
-
-	mvOsMemset(nfp_ports, 0, sizeof(MV_U32) * NFP_MAX_PORTS);
-	mvOsMemset(nfp_stats, 0, sizeof(NFP_STATS) * NFP_MAX_PORTS);
-	mvOsMemset(nfp_if_real_map, 0, sizeof(nfp_if_real_map));
-	mvOsMemset(nfp_if_map, 0, sizeof(nfp_if_map));
-	nfpDebugLevel = NFP_WARN_PRINT; /* Note: can also be (NFP_DBG_PRINT | NFP_WARN_PRINT) */
-
-#ifdef NFP_CLASSIFY
-	for (i = 0; i < MV_NFP_CLASSIFY_FEATURES; i++) {
-		classifyMode[i] = MV_NFP_CLASSIFY_MODE_DISABLED;
-		exactPolicy[i] = MV_NFP_CLASSIFY_POLICY_HIGHEST;
-	}
-#endif /* NFP_CLASSIFY */
-}
-
-MV_VOID   mvNfpModeSet(int mode)
-{
-	nfpMode = mode;
-}
-
-MV_U32 mvNfpPortCapGet(MV_U32 port)
-{
-	return nfp_ports[port];
-}
-
-MV_VOID mvNfpDebugLevelSet(int dbgLevelFlags)
-{
-	nfpDebugLevel = dbgLevelFlags;
-}
-
-static INLINE int needFragment(MV_IP_HEADER_INFO *pIpInfo, NFP_IF_MAP *pOutIf)
-{
-	return (pIpInfo->ipLen > pOutIf->mtu);
-}
-
-/* Update packet's MAC header, including Marvell Header, DA and SA */
-static INLINE void mvNfpFibMacUpdate(MV_U8 *pData, NFP_RULE_FIB *pFib)
-{
-	*(MV_U32 *) (pData + 0) = *(MV_U32 *) (&pFib->mh);
-	*(MV_U32 *) (pData + 4) = *(MV_U32 *) (&pFib->da[2]);
-	*(MV_U32 *) (pData + 8) = *(MV_U32 *) (&pFib->sa[0]);
-	*(MV_U16 *) (pData + 12) = *(MV_U16 *) (&pFib->sa[4]);
-}
-
-/* Update packet's IPv4 Header (decrement TTL field) */
-static INLINE void mvNfpFibIpUpdate(MV_IP_HEADER_INFO *pIpInfo)
-{
-	if (pIpInfo->family == MV_INET)
-		pIpInfo->ip_hdr.ip4->ttl--;
-	else
-		pIpInfo->ip_hdr.ip6->hoplimit--;
-}
-
-#ifdef NFP_CLASSIFY
-static INLINE MV_VOID mvNfpClassifyInit(NFP_CLASSIFY_INFO *info)
-{
-	info->flags = 0;
-	info->pkt_vlan_prio = NFP_INVALID_VPRIO;
-	info->bridge_vlan_prio = NFP_INVALID_VPRIO;
-	info->ct_vlan_prio = NFP_INVALID_VPRIO;
-	info->pkt_dscp = NFP_INVALID_DSCP;
-	info->ct_dscp = NFP_INVALID_DSCP;
-	info->iif_prio = NFP_PRIO_INVALID;
-	info->iif_vlan_prio = NFP_PRIO_INVALID;
-	info->iif_dscp_prio = NFP_PRIO_INVALID;
-}
-
-static INLINE MV_VOID mvNfpVpriPktClassifySave(MV_U16 vlanId, NFP_CLASSIFY_INFO *info)
-{
-	info->pkt_vlan_prio = (vlanId >> 13); /* save 3 MSBits in VLAN ID */
-}
-
-static INLINE MV_VOID mvNfpVpriBridgeClassifySave(MV_U8 *pData, NFP_RULE_BRIDGE	*bridgeRule, NFP_CLASSIFY_INFO *info)
-{
-	int i;
-	MV_U16 eth_type;
-
-	if (info->pkt_vlan_prio != NFP_INVALID_VPRIO)
-		eth_type = MV_16BIT_BE(*(MV_U16 *)(pData + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE +
-							   MV_MAC_ADDR_SIZE + MV_VLAN_HLEN));
-	else
-		eth_type = MV_16BIT_BE(*(MV_U16 *)(pData + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE));
-
-	for (i = 0; i < NFP_VPRI_MAP_GLOBAL; i++) {
-		if ((bridgeRule->vpri_map[i].eth_type == eth_type) && bridgeRule->vpri_map[i].valid) {
-			info->bridge_vlan_prio = bridgeRule->vpri_map[i].new_prio;
-			info->flags |= NFP_F_SET_EXACT_VLAN_PRIO;
-			info->flags |= NFP_F_SET_VLAN_PRIO;
-			return;
-		}
-	}
-	if (bridgeRule->vpri_map[NFP_VPRI_MAP_GLOBAL].valid) {
-		info->bridge_vlan_prio = bridgeRule->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio;
-		info->flags |= NFP_F_SET_EXACT_VLAN_PRIO;
-		info->flags |= NFP_F_SET_VLAN_PRIO;
-	}
-}
-
-#ifdef NFP_CT
-static INLINE MV_VOID mvNfpPktDscpClassifySave(MV_IP_HEADER_INFO *pIpHdr, NFP_CLASSIFY_INFO *info)
-{
-		MV_IP6_HEADER *pIp6Hdr = pIpHdr->ip_hdr.ip6;
-		MV_IP_HEADER *pIph = pIpHdr->ip_hdr.ip4;
-		MV_U8 *pIp6 = (char *)pIp6Hdr;
-
-		/* First get the packet's original DSCP */
-		if (pIpHdr->family == MV_INET) {
-			/* 6 MSBits of the TOS field are DSCP, 2 LSBits are ECN */
-			info->pkt_dscp = ((pIph->tos) >> 2);
-			info->pkt_ecn = (pIph->tos & 0x3);
-		} else {
-			/* TC field is divided on the first 2 bytes of IPv6 header */
-			info->pkt_dscp = (((*pIp6 & 0xF) << 4) | (*(pIp6 + 1) >> 6));
-			info->pkt_ecn = ((*(pIp6 + 1) >> 4) & 0x3);
-		}
-}
-
-static INLINE MV_VOID mvNfpDscpClassifySave(NFP_RULE_CT *pCt, NFP_CLASSIFY_INFO *info)
-{
-		/* Now get the DSCP value from the 5 tuple rule */
-		if (pCt->dscp_map[info->pkt_dscp].valid) {
-			info->ct_dscp = pCt->dscp_map[info->pkt_dscp].new_dscp;
-			info->flags |= NFP_F_SET_EXACT_DSCP;
-			info->flags |= NFP_F_SET_DSCP;
-		} else if (pCt->dscp_map[NFP_DSCP_MAP_GLOBAL].valid) {
-			info->ct_dscp = pCt->dscp_map[NFP_DSCP_MAP_GLOBAL].new_dscp;
-			info->flags |= NFP_F_SET_EXACT_DSCP;
-			info->flags |= NFP_F_SET_DSCP;
-		}
-}
-
-static INLINE MV_VOID mvNfpVpriCtClassifySave(NFP_RULE_CT *pCt, NFP_CLASSIFY_INFO *info)
-{
-	if (info->pkt_vlan_prio != NFP_INVALID_VPRIO) {
-		if (pCt->vpri_map[info->pkt_vlan_prio].valid) {
-			info->ct_vlan_prio = pCt->vpri_map[info->pkt_vlan_prio].new_prio;
-			info->flags |= NFP_F_SET_EXACT_VLAN_PRIO;
-			info->flags |= NFP_F_SET_VLAN_PRIO;
-			return;
-		}
-	}
-	if (pCt->vpri_map[NFP_VPRI_MAP_GLOBAL].valid) {
-		info->ct_vlan_prio = pCt->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio;
-		info->flags |= NFP_F_SET_EXACT_VLAN_PRIO;
-		info->flags |= NFP_F_SET_VLAN_PRIO;
-	}
-}
-#endif /* NFP_CT */
-
-static INLINE MV_VOID mvNfpTxqClassifySave(int txq, NFP_CLASSIFY_INFO *info)
-{
-	if (info->flags & NFP_F_SET_EXACT_TXQ) {
-		/* update info->txq according to policy */
-		switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_TXQ]) {
-		case MV_NFP_CLASSIFY_POLICY_FIRST:
-			/* do nothing - this is not the first time this function was called */
-			break;
-		case MV_NFP_CLASSIFY_POLICY_LAST:
-			info->txq = txq;
-			break;
-		case MV_NFP_CLASSIFY_POLICY_HIGHEST:
-			if (txq > info->txq)
-				info->txq = txq;
-			break;
-		case MV_NFP_CLASSIFY_POLICY_LOWEST:
-			if (txq < info->txq)
-				info->txq = txq;
-			break;
-		default:
-			NFP_WARN("%s: unknown txq policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_TXQ]);
-			return;
-		}
-	} else {
-		info->flags |= NFP_F_SET_EXACT_TXQ;
-		info->flags |= NFP_F_SET_TXQ;
-		info->txq = txq;
-	}
-}
-
-static INLINE MV_VOID mvNfpTxpClassifySave(MV_U8 txp, NFP_CLASSIFY_INFO *info)
-{
-	if (info->flags & NFP_F_SET_EXACT_TXP) {
-		/* update info->txp according to policy */
-		switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_TXP]) {
-		case MV_NFP_CLASSIFY_POLICY_FIRST:
-			/* do nothing - this is not the first time this function was called */
-			break;
-		case MV_NFP_CLASSIFY_POLICY_LAST:
-			info->txp = txp;
-			break;
-		case MV_NFP_CLASSIFY_POLICY_HIGHEST:
-			if (txp > info->txp)
-				info->txp = txp;
-			break;
-		case MV_NFP_CLASSIFY_POLICY_LOWEST:
-			if (txp < info->txp)
-				info->txp = txp;
-			break;
-		default:
-			NFP_WARN("%s: unknown txp policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_TXP]);
-			return;
-		}
-	} else {
-		info->flags |= NFP_F_SET_EXACT_TXP;
-		info->flags |= NFP_F_SET_TXP;
-		info->txp = txp;
-	}
-}
-
-static INLINE MV_VOID mvNfpMhClassifySave(MV_U16 mh, NFP_CLASSIFY_INFO *info)
-{
-	if (info->flags & NFP_F_SET_EXACT_MH) {
-		/* update info->mh according to policy */
-		switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_MH]) {
-		case MV_NFP_CLASSIFY_POLICY_FIRST:
-			/* do nothing - this is not the first time this function was called */
-			break;
-		case MV_NFP_CLASSIFY_POLICY_LAST:
-			info->mh = mh;
-			break;
-		case MV_NFP_CLASSIFY_POLICY_HIGHEST:
-			if (mh > info->mh)
-				info->mh = mh;
-			break;
-		case MV_NFP_CLASSIFY_POLICY_LOWEST:
-			if (mh < info->mh)
-				info->mh = mh;
-			break;
-		default:
-			NFP_WARN("%s: unknown MH policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_MH]);
-			return;
-		}
-	} else {
-		info->flags |= NFP_F_SET_EXACT_MH;
-		info->flags |= NFP_F_SET_MH;
-		info->mh = mh;
-	}
-}
-
-#ifdef NFP_CT
-static INLINE int mvNfpClassifyExactDscpGet(NFP_CLASSIFY_INFO *info)
-{
-	int newDscp = NFP_INVALID_DSCP;
-	/* use dscp from exact match classification */
-	switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_DSCP]) {
-	case MV_NFP_CLASSIFY_POLICY_FIRST:
-		newDscp = info->pkt_dscp; /* should always be valid */
-		break;
-	case MV_NFP_CLASSIFY_POLICY_LAST:
-		if (info->ct_dscp != NFP_INVALID_DSCP)
-			newDscp = info->ct_dscp;
-		else
-			newDscp = info->pkt_dscp;
-		break;
-	case MV_NFP_CLASSIFY_POLICY_HIGHEST:
-		newDscp = (info->ct_dscp > info->pkt_dscp) ? info->ct_dscp : info->pkt_dscp;
-		break;
-	case MV_NFP_CLASSIFY_POLICY_LOWEST:
-		if (info->ct_dscp != NFP_INVALID_DSCP)
-			newDscp = (info->ct_dscp < info->pkt_dscp) ? info->ct_dscp : info->pkt_dscp;
-		else
-			newDscp = info->pkt_dscp;
-		break;
-	default:
-		NFP_WARN("%s: unknown DSCP policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_DSCP]);
-		return NFP_INVALID_DSCP;
-	}
-	return newDscp;
-}
-
-static INLINE int mvNfpClassifyFeatureGetVal(int exactVal, int priorityVal, MV_NFP_CLASSIFY_MODE mode)
-{
-	if (mode == MV_NFP_CLASSIFY_MODE_HIGHEST)
-		return (exactVal > priorityVal) ? exactVal : priorityVal;
-	else
-		return (exactVal < priorityVal) ? exactVal : priorityVal;
-}
-
-
-static INLINE MV_VOID mvNfpDscpClassifyUpdate(MV_IP_HEADER_INFO *pIpHdr, NFP_CLASSIFY_INFO *info)
-{
-	MV_IP6_HEADER *pIp6Hdr = pIpHdr->ip_hdr.ip6;
-	MV_IP_HEADER *pIph = pIpHdr->ip_hdr.ip4;
-	MV_U8 *pIp6 = (char *)pIp6Hdr;
-	int newDscp;
-	MV_U16 exactDscpFlag , prioDscpFlag;
-	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_DSCP);
-
-	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
-		return;
-
-	if (!(info->flags & NFP_F_SET_DSCP))
-		/* both exact and priority values are invalid */
-		return;
-
-	exactDscpFlag = info->flags & NFP_F_SET_EXACT_DSCP;
-	prioDscpFlag = info->flags & NFP_F_SET_PRIO_DSCP;
-
-	switch (mode) {
-	case MV_NFP_CLASSIFY_MODE_EXACT:
-		if (exactDscpFlag)
-			newDscp = mvNfpClassifyExactDscpGet(info);
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_PRIO:
-		if (prioDscpFlag)
-			newDscp = info->prio_dscp;
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_HIGHEST:
-	case MV_NFP_CLASSIFY_MODE_LOWEST:
-		if (!exactDscpFlag) {
-			if (!prioDscpFlag)
-				return;/*both valid*/
-			newDscp = info->prio_dscp;
-		} else if (!prioDscpFlag)
-			newDscp = mvNfpClassifyExactDscpGet(info);
-		else/*both valid*/
-			newDscp =  mvNfpClassifyFeatureGetVal(mvNfpClassifyExactDscpGet(info), info->prio_dscp, mode);
-		break;
-	default:
-		NFP_WARN("%s: unknown DSCP mode %d\n", __func__, mode);
-		return;
-	}
-
-	if  (newDscp != info->pkt_dscp) {
-		if (pIpHdr->family == MV_INET) {
-			pIph->tos = ((newDscp << 2) | info->pkt_ecn);
-		} else {
-			*pIp6 &= ~0xF;			/* Clear 4 LSBits of 1st byte of IPv6 header */
-			*pIp6 |= (newDscp >> 4);	/* Set 4 MSBits of new Traffic Class value */
-			pIp6++;
-			*pIp6 &= ~0xF0;			/* Clear 4 MSBits of 2nd byte of IPv6 header */
-			*pIp6 |= (((newDscp & 0x3) << 6) | (info->pkt_ecn << 4));	/* Set 4 LSBits of new Traffic Class value */
-		}
-	}
-}
-#endif /* NFP_CT */
-
-static INLINE int mvNfpClassifyExactVprioGet(NFP_CLASSIFY_INFO *info)
-{
-	int exactVprio = NFP_INVALID_VPRIO;
-	switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_VPRIO]) {
-	case MV_NFP_CLASSIFY_POLICY_FIRST:
-		if (info->pkt_vlan_prio != NFP_INVALID_VPRIO)
-			exactVprio = info->pkt_vlan_prio;
-		else if (info->bridge_vlan_prio != NFP_INVALID_VPRIO)
-			exactVprio = info->bridge_vlan_prio;
-		else if (info->ct_vlan_prio != NFP_INVALID_VPRIO)
-			exactVprio = info->ct_vlan_prio;
-		break;
-	case MV_NFP_CLASSIFY_POLICY_LAST:
-		if (info->ct_vlan_prio != NFP_INVALID_VPRIO)
-			exactVprio = info->ct_vlan_prio;
-		else if (info->bridge_vlan_prio != NFP_INVALID_VPRIO)
-			exactVprio = info->bridge_vlan_prio;
-		else if (info->pkt_vlan_prio != NFP_INVALID_VPRIO)
-			exactVprio = info->pkt_vlan_prio;
-		break;
-	case MV_NFP_CLASSIFY_POLICY_HIGHEST:
-		exactVprio = info->pkt_vlan_prio;
-		if (info->bridge_vlan_prio > exactVprio)
-			exactVprio = info->bridge_vlan_prio;
-		if (info->ct_vlan_prio > exactVprio)
-			exactVprio = info->ct_vlan_prio;
-		break;
-	case MV_NFP_CLASSIFY_POLICY_LOWEST:
-		exactVprio = info->pkt_vlan_prio;
-		if ((info->bridge_vlan_prio != NFP_INVALID_VPRIO) && (info->bridge_vlan_prio < exactVprio))
-			exactVprio = info->bridge_vlan_prio;
-		if ((info->ct_vlan_prio != NFP_INVALID_VPRIO) && (info->ct_vlan_prio < exactVprio))
-			exactVprio = info->ct_vlan_prio;
-		break;
-	default:
-		NFP_WARN("%s: unknown VLAN Priority policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_VPRIO]);
-		return NFP_INVALID_VPRIO;
-	}
-	return exactVprio;
-}
-
-
-static INLINE MV_VOID mvNfpVpriClassifyUpdate(MV_U16 *vid, NFP_CLASSIFY_INFO *info)
-{
-	int vprio;
-	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_VPRIO);
-	MV_U16 exactVlanPrioFlag , prioVlanPrioFlag;
-
-	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
-		return;
-
-	if (!(info->flags & NFP_F_SET_VLAN_PRIO))
-		/* both exact and priority values are invalid */
-		return;
-
-	exactVlanPrioFlag = info->flags & NFP_F_SET_EXACT_VLAN_PRIO;
-	prioVlanPrioFlag = info->flags & NFP_F_SET_PRIO_VLAN_PRIO;
-
-	switch (mode) {
-	case MV_NFP_CLASSIFY_MODE_EXACT:
-		if (exactVlanPrioFlag)
-			vprio = mvNfpClassifyExactVprioGet(info);
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_PRIO:
-		if (prioVlanPrioFlag)
-			vprio =  info->prio_vprio;
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_HIGHEST:
-	case MV_NFP_CLASSIFY_MODE_LOWEST:
-		if (!exactVlanPrioFlag) {
-			if (!prioVlanPrioFlag)
-				return;
-			vprio = info->prio_vprio;
-		} else if (!prioVlanPrioFlag)
-			vprio = mvNfpClassifyExactVprioGet(info);
-		else/*both valid*/
-			vprio = mvNfpClassifyFeatureGetVal(mvNfpClassifyExactVprioGet(info), info->prio_vprio, mode);
-		break;
-	default:
-		NFP_WARN("%s: unknown VLAN_PRIO mode %d\n", __func__, mode);
-		return;
-	}
-
-	(*vid) &= ~0xE000;
-	(*vid) |= (vprio << 13); /* Set 3 MSBits */
-}
-
-static INLINE MV_VOID mvNfpMhClassifyUpdate(MV_U8 *pData, NFP_CLASSIFY_INFO *info)
-{
-	MV_U16 mh;
-	MV_U16 exactMhFlag , prioMhFlag;
-	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_MH);
-
-	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
-		return;
-
-	if (!(info->flags & NFP_F_SET_MH))
-		/* both exact and priority values are invalid */
-		return;
-
-	exactMhFlag = info->flags & NFP_F_SET_EXACT_MH;
-	prioMhFlag = info->flags & NFP_F_SET_PRIO_MH;
-
-	switch (mode) {
-	case MV_NFP_CLASSIFY_MODE_EXACT:
-		if (exactMhFlag)
-			mh = info->mh;
-		else
-			return;
-		break;
-	case NFP_F_SET_PRIO_MH:
-		if (prioMhFlag)
-			mh = info->prio_mh;
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_HIGHEST:
-	case MV_NFP_CLASSIFY_MODE_LOWEST:
-		if (!exactMhFlag) {
-			if (!prioMhFlag)
-				return;
-			mh = info->prio_mh;
-		} else if (!prioMhFlag)
-			mh = info->mh;
-		else/*both valid*/
-			mh = mvNfpClassifyFeatureGetVal(info->mh, info->prio_mh, mode);
-		break;
-	default:
-		NFP_WARN("%s: unknown MH mode %d\n", __func__, mode);
-		return;
-	}
-
-	*(MV_U16 *)(pData) = MV_16BIT_BE(mh);
-}
-
-static INLINE MV_VOID mvNfpTxpClassifyUpdate(MV_NFP_RESULT *pRes, NFP_CLASSIFY_INFO *info)
-{
-	MV_U8 newTxp;
-	MV_U16 exactTxpFlag , prioTxpFlag;
-	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_TXP);
-
-	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
-		return;
-
-	if (!(info->flags & NFP_F_SET_TXP))
-		/* both exact and priority values are invalid */
-		return;
-
-	exactTxpFlag = info->flags & NFP_F_SET_EXACT_TXP;
-	prioTxpFlag = info->flags & NFP_F_SET_PRIO_TXP;
-
-	switch (mode) {
-	case MV_NFP_CLASSIFY_MODE_EXACT:
-		if (exactTxpFlag)
-			newTxp = info->txp;
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_PRIO:
-		if (prioTxpFlag)
-			newTxp = info->prio_txp;
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_HIGHEST:
-	case MV_NFP_CLASSIFY_MODE_LOWEST:
-		if (!exactTxpFlag) {
-			if (!prioTxpFlag)
-				return;
-			newTxp = info->prio_txp;
-		} else if (!prioTxpFlag)
-			newTxp = info->txp;
-		else/*both valid*/
-			newTxp = mvNfpClassifyFeatureGetVal(info->txp, info->prio_txp, mode);
-		break;
-	default:
-		NFP_WARN("%s: unknown TPX mode %d\n", __func__, mode);
-		return;
-	}
-
-	pRes->flags |= MV_NFP_RES_TXP_VALID;
-	pRes->txp = newTxp;
-}
-
-static INLINE MV_VOID mvNfpTxqClassifyUpdate(MV_NFP_RESULT *pRes, NFP_CLASSIFY_INFO *info)
-{
-	MV_U8 newTxq;
-	MV_U16 exactTxqFlag , prioTxqFlag;
-	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_TXQ);
-
-	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
-		return;
-
-	if (!(info->flags & NFP_F_SET_TXQ))
-		/* both exact and priority values are invalid */
-		return;
-
-	exactTxqFlag = info->flags & NFP_F_SET_EXACT_TXQ;
-	prioTxqFlag = info->flags & NFP_F_SET_PRIO_TXQ;
-
-	switch (mode) {
-	case MV_NFP_CLASSIFY_MODE_EXACT:
-		if (exactTxqFlag)
-			newTxq = info->txq;
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_PRIO:
-		if (prioTxqFlag)
-			newTxq = info->prio_txq;
-		else
-			return;
-		break;
-	case MV_NFP_CLASSIFY_MODE_HIGHEST:
-	case MV_NFP_CLASSIFY_MODE_LOWEST:
-		if (!exactTxqFlag) {
-			if (!prioTxqFlag)
-				return;
-			newTxq = info->prio_txq;
-		} else if (!prioTxqFlag)
-			newTxq = info->txq;
-		else/*both valid*/
-			newTxq = mvNfpClassifyFeatureGetVal(info->txq, info->prio_txq, mode);
-		break;
-	default:
-		NFP_WARN("%s: unknown TPX mode 3 %d\n", __func__, mode);
-		return;
-	}
-
-	pRes->flags |= MV_NFP_RES_TXQ_VALID;
-	pRes->txq = newTxq;
-}
-
-
-/* Get classification priority according to policy
- * Priority can come from:
- *	1. iif => prio
- *	2. iif + vprio => prio
- *	3. iif + dscp => prio
- * Policy can be Highest or Lowest.
- * Return correct priority, or NFP_PRIO_INVALID if no priority is available */
-static INLINE int mvNfpClassifyPrioGet(NFP_CLASSIFY_INFO *info)
-{
-	MV_NFP_CLASSIFY_POLICY prioPolicy = mvNfpPrioPolicyGet();
-	int prio;
-
-	if (!info)
-		return NFP_PRIO_INVALID;
-
-	/* get priority from iif/(iif+vprio)/(iif+dscp) according to priority policy (highest/lowest) */
-	prio = info->iif_prio;
-
-	if ((info->iif_vlan_prio != NFP_PRIO_INVALID) &&
-		((prio == NFP_PRIO_INVALID) ||
-		((prioPolicy == MV_NFP_CLASSIFY_POLICY_HIGHEST) && (prio < info->iif_vlan_prio)) ||
-		((prioPolicy == MV_NFP_CLASSIFY_POLICY_LOWEST) && (prio > info->iif_vlan_prio))))
-		prio = info->iif_vlan_prio;
-	if ((info->iif_dscp_prio != NFP_PRIO_INVALID) &&
-		((prio == NFP_PRIO_INVALID) ||
-		((prioPolicy == MV_NFP_CLASSIFY_POLICY_HIGHEST) && (prio < info->iif_dscp_prio)) ||
-		((prioPolicy == MV_NFP_CLASSIFY_POLICY_LOWEST) && (prio > info->iif_dscp_prio))))
-		prio = info->iif_dscp_prio;
-
-	return prio;
-}
-
-/* save classification data, from priority */
-static INLINE MV_VOID mvNfpClassifyPrioSave(NFP_IF_MAP *pOutIf, NFP_CLASSIFY_INFO *info, int prio)
-{
-	NFP_PRIO_CLASSIFY_INFO *classifyFromOif = NULL;
-
-	if (!pOutIf || !info || (prio == NFP_PRIO_INVALID))
-		return;
-
-	classifyFromOif = &(pOutIf->prio_to_classify[prio]);
-
-	/* for each feature, save classify data */
-	if (classifyFromOif->flags & NFP_F_PRIO_DSCP) {
-		info->prio_dscp = classifyFromOif->dscp;
-		info->flags |= NFP_F_SET_PRIO_DSCP;
-		info->flags |= NFP_F_SET_DSCP;
-	} else
-		info->flags &= ~NFP_F_SET_PRIO_DSCP;
-
-	if (classifyFromOif->flags & NFP_F_PRIO_VPRIO) {
-		info->prio_vprio = classifyFromOif->vprio;
-		info->flags |= NFP_F_SET_PRIO_VLAN_PRIO;
-		info->flags |= NFP_F_SET_VLAN_PRIO;
-	} else
-		info->flags &= ~NFP_F_SET_PRIO_VLAN_PRIO;
-
-	if (classifyFromOif->flags & NFP_F_PRIO_TXQ) {
-		info->prio_txq = classifyFromOif->txq;
-		info->flags |= NFP_F_SET_PRIO_TXQ;
-		info->flags |= NFP_F_SET_TXQ;
-	} else
-		info->flags &= ~NFP_F_SET_PRIO_TXQ;
-
-	if (classifyFromOif->flags & NFP_F_PRIO_TXP) {
-		info->prio_txp = classifyFromOif->txp;
-		info->flags |= NFP_F_SET_PRIO_TXP;
-		info->flags |= NFP_F_SET_TXP;
-	} else
-		info->flags &= ~NFP_F_SET_PRIO_TXP;
-
-	if (classifyFromOif->flags & NFP_F_PRIO_MH) {
-		info->prio_mh = classifyFromOif->mh;
-		info->flags |= NFP_F_SET_PRIO_MH;
-		info->flags |= NFP_F_SET_MH;
-	} else
-		info->flags &= ~NFP_F_SET_PRIO_MH;
-
-}
-#endif /* NFP_CLASSIFY */
-
-#ifdef NFP_VLAN
-MV_STATUS mvNfpVlanPvidSet(int if_index, MV_U16 pvid)
-{
-	NFP_IF_MAP *vlanIf = mvNfpIfMapGet(if_index);
-
-	if (vlanIf == NULL) {
-		mvOsPrintf("%s: interface %d is not valid\n", __func__, if_index);
-		return MV_NOT_FOUND;
-	}
-
-	if (pvid == NFP_INVALID_VLAN)
-		vlanIf->flags &= ~NFP_F_MAP_VLAN_PVID;
-	else
-		vlanIf->flags |= NFP_F_MAP_VLAN_PVID;
-
-	vlanIf->pvid = pvid;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpVlanVidSet(int if_index, MV_U16 vid)
-{
-	NFP_IF_MAP *vlanIf = mvNfpIfMapGet(if_index);
-
-	if (vlanIf == NULL) {
-		mvOsPrintf("%s: interface %d is not valid\n", __func__, if_index);
-		return MV_NOT_FOUND;
-	}
-	vlanIf->vlanId = vid;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpVlanVidGet(int if_index, MV_U16 *vid)
-{
-	NFP_IF_MAP *vlanIf = mvNfpIfMapGet(if_index);
-
-	if (vlanIf == NULL) {
-		mvOsPrintf("%s: interface %d is not valid\n", __func__, if_index);
-		return MV_NOT_FOUND;
-	}
-	*vid = vlanIf->vlanId;
-
-	return MV_OK;
-}
-
-/* Find virtual interface match vlanId */
-static INLINE NFP_IF_MAP *mvNfpVlanIfFind(NFP_IF_MAP *ifMap, MV_U16 vlanId)
-{
-	NFP_IF_MAP *vlanIf;
-
-	if (ifMap->vlanId == vlanId)
-		return ifMap;
-
-	vlanIf = ifMap->virtIf;
-	while (vlanIf != NULL) {
-		if ((vlanIf->vlanId == vlanId))
-			return vlanIf;
-
-		vlanIf = vlanIf->virtNext;
-	}
-	return NULL;
-}
-
-static INLINE MV_STATUS mvNfpVlanRx(int port, NETA_RX_DESC *pRxDesc, MV_U8 *pData,
-				    MV_ETH_PKT *pPkt, NFP_IF_MAP **ppIfMap,
-				    MV_NFP_RESULT *pRes)
-{
-	MV_U16     vlanId;
-	NFP_IF_MAP *vlanIfMap = NULL, *ifMap = *ppIfMap;
-
-	/* PVID processing */
-	if (NETA_RX_IS_VLAN(pRxDesc)) {
-		/* tagged packets */
-		if (ifMap->flags & NFP_F_MAP_VLAN_RX_DROP_TAGGED) {
-			/* Drop tagged packets */
-			NFP_INC(port, vlan_rx_tag_drop);
-			return MV_DROPPED;
-		}
-		vlanId = *((MV_U16 *)(pData + MV_ETH_MH_SIZE + sizeof(MV_802_3_HEADER)));
-		vlanId = MV_16BIT_BE(vlanId);
-#ifdef NFP_CLASSIFY
-		mvNfpVpriPktClassifySave(vlanId, (NFP_CLASSIFY_INFO *)(pRes->privateData));
-#endif /* NFP_CLASSIFY */
-		vlanId &= 0xFFF;
-	} else {
-		/* Untagged packet */
-		if (ifMap->flags & NFP_F_MAP_VLAN_RX_DROP_UNTAGGED) {
-			/* Drop untagged packets */
-			NFP_INC(port, vlan_rx_untag_drop);
-			return MV_DROPPED;
-		}
-		if (ifMap->flags & NFP_F_MAP_VLAN_PVID)
-			vlanId = ifMap->pvid;
-		else
-			vlanId = NFP_INVALID_VLAN;
-	}
-	pPkt->vlanId = vlanId;
-
-	if (vlanId != NFP_INVALID_VLAN) {
-		/* Tagged packet */
-		/* look for vlanId through virtual interfaces mapped to this ifMap */
-		vlanIfMap = mvNfpVlanIfFind(ifMap, vlanId);
-		if (vlanIfMap) {
-			/* found */
-			NFP_INC(port, vlan_rx_found);
-			*ppIfMap = vlanIfMap;
-			return MV_CONTINUE;
-		}
-		/* not found */
-		if (ifMap->flags & NFP_F_MAP_VLAN_RX_DROP_UNKNOWN) {
-			/* Drop packets with unknown VIDs */
-			NFP_INC(port, vlan_rx_unknown_drop);
-			return MV_DROPPED;
-		}
-	}
-	/* Default - Transparent mode */
-	NFP_INC(port, vlan_rx_trans);
-	return MV_CONTINUE;
-}
-
-static INLINE int mvNfpVlanAdd(int port, MV_U8 *pData, MV_U16 vid, MV_BOOL moveMac, MV_NFP_RESULT *pRes)
-{
-	MV_U8  *pNew;
-	MV_U16 *pVlan;
-
-	NFP_INC(port, vlan_tx_add);
-
-	pNew = pData - MV_VLAN_HLEN;
-	if (moveMac) {
-		/* move MAC header 4 bytes left. Copy 12 bytes (DA + SA) */
-		*(MV_U32 *)(pNew + 2) = *(MV_U32 *)(pData + 2);
-		*(MV_U32 *)(pNew + 2 + 4) = *(MV_U32 *)(pData + 2 + 4);
-		*(MV_U32 *)(pNew + 2 + 4 + 4) = *(MV_U32 *)(pData + 2 + 4 + 4);
-	}
-	pVlan = (MV_U16 *)(pNew + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE);
-	/* Set VLAN Type - 0x8100 */
-	*pVlan = MV_16BIT_BE(MV_VLAN_TYPE);
-	pVlan++;
-	/* Set VID + priority */
-#ifdef NFP_CLASSIFY
-	mvNfpVpriClassifyUpdate(&vid, (NFP_CLASSIFY_INFO *)(pRes->privateData));
-#endif /* NFP_CLASSIFY */
-	*pVlan = MV_16BIT_BE(vid);
-
-	return -MV_VLAN_HLEN;
-}
-
-static INLINE int mvNfpVlanRemove(int port, MV_U8 *pData, MV_BOOL moveMac)
-{
-	MV_U8  *pNew;
-
-	NFP_INC(port, vlan_tx_remove);
-
-	if (moveMac) {
-		/* move MAC header 4 bytes right. Copy 12 bytes (DA + SA) */
-		pNew = pData + MV_VLAN_HLEN;
-		*(MV_U32 *)(pNew + 2 + 4 + 4) = *(MV_U32 *)(pData + 2 + 4 + 4);
-		*(MV_U32 *)(pNew + 2 + 4) = *(MV_U32 *)(pData + 2 + 4);
-		*(MV_U32 *)(pNew + 2) = *(MV_U32 *)(pData + 2);
-	}
-	return MV_VLAN_HLEN;
-}
-
-static INLINE int mvNfpVlanReplace(int port, MV_U8 *pData, MV_U16 vid, MV_NFP_RESULT *pRes)
-{
-	MV_U16 *pVlan;
-
-	NFP_INC(port, vlan_tx_replace);
-
-	pVlan = (MV_U16 *)(pData + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE);
-	/* Set VLAN Type - 0x8100 */
-	*pVlan = MV_16BIT_BE(MV_VLAN_TYPE);
-	pVlan++;
-	/* Set VID + priority */
-#ifdef NFP_CLASSIFY
-	mvNfpVpriClassifyUpdate(&vid, (NFP_CLASSIFY_INFO *)(pRes->privateData));
-#endif /* NFP_CLASSIFY */
-	*pVlan = MV_16BIT_BE(vid);
-
-	return 0;
-}
-
-static INLINE int mvNfpVlanTxUpdate(int port, NETA_RX_DESC *pRxDesc, NFP_IF_MAP *pOutIf,
-					MV_U8 *pData, MV_ETH_PKT *pPkt, MV_BOOL saveMac,
-					MV_NFP_RESULT *pRes)
-{
-	int vlanShift = 0;
-
-	if (NETA_RX_IS_VLAN(pRxDesc)) {
-		/* Original packet was tagged */
-		if (pOutIf->flags & NFP_F_MAP_VLAN_TX_UNTAGGED)
-			vlanShift = mvNfpVlanRemove(port, pData, saveMac);
-		else if (pOutIf->flags & NFP_F_MAP_VLAN_TX_TAGGED)
-			vlanShift = mvNfpVlanReplace(port, pData, pOutIf->vlanId, pRes);
-	} else {
-		/* Original packet was untagged */
-		if (pOutIf->flags & NFP_F_MAP_VLAN_TX_TAGGED)
-			vlanShift = mvNfpVlanAdd(port, pData, pOutIf->vlanId, saveMac, pRes);
-		else if (pPkt->vlanId != NFP_INVALID_VLAN) /* PVID case */
-			vlanShift = mvNfpVlanAdd(port, pData, pPkt->vlanId, saveMac, pRes);
-	}
-	pPkt->bytes -= vlanShift;
-	return vlanShift;
-}
-#endif /* NFP_VLAN */
-
-#ifdef NFP_PPP
-/* Find PPPoE interface with the "sid" */
-static INLINE NFP_IF_MAP *mvNfpPppIfFind(NFP_IF_MAP *ifMap, MV_U16 sid)
-{
-	NFP_IF_MAP *virtIf;
-
-	if ((ifMap->flags & NFP_F_MAP_PPPOE) && (ifMap->sid == sid))
-		return ifMap;
-
-	virtIf = ifMap->virtIf;
-	while (virtIf != NULL) {
-		if ((virtIf->flags & NFP_F_MAP_PPPOE) && (virtIf->sid == sid))
-			return virtIf;
-
-		virtIf = virtIf->virtNext;
-	}
-	return NULL;
-}
-
-MV_STATUS mvNfpPppAdd(int ifIndex, MV_U16 sid, MV_U8 *remoteMac)
-{
-	NFP_IF_MAP *pppIf = mvNfpIfMapGet(ifIndex);
-
-	if (pppIf == NULL) {
-		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIndex);
-		return MV_NOT_FOUND;
-	}
-	/* Copy SA MAC address from parent interface */
-	memcpy(pppIf->mac, pppIf->parentIf->mac, MV_MAC_ADDR_SIZE);
-
-	memcpy(pppIf->remoteMac, remoteMac, MV_MAC_ADDR_SIZE);
-	pppIf->sid = MV_16BIT_BE(sid);
-	pppIf->flags |= NFP_F_MAP_PPPOE;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPppDel(int ifIndex)
-{
-	NFP_IF_MAP *pppIf = mvNfpIfMapGet(ifIndex);
-
-	if (pppIf == NULL) {
-		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIndex);
-		return MV_NOT_FOUND;
-	}
-	pppIf->flags &= ~NFP_F_MAP_PPPOE;
-	pppIf->sid = 0;
-	mvOsMemset(pppIf->remoteMac, 0, MV_MAC_ADDR_SIZE);
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPppRx(int port, NETA_RX_DESC *pRxDesc, MV_U8 *pData, MV_ETH_PKT *pPkt ,
-					 NFP_IF_MAP **ppIfMap, MV_IP_HEADER_INFO *pIpHdrInfo)
-{
-	unsigned char *pIpHdr;
-	PPPoE_HEADER  *pPppHdr;
-	NFP_IF_MAP    *ifMap = *ppIfMap;
-	NFP_IF_MAP    *ifPppMap = NULL;
-
-	if (NETA_RX_IS_PPPOE(pRxDesc)) {
-		pIpHdr = (unsigned char *)pIpHdrInfo->ip_hdr.ip4;
-		pPppHdr = (PPPoE_HEADER *)(pIpHdr - MV_PPPOE_HDR_SIZE);
-
-		ifPppMap = mvNfpPppIfFind(ifMap, pPppHdr->session);
-		if (ifPppMap == NULL) {
-			NFP_WARN("%s: PPPoE sid=%d not found; ifMap->name=%s\n",
-				__func__, MV_16BIT_BE(pPppHdr->session), ifMap->name);
-			NFP_INC(port, pppoe_rx_not_found);
-			return MV_TERMINATE;
-		}
-		NFP_INC(port, pppoe_rx_found);
-	}
-	return MV_CONTINUE;
-}
-#endif /* NFP_PPP */
-
-
-#ifdef NFP_BRIDGE
-/* Do bridging: MV_OK - bridging, MV_TERMINATE - slow path, MV_CONTINUE - Routing */
-static INLINE MV_STATUS  mvNfpBridgeRx(int port, NETA_RX_DESC *pRxDesc, NFP_IF_MAP *inIfMap, MV_ETH_PKT *pPkt,
-				       MV_NFP_RESULT *pRes)
-{
-	int             shift = 0;
-	MV_U8           *pData;
-	MV_U8           *da, *sa;
-	NFP_IF_MAP      *outIfMap;
-#ifdef NFP_FDB_MODE
-	NFP_RULE_FDB	*fdbRule;
-#else
-	NFP_RULE_BRIDGE	*bridgeRule;
-#endif
-#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
-	int prio;
-	NFP_CLASSIFY_INFO *classifyInfo = (NFP_CLASSIFY_INFO *)(pRes->privateData);
-#endif /* NFP_CLASSIFY */
-
-	pData = pPkt->pBuf + pPkt->offset;
-	da = pData + MV_ETH_MH_SIZE;
-	sa = da + MV_MAC_ADDR_SIZE;
-
-#ifdef NFP_FDB_MODE
-	/* BridgeIf + SA lookup */
-	fdbRule = mvNfpFdbLookup(inIfMap->bridgeIf, pData + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE);
-	if (fdbRule == NULL) {
-		NFP_INC(port, fdb_sa_miss);
-		return MV_TERMINATE;
-	}
-	/* Check if FDB entry move to other port of the bridge */
-	if (fdbRule->if_index != inIfMap->ifIdx) {
-		NFP_INC(port, fdb_port_miss);
-		return MV_TERMINATE;
-	}
-
-	/* BridgeIf + DA lookup */
-	fdbRule = mvNfpFdbLookup(inIfMap->bridgeIf, pData + MV_ETH_MH_SIZE);
-	if (fdbRule == NULL) {
-		NFP_INC(port, fdb_da_miss);
-		return MV_TERMINATE;
-	}
-	fdbRule->age++;
-
-	if (fdbRule->status == NFP_BRIDGE_LOCAL) {
-		NFP_INC(port, fdb_local);
-		return MV_CONTINUE;
-	}
-	outIfMap = mvNfpIfMapGet(fdbRule->if_index);
-	if (outIfMap == NULL) {
-		mvOsPrintf("%s: bridge rule interface %d is not valid\n", __func__, fdbRule->if_index);
-		NFP_INC(port, oif_err);
-		return MV_TERMINATE;
-	}
-	NFP_INC(port, fdb_hit);
-#else
-	bridgeRule = mvNfpBridgeLookup(da, sa, inIfMap->ifIdx);
-	if (bridgeRule == NULL) {
-		NFP_INC(port, bridge_miss);
-		return MV_TERMINATE;
-	}
-	bridgeRule->age++;
-
-#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
-	if (bridgeRule->flags & NFP_F_BR_SET_VLAN_PRIO)
-		mvNfpVpriBridgeClassifySave(pData, bridgeRule, classifyInfo);
-	if (bridgeRule->flags & NFP_F_BR_SET_TXQ)
-		mvNfpTxqClassifySave(bridgeRule->txq, classifyInfo);
-	if (bridgeRule->flags & NFP_F_BR_SET_TXP)
-		mvNfpTxpClassifySave(bridgeRule->txp, classifyInfo);
-	if (bridgeRule->flags & NFP_F_BR_SET_MH)
-		mvNfpMhClassifySave(bridgeRule->mh, classifyInfo);
-#endif /* NFP_CLASSIFY */
-
-	/* Check if this is a local bridge rule (DA is "to me") */
-	if (inIfMap->bridgeIf == bridgeRule->oif) {
-		NFP_INC(port, bridge_local);
-		return MV_CONTINUE;
-	}
-	outIfMap = mvNfpIfMapGet(bridgeRule->oif);
-	if (outIfMap == NULL) {
-		mvOsPrintf("%s: bridge rule out interface %d is not valid\n", __func__, bridgeRule->oif);
-		NFP_INC(port, oif_err);
-		return MV_TERMINATE;
-	}
-#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
-	prio = mvNfpClassifyPrioGet(classifyInfo);
-	if (prio != NFP_PRIO_INVALID)
-		mvNfpClassifyPrioSave(outIfMap, classifyInfo, prio);
-#endif /* NFP_CLASSIFY */
-
-	NFP_INC(port, bridge_hit);
-#endif /* NFP_FDB_MODE */
-
-#ifdef NFP_VLAN
-	/* Process VLAN tag */
-	shift += mvNfpVlanTxUpdate(port, pRxDesc, outIfMap, pData + shift, pPkt, MV_TRUE, pRes);
-#endif /* NFP_VLAN */
-
-	while (outIfMap->parentIf)
-		outIfMap = outIfMap->parentIf;
-
-	/* Update pPkt for bridging TX */
-	pRes->dev = outIfMap->dev;
-	if (outIfMap->flags & NFP_F_MAP_EXT)
-		pRes->flags |= MV_NFP_RES_NETDEV_EXT;
-
-	/* Process 2B of MH */
-	if (outIfMap->flags & NFP_F_MAP_TX_MH) {
-		/* Transmit with MH */
-		*(MV_U16 *)(pData + shift) = outIfMap->txMh;
-#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
-		/* allow setting MH only for PON ports */
-		if (MV_PON_PORT(outIfMap->port))
-			mvNfpMhClassifyUpdate(pData + shift, classifyInfo);
-#endif /* NFP_CLASSIFY */
-	} else {
-		/* Transmit without MH */
-		shift += MV_ETH_MH_SIZE;
-		pPkt->bytes -= MV_ETH_MH_SIZE;
-	}
-
-	pRes->shift = shift;
-
-#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
-	mvNfpTxqClassifyUpdate(pRes, classifyInfo);
-
-	/* allow setting txp only for PON ports */
-	if (MV_PON_PORT(outIfMap->port))
-		mvNfpTxpClassifyUpdate(pRes, classifyInfo);
-
-#endif /* NFP_CLASSIFY */
-
-	pRes->tx_cmd = NETA_TX_L4_CSUM_NOT;
-
-	if ((pRes->flags & MV_NFP_RES_NETDEV_EXT) == 0)
-		mvOsCacheLineFlush(NULL, pData);
-	return MV_OK;
-}
-#endif /* NFP_BRIDGE */
-
-#ifdef NFP_NAT
-static INLINE void mvNfpNatUpdate(MV_IP_HEADER_INFO *pIpInfo, NFP_RULE_CT *pCt, MV_NFP_RESULT *pRes, NFP_IF_MAP *pOutIf)
-{
-	MV_IP_HEADER *pIpHdr = pIpInfo->ip_hdr.ip4;
-	char          *l4Hdr = ((char *)pIpHdr + pIpInfo->ipHdrLen);
-	MV_U16        *pPort;
-	MV_U32        old_val = 0, new_val = 0;
-	int           csum;
-
-	if ((pIpHdr->protocol == MV_IP_PROTO_UDP) && (((MV_UDP_HEADER *)l4Hdr)->check == 0)) {
-		/* skip L4 csum */
-		csum = 0;
-	} else if ((pOutIf->flags & NFP_F_MAP_EXT) ||
-			needFragment(pIpInfo, pOutIf) ||
-			(pIpInfo->ipLen > MV_ETH_TX_CSUM_MAX_SIZE)) {
-		/* L4 checksum must be calculated by SW */
-		csum = 1;
-	} else {
-		/* L4 checksum can be calculated by HW */
-		csum = 2;
-	}
-
-	if (pCt->flags & NFP_F_CT_SNAT) {
-		pPort = (MV_U16 *)l4Hdr;
-
-		if (csum == 1) {
-			old_val = pIpHdr->srcIP + *pPort;
-			new_val = pCt->new_sip + pCt->new_sport;
-		}
-		pIpHdr->srcIP = pCt->new_sip;
-		*pPort = pCt->new_sport;
-	}
-
-	if (pCt->flags & NFP_F_CT_DNAT) {
-		pPort = (MV_U16 *)(l4Hdr + 2);
-
-		if (csum == 1) {
-			old_val += pIpHdr->dstIP + *pPort;
-			new_val += pCt->new_dip + pCt->new_dport;
-		}
-		pIpHdr->dstIP = pCt->new_dip;
-		*pPort = pCt->new_dport;
-	}
-
-	switch (csum) {
-	case 0:
-		pRes->pWrite = l4Hdr + sizeof(MV_UDP_HEADER);
-		break;
-
-	case 1:
-		pRes->diffL4[0] = ~old_val;
-		pRes->diffL4[1] = new_val;
-
-		pRes->flags |= MV_NFP_RES_L4_CSUM_NEEDED;
-		break;
-
-	case 2:
-		pRes->tx_cmd &= ~NETA_TX_L4_CSUM_MASK;
-		if (pIpHdr->protocol == MV_IP_PROTO_TCP) {
-			pRes->pWrite = l4Hdr + 4;
-			pRes->tx_cmd |= NETA_TX_L4_TCP | NETA_TX_L4_CSUM_FULL;
-		} else if (pIpHdr->protocol == MV_IP_PROTO_UDP) {
-			pRes->pWrite = l4Hdr + sizeof(MV_UDP_HEADER);
-			pRes->tx_cmd |= NETA_TX_L4_UDP | NETA_TX_L4_CSUM_FULL;
-		}
-		break;
-	}
-}
-#endif /* NFP_NAT */
-
-#ifdef NFP_PPP
-static INLINE int removePppoeHeader(MV_IP_HEADER_INFO *pIpHdrInfo)
-{
-	unsigned char *pIpHdr;
-
-	/* writing IP ethertype to the new location of ether header */
-	if (pIpHdrInfo->family == MV_INET) {
-		pIpHdr = (unsigned char *)(pIpHdrInfo->ip_hdr.ip4);
-		*(pIpHdr - 1) = 0x00;
-		*(pIpHdr - 2) = 0x08;
-	} else {
-		pIpHdr = (unsigned char *)(pIpHdrInfo->ip_hdr.ip6);
-	  *(pIpHdr - 1) = 0xDD;
-	  *(pIpHdr - 2) = 0x86;
-	}
-	return MV_PPPOE_HDR_SIZE;
-}
-
-static INLINE int addPppoeHeader(NFP_IF_MAP *pOutIf, MV_IP_HEADER_INFO *pIpHdrInfo)
-{
-	unsigned char *pIpHdr;
-	PPPoE_HEADER *pPPPNew;
-
-	if (pIpHdrInfo->family == MV_INET)
-		pIpHdr = (unsigned char *)pIpHdrInfo->ip_hdr.ip4;
-	else
-		pIpHdr = (unsigned char *)pIpHdrInfo->ip_hdr.ip6;
-
-	/* Keep VLAN fields*/
-	*(pIpHdr - MV_PPPOE_HDR_SIZE - 3) = *(pIpHdr - 3);
-	*(pIpHdr - MV_PPPOE_HDR_SIZE - 4) = *(pIpHdr - 4);
-	*(pIpHdr - MV_PPPOE_HDR_SIZE - 5) = *(pIpHdr - 5);
-	*(pIpHdr - MV_PPPOE_HDR_SIZE - 6) = *(pIpHdr - 6);
-
-	*(pIpHdr - MV_PPPOE_HDR_SIZE - 1) = 0x64;
-	*(pIpHdr - MV_PPPOE_HDR_SIZE - 2) = 0x88;
-
-	pPPPNew = (PPPoE_HEADER *)(pIpHdr - MV_PPPOE_HDR_SIZE);
-	pPPPNew->version = 0x11;
-	pPPPNew->code = 0x0;
-	pPPPNew->session = pOutIf->sid;
-
-	/* calculate PPPoE payload len considering padding for short packets */
-	if (pIpHdrInfo->family == MV_INET) {
-		pPPPNew->proto =  MV_16BIT_BE(MV_IP_PPP);
-		pPPPNew->len = MV_16BIT_BE(pIpHdrInfo->ipLen + MV_PPP_HDR_SIZE);
-	} else {
-		pPPPNew->proto = MV_16BIT_BE(MV_IP6_PPP);
-		pPPPNew->len = MV_16BIT_BE(pIpHdrInfo->ipLen + MV_PPP_HDR_SIZE + pIpHdrInfo->ipHdrLen);
-	}
-	return -MV_PPPOE_HDR_SIZE;
-}
-
-
-static INLINE void replacePppoeHeader(NFP_IF_MAP *pOutIf, MV_IP_HEADER_INFO *pIpHdrInfo)
-{
-	PPPoE_HEADER *pPPPHdr;
-	unsigned char *pIpHdr;
-
-	pIpHdr = (unsigned char *)pIpHdrInfo->ip_hdr.ip4;
-	pPPPHdr = (PPPoE_HEADER *)(pIpHdr - MV_PPPOE_HDR_SIZE);
-	if (pPPPHdr)
-		pPPPHdr->session = pOutIf->sid;
-}
-
-
-static INLINE int mvNfpPppTxUpdate(MV_U32 port, NETA_RX_DESC *pRxDesc,
-					NFP_IF_MAP *pOutIf, MV_ETH_PKT *pPkt,
-					MV_IP_HEADER_INFO *pIpHdrInfo)
-{
-	int pppShift = 0;
-
-	if (NETA_RX_IS_PPPOE(pRxDesc)) {
-		/* Ingress packet has PPPoE header */
-		if (pOutIf->flags & NFP_F_MAP_PPPOE) {
-			replacePppoeHeader(pOutIf, pIpHdrInfo);
-			NFP_INC(port, pppoe_tx_replace);
-		} else {
-			/* remove pppoe header */
-			pppShift = removePppoeHeader(pIpHdrInfo);
-			pPkt->bytes -= pppShift;
-			NFP_INC(port, pppoe_tx_remove);
-		}
-	} else {
-		/* Ingress packet doesn't have PPPoE header */
-		if (pOutIf->flags & NFP_F_MAP_PPPOE) {
-			/* add pppoe header */
-			pppShift = addPppoeHeader(pOutIf, pIpHdrInfo);
-			pPkt->bytes -= pppShift;
-			NFP_INC(port, pppoe_tx_add);
-		}
-	}
-	return pppShift;
-}
-#endif /* NFP_PPP */
-
-
-static INLINE MV_STATUS mvNfpStatusCheck(MV_U32 port, const NETA_RX_DESC *pRxDesc)
-{
-#ifndef CONFIG_MV_ETH_PNC
-	if ((pRxDesc->status & ETH_RX_NOT_LLC_SNAP_FORMAT_MASK) == 0) {
-		NFP_INC(port, non_ip);
-		return MV_TERMINATE;
-	}
-#endif /* !CONFIG_MV_ETH_PNC */
-
-	if (NETA_RX_L3_IS_UN(pRxDesc->status)) {
-		NFP_INC(port, non_ip);
-		return MV_TERMINATE;
-	}
-	if (NETA_RX_L3_IS_IP4_ERR(pRxDesc->status)) {
-		NFP_INC(port, ipv4_csum_err);
-		return MV_TERMINATE;
-	}
-	if ((NETA_RX_L4_IS_TCP(pRxDesc->status) ||
-	     NETA_RX_L4_IS_UDP(pRxDesc->status)) &&
-	     (!NETA_RX_L4_CSUM_IS_OK(pRxDesc->status))) {
-		NFP_INC(port, l4_csum_err);
-		return MV_TERMINATE;
-	}
-
-	if (nfpMode == MV_NFP_5_TUPLE) {
-		/* Only UDP or TCP packets with correct checksum are processed in 5 tuple mode */
-		if (!NETA_RX_L4_CSUM_IS_OK(pRxDesc->status)) {
-			NFP_INC(port, l4_unknown);
-			return MV_TERMINATE;
-		}
-	}
-	return MV_CONTINUE;
-}
-
-static INLINE MV_STATUS mvNfpParseIpHeader(MV_U32 port, const NETA_RX_DESC *pRxDesc, MV_U8 *pData,
-							MV_IP_HEADER_INFO *pIpHdr)
-{
-	MV_U8 *pEth;
-
-	pEth = pData + MV_ETH_MH_SIZE;
-	if (pEth[0] & 0x01) {	/* Check multicast and broadcast */
-		NFP_INC(port, mac_mcast);
-		return MV_TERMINATE;
-	}
-
-	pIpHdr->ipOffset = NETA_RX_GET_IPHDR_OFFSET(pRxDesc);
-	pIpHdr->ipHdrLen =  NETA_RX_GET_IPHDR_HDRLEN(pRxDesc) << 2;
-
-	if (NETA_RX_L3_IS_IP6(pRxDesc->status)) {
-		pIpHdr->family = MV_INET6;
-		pIpHdr->ip_hdr.ip6 = (MV_IP6_HEADER *) (pData + pIpHdr->ipOffset);
-		if ((pIpHdr->ip_hdr.ip6)->hoplimit <= 1) {
-			NFP_INC(port, ttl_exp);
-			return MV_TERMINATE;
-		}
-		pIpHdr->ipLen = MV_16BIT_BE(pIpHdr->ip_hdr.ip6->payloadLength);
-		pIpHdr->ipProto = pIpHdr->ip_hdr.ip6->protocol;
-
-		NFP_INC(port, ipv6);
-	} else {
-		pIpHdr->family = MV_INET;
-		pIpHdr->ip_hdr.ip4 = (MV_IP_HEADER *) (pData + pIpHdr->ipOffset);
-		pIpHdr->ipLen = MV_16BIT_BE(pIpHdr->ip_hdr.ip4->totalLength);
-		pIpHdr->ipProto = pIpHdr->ip_hdr.ip4->protocol;
-
-#ifdef NFP_CT
-		if (nfpMode == MV_NFP_5_TUPLE) {
-			if (NETA_RX_IP_IS_FRAG(pRxDesc->status)) {
-				NFP_INC(port, ipv4_rx_frag);
-				return MV_TERMINATE;
-			}
-		}
-#endif /* NFP_CT */
-
-		if ((pIpHdr->ip_hdr.ip4)->ttl <= 1) {
-			NFP_INC(port, ttl_exp);
-			return MV_TERMINATE;
-		}
-		NFP_INC(port, ipv4);
-	}
-	return MV_CONTINUE;
-}
-
-static INLINE MV_STATUS mvNfpFragmentCheck(int port, MV_IP_HEADER_INFO *pIpInfo, NFP_IF_MAP *pOutIf)
-{
-	if (needFragment(pIpInfo, pOutIf)) {
-		if ((pIpInfo->family == MV_INET) &&
-			(pIpInfo->ip_hdr.ip4->fragmentCtrl & MV_16BIT_BE(MV_IP4_DF_FLAG_MASK))) {
-			NFP_INC(port, ip_tx_frag_err);
-			return MV_TERMINATE;
-		}
-		NFP_INC(port, ip_tx_frag);
-	}
-	return MV_CONTINUE;
-}
-
-#ifdef NFP_CLASSIFY
-MV_STATUS mvNfpClassifyModeSet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_MODE mode)
-{
-	if ((feature < MV_NFP_CLASSIFY_FEATURE_DSCP) || (feature > MV_NFP_CLASSIFY_FEATURE_MH)) {
-		mvOsPrintf("%s: Illegal feature value %d\n", __func__, feature);
-		return MV_BAD_PARAM;
-	}
-
-	if ((mode < MV_NFP_CLASSIFY_MODE_DISABLED) || (mode > MV_NFP_CLASSIFY_MODE_LOWEST)) {
-		mvOsPrintf("%s: Illegal mode value %d\n", __func__, mode);
-		return MV_BAD_PARAM;
-	}
-
-	classifyMode[feature] = mode;
-	return MV_OK;
-}
-
-MV_NFP_CLASSIFY_MODE mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE feature)
-{
-	if ((feature < MV_NFP_CLASSIFY_FEATURE_DSCP) || (feature >= MV_NFP_CLASSIFY_FEATURE_INVALID)) {
-		mvOsPrintf("%s: Illegal feature value %d\n", __func__, feature);
-		return MV_NFP_CLASSIFY_MODE_INVALID;
-	}
-	return classifyMode[feature];
-}
-
-MV_STATUS mvNfpExactPolicySet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_POLICY policy)
-{
-	if ((feature < MV_NFP_CLASSIFY_FEATURE_DSCP) || (feature > MV_NFP_CLASSIFY_FEATURE_MH)) {
-		mvOsPrintf("%s: Illegal feature value %d\n", __func__, feature);
-		return MV_BAD_PARAM;
-	}
-
-	if ((policy < MV_NFP_CLASSIFY_POLICY_HIGHEST) || (policy > MV_NFP_CLASSIFY_POLICY_LAST)) {
-		mvOsPrintf("%s: Illegal policy value %d\n", __func__, policy);
-		return MV_BAD_PARAM;
-	}
-
-	exactPolicy[feature] = policy;
-	return MV_OK;
-}
-
-MV_NFP_CLASSIFY_POLICY mvNfpExactPolicyGet(MV_NFP_CLASSIFY_FEATURE feature)
-{
-	if ((feature < MV_NFP_CLASSIFY_FEATURE_DSCP) || (feature > MV_NFP_CLASSIFY_FEATURE_MH)) {
-		mvOsPrintf("%s: Illegal feature value %d\n", __func__, feature);
-		return MV_NFP_CLASSIFY_POLICY_INVALID;
-	}
-
-	return exactPolicy[feature];
-}
-
-MV_STATUS mvNfpPrioPolicySet(MV_NFP_CLASSIFY_POLICY policy)
-{
-	if ((policy < MV_NFP_CLASSIFY_POLICY_HIGHEST) || (policy > MV_NFP_CLASSIFY_POLICY_LOWEST)) {
-		mvOsPrintf("%s: Illegal policy value %d\n", __func__, policy);
-		return MV_NFP_CLASSIFY_POLICY_INVALID;
-	}
-
-	prioPolicy = policy;
-	return MV_OK;
-}
-
-MV_NFP_CLASSIFY_POLICY mvNfpPrioPolicyGet(MV_VOID)
-{
-	return prioPolicy;
-}
-
-
-/* Priority classification API */
-MV_STATUS mvNfpIifToPrioSet(int iif, MV_U8 prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio < NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(iif);
-	if (!ifMap) {
-		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
-		return MV_BAD_PARAM;
-	}
-	ifMap->prio = prio;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIifVlanToPrioSet(int iif, MV_U8 vlan_prio, MV_U8 prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio < NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-	if (vlan_prio < NFP_VPRI_MIN || vlan_prio > NFP_VPRI_MAX) {
-		NFP_WARN("%s: vlan_prio #%d is invalid.\n", __func__, vlan_prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(iif);
-	if (!ifMap) {
-		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
-		return MV_BAD_PARAM;
-	}
-	ifMap->vpri_to_prio[vlan_prio].prio = prio;
-	ifMap->vpri_to_prio[vlan_prio].valid = 1;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIifDscpToPrioSet(int iif, MV_U8 dscp, MV_U8 prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio < NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-	if (dscp < NFP_DSCP_MIN || dscp > NFP_DSCP_MAX) {
-		NFP_WARN("%s: dscp #%d is invalid.\n", __func__, dscp);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(iif);
-	if (!ifMap) {
-		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
-		return MV_BAD_PARAM;
-	}
-	ifMap->dscp_to_prio[dscp].prio = prio;
-	ifMap->dscp_to_prio[dscp].valid = 1;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIifToPrioDel(int iif)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	ifMap = mvNfpIfMapGet(iif);
-	if (!ifMap) {
-		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
-		return MV_BAD_PARAM;
-	}
-	ifMap->prio = NFP_PRIO_INVALID;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIifVlanToPrioDel(int iif, MV_U8 vlan_prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (vlan_prio < NFP_VPRI_MIN || vlan_prio > NFP_VPRI_MAX) {
-		NFP_WARN("%s: vlan_prio #%d is invalid.\n", __func__, vlan_prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(iif);
-	if (!ifMap) {
-		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
-		return MV_BAD_PARAM;
-	}
-	ifMap->vpri_to_prio[vlan_prio].prio = NFP_PRIO_INVALID;
-	ifMap->vpri_to_prio[vlan_prio].valid = 0;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIifDscpToPrioDel(int iif, MV_U8 dscp)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (dscp < NFP_DSCP_MIN || dscp > NFP_DSCP_MAX) {
-		NFP_WARN("%s: dscp #%d is invalid.\n", __func__, dscp);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(iif);
-	if (!ifMap) {
-		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
-		return MV_BAD_PARAM;
-	}
-	ifMap->dscp_to_prio[dscp].prio = NFP_PRIO_INVALID;
-	ifMap->dscp_to_prio[dscp].valid = 0;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToDscpSet(int oif, MV_U8 prio, MV_U8 dscp)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-	if (dscp < NFP_DSCP_MIN || dscp > NFP_DSCP_MAX) {
-		NFP_WARN("%s: dscp #%d is invalid.\n", __func__, dscp);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].dscp = dscp;
-	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_DSCP;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToVprioSet(int oif, MV_U8 prio, MV_U8 vlan_prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-	if (vlan_prio < NFP_VPRI_MIN || vlan_prio > NFP_VPRI_MAX) {
-		NFP_WARN("%s: vlan_prio #%d is invalid.\n", __func__, vlan_prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].vprio = vlan_prio;
-	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_VPRIO;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToTxpSet(int oif, MV_U8 prio, MV_U8 txp)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].txp = txp;
-	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_TXP;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToTxqSet(int oif, MV_U8 prio, MV_U8 txq)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-	if (txq >= CONFIG_MV_ETH_TXQ) {
-		NFP_WARN("%s: txq #%d is invalid.\n", __func__, txq);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].txq = txq;
-	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_TXQ;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToMhSet(int oif, MV_U8 prio, MV_U16 mh)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].mh = mh;
-	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_MH;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToDscpDel(int oif, MV_U8 prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_DSCP;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToVprioDel(int oif, MV_U8 prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_VPRIO;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToTxpDel(int oif, MV_U8 prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_TXP;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToTxqDel(int oif, MV_U8 prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_TXQ;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpPrioToMhDel(int oif, MV_U8 prio)
-{
-	NFP_IF_MAP *ifMap   = NULL;
-
-	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
-		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap) {
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-		return MV_BAD_PARAM;
-	}
-
-	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_MH;
-
-	return MV_OK;
-}
-
-
-MV_VOID mvNfpIngressPrioDump(int iif)
-{
-	int i;
-	NFP_IF_MAP *ifMap   = NULL;
-
-	ifMap = mvNfpIfMapGet(iif);
-	if (!ifMap)
-		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
-
-	mvOsPrintf("ingress interface #%d prio dump\n\n", iif);
-
-	if (ifMap->prio != NFP_PRIO_INVALID)
-		mvOsPrintf("interface priority = %d\n\n", ifMap->prio);
-	else
-		mvOsPrintf("interface priority = invalid (no priority)\n\n");
-
-
-	mvOsPrintf("interface + DSCP to priority Map: \n");
-	mvOsPrintf("      DSCP       Priority\n");
-	for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++) {
-		if (ifMap->dscp_to_prio[i].valid) {
-			if (i == NFP_DSCP_MAP_GLOBAL)
-				mvOsPrintf("      Global     %2d\n", ifMap->dscp_to_prio[i].prio);
-			else
-				mvOsPrintf("      %2d         %2d\n", i, ifMap->dscp_to_prio[i].prio);
-		}
-	}
-
-	mvOsPrintf("\ninterface + Vpri to priority Map: \n");
-	mvOsPrintf("      Vpri       Priority\n");
-	for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++) {
-		if (ifMap->vpri_to_prio[i].valid) {
-			if (i == NFP_VPRI_MAP_GLOBAL)
-				mvOsPrintf("      Global     %2d\n", ifMap->vpri_to_prio[i].prio);
-			else
-				mvOsPrintf("      %2d         %2d\n", i, ifMap->vpri_to_prio[i].prio);
-		}
-	}
-}
-
-MV_VOID mvNfpEgressPrioDump(int oif)
-{
-	int i;
-	NFP_IF_MAP *ifMap   = NULL;
-
-	ifMap = mvNfpIfMapGet(oif);
-	if (!ifMap)
-		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
-
-	mvOsPrintf("egress interface #%d prio dump\n\n", oif);
-	mvOsPrintf("interface + prio to classification data Map: \n");
-	mvOsPrintf("      Prio        DSCP        Vpri        TXP         TXQ         MH\n");
-	for (i = 0; i < NFP_PRIO_MAP_SIZE; i++) {
-		if (ifMap->prio_to_classify[i].flags) {
-			mvOsPrintf("      %2d", i);
-
-			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_DSCP)
-				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].dscp);
-			else
-				mvOsPrintf("            ");
-			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_VPRIO)
-				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].vprio);
-			else
-				mvOsPrintf("            ");
-			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_TXP)
-				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].txp);
-			else
-				mvOsPrintf("            ");
-			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_TXQ)
-				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].txq);
-			else
-				mvOsPrintf("            ");
-			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_MH)
-				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].mh);
-			mvOsPrintf("\n");
-		}
-	}
-}
-
-static INLINE MV_VOID mvNfpClassifyIifToPrioSave(NFP_IF_MAP *pInIf, NFP_CLASSIFY_INFO *info)
-{
-	info->iif_prio = pInIf->prio;
-}
-
-static INLINE MV_VOID mvNfpClassifyIifVprioToPrioSave(NFP_IF_MAP *pInIf, NFP_CLASSIFY_INFO *info)
-{
-	MV_U8 vprio = info->pkt_vlan_prio;
-	MV_U8 valid = pInIf->vpri_to_prio[vprio].valid;
-
-	info->iif_vlan_prio = (valid) ? pInIf->vpri_to_prio[vprio].prio : NFP_PRIO_INVALID;
-
-}
-
-static INLINE MV_VOID mvNfpClassifyIifDscpToPrioSave(NFP_IF_MAP *pInIf, NFP_CLASSIFY_INFO *info)
-{
-	MV_U8 dscp = info->pkt_dscp;
-	MV_U8 valid = pInIf->dscp_to_prio[dscp].valid;
-
-	info->iif_dscp_prio = (valid) ? pInIf->dscp_to_prio[dscp].prio : NFP_PRIO_INVALID;
-}
-#endif /* NFP_CLASSIFY */
-
-
-static INLINE MV_STATUS mvNfpTwoTupleProcess(MV_U32 port, MV_IP_HEADER_INFO *pIpHdr,
-					     MV_ETH_PKT *pPkt, NFP_RULE_FIB **pFib)
-{
-	MV_U8		*srcL3, *dstL3;
-
-	if (pIpHdr->family == MV_INET) {
-		/* Remove padding */
-		pPkt->bytes = (pIpHdr->ipLen + pIpHdr->ipOffset);
-
-		dstL3 = (MV_U8 *)&(pIpHdr->ip_hdr.ip4->dstIP);
-		srcL3 = (MV_U8 *)&(pIpHdr->ip_hdr.ip4->srcIP);
-	} else {
-		dstL3 = pIpHdr->ip_hdr.ip6->dstAddr;
-		srcL3 = pIpHdr->ip_hdr.ip6->srcAddr;
-	}
-
-	*pFib = mvNfpFibLookup(pIpHdr->family, srcL3, dstL3);
-
-	if (!(*pFib)) {
-		NFP_WARN("%s failed: ", __func__);
-		mvNfp2TupleInfoPrint(NFP_WARN_PRINT, pIpHdr->family, srcL3, dstL3);
-
-		NFP_INC(port, fib_miss);
-		return MV_TERMINATE;
-	}
-	(*pFib)->age++;
-
-	NFP_INC(port, fib_hit);
-
-	return MV_CONTINUE;
-}
-
-#ifdef NFP_CT
-
-#ifdef NFP_CT_LEARN
-/* Check for FIN/RST flags in TCP header */
-static INLINE MV_U8 mvNfpTcpClose(MV_IP_HEADER_INFO *pIpHdr)
-{
-	MV_TCP_HEADER	*pTcpHdr;
-
-	if (pIpHdr->ipProto != MV_IP_PROTO_TCP)
-		return 0;
-
-	pTcpHdr = (MV_TCP_HEADER *)((unsigned)(pIpHdr->ip_hdr.l3) + pIpHdr->ipHdrLen);
-
-	return (MV_16BIT_BE(pTcpHdr->flags) & (MV_TCP_FLAG_RST | MV_TCP_FLAG_FIN));
-}
-#endif /* NFP_CT_LEARN */
-
-static INLINE MV_STATUS mvNfpFiveTupleProcess(MV_U32 port, MV_IP_HEADER_INFO *pIpHdr,
-					      MV_ETH_PKT *pPkt, NFP_RULE_CT **ppCt,
-					      MV_NFP_RESULT *pRes)
-{
-	NFP_RULE_CT	*pCt = NULL;
-	MV_U8		*srcL3, *dstL3;
-	MV_U16 		proto = 0;
-	MV_U32		ports = 0;
-
-	if (pIpHdr->family == MV_INET) {
-		MV_IP_HEADER *pIph = pIpHdr->ip_hdr.ip4;
-
-		/* Remove padding */
-		pPkt->bytes = (pIpHdr->ipLen + pIpHdr->ipOffset);
-
-		dstL3 = (MV_U8 *)&(pIph->dstIP);
-		srcL3 = (MV_U8 *)&(pIph->srcIP);
-		proto = pIph->protocol;
-		ports = *(MV_U32 *)((char *)pIph + pIpHdr->ipHdrLen);
-	} else {
-		MV_IP6_HEADER *pIp6Hdr = pIpHdr->ip_hdr.ip6;
-
-		srcL3 = pIp6Hdr->srcAddr;
-		dstL3 = pIp6Hdr->dstAddr;
-		proto = pIp6Hdr->protocol;
-		ports = *(MV_U32 *)((char *)pIp6Hdr + pIpHdr->ipHdrLen);
-	}
-	pCt = mvNfpCtLookupByTuple(pIpHdr->family, srcL3, dstL3, ports, proto);
-
-	if (!pCt) {
-		NFP_WARN("%s failed: ", __func__);
-		mvNfp5TupleInfoPrint(NFP_WARN_PRINT, pIpHdr->family, srcL3, dstL3,
-					MV_16BIT_BE(ports & 0xFFFF), MV_16BIT_BE((ports >> 16) & 0xFFFF), proto);
-
-		NFP_INC(port, ct_miss);
-		return MV_TERMINATE;
-	}
-	pCt->age++;
-	pCt->hit_cntr++;
-	NFP_INC(port, ct_hit);
-
-#ifdef NFP_CT_LEARN
-	if (mvNfpTcpClose(pIpHdr)) {
-		NFP_INC(port, ct_tcp_fin_rst);
-		return MV_TERMINATE;
-	}
-#endif /* NFP_CT_LEARN */
-
-	if (pCt->flags & NFP_F_CT_DROP)
-		return MV_DROPPED;
-
-	*ppCt = pCt;
-
-#ifdef NFP_CLASSIFY
-	{
-		int txq = 0;
-		NFP_CLASSIFY_INFO *classifyInfo = (NFP_CLASSIFY_INFO *)(pRes->privateData);
-
-		if (pCt->flags & NFP_F_CT_SET_DSCP)
-			mvNfpDscpClassifySave(pCt, classifyInfo);
-		if (pCt->flags & NFP_F_CT_SET_VLAN_PRIO)
-			mvNfpVpriCtClassifySave(pCt, classifyInfo);
-
-		/* classifyInfo->pkt_dscp is updated in mvNfpDscpClassifySave so it is valid here */
-		if (pCt->txq_map[classifyInfo->pkt_dscp].valid)
-			txq = pCt->txq_map[classifyInfo->pkt_dscp].txq;
-		else if (pCt->txq_map[NFP_DSCP_MAP_GLOBAL].valid)
-			txq = pCt->txq_map[NFP_DSCP_MAP_GLOBAL].txq;
-
-		if (pCt->flags & NFP_F_CT_SET_TXQ)
-			mvNfpTxqClassifySave(txq, classifyInfo);
-		if (pCt->flags & NFP_F_CT_SET_TXP)
-			mvNfpTxpClassifySave(pCt->txp, classifyInfo);
-		if (pCt->flags & NFP_F_CT_SET_MH)
-			mvNfpMhClassifySave(pCt->mh, classifyInfo);
-	}
-#endif /* NFP_CLASSIFY */
-#ifdef NFP_LIMIT
-	if (pCt->tbfInfo)
-		return mvNfpTbfProcess(pCt->tbfInfo, pPkt->bytes);
-#endif /* NFP_LIMIT */
-	return MV_CONTINUE;
-}
-#endif /* NFP_CT */
-
- /* NFP Process */
-MV_STATUS mvNfpRx(MV_U32 port, NETA_RX_DESC *pRxDesc, MV_ETH_PKT *pPkt, MV_NFP_RESULT *pRes)
-{
-	NFP_RULE_FIB      *pFib;
-	MV_U8             *pData;
-	MV_IP_HEADER_INFO *ipHdrInfo = &pRes->ipInfo;
-	int               shift = 0;
-	MV_STATUS         status;
-	NFP_IF_MAP        *pInIf, *pOutIf;
-#ifdef NFP_CT
-	NFP_RULE_CT       *pCt = NULL;
-#endif /* NFP_CT */
-#ifdef NFP_CLASSIFY
-	int prio;
-	NFP_CLASSIFY_INFO classifyInfo;
-
-	mvOsMemset(&classifyInfo, 0, sizeof(NFP_CLASSIFY_INFO));
-	mvNfpClassifyInit(&classifyInfo);
-	pRes->privateData = &classifyInfo;
-#endif /* NFP_CLASSIFY */
-	NFP_INC(port, rx);
-	pData = pPkt->pBuf + pPkt->offset;
-	pRes->flags = 0;
-	pRes->shift = 0;
-	pRes->tx_cmd = NETA_TX_L4_CSUM_NOT;
-
-	/* Lookup incoming interface (port + switchGroup) */
-	pInIf = mvNfpIfMapRealGet(port, pData);
-	if (pInIf == NULL) {
-		NFP_INC(port, iif_err);
-		return MV_TERMINATE;
-	}
-
-#ifdef NFP_CLASSIFY
-	/* map iif to prio */
-	mvNfpClassifyIifToPrioSave(pInIf, &classifyInfo);
-#endif /* NFP_CLASSIFY */
-
-#ifdef NFP_VLAN
-	status = mvNfpVlanRx(port, pRxDesc, pData, pPkt, &pInIf, pRes);
-	if (status != MV_CONTINUE)
-		return status;
-#endif /* NFP_VLAN */
-
-#ifdef NFP_CLASSIFY
-	/* map iif + vlan to prio */
-	mvNfpClassifyIifVprioToPrioSave(pInIf, &classifyInfo);
-#endif /* NFP_CLASSIFY */
-
-#ifdef NFP_BRIDGE
-	if (pInIf->flags & NFP_F_MAP_BRIDGE_PORT) {
-		/* Do bridging: OK - bridging, TERMINATE - slow path, CONTINUE - Routing */
-		status = mvNfpBridgeRx(port, pRxDesc, pInIf, pPkt, pRes);
-		if (status != MV_CONTINUE)
-			return status;
-	}
-#endif /* NFP_BRIDGE */
-
-	status = mvNfpStatusCheck(port, pRxDesc);
-	if (status != MV_CONTINUE)
-		return status;
-
-	status = mvNfpParseIpHeader(port, pRxDesc, pData, ipHdrInfo);
-	if (status != MV_CONTINUE)
-		return status;
-
-	pRes->flags |= MV_NFP_RES_IP_INFO_VALID;
-
-#ifdef NFP_PPP
-		status = mvNfpPppRx(port, pRxDesc, pData, pPkt, &pInIf,  ipHdrInfo);
-		if (status != MV_CONTINUE)
-			return status;
-#endif /* NFP_PPP */
-#ifdef NFP_CLASSIFY
-	mvNfpPktDscpClassifySave(ipHdrInfo, &classifyInfo);
-#endif /* NFP_CLASSIFY */
-	if (nfpMode == MV_NFP_2_TUPLE) {
-		status = mvNfpTwoTupleProcess(port, ipHdrInfo, pPkt, &pFib);
-		if (status != MV_CONTINUE)
-			return status;
-	} else {
-#ifdef NFP_CT
-		status = mvNfpFiveTupleProcess(port, ipHdrInfo, pPkt, &pCt, pRes);
-		if (status != MV_CONTINUE)
-			return status;
-
-		pFib = pCt->fib;
-		pFib->age++;
-#else
-		return MV_TERMINATE;
-#endif /* NFP_CT */
-	}
-#ifdef NFP_CLASSIFY
-	/* map iif + dscp to prio */
-	mvNfpClassifyIifDscpToPrioSave(pInIf, &classifyInfo);
-#endif /* NFP_CLASSIFY */
-	/* At this point pFib is valid */
-	pOutIf = mvNfpIfMapGet(pFib->oif);
-	if (pOutIf == NULL) {
-		mvOsPrintf("%s: fib out interface %d is not valid\n", __func__, pFib->oif);
-		NFP_INC(port, oif_err);
-		return MV_TERMINATE;
-	}
-
-	/* Check if fragmentation needed but don't fragment bit is set */
-	status = mvNfpFragmentCheck(port, ipHdrInfo, pOutIf);
-	if (status != MV_CONTINUE)
-		return status;
-
-	pRes->mtu = pOutIf->mtu;
-	pRes->pWrite = ((MV_U8 *)ipHdrInfo->ip_hdr.l3) + ipHdrInfo->ipHdrLen;
-
-#ifdef NFP_NAT
-	if (pCt && (pCt->flags & (NFP_F_CT_SNAT | NFP_F_CT_DNAT)))
-		mvNfpNatUpdate(ipHdrInfo, pCt, pRes, pOutIf);
-#endif /* NFP_NAT */
-
-	mvNfpFibIpUpdate(ipHdrInfo);
-
-#ifdef NFP_PPP
-	shift = mvNfpPppTxUpdate(port, pRxDesc, pOutIf, pPkt, ipHdrInfo);
-	if (pOutIf->flags & NFP_F_MAP_PPPOE)
-		pOutIf = pOutIf->parentIf;
-#endif /* NFP_PPP */
-
-#ifdef NFP_CLASSIFY
-	prio = mvNfpClassifyPrioGet(&classifyInfo);
-	if (prio != NFP_PRIO_INVALID)
-		mvNfpClassifyPrioSave(pOutIf, &classifyInfo, prio);
-#endif /* NFP_CLASSIFY */
-
-#ifdef NFP_VLAN
-	shift += mvNfpVlanTxUpdate(port, pRxDesc, pOutIf, pData + shift, pPkt, MV_FALSE, pRes);
-#endif /* NFP_VLAN */
-
-	mvNfpFibMacUpdate(pData + shift, pFib);
-
-	while (pOutIf->parentIf)
-		pOutIf = pOutIf->parentIf;
-
-	pRes->dev = pOutIf->dev;
-	if (pOutIf->flags & NFP_F_MAP_EXT)
-		pRes->flags |= MV_NFP_RES_NETDEV_EXT;
-
-#ifdef NFP_CLASSIFY
-	/* Update packet according to classification results */
-
-#ifdef NFP_CT
-	mvNfpDscpClassifyUpdate(ipHdrInfo, &classifyInfo);
-#endif /* NFP_CT */
-
-	/* allow setting MH only for PON ports */
-	if (MV_PON_PORT(pOutIf->port))
-		mvNfpMhClassifyUpdate(pData + shift, &classifyInfo);
-
-	if (classifyInfo.flags & NFP_F_SET_TXQ)
-		mvNfpTxqClassifyUpdate(pRes, &classifyInfo);
-
-	/* allow setting txp only for PON ports */
-	if (MV_PON_PORT(pOutIf->port))
-		mvNfpTxpClassifyUpdate(pRes, &classifyInfo);
-
-#endif /* NFP_CLASSIFY */
-
-	/* Process 2B of MH */
-	if (!(pOutIf->flags & NFP_F_MAP_TX_MH)) {
-		shift += MV_ETH_MH_SIZE;
-		pPkt->bytes -= MV_ETH_MH_SIZE;
-	}
-	pRes->shift = shift;
-
-	if ((pRes->flags & (MV_NFP_RES_L4_CSUM_NEEDED | MV_NFP_RES_NETDEV_EXT)) == 0) {
-
-		/* Flush maximum accessed data before TX */
-		if (shift < 0)
-			pData += shift;
-
-		mvOsCacheMultiLineFlushInv(NULL, pData, (pRes->pWrite - pData));
-	}
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIfMapCreate(NFP_IF_MAP *ifMap2)
-{
-	MV_U32      flags;
-	NFP_IF_MAP  *newMap, *ifMap;
-
-	newMap = mvOsMalloc(sizeof(NFP_IF_MAP));
-	if (newMap == NULL) {
-		mvOsPrintf("%s: can't allocate NFP_IF_MAP\n", __func__);
-		return MV_NO_RESOURCE;
-	}
-	memcpy(newMap, ifMap2, sizeof(NFP_IF_MAP));
-	flags = newMap->flags;
-
-	if (!(flags & NFP_F_MAP_INT))
-		newMap->port = NFP_INVALID_PORT;
-
-	if (flags & NFP_F_MAP_EXT) {
-		if (nfpFreeExtPort >= NFP_MAX_PORTS) {
-			mvOsPrintf("%s: No free place for external interface. nfpFreeExtPort=%d\n",
-				__func__, nfpFreeExtPort);
-			mvOsFree(newMap);
-			return MV_BUSY;
-		}
-		newMap->port = nfpFreeExtPort;
-		nfpFreeExtPort++;
-	}
-
-	if (flags & NFP_F_MAP_SWITCH_PORT) {
-		/* Set MH flag for port */
-		nfp_ports[newMap->port] |= NFP_F_PORT_MH;
-	} else
-		newMap->switchGroup = NFP_INVALID_SWITCH_GROUP;
-
-	if (!(flags & NFP_F_MAP_TX_MH))
-		newMap->txMh = 0;
-
-	newMap->vlanId = NFP_INVALID_VLAN;
-#ifdef NFP_CLASSIFY
-	newMap->prio = NFP_PRIO_INVALID;
-#endif /* NFP_CLASSIFY */
-
-	/* Check if such entry already exist */
-	ifMap = nfp_if_map[newMap->ifIdx & NFP_DEV_HASH_MASK];
-	while (ifMap) {
-		if (ifMap->ifIdx == newMap->ifIdx) {
-			mvOsPrintf("%s: ifMap for ifIdx=%d already exist\n", __func__, newMap->ifIdx);
-			mvOsFree(newMap);
-			return MV_BUSY;
-		}
-		if (mvNfpIfMapCmp(newMap->port, newMap->switchGroup, ifMap)) {
-			mvOsPrintf("%s: ifMap with port=%d, switchGroup=%d already exist\n",
-					__func__, newMap->port, newMap->switchGroup);
-			mvOsFree(newMap);
-			return MV_BUSY;
-		}
-		ifMap = ifMap->nextMap;
-	}
-	/* Add to nfp_if_map */
-	newMap->nextMap = nfp_if_map[newMap->ifIdx & NFP_DEV_HASH_MASK];
-	nfp_if_map[newMap->ifIdx & NFP_DEV_HASH_MASK] = newMap;
-
-	/* Add to nfp_if_real_map */
-	if (newMap->port != NFP_INVALID_PORT) {
-		if (newMap->switchGroup == NFP_INVALID_SWITCH_GROUP)
-			nfp_if_real_map[newMap->port][0] = newMap;
-		else
-			nfp_if_real_map[newMap->port][newMap->switchGroup] = newMap;
-	}
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIfVirtMap(int ifIdx, int virtIf)
-{
-	NFP_IF_MAP *ifMap = mvNfpIfMapGet(ifIdx);
-	NFP_IF_MAP *ifVirt = mvNfpIfMapGet(virtIf);
-	NFP_IF_MAP *ifTemp;
-
-	/* parentIf and virtIf must be created */
-	if ((ifMap == NULL) || (ifVirt == NULL)) {
-		mvOsPrintf("%s: interface not valid - parent=%d (%p), virt=%d (%p)\n",
-				__func__, ifIdx, ifMap, virtIf, ifVirt);
-		return MV_NOT_FOUND;
-	}
-	/* Check validity - TBD */
-
-	/* Set MH as in parent interface */
-	ifVirt->txMh = ifMap->txMh;
-	/* Set external flag if parent is external */
-	if (ifMap->flags & NFP_F_MAP_EXT)
-		ifVirt->flags |= NFP_F_MAP_EXT;
-
-	/* Bind */
-	ifTemp = ifMap->virtIf;
-	ifMap->virtIf = ifVirt;
-	ifVirt->virtNext = ifTemp;
-
-	/* Remember parent interface */
-	ifVirt->parentIf = ifMap;
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIfVirtUnmap(int virtIf)
-{
-	NFP_IF_MAP *ifVirt = mvNfpIfMapGet(virtIf);
-	NFP_IF_MAP *ifUp, *ifTemp;
-
-	if (ifVirt == NULL) {
-		mvOsPrintf("%s: virtual interface is not valid - virt=%d\n",
-				__func__, virtIf);
-		return MV_NOT_FOUND;
-	}
-
-	if (ifVirt->virtIf != NULL) {
-		mvOsPrintf("%s: Can't unmap (%s), virtual interface %s was created\n",
-			__func__, ifVirt->name, ifVirt->virtIf->name);
-		return MV_NOT_FOUND;
-	}
-
-	ifUp = ifVirt->parentIf;
-
-	if (ifUp == NULL) {
-		mvOsPrintf("%s: Can't unmap (%s), parentIf is NULL\n", __func__, ifVirt->name);
-		return MV_NOT_FOUND;
-	}
-
-	ifTemp = ifUp->virtIf;
-	if (ifTemp == ifVirt) {
-		ifUp->virtIf = ifVirt->virtNext;
-		/* FIXME: PPPoE over VLAN */
-		return MV_OK;
-	}
-
-	while (ifTemp->virtNext != NULL) {
-		if (ifTemp->virtNext == ifVirt) {
-			ifTemp->virtNext = ifVirt->virtNext;
-			/* FIXME: PPPoE over VLAN */
-			return MV_OK;
-		}
-		ifTemp = ifTemp->virtNext;
-	}
-
-	mvOsPrintf("%s: virtual interface %d is not mapped to interface %d\n",
-				__func__, virtIf, ifUp->ifIdx);
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpIfFlagsSet(int ifIdx, MV_U32 flags)
-{
-	NFP_IF_MAP *ifMap = mvNfpIfMapGet(ifIdx);
-
-	if (ifMap == NULL) {
-		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIdx);
-		return MV_NOT_FOUND;
-	}
-	ifMap->flags |= flags;
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIfFlagsClear(int ifIdx, MV_U32 flags)
-{
-	NFP_IF_MAP *ifMap = mvNfpIfMapGet(ifIdx);
-
-	if (ifMap == NULL) {
-		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIdx);
-		return MV_NOT_FOUND;
-	}
-	ifMap->flags &= ~flags;
-	return MV_OK;
-}
-
-MV_STATUS mvNfpIfMapMacUpdate(int ifIdx, const MV_U8 *mac)
-{
-	NFP_IF_MAP *map = mvNfpIfMapGet(ifIdx);
-
-	if (map != NULL) {
-		mvOsMemcpy(map->mac, mac, MV_MAC_ADDR_SIZE);
-		return MV_OK;
-	}
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpIfMapMtuUpdate(int ifIdx, int mtu)
-{
-	NFP_IF_MAP *map = mvNfpIfMapGet(ifIdx);
-
-	if (map != NULL) {
-		map->mtu = mtu;
-		return MV_OK;
-	}
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpIfMapPortGet(int ifIdx, int *port)
-{
-	NFP_IF_MAP *ifMap = mvNfpIfMapGet(ifIdx);
-
-	if (ifMap && (ifMap->port != NFP_INVALID_PORT)) {
-		*port = ifMap->port;
-		return MV_OK;
-	}
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpIfMapDelete(int ifIdx)
-{
-	MV_U32 hash = 0;
-	NFP_IF_MAP *currMap = NULL, *prevMap = NULL;
-
-	if ((ifIdx <= 0) || (mvNfpIfMapGet(ifIdx) == NULL)) {
-		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIdx);
-		return MV_BAD_PARAM;
-	}
-	hash = (ifIdx & NFP_DEV_HASH_MASK);
-
-	/* remove from nfp_if_map */
-	for (currMap = nfp_if_map[hash]; currMap != NULL; prevMap = currMap, currMap = currMap->nextMap) {
-		if (currMap->ifIdx == ifIdx) {
-			if (prevMap == NULL)
-				nfp_if_map[hash] = currMap->nextMap;
-			else
-				prevMap->nextMap = currMap->nextMap;
-
-			/* do not delete element yet, need to remove it from nfp_if_real_map */
-			break;
-		}
-	}
-
-	if (currMap) {
-		if (currMap->port != NFP_INVALID_PORT) {
-			/* remove from nfp_if_real_map */
-			if (currMap->switchGroup == NFP_INVALID_SWITCH_GROUP)
-				nfp_if_real_map[currMap->port][0] = NULL;
-			else
-				nfp_if_real_map[currMap->port][currMap->switchGroup] = NULL;
-		}
-		/* delete element */
-		mvOsFree(currMap);
-		return MV_OK;
-	}
-	return MV_NOT_FOUND;
-}
-
-#ifdef NFP_BRIDGE
-/* There are functions common for mvNfpBridge.c and for mvNfpFdb.c */
-MV_STATUS mvNfpIfToBridgeAdd(int bridgeIf, int portIf)
-{
-	NFP_IF_MAP  *portIfMap = mvNfpIfMapGet(portIf);
-	NFP_IF_MAP  *bridgeIfMap = mvNfpIfMapGet(bridgeIf);
-
-	if (bridgeIfMap == NULL) {
-		mvOsPrintf("%s: trying to add interface (%d) to non-registered bridge (%d)\n",
-			__func__, portIf, bridgeIf);
-		return MV_NOT_FOUND;
-	}
-	if (!(bridgeIfMap->flags & NFP_F_MAP_BRIDGE) || (bridgeIfMap->ifIdx != bridgeIf)) {
-		mvOsPrintf("%s: Wrong bridgeIf=%d\n", __func__, bridgeIf);
-		return MV_FAIL;
-	}
-
-	if (portIfMap != NULL) {
-		/* Check that port_if isn't already connected to an other bridge */
-		if ((portIfMap->flags & NFP_F_MAP_BRIDGE_PORT) && (portIfMap->bridgeIf != bridgeIf))
-			return MV_BUSY;
-
-		portIfMap->flags |= NFP_F_MAP_BRIDGE_PORT;
-		portIfMap->bridgeIf = bridgeIf;
-		return MV_OK;
-	}
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpIfToBridgeDel(int bridge_if, int port_if)
-{
-	NFP_IF_MAP  *portIfMap = mvNfpIfMapGet(port_if);
-
-	if (portIfMap != NULL) {
-		/* Check that port_if is connected to this bridge */
-		if (!(portIfMap->flags & NFP_F_MAP_BRIDGE_PORT) || (portIfMap->bridgeIf != bridge_if))
-			return MV_BAD_PARAM;
-
-		portIfMap->flags &= ~NFP_F_MAP_BRIDGE_PORT;
-		portIfMap->bridgeIf = 0;
-		return MV_OK;
-	}
-	return MV_NOT_FOUND;
-}
-
-MV_BOOL mvNfpIfOnSameBridge(NFP_IF_MAP *ifMap1, NFP_IF_MAP *ifMap2)
-{
-	if ((ifMap1 != NULL) && (ifMap2 != NULL)) {
-		/* first interface is bridge and second is port on the same bridge */
-		if ((ifMap1->flags & NFP_F_MAP_BRIDGE) &&
-			(ifMap2->flags & NFP_F_MAP_BRIDGE_PORT) &&
-			(ifMap1->ifIdx == ifMap2->bridgeIf))
-			return MV_TRUE;
-
-		/* second interface is bridge and first is port on the same bridge */
-		if ((ifMap1->flags & NFP_F_MAP_BRIDGE_PORT) &&
-			(ifMap2->flags & NFP_F_MAP_BRIDGE) &&
-			(ifMap1->bridgeIf == ifMap2->ifIdx))
-			return MV_TRUE;
-
-		/* two interfaces are ports of the same bridge */
-		if ((ifMap1->flags & NFP_F_MAP_BRIDGE_PORT) &&
-		    (ifMap2->flags & NFP_F_MAP_BRIDGE_PORT) &&
-		    (ifMap1->bridgeIf == ifMap2->bridgeIf))
-			return MV_TRUE;
-	}
-	return MV_FALSE;
-}
-#endif /* NFP_BRIDGE */
-
-MV_VOID mvNfpIpInfoPrint(u32 dbgLevel, int family, u8 *ipAddr)
-{
-	if (nfpDebugLevel & dbgLevel) {
-		if (family == MV_INET)
-			mvOsPrintf("IPv4: " MV_IPQUAD_FMT "\n",	MV_IPQUAD(ipAddr));
-		else
-			mvOsPrintf("IPv6: " MV_IP6_FMT "\n", MV_IP6_ARG(ipAddr));
-	}
-}
-
-MV_VOID mvNfp2TupleInfoPrint(u32 dbgLevel, int family, u8 *srcL3, u8 *dstL3)
-{
-	if (nfpDebugLevel & dbgLevel) {
-		if (family == MV_INET)
-			mvOsPrintf("IPv4: " MV_IPQUAD_FMT "->" MV_IPQUAD_FMT"\n",
-				MV_IPQUAD(srcL3), MV_IPQUAD(dstL3));
-		else
-			mvOsPrintf("IPv6: " MV_IP6_FMT "->" MV_IP6_FMT"\n",
-				MV_IP6_ARG(srcL3), MV_IP6_ARG(dstL3));
-	}
-}
-
-
-MV_VOID mvNfp5TupleInfoPrint(u32 dbgLevel, int family, u8 *srcL3, u8 *dstL3, u16 sport, u16 dport, u8 proto)
-{
-	if (nfpDebugLevel & dbgLevel) {
-		if (family == MV_INET)
-			mvOsPrintf("IPv4: " MV_IPQUAD_FMT ":%d->" MV_IPQUAD_FMT":%d",
-				MV_IPQUAD(srcL3), sport, MV_IPQUAD(dstL3), dport);
-		else
-			mvOsPrintf("IPv6: " MV_IP6_FMT ":%d->" MV_IP6_FMT":%d",
-				MV_IP6_ARG(srcL3), sport, MV_IP6_ARG(dstL3), dport);
-
-		if (proto == MV_IP_PROTO_TCP)
-			mvOsPrintf(", proto = TCP\n");
-		else if (proto == MV_IP_PROTO_UDP)
-			mvOsPrintf(", proto = UDP\n");
-		else
-			mvOsPrintf(", proto = Unknown (%d)\n", proto);
-	}
-}
-
-static void mvNfpIfMapPrint(NFP_IF_MAP *ifMap)
-{
-	mvOsPrintf(" %8s  %3d  %3d   %3d   %4d  0x%04x  "MV_MACQUAD_FMT"  %4d  %3d  %3d    0x%04x\n",
-				ifMap->name, ifMap->ifIdx, ifMap->port, ifMap->switchGroup, ifMap->vlanId,
-				ifMap->txMh, MV_MACQUAD(ifMap->mac), ifMap->mtu,
-				ifMap->bridgeIf, ifMap->parentIf ? ifMap->parentIf->ifIdx : ifMap->ifIdx, ifMap->flags);
-	if (ifMap->virtIf) {
-		NFP_IF_MAP *ifVirt = ifMap->virtIf;
-
-		mvOsPrintf("\t Virtual list: ");
-		while (ifVirt) {
-			mvOsPrintf(" %d,", ifVirt->ifIdx);
-			ifVirt = ifVirt->virtNext;
-		}
-		mvOsPrintf("\n");
-	}
-}
-
-MV_VOID mvNfpIfMapDump(void)
-{
-	int		i;
-	NFP_IF_MAP	*ifMap;
-
-	mvOsPrintf("\n(ifMap - direct)\n");
-	mvOsPrintf("[No]:      name   idx  port  swGr  vid   txMh           mac         mtu  brIf  upIf  flags\n");
-	for (i = 0; i < NFP_DEV_HASH_SZ; i++) {
-		ifMap = nfp_if_map[i];
-
-		while (ifMap != NULL) {
-			mvOsPrintf("[%2d]: ", i);
-			mvNfpIfMapPrint(ifMap);
-			ifMap = ifMap->nextMap;
-		}
-	}
-	mvOsPrintf("\n");
-	mvOsPrintf("(ifMap - Real)\n");
-	mvOsPrintf("[Port][Group]:      name  idx\n");
-	for (i = 0; i < NFP_MAX_PORTS; i++) {
-		int j;
-
-		for (j = 0; j < NFP_MAX_SWITCH_GROUPS; j++) {
-			ifMap = nfp_if_real_map[i][j];
-			if (ifMap != NULL)
-				mvOsPrintf("[%4d][%5d]:  %8s  %3d\n", i, j, ifMap->name, ifMap->ifIdx);
-		}
-	}
-}
-
-MV_VOID mvNfpStats(MV_U32 port)
-{
-	if ((port < 0) || (port >= NFP_MAX_PORTS)) {
-		mvOsPrintf("Invalid port number %d\n", port);
-		return;
-	}
-
-	mvOsPrintf("\n====================================================\n");
-	mvOsPrintf(" NFP statistics");
-	mvOsPrintf("\n----------------------------------------------------\n");
-
-#ifdef NFP_STAT
-	mvOsPrintf("nfp_rx........................%10u\n", nfp_stats[port].rx);
-	mvOsPrintf("nfp_iif_err...................%10u\n", nfp_stats[port].iif_err);
-	mvOsPrintf("nfp_oif_err...................%10u\n", nfp_stats[port].oif_err);
-
-#ifdef NFP_VLAN
-	mvOsPrintf("nfp_vlan_rx_tag_drop..........%10u\n", nfp_stats[port].vlan_rx_tag_drop);
-	mvOsPrintf("nfp_vlan_rx_untag_drop........%10u\n", nfp_stats[port].vlan_rx_untag_drop);
-	mvOsPrintf("nfp_vlan_rx_unknown_drop......%10u\n", nfp_stats[port].vlan_rx_unknown_drop);
-	mvOsPrintf("nfp_vlan_rx_found.............%10u\n", nfp_stats[port].vlan_rx_found);
-	mvOsPrintf("nfp_vlan_rx_trans.............%10u\n", nfp_stats[port].vlan_rx_trans);
-	mvOsPrintf("nfp_vlan_tx_add...............%10u\n", nfp_stats[port].vlan_tx_add);
-	mvOsPrintf("nfp_vlan_tx_remove............%10u\n", nfp_stats[port].vlan_tx_remove);
-	mvOsPrintf("nfp_vlan_tx_replace...........%10u\n", nfp_stats[port].vlan_tx_replace);
-#endif /* NFP_VLAN */
-
-#ifdef NFP_BRIDGE
-#ifdef NFP_FDB_MODE
-	mvOsPrintf("nfp_fdb_local.................%10u\n", nfp_stats[port].fdb_local);
-	mvOsPrintf("nfp_fdb_sa_miss...............%10u\n", nfp_stats[port].fdb_sa_miss);
-	mvOsPrintf("nfp_fdb_da_miss...............%10u\n", nfp_stats[port].fdb_da_miss);
-	mvOsPrintf("nfp_fdb_port_miss.............%10u\n", nfp_stats[port].fdb_port_miss);
-	mvOsPrintf("nfp_fdb_hit...................%10u\n", nfp_stats[port].fdb_hit);
-#else
-	mvOsPrintf("nfp_bridge_miss...............%10u\n", nfp_stats[port].bridge_miss);
-	mvOsPrintf("nfp_bridge_hit................%10u\n", nfp_stats[port].bridge_hit);
-	mvOsPrintf("nfp_bridge_local..............%10u\n", nfp_stats[port].bridge_local);
-#endif /* NFP_FDB_MODE */
-#endif /* NFP_BRIDGE */
-
-	mvOsPrintf("nfp_non_ip....................%10u\n", nfp_stats[port].non_ip);
-	mvOsPrintf("nfp_ipv4_csum_err.............%10u\n", nfp_stats[port].ipv4_csum_err);
-	mvOsPrintf("nfp_mac_mcast.................%10u\n", nfp_stats[port].mac_mcast);
-	mvOsPrintf("nfp_ttl_exp...................%10u\n", nfp_stats[port].ttl_exp);
-	mvOsPrintf("nfp_l4_unknown................%10u\n", nfp_stats[port].l4_unknown);
-	mvOsPrintf("nfp_l4_csum_err...............%10u\n", nfp_stats[port].l4_csum_err);
-	mvOsPrintf("nfp_ipv4......................%10u\n", nfp_stats[port].ipv4);
-	mvOsPrintf("nfp_ipv6......................%10u\n", nfp_stats[port].ipv6);
-	mvOsPrintf("nfp_ip_rx_frag................%10u\n", nfp_stats[port].ipv4_rx_frag);
-	mvOsPrintf("nfp_ip_tx_frag................%10u\n", nfp_stats[port].ip_tx_frag);
-	mvOsPrintf("nfp_ip_tx_frag_err............%10u\n", nfp_stats[port].ip_tx_frag_err);
-
-#ifdef NFP_PPP
-	mvOsPrintf("pppoe_rx_not_found............%10u\n", nfp_stats[port].pppoe_rx_not_found);
-	mvOsPrintf("pppoe_rx_found................%10u\n", nfp_stats[port].pppoe_rx_found);
-	mvOsPrintf("pppoe_tx_add..................%10u\n", nfp_stats[port].pppoe_tx_add);
-	mvOsPrintf("pppoe_tx_remove...............%10u\n", nfp_stats[port].pppoe_tx_remove);
-	mvOsPrintf("pppoe_tx_replace..............%10u\n", nfp_stats[port].pppoe_tx_replace);
-#endif /* NFP_PPP */
-
-#ifdef NFP_FIB
-	mvOsPrintf("nfp_fib_hit...................%10u\n", nfp_stats[port].fib_hit);
-	mvOsPrintf("nfp_fib_miss..................%10u\n", nfp_stats[port].fib_miss);
-#endif /* NFP_FIB */
-
-#ifdef NFP_CT
-	mvOsPrintf("nfp_ct_hit....................%10u\n", nfp_stats[port].ct_hit);
-	mvOsPrintf("nfp_ct_miss...................%10u\n", nfp_stats[port].ct_miss);
-	mvOsPrintf("nfp_ct_tcp_fin_rst............%10u\n", nfp_stats[port].ct_tcp_fin_rst);
-#ifdef NFP_NAT
-	mvOsPrintf("nfp_dnat_hit..................%10u\n", nfp_stats[port].dnat_hit);
-	mvOsPrintf("nfp_dnat_miss.................%10u\n", nfp_stats[port].dnat_miss);
-	mvOsPrintf("nfp_dnat_inv..................%10u\n", nfp_stats[port].dnat_inv);
-
-	mvOsPrintf("nfp_snat_hit..................%10u\n", nfp_stats[port].snat_hit);
-	mvOsPrintf("nfp_snat_miss.................%10u\n", nfp_stats[port].snat_miss);
-	mvOsPrintf("nfp_snat_inv..................%10u\n", nfp_stats[port].snat_inv);
-#endif /* NFP_NAT */
-#endif /* NFP_CT */
-
-	mvOsMemset(&nfp_stats[port], 0, sizeof(NFP_STATS));
-#endif /* NFP_STAT */
-}
--- a/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.h
+++ /dev/null
@@ -1,1143 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-/*******************************************************************************
-* mvNfp.h - Header File for Marvell NFP
-*
-* DESCRIPTION:
-*       This header file contains macros, typedefs and function declarations
-* 	specific to the Marvell Network Fast Processing.
-*
-* DEPENDENCIES:
-*       None.
-*
-*******************************************************************************/
-
-#ifndef __mvNfp_h__
-#define __mvNfp_h__
-
-#include "mvSysHwConfig.h"
-#include "mvTypes.h"
-#include "mvCommon.h"
-#include "mvStack.h"
-#include "mvList.h"
-#include "mv802_3.h"
-#include "gbe/mvEthRegs.h"
-#include "pnc/mvPnc.h"
-
-#include "mvNfpDefs.h"
-
-/* Enable / Disable NFP Debug Prints: */
-
-#define NFP_DBG(x...)  if (nfpDebugLevel & NFP_DBG_PRINT) mvOsPrintf(x)
-/*#define NFP_WARN(x...)*/
-
-#define NFP_WARN(x...)  if (nfpDebugLevel & NFP_WARN_PRINT) mvOsPrintf(x)
-/*#define NFP_WARN(x...)*/
-
-#define	NFP_NO_PRINT	0x0
-#define	NFP_DBG_PRINT	0x1
-#define	NFP_WARN_PRINT	0x2
-
-/* defined in mvNfp.c */
-extern MV_U32 nfpDebugLevel;
-
-extern MV_U32	 nfp_ports[];
-extern MV_U32    nfp_jhash_iv;
-
-#ifdef CONFIG_MV_ETH_SWITCH
-/* switchGroup coded by bits[4-7] of MSB in Marvell header */
-#define NFP_SWITCH_GROUP(port, mh)       	\
-		((nfp_ports[port] & NFP_F_PORT_MH) ? ((*(MV_U8 *)(mh)) >> 4) : NFP_INVALID_SWITCH_GROUP)
-#else
-# define NFP_SWITCH_GROUP(port, mh)      NFP_INVALID_SWITCH_GROUP
-#endif /* CONFIG_MV_ETH_SWITCH */
-
-/* NFP Operation Mode */
-typedef enum {
-	MV_NFP_DISABLED	= 0,
-	MV_NFP_2_TUPLE	= 1,
-	MV_NFP_5_TUPLE	= 2,
-	MV_NFP_MODE_LAST
-} MV_NFP_MODE;
-
-typedef enum {
-	MV_NFP_OFF = 0,
-	MV_NFP_ON  = 1,
-	MV_NFP_STATE_LAST
-} MV_NFP_STATE;
-
-
-static INLINE MV_U32 mv_jhash_array(const MV_U8 *k, MV_U32 length, MV_U32 initval)
-{
-	MV_U32 a, b, c, l;
-
-	l = length;
-	a = b = MV_JHASH_GOLDEN_RATIO;
-	c = initval;
-
-	while (l >= 12) {
-		a += (k[0] + ((MV_U32) k[1] << 8) + ((MV_U32) k[2] << 16) + ((MV_U32) k[3] << 24));
-		b += (k[4] + ((MV_U32) k[5] << 8) + ((MV_U32) k[6] << 16) + ((MV_U32) k[7] << 24));
-		c += (k[8] + ((MV_U32) k[9] << 8) + ((MV_U32) k[10] << 16) + ((MV_U32) k[11] << 24));
-		MV_JHASH_MIX(a, b, c);
-		k += 12;
-		l -= 12;
-	}
-
-	c += length;
-	switch (l) {
-	case 11:
-		c += ((MV_U32) k[10] << 24);
-	case 10:
-		c += ((MV_U32) k[9] << 16);
-	case 9:
-		c += ((MV_U32) k[8] << 8);
-	case 8:
-		b += ((MV_U32) k[7] << 24);
-	case 7:
-		b += ((MV_U32) k[6] << 16);
-	case 6:
-		b += ((MV_U32) k[5] << 8);
-	case 5:
-		b += k[4];
-	case 4:
-		a += ((MV_U32) k[3] << 24);
-	case 3:
-		a += ((MV_U32) k[2] << 16);
-	case 2:
-		a += ((MV_U32) k[1] << 8);
-	case 1:
-		a += k[0];
-	default:
-		/* do nothing */;
-	}
-
-	MV_JHASH_MIX(a, b, c);
-	return c;
-}
-
-
-static INLINE MV_U32 mv_jhash_2addr(int family, const MV_U8 *aa, const MV_U8 *ab, MV_U32 c, MV_U32 initval)
-{
-	MV_U32 a, b;
-
-	if (family == MV_INET6) {
-		a = mv_jhash_array(aa, 16, initval);
-		b = mv_jhash_array(ab, 16, initval);
-	} else {
-		a = *((const MV_U32 *)(aa));
-		b = *((const MV_U32 *)(ab));
-	}
-
-	return mv_jhash_3words(a, b, c, initval);
-}
-
-static INLINE MV_U32 mv_jhash_2macs(const MV_U8 *da, const MV_U8 *sa, MV_U32 c, MV_U32 initval)
-{
-	MV_U32 a, b;
-
-	a = mv_jhash_array(da, MV_MAC_ADDR_SIZE, initval);
-	b = mv_jhash_array(sa, MV_MAC_ADDR_SIZE, initval);
-
-	return mv_jhash_3words(a, b, c, initval);
-}
-
-static INLINE MV_U32 mv_jhash_1addr(int family, const MV_U8 *aa, MV_U32 b, MV_U32 c, MV_U32 initval)
-{
-	MV_U32 a;
-
-	if (family == MV_INET6)
-		a = mv_jhash_array(aa, 16, initval);
-	else
-		a = *((const MV_U32 *)(aa));
-
-	return mv_jhash_3words(a, b, c, initval);
-}
-
-/* L3 address copy. Supports AF_INET and AF_INET6 */
-static inline MV_VOID l3_addr_copy(int family, u8 *dst, const u8 *src)
-{
-	const u32 *s = (const u32 *)src;
-	u32 *d = (u32 *) dst;
-
-	*d++ = *s++;		/* 4 */
-	if (family == MV_INET)
-		return;
-
-	*d++ = *s++;		/* 8 */
-	*d++ = *s++;		/* 12 */
-	*d++ = *s++;		/* 16 */
-}
-
-static INLINE MV_U32 l3_addr_eq(int family, const MV_U8 *a, const MV_U8 *b)
-{
-	const MV_U32 *aa = (const MV_U32 *)a;
-	const MV_U32 *bb = (const MV_U32 *)b;
-	MV_U32 r;
-
-	r = *aa++ ^ *bb++;	/* 4 */
-	if (family == MV_INET)
-		return !r;
-
-	r |= *aa++ ^ *bb++;	/* 8 */
-	r |= *aa++ ^ *bb++;	/* 12 */
-	r |= *aa++ ^ *bb++;	/* 16 */
-
-	return !r;
-}
-
-/*******************************
- * Hash tables size definitions
- *******************************/
-
-#define NFP_DEV_HASH_BITS	7
-#define NFP_DEV_HASH_SZ		(1 << NFP_DEV_HASH_BITS)
-#define NFP_DEV_HASH_MASK	(NFP_DEV_HASH_SZ - 1)
-
-#define	NFP_FDB_HASH_BITS	14
-#define	NFP_FSB_HASH_SIZE	(1 << NFP_FDB_HASH_BITS)
-#define	NFP_FDB_HASH_MASK	(NFP_FDB_HASH_SIZE - 1)
-
-#define	NFP_BRIDGE_HASH_BITS	14
-#define	NFP_BRIDGE_HASH_SIZE	(1 << NFP_BRIDGE_HASH_BITS)
-#define	NFP_BRIDGE_HASH_MASK	(NFP_BRIDGE_HASH_SIZE - 1)
-
-#define	NFP_ARP_HASH_BITS	14
-#define	NFP_ARP_HASH_SIZE	(1 << NFP_ARP_HASH_BITS)
-#define	NFP_ARP_HASH_MASK	(NFP_ARP_HASH_SIZE - 1)
-
-#define	NFP_FIB_HASH_BITS	14
-#define	NFP_FIB_HASH_SIZE	(1 << NFP_FIB_HASH_BITS)
-#define	NFP_FIB_HASH_MASK	(NFP_FIB_HASH_SIZE - 1)
-
-#define	NFP_CT_HASH_BITS	14
-#define	NFP_CT_HASH_SIZE	(1 << NFP_CT_HASH_BITS)
-#define	NFP_CT_HASH_MASK	(NFP_CT_HASH_SIZE - 1)
-
-/*********
- * Flags
- *********/
-
-/* Flags relevant for port capabilities */
-#define NFP_F_PORT_MH           0x1
-
-/* Flags relevant for NFP_IF_MAP, to be used in NFP_IF_MAP flags */
-#define NFP_F_MAP_INT                    0x0001
-#define NFP_F_MAP_EXT                    0x0002
-#define NFP_F_MAP_SWITCH_PORT            0x0004
-#define NFP_F_MAP_BRIDGE                 0x0008
-#define NFP_F_MAP_BRIDGE_PORT            0x0010
-#define NFP_F_MAP_TX_MH                  0x0020
-#define NFP_F_MAP_VLAN_PVID              0x0040
-#define NFP_F_MAP_VLAN_RX_DROP_TAGGED    0x0080
-#define NFP_F_MAP_VLAN_RX_DROP_UNTAGGED  0x0100
-#define NFP_F_MAP_VLAN_RX_DROP_UNKNOWN   0x0200
-#define NFP_F_MAP_VLAN_RX_FLAGS          (NFP_F_MAP_VLAN_RX_DROP_TAGGED | NFP_F_MAP_VLAN_RX_DROP_UNTAGGED | \
-										NFP_F_MAP_VLAN_RX_DROP_UNKNOWN)
-
-#define NFP_F_MAP_VLAN_TX_TAGGED         0x0400
-#define NFP_F_MAP_VLAN_TX_UNTAGGED       0x0800
-#define NFP_F_MAP_VLAN_TX_FLAGS          (NFP_F_MAP_VLAN_TX_UNTAGGED | NFP_F_MAP_VLAN_TX_TAGGED)
-
-#define NFP_F_MAP_PPPOE                  0x1000
-
-/* Flags relevant for NFP Bridging, to be used in NFP_RULE_BRIDGE flags */
-#define NFP_F_BR_SET_VLAN_PRIO  0x1
-#define NFP_F_BR_SET_TXQ        0x2
-#define NFP_F_BR_SET_TXP        0x4
-#define NFP_F_BR_SET_MH         0x8
-#define NFP_F_BR_NOT_EXIST      0x10
-
-/* Flags relevant for NFP FIB rules, to be used in NFP_RULE_FIB flags */
-#define NFP_F_FIB_BRIDGE_INV    0x1
-#define NFP_F_FIB_ARP_INV       0x2
-#define NFP_F_FIB_HWF           0x4
-#define NFP_F_FIB_ALL_FLAGS	    (NFP_F_FIB_BRIDGE_INV | NFP_F_FIB_ARP_INV | NFP_F_FIB_HWF)
-
-/* Flags relevant for 5 Tuple NFP mode (CT), to be used in NFP_RULE_CT flags */
-#define	NFP_F_CT_SNAT           0x1
-#define	NFP_F_CT_DNAT           0x2
-#define NFP_F_CT_DROP           0x4
-#define NFP_F_CT_SET_DSCP       0x8
-#define NFP_F_CT_SET_VLAN_PRIO  0x10
-#define NFP_F_CT_SET_TXQ        0x20
-#define NFP_F_CT_SET_TXP        0x40
-#define NFP_F_CT_SET_MH         0x80
-#define NFP_F_CT_LIMIT          0x100
-#define NFP_F_CT_FIB_INV        0x200
-#define NFP_F_CT_HWF            0x400
-#define NFP_F_CT_UDP_CSUM       0x800
-#define NFP_F_CT_NOT_EXIST      0x1000
-
-
-/* Flags relevant for classification info NFP_CLASSIFY_INFO */
-#define NFP_F_SET_TXQ			0x01
-#define NFP_F_SET_TXP			0x02
-#define NFP_F_SET_MH			0x04
-#define NFP_F_SET_VLAN_PRIO		0x08
-#define NFP_F_SET_DSCP			0x10
-#define NFP_F_SET_PRIO_TXQ		0x20
-#define NFP_F_SET_PRIO_TXP		0x40
-#define NFP_F_SET_PRIO_MH		0x80
-#define NFP_F_SET_PRIO_VLAN_PRIO	0x100
-#define NFP_F_SET_PRIO_DSCP		0x200
-#define NFP_F_SET_EXACT_TXQ		0x400
-#define NFP_F_SET_EXACT_TXP		0x800
-#define NFP_F_SET_EXACT_MH		0x1000
-#define NFP_F_SET_EXACT_VLAN_PRIO	0x2000
-#define NFP_F_SET_EXACT_DSCP		0x4000
-
-#define NFP_INVALID_VLAN          4096
-#define NFP_INVALID_VPRIO         -1
-#define NFP_INVALID_DSCP          -1
-#define NFP_INVALID_TXP	          255
-#define NFP_INVALID_TXQ	          255
-#define NFP_INVALID_MH	          0xFFFF
-#define NFP_INVALID_SWITCH_GROUP  255
-#define NFP_INVALID_PORT          255
-
-/*****************************
- * Classification definitions
- *****************************/
-
-#ifdef NFP_CLASSIFY
-
-/* 0..7 + one cell for global mapping regardless of the old VLAN Prio value (the '-1' option) */
-#define NFP_VPRI_MAP_SIZE	9
-#define NFP_VPRI_MAP_GLOBAL	8 /* index in the array for the global mapping */
-#define NFP_VPRI_MIN		0
-#define NFP_VPRI_MAX		7
-
-typedef struct {
-	MV_U16 eth_type; /* Used for bridging VLAN priority mapping */
-	MV_U8 new_prio;
-	MV_U8 valid;
-} NFP_VPRI_MAP_INFO;
-
-
-#define	MV_ETH_NFP_GLOBAL_MAP	-1
-
-/* 0..63 + one cell for global mapping regardless of the old DSCP value (the '-1' option) */
-#define NFP_DSCP_MAP_SIZE	65
-#define NFP_DSCP_MAP_GLOBAL	64 /* index in the array for the global mapping */
-#define NFP_DSCP_MIN		0
-#define NFP_DSCP_MAX		63
-
-typedef struct {
-	MV_U8 new_dscp;
-	MV_U8 valid;
-} NFP_DSCP_MAP_INFO;
-
-typedef struct {
-	MV_U8 txq;
-	MV_U8 valid;
-} NFP_TXQ_MAP_INFO;
-
-#define MV_NFP_CLASSIFY_FEATURES	5
-
-typedef enum {
-	MV_NFP_CLASSIFY_FEATURE_DSCP		= 0,
-	MV_NFP_CLASSIFY_FEATURE_VPRIO		= 1,
-	MV_NFP_CLASSIFY_FEATURE_TXQ		= 2,
-	MV_NFP_CLASSIFY_FEATURE_TXP		= 3,
-	MV_NFP_CLASSIFY_FEATURE_MH		= 4,
-	MV_NFP_CLASSIFY_FEATURE_INVALID	= 5,
-} MV_NFP_CLASSIFY_FEATURE;
-
-typedef enum {
-	MV_NFP_CLASSIFY_MODE_DISABLED	= 0,
-	MV_NFP_CLASSIFY_MODE_EXACT	= 1,
-	MV_NFP_CLASSIFY_MODE_PRIO	= 2,
-	MV_NFP_CLASSIFY_MODE_HIGHEST	= 3,
-	MV_NFP_CLASSIFY_MODE_LOWEST	= 4,
-	MV_NFP_CLASSIFY_MODE_INVALID  = 5,
-} MV_NFP_CLASSIFY_MODE;
-
-typedef enum {
-	MV_NFP_CLASSIFY_POLICY_HIGHEST	= 0,
-	MV_NFP_CLASSIFY_POLICY_LOWEST	= 1,
-	MV_NFP_CLASSIFY_POLICY_FIRST	= 2,
-	MV_NFP_CLASSIFY_POLICY_LAST	= 3,
-	MV_NFP_CLASSIFY_POLICY_EXACT	= 4,
-	MV_NFP_CLASSIFY_POLICY_PRIORITY	= 5,
-	MV_NFP_CLASSIFY_POLICY_INVALID = 6,
-} MV_NFP_CLASSIFY_POLICY;
-
-MV_STATUS mvNfpClassifyModeSet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_MODE mode);
-MV_NFP_CLASSIFY_MODE mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE feature);
-
-MV_STATUS mvNfpExactPolicySet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_POLICY policy);
-MV_NFP_CLASSIFY_POLICY mvNfpExactPolicyGet(MV_NFP_CLASSIFY_FEATURE feature);
-MV_STATUS mvNfpPrioPolicySet(MV_NFP_CLASSIFY_POLICY policy);
-MV_NFP_CLASSIFY_POLICY mvNfpPrioPolicyGet(MV_VOID);
-MV_STATUS mvNfpMixedPolicySet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_POLICY policy);
-MV_NFP_CLASSIFY_POLICY mvNfpMixedPolicyGet(MV_NFP_CLASSIFY_FEATURE feature);
-
-/* Priority classification API */
-#define NFP_PRIO_MAP_SIZE 64
-#define NFP_PRIO_MAX 63
-#define NFP_PRIO_INVALID -1
-
-/* Flags relevant for NFP_PRIO_CLASSIFY_INFO */
-#define NFP_F_PRIO_DSCP		0x01
-#define NFP_F_PRIO_VPRIO	0x02
-#define NFP_F_PRIO_TXP		0x04
-#define NFP_F_PRIO_TXQ		0x08
-#define NFP_F_PRIO_MH		0x10
-
-typedef struct {
-	MV_U8 prio;
-	MV_U8 valid;
-} NFP_PRIO_MAP_INFO;
-
-
-typedef struct {
-	MV_U16 flags;
-	MV_U8  txp;
-	MV_U8  txq;
-	int dscp;
-	int vprio;
-	MV_U16 mh;
-} NFP_PRIO_CLASSIFY_INFO;
-
-MV_STATUS mvNfpIifToPrioSet(int iif, MV_U8 prio);
-MV_STATUS mvNfpIifVlanToPrioSet(int iif, MV_U8 vlan_prio, MV_U8 prio);
-MV_STATUS mvNfpIifDscpToPrioSet(int iif, MV_U8 dscp, MV_U8 prio);
-
-MV_STATUS mvNfpIifToPrioDel(int iif);
-MV_STATUS mvNfpIifVlanToPrioDel(int iif, MV_U8 vlan_prio);
-MV_STATUS mvNfpIifDscpToPrioDel(int iif, MV_U8 dscp);
-
-MV_STATUS mvNfpPrioToDscpSet(int oif, MV_U8 prio, MV_U8 dscp);
-MV_STATUS mvNfpPrioToVprioSet(int oif, MV_U8 prio, MV_U8 vlan_prio);
-MV_STATUS mvNfpPrioToTxpSet(int oif, MV_U8 prio, MV_U8 txp);
-MV_STATUS mvNfpPrioToTxqSet(int oif, MV_U8 prio, MV_U8 txq);
-MV_STATUS mvNfpPrioToMhSet(int oif, MV_U8 prio, MV_U16 mh);
-
-MV_STATUS mvNfpPrioToDscpDel(int oif, MV_U8 prio);
-MV_STATUS mvNfpPrioToVprioDel(int oif, MV_U8 prio);
-MV_STATUS mvNfpPrioToTxpDel(int oif, MV_U8 prio);
-MV_STATUS mvNfpPrioToTxqDel(int oif, MV_U8 prio);
-MV_STATUS mvNfpPrioToMhDel(int oif, MV_U8 prio);
-
-MV_VOID mvNfpIngressPrioDump(int iif);
-MV_VOID mvNfpEgressPrioDump(int oif);
-#endif /* NFP_CLASSIFY */
-
-
-/*****************
- * Interface Map
- *****************/
-
-typedef struct nfp_if_map {
-
-	struct nfp_if_map *nextMap;
-	struct nfp_if_map *parentIf;
-	struct nfp_if_map *virtIf;
-	struct nfp_if_map *virtNext;
-	int     ifIdx;
-	char    name[16];
-	MV_VOID *dev;
-	MV_U8   port;
-	MV_U8   switchGroup;
-	MV_U16  pvid;
-	MV_U16  txMh;
-	MV_U8   mac[MV_MAC_ADDR_SIZE];
-	MV_U16  vlanId;
-	int     mtu;
-	int     bridgeIf;
-	MV_U32  flags;
-#ifdef NFP_PPP
-	MV_U16  sid;
-	MV_U8   remoteMac[MV_MAC_ADDR_SIZE];
-#endif /* NFP_PPP */
-
-#ifdef NFP_CLASSIFY
-	int prio;
-	NFP_PRIO_MAP_INFO dscp_to_prio[NFP_DSCP_MAP_SIZE];
-	NFP_PRIO_MAP_INFO vpri_to_prio[NFP_VPRI_MAP_SIZE];
-	NFP_PRIO_CLASSIFY_INFO prio_to_classify[NFP_PRIO_MAP_SIZE];
-#endif /* NFP_CLASSIFY */
-} NFP_IF_MAP;
-
-extern NFP_IF_MAP  *nfp_if_map[NFP_DEV_HASH_SZ];
-extern NFP_IF_MAP  *nfp_if_real_map[NFP_MAX_PORTS][NFP_MAX_SWITCH_GROUPS];
-
-static INLINE NFP_IF_MAP *mvNfpIfMapGet(int ifIdx)
-{
-	NFP_IF_MAP *ifMap = nfp_if_map[ifIdx & NFP_DEV_HASH_MASK];
-
-	while (ifMap != NULL) {
-		if (ifMap->ifIdx == ifIdx)
-			return ifMap;
-		ifMap = ifMap->nextMap;
-	}
-	return NULL;
-}
-
-static INLINE int mvNfpIfMapCmp(int port, MV_U8 switchGroup, NFP_IF_MAP *ifMap)
-{
-	if ((ifMap->port == port) && (ifMap->switchGroup == switchGroup))
-		return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-static INLINE NFP_IF_MAP *mvNfpIfMapRealGet(int port, MV_U8 *mh)
-{
-	MV_U8		switchGroup;
-	NFP_IF_MAP	*ifMap;
-
-	/* Support port and switchGroup */
-	switchGroup = NFP_SWITCH_GROUP(port, mh);
-	if (switchGroup == NFP_INVALID_SWITCH_GROUP)
-		ifMap = nfp_if_real_map[port][0];
-	else
-		ifMap = nfp_if_real_map[port][switchGroup];
-
-	if ((ifMap) && mvNfpIfMapCmp(port, switchGroup, ifMap))
-		return ifMap;
-
-	return NULL;
-}
-
-
-/************
- * Bridging
- ************/
-
-#ifdef NFP_BRIDGE
-
-#define NFP_BRIDGE_INV		0
-#define NFP_BRIDGE_LOCAL	1
-#define NFP_BRIDGE_NON_LOCAL	2
-
-typedef struct nfp_rule_fdb {
-	struct nfp_rule_fdb *next;
-	MV_U16 reserved;
-	MV_U8  mac[MV_MAC_ADDR_SIZE];
-	int    bridgeIf;
-	int    if_index;
-	MV_U32 age;
-	MV_U8  status;
-
-} NFP_RULE_FDB;
-
-extern NFP_RULE_FDB **nfp_fdb_hash;
-
-static INLINE MV_U32 mvNfpFdbRuleHash(int bridgeIf, const MV_U8 *mac)
-{
-	MV_U32 hash = 0;
-	int    align = (MV_U32)mac & 3;
-
-	switch (align) {
-	case 0:
-		/* SA - 4 byte alignement - BE support TBD */
-		hash = mv_jhash_3words(bridgeIf, *(MV_U16 *)(mac), (*(MV_U16 *)(mac + 2)) | ((*(MV_U16 *)(mac + 4)) << 16),
-							nfp_jhash_iv);
-		break;
-
-	case 2:
-		/* DA - 2 byte alignement */
-		hash = mv_jhash_3words(bridgeIf, *(MV_U16 *)(mac), *(MV_U32 *)(mac + 2), nfp_jhash_iv);
-		break;
-
-	default:
-		mvOsPrintf("%s: Unexpected alignment: mac=%p\n", __func__, mac);
-	}
-
-	hash &= NFP_BRIDGE_HASH_MASK;
-	return hash;
-}
-
-static INLINE MV_STATUS mvNfpFdbRuleCmp(MV_U16 bridgeIf, const MV_U8 *mac, NFP_RULE_FDB *rule)
-{
-	int    align = (MV_U32)mac & 3;
-
-	switch (align) {
-	case 0:
-		/* SA - 4 byte alignement */
-		if ((rule->bridgeIf == bridgeIf) &&
-			(*(MV_U16 *)(rule->mac)) == (*(MV_U16 *)(mac)) &&
-			(*(MV_U16 *)(rule->mac + 2)) == (*(MV_U16 *)(mac + 2)) &&
-			(*(MV_U16 *)(rule->mac + 4)) == (*(MV_U16 *)(mac + 4)))
-			return MV_TRUE;
-		break;
-	case 2:
-		/* DA - 2 byte alignement */
-		if ((rule->bridgeIf == bridgeIf) &&
-			(*(MV_U16 *)(rule->mac)) == (*(MV_U16 *)(mac)) &&
-			(*(MV_U32 *)(rule->mac + 2)) == (*(MV_U32 *)(mac + 2)))
-			return MV_TRUE;
-		break;
-	default:
-		mvOsPrintf("%s: Unexpected alignment: mac=%p\n", __func__, mac);
-	}
-	return MV_FALSE;
-}
-
-static INLINE NFP_RULE_FDB *mvNfpFdbLookup(MV_U16 bridgeIf, const MV_U8 *mac)
-{
-	MV_U32 hash;
-	NFP_RULE_FDB *rule;
-
-	hash = mvNfpFdbRuleHash(bridgeIf, mac);
-
-	rule = nfp_fdb_hash[hash];
-	while (rule) {
-		if (mvNfpFdbRuleCmp(bridgeIf, mac, rule))
-			return rule;
-
-		rule = rule->next;
-	}
-	return NULL;
-}
-
-typedef struct nfp_rule_bridge {
-	struct nfp_rule_bridge *next;
-	MV_U16  reserved;
-	MV_U8	da[MV_MAC_ADDR_SIZE];
-	MV_U8	sa[MV_MAC_ADDR_SIZE];
-	int	iif;
-	int	oif;
-	MV_U32	flags;
-	MV_U32	age;
-#ifdef NFP_CLASSIFY
-	NFP_VPRI_MAP_INFO  vpri_map[NFP_VPRI_MAP_SIZE];
-	MV_U8	txq;
-	MV_U8	txp;
-	MV_U16  mh;
-#endif /* NFP_CLASSIFY */
-
-} NFP_RULE_BRIDGE;
-
-extern NFP_RULE_BRIDGE **nfp_bridge_hash;
-
-
-static INLINE MV_U32 mvNfpBridgeRuleHash(const MV_U8 *da, const MV_U8 *sa, MV_U16 iif)
-{
-	MV_U32 hash = mv_jhash_2macs(da, sa, iif, nfp_jhash_iv);
-	hash &= NFP_BRIDGE_HASH_MASK;
-	return hash;
-}
-
-
-static INLINE MV_STATUS mvNfpBridgeRuleCmp(const MV_U8 *da, const MV_U8 *sa, MV_U16 iif, NFP_RULE_BRIDGE *rule)
-{
-	if ((iif == rule->iif) &&
-	    (*(MV_U16 *)(rule->da)) == (*(MV_U16 *)(da))	 &&
-	    (*(MV_U32 *)(rule->da + 2)) == (*(MV_U32 *)(da + 2)) &&
-	    (*(MV_U32 *)(rule->sa)) == (*(MV_U32 *)(sa))	 &&
-	    (*(MV_U16 *)(rule->sa + 4)) == (*(MV_U16 *)(sa + 4)))
-		return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-static INLINE NFP_RULE_BRIDGE *mvNfpBridgeLookup(const MV_U8 *da, const MV_U8 *sa, MV_U16 iif)
-{
-	MV_U32 hash;
-	NFP_RULE_BRIDGE *rule;
-
-	hash = 	mvNfpBridgeRuleHash(da, sa, iif);
-
-	rule = nfp_bridge_hash[hash];
-	while (rule) {
-		if (mvNfpBridgeRuleCmp(da, sa, iif, rule))
-			return rule;
-
-		rule = rule->next;
-	}
-	return NULL;
-}
-#endif /* NFP_BRIDGE */
-
-typedef struct nfp_rule_arp {
-	struct nfp_rule_arp *next;
-	int	family;
-	MV_U8	nextHopL3[MV_MAX_L3_ADDR_SIZE];
-	MV_U8	da[MV_MAC_ADDR_SIZE];
-	MV_U32	age;
-
-} NFP_RULE_ARP;
-
-#ifdef NFP_FIB
-typedef struct nfp_rule_fib {
-	struct nfp_rule_fib *next;
-	int	family;
-	MV_U8	srcL3[MV_MAX_L3_ADDR_SIZE];
-	MV_U8	dstL3[MV_MAX_L3_ADDR_SIZE];
-	MV_U16	mh;
-	MV_U8	da[MV_MAC_ADDR_SIZE];
-	MV_U8	sa[MV_MAC_ADDR_SIZE];
-	MV_U32	age;
-	MV_U8	defGtwL3[MV_MAX_L3_ADDR_SIZE];
-	MV_U32	flags;
-	int     oif;
-	MV_U32	ref;
-#ifdef NFP_CT
-	MV_U16	ct_ref_count;
-	MV_U16	ct_hwf_ref_count;
-#endif /* NFP_CT */
-} NFP_RULE_FIB;
-#endif /* NFP_FIB */
-
-#ifdef NFP_LIMIT
-typedef struct {
-	MV_U32	credit;
-	MV_U32	creditMax;
-	MV_U32	creditPerTick;
-	MV_U32	lastUpdate;
-
-	MV_U32	refCnt;
-	MV_U32 	index;
-	MV_U32	maxElapsedTicks;
-} NFP_TBF_INFO;
-#endif /* NFP_LIMIT */
-
-#ifdef NFP_CT
-typedef struct {
-	int family;
-	MV_U8  src_l3[MV_MAX_L3_ADDR_SIZE];
-	MV_U8  dst_l3[MV_MAX_L3_ADDR_SIZE];
-	MV_U16 sport;
-	MV_U16 dport;
-	MV_U8  proto;
-} MV_NFP_CT_KEY;
-
-typedef struct {
-	MV_U32 flags;
-	MV_U32 new_sip;
-	MV_U32 new_dip;
-	MV_U16 new_sport;
-	MV_U16 new_dport;
-	MV_U8 sa[MV_MAC_ADDR_SIZE];
-	MV_U8 da[MV_MAC_ADDR_SIZE];
-	MV_U8 out_port;
-#ifdef NFP_CLASSIFY
-	MV_U8 txp;
-	MV_U8 txq;
-	MV_U8 dscp;
-	MV_U8 vprio;
-	MV_U16 mh;
-#endif /* NFP_CLASSIFY */
-} MV_NFP_CT_INFO;
-
-typedef struct nfp_rule_ct {
-	struct nfp_rule_ct *next;
-	/* 5 tuple key */
-	int family;
-	MV_U8 srcL3[MV_MAX_L3_ADDR_SIZE];
-	MV_U8 dstL3[MV_MAX_L3_ADDR_SIZE];
-	MV_U32 ports;
-	MV_U16 proto;
-	MV_U16 reserved;	/* for alignment */
-	NFP_RULE_FIB *fib;
-#ifdef NFP_NAT
-	MV_U32 new_sip;
-	MV_U32 new_dip;
-	MV_U16 new_sport;
-	MV_U16 new_dport;
-#endif /* NFP_NAT */
-
-#ifdef NFP_LIMIT
-	/* Token Bucket Filter information */
-	NFP_TBF_INFO *tbfInfo;
-#endif /* NFP_LIMIT */
-
-#ifdef NFP_CLASSIFY
-	/* indexes 0..63 are the old dscp, values in the array cells are the new dscp. index 64 is for global mapping */
-	NFP_DSCP_MAP_INFO  dscp_map[NFP_DSCP_MAP_SIZE];
-	NFP_VPRI_MAP_INFO  vpri_map[NFP_VPRI_MAP_SIZE];
-	NFP_TXQ_MAP_INFO   txq_map[NFP_DSCP_MAP_SIZE];
-	MV_U8 txp;
-	MV_U16 mh;
-#endif /* NFP_CLASSIFY */
-	MV_U32 flags;
-	MV_U32 age;
-	MV_U32 hit_cntr;
-	MV_U8 visited;
-} NFP_RULE_CT;
-#endif /* NFP_CT */
-
-typedef struct {
-#ifdef NFP_STAT
-	MV_U32 rx;
-	MV_U32 iif_err;
-	MV_U32 oif_err;
-	MV_U32 mac_mcast;
-	MV_U32 non_ip;
-	MV_U32 ipv4;
-	MV_U32 ipv6;
-	MV_U32 ipv4_csum_err;
-	MV_U32 ipv4_rx_frag;
-	MV_U32 ttl_exp;
-	MV_U32 l4_unknown;
-	MV_U32 l4_csum_err;
-	MV_U32 ip_tx_frag;
-	MV_U32 ip_tx_frag_err;
-
-#ifdef NFP_BRIDGE
-	MV_U32 bridge_hit;
-	MV_U32 bridge_miss;
-	MV_U32 bridge_local;
-
-	MV_U32 fdb_sa_miss;
-	MV_U32 fdb_da_miss;
-	MV_U32 fdb_port_miss;
-	MV_U32 fdb_hit;
-	MV_U32 fdb_local;
-#endif /* NFP_BRIDGE */
-
-
-#ifdef NFP_VLAN
-	MV_U32 vlan_rx_tag_drop;
-	MV_U32 vlan_rx_untag_drop;
-	MV_U32 vlan_rx_unknown_drop;
-	MV_U32 vlan_rx_found;
-	MV_U32 vlan_rx_trans;
-	MV_U32 vlan_tx_add;
-	MV_U32 vlan_tx_remove;
-	MV_U32 vlan_tx_replace;
-#endif /* NFP_VLAN */
-
-#ifdef NFP_PPP
-	MV_U32 pppoe_rx_not_found;
-	MV_U32 pppoe_rx_found;
-	MV_U32 pppoe_tx_add;
-	MV_U32 pppoe_tx_remove;
-	MV_U32 pppoe_tx_replace;
-#endif	/* NFP_PPP */
-
-#ifdef NFP_FIB
-	MV_U32 fib_hit;
-	MV_U32 fib_miss;
-	MV_U32 fib_inv;
-#endif	/* NFP_FIB */
-
-#ifdef NFP_CT
-	MV_U32 ct_hit;
-	MV_U32 ct_miss;
-	MV_U32 ct_tcp_fin_rst;
-#endif /* NFP_CT */
-
-#ifdef NFP_NAT
-	MV_U32 dnat_hit;
-	MV_U32 dnat_miss;
-	MV_U32 dnat_inv;
-	MV_U32 snat_hit;
-	MV_U32 snat_miss;
-	MV_U32 snat_inv;
-#endif	/* NFP_NAT */
-
-#endif	/* NFP_STAT */
-} NFP_STATS;
-
-MV_VOID   mvNfpInit(MV_VOID);
-
-MV_VOID   mvNfpPortCapSet(MV_U32 port, MV_U32 cap, MV_U32 on);
-MV_U32    mvNfpPortCapGet(MV_U32 port);
-MV_VOID   mvNfpDebugLevelSet(int dbgLevelFlags);
-
-MV_VOID   mvNfpStats(MV_U32);
-MV_VOID   mvNfpStats(MV_U32 port);
-
-#ifdef NFP_BRIDGE
-MV_STATUS mvNfpIfToBridgeAdd(int bridge_if, int port_if);
-MV_STATUS mvNfpIfToBridgeDel(int bridge_if, int port_if);
-MV_BOOL   mvNfpIfOnSameBridge(NFP_IF_MAP *ifMap1, NFP_IF_MAP *ifMap2);
-#ifdef NFP_FDB_MODE
-MV_STATUS _INIT mvNfpFdbInit(MV_VOID);
-void mvNfpFdbDestroy(void);
-MV_STATUS mvNfpFdbRuleAdd(NFP_RULE_FDB *rule2);
-MV_STATUS mvNfpFdbRuleDel(NFP_RULE_FDB *rule2);
-MV_STATUS mvNfpFdbRuleAge(NFP_RULE_FDB *rule2);
-MV_VOID	  mvNfpFdbDump(MV_VOID);
-MV_VOID	  mvNfpFdbFlushBridge(int ifindex);
-#else
-MV_STATUS _INIT mvNfpBridgeInit(MV_VOID);
-MV_STATUS mvNfpBridgeRuleAdd(NFP_RULE_BRIDGE *rule2);
-MV_STATUS mvNfpBridgeRuleDel(NFP_RULE_BRIDGE *rule2);
-MV_STATUS mvNfpBridgeRuleAge(NFP_RULE_BRIDGE *rule2);
-MV_VOID	  mvNfpBridgeDump(MV_VOID);
-
-#ifdef NFP_CLASSIFY
-MV_STATUS mvNfpBridgeTxqRuleAdd(NFP_RULE_BRIDGE *rule2);
-MV_STATUS mvNfpBridgeTxqRuleDel(NFP_RULE_BRIDGE *rule2);
-MV_STATUS mvNfpBridgeTxpRuleAdd(NFP_RULE_BRIDGE *rule2);
-MV_STATUS mvNfpBridgeTxpRuleDel(NFP_RULE_BRIDGE *rule2);
-MV_STATUS mvNfpBridgeMhRuleAdd(NFP_RULE_BRIDGE *rule2);
-MV_STATUS mvNfpBridgeMhRuleDel(NFP_RULE_BRIDGE *rule2);
-MV_STATUS mvNfpBridgeVlanPrioRuleAdd(NFP_RULE_BRIDGE *rule2, int eth_type, int new_prio);
-MV_STATUS mvNfpBridgeVlanPrioRuleDel(NFP_RULE_BRIDGE *rule2, int eth_type);
-#endif /* NFP_CLASSIFY */
-#endif /* NFP_FDB_MODE */
-#endif /* NFP_BRIDGE */
-
-#ifdef NFP_VLAN
-MV_STATUS mvNfpVlanPvidSet(int if_index, MV_U16 pvid);
-MV_STATUS mvNfpVlanVidSet(int if_index, MV_U16 vid);
-MV_STATUS mvNfpVlanVidGet(int if_index, MV_U16 *vid);
-#endif /* NFP_VLAN */
-
-#ifdef NFP_PPP
-MV_STATUS mvNfpPppAdd(int ifIndex, MV_U16 sid, MV_U8 *remoteMac);
-MV_STATUS mvNfpPppDel(int ifIndex);
-#endif /* NFP_PPP */
-
-#ifdef NFP_FIB
-extern NFP_RULE_FIB **fib_hash;
-extern MV_LIST_ELEMENT *fib_inv_list;
-extern NFP_RULE_ARP **nfp_arp_hash;
-
-static INLINE MV_U32 mvNfpArpRuleHash(int family, MV_U8 *nextHopL3)
-{
-	MV_U32 hash = mv_jhash_1addr(family, nextHopL3, (MV_U32)0, (MV_U32)0, nfp_jhash_iv);
-	hash &= NFP_ARP_HASH_MASK;
-	return hash;
-}
-
-static INLINE MV_STATUS mvNfpArpRuleCmp(int family, MV_U8 *nextHopL3, NFP_RULE_ARP *rule)
-{
-	if ((family == rule->family) && l3_addr_eq(family, rule->nextHopL3, nextHopL3))
-		return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-static INLINE NFP_RULE_ARP *mvNfpArpLookup(int family, MV_U8 *nextHopL3)
-{
-	MV_U32 hash;
-	NFP_RULE_ARP *rule;
-
-	hash = mvNfpArpRuleHash(family, nextHopL3);
-
-	rule = nfp_arp_hash[hash];
-	while (rule) {
-		if (mvNfpArpRuleCmp(family, nextHopL3, rule))
-			return rule;
-
-		rule = rule->next;
-	}
-	return NULL;
-}
-
-static INLINE MV_U32 mvNfpFibRuleHash(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3)
-{
-	MV_U32 hash = mv_jhash_2addr(family, src_l3, dst_l3, (MV_U32)0, nfp_jhash_iv);
-	hash &= NFP_FIB_HASH_MASK;
-	return hash;
-}
-
-static INLINE MV_STATUS mvNfpFibRuleCmp(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3, NFP_RULE_FIB *rule)
-{
-	if ((family == rule->family) &&
-		l3_addr_eq(family, rule->srcL3, src_l3)	&&
-		l3_addr_eq(family, rule->dstL3, dst_l3))
-		return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-static INLINE NFP_RULE_FIB *mvNfpFibLookup(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3)
-{
-	MV_U32 hash;
-	NFP_RULE_FIB *rule;
-
-	hash = mvNfpFibRuleHash(family, src_l3, dst_l3);
-	rule = fib_hash[hash];
-	while (rule) {
-		if (!(rule->family == family))
-			continue;
-		if (mvNfpFibRuleCmp(family, src_l3, dst_l3, rule))
-			return rule;
-		rule = rule->next;
-	}
-	return NULL;
-}
-
-MV_VOID   mvNfpModeSet(int mode);
-
-MV_VOID   mvNfpIpInfoPrint(u32 dbgLevel, int family, u8 *ipAddr);
-MV_VOID   mvNfp2TupleInfoPrint(u32 dbgLevel, int family, u8 *srcL3, u8 *dstL3);
-MV_VOID   mvNfp5TupleInfoPrint(u32 dbgLevel, int family, u8 *srcL3, u8 *dstL3, u16 sport, u16 dport, u8 proto);
-
-MV_STATUS mvNfpIfMapCreate(NFP_IF_MAP *ifMap);
-MV_STATUS mvNfpIfVirtMap(int parentIf, int virtIf);
-MV_STATUS mvNfpIfVirtUnmap(int virtIf);
-
-MV_STATUS mvNfpIfFlagsSet(int ifIdx, MV_U32 flags);
-MV_STATUS mvNfpIfFlagsClear(int ifIdx, MV_U32 flags);
-MV_STATUS mvNfpIfMapMacUpdate(int ifIdx, const MV_U8 *mac);
-MV_STATUS mvNfpIfMapMtuUpdate(int ifIdx, int mtu);
-MV_STATUS mvNfpIfMapDelete(int ifIdx);
-MV_VOID   mvNfpIfMapDump(MV_VOID);
-
-MV_STATUS mvNfpFibInit(MV_VOID);
-MV_VOID   mvNfpFibDump(MV_VOID);
-MV_VOID   mvNfpFibClean(MV_VOID);
-MV_VOID   mvNfpFibDestroy(MV_VOID);
-MV_STATUS mvNfpFibRuleValid(NFP_RULE_FIB *fib, MV_LIST_ELEMENT *curr);
-
-MV_STATUS mvNfpFibRuleAdd(NFP_RULE_FIB *fib2);
-MV_STATUS mvNfpFibRuleDel(NFP_RULE_FIB *fib2);
-MV_STATUS mvNfpFibRuleAge(NFP_RULE_FIB *fib2);
-
-
-MV_STATUS mvNfpArpInit(MV_VOID);
-MV_VOID   mvNfpArpDump(MV_VOID);
-MV_VOID   mvNfpArpDestroy(MV_VOID);
-MV_STATUS mvNfpArpRuleAdd(NFP_RULE_ARP *arp2);
-MV_STATUS mvNfpArpRuleDel(NFP_RULE_ARP *arp2);
-MV_STATUS mvNfpArpRuleAge(NFP_RULE_ARP *arp2);
-MV_STATUS mvNfpArpRuleUpdateFibEntries(NFP_RULE_ARP *arp);
-
-#endif /* NFP_FIB */
-
-#ifdef NFP_CT
-extern NFP_RULE_CT **ct_hash;
-
-static INLINE MV_U32 mvNfpCtHashByTuple(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3,
-					MV_U32 ports, MV_U16 proto)
-{
-	MV_U32 hash = mv_jhash_2addr(family, src_l3, dst_l3, (ports | proto), nfp_jhash_iv);
-	hash &= NFP_CT_HASH_MASK;
-	return hash;
-}
-
-static INLINE NFP_RULE_CT *mvNfpCtLookupByTuple(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3,
-						 MV_U32 ports, MV_U16 proto)
-{
-	MV_U32 hash;
-	NFP_RULE_CT *ct;
-
-	hash = mvNfpCtHashByTuple(family, src_l3, dst_l3, ports, proto);
-	ct = ct_hash[hash];
-	while (ct) {
-		if ((ct->family == family) &&
-			l3_addr_eq(ct->family, ct->srcL3, src_l3) &&
-			l3_addr_eq(ct->family, ct->dstL3, dst_l3) &&
-			(ct->ports == ports) && (ct->proto == proto))
-			return ct;
-		ct = ct->next;
-	}
-
-	return NULL;
-}
-
-extern NFP_RULE_CT **ct_hash;
-MV_STATUS mvNfpCtInit(MV_VOID);
-MV_VOID mvNfpCtRuleFibUpdate(NFP_RULE_FIB *fib);
-MV_VOID mvNfpCtRuleFibInvalidate(NFP_RULE_FIB *fib);
-MV_STATUS mvNfpCtFilterModeSet(NFP_RULE_CT *ct2);
-MV_STATUS mvNfpCtRuleUdpCsumSet(NFP_RULE_CT *ct2, int mode);
-MV_STATUS mvNfpCtRateLimitSet(NFP_RULE_CT *ct2, int tbf_index);
-MV_STATUS mvNfpCtRateLimitDel(NFP_RULE_CT *ct2);
-#ifdef NFP_CLASSIFY
-MV_STATUS mvNfpCtDscpRuleAdd(NFP_RULE_CT *ct2, int dscp, int new_dscp);
-MV_STATUS mvNfpCtDscpRuleDel(NFP_RULE_CT *ct2, int dscp);
-MV_STATUS mvNfpCtVlanPrioRuleAdd(NFP_RULE_CT *ct2, int prio, int new_prio);
-MV_STATUS mvNfpCtVlanPrioRuleDel(NFP_RULE_CT *ct2, int prio);
-MV_STATUS mvNfpCtTxqRuleAdd(NFP_RULE_CT *ct2, int dscp, int txq);
-MV_STATUS mvNfpCtTxqRuleDel(NFP_RULE_CT *ct2, int dscp);
-MV_STATUS mvNfpCtTxpRuleAdd(NFP_RULE_CT *ct2);
-MV_STATUS mvNfpCtTxpRuleDel(NFP_RULE_CT *ct2);
-MV_STATUS mvNfpCtMhRuleAdd(NFP_RULE_CT *ct2);
-MV_STATUS mvNfpCtMhRuleDel(NFP_RULE_CT *ct2);
-#endif /* NFP_CLASSIFY */
-MV_STATUS mvNfpCtRuleDel(NFP_RULE_CT *rule);
-MV_STATUS mvNfpCtRuleAge(NFP_RULE_CT *rule);
-MV_VOID mvNfpCtDump(MV_VOID);
-MV_VOID mvNfpCtClean(int family);
-MV_VOID mvNfpCtDestroy(MV_VOID);
-
-MV_VOID mvNfpCtCleanVisited(MV_U32 row, MV_U32 iterator_id);
-MV_STATUS mvNfpCtFirstRuleGet(NFP_RULE_CT **rule, MV_U32 iterator_id);
-MV_STATUS mvNfpCtNextRuleGet(NFP_RULE_CT **rule, MV_U32 iterator_id);
-MV_STATUS mvNfpCtRuleMaxHitCntrGet(NFP_RULE_CT **rule);
-MV_STATUS mvNfpCtRuleHwfSet(MV_NFP_CT_KEY *key, int mode);
-MV_STATUS mvNfpCtRuleHitCntrGet(MV_NFP_CT_KEY *key, MV_U32 *hit_cntr);
-MV_STATUS mvNfpCtRuleHitCntrSet(MV_NFP_CT_KEY *key, MV_U32 val);
-MV_STATUS mvNfpCtRuleInfoGet(MV_NFP_CT_KEY *key, MV_NFP_CT_INFO *ct_info);
-#endif /* NFP_CT */
-
-#ifdef NFP_NAT
-MV_STATUS mvNfpCtNatRuleAdd(NFP_RULE_CT *rule);
-#endif /* NFP_NAT */
-
-#ifdef NFP_LIMIT
-void mvNfpCtTbfsDump(void);
-int mvNfpTbfCreate(int limit, int burst_limit);
-MV_STATUS mvNfpTbfDel(int tbf);
-MV_STATUS mvNfpTbfProcess(NFP_TBF_INFO *tbf, MV_U32 packetSize);
-#endif /* NFP_LIMIT */
-
-#ifndef NFP_FDB_MODE
-void mvNfpFlushBridge(int ifindex);
-#endif
-
-void mvNfpFlushFib(int ifindex);
-
-#endif /* __mvNfp_h__ */
--- a/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpBridge.c
+++ /dev/null
@@ -1,728 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell Interfdbional Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-Interfdbional Ltd. and/or its affiliates ("Marvell") under the following
-alterfdbive licensing terms.  Once you have made an election to distribute the
-File under one of the following license alterfdbives, please (i) delete this
-introductory statement regarding license alterfdbives, (ii) delete the two
-license alterfdbives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-/*******************************************************************************
-* mvNfpBridge.c - Marvell Fast Network Processing
-*
-* DESCRIPTION:
-*
-*       Supported Features:
-*       - OS independent.
-*
-*******************************************************************************/
-
-#include "mvOs.h"
-#include "mvDebug.h"
-#include "mvList.h"
-#include "gbe/mvNeta.h"
-#include "mvNfpDefs.h"
-#include "mvNfp.h"
-
-NFP_RULE_BRIDGE **nfp_bridge_hash = NULL;
-#ifdef NFP_CLASSIFY
-MV_LIST_ELEMENT *bridge_inv_list = NULL;
-#endif /* NFP_CLASSIFY */
-
-MV_STATUS _INIT mvNfpBridgeInit(void)
-{
-	MV_U32 bytes = sizeof(NFP_RULE_BRIDGE *) * NFP_BRIDGE_HASH_SIZE;
-
-	nfp_bridge_hash = (NFP_RULE_BRIDGE **)mvOsMalloc(bytes);
-	if (nfp_bridge_hash == NULL) {
-		mvOsPrintf("NFP (bridge hash): not enough memory\n");
-		return MV_NO_RESOURCE;
-	}
-	mvOsMemset(nfp_bridge_hash, 0, bytes);
-#ifdef NFP_CLASSIFY
-	bridge_inv_list = mvListCreate();
-	if (bridge_inv_list == NULL) {
-		mvOsPrintf("NFP (bridge): not enough memory\n");
-		mvOsFree(nfp_bridge_hash);
-		return MV_NO_RESOURCE;
-	}
-#endif /* NFP_CLASSIFY */
-	mvOsPrintf("NFP (bridge) init %d entries, %d bytes\n", NFP_BRIDGE_HASH_SIZE, bytes);
-
-	return MV_OK;
-}
-
-/* Clear Bridge Rule Database */
-MV_STATUS mvNfpBridgeClear(void)
-{
-	int	i;
-	NFP_RULE_BRIDGE	*rule, *tmp;
-#ifdef NFP_CLASSIFY
-	MV_LIST_ELEMENT	*curr, *tmp_list;
-#endif /* NFP_CLASSIFY */
-
-	if (nfp_bridge_hash == NULL)
-		return MV_NOT_INITIALIZED;
-
-	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
-
-		rule = nfp_bridge_hash[i];
-		while (rule) {
-			tmp = rule;
-			rule = rule->next;
-			mvOsFree(tmp);
-		}
-		nfp_bridge_hash[i] = NULL;
-	}
-#ifdef NFP_CLASSIFY
-	/* Clean bridge invalid rules list */
-	if (bridge_inv_list) {
-		curr = bridge_inv_list->next;
-		while (curr) {
-			tmp_list = curr->next;
-			rule = (NFP_RULE_BRIDGE *)curr->data;
-			mvOsFree(rule);
-			mvListDel(curr);
-			curr = tmp_list;
-		}
-	}
-#endif /* NFP_CLASSIFY */
-	return MV_OK;
-}
-
-void mvNfpBridgeDestroy(void)
-{
-	if (nfp_bridge_hash != NULL)
-		mvOsFree(nfp_bridge_hash);
-#ifdef NFP_CLASSIFY
-	mvListDestroy(bridge_inv_list);
-#endif /* NFP_CLASSIFY */
-}
-
-#ifdef NFP_CLASSIFY
-static NFP_RULE_BRIDGE *mvNfpBridgeRuleInvalidLookup(NFP_RULE_BRIDGE *rule2)
-{
-	MV_LIST_ELEMENT	*curr;
-	NFP_RULE_BRIDGE *rule;
-
-	if (!bridge_inv_list)
-		return NULL;
-
-	curr = bridge_inv_list->next;
-	while (curr) {
-		rule = (NFP_RULE_BRIDGE *)curr->data;
-		if (mvNfpBridgeRuleCmp(rule2->da, rule2->sa, rule2->iif, rule))
-			return rule;
-		curr = curr->next;
-	}
-	return NULL;
-}
-
-NFP_RULE_BRIDGE *mvNfpBridgeClassifyRuleCreate(NFP_RULE_BRIDGE *rule2)
-{
-	/* rule not exist - create rule and mark it as "not exist" */
-	NFP_RULE_BRIDGE *rule = (NFP_RULE_BRIDGE *)mvOsMalloc(sizeof(NFP_RULE_BRIDGE));
-	if (!rule) {
-		mvOsPrintf("%s: OOM\n", __func__);
-		return NULL;
-	}
-
-	mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_BRIDGE));
-
-	rule->flags |= NFP_F_BR_NOT_EXIST;
-	/* this rule is invalid until mvNfpBridgeRuleAdd will be called */
-	mvListAddHead(bridge_inv_list, (MV_ULONG)rule);
-	return rule;
-}
-#endif /* NFP_CLASSIFY */
-
-void mvNfpBridgeFibUpdate(NFP_RULE_BRIDGE *rule, int prev_oif)
-{
-	MV_LIST_ELEMENT	*curr, *tmp;
-	int i;
-	NFP_RULE_FIB	*fib;
-	NFP_IF_MAP      *outIfMap;
-
-	outIfMap = mvNfpIfMapGet(rule->oif);
-	/* Update relevant FIB rules */
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-		while (fib) {
-			if ((prev_oif == fib->oif) &&
-			    (!memcmp(rule->da, fib->da, MV_MAC_ADDR_SIZE)) &&
-			    (!memcmp(rule->sa, fib->sa, MV_MAC_ADDR_SIZE))) {
-				fib->oif = outIfMap->ifIdx;
-				fib->mh = outIfMap->txMh;
-			}
-			fib = fib->next;
-		}
-	}
-
-	curr = fib_inv_list->next;
-	while (curr) {
-		fib = (NFP_RULE_FIB *)curr->data;
-		tmp = curr->next;
-		if ((prev_oif == fib->oif) &&
-		    (!memcmp(rule->da, fib->da, MV_MAC_ADDR_SIZE)) &&
-		    (!memcmp(rule->sa, fib->sa, MV_MAC_ADDR_SIZE))) {
-			fib->oif = outIfMap->ifIdx;
-			fib->mh = outIfMap->txMh;
-			fib->flags &= ~NFP_F_FIB_BRIDGE_INV;
-
-			mvNfpFibRuleValid(fib, curr);
-		}
-		curr = tmp;
-	}
-}
-
-MV_STATUS mvNfpBridgeRuleAdd(NFP_RULE_BRIDGE *rule2)
-{
-	MV_U32          hash;
-	NFP_RULE_BRIDGE *rule;
-	NFP_RULE_FIB    *fib;
-	MV_LIST_ELEMENT	*curr, *tmp;
-	NFP_IF_MAP      *inIfMap, *outIfMap;
-
-	hash = mvNfpBridgeRuleHash(rule2->da, rule2->sa, rule2->iif);
-	rule = nfp_bridge_hash[hash];
-	while (rule) {
-		if (mvNfpBridgeRuleCmp(rule2->da, rule2->sa, rule2->iif, rule)) {
-			MV_U32 age = rule->age;
-
-			/* Update rule, but save age */
-			mvNfpBridgeFibUpdate(rule2, mvNfpIfMapGet(rule->oif)->ifIdx);
-			mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_BRIDGE));
-			rule->age = age;
-			goto out;
-		}
-		rule = rule->next;
-	}
-
-	/* New rule - check that iif and oif connected to the same bridgeIf */
-	inIfMap = mvNfpIfMapGet(rule2->iif);
-	outIfMap = mvNfpIfMapGet(rule2->oif);
-
-	if (mvNfpIfOnSameBridge(inIfMap, outIfMap) == MV_FALSE) {
-		mvOsPrintf("%s: iif=%d and oif=%d are not connected to the same bridge\n",
-					__func__, rule2->iif, rule2->oif);
-		return MV_FAIL;
-	}
-#ifdef NFP_CLASSIFY
-	/* check if there is an invalid rule */
-	rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (rule && (rule->flags & NFP_F_BR_NOT_EXIST)) {
-		rule->flags &= ~NFP_F_BR_NOT_EXIST;
-		rule->oif = rule2->oif;
-		/* remove from invalid list */
-		curr = mvListFind(bridge_inv_list, (MV_ULONG)rule);
-		mvListDel(curr);
-	} else {
-#endif /* NFP_CLASSIFY */
-	rule = (NFP_RULE_BRIDGE *)mvOsMalloc(sizeof(NFP_RULE_BRIDGE));
-	if (rule == NULL) {
-		mvOsPrintf("%s: NFP (bridge rule) - OOM\n", __func__);
-		return MV_FAIL;
-	}
-
-	mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_BRIDGE));
-#ifdef NFP_CLASSIFY
-	}
-#endif /* NFP_CLASSIFY */
-
-	rule->next = nfp_bridge_hash[hash];
-	nfp_bridge_hash[hash] = rule;
-
-	/* Update incomplete FIB entries */
-	curr = fib_inv_list->next;
-	while (curr) {
-		fib = (NFP_RULE_FIB *)curr->data;
-		tmp = curr->next;
-		if ((rule->iif == fib->oif) &&
-		    (!memcmp(rule->da, fib->da, MV_MAC_ADDR_SIZE)) &&
-		    (!memcmp(rule->sa, fib->sa, MV_MAC_ADDR_SIZE))) {
-
-			/* Found incomplete FIB entry */
-			fib->oif = outIfMap->ifIdx;
-			fib->mh = outIfMap->txMh;
-			fib->flags &= ~NFP_F_FIB_BRIDGE_INV;
-
-			mvNfpFibRuleValid(fib, curr);
-		}
-		curr = tmp;
-	}
-
-out:
-	NFP_DBG("NFP (bridge) add %p\n", rule);
-	return MV_OK;
-}
-
-MV_STATUS mvNfpBridgeRuleDel(NFP_RULE_BRIDGE *rule2)
-{
-	MV_U32 hash;
-	NFP_RULE_BRIDGE *rule, *prev;
-	NFP_RULE_FIB	*fib, *fib_prev;
-	NFP_IF_MAP      *ifMap;
-	int i;
-#ifdef NFP_CLASSIFY
-	MV_LIST_ELEMENT	*element;
-#endif /* NFP_CLASSIFY */
-
-	hash = mvNfpBridgeRuleHash(rule2->da, rule2->sa, rule2->iif);
-
-	rule = nfp_bridge_hash[hash];
-	prev = NULL;
-
-	while (rule) {
-		if (mvNfpBridgeRuleCmp(rule2->da, rule2->sa, rule2->iif, rule)) {
-			/* Found: delete rule */
-			if (prev)
-				prev->next = rule->next;
-			else
-				nfp_bridge_hash[hash] = rule->next;
-
-			NFP_DBG("NFP (bridge) del %p\n", rule);
-			rule2->oif = rule->oif;
-			mvOsFree(rule);
-			break;
-		}
-		prev = rule;
-		rule = rule->next;
-	}
-#ifdef NFP_CLASSIFY
-	if (!rule) {
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-		if (rule) {
-			element = mvListFind(bridge_inv_list, (MV_ULONG)rule);
-			mvListDel(element);
-			mvOsFree(rule);
-			/* invalid bridge rules doesn't affect fib rules */
-			return MV_OK;
-		}
-	}
-#endif /* NFP_CLASSIFY */
-	if (!rule)
-		return MV_NOT_FOUND;
-
-	/* Invalidate relevant FIB rules */
-	ifMap = mvNfpIfMapGet(rule2->oif);
-
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-		fib_prev = NULL;
-		while (fib) {
-			if ((rule2->oif == fib->oif) &&
-				(!memcmp(rule2->da, fib->da, MV_MAC_ADDR_SIZE))) {
-				/* Invalidate FIB route. FIXME - update HWF rule */
-				fib->flags |= NFP_F_FIB_BRIDGE_INV;
-				fib->oif = ifMap->bridgeIf;
-
-				/* Remove FIB rule from hash table */
-				if (fib_prev)
-					fib_prev->next = fib->next;
-				else
-					fib_hash[i] = fib->next;
-
-				/* Add FIB rule to incomplete list */
-				mvListAddHead(fib_inv_list, (MV_ULONG)fib);
-#ifdef NFP_CT
-				/* Invalidate relevant CT rules */
-				mvNfpCtRuleFibInvalidate(fib);
-#endif /* NFP_CT */
-			}
-			fib_prev = fib;
-			fib = fib->next;
-		}
-	}
-	return MV_OK;
-}
-
-MV_STATUS mvNfpBridgeRuleAge(NFP_RULE_BRIDGE *rule2)
-{
-	NFP_RULE_BRIDGE *rule;
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-#ifdef NFP_CLASSIFY
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-#endif /* NFP_CLASSIFY */
-	if (rule) {
-		rule2->age = rule->age;
-		rule->age = 0;
-		return MV_OK;
-	}
-	rule2->age = 0;
-	return MV_NOT_FOUND;
-}
-
-#ifdef NFP_CLASSIFY
-MV_STATUS mvNfpBridgeTxqRuleAdd(NFP_RULE_BRIDGE *rule2)
-{
-	NFP_RULE_BRIDGE *rule;
-
-	/* sanity: chack txq parameter */
-	if ((rule2->txq < 0) || (rule2->txq >= CONFIG_MV_ETH_TXQ)) {
-		mvOsPrintf("%s Error: txq (%d) is out of range\n", __func__, rule2->txq);
-		return MV_BAD_PARAM;
-	}
-	if (!(rule2->flags & NFP_F_BR_SET_TXQ)) {
-		mvOsPrintf("%s: NFP_F_BR_SET_TXQ flag is not set\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (!rule) {
-		rule = mvNfpBridgeClassifyRuleCreate(rule2);
-		if (!rule)
-			return MV_FAIL;
-	}
-
-	/* Update rule Txq table */
-	rule->txq = rule2->txq;
-	rule->flags |= NFP_F_BR_SET_TXQ;
-
-	NFP_DBG("NFP (bridge txq) set %p\n", rule);
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpBridgeTxqRuleDel(NFP_RULE_BRIDGE *rule2)
-{
-	NFP_RULE_BRIDGE *rule;
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (rule) {
-		rule->txq = 0;
-		rule->flags &= ~NFP_F_BR_SET_TXQ;
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpBridgeTxpRuleAdd(NFP_RULE_BRIDGE *rule2)
-{
-	NFP_RULE_BRIDGE *rule;
-
-	/* sanity: chack txp parameter */
-	if (rule2->txp < 0) {
-		mvOsPrintf("%s Error: txp (%d) is out of range\n", __func__, rule2->txp);
-		return MV_BAD_PARAM;
-	}
-	if (!(rule2->flags & NFP_F_BR_SET_TXP)) {
-		mvOsPrintf("%s: NFP_F_BR_SET_TXP flag is not set\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (!rule) {
-		rule = mvNfpBridgeClassifyRuleCreate(rule2);
-		if (!rule)
-			return MV_FAIL;
-	}
-
-	/* Update rule Txp table */
-	rule->txp = rule2->txp;
-	rule->flags |= NFP_F_BR_SET_TXP;
-
-	NFP_DBG("NFP (bridge txp) set %p\n", rule);
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpBridgeTxpRuleDel(NFP_RULE_BRIDGE *rule2)
-{
-	NFP_RULE_BRIDGE *rule;
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (rule) {
-		rule->txp = 0;
-		rule->flags &= ~NFP_F_BR_SET_TXP;
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpBridgeMhRuleAdd(NFP_RULE_BRIDGE *rule2)
-{
-	NFP_RULE_BRIDGE *rule;
-
-	/* sanity: chack MH parameter */
-	if ((rule2->mh < 0) || (rule2->mh >= 0xFFFF)) {
-		mvOsPrintf("%s Error: mh (%d) is out of range\n", __func__, rule2->mh);
-		return MV_BAD_PARAM;
-	}
-	if (!(rule2->flags & NFP_F_BR_SET_MH)) {
-		mvOsPrintf("%s: NFP_F_BR_SET_MH flag is not set\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (!rule) {
-		rule = mvNfpBridgeClassifyRuleCreate(rule2);
-		if (!rule)
-			return MV_FAIL;
-	}
-
-	/* Update rule Txq table */
-	rule->mh = rule2->mh;
-	rule->flags |= NFP_F_BR_SET_MH;
-
-	NFP_DBG("NFP (bridge mh) set %p\n", rule);
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpBridgeMhRuleDel(NFP_RULE_BRIDGE *rule2)
-{
-	NFP_RULE_BRIDGE *rule;
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (rule) {
-		rule->mh = 0;
-		rule->flags &= ~NFP_F_BR_SET_MH;
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpBridgeVlanPrioRuleAdd(NFP_RULE_BRIDGE *rule2, int eth_type, int new_prio)
-{
-	NFP_RULE_BRIDGE *rule;
-	int i, first;
-
-	/* sanity: chack new_prio parameter */
-	if ((new_prio < NFP_VPRI_MIN) || (new_prio > NFP_VPRI_MAX)) {
-		mvOsPrintf("%s Error: new_prio value (%d) is out of range\n", __func__, new_prio);
-		return MV_BAD_PARAM;
-	}
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (!rule) {
-		rule = mvNfpBridgeClassifyRuleCreate(rule2);
-		if (!rule)
-			return MV_FAIL;
-	}
-
-	if (eth_type == MV_ETH_NFP_GLOBAL_MAP) {
-		rule->vpri_map[NFP_VPRI_MAP_GLOBAL].eth_type = eth_type;
-		rule->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio = new_prio;
-		rule->vpri_map[NFP_VPRI_MAP_GLOBAL].valid = MV_TRUE;
-	} else {
-		for (first = -1, i = 0; i < NFP_VPRI_MAP_GLOBAL; i++) {
-			if (rule->vpri_map[i].eth_type == eth_type) {
-				rule->vpri_map[i].new_prio = new_prio;	/* just update */
-				return MV_OK;
-			}
-			if ((first == -1) && (rule->vpri_map[i].valid == MV_FALSE))
-				first = i;
-		}
-		if (first != -1) {
-			rule->vpri_map[first].eth_type = eth_type;
-			rule->vpri_map[first].new_prio = new_prio;
-			rule->vpri_map[first].valid = MV_TRUE;
-		} else {
-			mvOsPrintf("%s Error: No available space for additional VPRIO mapping\n", __func__);
-		}
-	}
-	rule->flags |= NFP_F_BR_SET_VLAN_PRIO;
-
-	return MV_OK;
-}
-
-static INLINE MV_STATUS mvNfpIsVpriSet(NFP_RULE_BRIDGE *rule)
-{
-	int i;
-
-	for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++)
-		if (rule->vpri_map[i].valid)
-			return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-MV_STATUS mvNfpBridgeVlanPrioRuleDel(NFP_RULE_BRIDGE *rule2, int eth_type)
-{
-	NFP_RULE_BRIDGE *rule;
-	int i;
-
-	/* sanity: check eth_type parameter */
-	if ((eth_type < MV_ETH_NFP_GLOBAL_MAP) || (eth_type > 0xFFFF)) {
-		mvOsPrintf("%s Error: eth_type value (%d) is out of range\n", __func__, eth_type);
-		return MV_BAD_PARAM;
-	}
-
-	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
-	if (!rule)
-		rule = mvNfpBridgeRuleInvalidLookup(rule2);
-	if (rule) {
-		if (eth_type == MV_ETH_NFP_GLOBAL_MAP) {
-			rule->vpri_map[NFP_VPRI_MAP_GLOBAL].eth_type = 0;
-			rule->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio = 0;
-			rule->vpri_map[NFP_VPRI_MAP_GLOBAL].valid = MV_FALSE;
-		} else {
-			for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++) {
-				if (rule->vpri_map[i].eth_type == eth_type) {
-					rule->vpri_map[i].eth_type = 0;
-					rule->vpri_map[i].new_prio = 0;
-					rule->vpri_map[i].valid = MV_FALSE;
-				}
-			}
-		}
-		if (!mvNfpIsVpriSet(rule))
-			rule->flags &= ~NFP_F_BR_SET_VLAN_PRIO;
-
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-#endif /* NFP_CLASSIFY */
-
-
-static void mvNfpBridgeRulePrint(NFP_RULE_BRIDGE *rule)
-{
-#ifdef NFP_CLASSIFY
-	int i;
-#endif /* NFP_CLASSIFY */
-
-	mvOsPrintf("Bridge: ");
-
-	mvOsPrintf(" DA=" MV_MACQUAD_FMT ", SA=" MV_MACQUAD_FMT ", iif=%u, oif=%u, flags=0x%04x, age=%u\n",
-		MV_MACQUAD(rule->da), MV_MACQUAD(rule->sa), rule->iif, rule->oif, rule->flags, rule->age);
-
-#ifdef NFP_CLASSIFY
-	if (rule->flags & NFP_F_BR_SET_VLAN_PRIO) {
-		mvOsPrintf(" VLAN Prio Map: ");
-		mvOsPrintf("eth_type\t\tVPrio\n");
-		for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++) {
-			if (rule->vpri_map[i].valid) {
-				if (i == NFP_VPRI_MAP_GLOBAL)
-					mvOsPrintf("Global:\t\t%d\n", rule->vpri_map[i].new_prio);
-				else
-					mvOsPrintf("0x%X\t\t%d\n", rule->vpri_map[i].eth_type, rule->vpri_map[i].new_prio);
-			}
-		}
-	}
-	if (rule->flags & NFP_F_BR_NOT_EXIST)
-		mvOsPrintf("This rule is in classification context - use mvNfpBridgeRuleAdd() to make it valid\n");
-#endif /* NFP_CLASSIFY */
-}
-
-void mvNfpBridgeDump(void)
-{
-	int             i;
-	NFP_RULE_BRIDGE *rule;
-#ifdef NFP_CLASSIFY
-	MV_LIST_ELEMENT	*curr;
-#endif /* NFP_CLASSIFY */
-
-	mvOsPrintf("\n(bridge)\n");
-	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
-		rule = nfp_bridge_hash[i];
-
-		while (rule) {
-			mvOsPrintf(" [%5d] ", i);
-			mvNfpBridgeRulePrint(rule);
-			rule = rule->next;
-		}
-	}
-#ifdef NFP_CLASSIFY
-	if (!bridge_inv_list)
-		return;
-	mvOsPrintf("(bridge_inv_list)\n");
-	curr = bridge_inv_list->next;
-	while (curr) {
-		rule = (NFP_RULE_BRIDGE *)curr->data;
-		mvNfpBridgeRulePrint(rule);
-		curr = curr->next;
-	}
-#endif /* NFP_CLASSIFY */
-}
-
-void mvNfpFlushBridge(int ifindex)
-{
-	int i;
-
-	NFP_RULE_BRIDGE *rule;
-
-	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
-		rule = nfp_bridge_hash[i];
-
-		while (rule) {
-			if ((rule->iif == ifindex) || (rule->oif == ifindex) || (ifindex == -1))
-				mvNfpBridgeRuleDel(rule);
-			rule = rule->next;
-		}
-	}
-}
--- a/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpCt.c
+++ /dev/null
@@ -1,1514 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell Interfdbional Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-Interfdbional Ltd. and/or its affiliates ("Marvell") under the following
-alterfdbive licensing terms.  Once you have made an election to distribute the
-File under one of the following license alterfdbives, please (i) delete this
-introductory statement regarding license alterfdbives, (ii) delete the two
-license alterfdbives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-/*******************************************************************************
-* mvNfpCt.c - Marvell Fast Network Processing
-*
-* DESCRIPTION:
-*
-*       Supported Features:
-*       - OS independent.
-*
-*******************************************************************************/
-
-/* includes */
-#include "mvOs.h"
-#include "mvDebug.h"
-#include "mvList.h"
-#include "gbe/mvNeta.h"
-#include "mvNfpDefs.h"
-#include "mvNfp.h"
-
-MV_LIST_ELEMENT *ct_inv_list = NULL;
-NFP_RULE_CT **ct_hash = NULL;
-int ct_iterator_row = 0;
-#ifdef NFP_LIMIT
-MV_LIST_ELEMENT *tbfs;
-#endif /* NFP_LIMIT */
-
-MV_STATUS _INIT mvNfpCtInit(MV_VOID)
-{
-	MV_U32 bytes = sizeof(NFP_RULE_CT *) * NFP_CT_HASH_SIZE;
-
-	ct_hash = (NFP_RULE_CT **)mvOsMalloc(bytes);
-	if (ct_hash == NULL) {
-		mvOsPrintf("NFP (ct): not enough memory for CT database\n");
-		return MV_NO_RESOURCE;
-	}
-
-	mvOsMemset(ct_hash, 0, bytes);
-	ct_inv_list = mvListCreate();
-	if (ct_inv_list == NULL) {
-		mvOsPrintf("NFP (ct): not enough memory for CT database\n");
-		mvOsFree(ct_hash);
-		return MV_NO_RESOURCE;
-	}
-
-	mvOsPrintf("NFP (ct) init %d entries, %d bytes\n", NFP_CT_HASH_SIZE, bytes);
-#ifdef NFP_LIMIT
-	tbfs = mvListCreate();
-	if (tbfs == NULL) {
-		mvOsPrintf("NFP (ct): not enough memory for TBF database\n");
-		mvListDestroy(ct_inv_list);
-		mvOsFree(ct_hash);
-		return MV_NO_RESOURCE;
-	}
-#endif /* NFP_LIMIT */
-	return MV_OK;
-}
-
-static INLINE MV_U32 mvNfpCtHash(NFP_RULE_CT *ct)
-{
-	MV_U32 hash = mv_jhash_2addr(ct->family, (const MV_U8 *)&ct->srcL3, (const MV_U8 *)&ct->dstL3,
-					(ct->ports | ct->proto), nfp_jhash_iv);
-	hash &= NFP_CT_HASH_MASK;
-	return hash;
-}
-
-static INLINE NFP_RULE_CT *mvNfpCtLookup(NFP_RULE_CT *ct2)
-{
-	MV_U32 hash;
-	NFP_RULE_CT *ct;
-
-	if (!ct_hash)
-		return NULL;
-
-	hash = mvNfpCtHash(ct2);
-	ct = ct_hash[hash];
-	while (ct) {
-		if ((ct->family == ct2->family) &&
-			l3_addr_eq(ct->family, ct->srcL3, ct2->srcL3) &&
-			l3_addr_eq(ct->family, ct->dstL3, ct2->dstL3) &&
-			(ct->ports == ct2->ports) && (ct->proto == ct2->proto))
-			return ct;
-		ct = ct->next;
-	}
-
-	return NULL;
-}
-
-/* Move CT rule from ct_inv_list to ct_hash */
-static MV_STATUS mvNfpCtRuleValid(NFP_RULE_CT *ct, MV_LIST_ELEMENT *curr)
-{
-	MV_U32	hash;
-
-	if (((ct->flags & NFP_F_CT_DROP) || !(ct->flags & NFP_F_CT_FIB_INV)) && !(ct->flags & NFP_F_CT_NOT_EXIST)) {
-		/* CT rule became ready */
-
-		/* Delete CT rule from incomplete list */
-		mvListDel(curr);
-
-		/* Add ct to hash table */
-		hash = mvNfpCtHash(ct);
-		ct->next = ct_hash[hash];
-		ct_hash[hash] = ct;
-		ct->visited = 0;
-
-		return MV_OK;
-	}
-	return MV_BAD_PARAM;
-}
-
-MV_VOID mvNfpCtRuleFibUpdate(NFP_RULE_FIB *fib)
-{
-	NFP_RULE_CT	*ct;
-	MV_LIST_ELEMENT	*curr, *tmp;
-	int i;
-
-	/* Update FIB rule pointers in CT hash */
-	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
-		ct = ct_hash[i];
-		while (ct) {
-			if ((fib->family == ct->family) &&
-				(l3_addr_eq(fib->family, fib->srcL3, ct->srcL3)) &&
-#ifdef NFP_NAT
-				((!(ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) ||
-				((ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, (MV_U8 *)&(ct->new_dip)))))) {
-#else
-				(l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) {
-#endif /* NFP_NAT */
-				/* Invalidate CT route */
-				if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
-					(ct->fib)->ct_ref_count--;
-				if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
-					(ct->fib)->ct_hwf_ref_count--;
-				ct->flags &= ~NFP_F_CT_FIB_INV;
-				ct->fib = fib;
-				(ct->fib)->ct_ref_count++;
-				if (ct->flags & NFP_F_CT_HWF)
-					(ct->fib)->ct_hwf_ref_count++;
-			}
-			ct = ct->next;
-		}
-	}
-
-	/* Update FIB rule pointers in CT invalid list */
-	if (!ct_inv_list)
-		return;
-
-	curr = ct_inv_list->next;
-	while (curr) {
-		ct = (NFP_RULE_CT *)curr->data;
-		tmp = curr->next;
-		if ((fib->family == ct->family) &&
-			(l3_addr_eq(fib->family, fib->srcL3, ct->srcL3)) &&
-#ifdef NFP_NAT
-			((!(ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) ||
-			((ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, (MV_U8 *)&(ct->new_dip)))))) {
-#else
-			(l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) {
-#endif /* NFP_NAT */
-			/* Found incomplete CT entry with a matching FIB rule */
-			if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
-				(ct->fib)->ct_ref_count--;
-			if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
-				(ct->fib)->ct_hwf_ref_count--;
-			ct->fib = fib;
-			(ct->fib)->ct_ref_count++;
-			if (ct->flags & NFP_F_CT_HWF)
-				(ct->fib)->ct_hwf_ref_count++;
-			ct->flags &= ~NFP_F_CT_FIB_INV;
-			mvNfpCtRuleValid(ct, curr);
-		}
-		curr = tmp;
-	}
-}
-
-MV_VOID mvNfpCtRuleFibInvalidate(NFP_RULE_FIB *fib)
-{
-	int i;
-	NFP_RULE_CT *ct, *ct_prev;
-	MV_LIST_ELEMENT	*curr;
-
-	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
-		ct = ct_hash[i];
-		ct_prev = NULL;
-		while (ct) {
-			if ((fib->family == ct->family) &&
-				(l3_addr_eq(fib->family, fib->srcL3, ct->srcL3)) &&
-#ifdef NFP_NAT
-				((!(ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) ||
-				((ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, (MV_U8 *)&(ct->new_dip)))))) {
-#else
-				(l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) {
-#endif /* NFP_NAT */
-				/* Invalidate CT route */
-				if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
-					(ct->fib)->ct_ref_count--;
-				if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
-					(ct->fib)->ct_hwf_ref_count--;
-				ct->flags |= NFP_F_CT_FIB_INV;
-				ct->fib = NULL;
-
-				if (!(ct->flags & NFP_F_CT_DROP)) {
-					/* Remove CT rule from hash table only if it is not a DROP rule */
-					if (ct_prev)
-						ct_prev->next = ct->next;
-					else
-						ct_hash[i] = ct->next;
-
-					/* Add CT rule to incomplete list */
-					mvListAddHead(ct_inv_list, (MV_ULONG)ct);
-				}
-			}
-			ct_prev = ct;
-			ct = ct->next;
-		}
-	}
-
-	/* Invalidate FIB rule pointers in CT invalid list (possible in classification context rules) */
-	if (!ct_inv_list)
-		return;
-
-	curr = ct_inv_list->next;
-	while (curr) {
-		ct = (NFP_RULE_CT *)curr->data;
-		if ((fib->family == ct->family) &&
-			(l3_addr_eq(fib->family, fib->srcL3, ct->srcL3)) &&
-#ifdef NFP_NAT
-			((!(ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) ||
-			((ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, (MV_U8 *)&(ct->new_dip)))))) {
-#else
-			(l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) {
-#endif /* NFP_NAT */
-			if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
-				(ct->fib)->ct_ref_count--;
-			if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
-				(ct->fib)->ct_hwf_ref_count--;
-			ct->flags |= NFP_F_CT_FIB_INV;
-			ct->fib = NULL;
-		}
-		curr = curr->next;
-	}
-}
-
-
-static MV_VOID mvNfpCtRulePrint(NFP_RULE_CT *ct)
-{
-#ifdef NFP_CLASSIFY
-	int i;
-#endif /* NFP_CLASSIFY */
-
-	if (ct->family == MV_INET)
-		mvOsPrintf("IPv4: "MV_IPQUAD_FMT":%d->"MV_IPQUAD_FMT":%d",
-			MV_IPQUAD(ct->srcL3), MV_16BIT_BE(ct->ports & 0xFFFF),
-			MV_IPQUAD(ct->dstL3), MV_16BIT_BE(ct->ports >> 16));
-	else /* MV_INET6 */
-		mvOsPrintf(" IPv6: "MV_IP6_FMT":%d->"MV_IP6_FMT":%d",
-			MV_IP6_ARG(ct->srcL3), MV_16BIT_BE(ct->ports & 0xFFFF),
-			MV_IP6_ARG(ct->dstL3), MV_16BIT_BE(ct->ports >> 16));
-
-	if (ct->proto == MV_IP_PROTO_TCP)
-		mvOsPrintf(" TCP - ");
-	else if (ct->proto == MV_IP_PROTO_UDP)
-		mvOsPrintf(" UDP - ");
-	else
-		mvOsPrintf(" %-2d - ", ct->proto);
-
-	if (ct->flags & NFP_F_CT_DROP)
-		mvOsPrintf("Drop, ");
-	else
-		mvOsPrintf("Forward, ");
-
-	mvOsPrintf("flags=0x%04x, ", ct->flags);
-
-#ifdef NFP_NAT
-	if (ct->flags & NFP_F_CT_DNAT)
-		mvOsPrintf("DNAT: "MV_IPQUAD_FMT":%d, ", MV_IPQUAD(((MV_U8 *)&ct->new_dip)), MV_16BIT_BE(ct->new_dport));
-
-	if (ct->flags & NFP_F_CT_SNAT)
-		mvOsPrintf("SNAT: "MV_IPQUAD_FMT":%d, ", MV_IPQUAD(((MV_U8 *)&ct->new_sip)), MV_16BIT_BE(ct->new_sport));
-#endif /* NFP_NAT */
-
-
-#ifdef NFP_CLASSIFY
-	if (ct->flags & NFP_F_CT_NOT_EXIST)
-		mvOsPrintf("This rule is in classification context\n");
-
-	if (ct->flags & NFP_F_CT_SET_MH)
-		mvOsPrintf("MH=0x%X ", ct->mh);
-
-	if (ct->flags & NFP_F_CT_SET_TXP)
-		mvOsPrintf("txp=0x%X ", ct->txp);
-#endif /* NFP_CLASSIFY */
-
-	mvOsPrintf("age=%d, hit=%d\n", ct->age, ct->hit_cntr);
-
-#ifdef NFP_CLASSIFY
-	if (ct->flags & NFP_F_CT_SET_TXQ) {
-		mvOsPrintf(" DSCP to TXQ Map: ");
-		mvOsPrintf("DSCP        TXQ\n");
-		for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++) {
-			if (ct->txq_map[i].valid) {
-				if (i == NFP_DSCP_MAP_GLOBAL)
-					mvOsPrintf("           Global     %2d\n", ct->txq_map[i].txq);
-				else
-					mvOsPrintf("           %2d         %2d\n", i, ct->txq_map[i].txq);
-			}
-		}
-	}
-
-	if (ct->flags & NFP_F_CT_SET_DSCP) {
-		mvOsPrintf(" DSCP Map: ");
-		mvOsPrintf("Old        New\n");
-		for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++) {
-			if (ct->dscp_map[i].valid) {
-				if (i == NFP_DSCP_MAP_GLOBAL)
-					mvOsPrintf("           Global     %2d\n", ct->dscp_map[i].new_dscp);
-				else
-					mvOsPrintf("           %2d         %2d\n", i, ct->dscp_map[i].new_dscp);
-			}
-		}
-	}
-
-	if (ct->flags & NFP_F_CT_SET_VLAN_PRIO) {
-		mvOsPrintf(" VPri Map: ");
-		mvOsPrintf("Old        New\n");
-		for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++) {
-			if (ct->vpri_map[i].valid) {
-				if (i == NFP_VPRI_MAP_GLOBAL)
-					mvOsPrintf("           Global     %2d\n", ct->vpri_map[i].new_prio);
-				else
-					mvOsPrintf("           %2d         %2d\n", i, ct->vpri_map[i].new_prio);
-			}
-		}
-	}
-#endif /* NFP_CLASSIFY */
-}
-
-static NFP_RULE_CT *mvNfpCtRuleInvalidLookup(NFP_RULE_CT *ct2)
-{
-	MV_LIST_ELEMENT	*curr;
-	NFP_RULE_CT *ct;
-
-	if (!ct_inv_list)
-		return NULL;
-
-	curr = ct_inv_list->next;
-	while (curr) {
-		ct = (NFP_RULE_CT *)curr->data;
-		if ((ct->family == ct2->family) &&
-			l3_addr_eq(ct->family, ct->srcL3, ct2->srcL3) &&
-			l3_addr_eq(ct->family, ct->dstL3, ct2->dstL3) &&
-			(ct->ports == ct2->ports) &&
-			(ct->proto == ct2->proto))
-			return ct;
-
-		curr = curr->next;
-	}
-	return NULL;
-}
-
-MV_STATUS   mvNfpCtRuleAge(NFP_RULE_CT *ct2)
-{
-	NFP_RULE_CT *ct;
-
-	ct = mvNfpCtRuleInvalidLookup(ct2);
-	if (ct) {
-		ct2->age = (ct->flags & NFP_F_CT_HWF) ? 1 : ct->age;
-		ct->age = (ct->flags & NFP_F_CT_HWF) ? ct->age : 0;
-		return MV_OK;
-	}
-
-	ct = mvNfpCtLookup(ct2);
-	if (ct) {
-		ct2->age = (ct->flags & NFP_F_CT_HWF) ? 1 : ct->age;
-		ct->age = (ct->flags & NFP_F_CT_HWF) ? ct->age : 0;
-		return MV_OK;
-	}
-
-	ct2->age = 0;
-	return MV_NOT_FOUND;
-}
-
-/* create rule from classification context                                           *
- *     - search and update if relevant FIB rule exist                                *
- *     - set NFP_F_CT_NOT_EXIST flag                                                 *
- *     - add rule to invalid rule list (NFP_F_CT_NOT_EXIST is set)                   *
- *     - if mvNfpCtFilterModeSet is called later, then clear NFP_F_CT_NOT_EXIST flag *
- * Return: pointer to created rule                                                   */
-NFP_RULE_CT *mvNfpCtClassifyRuleCreate(NFP_RULE_CT *ct2)
-{
-	/* rule not exist - create rule and mark it as "not exist" */
-	NFP_RULE_CT *ct = (NFP_RULE_CT *)mvOsMalloc(sizeof(NFP_RULE_CT));
-	if (!ct) {
-		mvOsPrintf("%s: OOM\n", __func__);
-		return NULL;
-	}
-
-	mvOsMemcpy(ct, ct2, sizeof(NFP_RULE_CT));
-
-	ct->flags |= NFP_F_CT_NOT_EXIST;
-	ct->flags |= NFP_F_CT_FIB_INV;
-	/* this rule is invalid until mvNfpCtFilterModeSet will be called */
-	mvListAddHead(ct_inv_list, (MV_ULONG)ct);
-	return ct;
-}
-
-#ifdef NFP_NAT
-MV_STATUS mvNfpCtNatRuleAdd(NFP_RULE_CT *nat2)
-{
-	NFP_RULE_CT *nat;
-	MV_U32 hash;
-
-	/* Update rule if it exists as a valid rule or as an invalid rule */
-	nat = mvNfpCtLookup(nat2);
-	if (!nat)
-		nat = mvNfpCtRuleInvalidLookup(nat2);
-
-	if (nat) {
-		if (nat->flags & NFP_F_CT_NOT_EXIST)
-			nat->flags &= ~NFP_F_CT_NOT_EXIST;
-		if (nat2->flags & NFP_F_CT_SNAT) {
-			nat->new_sip = nat2->new_sip;
-			nat->new_sport = nat2->new_sport;
-			nat->flags |= NFP_F_CT_SNAT;
-		}
-		if (nat2->flags & NFP_F_CT_DNAT) {
-			nat->new_dip = nat2->new_dip;
-			nat->new_dport = nat2->new_dport;
-			nat->flags |= NFP_F_CT_DNAT;
-		}
-		/* copy other information to nat2 - classification, tbf, etc.. */
-		mvOsMemcpy(nat2, nat, sizeof(NFP_RULE_CT));
-
-		/* delete previous rule, and add it again later (will search for fib again)    */
-		/* delete is important because it updates fib->ct_ref_count, rate limit, etc.. */
-		mvNfpCtRuleDel(nat);
-	}
-
-	nat = (NFP_RULE_CT *)mvOsMalloc(sizeof(NFP_RULE_CT));
-	if (!nat) {
-		mvOsPrintf("%s: OOM\n", __func__);
-		return MV_FAIL;
-	}
-	mvOsMemcpy(nat, nat2, sizeof(NFP_RULE_CT));
-
-	if (nat->flags & NFP_F_CT_DNAT)
-		nat->fib = mvNfpFibLookup(nat2->family, nat2->srcL3, (const MV_U8 *)&(nat2->new_dip));
-	else
-		nat->fib = mvNfpFibLookup(nat2->family, nat2->srcL3, nat2->dstL3);
-
-	if (nat->fib) {
-		(nat->fib)->ct_ref_count++; /* update FIB reference count */
-		hash = mvNfpCtHash(nat2);
-		nat->next = ct_hash[hash];
-		ct_hash[hash] = nat;
-		nat->visited = 0;
-	} else {
-		mvListAddHead(ct_inv_list, (MV_ULONG)nat);
-	}
-
-	NFP_DBG("NFP (nat) add %p\n", nat);
-
-	return MV_OK;
-}
-#endif /* NFP_NAT */
-
-MV_STATUS mvNfpCtFilterModeSet(NFP_RULE_CT *ct2)
-{
-	NFP_RULE_CT *ct, *new_ct;
-	MV_LIST_ELEMENT	*element;
-	MV_U32 hash;
-
-	/* The rule can be in one of several initial states, each requires different handling	*/
-	/* The rule can exists as valid, exist as invalid or not exist at this point		*/
-
-	ct = mvNfpCtLookup(ct2);
-	if (ct) {
-		/* Rule exists as valid */
-		/* Either it has valid FIB information, or it is a DROP rule */
-
-		if (ct2->flags & NFP_F_CT_DROP) {
-			/* Updated rule says DROP, so we don't care if FIB information exists or not */
-			ct->flags |= NFP_F_CT_DROP;
-		} else {
-			/* Updated rule says FORWARD */
-			ct->flags &= ~NFP_F_CT_DROP;
-			if (ct->flags & NFP_F_CT_FIB_INV) {
-				/* need to move this rule to the invalid list */
-				new_ct = (NFP_RULE_CT *)mvOsMalloc(sizeof(NFP_RULE_CT));
-				if (!new_ct) {
-					mvOsPrintf("%s: OOM\n", __func__);
-					return MV_FAIL;
-				}
-				mvOsMemcpy(new_ct, ct, sizeof(NFP_RULE_CT));
-#ifdef NFP_LIMIT
-				if (new_ct->tbfInfo)
-					new_ct->tbfInfo->refCnt++;
-#endif /* NFP_LIMIT */
-				mvNfpCtRuleDel(ct);
-				mvListAddHead(ct_inv_list, (MV_ULONG)new_ct);
-			}
-		}
-		return MV_OK;
-	}
-
-
-	ct = mvNfpCtRuleInvalidLookup(ct2);
-	/* Rule exists as invalid */
-	if (ct) {
-		/* this rule was created by classification API  *
-		 *     mark it as "real" rule                   *
-		 *     search for relevant fib rule             */
-		if (ct->flags & NFP_F_CT_NOT_EXIST) {
-			ct->flags &= ~NFP_F_CT_NOT_EXIST;
-			ct->flags |= NFP_F_CT_FIB_INV;
-			ct->fib = mvNfpFibLookup(ct2->family, ct2->srcL3, ct2->dstL3);
-			if (ct->fib) {
-				(ct->fib)->ct_ref_count++;
-				ct->flags &= ~NFP_F_CT_FIB_INV;
-			}
-		}
-		if (ct2->flags & NFP_F_CT_DROP || !(ct->flags & NFP_F_CT_FIB_INV)) {
-			/* need to move this rule to the valid rules database */
-			if (ct2->flags & NFP_F_CT_DROP)
-				ct->flags |= NFP_F_CT_DROP;
-			element = mvListFind(ct_inv_list, (MV_ULONG)ct);
-			if (!element)
-				return MV_FAIL;
-			return mvNfpCtRuleValid(ct, element);
-		} else {
-			/* no need to do anything special - clearing DROP flag just for clarity, it is already cleared */
-			ct->flags &= ~NFP_F_CT_DROP;
-			return MV_OK;
-		}
-	}
-
-
-	/* Rule doesn't exist, need to create  a new one */
-	ct = (NFP_RULE_CT *)mvOsMalloc(sizeof(NFP_RULE_CT));
-	if (!ct) {
-		mvOsPrintf("%s: OOM\n", __func__);
-		return MV_FAIL;
-	}
-
-	mvOsMemcpy(ct, ct2, sizeof(NFP_RULE_CT));
-
-	ct->flags |= NFP_F_CT_FIB_INV;
-	ct->fib = mvNfpFibLookup(ct2->family, ct2->srcL3, ct2->dstL3);
-	if (ct->fib) {
-		(ct->fib)->ct_ref_count++;
-		ct->flags &= ~NFP_F_CT_FIB_INV;
-	}
-
-	if ((ct->flags & NFP_F_CT_DROP) || !(ct->flags & NFP_F_CT_FIB_INV)) {
-		hash = mvNfpCtHash(ct2);
-		ct->next = ct_hash[hash];
-		ct_hash[hash] = ct;
-		ct->visited = 0;
-	} else {
-		mvListAddHead(ct_inv_list, (MV_ULONG)ct);
-	}
-
-	NFP_DBG("NFP (ct filter mode) set %p\n", ct);
-
-	return MV_OK;
-}
-
-#ifdef NFP_LIMIT
-void mvNfpCtTbfsDump(void)
-{
-	MV_LIST_ELEMENT	*curr;
-	NFP_TBF_INFO *tbf_data;
-	mvOsPrintf("Tbfs list:\n");
-	if (!tbfs)
-		return;
-	curr = tbfs->next;
-	while (curr) {
-		tbf_data = (NFP_TBF_INFO *)curr->data;
-		mvOsPrintf("index: %d,  limit: %d,  burst: %d, refCnt: %d\n", tbf_data->index,
-				tbf_data->creditPerTick * mvOsGetTicksFreq(), tbf_data->creditMax, tbf_data->refCnt);
-		curr = curr->next;
-	}
-	mvOsPrintf("\n");
-}
-
-/* limit units = KBytes/sec, burst_limit units = Kbytes */
-int mvNfpTbfCreate(int limit, int burst_limit)
-{
-	NFP_TBF_INFO *tbf;
-
-	if (limit < 0 || burst_limit < 0 || !tbfs)
-		return -1;
-
-	tbf = mvOsMalloc(sizeof(NFP_TBF_INFO));
-	if (!tbf) {
-		mvOsPrintf("%s: OOM\n", __func__);
-		return -1;
-	}
-
-	tbf->refCnt = 0;
-	tbf->credit = tbf->creditMax = (burst_limit * 1000); /* Bytes */
-	/* convert from KBytes/sec to Bytes/tick */
-	tbf->creditPerTick = (limit * 1000) / mvOsGetTicksFreq(); /* Bytes per tick */
-	if (tbf->creditPerTick == 0)
-		tbf->maxElapsedTicks = 0;
-	else
-		tbf->maxElapsedTicks = tbf->creditMax / tbf->creditPerTick; /* ticks */
-	tbf->lastUpdate = mvOsGetTicks(); /* ticks */
-
-	/* calculate index */
-	if (tbfs->next)
-		tbf->index = ((NFP_TBF_INFO *)(tbfs->next->data))->index + 1;
-	else
-		tbf->index = 0;
-
-	if (!mvListAddHead(tbfs, (MV_U32)tbf)) {
-		mvOsPrintf("%s: OOM\n", __func__);
-		mvOsFree(tbf);
-		return -1;
-	}
-	return tbf->index;
-}
-
-NFP_TBF_INFO *mvNfpTbfGet(int tbf)
-{
-	MV_LIST_ELEMENT	*curr;
-	NFP_TBF_INFO *tbf_data;
-	if (tbf < 0 || !tbfs)
-		return NULL;
-	curr = tbfs->next;
-	while (curr) {
-		tbf_data = (NFP_TBF_INFO *)curr->data;
-		if (tbf_data->index == tbf)
-			return tbf_data;
-		curr = curr->next;
-	}
-	return NULL;
-}
-
-MV_STATUS mvNfpTbfDel(int tbf)
-{
-	MV_LIST_ELEMENT *element;
-	NFP_TBF_INFO *tbf_data = mvNfpTbfGet(tbf);
-	if (!tbf_data) {
-		mvOsPrintf("%s: Invalid Token Bucket Filter index (%d)\n", __func__, tbf);
-		return MV_BAD_PARAM;
-	}
-	/* delete tbf only if there are no rules attached */
-	if (!tbf_data->refCnt) {
-		element = mvListFind(tbfs, (MV_ULONG)tbf_data);
-		mvListDel(element);
-		mvOsFree(tbf_data);
-	}
-	return MV_OK;
-}
-
-MV_STATUS mvNfpCtRateLimitSet(NFP_RULE_CT *ct2, int tbf_index)
-{
-	NFP_RULE_CT *ct;
-	NFP_TBF_INFO *tbf = mvNfpTbfGet(tbf_index);
-
-	if (!ct2)
-		return MV_BAD_PARAM;
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-
-	if (ct) {
-		if (tbf) {
-			if (ct->tbfInfo)
-				(ct->tbfInfo)->refCnt--;
-			tbf->refCnt++;
-			ct->tbfInfo = tbf;
-			ct->flags |= NFP_F_CT_LIMIT;
-		} else {
-			mvOsPrintf("%s: Invalid Token Bucket Filter index (%d)\n", __func__, tbf_index);
-			return MV_BAD_PARAM;
-		}
-	} else {
-		mvOsPrintf("%s Error: Could not find existing 5 tuple rule\n", __func__);
-		return MV_NOT_FOUND;
-	}
-
-	NFP_DBG("NFP (ct rate limit) set %p\n", ct);
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpCtRateLimitDel(NFP_RULE_CT *ct2)
-{
-	NFP_RULE_CT *ct;
-
-	if (!ct2)
-		return MV_BAD_PARAM;
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-
-	if (ct) {
-		if (ct->tbfInfo)
-			(ct->tbfInfo)->refCnt--;
-
-		ct->tbfInfo = NULL;
-		ct->flags &= ~NFP_F_CT_LIMIT;
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpTbfProcess(NFP_TBF_INFO *tbf, MV_U32 packetSize)
-{
-	MV_U32 ticks = mvOsGetTicks();
-	MV_U32 elapsed;
-
-	if (!tbf)
-		return MV_CONTINUE;
-	/* Update credit */
-	elapsed = ticks - tbf->lastUpdate;
-	tbf->lastUpdate = ticks;
-	/* safe check if elapsed time is higher than "time that gives maximum credit" */
-	if (elapsed > tbf->maxElapsedTicks) {
-		tbf->credit = tbf->creditMax;
-	} else {
-		tbf->credit += elapsed * tbf->creditPerTick;
-		if (tbf->credit > tbf->creditMax)
-			tbf->credit = tbf->creditMax;
-	}
-
-	/* Check result */
-	if (packetSize > tbf->credit)
-		return MV_DROPPED;
-	tbf->credit -= packetSize;
-	return MV_CONTINUE;
-}
-#endif /* NFP_LIMIT */
-
-#ifdef NFP_CLASSIFY
-/* Add DSCP mapping for an existing 5 tuple rule */
-MV_STATUS mvNfpCtDscpRuleAdd(NFP_RULE_CT *ct2, int dscp, int new_dscp)
-{
-	NFP_RULE_CT *ct;
-
-	/* sanity: chack new_dscp parameter */
-	if ((new_dscp < NFP_DSCP_MIN) || (new_dscp > NFP_DSCP_MAX)) {
-		mvOsPrintf("%s Error: new_dscp value (%d) is out of range\n", __func__, new_dscp);
-		return MV_BAD_PARAM;
-	}
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-	/* rule is not exist - create rule from classification context */
-	if (!ct) {
-		ct = mvNfpCtClassifyRuleCreate(ct2);
-		if (!ct)
-			return MV_FAIL;
-	}
-
-	/* Update rule DSCP map table */
-	if (ct2->flags & NFP_F_CT_SET_DSCP) {
-		if (dscp == MV_ETH_NFP_GLOBAL_MAP) {
-			ct->dscp_map[NFP_DSCP_MAP_GLOBAL].new_dscp = new_dscp;
-			ct->dscp_map[NFP_DSCP_MAP_GLOBAL].valid = MV_TRUE;
-		} else if ((dscp >= NFP_DSCP_MIN) && (dscp <= NFP_DSCP_MAX)) {
-			ct->dscp_map[dscp].new_dscp = new_dscp;
-			ct->dscp_map[dscp].valid = MV_TRUE;
-		} else {
-			mvOsPrintf("%s Error: dscp value (%d) is out of range\n", __func__, dscp);
-			return MV_BAD_PARAM;
-		}
-		ct->flags |= NFP_F_CT_SET_DSCP;
-	} else {
-		mvOsPrintf("%s Error: NFP_F_CT_SET_DSCP flag is not set\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	NFP_DBG("NFP (ct dscp) set %p\n", ct);
-
-	return MV_OK;
-}
-
-static INLINE MV_STATUS mvNfpIsDscpSet(NFP_RULE_CT *ct)
-{
-	int i;
-
-	for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++)
-		if (ct->dscp_map[i].valid)
-			return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-MV_STATUS mvNfpCtDscpRuleDel(NFP_RULE_CT *ct2, int dscp)
-{
-	NFP_RULE_CT *ct;
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-
-	if (ct) {
-		if (dscp == MV_ETH_NFP_GLOBAL_MAP) {
-			ct->dscp_map[NFP_DSCP_MAP_GLOBAL].new_dscp = 0;
-			ct->dscp_map[NFP_DSCP_MAP_GLOBAL].valid = MV_FALSE;
-		} else if ((dscp >= NFP_DSCP_MIN) && (dscp <= NFP_DSCP_MAX)) {
-			ct->dscp_map[dscp].new_dscp = 0;
-			ct->dscp_map[dscp].valid = MV_FALSE;
-		} else {
-			mvOsPrintf("%s Error: dscp value (%d) is out of range\n", __func__, dscp);
-			return MV_BAD_PARAM;
-		}
-
-		if (!mvNfpIsDscpSet(ct))
-			ct->flags &= ~NFP_F_CT_SET_DSCP;
-
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpCtVlanPrioRuleAdd(NFP_RULE_CT *ct2, int prio, int new_prio)
-{
-	NFP_RULE_CT *ct;
-
-	/* sanity: chack new_prio parameter */
-	if ((new_prio < NFP_VPRI_MIN) || (new_prio > NFP_VPRI_MAX)) {
-		mvOsPrintf("%s Error: new_prio value (%d) is out of range\n", __func__, new_prio);
-		return MV_BAD_PARAM;
-	}
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-	/* rule is not exist - create rule from classification context */
-	if (!ct) {
-		ct = mvNfpCtClassifyRuleCreate(ct2);
-		if (!ct)
-			return MV_FAIL;
-	}
-
-	/* Update rule VLAN Priority map table */
-	if (ct2->flags & NFP_F_CT_SET_VLAN_PRIO) {
-		if (prio == MV_ETH_NFP_GLOBAL_MAP) {
-			ct->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio = new_prio;
-			ct->vpri_map[NFP_VPRI_MAP_GLOBAL].valid = MV_TRUE;
-		} else if ((prio >= NFP_VPRI_MIN) && (prio <= NFP_VPRI_MAX)) {
-			ct->vpri_map[prio].new_prio = new_prio;
-			ct->vpri_map[prio].valid = MV_TRUE;
-		} else {
-			mvOsPrintf("%s Error: prio value (%d) is out of range\n", __func__, prio);
-			return MV_BAD_PARAM;
-		}
-		ct->flags |= NFP_F_CT_SET_VLAN_PRIO;
-	} else {
-		mvOsPrintf("%s: NFP_F_CT_SET_VLAN_PRIO flag is not set\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	NFP_DBG("NFP (ct vpri) set %p\n", ct);
-
-	return MV_OK;
-}
-
-static INLINE MV_STATUS mvNfpIsVpriSet(NFP_RULE_CT *ct)
-{
-	int i;
-
-	for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++)
-		if (ct->vpri_map[i].valid)
-			return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-MV_STATUS mvNfpCtVlanPrioRuleDel(NFP_RULE_CT *ct2, int prio)
-{
-	NFP_RULE_CT *ct;
-
-	/* sanity: chack prio parameter */
-	if ((prio < MV_ETH_NFP_GLOBAL_MAP) || (prio > NFP_VPRI_MAP_GLOBAL)) {
-		mvOsPrintf("%s Error: prio value (%d) is out of range\n", __func__, prio);
-		return MV_BAD_PARAM;
-	}
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-
-	if (ct) {
-		if (prio == MV_ETH_NFP_GLOBAL_MAP) {
-			ct->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio = 0;
-			ct->vpri_map[NFP_VPRI_MAP_GLOBAL].valid = MV_FALSE;
-		} else {
-			ct->vpri_map[prio].new_prio = 0;
-			ct->vpri_map[prio].valid = MV_FALSE;
-		}
-		if (!mvNfpIsVpriSet(ct))
-			ct->flags &= ~NFP_F_CT_SET_VLAN_PRIO;
-
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpCtTxqRuleAdd(NFP_RULE_CT *ct2, int dscp, int txq)
-{
-	NFP_RULE_CT *ct;
-
-	/* sanity: chack txq parameter */
-	if ((txq < 0) || (txq >= CONFIG_MV_ETH_TXQ)) {
-		mvOsPrintf("%s Error: txq (%d) is out of range\n", __func__, txq);
-		return MV_BAD_PARAM;
-	}
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-	/* rule is not exist - create rule from classification context */
-	if (!ct) {
-		ct = mvNfpCtClassifyRuleCreate(ct2);
-		if (!ct)
-			return MV_FAIL;
-	}
-
-	/* Update rule DSCP to TXQ map table */
-	if (ct2->flags & NFP_F_CT_SET_TXQ) {
-		if (dscp == MV_ETH_NFP_GLOBAL_MAP) {
-			ct->txq_map[NFP_DSCP_MAP_GLOBAL].txq = txq;
-			ct->txq_map[NFP_DSCP_MAP_GLOBAL].valid = MV_TRUE;
-		} else if ((dscp >= NFP_DSCP_MIN) && (dscp <= NFP_DSCP_MAX)) {
-			ct->txq_map[dscp].txq = txq;
-			ct->txq_map[dscp].valid = MV_TRUE;
-		} else {
-			mvOsPrintf("%s Error: dscp value (%d) is out of range\n", __func__, dscp);
-			return MV_BAD_PARAM;
-		}
-		ct->flags |= NFP_F_CT_SET_TXQ;
-	} else {
-		mvOsPrintf("%s Error: NFP_F_CT_SET_TXQ flag is not set\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	NFP_DBG("NFP (ct txq) set %p\n", ct);
-
-	return MV_OK;
-}
-
-static INLINE MV_STATUS mvNfpIsTxqSet(NFP_RULE_CT *ct)
-{
-	int i;
-
-	for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++)
-		if (ct->txq_map[i].valid)
-			return MV_TRUE;
-
-	return MV_FALSE;
-}
-
-MV_STATUS mvNfpCtTxqRuleDel(NFP_RULE_CT *ct2, int dscp)
-{
-	NFP_RULE_CT *ct;
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-
-	if (ct) {
-		if (dscp == MV_ETH_NFP_GLOBAL_MAP) {
-			ct->txq_map[NFP_DSCP_MAP_GLOBAL].txq = 0;
-			ct->txq_map[NFP_DSCP_MAP_GLOBAL].valid = MV_FALSE;
-		} else if ((dscp >= NFP_DSCP_MIN) && (dscp <= NFP_DSCP_MAX)) {
-			ct->txq_map[dscp].txq = 0;
-			ct->txq_map[dscp].valid = MV_FALSE;
-		} else {
-			mvOsPrintf("%s Error: dscp value (%d) is out of range\n", __func__, dscp);
-			return MV_BAD_PARAM;
-		}
-
-		if (!mvNfpIsTxqSet(ct))
-			ct->flags &= ~NFP_F_CT_SET_TXQ;
-
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpCtTxpRuleAdd(NFP_RULE_CT *ct2)
-{
-	NFP_RULE_CT *ct;
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-	/* rule is not exist - create rule from classification context */
-	if (!ct) {
-		ct = mvNfpCtClassifyRuleCreate(ct2);
-		if (!ct)
-			return MV_FAIL;
-	}
-
-	/* Update rule Txq table */
-	if (ct2->flags & NFP_F_CT_SET_TXP) {
-		ct->txp = ct2->txp;
-		ct->flags |= NFP_F_CT_SET_TXP;
-	} else {
-		mvOsPrintf("%s: NFP_F_CT_SET_TXP flag is not set\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	NFP_DBG("NFP (ct txp) set %p\n", ct);
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpCtTxpRuleDel(NFP_RULE_CT *ct2)
-{
-	NFP_RULE_CT *ct;
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-
-	if (ct) {
-		ct->txp = 0;
-		ct->flags &= ~NFP_F_CT_SET_TXP;
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpCtMhRuleAdd(NFP_RULE_CT *ct2)
-{
-	NFP_RULE_CT *ct;
-
-	/* sanity: chack mh parameter */
-	if (ct2->mh < 0) {
-		mvOsPrintf("%s Error: mh (%d) is out of range\n", __func__, ct2->mh);
-		return MV_BAD_PARAM;
-	}
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-	/* rule is not exist - create rule from classification context */
-	if (!ct) {
-		ct = mvNfpCtClassifyRuleCreate(ct2);
-		if (!ct)
-			return MV_FAIL;
-	}
-
-	/* Update rule MH table */
-	if (ct2->flags & NFP_F_CT_SET_MH) {
-		ct->mh = ct2->mh;
-		ct->flags |= NFP_F_CT_SET_MH;
-	} else {
-		mvOsPrintf("%s: NFP_F_CT_SET_MH flag is not set\n", __func__);
-		return MV_BAD_PARAM;
-	}
-
-	NFP_DBG("NFP (ct mh) set %p\n", ct);
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpCtMhRuleDel(NFP_RULE_CT *ct2)
-{
-	NFP_RULE_CT *ct;
-
-	/* Rule must exist already, but it can be valid or invalid */
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-
-	if (ct) {
-		ct->mh = 0;
-		ct->flags &= ~NFP_F_CT_SET_MH;
-		return MV_OK;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-#endif /* NFP_CLASSIFY */
-
-MV_STATUS mvNfpCtRuleDel(NFP_RULE_CT *ct2)
-{
-	MV_U32 hash;
-	NFP_RULE_CT *ct, *prev;
-	MV_LIST_ELEMENT	*element;
-
-	/* If this rule currently exists in the Invalid Rules DB, delete it */
-	ct = mvNfpCtRuleInvalidLookup(ct2);
-	if (ct) {
-		if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
-			(ct->fib)->ct_ref_count--;
-		if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
-			(ct->fib)->ct_hwf_ref_count--;
-		element = mvListFind(ct_inv_list, (MV_ULONG)ct);
-#ifdef NFP_LIMIT
-		if (ct->tbfInfo)
-			mvNfpCtRateLimitDel(ct);
-#endif /* NFP_LIMIT */
-		mvListDel(element);
-		mvOsFree(ct);
-		return MV_OK;
-	}
-
-	hash = mvNfpCtHash(ct2);
-	ct = ct_hash[hash];
-
-	prev = NULL;
-	while (ct) {
-		if ((ct->family == ct2->family) &&
-			l3_addr_eq(ct->family, ct->srcL3, ct2->srcL3) &&
-			l3_addr_eq(ct->family, ct->dstL3, ct2->dstL3) &&
-			(ct->ports == ct2->ports) &&
-			(ct->proto == ct2->proto)) {
-			if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
-				(ct->fib)->ct_ref_count--;
-			if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
-				(ct->fib)->ct_hwf_ref_count--;
-			if (prev)
-				prev->next = ct->next;
-			else
-				ct_hash[hash] = ct->next;
-
-			NFP_DBG("NFP (ct) del %p\n", ct);
-#ifdef NFP_LIMIT
-			if (ct->tbfInfo)
-				mvNfpCtRateLimitDel(ct);
-#endif /* NFP_LIMIT */
-			mvOsFree(ct);
-			return MV_OK;
-		}
-		prev = ct;
-		ct = ct->next;
-	}
-
-	return MV_NOT_FOUND;
-}
-
-void    mvNfpCtClean(int family)
-{
-	int             i;
-	NFP_RULE_CT    *ct, *next;
-#ifdef NFP_LIMIT
-	NFP_TBF_INFO *tbf_data;
-#endif /* NFP_LIMIT */
-	MV_LIST_ELEMENT	*curr, *tmp;
-
-	/* Clean CT incomplete rules list */
-	if (ct_inv_list) {
-		curr = ct_inv_list->next;
-		while (curr) {
-			tmp = curr->next;
-			ct = (NFP_RULE_CT *)curr->data;
-			if (ct->family == family) {
-#ifdef NFP_LIMIT
-			if (ct->tbfInfo)
-				mvNfpCtRateLimitDel(ct);
-#endif /* NFP_LIMIT */
-			mvOsFree(ct);
-			mvListDel(curr);
-			}
-			curr = tmp;
-		}
-	}
-
-	/* Clean CT hash table */
-	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
-		ct = ct_hash[i];
-
-		while (ct) {
-			next = ct->next;
-			if (ct->family == family) {
-#ifdef NFP_LIMIT
-			if (ct->tbfInfo)
-				mvNfpCtRateLimitDel(ct);
-#endif /* NFP_LIMIT */
-			mvOsFree(ct);
-			}
-			ct = next;
-		}
-		ct_hash[i] = NULL;
-	}
-#ifdef NFP_LIMIT
-	/* clean tbfs */
-	if (tbfs) {
-		curr = tbfs->next;
-		while (curr) {
-			tbf_data = (NFP_TBF_INFO *)mvListDel(curr);
-			mvOsFree(tbf_data);
-			curr = tbfs->next;
-		}
-	}
-
-#endif /* NFP_LIMIT */
-}
-
-void	mvNfpCtDestroy(void)
-{
-	if (ct_hash)
-		mvOsFree(ct_hash);
-#ifdef NFP_LIMIT
-	if (tbfs)
-		mvOsFree(tbfs);
-#endif /* NFP_LIMIT */
-	mvListDestroy(ct_inv_list);
-}
-
-MV_VOID mvNfpCtCleanVisited(MV_U32 row, MV_U32 iterator_id)
-{
-	NFP_RULE_CT *curr  = ct_hash[row];
-
-	while (curr) {
-		curr->visited = curr->visited & ~(1 << iterator_id);
-		curr = curr->next;
-	}
-}
-
-MV_STATUS mvNfpCtFirstRuleGet(NFP_RULE_CT **rule, MV_U32 iterator_id)
-{
-	mvNfpCtCleanVisited(ct_iterator_row, iterator_id);
-	ct_iterator_row  = 0;
-	return mvNfpCtNextRuleGet(rule, iterator_id);
-}
-
-MV_STATUS mvNfpCtNextRuleGet(NFP_RULE_CT **rule, MV_U32 iterator_id)
-{
-	NFP_RULE_CT *curr;
-
-	while (ct_iterator_row < NFP_CT_HASH_SIZE) {
-		curr  = ct_hash[ct_iterator_row];
-		/* skip visited and HWF processed rules */
-		while (curr && ((curr->visited & (1 << iterator_id))
-				|| (curr->flags & NFP_F_CT_HWF)))
-			curr = curr->next;
-		if (!curr) { /* reached end of line */
-			mvNfpCtCleanVisited(ct_iterator_row, iterator_id);
-			ct_iterator_row++;
-			continue;
-		}
-		curr->visited = 1; /* update - this rule is now visited by iterator */
-		*rule = curr;
-		return MV_OK;
-	}
-	/* reached end of DB - no rule is found */
-	ct_iterator_row = 0; /* next call start from the begining of the DB */
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpCtRuleMaxHitCntrGet(NFP_RULE_CT **rule)
-{
-	int i;
-	MV_U32 max = -1;
-	NFP_RULE_CT *curr, *max_rule = NULL;
-
-	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
-		curr = ct_hash[i];
-		while (curr) {
-			if (curr->flags & NFP_F_CT_HWF) {
-				curr = curr->next;
-				continue;
-			}
-			if (curr->hit_cntr > max || !max_rule) {
-				max = curr->hit_cntr;
-				max_rule = curr;
-			}
-			curr = curr->next;
-		}
-	}
-	if (!max_rule)
-		return MV_NOT_FOUND;
-	*rule = max_rule;
-	return MV_OK;
-}
-
-/* 0 - set zero to UDP csum on TX, 1 - recalculate UDP csum on TX */
-MV_STATUS mvNfpCtRuleUdpCsumSet(NFP_RULE_CT *ct2, int mode)
-{
-	NFP_RULE_CT *ct;
-
-	if (!ct2 || (mode < 0) || (mode > 1) || (ct2->proto != MV_IP_PROTO_UDP))
-		return MV_BAD_PARAM;
-
-	ct = mvNfpCtLookup(ct2);
-	if (!ct)
-		ct = mvNfpCtRuleInvalidLookup(ct2);
-
-	if (!ct)
-		return MV_NOT_FOUND;
-
-	if (mode)
-		ct->flags |= NFP_F_CT_UDP_CSUM;
-	else
-		ct->flags &= ~NFP_F_CT_UDP_CSUM;
-
-	return MV_OK;
-}
-
-/* mode = 1:HWF,  0:NFP  */
-MV_STATUS mvNfpCtRuleHwfSet(MV_NFP_CT_KEY *key, int mode)
-{
-	NFP_RULE_CT *rule;
-	MV_U32 nflags = 0, ports;
-
-	if (!key || (mode < 0) || (mode > 1))
-		return MV_BAD_PARAM;
-
-	ports = (MV_16BIT_BE(key->dport) << 16) | MV_16BIT_BE(key->sport);
-	rule = mvNfpCtLookupByTuple(key->family, key->src_l3, key->dst_l3, ports, key->proto);
-	if (!rule)
-		return MV_NOT_FOUND;
-
-	/* sanity check */
-	if (!rule->fib || (rule->flags & NFP_F_CT_FIB_INV))
-		return MV_NOT_FOUND;
-
-	if (mode)
-		nflags = (rule->flags | NFP_F_CT_HWF);
-	else
-		nflags = (rule->flags & ~NFP_F_CT_HWF);
-
-	if (rule->flags != nflags) {
-		/* Mode is changed - update hwf ref count */
-		if (mode) /* go to HWF mode */
-			rule->fib->ct_hwf_ref_count++;
-		else {
-			/* exit from HWF mode */
-			rule->fib->ct_hwf_ref_count--;
-			rule->hit_cntr = 0;
-		}
-	}
-	rule->flags = nflags;
-	return MV_OK;
-}
-
-MV_STATUS mvNfpCtRuleHitCntrGet(MV_NFP_CT_KEY *key, MV_U32 *hit_cntr)
-{
-	NFP_RULE_CT *rule;
-	MV_U32 ports;
-
-	if (!key || !hit_cntr)
-		return MV_BAD_PARAM;
-		ports = (MV_16BIT_BE(key->dport) << 16) | MV_16BIT_BE(key->sport);
-	rule = mvNfpCtLookupByTuple(key->family, key->src_l3, key->dst_l3, ports, key->proto);
-	if (!rule)
-		return MV_NOT_FOUND;
-	*hit_cntr = rule->hit_cntr;
-	return MV_OK;
-}
-
-MV_STATUS mvNfpCtRuleHitCntrSet(MV_NFP_CT_KEY *key, MV_U32 val)
-{
-	NFP_RULE_CT *rule;
-	MV_U32 ports;
-
-	if (!key || val < 0)
-		return MV_BAD_PARAM;
-	ports = (MV_16BIT_BE(key->dport) << 16) | MV_16BIT_BE(key->sport);
-	rule = mvNfpCtLookupByTuple(key->family, key->src_l3, key->dst_l3, ports, key->proto);
-	if (!rule)
-		return MV_NOT_FOUND;
-	rule->hit_cntr = val;
-	return MV_OK;
-}
-
-MV_STATUS mvNfpCtRuleInfoGet(MV_NFP_CT_KEY *key, MV_NFP_CT_INFO *ct_info)
-{
-	NFP_RULE_CT *rule;
-	NFP_IF_MAP *ifMap;
-	MV_U32 ports;
-
-	if (!key || !ct_info)
-		return MV_BAD_PARAM;
-	ports = (MV_16BIT_BE(key->dport) << 16) | MV_16BIT_BE(key->sport);
-	rule = mvNfpCtLookupByTuple(key->family, key->src_l3, key->dst_l3, ports, key->proto);
-	if (!rule)
-		return MV_NOT_FOUND;
-	ct_info->flags = rule->flags;
-	ct_info->new_sip = rule->new_sip;
-	ct_info->new_dip = rule->new_dip;
-	ct_info->new_sport = rule->new_sport;
-	ct_info->new_dport = rule->new_dport;
-	if (rule->fib) {
-		memcpy(ct_info->sa, (rule->fib)->sa, MV_MAC_ADDR_SIZE);
-		memcpy(ct_info->da, (rule->fib)->da, MV_MAC_ADDR_SIZE);
-		ifMap = mvNfpIfMapGet((rule->fib)->oif);
-		ct_info->out_port = ifMap->port;
-	}
-#ifdef NFP_CLASSIFY
-	ct_info->mh = rule->mh;
-	ct_info->txp = rule->txp;
-	/* return only global txq/dscp/vprio mapping */
-	ct_info->txq = (rule->txq_map[NFP_DSCP_MAP_GLOBAL]).txq;
-	if (!(rule->txq_map[NFP_DSCP_MAP_GLOBAL]).valid)
-		ct_info->flags = ct_info->flags & ~NFP_F_CT_SET_TXQ;
-	ct_info->dscp = (rule->dscp_map[NFP_DSCP_MAP_GLOBAL]).new_dscp;
-	if (!(rule->dscp_map[NFP_DSCP_MAP_GLOBAL]).valid)
-		ct_info->flags = ct_info->flags & ~NFP_F_CT_SET_DSCP;
-	ct_info->vprio = (rule->vpri_map[NFP_VPRI_MAP_GLOBAL]).new_prio;
-	if (!(rule->vpri_map[NFP_VPRI_MAP_GLOBAL]).valid)
-		ct_info->flags = ct_info->flags & ~NFP_F_CT_SET_VLAN_PRIO;
-#endif /* NFP_CLASSIFY */
-	return MV_OK;
-}
-
-void    mvNfpCtDump(void)
-{
-	MV_U32 i;
-	NFP_RULE_CT *ct;
-	MV_LIST_ELEMENT	*curr;
-
-	mvOsPrintf("\n(ct hash)\n");
-	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
-		ct = ct_hash[i];
-
-		while (ct) {
-			mvOsPrintf(" [%2d] ", i);
-			mvNfpCtRulePrint(ct);
-
-			ct = ct->next;
-		}
-	}
-	if (!ct_inv_list) {
-		mvOsPrintf("(ct_inv_list) does not exist\n");
-		return;
-	}
-	mvOsPrintf("(ct_inv_list)\n");
-	curr = ct_inv_list->next;
-	while (curr) {
-		ct = (NFP_RULE_CT *)curr->data;
-		mvNfpCtRulePrint(ct);
-		curr = curr->next;
-	}
-}
--- a/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h
+++ /dev/null
@@ -1,223 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-/*******************************************************************************
-* mvNfpDefs.h - Header File for Marvell NFP Configuration definitions
-*
-* DESCRIPTION:
-*
-* DEPENDENCIES:
-*       None.
-*
-*******************************************************************************/
-
-#ifndef __mvNfpDefs_h__
-#define __mvNfpDefs_h__
-
-#include "mv802_3.h"
-#include "gbe/mvNetaRegs.h"
-#include "gbe/mvNeta.h"
-
-#ifdef CONFIG_MV_ETH_NFP_MODULE
-# define CONFIG_MV_ETH_NFP
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP
-
-#define ETH_NFP
-
-#ifdef CONFIG_MV_ETH_NFP_EXT
-# define NFP_EXT
-# define NFP_EXT_NUM 	CONFIG_MV_ETH_NFP_EXT_NUM
-#else
-# define NFP_EXT_NUM 	0
-#endif
-
-#define NFP_MAX_PORTS   (MV_ETH_MAX_PORTS + NFP_EXT_NUM)
-
-#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN) || defined(CONFIG_MV_ETH_NFP_VLAN_LEARN) || defined(CONFIG_MV_ETH_NFP_FDB_LEARN) || \
-		defined(CONFIG_MV_ETH_NFP_PPP_LEARN) || defined(CONFIG_MV_ETH_NFP_CT_LEARN)
-#define NFP_LEARN
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_FIB
-#define NFP_FIB
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_FIB_LEARN
-#define NFP_FIB_LEARN
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_VLAN
-#define NFP_VLAN
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_VLAN_LEARN
-#define NFP_VLAN_LEARN
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_PPP
-#define NFP_PPP
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_PPP_LEARN
-#define NFP_PPP_LEARN
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_CT
-#define NFP_CT
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_CT_LEARN
-#define NFP_CT_LEARN
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_NAT
-#define NFP_NAT
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_LIMIT
-#define NFP_LIMIT
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_CLASSIFY
-#define NFP_CLASSIFY
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_STATS
-#define NFP_STAT
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_BRIDGE
-#define NFP_BRIDGE
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_FDB_MODE
-#define NFP_FDB_MODE
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP_FDB_LEARN
-#define NFP_FDB_LEARN
-#endif
-
-#ifdef CONFIG_MV_ETH_SWITCH
-# define NFP_MAX_SWITCH_GROUPS  CONFIG_MV_ETH_SWITCH_NETDEV_NUM
-#else
-# define NFP_MAX_SWITCH_GROUPS  1
-#endif /* CONFIG_MV_ETH_SWITCH */
-
-typedef struct {
-	MV_U16 flags;
-
-	MV_U8  txp;
-	MV_U8  txq;
-
-	MV_U8 pkt_ecn;
-	MV_U8 pkt_dscp;
-	int   ct_dscp;
-
-	int pkt_vlan_prio;
-	int bridge_vlan_prio;
-	int ct_vlan_prio;
-
-	MV_U16 mh;
-
-	int iif_prio;
-	int iif_vlan_prio;
-	int iif_dscp_prio;
-
-	int prio_dscp;
-	int prio_vprio;
-	MV_U8 prio_txp;
-	MV_U8 prio_txq;
-	MV_U16 prio_mh;
-
-} NFP_CLASSIFY_INFO;
-
-typedef struct {
-	void   *dev;
-	MV_U32 tx_cmd;
-	MV_U32 diffL4[2];
-	MV_U8  *pWrite;
-	MV_U16 flags;
-	MV_U16 mtu;
-	short  shift;
-	MV_U8  txp;
-	MV_U8  txq;
-	MV_IP_HEADER_INFO ipInfo;
-	void   *privateData;
-} MV_NFP_RESULT;
-
-#define MV_NFP_RES_TXP_VALID       0x0001
-#define MV_NFP_RES_TXQ_VALID       0x0002
-#define MV_NFP_RES_IP_INFO_VALID   0x0004
-#define MV_NFP_RES_NETDEV_EXT      0x0010
-#define MV_NFP_RES_L4_CSUM_NEEDED  0x0020
-
-MV_STATUS mvNfpIfMapPortGet(int ifIdx, int *port);
-MV_STATUS mvNfpRx(MV_U32 inPort, NETA_RX_DESC *pRxDesc, MV_ETH_PKT *pPkt, MV_NFP_RESULT* pRes);
-
-#endif /* CONFIG_MV_ETH_NFP */
-
-#endif /* __mvNfp_h__ */
--- a/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFdb.c
+++ /dev/null
@@ -1,309 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell Interfdbional Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-Interfdbional Ltd. and/or its affiliates ("Marvell") under the following
-alterfdbive licensing terms.  Once you have made an election to distribute the
-File under one of the following license alterfdbives, please (i) delete this
-introductory statement regarding license alterfdbives, (ii) delete the two
-license alterfdbives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-/*******************************************************************************
-* mvNfpFdb.c - Marvell Fast Network Processing
-*
-* DESCRIPTION:
-*
-*       Supported Features:
-*       - OS independent.
-*
-*******************************************************************************/
-
-#include "mvOs.h"
-#include "mvDebug.h"
-#include "mvList.h"
-#include "gbe/mvNeta.h"
-#include "mvNfpDefs.h"
-#include "mvNfp.h"
-
-NFP_RULE_FDB **nfp_fdb_hash = NULL;
-
-MV_STATUS _INIT mvNfpFdbInit(void)
-{
-	MV_U32 bytes = sizeof(NFP_RULE_FDB *) * NFP_BRIDGE_HASH_SIZE;
-
-	nfp_fdb_hash = (NFP_RULE_FDB **)mvOsMalloc(bytes);
-	if (nfp_fdb_hash == NULL) {
-		mvOsPrintf("NFP (FDB hash): not enough memory\n");
-		return MV_NO_RESOURCE;
-	}
-	mvOsMemset(nfp_fdb_hash, 0, bytes);
-
-	mvOsPrintf("NFP (FDB) init %d entries, %d bytes\n", NFP_BRIDGE_HASH_SIZE, bytes);
-
-	return MV_OK;
-}
-
-/* Clear FDB Rule Database */
-MV_STATUS mvNfpFdbClear(void)
-{
-	int	i;
-	NFP_RULE_FDB	*rule, *tmp;
-
-	if (nfp_fdb_hash == NULL)
-		return MV_NOT_INITIALIZED;
-
-	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
-
-		rule = nfp_fdb_hash[i];
-		while (rule) {
-			tmp = rule;
-			rule = rule->next;
-			mvOsFree(tmp);
-		}
-		nfp_fdb_hash[i] = NULL;
-	}
-	return MV_OK;
-}
-
-void mvNfpFdbDestroy(void)
-{
-	if (nfp_fdb_hash != NULL)
-		mvOsFree(nfp_fdb_hash);
-}
-
-MV_STATUS mvNfpFdbRuleAdd(NFP_RULE_FDB *rule2)
-{
-	MV_U32 hash;
-	NFP_RULE_FDB	*rule;
-	NFP_RULE_FIB	*fib;
-	NFP_IF_MAP      *outIfMap;
-	MV_LIST_ELEMENT	*curr, *tmp;
-
-	hash = mvNfpFdbRuleHash(rule2->bridgeIf, rule2->mac);
-
-	rule = nfp_fdb_hash[hash];
-	while (rule) {
-		if (mvNfpFdbRuleCmp(rule2->bridgeIf, rule2->mac, rule)) {
-			MV_U32 age = rule->age;
-
-			/* Update rule, but save age */
-			mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_FDB));
-			rule->age = age;
-			goto out;
-		}
-		rule = rule->next;
-	}
-
-	rule = (NFP_RULE_FDB *)mvOsMalloc(sizeof(NFP_RULE_FDB));
-	if (rule == NULL) {
-		mvOsPrintf("%s: NFP (FDB rule) - OOM\n", __func__);
-		return MV_FAIL;
-	}
-
-	mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_FDB));
-
-	rule->next = nfp_fdb_hash[hash];
-	nfp_fdb_hash[hash] = rule;
-
-	outIfMap = mvNfpIfMapGet(rule->if_index);
-
-	/* Update incomplete FIB entires */
-	curr = fib_inv_list->next;
-	while (curr) {
-		fib = (NFP_RULE_FIB *)curr->data;
-		tmp = curr->next;
-		if ((rule->bridgeIf == fib->oif) &&
-			(!memcmp(rule->mac, fib->da, MV_MAC_ADDR_SIZE))) {
-
-			/* Found incomplete FIB entry */
-			fib->oif = outIfMap->ifIdx;
-			fib->mh = outIfMap->txMh;
-			fib->flags &= ~NFP_F_FIB_BRIDGE_INV;
-
-			mvNfpFibRuleValid(fib, curr);
-		}
-		curr = tmp;
-	}
-out:
-	NFP_DBG("NFP (FDB) add %p\n", rule);
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpFdbRuleDel(NFP_RULE_FDB *rule2)
-{
-	MV_U32 hash;
-	NFP_RULE_FDB	*rule, *prev;
-	NFP_RULE_FIB	*fib, *fib_prev;
-	int i;
-
-	hash = mvNfpFdbRuleHash(rule2->bridgeIf, rule2->mac);
-
-	rule = nfp_fdb_hash[hash];
-	prev = NULL;
-
-	while (rule) {
-		if (mvNfpFdbRuleCmp(rule2->bridgeIf, rule2->mac, rule)) {
-			/* Found: delete rule */
-			if (prev)
-				prev->next = rule->next;
-			else
-				nfp_fdb_hash[hash] = rule->next;
-
-			NFP_DBG("NFP (FDB) del %p\n", rule);
-			rule2->if_index = rule->if_index;
-			mvOsFree(rule);
-			break;
-		}
-		prev = rule;
-		rule = rule->next;
-	}
-	if (rule == NULL)
-		return MV_NOT_FOUND;
-
-	/* Invalidate relevant FIB rules */
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-		fib_prev = NULL;
-		while (fib) {
-			if ((rule2->if_index == fib->oif) &&
-				(!memcmp(rule2->mac, fib->da, MV_MAC_ADDR_SIZE))) {
-				/* Invalidate FIB route. FIXME - update HWF rule */
-				fib->flags |= NFP_F_FIB_BRIDGE_INV;
-				fib->oif = rule2->bridgeIf;
-
-				/* Remove FIB rule from hash table */
-				if (fib_prev)
-					fib_prev->next = fib->next;
-				else
-					fib_hash[i] = fib->next;
-
-				/* Add FIB rule to incomplete list */
-				mvListAddHead(fib_inv_list, (MV_ULONG)fib);
-#ifdef NFP_CT
-				/* Invalidate relevant CT rules */
-				mvNfpCtRuleFibInvalidate(fib);
-#endif /* NFP_CT */
-			}
-			fib_prev = fib;
-			fib = fib->next;
-		}
-	}
-
-	return MV_OK;
-}
-
-MV_STATUS mvNfpFdbRuleAge(NFP_RULE_FDB *rule2)
-{
-	NFP_RULE_FDB *rule;
-
-	rule = mvNfpFdbLookup(rule2->bridgeIf, rule2->mac);
-	if (rule) {
-		rule2->age = rule->age;
-		rule->age = 0;
-		return MV_OK;
-	}
-	rule2->age = 0;
-	return MV_NOT_FOUND;
-}
-
-static void mvNfpFdbRulePrint(NFP_RULE_FDB *rule)
-{
-	if (rule->status == NFP_BRIDGE_INV)
-		mvOsPrintf("INVALID  : ");
-	else if (rule->status == NFP_BRIDGE_LOCAL)
-		mvOsPrintf("LOCAL    : ");
-	else
-		mvOsPrintf("NON_LOCAL: ");
-
-	mvOsPrintf(" bridgeIf=%d, if_index=%u, MAC=" MV_MACQUAD_FMT " age=%u\n",
-		rule->bridgeIf, rule->if_index, MV_MACQUAD(rule->mac), rule->age);
-}
-
-void mvNfpFdbDump(void)
-{
-	int             i;
-	NFP_RULE_FDB *rule;
-
-	mvOsPrintf("\n(fdb)\n");
-	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
-		rule = nfp_fdb_hash[i];
-
-		while (rule) {
-			mvOsPrintf(" [%5d] ", i);
-			mvNfpFdbRulePrint(rule);
-			rule = rule->next;
-		}
-	}
-}
-
-void mvNfpFdbFlushBridge(int ifindex)
-{
-	int i;
-
-	NFP_RULE_FDB *rule;
-
-	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
-		rule = nfp_fdb_hash[i];
-
-		while (rule) {
-			if ((rule->if_index == ifindex) || (ifindex == -1))
-				mvNfpFdbRuleDel(rule);
-			rule = rule->next;
-		}
-	}
-}
--- a/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFib.c
+++ /dev/null
@@ -1,718 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell Interfdbional Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-Interfdbional Ltd. and/or its affiliates ("Marvell") under the following
-alterfdbive licensing terms.  Once you have made an election to distribute the
-File under one of the following license alterfdbives, please (i) delete this
-introductory statement regarding license alterfdbives, (ii) delete the two
-license alterfdbives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-/*******************************************************************************
-* mvNfpFib.c - Marvell Fast Network Processing
-*
-* DESCRIPTION:
-*
-*       Supported Features:
-*       - OS independent.
-*
-*******************************************************************************/
-
-#include "mvOs.h"
-#include "mvDebug.h"
-#include "mvList.h"
-#include "gbe/mvNeta.h"
-#include "mvNfpDefs.h"
-#include "mvNfp.h"
-
-MV_LIST_ELEMENT *fib_inv_list = NULL;
-NFP_RULE_FIB **fib_hash = NULL;
-NFP_RULE_ARP **nfp_arp_hash = NULL;
-
-MV_STATUS _INIT mvNfpFibInit(void)
-{
-	MV_U32 bytes = sizeof(NFP_RULE_FIB *) * NFP_FIB_HASH_SIZE;
-
-	fib_hash = (NFP_RULE_FIB **)mvOsMalloc(bytes);
-	if (fib_hash == NULL) {
-		mvOsPrintf("NFP (fib): not enough memory\n");
-		return MV_NO_RESOURCE;
-	}
-	mvOsMemset(fib_hash, 0, bytes);
-
-	fib_inv_list = mvListCreate();
-	if (fib_inv_list == NULL) {
-		mvOsPrintf("NFP (fib): not enough memory\n");
-		mvOsFree(fib_hash);
-		return MV_NO_RESOURCE;
-	}
-
-	mvOsPrintf("NFP (fib) init %d entries, %d bytes\n", NFP_FIB_HASH_SIZE, bytes);
-
-	return MV_OK;
-}
-
-/* Move FIB rule from fib_inv_list to fib_hash */
-MV_STATUS mvNfpFibRuleValid(NFP_RULE_FIB *fib, MV_LIST_ELEMENT *curr)
-{
-	MV_U32	hash;
-
-	if (!(fib->flags & (NFP_F_FIB_ARP_INV | NFP_F_FIB_BRIDGE_INV))) {
-		/* FIB rule became ready */
-
-		/* Delete FIB rule from incomplete list */
-		mvListDel(curr);
-
-		/* Add fib to hash table */
-		hash = mvNfpFibRuleHash(fib->family, fib->srcL3, fib->dstL3);
-		fib->next = fib_hash[hash];
-		fib_hash[hash] = fib;
-
-#ifdef NFP_CT
-		/* Update incomplete CT entires */
-		mvNfpCtRuleFibUpdate(fib);
-#endif /* NFP_CT */
-
-		return MV_OK;
-	}
-	return MV_BAD_PARAM;
-}
-
-static void mvNfpFibRulePrint(NFP_RULE_FIB *fib)
-{
-	if (fib->family == MV_INET)
-		mvOsPrintf("IPv4: " MV_IPQUAD_FMT "->" MV_IPQUAD_FMT"\n",
-			   MV_IPQUAD(fib->srcL3), MV_IPQUAD(fib->dstL3));
-	else
-		mvOsPrintf("IPv6: " MV_IP6_FMT "->" MV_IP6_FMT"\n",
-					MV_IP6_ARG(fib->srcL3), MV_IP6_ARG(fib->dstL3));
-
-	mvOsPrintf("     mh=%2.2x:%2.2x, da=" MV_MACQUAD_FMT ", sa=" MV_MACQUAD_FMT,
-				((MV_U8 *) &fib->mh)[0], ((MV_U8 *) &fib->mh)[1], MV_MACQUAD(fib->da), MV_MACQUAD(fib->sa));
-#ifdef NFP_CT
-	mvOsPrintf("\n     fib=%p, oif=%d, ref=%d, age=%d, ct_ref_count=%d, ct_hwf_ref_count=%d\n",
-				fib, fib->oif, fib->ref, fib->age, fib->ct_ref_count, fib->ct_hwf_ref_count);
-#else
-	mvOsPrintf("\n     fib=%p, oif=%d, ref=%d, age=%d\n",
-				fib, fib->oif, fib->ref, fib->age);
-#endif /* NFP_CT */
-
-	if (fib->flags & NFP_F_FIB_ALL_FLAGS)
-		mvOsPrintf("     Flags: ");
-	if (fib->flags & NFP_F_FIB_HWF)
-		mvOsPrintf("NFP_F_FIB_HWF ");
-	if (fib->flags & NFP_F_FIB_BRIDGE_INV)
-		mvOsPrintf("NFP_F_FIB_BRIDGE_INV ");
-	if (fib->flags & NFP_F_FIB_ARP_INV)
-		mvOsPrintf("NFP_F_FIB_ARP_INV ");
-
-	mvOsPrintf("\n");
-}
-
-MV_STATUS mvNfpArpRuleAdd(NFP_RULE_ARP *arp2)
-{
-	MV_U32          hash;
-	NFP_RULE_FIB    *fib;
-	NFP_RULE_ARP    *arp;
-	MV_LIST_ELEMENT	*curr, *tmp;
-
-	if (!nfp_arp_hash || !fib_hash || !fib_inv_list)
-		return MV_FAIL;
-
-	/* Check if such rule already exist - update it */
-	arp = mvNfpArpLookup(arp2->family, arp2->nextHopL3);
-	if (arp) {
-		/* Rule exists - update it and the relevant FIB entries */
-		mvOsMemcpy(arp, arp2, sizeof(NFP_RULE_ARP));
-		mvNfpArpRuleUpdateFibEntries(arp);
-	} else { /* Add new rule to ARP hash table */
-		arp = (NFP_RULE_ARP *)mvOsMalloc(sizeof(NFP_RULE_ARP));
-		if (!arp) {
-			mvOsPrintf("%s: NFP (arp) OOM\n", __func__);
-			return MV_FAIL;
-		}
-		mvOsMemcpy(arp, arp2, sizeof(NFP_RULE_ARP));
-		hash = mvNfpArpRuleHash(arp2->family, arp2->nextHopL3);
-		arp->next = nfp_arp_hash[hash];
-		nfp_arp_hash[hash] = arp;
-	}
-
-	/* Update incomplete FIB entires */
-	curr = fib_inv_list->next;
-	while (curr) {
-		fib = (NFP_RULE_FIB *)curr->data;
-		tmp = curr->next;
-		if ((arp2->family == fib->family) &&
-			(l3_addr_eq(arp2->family, arp2->nextHopL3, fib->defGtwL3))) {
-
-			/* Found incomplete FIB entry - copy DA from arp2 */
-			mvOsMemcpy((MV_U8 *)&fib->da, (MV_U8 *)&arp2->da, MV_MAC_ADDR_SIZE);
-			fib->flags &= ~NFP_F_FIB_ARP_INV;
-
-#ifdef NFP_BRIDGE
-			if (fib->flags & NFP_F_FIB_BRIDGE_INV) {
-				NFP_IF_MAP      *outIfMap;
-#ifdef NFP_FDB_MODE
-				NFP_RULE_FDB *fdb;
-
-				/* Check FDB hash */
-				fdb = mvNfpFdbLookup(fib->oif, fib->da);
-				if (fdb) {
-					outIfMap = mvNfpIfMapGet(fdb->if_index);
-#else
-				NFP_RULE_BRIDGE *bridge;
-
-				/* Check BRIDGE hash */
-				bridge = mvNfpBridgeLookup(fib->da, fib->sa, fib->oif);
-				if (bridge) {
-					outIfMap = mvNfpIfMapGet(bridge->oif);
-#endif /* NFP_FDB_MODE */
-					fib->oif = outIfMap->ifIdx;
-					fib->mh = outIfMap->txMh;
-					fib->flags &= ~NFP_F_FIB_BRIDGE_INV;
-				} else {
-					NFP_WARN("%s: bridgeLookup failed, oif=%d, da="MV_MACQUAD_FMT"\n",
-						__func__, fib->oif, MV_MACQUAD(fib->da));
-				}
-			}
-#endif /* NFP_BRIDGE */
-
-			mvNfpFibRuleValid(fib, curr);
-		}
-		curr = tmp;
-	}
-	return MV_OK;
-}
-
-/* Update all routes with rule2->defGtwL3 */
-MV_STATUS mvNfpArpRuleUpdateFibEntries(NFP_RULE_ARP *arp)
-{
-	int		i;
-	NFP_RULE_FIB	*fib;
-
-	if (!fib_hash)
-		return MV_FAIL;
-
-	/* Update relevant FIB rules */
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-		while (fib) {
-			if ((arp->family == fib->family) &&
-				(l3_addr_eq(arp->family, arp->nextHopL3, fib->defGtwL3)))
-				mvOsMemcpy((MV_U8 *)&fib->da, (MV_U8 *)&arp->da, MV_MAC_ADDR_SIZE);
-			fib = fib->next;
-		}
-	}
-	return MV_OK;
-}
-
-/* Delete ARP Rule and invalidate all routes with rule2->defGtwL3 */
-MV_STATUS mvNfpArpRuleDel(NFP_RULE_ARP *arp2)
-{
-	int				i;
-	MV_U32          hash;
-	NFP_RULE_ARP	*arp, *arp_prev;
-	NFP_RULE_FIB	*fib, *fib_prev;
-
-	if (!nfp_arp_hash || !fib_hash)
-		return MV_FAIL;
-
-	/* Find rule in ARP hash table and delete it */
-	hash = mvNfpArpRuleHash(arp2->family, arp2->nextHopL3);
-
-	arp = nfp_arp_hash[hash];
-	arp_prev = NULL;
-
-	while (arp) {
-		if (mvNfpArpRuleCmp(arp2->family, arp2->nextHopL3, arp)) {
-			/* Found: delete ARP rule */
-			if (arp_prev)
-				arp_prev->next = arp->next;
-			else
-				nfp_arp_hash[hash] = arp->next;
-
-			NFP_DBG("NFP (arp) del %p\n", arp);
-			mvOsFree(arp);
-			break;
-		}
-		arp_prev = arp;
-		arp = arp->next;
-	}
-	if (arp == NULL)
-		return MV_NOT_FOUND;
-
-	/* Invalidate relevant FIB rules */
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-		fib_prev = NULL;
-		while (fib) {
-			if ((arp2->family == fib->family) &&
-				(l3_addr_eq(arp2->family, arp2->nextHopL3, fib->defGtwL3))) {
-
-				/* Invalidate FIB route. FIXME - update HWF rule */
-				fib->flags |= NFP_F_FIB_ARP_INV;
-
-				/* Remove FIB rule from hash table */
-				if (fib_prev)
-					fib_prev->next = fib->next;
-				else
-					fib_hash[i] = fib->next;
-
-				/* Add FIB rule to incomplete list */
-				mvListAddHead(fib_inv_list, (MV_ULONG)fib);
-#ifdef NFP_CT
-				/* Invalidate relevant CT rules */
-				mvNfpCtRuleFibInvalidate(fib);
-#endif /* NFP_CT */
-			}
-			fib_prev = fib;
-			fib = fib->next;
-		}
-	}
-	return MV_OK;
-}
-
-/* If exist routing entires with the rule2->defGtwL3 - prevent aging */
-MV_STATUS mvNfpArpRuleAge(NFP_RULE_ARP *arp2)
-{
-	int		i;
-	NFP_RULE_FIB	*fib;
-
-	arp2->age = 0;
-	if (!nfp_arp_hash || !fib_hash)
-		return MV_FAIL;
-
-	/* FIXME: Find rule in ARP hash table */
-
-	/* prevent ARP aging if there are at least one valid FIB rule use it */
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-		while (fib) {
-			if ((arp2->family == fib->family) &&
-				(l3_addr_eq(arp2->family, arp2->nextHopL3, fib->defGtwL3))) {
-
-				/* Prevent neigbour aging */
-				arp2->age = 1;
-				return MV_OK;
-			}
-			fib = fib->next;
-		}
-	}
-	return MV_NOT_FOUND;
-}
-
-static NFP_RULE_FIB *mvNfpFibRuleInvalidLookup(int family, const MV_U8 *srcL3, const MV_U8 *dstL3)
-{
-	MV_LIST_ELEMENT	*curr;
-	NFP_RULE_FIB *currRule;
-
-	if (!fib_inv_list)
-		return NULL;
-
-	curr = fib_inv_list->next;
-	while (curr) {
-		currRule = (NFP_RULE_FIB *)curr->data;
-		if (mvNfpFibRuleCmp(family, srcL3, dstL3, currRule))
-			return currRule;
-
-		curr = curr->next;
-	}
-	return NULL;
-}
-
-/* prevent FIB aging if there are 5 tuple rules based on this FIB rule */
-MV_STATUS mvNfpFibRuleAge(NFP_RULE_FIB *fib2)
-{
-	NFP_RULE_FIB *fib;
-
-	fib = mvNfpFibRuleInvalidLookup(fib2->family, fib2->srcL3, fib2->dstL3);
-	if (fib) {
-#ifdef NFP_CT
-		fib2->age = (fib->ct_hwf_ref_count > 0) ? 1 : fib->age;
-		fib->age = (fib->ct_hwf_ref_count > 0) ? fib->age : 0;
-#else
-		fib2->age = fib->age;
-		fib->age = 0;
-#endif /* NFP_CT */
-		return MV_OK;
-	}
-
-	fib = mvNfpFibLookup(fib2->family, fib2->srcL3, fib2->dstL3);
-	if (fib) {
-#ifdef NFP_CT
-			fib2->age = (fib->ct_hwf_ref_count > 0) ? 1 : fib->age;
-			fib->age = (fib->ct_hwf_ref_count > 0) ? fib->age : 0;
-#else
-			fib2->age = fib->age;
-			fib->age = 0;
-#endif /* NFP_CT */
-		return MV_OK;
-	}
-
-	fib2->age = 0;
-	return MV_NOT_FOUND;
-}
-
-MV_STATUS mvNfpFibRuleAdd(NFP_RULE_FIB *fib2)
-{
-	MV_U32 hash, ref = 0;
-	NFP_RULE_FIB *fib;
-	MV_LIST_ELEMENT	*element;
-	NFP_IF_MAP      *outIfMap;
-
-	/* sanity checks */
-	if (!fib_hash || !fib_inv_list)
-		return MV_FAIL;
-
-	/* If this rule currently exists in the Invalid Rules DB, delete it */
-	fib = mvNfpFibRuleInvalidLookup(fib2->family, fib2->srcL3, fib2->dstL3);
-	if (fib) {
-		element = mvListFind(fib_inv_list, (MV_ULONG)fib);
-		mvListDel(element);
-	}
-	/* If this rule currently exists as a valid rule, we want to update it */
-	/* so we save the reference count, but delete and re-add it */
-	fib = mvNfpFibLookup(fib2->family, fib2->srcL3, fib2->dstL3);
-	if (fib) {
-		ref = fib->ref;
-		mvNfpFibRuleDel(fib);
-	}
-
-	outIfMap = mvNfpIfMapGet(fib2->oif);
-	memcpy(fib2->sa, outIfMap->mac, MV_MAC_ADDR_SIZE);
-	fib2->mh = outIfMap->txMh;
-
-	if (fib2->flags & NFP_F_FIB_ARP_INV) {
-#ifdef NFP_PPP
-		if (outIfMap->flags & NFP_F_MAP_PPPOE) {
-			mvOsMemcpy(fib2->da, outIfMap->remoteMac, MV_MAC_ADDR_SIZE);
-			fib2->flags &= ~NFP_F_FIB_ARP_INV;
-		} else {
-#endif /* NFP_PPP */
-			NFP_RULE_ARP  *arp;
-			if (fib2->family == MV_INET) {
-				NFP_DBG("%s: ArpLookup, defGtwL3="MV_IPQUAD_FMT"\n",
-							__func__, MV_IPQUAD(fib2->defGtwL3));
-			} else {
-				NFP_DBG("%s: ArpLookup, defGtwL3="MV_IP6_FMT"\n",
-							__func__, MV_IP6_ARG(fib2->defGtwL3));
-			}
-
-			/* lookup for ARP entry */
-			arp = mvNfpArpLookup(fib2->family, fib2->defGtwL3);
-			if (arp) {
-				mvOsMemcpy(fib2->da, arp->da, MV_MAC_ADDR_SIZE);
-				fib2->flags &= ~NFP_F_FIB_ARP_INV;
-			} else {
-				if (fib2->family == MV_INET) {
-					NFP_WARN("%s: ArpLookup failed, defGtwL3="MV_IPQUAD_FMT"\n",
-								__func__, MV_IPQUAD(fib2->defGtwL3));
-				} else {
-					NFP_WARN("%s: ArpLookup failed, defGtwL3="MV_IP6_FMT"\n",
-								__func__, MV_IP6_ARG(fib2->defGtwL3));
-				}
-			}
-#ifdef NFP_PPP
-		}
-#endif /* NFP_PPP */
-	}
-#ifdef NFP_BRIDGE
-	/* ARP (da) is known, bridge (oif) is unknown */
-	if ((fib2->flags & (NFP_F_FIB_BRIDGE_INV | NFP_F_FIB_ARP_INV)) == NFP_F_FIB_BRIDGE_INV) {
-
-#ifdef NFP_FDB_MODE
-		NFP_RULE_FDB  *fdb;
-
-		/* lookup for FDB entry */
-		fdb = mvNfpFdbLookup(fib2->oif, fib2->da);
-		if (fdb) {
-			outIfMap = mvNfpIfMapGet(fdb->if_index);
-#else
-		NFP_RULE_BRIDGE  *bridge;
-
-		/* lookup for Bridging entry */
-		bridge = mvNfpBridgeLookup(fib2->da, fib2->sa, fib2->oif);
-		if (bridge) {
-			outIfMap = mvNfpIfMapGet(bridge->oif);
-#endif /* NFP_FDB_MODE */
-			fib2->oif = outIfMap->ifIdx;
-			fib2->mh = outIfMap->txMh;
-			fib2->flags &= ~NFP_F_FIB_BRIDGE_INV;
-		} else {
-			NFP_WARN("%s: mvNfpFdbLookup failed, oif=%d, mac="MV_MACQUAD_FMT"\n",
-					__func__, fib2->oif, MV_MACQUAD(fib2->da));
-		}
-	}
-#endif /* NFP_BRIDGE */
-
-	if (fib2->flags & (NFP_F_FIB_BRIDGE_INV | NFP_F_FIB_ARP_INV)) {
-		/* Put FIB entry to incomplete list */
-		fib = (NFP_RULE_FIB *)mvOsMalloc(sizeof(NFP_RULE_FIB));
-		if (!fib) {
-			mvOsPrintf("%s: NFP (fib) OOM\n", __func__);
-			return MV_FAIL;
-		}
-		mvOsMemcpy(fib, fib2, sizeof(NFP_RULE_FIB));
-		mvListAddHead(fib_inv_list, (MV_ULONG)fib);
-		return MV_OK;
-	}
-
-	/* FIB Entry is valid - add it to hash */
-	hash = mvNfpFibRuleHash(fib2->family, fib2->srcL3, fib2->dstL3);
-
-	fib = (NFP_RULE_FIB *)mvOsMalloc(sizeof(NFP_RULE_FIB));
-	if (!fib) {
-		mvOsPrintf("%s: NFP (fib) OOM\n", __func__);
-		return MV_FAIL;
-	}
-	mvOsMemcpy(fib, fib2, sizeof(NFP_RULE_FIB));
-	fib->ref = ref;
-
-	fib->next = fib_hash[hash];
-	fib_hash[hash] = fib;
-
-#ifdef NFP_CT
-	/* Update incomplete CT entires */
-	mvNfpCtRuleFibUpdate(fib);
-#endif /* NFP_CT */
-
-	NFP_DBG("NFP (fib) add %p\n", fib);
-	return MV_OK;
-}
-
-MV_STATUS mvNfpFibRuleDel(NFP_RULE_FIB *fib2)
-{
-	MV_U32 hash;
-	NFP_RULE_FIB *fib, *prev;
-	MV_LIST_ELEMENT	*element;
-
-	/* If this rule currently exists in the Invalid Rules DB, delete it */
-	fib = mvNfpFibRuleInvalidLookup(fib2->family, fib2->srcL3, fib2->dstL3);
-	if (fib) {
-		element = mvListFind(fib_inv_list, (MV_ULONG)fib);
-		mvListDel(element);
-		mvOsFree(fib);
-		return MV_OK;
-	}
-
-	hash = mvNfpFibRuleHash(fib2->family, fib2->srcL3, fib2->dstL3);
-	fib = fib_hash[hash];
-
-	prev = NULL;
-	while (fib) {
-		if (mvNfpFibRuleCmp(fib2->family, fib2->srcL3, fib2->dstL3, fib)) {
-			if (prev)
-				prev->next = fib->next;
-			else
-				fib_hash[hash] = fib->next;
-
-			NFP_DBG("NFP (fib) del %p\n", fib);
-			mvOsFree(fib);
-#ifdef NFP_CT
-			/* Invalidate relevant CT rules */
-			mvNfpCtRuleFibInvalidate(fib2);
-#endif /* NFP_CT */
-			return MV_OK;
-		}
-		prev = fib;
-		fib = fib->next;
-	}
-	return MV_NOT_FOUND;
-}
-
-void mvNfpFibClean(void)
-{
-	int i;
-	NFP_RULE_FIB *fib, *next;
-	MV_LIST_ELEMENT	*curr, *tmp;
-
-	/* Clean FIB incomplete rules list */
-	if (fib_inv_list) {
-		curr = fib_inv_list->next;
-		while (curr) {
-			tmp = curr->next;
-			mvListDel(curr);
-			curr = tmp;
-		}
-	}
-
-	/* Clean FIB hash table */
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-		while (fib) {
-			next = fib->next;
-			mvOsFree(fib);
-			fib = next;
-		}
-		fib_hash[i] = NULL;
-	}
-}
-
-void mvNfpFibDestroy(void)
-{
-	if (fib_hash != NULL)
-		mvOsFree(fib_hash);
-
-	mvListDestroy(fib_inv_list);
-}
-
-void mvNfpFibDump(void)
-{
-	MV_U32 i;
-	NFP_RULE_FIB *fib;
-	MV_LIST_ELEMENT	*curr;
-
-	mvOsPrintf("\n(fib_hash)\n");
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-
-		while (fib) {
-			mvOsPrintf(" [%5d] ", i);
-			mvNfpFibRulePrint(fib);
-			fib = fib->next;
-		}
-	}
-	if (!fib_inv_list) {
-		mvOsPrintf("(fib_inv_list) does not exist\n");
-		return;
-	}
-	mvOsPrintf("(fib_inv_list)\n");
-	curr = fib_inv_list->next;
-	while (curr) {
-		fib = (NFP_RULE_FIB *)curr->data;
-		mvNfpFibRulePrint(fib);
-		curr = curr->next;
-	}
-}
-
-
-static void mvNfpArpRulePrint(NFP_RULE_ARP *arp)
-{
-	if (arp->family == MV_INET)
-		mvOsPrintf("IPv4: nextHop=" MV_IPQUAD_FMT, MV_IPQUAD(arp->nextHopL3));
-	else
-		mvOsPrintf("IPv6: nextHop=" MV_IP6_FMT, MV_IP6_ARG(arp->nextHopL3));
-
-	mvOsPrintf(" da=" MV_MACQUAD_FMT " age=%u\n",
-				MV_MACQUAD(arp->da), (mvNfpArpRuleAge(arp) == MV_OK) ? 1 : 0);
-}
-
-MV_STATUS _INIT mvNfpArpInit(void)
-{
-	MV_U32 bytes = sizeof(NFP_RULE_ARP *) * NFP_ARP_HASH_SIZE;
-
-	nfp_arp_hash = (NFP_RULE_ARP **)mvOsMalloc(bytes);
-	if (nfp_arp_hash == NULL) {
-		mvOsPrintf("NFP (arp): not enough memory\n");
-		return MV_NO_RESOURCE;
-	}
-
-	mvOsMemset(nfp_arp_hash, 0, bytes);
-
-	mvOsPrintf("NFP (arp) init %d entries, %d bytes\n", NFP_ARP_HASH_SIZE, bytes);
-
-	return MV_OK;
-}
-
-void mvNfpArpDestroy(void)
-{
-	if (nfp_arp_hash != NULL)
-		mvOsFree(nfp_arp_hash);
-}
-
-void mvNfpArpDump(void)
-{
-	MV_U32 i;
-	NFP_RULE_ARP *arp;
-
-	mvOsPrintf("\n(arp)\n");
-	for (i = 0; i < NFP_ARP_HASH_SIZE; i++) {
-		arp = nfp_arp_hash[i];
-
-		while (arp) {
-			mvOsPrintf(" [%5d] ", i);
-			mvNfpArpRulePrint(arp);
-			arp = arp->next;
-		}
-	}
-}
-
-void mvNfpFlushFib(int ifindex)
-{
-	NFP_RULE_FIB *fib;
-	MV_LIST_ELEMENT	*curr;
-	int i;
-	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
-		fib = fib_hash[i];
-
-		while (fib) {
-			if (fib->oif == ifindex)
-				mvNfpFibRuleDel(fib);
-
-			fib = fib->next;
-		}
-	}
-	if (fib_inv_list) {
-		curr = fib_inv_list->next;
-		while (curr) {
-			fib = (NFP_RULE_FIB *)curr->data;
-			if (fib->oif == ifindex)
-				mvNfpFibRuleDel(fib);
-			curr = curr->next;
-		}
-	}
-}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncRxq.c
@@ -0,0 +1,412 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvOs.h"
+#include "mvCommon.h"
+#include "mv802_3.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+#include "gbe/mvNetaRegs.h"
+#include "gbe/mvEthRegs.h"
+
+#include "mvPnc.h"
+#include "mvTcam.h"
+
+#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
+int first_2tuple_rule = TE_FLOW_L3_END + 1;
+int last_5tuple_rule = TE_FLOW_L3 - 1;
+
+extern int pnc_port_mask_check(unsigned int mask, int eth_port);
+
+static INLINE struct tcam_entry *pnc_create_2t_entry(unsigned int sip, unsigned int dip)
+{
+	struct tcam_entry *te = tcam_sw_alloc(TCAM_LU_FLOW_IP4);
+
+	tcam_sw_set_byte(te, 12, (sip >> 0) & 0xFF);
+	tcam_sw_set_byte(te, 13, (sip >> 8) & 0xFF);
+	tcam_sw_set_byte(te, 14, (sip >> 16) & 0xFF);
+	tcam_sw_set_byte(te, 15, (sip >> 24) & 0xFF);
+
+	tcam_sw_set_byte(te, 16, (dip >> 0) & 0xFF);
+	tcam_sw_set_byte(te, 17, (dip >> 8) & 0xFF);
+	tcam_sw_set_byte(te, 18, (dip >> 16) & 0xFF);
+	tcam_sw_set_byte(te, 19, (dip >> 24) & 0xFF);
+
+	return te;
+}
+
+static INLINE int tcam_sw_cmp_2tuple(struct tcam_entry *te, unsigned int sip, unsigned int dip)
+{
+	return !((tcam_sw_cmp_bytes(te, 12, 4, (unsigned char *)&sip) == 0)
+			&& (tcam_sw_cmp_bytes(te, 16, 4, (unsigned char *)&dip) == 0));
+}
+
+static INLINE int tcam_sw_cmp_5tuple(struct tcam_entry *te, unsigned int sip, unsigned int dip,
+								unsigned int ports, unsigned int proto)
+{
+	if (tcam_sw_cmp_2tuple(te, sip, dip) != 0)
+		return 1;
+
+	return !((tcam_sw_cmp_bytes(te, 9, 1, (unsigned char *)&proto) == 0) &&
+			(tcam_sw_cmp_bytes(te, 20, 2, (unsigned char *)&ports) == 0));
+}
+#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
+
+static INLINE int pnc_mask_to_port(unsigned int mask)
+{
+#ifdef CONFIG_ARCH_FEROCEON_KW2
+	switch (mask) {
+	case 27:
+		return 0;
+	case 15:
+		return 1;
+	case 30:
+		return 2;
+	default:
+		return -1;
+	}
+#else
+	switch (mask) {
+	case 30:
+		return 0;
+	case 15:
+		return 1;
+	case 27:
+		return 2;
+	case 23:
+		return 3;
+	default:
+		return -1;
+	}
+#endif /* MV_ETH_PNC_NEW */
+}
+
+/*
+ * pnc_ip4_2tuple - Add 2-tuple priority rules
+ */
+int pnc_ip4_2tuple_rxq(unsigned int eth_port, unsigned int sip, unsigned int dip, int rxq)
+{
+#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
+	struct tcam_entry *te;
+	unsigned int pdata, pmask;
+	int tid, empty = -1, min_index_occupied = TE_FLOW_L3_END + 1;
+
+	if (rxq < -2 || rxq >= CONFIG_MV_ETH_RXQ || eth_port >= CONFIG_MV_ETH_PORTS_NUM)
+		return 1;
+
+	for (tid = TE_FLOW_L3_END; tid > last_5tuple_rule; tid--) {
+		te = pnc_tcam_entry_get(tid);
+		/* Remember first Empty entry */
+		if (te == NULL) {
+			if (empty == -1)
+				empty = tid;
+			continue;
+		}
+
+		/* Find existing entry for this rule */
+		if (tcam_sw_cmp_2tuple(te, sip, dip) == 0) {
+			tcam_sw_get_port(te, &pdata, &pmask);
+			if (rxq == -2) { /* delete rule */
+				if (!pnc_port_mask_check(pmask, eth_port)) {
+					printk(KERN_ERR "%s: rule is not associated with this port (%d)\n", __func__, eth_port);
+					tcam_sw_free(te);
+					return 1;
+				}
+				if (first_2tuple_rule == tid)
+					first_2tuple_rule = min_index_occupied;
+				pnc_te_del(tid);
+				tcam_sw_free(te);
+				return 0;
+			}
+
+			if (!pnc_port_mask_check(pmask, eth_port)) { /* rule is already associated with another port */
+				printk(KERN_ERR "%s: rule is already associated with port %d\n",
+									__func__, pnc_mask_to_port(pmask));
+				return 1;
+			}
+			if (rxq == -1) { /* set rule to drop mode */
+				sram_sw_set_rinfo(te, RI_DROP, RI_DROP);
+				sram_sw_set_lookup_done(te, 1);
+				tcam_hw_write(te, tid);
+			} else { /* update rxq */
+				sram_sw_set_rinfo(te, 0, RI_DROP);
+				sram_sw_set_rinfo(te, RI_L3_FLOW, RI_L3_FLOW);
+				sram_sw_set_rxq(te, rxq, 0);
+				tcam_hw_write(te, tid);
+			}
+
+			tcam_sw_free(te);
+			return 0;
+		}
+		min_index_occupied = tid;
+		tcam_sw_free(te);
+	}
+
+	/* Add rule to PNC */
+	if (rxq == -2) {
+		mvOsPrintf("%s: Entry not found - sip=0x%x, dip=0x%x, rxq=%d\n", __func__, sip, dip, rxq);
+		return 1;
+	}
+	/* Not found existing entry and no free TCAM entry - Failed */
+	if ((empty == -1) || (empty <= last_5tuple_rule)) {
+		mvOsPrintf("%s: No free place - sip=0x%x, dip=0x%x, rxq=%d\n", __func__, sip, dip, rxq);
+		return 1;
+	}
+
+	/* update upper border of 2 tuple rules */
+	if (first_2tuple_rule > empty)
+		first_2tuple_rule = empty;
+
+	te = pnc_create_2t_entry(sip, dip);
+	pmask = pnc_port_mask(eth_port);
+	tcam_sw_set_port(te, 0, pmask);
+	sram_sw_set_lookup_done(te, 1);
+	tcam_sw_text(te, "ipv4_2t");
+
+	if (rxq == -1) {
+		sram_sw_set_rinfo(te, RI_DROP, RI_DROP);
+		sram_sw_set_lookup_done(te, 1);
+	} else {
+		sram_sw_set_rinfo(te, 0, RI_DROP);
+		sram_sw_set_rinfo(te, RI_L3_FLOW, RI_L3_FLOW);
+		sram_sw_set_rxq(te, rxq, 0);
+	}
+
+	tcam_hw_write(te, empty);
+	tcam_sw_free(te);
+
+	return 0;
+#else
+	return -1;
+#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
+}
+
+/*
+ * pnc_ip4_5tuple - Add 5-tuple priority rules
+ */
+int pnc_ip4_5tuple_rxq(unsigned int eth_port, unsigned int sip, unsigned int dip, unsigned int ports,
+						unsigned int proto, int rxq)
+{
+#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
+	struct tcam_entry *te;
+	unsigned int pdata, pmask;
+	int tid, empty = -1, max_index_occupied = TE_FLOW_L3 - 1;
+
+	if (rxq < -2 || rxq >= CONFIG_MV_ETH_RXQ || eth_port >= CONFIG_MV_ETH_PORTS_NUM)
+		return 1;
+
+	for (tid = TE_FLOW_L3; tid < first_2tuple_rule; tid++) {
+		te = pnc_tcam_entry_get(tid);
+		/* Remember first Empty entry */
+		if (te == NULL) {
+			if (empty == -1)
+				empty = tid;
+			continue;
+		}
+		/* Find existing entry for this rule */
+		if (tcam_sw_cmp_5tuple(te, sip, dip, ports, proto) == 0) {
+			tcam_sw_get_port(te, &pdata, &pmask);
+			if (rxq == -2) { /* delete rule */
+				if (!pnc_port_mask_check(pmask, eth_port)) {
+					printk(KERN_ERR "%s: rule is not associated with this port (%d)\n", __func__, eth_port);
+					tcam_sw_free(te);
+					return 1;
+				}
+				if (last_5tuple_rule == tid)
+					last_5tuple_rule = max_index_occupied;
+				pnc_te_del(tid);
+				tcam_sw_free(te);
+				return 0;
+			}
+
+			if (!pnc_port_mask_check(pmask, eth_port)) { /* rule is already associated with another port */
+				printk(KERN_ERR "%s: rule is already associated with port %d\n",
+									__func__, pnc_mask_to_port(pmask));
+				return 1;
+			}
+			if (rxq == -1) { /* set rule to drop mode */
+				sram_sw_set_rinfo(te, RI_DROP, RI_DROP);
+				sram_sw_set_lookup_done(te, 1);
+				tcam_hw_write(te, tid);
+			} else { /* update rxq */
+				sram_sw_set_rinfo(te, 0, RI_DROP);
+				sram_sw_set_rinfo(te, RI_L3_FLOW, RI_L3_FLOW);
+				sram_sw_set_rxq(te, rxq, 0);
+				tcam_hw_write(te, tid);
+			}
+
+			tcam_sw_free(te);
+			return 0;
+		}
+		max_index_occupied = tid;
+		tcam_sw_free(te);
+	}
+
+	/* Add rule to PNC */
+	if (rxq == -2) {
+		mvOsPrintf("%s: Entry not found - sip=0x%x, dip=0x%x, ports=0x%x, proto=%d, rxq=%d\n",
+				__func__, sip, dip, ports, proto, rxq);
+		return 1;
+	}
+	/* Not found existing entry and no free TCAM entry - Failed */
+	if ((empty == -1) || (empty >= first_2tuple_rule)) {
+		mvOsPrintf("%s: No free place - sip=0x%x, dip=0x%x, ports=0x%x, proto=%d, rxq=%d\n",
+				__func__, sip, dip, ports, proto, rxq);
+		return 1;
+	}
+
+	/* update lower border of 5 tuple rules */
+	if (last_5tuple_rule < empty)
+		last_5tuple_rule = empty;
+
+	te = pnc_create_2t_entry(sip, dip);
+
+	tcam_sw_set_byte(te, 9, proto);
+	tcam_sw_set_byte(te, 20, (ports >> 0) & 0xFF);
+	tcam_sw_set_byte(te, 21, (ports >> 8) & 0xFF);
+	tcam_sw_set_byte(te, 22, (ports >> 16) & 0xFF);
+	tcam_sw_set_byte(te, 23, (ports >> 24) & 0xFF);
+	pmask = pnc_port_mask(eth_port);
+	tcam_sw_set_port(te, 0, pmask);
+	sram_sw_set_lookup_done(te, 1);
+	tcam_sw_text(te, "ipv4_5t");
+
+	if (rxq == -1) {
+		sram_sw_set_rinfo(te, RI_DROP, RI_DROP);
+		sram_sw_set_lookup_done(te, 1);
+	} else {
+		sram_sw_set_rinfo(te, 0, RI_DROP);
+		sram_sw_set_rinfo(te, RI_L3_FLOW, RI_L3_FLOW);
+		sram_sw_set_rxq(te, rxq, 0);
+	}
+
+	tcam_hw_write(te, empty);
+	tcam_sw_free(te);
+
+	return 0;
+#else
+	return -1;
+#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
+}
+
+
+/*
+ * pnc_rxq_map_dump - Dump all rules
+ */
+int pnc_rxq_map_dump()
+{
+#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
+	struct tcam_entry *te;
+	unsigned int tid, sport, dport, word, shift, rinfo, mask, data;
+	unsigned char sip[4], dip[4], sip_buf[16], dip_buf[16], *proto;
+
+	mvOsPrintf(" Tid   Sip               Dip               Sport   Dport   Proto   Rxq    Port   Name\n");
+	for (tid = TE_FLOW_L3; tid <= TE_FLOW_L3_END; tid++) {
+		te = pnc_tcam_entry_get(tid);
+		/* Remember first Empty entry */
+		if (te) {
+			memset(sip_buf, 0, 16);
+			memset(dip_buf, 0, 16);
+
+			sip[0] = *(te->data.u.byte + 12);
+			sip[1] = *(te->data.u.byte + 13);
+			sip[2] = *(te->data.u.byte + 14);
+			sip[3] = *(te->data.u.byte + 15);
+			dip[0] = *(te->data.u.byte + 16);
+			dip[1] = *(te->data.u.byte + 17);
+			dip[2] = *(te->data.u.byte + 18);
+			dip[3] = *(te->data.u.byte + 19);
+			mvOsSPrintf(sip_buf, "%d.%d.%d.%d", sip[0], sip[1], sip[2], sip[3]);
+			mvOsSPrintf(dip_buf, "%d.%d.%d.%d", dip[0], dip[1], dip[2], dip[3]);
+			mvOsPrintf(" %-3d   %-15s   %-15s   ", tid, sip_buf, dip_buf);
+
+			if (te->ctrl.text[5] == '5') {
+				sport = MV_BYTE_SWAP_16BIT(*((u16 *)(te->data.u.byte + 20)));
+				dport = MV_BYTE_SWAP_16BIT(*((u16 *)(te->data.u.byte + 22)));
+				proto = (*(te->data.u.byte + 9) == 6) ? "TCP" : "UDP";
+				mvOsPrintf("%-5d   %-5d   %-5s   ", sport, dport, proto);
+			} else
+				mvOsPrintf("-----   -----   -----   ");
+
+			word = RI_VALUE_OFFS / 32;
+			shift = RI_VALUE_OFFS % 32;
+			rinfo = (te->sram.word[word] >> shift) & ((1 << RI_BITS) - 1);
+			if (rinfo & 1)
+				mvOsPrintf("DROP   ");
+			else
+				mvOsPrintf("%-4d   ", sram_sw_get_rxq(te, NULL));
+
+			tcam_sw_get_port(te, &data, &mask);
+			mvOsPrintf("%-4d   ", pnc_mask_to_port(mask));
+			mvOsPrintf("%s\n", te->ctrl.text);
+
+			tcam_sw_free(te);
+		}
+	}
+
+	return 0;
+#else
+	return -1;
+#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
+}
