From 1700d9155ed8a74ceb7203a6dfb628021f7f62f8 Mon Sep 17 00:00:00 2001
From: Tawfik Bayouk <tawfik@marvell.com>
Date: Mon, 17 Sep 2012 16:48:43 +0300
Subject: [PATCH 400/609] Port in ArmadaXP U-boot 2011.12 release 5.1.0

Change-Id: I912777e70d387ac584bdf69b6d8ff2327a073660

Signed-off-by: Seif Mazareeb <seif@marvell.com>
---
 .../armada_xp_family/boardEnv/mvBoardEnvLib.c      |  183 +-
 .../armada_xp_family/boardEnv/mvBoardEnvLib.h      |    1 -
 .../armada_xp_family/boardEnv/mvBoardEnvSpec.c     |   14 +-
 .../armada_xp_family/boardEnv/mvBoardEnvSpec.h     |    4 +-
 .../armada_xp_family/ctrlEnv/mvCtrlEnvLib.c        |  194 +-
 .../armada_xp_family/ctrlEnv/mvCtrlEnvLib.h        |    4 +
 .../armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h       |   20 +-
 .../armada_xp_family/ctrlEnv/mvSemaphore.c         |    2 +-
 .../armada_xp_family/ctrlEnv/mvUnitMap.c           |    2 +-
 .../armada_xp_family/ctrlEnv/sys/mvCpuIf.c         |   35 +-
 .../armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h     |    8 +-
 arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c        |    2 +-
 .../plat-armada/mv_hal/ddr2_3/bak/mvDramCounters.h |  273 --
 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIf.c  | 2145 ---------------
 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIf.h  |  186 --
 .../mv_hal/ddr2_3/bak/mvDramIfBasicInit.S          | 1027 --------
 .../plat-armada/mv_hal/ddr2_3/bak/mvDramIfConfig.S |  528 ----
 .../plat-armada/mv_hal/ddr2_3/bak/mvDramIfConfig.h |  157 --
 .../plat-armada/mv_hal/ddr2_3/bak/mvDramIfRegs.h   |  428 ---
 .../mv_hal/ddr2_3/bak/mvDramIfStaticInit.h         |  192 --
 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvSysDdr.h  |  118 -
 arch/arm/plat-armada/mv_hal/ddr2_3/bak/spd/mvSpd.c | 1460 ----------
 arch/arm/plat-armada/mv_hal/ddr2_3/bak/spd/mvSpd.h |  199 --
 arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c      |   29 +
 arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.h      |    5 +-
 arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c     |   91 +-
 arch/arm/plat-armada/mv_hal/gpp/mvGpp.h            |    1 -
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c |    4 +-
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.c       | 2784 ++++++++++++++++++++
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.h       | 1143 ++++++++
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpBridge.c |  728 +++++
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpCt.c     | 1514 +++++++++++
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h   |  223 ++
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFdb.c    |  309 +++
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFib.c    |  718 +++++
 arch/arm/plat-armada/mv_hal/neta/pnc/mvPncRxq.c    |  412 ---
 arch/arm/plat-armada/mv_hal/nfc/mvNfc.c            |   20 +-
 arch/arm/plat-armada/mv_hal/pci-if/mvCompVer.txt   |    3 +
 arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.c       |  344 +++
 arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.h       |  134 +
 arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h   |  235 ++
 .../mv_hal/pci-if/pci_util/mvPciUtils.c            |  753 ++++++
 .../mv_hal/pci-if/pci_util/mvPciUtils.h            |  303 +++
 arch/arm/plat-armada/mv_hal/pex/mvPex.c            |  194 +-
 arch/arm/plat-armada/mv_hal/pex/mvPexAddrDec.c     |  227 +-
 arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h        |    1 -
 arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS1339.h |    1 -
 .../plat-armada/mv_hal/rtc/ext_rtc/mvDS1339Reg.h   |    1 -
 arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS133x.h |    1 -
 .../plat-armada/mv_hal/rtc/ext_rtc/mvDS133xReg.h   |    1 -
 arch/arm/plat-armada/mv_hal/rtc/mvCompVer.txt      |    1 -
 .../plat-armada/mv_hal/sata/CoreDriver/mvSata.c    |   45 -
 .../mv_hal/sata/CoreDriver/mvSataAddrDec.c         |   52 -
 .../mv_hal/sata/CoreDriver/mvStorageDev.c          |  171 --
 arch/arm/plat-armada/mv_hal/sflash/mvSFlash.c      |   22 +-
 arch/arm/plat-armada/mv_hal/spi/mvSpiCmnd.c        |    1 -
 arch/arm/plat-armada/mv_hal/spi/mvSpiSpec.h        |    1 -
 arch/arm/plat-armada/mv_hal/twsi/mvCompVer.txt     |    1 -
 arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c          |    4 +-
 arch/arm/plat-armada/mv_hal/twsi/mvTwsi.h          |    1 -
 arch/arm/plat-armada/mv_hal/uart/mvCompVer.txt     |    1 -
 arch/arm/plat-armada/mv_hal/uart/mvUart.c          |    9 +-
 arch/arm/plat-armada/mv_hal/usb/api/mvUsbCh9.h     |   18 +-
 arch/arm/plat-armada/mv_hal/usb/api/mvUsbDebug.h   |   20 +-
 arch/arm/plat-armada/mv_hal/usb/api/mvUsbDefs.h    |   18 +-
 arch/arm/plat-armada/mv_hal/usb/api/mvUsbDevApi.h  |   37 +-
 arch/arm/plat-armada/mv_hal/usb/api/mvUsbTypes.h   |   64 +-
 arch/arm/plat-armada/mv_hal/usb/common/mvUsbCore.h |  163 +-
 arch/arm/plat-armada/mv_hal/usb/common/mvUsbDesc.h |   44 +-
 .../plat-armada/mv_hal/usb/device/mvUsbDevCh9.c    |  116 +-
 .../plat-armada/mv_hal/usb/device/mvUsbDevMain.c   |  202 +-
 .../plat-armada/mv_hal/usb/device/mvUsbDevPrv.h    |   78 +-
 .../plat-armada/mv_hal/usb/device/mvUsbDevRecv.c   |   46 +-
 .../plat-armada/mv_hal/usb/device/mvUsbDevSend.c   |   84 +-
 .../plat-armada/mv_hal/usb/device/mvUsbDevUtl.c    |  258 +-
 .../plat-armada/mv_hal/usb/device/mvUsbHsDevCncl.c |  118 +-
 .../plat-armada/mv_hal/usb/device/mvUsbHsDevMain.c |  766 +++---
 .../plat-armada/mv_hal/usb/device/mvUsbHsDevUtl.c  |  136 +-
 arch/arm/plat-armada/mv_hal/usb/examples/disk.c    |  926 +++----
 arch/arm/plat-armada/mv_hal/usb/examples/disk.h    |   22 +-
 arch/arm/plat-armada/mv_hal/usb/examples/mouse.c   |  762 +++---
 arch/arm/plat-armada/mv_hal/usb/examples/mouse.h   |   18 +-
 arch/arm/plat-armada/mv_hal/usb/mvCompVer.txt      |    1 -
 arch/arm/plat-armada/mv_hal/usb/mvUsb.c            |  117 +-
 arch/arm/plat-armada/mv_hal/xor/mvXor.c            |    9 +-
 85 files changed, 11430 insertions(+), 10263 deletions(-)
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramCounters.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIf.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIf.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfBasicInit.S
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfConfig.S
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfConfig.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfRegs.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfStaticInit.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvSysDdr.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/spd/mvSpd.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/ddr2_3/bak/spd/mvSpd.h
 create mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.c
 create mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.h
 create mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpBridge.c
 create mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpCt.c
 create mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFdb.c
 create mode 100644 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFib.c
 delete mode 100755 arch/arm/plat-armada/mv_hal/neta/pnc/mvPncRxq.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pci-if/mvCompVer.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.h

--- a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c
@@ -281,7 +281,7 @@ MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethP
 			return MV_TRUE;
 		break;
 	case DB_78X60_PCAC_ID:
-	case RD_78460_GP_ID:
+	case DB_784MP_GP_ID:
 	case RD_78460_NAS_ID:
 	case RD_78460_CUSTOMER_ID:
 	case DB_78X60_PCAC_REV2_ID:
@@ -1412,8 +1412,8 @@ MV_VOID mvBoardIdSet(MV_VOID)
 		gBoardId = DB_78X60_AMC_ID;
 #elif defined(DB_78X60_PCAC_REV2)
 		gBoardId = DB_78X60_PCAC_REV2_ID;
-#elif defined(RD_78460_GP)
-		gBoardId = RD_78460_GP_ID;
+#elif defined(DB_784MP_GP)
+		gBoardId = DB_784MP_GP_ID;
 #elif defined(RD_78460_CUSTOMER)
 		gBoardId = RD_78460_CUSTOMER_ID;
 #else
@@ -1557,8 +1557,8 @@ MV_U8 mvBoardFabFreqGet(MV_VOID)
 	if ((MV_8)MV_ERROR == (MV_8)sar0)
 		return MV_ERROR;
 
-	if (RD_78460_GP_ID == boardId)
-		return (sar0 & 0x0f);
+	if (DB_784MP_GP_ID == boardId)
+		return (sar0 & 0x1f);
 
 	sar1 = mvBoardTwsiSatRGet(3, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar1)
@@ -1576,9 +1576,9 @@ MV_STATUS mvBoardFabFreqSet(MV_U8 freqVa
 	sar0 = mvBoardTwsiSatRGet(2, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar0)
 		return MV_ERROR;
-	if (RD_78460_GP_ID == boardId) {
-		sar0 &= ~(0x0F);
-		sar0 |= (freqVal & 0xF);
+	if (DB_784MP_GP_ID == boardId) {
+		sar0 &= ~(0x1F);
+		sar0 |= (freqVal & 0x1F);
 		if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar0)) {
 			DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
 			return MV_ERROR;
@@ -1608,68 +1608,6 @@ MV_STATUS mvBoardFabFreqSet(MV_U8 freqVa
 	return MV_OK;
 }
 /*******************************************************************************/
-MV_U8 mvBoardFabFreqModeGet(MV_VOID)
-{
-	MV_U8 sar0;
-
-	sar0 = mvBoardTwsiSatRGet(3, 0);
-	if ((MV_8)MV_ERROR == (MV_8)sar0)
-		return MV_ERROR;
-
-	return (sar0 & 0x1);
-}
-
-/*******************************************************************************/
-MV_STATUS mvBoardFabFreqModeSet(MV_U8 freqVal)
-{
-	MV_U8 sar0;
-
-	sar0 = mvBoardTwsiSatRGet(3, 0);
-	if ((MV_8)MV_ERROR == (MV_8)sar0)
-		return MV_ERROR;
-
-	sar0 &= ~(0x1);
-	sar0 |= (freqVal & 0x1);
-	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar0)) {
-		DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
-		return MV_ERROR;
-	}
-
-	DB(mvOsPrintf("Board: Write FreqOpt S@R succeeded\n"));
-	return MV_OK;
-}
-/*******************************************************************************/
-MV_U8 mvBoardCpuFreqModeGet(MV_VOID)
-{
-	MV_U8 sar0;
-
-	sar0 = mvBoardTwsiSatRGet(2, 0);
-	if ((MV_8)MV_ERROR == (MV_8)sar0)
-		return MV_ERROR;
-
-	return (sar0 & 0x1);
-}
-
-/*******************************************************************************/
-MV_STATUS mvBoardCpuFreqModeSet(MV_U8 freqVal)
-{
-	MV_U8 sar0;
-
-	sar0 = mvBoardTwsiSatRGet(2, 0);
-	if ((MV_8)MV_ERROR == (MV_8)sar0)
-		return MV_ERROR;
-
-	sar0 &= ~(0x1);
-	sar0 |= (freqVal & 0x1);
-	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar0)) {
-		DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
-		return MV_ERROR;
-	}
-
-	DB(mvOsPrintf("Board: Write FreqOpt S@R succeeded\n"));
-	return MV_OK;
-}
-/*******************************************************************************/
 MV_U8 mvBoardCpuFreqGet(MV_VOID)
 {
 	MV_U8 sar;
@@ -1679,7 +1617,7 @@ MV_U8 mvBoardCpuFreqGet(MV_VOID)
 	sar = mvBoardTwsiSatRGet(1, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
-	if (RD_78460_GP_ID == boardId) {
+	if (DB_784MP_GP_ID == boardId) {
 		return (sar & 0x0f);
 	}
 
@@ -1700,7 +1638,7 @@ MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVa
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
 
-	if (RD_78460_GP_ID == boardId) {
+	if (DB_784MP_GP_ID == boardId) {
 		sar &= ~0x0f;
 		sar |= (freqVal & 0x0f);
 		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
@@ -1749,7 +1687,7 @@ MV_U8 mvBoardBootDevGet(MV_VOID)
 	sar = mvBoardTwsiSatRGet(0, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
-	if (RD_78460_GP_ID == mvBoardIdGet())
+	if (DB_784MP_GP_ID == mvBoardIdGet())
 		sar = (sar >> 1);
 
 	return (sar & 0x7);
@@ -1764,7 +1702,7 @@ MV_STATUS mvBoardBootDevSet(MV_U8 val)
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
 
-	if (RD_78460_GP_ID == boardId) {
+	if (DB_784MP_GP_ID == boardId) {
 		sar &= ~(0x7 << 1);
 		sar |= ((val & 0x7) << 1);
 	}
@@ -1789,7 +1727,7 @@ MV_U8 mvBoardBootDevWidthGet(MV_VOID)
 	sar = mvBoardTwsiSatRGet(0, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
-	if (RD_78460_GP_ID == boardId)
+	if (DB_784MP_GP_ID == boardId)
 		return (sar & 1);
 
 	return (sar & 0x18) >> 3;
@@ -1803,7 +1741,7 @@ MV_STATUS mvBoardBootDevWidthSet(MV_U8 v
 	sar = mvBoardTwsiSatRGet(0, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
-	if (RD_78460_GP_ID == boardId) {
+	if (DB_784MP_GP_ID == boardId) {
 		sar &= ~(1);
 		sar |= (val & 0x1);
 	}
@@ -1828,6 +1766,8 @@ MV_U8 mvBoardCpu0EndianessGet(MV_VOID)
 #endif
 {
 	MV_U8 sar;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		return 3;
 
 	sar = mvBoardTwsiSatRGet(3, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
@@ -1846,6 +1786,8 @@ MV_STATUS mvBoardCpu0EndianessSet(MV_U8
 #endif
 {
 	MV_U8 sar;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		return MV_OK;
 
 	sar = mvBoardTwsiSatRGet(3, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
@@ -1870,11 +1812,11 @@ MV_U8 mvBoardL2SizeGet(MV_VOID)
 {
 	MV_U8 sar;
 	MV_U32 boardId = mvBoardIdGet();
-	if (RD_78460_GP_ID == boardId) {
+	if (DB_784MP_GP_ID == boardId) {
 		sar = mvBoardTwsiSatRGet(0, 0);
 		if ((MV_8)MV_ERROR == (MV_8)sar)
 			return MV_ERROR;
-		return ((sar & 0x10)>>4);
+		return (((sar & 0x10)>>3)+ 1);
 	}
 
 	sar = mvBoardTwsiSatRGet(1, 0);
@@ -1887,12 +1829,12 @@ MV_U8 mvBoardL2SizeGet(MV_VOID)
 MV_STATUS mvBoardL2SizeSet(MV_U8 val)
 {
 	MV_U8 sar;
-	if (RD_78460_GP_ID == mvBoardIdGet()) {
+	if (DB_784MP_GP_ID == mvBoardIdGet()) {
 		sar = mvBoardTwsiSatRGet(0, 0);
 		if ((MV_8)MV_ERROR == (MV_8)sar)
 			return MV_ERROR;
 		sar &= ~(0x1 << 4);
-		sar |= ((val & 0x1) << 4);
+		sar |= ((val & 0x2) << 3);
 		if (MV_OK != mvBoardTwsiSatRSet(0, 0, sar)) {
 			DB1(mvOsPrintf("Board: Write L2Size S@R fail\n"));
 			return MV_ERROR;
@@ -1919,6 +1861,13 @@ MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
 {
 	MV_U8 sar;
 
+	if (DB_784MP_GP_ID == mvBoardIdGet()) {
+		sar = mvBoardTwsiSatRGet(1, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		sar &=0x10;
+		return (1+(sar >>3));
+	}
 	sar = mvBoardTwsiSatRGet(3, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
@@ -1934,6 +1883,20 @@ MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
 MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val)
 {
 	MV_U8 sar;
+	if (DB_784MP_GP_ID == mvBoardIdGet()) {
+		sar = mvBoardTwsiSatRGet(1, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		sar &=~0x10;
+		val &= 2;
+		sar |= (val<<3);
+		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuCoreNum S@R fail\n"));
+			return MV_ERROR;
+		}
+		DB(mvOsPrintf("Board: Write CpuCoreNum S@R succeeded\n"));
+		return MV_OK;
+	}
 	sar = mvBoardTwsiSatRGet(3, 0);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
@@ -2009,7 +1972,6 @@ MV_U16 mvBoardPexCapabilityGet(MV_VOID)
 	switch (boardId) {
 	case DB_78X60_PCAC_ID:
 	case RD_78460_NAS_ID:
-	case RD_78460_GP_ID:
 	case RD_78460_CUSTOMER_ID:
 	case DB_78X60_AMC_ID:
 	case DB_78X60_PCAC_REV2_ID:
@@ -2017,6 +1979,7 @@ MV_U16 mvBoardPexCapabilityGet(MV_VOID)
 	case RD_78460_SERVER_REV2_ID:
 		sar = 0x1; /* Gen2 */
 		break;
+	case DB_784MP_GP_ID:
 	case DB_88F78XX0_BP_ID:
 	case FPGA_88F78XX0_ID:
 	case DB_88F78XX0_BP_REV2_ID:
@@ -2060,22 +2023,28 @@ MV_U16 mvBoardPexModeGet(MV_VOID)
 
 }
 /*******************************************************************************/
-MV_STATUS mvBoardDramEccSet(MV_U16 conf)
+MV_STATUS mvBoardDramEccSet(MV_U16 ecc)
 {
 	MV_U8 sar;
-	sar = mvBoardTwsiSatRGet(3, 1);
+	MV_U8 devNum;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		devNum = 2;
+	else
+		devNum = 3;
+
+	sar = mvBoardTwsiSatRGet(devNum, 1);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
 
 	sar &= ~(0x2);
-	sar |= ((conf & 0x1) << 1);
+	sar |= ((ecc & 0x1) << 1);
 
-	if (MV_OK != mvBoardTwsiSatRSet(3, 1, sar)) {
-		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+	if (MV_OK != mvBoardTwsiSatRSet(devNum, 1, sar)) {
+		DB(mvOsPrintf("Board: Write eccID S@R fail\n"));
 		return MV_ERROR;
 	}
 
-	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	DB(mvOsPrintf("Board: Write eccID S@R succeeded\n"));
 	return MV_OK;
 }
 
@@ -2083,28 +2052,39 @@ MV_STATUS mvBoardDramEccSet(MV_U16 conf)
 MV_U16 mvBoardDramEccGet(MV_VOID)
 {
 	MV_U8 sar;
+	MV_U8 devNum;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		devNum = 2;
+	else
+		devNum = 3;
 
-	sar = mvBoardTwsiSatRGet(3, 1);
+	sar = mvBoardTwsiSatRGet(devNum, 1);
 	return ((sar & 0x2) >> 1);
 }
 
 /*******************************************************************************/
-MV_STATUS mvBoardDramBusWidthSet(MV_U16 conf)
+MV_STATUS mvBoardDramBusWidthSet(MV_U16 dramBusWidth)
 {
 	MV_U8 sar;
-	sar = mvBoardTwsiSatRGet(3, 1);
+	MV_U8 devNum;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		devNum = 2;
+	else
+		devNum = 3;
+
+	sar = mvBoardTwsiSatRGet(devNum, 1);
 	if ((MV_8)MV_ERROR == (MV_8)sar)
 		return MV_ERROR;
 
 	sar &= ~(0x1);
-	sar |= (conf & 0x1);
+	sar |= (dramBusWidth & 0x1);
 
-	if (MV_OK != mvBoardTwsiSatRSet(3, 1, sar)) {
-		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+	if (MV_OK != mvBoardTwsiSatRSet(devNum, 1, sar)) {
+		DB(mvOsPrintf("Board: Write dramBusWidthID S@R fail\n"));
 		return MV_ERROR;
 	}
 
-	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	DB(mvOsPrintf("Board: Write dramBusWidthID S@R succeeded\n"));
 	return MV_OK;
 }
 
@@ -2113,7 +2093,13 @@ MV_U16 mvBoardDramBusWidthGet(MV_VOID)
 {
 	MV_U8 sar;
 
-	sar = mvBoardTwsiSatRGet(3, 1);
+	MV_U8 devNum;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		devNum = 2;
+	else
+		devNum = 3;
+
+	sar = mvBoardTwsiSatRGet(devNum, 1);
 	return (sar & 0x1);
 }
 
@@ -2121,6 +2107,8 @@ MV_U16 mvBoardDramBusWidthGet(MV_VOID)
 MV_U8 mvBoardAltFabFreqGet(MV_VOID)
 {
 	MV_U8 sar0;
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		return 5;
 
 	sar0 = mvBoardTwsiSatRGet(2, 1);
 	if ((MV_8)MV_ERROR == (MV_8)sar0)
@@ -2131,6 +2119,9 @@ MV_U8 mvBoardAltFabFreqGet(MV_VOID)
 /*******************************************************************************/
 MV_STATUS mvBoardAltFabFreqSet(MV_U8 freqVal)
 {
+	if (DB_784MP_GP_ID == mvBoardIdGet())
+		return MV_OK;
+
 	if (MV_OK != mvBoardTwsiSatRSet(2, 1, freqVal)) {
 		DB1(mvOsPrintf("Board: Write Alt FreqOpt S@R fail\n"));
 		return MV_ERROR;
@@ -2737,7 +2728,7 @@ MV_BOARD_PEX_INFO *mvBoardPexInfoGet(voi
 	case FPGA_88F78XX0_ID:
 	case DB_88F78XX0_BP_REV2_ID:
 	case RD_78460_NAS_ID:
-	case RD_78460_GP_ID:
+	case DB_784MP_GP_ID:
 	case RD_78460_CUSTOMER_ID:
 	case DB_78X60_AMC_ID:
 	case DB_78X60_PCAC_REV2_ID:
--- a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h
@@ -395,7 +395,6 @@ MV_U8 mvBoardCpuFreqGet(MV_VOID);
 MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
 MV_U8 mvBoardCpuFreqModeGet(MV_VOID);
 MV_STATUS mvBoardCpuFreqModeSet(MV_U8 freqVal);
-MV_U8 mvBoardFabFreqModeGet(MV_VOID);
 MV_STATUS mvBoardFabFreqModeSet(MV_U8 freqVal);
 MV_U8 mvBoardBootDevGet(MV_VOID);
 MV_STATUS mvBoardBootDevSet(MV_U8 val);
--- a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c
@@ -369,12 +369,12 @@ MV_BOARD_MPP_INFO db88f78XX0rev2InfoBoar
 
 MV_SERDES_CFG db88f78XX0rev2InfoBoardSerdesConfigValue[] = {
 	/* A0 */
-	{MV_TRUE, 0x33221111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED, PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Default: No Pex module, PEX0 x1, disabled*/
-	{MV_TRUE, 0x31211111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_MODE_X1, PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x1, PEX1 x1*/
-	{MV_TRUE, 0x33221111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_DISABLED,PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* no Pex module, PEX0 x4, PEX1 disabled*/
-	{MV_TRUE, 0x31211111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X1,PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x4, PEX1 x1*/
-	{MV_TRUE, 0x11111111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_MODE_X4,PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x1, PEX1 x4*/
-	{MV_TRUE, 0x11111111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4,PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x4, PEX1 x4*/
+	{MV_TRUE, 0x33221111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},/* Default: No Pex module, PEX0 x1, disabled*/
+	{MV_TRUE, 0x33211111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_MODE_X1,  PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x1, PEX1 x1*/
+	{MV_TRUE, 0x33221111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_DISABLED, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},/* no Pex module, PEX0 x4, PEX1 disabled*/
+	{MV_TRUE, 0x33211111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X1,  PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x4, PEX1 x1*/
+	{MV_TRUE, 0x11111111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_MODE_X4,  PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x1, PEX1 x4*/
+	{MV_TRUE, 0x11111111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4,  PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x4, PEX1 x4*/
 };
 
 MV_BOARD_TDM_INFO	db88f78XX0rev2Tdm880[]	= { {1}, {2} };
@@ -1172,7 +1172,7 @@ MV_BOARD_MPP_INFO db78X60amcInfoBoardMpp
 };
 
 MV_SERDES_CFG db78X60amcInfoBoardSerdesConfigValue[] = {
-	 {MV_TRUE, 0x33111111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030} /* Default */
+	 {MV_TRUE, 0x23111111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X1, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030} /* Default */
 };
 
 
--- a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h
@@ -98,8 +98,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #define DB_78X60_AMC_ID				(RD_78460_NAS_ID + 1)
 #define DB_78X60_PCAC_REV2_ID		(DB_78X60_AMC_ID + 1)
 #define RD_78460_SERVER_REV2_ID		(DB_78X60_PCAC_REV2_ID + 1)
-#define RD_78460_GP_ID				(RD_78460_SERVER_REV2_ID + 1)
-#define RD_78460_CUSTOMER_ID		(RD_78460_GP_ID+ 1)
+#define DB_784MP_GP_ID				(RD_78460_SERVER_REV2_ID + 1)
+#define RD_78460_CUSTOMER_ID		(DB_784MP_GP_ID+ 1)
 #define MV_MAX_BOARD_ID				(RD_78460_CUSTOMER_ID + 1)
 #define INVALID_BAORD_ID			0xFFFFFFFF
 
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -123,7 +123,7 @@ MV_BIOS_MODE bios_modes[BIOS_MODES_NUM]
 #else
 /*DBConf ConfID Code L2Size CPUFreq CpuFreqMode FabricFreq  Altfabricfreq     FabricFreqMode CPU1/2/3Enable cpuEndianess dramBusWidth BootSRC BootWidth */
 /*	                       0x4d/[1:0]  0x4d/[4:2]  0x4e[0]      0x4e/[4:1]  	0x4f[0]   0x4f/[2:1]      0x4f/[3]   	  */
-{"78130",0x10, 0x7813, 0x1,  0x3,      0x0,      0x1a,		0x5,		0x1,	     0x0,	    0x1,	0x1, 	     0x3,	0x1},
+{"78130",0x10, 0x7813, 0x1,  0x3,      0x0,  0x1a,		0x5,		0x1,	     0x0,	    0x1,	0x1, 	     0x3,	0x1},
 {"78160",0x12, 0x7816, 0x1,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x0,	    0x1, 	0x0, 	     0x3,	0x1},
 {"78230",0x13, 0x7823, 0x1,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x1,	    0x0,	0x1, 	     0x3,	0x1},
 {"78260",0x14, 0x7826, 0x1,  0x3,      0x0,	 0x1a,		0x5,		0x1,	     0x1,	    0x0,	0x0, 	     0x3,	0x1},
@@ -133,21 +133,17 @@ MV_BIOS_MODE bios_modes[BIOS_MODES_NUM]
 /*	{"6710" ,0x11, 0x6710,	0x0,	   0x3,		0x0,	      0x5, 		0x0,		0x0,		0x1,		0x0},     */
 };
 #endif
-
-#if 0
-table below before moving all flavour to 1333/667 mode only
-MV_BIOS_MODE bios_modes[BIOS_MODES_NUM] = {
-/*	DB Conf		Code		L2 size		CPU Freq	Fabric Freq		CPU1/2/3 Enable		CPU Mode v6UP/v6MP
-	0x4d/[1:0]	0x4d/[4:2]	0x4e/[4:1]		0x4f/[2:1]				4f/[4:3]*/
-	{"78130", 	0x7813, 	0x1, 		0x1, 		0x1, 			0x0,					0x0},
-	{"KW40", 	0x6710, 	0x1, 		0x1, 		0x1, 			0x0,					0x0},
-	{"78160", 	0x7816, 	0x1, 		0x3, 		0x5, 			0x0,					0x0},
-	{"78230", 	0x7823, 	0x1, 		0x1, 		0x1, 			0x2,					0x2},
-	{"78260", 	0x7826, 	0x1, 		0x3, 		0x5, 			0x2,					0x2},
-	{"78460", 	0x7846, 	0x3, 		0x3, 		0x5, 			0x3,					0x2},
-	{"78480", 	0x7846, 	0x3, 		0x5, 		0x5, 			0x3,					0x2}
+MV_BIOS_MODE bios_modes_b0[BIOS_MODES_NUM] = {
+/*DBConf ConfID Code L2Size CPUFreq CpuFreqMode FabricFreq  Altfabricfreq  FabricFreqMode CPUEna  cpuEndianess dramBusWidth BootSRC BootWidth */
+/*	                       0x4d/[1:0]  0x4d/[4:2]  0x4e[0]      0x4e/[4:1]  	0x4f[0]   0x4f/[2:1]      0x4f/[3]   	  */
+{"78130",0x10, 0x7813, 0x1,  0x3,      0x0,  		0x5,  	    0x5,        	0x1,	     0x0,	    0x1,		0x1, 	   0x3,		0x1},
+{"78160",0x12, 0x7816, 0x1,  0x3,      0x0,	 		0x5, 		0x5,			0x1,	     0x0,	    0x1, 		0x0, 	   0x3,		0x1},
+{"78230",0x13, 0x7823, 0x1,  0x3,      0x0,	 		0x5, 		0x5,			0x1,	     0x1,	    0x0,		0x1, 	   0x3,		0x1},
+{"78260",0x14, 0x7826, 0x1,  0x3,      0x0,	 		0x5,		0x5,			0x1,	     0x1,	    0x0,		0x0, 	   0x3,		0x1},
+{"78460",0x15, 0x7846, 0x3,  0x3,      0x0,	 		0x5, 		0x5,			0x1,	     0x3,	    0x1,		0x0, 	   0x3,		0x1},
+{"78480",0x16, 0x7846, 0x3,  0x3,      0x0,	 		0x5, 		0x5,			0x1,	     0x3,	    0x1,		0x0, 	   0x3,		0x1}
 };
-#endif
+
 MV_U32 mvCtrlGetCpuNum(MV_VOID)
 {
 	return ((MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_CORE_MASK) >> SAR1_CPU_CORE_OFFSET);
@@ -166,6 +162,7 @@ MV_BOOL mvCtrlIsValidSatR(MV_VOID)
 	MV_U8 fabricFreq;
 	MV_U8 cpuFreqMode;
 	MV_U8 fabricFreqMode;
+	MV_BIOS_MODE * pBbiosModes;
 
 	MV_U32 confId = mvBoardConfIdGet();
 
@@ -178,45 +175,51 @@ MV_BOOL mvCtrlIsValidSatR(MV_VOID)
 	/* Bug fix in HW, bit0 & bit1 are swapped */
 	cpuEna |= (tmpSocCores & 0x2) >> 1;
 	cpuEna |= (tmpSocCores & 0x1) << 1;
+	if (mvCtrlRevGet() == 2)
+		pBbiosModes = bios_modes_b0;
+	else
+		pBbiosModes = bios_modes;
 
 	/* Find out what is programmed in SAR and change device ID accordingly */
 	for (i = 0; i < BIOS_MODES_NUM; i++) {
-		if (bios_modes[i].confId == confId) {
+		if (pBbiosModes->confId == confId) {
 			DB(mvOsPrintf("confId = 0x%x\n", confId));
-			DB(mvOsPrintf("cpuFreq [0x%x] = 0x%x\n", cpuFreq, bios_modes[i].cpuFreq));
-			DB(mvOsPrintf("fabricFreq [0x%x] = 0x%x\n", fabricFreq, bios_modes[i].fabricFreq));
-			DB(mvOsPrintf("cpuEna [0x%x] = 0x%x\n", cpuEna, bios_modes[i].cpuEna));
-			DB(mvOsPrintf("cpuFreqMode [0x%x] = 0x%x\n", cpuFreqMode, bios_modes[i].cpuFreqMode));
-			DB(mvOsPrintf("fabricFreqMode [0x%x] = 0x%x\n", fabricFreqMode, bios_modes[i].fabricFreqMode));
-			DB(mvOsPrintf("l2size [0x%x] = 0x%x\n", l2size, bios_modes[i].l2size));
-			if ((cpuFreq == bios_modes[i].cpuFreq) &&
-				(fabricFreq ==  bios_modes[i].fabricFreq) &&
-				(cpuEna == bios_modes[i].cpuEna) &&
-				(cpuFreqMode == bios_modes[i].cpuFreqMode) &&
-				(fabricFreqMode == bios_modes[i].fabricFreqMode) &&
-				(l2size == bios_modes[i].l2size)) {
+			DB(mvOsPrintf("cpuFreq [0x%x] = 0x%x\n", cpuFreq, pBbiosModes->cpuFreq));
+			DB(mvOsPrintf("fabricFreq [0x%x] = 0x%x\n", fabricFreq, pBbiosModes->fabricFreq));
+			DB(mvOsPrintf("cpuEna [0x%x] = 0x%x\n", cpuEna, pBbiosModes->cpuEna));
+			DB(mvOsPrintf("cpuFreqMode [0x%x] = 0x%x\n", cpuFreqMode, pBbiosModes->cpuFreqMode));
+			DB(mvOsPrintf("fabricFreqMode [0x%x] = 0x%x\n", fabricFreqMode, pBbiosModes->fabricFreqMode));
+			DB(mvOsPrintf("l2size [0x%x] = 0x%x\n", l2size, pBbiosModes->l2size));
+			if ((cpuFreq == pBbiosModes->cpuFreq) &&
+				(fabricFreq ==  pBbiosModes->fabricFreq) &&
+				(cpuEna == pBbiosModes->cpuEna) &&
+				(cpuFreqMode == pBbiosModes->cpuFreqMode) &&
+				(fabricFreqMode == pBbiosModes->fabricFreqMode) &&
+				(l2size == pBbiosModes->l2size)) {
 				return MV_TRUE;
 			} else {
 				return MV_FALSE;
 			}
 		}
+		pBbiosModes++;
 	}
 	return MV_FALSE;
 }
 MV_STATUS mvCtrlUpdatePexId(MV_VOID)
 {
-	/* MV_U32 socFreq, tmpSocCores;		*/
-	/* MV_U32 socCores = 0;				*/
 	MV_U32 pmCtrl;
 #if defined(DB_88F78X60) || defined(RD_88F78460_SERVER) || defined (DB_88F78X60_REV2)
+	MV_BIOS_MODE * pBbiosModes;
 	MV_U32 devVendId;
-	int i;
-	int j;
+	int i, j;
 	MV_U16 confId;
 	MV_U32 tmp;
-	MV_U32 NewVal;
-#endif
+	if (mvCtrlRevGet() == 2)
+		pBbiosModes = bios_modes_b0;
+	else
+		pBbiosModes = bios_modes;
 
+#endif
 	/* if PEX0 clock is disabled - enable it for reading the device ID */
 	pmCtrl = MV_REG_READ(POWER_MNG_CTRL_REG);
 	if ((pmCtrl & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0)) {
@@ -225,38 +228,34 @@ MV_STATUS mvCtrlUpdatePexId(MV_VOID)
 	}
 #if defined(DB_88F78X60) || defined (DB_88F78X60_REV2)
 	devVendId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
-	/* socFreq   = MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_DDR3_FREQ_MASK; */
-	/* tmpSocCores  = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_CORE_MASK) >> SAR1_CPU_CORE_OFFSET; */
-	confId = mvBoardConfIdGet();
 
-	/* Bug fix in HW, bit0 & bit1 are swapped */
-/*	socCores |= (tmpSocCores & 0x2) >> 1;
-	socCores |= (tmpSocCores & 0x1) << 1;
-*/
-	/* Find out what is programmed in SAR and change device ID accordingly */
-/*	if ((socFreq == SAR_CPU_FAB_GET(bios_modes[i].cpuFreq, bios_modes[i].fabricFreq)) &&
-			(socCores == bios_modes[i].cpuEna)) {
-*/
-	tmp = MV_REG_READ(SOC_CTRL_REG); /*Saving old value of 0x18204 to tmp*/
-	NewVal = tmp;
-	NewVal |=0x00000080; /* writing 1 to bit 7 */
-	MV_REG_WRITE(SOC_CTRL_REG, NewVal); /* writing '1' to bit 7 in order to get an access to PEX registers */
+	confId = mvBoardConfIdGet();
+	tmp = MV_REG_READ(SOC_CTRL_REG);
 	for (i = 0; i < BIOS_MODES_NUM; i++) {
-		if (bios_modes[i].confId == confId) {
+		if (pBbiosModes->confId == confId) {
 			devVendId &= 0x0000FFFF;
-			devVendId |= bios_modes[i].code << 16;
+			devVendId |= pBbiosModes->code << 16;
 			for (j=0;j<mvCtrlPexMaxIfGet();j++){
 				MV_REG_WRITE(MV_PEX_IF_REGS_OFFSET(j), devVendId);
+				if ((0 == j) & (0 == (tmp & PCIE0_QUADX1_EN)))
+					j+=3;
+				if ((4 == j) & (0 == (tmp & PCIE1_QUADX1_EN)))
+					j+=3;
 			}
 		}
+		pBbiosModes++;
 	}
-	MV_REG_WRITE(SOC_CTRL_REG, tmp);/*returing 0x18204 to it's previous value. */
 
 #elif defined(RD_88F78460_SERVER)
 	devVendId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
 	devVendId &= 0x0000FFFF;
 	devVendId |= 0x7846 << 16;
 	MV_REG_WRITE(MV_PEX_IF_REGS_OFFSET(0), devVendId);
+//#elif defined(RD_78460_GP)
+//	devVendId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
+//	devVendId &= 0x0000FFFF;
+//	devVendId |= 0x7846 << 16;
+//	MV_REG_WRITE(MV_PEX_IF_REGS_OFFSET(0), devVendId);
 #endif
 	/* Reset the original value of PEX0 clock */
 	if ((pmCtrl & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0))
@@ -289,10 +288,9 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 {
 	MV_U32 mppGroup;
 	MV_U32 mppVal;
-	MV_BOARD_PEX_INFO  *boardPexInfo = mvBoardPexInfoGet();
-	MV_U32 pexUnit = 0;
 	MV_U32 i, gppMask;
 
+
 	/* Disable MBus Error Propagation */
 	MV_REG_BIT_RESET(SOC_COHERENCY_FABRIC_CTRL_REG, BIT8);
 
@@ -332,20 +330,6 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 	if (MV_OK != mvCtrlSerdesPhyConfig())
 		mvOsPrintf("mvCtrlEnvInit: Can't init some or all SERDES lanes\n");
 
-	for (pexUnit = 0; pexUnit < mvCtrlPexMaxUnitGet(); pexUnit++) {
-		/* PEX enabling */
-		if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg != PEX_BUS_DISABLED)
-			MV_REG_BIT_SET(SOC_CTRL_REG, SCR_PEX_ENA_MASK(pexUnit));
-		else
-			MV_REG_BIT_RESET(SOC_CTRL_REG, SCR_PEX_ENA_MASK(pexUnit));
-	}
-
-	/* In case the sample at reset REG indicates a CLK 100MHZ is used for output we should enable the CLK through the SOC CTRL REG*/
-	if ( ((MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & PEX_CLK_100MHZ_MASK) >> PEX_CLK_100MHZ_OFFSET) == 0x1) {
-	        MV_REG_BIT_SET(SOC_CTRL_REG,PCIE0_CLK_OUT_EN_MASK);
-	        MV_REG_BIT_SET(SOC_CTRL_REG,PCIE1_CLK_OUT_EN_MASK);
-	}
-
 #ifndef MV88F78X60_Z1
 	MV_REG_BIT_SET(PUP_EN_REG,0x17); /* Enable GBE0, GBE1, LCD and NFC PUP */
 #endif
@@ -999,7 +983,6 @@ MV_STATUS mvCtrlModelRevNameGet(char *pN
 	 case MV_78130_A0_ID:
                mvOsSPrintf(pNameBuff, "%s", MV_78130_A0_NAME);
                break;
-
        case MV_78230_A0_ID:
                mvOsSPrintf(pNameBuff, "%s", MV_78230_A0_NAME);
                break;
@@ -1012,6 +995,22 @@ MV_STATUS mvCtrlModelRevNameGet(char *pN
        case MV_78460_A0_ID:
               mvOsSPrintf(pNameBuff, "%s", MV_78460_A0_NAME);
                break;
+	case MV_78130_B0_ID:
+			  mvOsSPrintf(pNameBuff, "%s", MV_78130_B0_NAME);
+			  break;
+	  case MV_78230_B0_ID:
+			  mvOsSPrintf(pNameBuff, "%s", MV_78230_B0_NAME);
+			  break;
+	  case MV_78160_B0_ID:
+			  mvOsSPrintf(pNameBuff, "%s", MV_78160_B0_NAME);
+			  break;
+	  case MV_78260_B0_ID:
+			  mvOsSPrintf(pNameBuff, "%s", MV_78260_B0_NAME);
+			  break;
+	  case MV_78460_B0_ID:
+			 mvOsSPrintf(pNameBuff, "%s", MV_78460_B0_NAME);
+			  break;
+
 	default:
 		mvCtrlNameGet(pNameBuff);
 		break;
@@ -1936,16 +1935,13 @@ MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID)
 	MV_U32		serdesLineCfg;
 	MV_U8		serdesLineNum;
 	MV_U8		pexUnit, pexLineNum;
-	MV_U8		step;
 	MV_U8		maxSerdesLines = mvCtrlSerdesMaxLinesGet();
 	MV_SERDES_CFG	*pSerdesInfo = mvBoardSerdesCfgGet();
 	MV_BOARD_PEX_INFO 	*boardPexInfo = mvBoardPexInfoGet();
 	MV_STATUS	status = MV_OK;
-	MV_U32		tmp;
 
 /* this is a mapping of the final power management clock gating control register value @ 0x18220.*/
 	MV_U32	powermngmntctrlregmap = 0x0;
-	MV_U32	ethport = 0;
 	MV_U32	tmpcounter = 0;
 
 	/* Check if no SERDESs available - FPGA */
@@ -2123,60 +2119,6 @@ MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID)
 #endif /* defined(MV_INCLUDE_CLK_PWR_CNTRL) */
 
 
-
-#if 0
-	#define MV_PEX_UNIT_TO_IF(pexUnit)	((pexUnit < 3) ? (pexUnit*4) : 9)
-	for (pexUnit = 0; pexUnit < mvCtrlPexMaxUnitGet(); pexUnit++) {
-		if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_DISABLED)
-			continue;
-                 /* PEX capability workaround: setting capability as GEN1 or GEN2 according to SatR (valid only for DB board) , (Mark , Moti) */
-                tmp = MV_REG_READ(PEX_LINK_CAPABILITIES_REG(MV_PEX_UNIT_TO_IF(pexUnit)));
-                tmp &= ~(0xF);
-                switch (mvBoardPexCapabilityGet()) {
-                    case 0x0:
-                             tmp |= 0x1;
-                              break;
-                    case 0x1:
-                    default:
-                              tmp |= 0x2;
-                              break;
-                  }
-                      MV_REG_WRITE(PEX_LINK_CAPABILITIES_REG(MV_PEX_UNIT_TO_IF(pexUnit)), tmp);
-		}
-#else
-		for (serdesLineNum = 0; serdesLineNum < maxSerdesLines; serdesLineNum++) {
-	                if (serdesLineNum < 8)
-                                serdesLineCfg = (pSerdesInfo->serdesLine0_7 >> (serdesLineNum << 2)) & 0xF;
-                        else
-                                serdesLineCfg = (pSerdesInfo->serdesLine8_15 >> ((serdesLineNum - 8) << 2)) & 0xF;
-
-			if(serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_PEX]) {
-				pexUnit    = serdesLineNum >> 2;
-				pexLineNum = serdesLineNum % 4;
-				if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_DISABLED)
-					continue;
-				tmp = MV_REG_READ(PEX_LINK_CAPABILITIES_REG(MV_SERDES_NUM_TO_PEX_NUM(serdesLineNum)));
-				tmp &= ~(0xF);
-				switch (mvBoardPexCapabilityGet()) {
-				case 0x0:
-					tmp |= 0x1;
-					break;
-				case 0x1:
-				default:
-					tmp |= 0x2;
-					break;
-				}
-				MV_REG_WRITE(PEX_LINK_CAPABILITIES_REG(MV_SERDES_NUM_TO_PEX_NUM(serdesLineNum)), tmp);
-
-				if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_MODE_X4)
-                                        serdesLineNum += 3;
-                        }
-                }
-
-#endif
-
-
-
 	return status;
 err_cfg:
 	DB(mvOsPrintf("%s: Wrong CFG (%#x) for SERDES line %d.\n",
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -189,7 +189,9 @@ typedef struct {
 	MV_U8 cpuFreq;
 	MV_U8 cpuFreqMode;
 	MV_U8 fabricFreq;
+#ifndef MV88F78X60_Z1
 	MV_U8 AltfabricFreq;
+#endif
 	MV_U8 fabricFreqMode;
 	MV_U8 cpuEna;
 #ifdef MV88F78X60_Z1
@@ -203,11 +205,13 @@ typedef struct {
 } MV_BIOS_MODE;
 
 extern MV_BIOS_MODE bios_modes[];
+extern MV_BIOS_MODE bios_modes_b0[];
 
 /* mcspLib.h API list */
 MV_U32 mvCtrlGetCpuNum(MV_VOID);
 MV_U32 mvCtrlGetQuadNum(MV_VOID);
 MV_STATUS mvCtrlUpdatePexId(MV_VOID);
+MV_BOOL mvCtrlIsValidSatR(MV_VOID);
 
 MV_STATUS mvCtrlEnvInit(MV_VOID);
 MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -117,8 +117,8 @@ extern "C" {
 	#define MV_ETH_BASE_ADDR		(0x70000)
 #endif
 #define MV_ETH_REGS_OFFSET(port)		(MV_ETH_BASE_ADDR - ((port) / 2) * 0x40000 + ((port) % 2) * 0x4000)
-#define MV_PEX_IF_REGS_OFFSET(pexIf)		(pexIf < 8 ? (0x40000 + ((pexIf) / 4) * 0x40000 + ((pexIf) % 4) * 0x4000)\
-							   : (0X42000 + ((pexIf) % 8) * 0x40000))
+#define MV_PEX_IF_REGS_OFFSET(pexIf)		(pexIf < 8 ? (0x40000 + ((pexIf) / 4) * 0x40000 + ((pexIf) % 4) * 0x4000) \
+											 : (0x42000 + ((pexIf) % 8) * 0x40000))
 #define MV_USB_REGS_OFFSET(dev)       		(0x50000 + (dev * 0x1000))
 #define MV_XOR_REGS_OFFSET(unit)		(unit ? 0xF0900 : 0x60900)
 #define MV_CESA_TDMA_REGS_OFFSET(chanNum)	(0x90000 + (chanNum * 0x2000))
@@ -130,16 +130,21 @@ extern "C" {
 #define MV_PNC_REGS_OFFSET			(0xC8000)
 #define MV_SDMMC_REGS_OFFSET			(0xD4000)
 
-#ifdef ARMADA_XP_ERRATA_SMI_1
-#define MV_ETH_SMI_PORT   1
+
+#ifdef CONFIG_ARMADA_XP_ERRATA_SMI_1
+	#define MV_ETH_SMI_PORT   1
 #else
-#define MV_ETH_SMI_PORT   0
+    #define MV_ETH_SMI_PORT   0
 #endif
 
 #define MV_SERDES_NUM_TO_PEX_NUM(sernum)	((sernum < 8) ? (sernum) : (8 + (sernum/12)))
 /*
  * Miscellanuous Controller Configurations
  */
+
+#define AVS_CONTROL2_REG			0x20868
+#define AVS_LOW_VDD_LIMIT			0x20860
+
 #define INTER_REGS_SIZE				_1M
 
 /* This define describes the TWSI interrupt bit and location */
@@ -238,7 +243,7 @@ extern "C" {
 #define MV_ETH_TX_CSUM_MAX_SIZE 		9800
 #define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
 
-#if defined(MV88F78X60_A0) || defined(MV88F78X60_B0)
+#if defined(MV88F78X60) && !defined(MV88F78X60_Z1)
 /* New GMAC module is used */
 #define MV_ETH_GMAC_NEW
 /* New WRR/EJP module is used */
@@ -249,7 +254,8 @@ extern "C" {
 #define MV_ETH_PNC_NEW
 /* PNC Load Balancing support */
 #define MV_ETH_PNC_LB
-#endif /* MV88F78X60_A0, MV88F78X60_B0*/
+#endif /* MV88F78X60_A0/B0 */
+
 #define MV_78130_ETH_MAX_PORT			3
 #define MV_78460_ETH_MAX_PORT			4
 
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c
@@ -121,4 +121,4 @@ MV_32 mvReadAmpReg(int regId)
 MV_32 mvWriteAmpReg(int regId, MV_32 value)
 {
 	return MV_REG_WRITE(MV_AMP_GLOBAL_REG(regId), value);
-}
+}
\ No newline at end of file
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c
@@ -263,4 +263,4 @@ MV_VOID mvUnitMapPrint()
 		}
 	}
 	mvOsPrintf("\n");
-}
+}
\ No newline at end of file
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c
@@ -87,17 +87,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin);
 
 MV_TARGET sampleAtResetTargetArray[] = BOOT_TARGETS_NAME_ARRAY;
-
-/*******************************************************************************
-* mvCpuIfVerify - Verify that the address decode registers matches the table
-*
-* INPUT:
-*       cpuAddrWinMap 	- Address decode table
-*
-* RETURN:
-*       MV_OK - pass MV_ERROR - fail
-*
-*******************************************************************************/
 MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap)
 {
 	MV_CPU_DEC_WIN win;
@@ -263,21 +252,13 @@ MV_STATUS mvCpuIfInitForCpu(MV_U32 cpu,
 		if (MV_TARGET_IS_PEX(target))
 			continue;
 #endif
-		if ((0 == cpuAddrWinMap[target].addrWin.size) || (DIS == cpuAddrWinMap[target].enable)) {
-			#if 0 /* TODO: windows are already disabled above, we need to skip only*/
-			if (MV_OK != mvCpuIfTargetWinEnable(target, MV_FALSE)) {
-				DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinEnable fail\n"));
-				return MV_ERROR;
-			}
-			#else
-			{continue; }
-			#endif
-		} else {
+		if ((0 == cpuAddrWinMap[target].addrWin.size) || (DIS == cpuAddrWinMap[target].enable))
+			continue;
+		else {
 			if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
 				DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinSet fail\n"));
 				return MV_ERROR;
 			}
-
 			addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
 			addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
 			if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
@@ -286,16 +267,6 @@ MV_STATUS mvCpuIfInitForCpu(MV_U32 cpu,
 			}
 		}
 	}
-#if 0
-/* This is not needed anymore cause pex enabled is already at CtrlEnvInit */
-#ifdef MV_INCLUDE_PEX
-	if (cpu == 0) {		/* Not needed for all CPUs */
-		MV_U32 pexUnits = mvCtrlPexMaxUnitGet();
-		for (i = 0; i < pexUnits; i++)
-			mvCpuIfEnablePex(i);
-	}
-#endif
-#endif
 	return MV_OK;
 }
 
--- a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -104,6 +104,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #define CPU1_PRIO_HIGH (CPU_PRIO_HIGH << 2)
 #define CPU2_PRIO_HIGH (CPU_PRIO_HIGH << 4)
 #define CPU3_PRIO_HIGH (CPU_PRIO_HIGH << 6)
+/*   SoC Control Register bits  */
+#define PCIE0_QUADX1_EN				(1<<7)
+#define PCIE1_QUADX1_EN				(1<<8)
+
 /* ARM Configuration register */
 /* CPU_CONFIG_REG (CCR) */
 
@@ -265,7 +269,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #define CL2ACR_REP_STRGY_LFSR_MASK              (0x1 << CL2ACR_REP_STRGY_OFFS)
 #define CL2ACR_REP_STRGY_semiPLRU_MASK		(0x2 << CL2ACR_REP_STRGY_OFFS)
 #define CL2ACR_REP_STRGY_semiPLRU_WA_MASK          (0x3 << CL2ACR_REP_STRGY_OFFS)
-
+#define CL2_DUAL_EVICTION		(0x1 << 4)
+#define CL2_PARITY_ENABLE		(0x1 << 21)
+#define CL2_InvalEvicLineUCErr          (0x1 << 22)
 
 /* SOC_CTRL_REG fields */
 #define SCR_PEX_ENA_OFFS(pex)			((pex) & 0x3)
--- a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c
+++ b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c
@@ -88,7 +88,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #if defined(MV88F78X60_Z1)
 #define CNTMR_EVENTS_STATUS_REG_PRIVATE(t)	(MV_CPUIF_REGS_OFFSET(TIMER_TO_CPU(t) + 0x68))
 #define TIMER_PRIVATE_BIT(timer)	(1 << ((CPU_TIMER(timer) * 8)))
-#elif defined(MV88F78X60_A0) || defined(MV88F78X60_B0)
+#elif defined(MV88F78X60) && !defined(MV88F78X60_Z1)
 #define CNTMR_EVENTS_STATUS_REG_PRIVATE		(MV_CPUIF_LOCAL_REGS_OFFSET + 0x68)
 #define TIMER_PRIVATE_BIT(timer)	(1 << ((timer - FIRST_PRIVATE_TIMER) * 8))
 #elif defined(CONFIG_ARCH_ARMADA370)
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramCounters.h
+++ /dev/null
@@ -1,273 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef __INCmvDramCountersh
-#define __INCmvDramCountersh
-
-/* includes */
-#include "mvCommon.h"
-#include "mvOs.h"
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "mvSysDdrConfig.h"
-#include "mvDramIfRegs.h"
-
-
-
-#define SDRAM_STAT_CNTRS_CTRL  			(MV_DDR_REGS_BASE + 0x1590)
-#define SDRAM_STAT_CNTR_SELECT_OFFSET(c)	((c == 0) ? 0 : 8)
-#define SDRAM_STAT_CNTR_SELECT_MASK(c)		(0x1F << SDRAM_STAT_CNTR_SELECT_OFFSET(c))
-#define SDRAM_STAT_CNTR_RESET_OFFSET		16
-#define SDRAM_STAT_CNTR_RESET_MASK		(0x1 << SDRAM_STAT_CNTR_RESET_OFFSET)
-#define SDRAM_STAT_CNTR_START_OFFSET		17
-#define SDRAM_STAT_CNTR_START_MASK		(0x1 << SDRAM_STAT_CNTR_START_OFFSET)
-
-#define SDRAM_STAT_CNTRS_VAL(set, idx)		(MV_DDR_REGS_BASE + 0x1594 + (set << 3) + (idx << 2))
-#define SDRAM_STAT_HCLK_VAL(idx)		(MV_DDR_REGS_BASE + 0x15A4 + (idx << 2))
-
-
-typedef enum {
-	MBUSL_CACHE_READ = 0,
-	MBUSL_BURST_READ,
-	MBUSL_PAR_READ,
-	MBUSL_CACHE_WRITE,
-	MBUSL_BURST_WRITE,
-	MBUSL_UNSPEC_WRITE,
-	MBUSL_FULL_PAR_WRITE,
-	MBUSL_SEMI_PAR_WRITE,
-	MBUSL_TOTAL_READS,
-	MBUSL_TOTAL_WRITES,
-	MBUSL_TOTAL_TRANS,
-	MBUSL0_TOTAL_TRANS,
-	MBUSL1_TOTAL_TRANS,
-	MBUSL_LOOKUP_HIT,
-	MBUS_CACHE_READ,
-	MBUS_BURST_READ,
-	MBUS_PAR_READ,
-	MBUS_CACHE_WRITE,
-	MBUS_CACHE_WRITE_RMW,
-	MBUS_BURST_WRITE,
-	MBUS_BURST_WRITE_RMW,
-	MBUS_PAR_WRITE,
-	MBUS_PAR_WRITE_RMW,
-	MBUS_TOTAL_READS,
-	MBUS_TOTAL_WRITES,
-	MBUS_TOTAL_TRANS,
-	MBUS0_TOTAL_TRANS,
-	MBUS1_TOTAL_TRANS,
-	MBUS_BURST_CHOP,
-	NUM_BURSTS_128BIT,
-	DRAM_ACTIVE,
-	DRAM_PRECHARGE
-} MV_DRAM_STAT_MODE;
-
-/*******************************************************************************
-* mvDramStatStart
-*
-* DESCRIPTION:
-*       Start DRAM statistics counters.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-static inline void mvDramStatStart(void)
-{
-	MV_REG_BIT_SET(SDRAM_STAT_CNTRS_CTRL, SDRAM_STAT_CNTR_START_MASK);
-}
-
-/*******************************************************************************
-* mvDramStatStop
-*
-* DESCRIPTION:
-*       Stop DRAM statistics counters.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-static inline void mvDramStatStop(void)
-{
-	MV_REG_BIT_RESET(SDRAM_STAT_CNTRS_CTRL, SDRAM_STAT_CNTR_START_MASK);
-}
-
-/*******************************************************************************
-* mvDramStatClear
-*
-* DESCRIPTION:
-*       Clear the DRAM statistics counters.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-static inline void mvDramStatClear(void)
-{
-	MV_U32 reg;
-
-	MV_REG_BIT_SET(SDRAM_STAT_CNTRS_CTRL, SDRAM_STAT_CNTR_RESET_MASK);
-	do {
-		reg = MV_REG_READ(SDRAM_STAT_CNTRS_CTRL);
-	} while(reg & SDRAM_STAT_CNTR_RESET_MASK);
-
-	return;
-}
-
-
-/*******************************************************************************
-* mvDramStatConfig
-*
-* DESCRIPTION:
-*       Configure the DRAM statistics counters.
-*
-* INPUT:
-*       cntIdx	- The counter index to configure.
-*	mode	- The mode to configure the counter.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_OK on success,
-*	MV_FAIL otherwise.
-*
-*******************************************************************************/
-static inline MV_STATUS mvDramStatConfig(MV_U8 cntIdx, MV_DRAM_STAT_MODE mode)
-{
-	MV_U32 reg;
-
-	reg = MV_REG_READ(SDRAM_STAT_CNTRS_CTRL);
-	reg &= ~SDRAM_STAT_CNTR_SELECT_MASK(cntIdx);
-	reg |= (mode << SDRAM_STAT_CNTR_SELECT_OFFSET(cntIdx));
-	MV_REG_WRITE(SDRAM_STAT_CNTRS_CTRL, reg);
-
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvDramStatRead
-*
-* DESCRIPTION:
-*       Read the current DRAM statistics value.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*       counter0 - Value of DRAM statistics counter #0.
-*       counter1 - Value of DRAM statistics counter #1.
-*	hclk	 - Value of HCLK counter.
-*
-* RETURN:
-*       MV_OK on success,
-*	MV_FAIL otherwise.
-*
-*******************************************************************************/
-static inline MV_STATUS mvDramStatRead(MV_U64 *counter0, MV_U64 *counter1, MV_U64 *hclk)
-{
-	MV_U32 val;
-
-	if(counter0 != NULL) {
-		val = MV_REG_READ(SDRAM_STAT_CNTRS_VAL(0, 0));
-		*counter0 = val;
-		val = MV_REG_READ(SDRAM_STAT_CNTRS_VAL(0, 1));
-		*counter0 |= ((MV_U64)val << 32);
-	}
-
-	if(counter1 != NULL) {
-		val = MV_REG_READ(SDRAM_STAT_CNTRS_VAL(1, 0));
-		*counter1 = val;
-		val = MV_REG_READ(SDRAM_STAT_CNTRS_VAL(1, 1));
-		*counter1 |= ((MV_U64)val << 32);
-	}
-
-	if(hclk != NULL) {
-		val = MV_REG_READ(SDRAM_STAT_HCLK_VAL(0));
-		*hclk = val;
-		val = MV_REG_READ(SDRAM_STAT_HCLK_VAL(1));
-		*hclk |= ((MV_U64)val << 32);
-	}
-
-	return MV_OK;
-}
-
-#endif /* __INCmvDramCountersh */
-
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIf.c
+++ /dev/null
@@ -1,2145 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-
-/* includes */
-#include "mvCommon.h"
-#include "mvOs.h"
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "mvSysDdrConfig.h" 
-#include "mvDramIf.h"
-#include "mvDramIfConfig.h"
-#include "mvDramIfRegs.h"
-/* #include "ctrlEnv/sys/mvCpuIf.h" */
-#include "mvDramIfStaticInit.h"
-#include "spd/mvSpd.h"
-
-/* #define MV_DEBUG */
-#ifdef MV_DEBUG
-#define DB(x) x
-#else
-#define DB(x)
-#endif
-
-/* DRAM bank presence encoding */
-#define BANK_PRESENT_CS0			    0x1
-#define BANK_PRESENT_CS0_CS1			0x3
-#define BANK_PRESENT_CS0_CS2			0x5
-#define BANK_PRESENT_CS0_CS1_CS2		0x7
-#define BANK_PRESENT_CS0_CS2_CS3		0xd
-#define BANK_PRESENT_CS0_CS2_CS3_CS4	0xf
-
-/* locals   */
-#ifndef MV_STATIC_DRAM_ON_BOARD
-static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo);
-static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, MV_U32  busClk, MV_STATUS TTmode );
-static MV_U32 dunitCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32  busClk);
-static MV_U32 sdramModeRegCalc(MV_U32 minCas);
-static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk);
-static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_DRAM_BANK_INFO *pBankInfoDIMM1);
-static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_DRAM_BANK_INFO *pBankInfo2, MV_U32 busClk);
-static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO *pBankInfo2, MV_U32 busClk, MV_U32 forcedCl);
-static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, MV_U32 busClk);
-static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk);
-static MV_U32 sdramDdr2TimeLoRegCalc(MV_U32 minCas);
-static MV_U32 sdramDdr2TimeHiRegCalc(MV_U32 minCas);
-#endif
-MV_32 DRAM_CS_Order[MV_DRAM_MAX_CS] = {N_A
-
-#ifdef MV_INCLUDE_SDRAM_CS1
-		,N_A
-#endif
-#ifdef MV_INCLUDE_SDRAM_CS2
-		,N_A
-#endif
-#ifdef MV_INCLUDE_SDRAM_CS3
-    ,N_A
-#endif
-	};
-/* Get DRAM size of CS num */
-MV_U32 mvDramCsSizeGet(MV_U32 csNum)
-{
-	MV_DRAM_BANK_INFO bankInfo;
-	MV_U32  size, deviceW, dimmW;
-#ifdef MV78XX0	
-	MV_U32  temp;
-#endif
-
-	if(MV_OK == mvDramBankInfoGet(csNum, &bankInfo))
-	{
-        	if (0 == bankInfo.size)
-			return 0;
-
-		/* Note that the Dimm width might be different then the device DRAM width */
-#ifdef MV78XX0	
-		temp = MV_REG_READ(SDRAM_CONFIG_REG);
-		deviceW = ((temp & SDRAM_DWIDTH_MASK) == SDRAM_DWIDTH_32BIT )? 32 : 64;
-#else
-		deviceW = 16 /* KW family */;
-#endif
-		dimmW = bankInfo.dataWidth - (bankInfo.dataWidth % 16);
-		size = ((bankInfo.size << 20) / (dimmW/deviceW)); 
-		return size;
-	}
-	else
-		return 0;
-}
-/*******************************************************************************
-* mvDramIfDetect - Prepare DRAM interface configuration values.
-*
-* DESCRIPTION:
-*       This function implements the full DRAM detection and timing 
-*       configuration for best system performance.
-*       Since this routine runs from a ROM device (Boot Flash), its stack 
-*       resides on RAM, that might be the system DRAM. Changing DRAM 
-*       configuration values while keeping vital data in DRAM is risky. That
-*       is why the function does not preform the configuration setting but 
-*       prepare those in predefined 32bit registers (in this case IDMA 
-*       registers are used) for other routine to perform the settings.
-*       The function will call for board DRAM SPD information for each DRAM 
-*       chip select. The function will then analyze those SPD parameters of 
-*       all DRAM banks in order to decide on DRAM configuration compatible 
-*       for all DRAM banks.
-*       The function will set the CPU DRAM address decode registers.
-*       Note: This routine prepares values that will overide configuration of
-*       mvDramBasicAsmInit().
-*       
-* INPUT:
-*       forcedCl - Forced CAL Latency. If equal to zero, do not force.
-*       eccDisable - Force down the ECC.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable, MV_U32 sysClk)
-{
-#ifndef MV_STATIC_DRAM_ON_BOARD
-	MV_32 	MV_DRAM_CS_order[MV_DRAM_MAX_CS] = {
-		SDRAM_CS0
-#ifdef MV_INCLUDE_SDRAM_CS1
-		,SDRAM_CS1
-#endif
-#ifdef MV_INCLUDE_SDRAM_CS2
-		,SDRAM_CS2
-#endif
-#ifdef MV_INCLUDE_SDRAM_CS3
-		,SDRAM_CS3
-#endif
-		};
-#endif
-	MV_U32  busClk;
-#ifndef MV_STATIC_DRAM_ON_BOARD
-	MV_U32  deviceW, dimmW;
-	MV_U32 numOfAllDevices = 0;
-	MV_STATUS TTMode; 
-	MV_DRAM_BANK_INFO bankInfo[MV_DRAM_MAX_CS];
-	MV_U32  size, base = 0, i, j, temp, busClkPs;
-	MV_U8	minCas;
-	MV_DRAM_DEC_WIN dramDecWin;
-	dramDecWin.addrWin.baseHigh = 0;
-#endif
-
-	busClk = sysClk;
-
-	if (0 == busClk)
-	{
-		mvOsPrintf("Dram: ERR. Can't detect system clock! \n");
-		return MV_ERROR;
-	}
-	
-#ifndef MV_STATIC_DRAM_ON_BOARD
-
-	busClkPs = 1000000000 / (busClk / 1000);  /* in ps units */
-	/* we will use bank 0 as the representative of the all the DRAM banks,  */
-	/* since bank 0 must exist.                                             */	
-	for(i = 0; i < MV_DRAM_MAX_CS; i++)
-	{ 
-		/* if Bank exist */
-		if(MV_OK == mvDramBankInfoGet(i, &bankInfo[i]))
-		{
-			DB(mvOsPrintf("Dram: Find bank %d\n", i));
-			/* check it isn't SDRAM */
-			if(bankInfo[i].memoryType != MEM_TYPE_DDR2)
-			{
-				mvOsOutput("Dram: ERR. SDRAM type not supported !!!\n");
-				return MV_ERROR;
-			}
-
-            		/* All banks must support the Mclk freqency */
-			if(bankInfo[i].minCycleTimeAtMaxCasLatPs > busClkPs)
-			{
-				mvOsOutput("Dram: ERR. Bank %d doesn't support memory clock!!!\n", i);
-				return MV_ERROR;
-			}
-
-			/* All banks must support registry in order to activate it */
-			if(bankInfo[i].registeredAddrAndControlInputs != 
-			   bankInfo[0].registeredAddrAndControlInputs)
-			{
-				mvOsOutput("Dram: ERR. different Registered settings !!!\n");
-				return MV_ERROR;
-			}
-
-			/* All banks must support same ECC mode */
-			if(bankInfo[i].errorCheckType != 
-			   bankInfo[0].errorCheckType)
-			{
-				mvOsOutput("Dram: ERR. different ECC settings !!!\n");
-				return MV_ERROR;
-			}
-
-		}
-		else
-		{
-			if( i == 0 ) /* bank 0 doesn't exist */
-			{
-				mvOsOutput("Dram: ERR. Fail to detect bank 0 !!!\n");
-				return MV_ERROR;
-			}
-			else
-			{
-				DB(mvOsPrintf("Dram: Could not find bank %d\n", i));
-				bankInfo[i].size = 0;     /* Mark this bank as non exist */
-			}
-		}
-	}
-
-#ifdef MV_INCLUDE_SDRAM_CS2
-	if (bankInfo[SDRAM_CS0].size <  bankInfo[SDRAM_CS2].size)
-	{
-		MV_DRAM_CS_order[0] = SDRAM_CS2;
-		MV_DRAM_CS_order[1] = SDRAM_CS3;
-		MV_DRAM_CS_order[2] = SDRAM_CS0;
-		MV_DRAM_CS_order[3] = SDRAM_CS1;
-		DRAM_CS_Order[0] = SDRAM_CS2;
-		DRAM_CS_Order[1] = SDRAM_CS3;
-		DRAM_CS_Order[2] = SDRAM_CS0;
-		DRAM_CS_Order[3] = SDRAM_CS1;
-
-	}
-	else
-#endif
-	{
-		MV_DRAM_CS_order[0] = SDRAM_CS0;
-		MV_DRAM_CS_order[1] = SDRAM_CS1;
-		DRAM_CS_Order[0] = SDRAM_CS0;
-		DRAM_CS_Order[1] = SDRAM_CS1;
-#ifdef MV_INCLUDE_SDRAM_CS2
-		MV_DRAM_CS_order[2] = SDRAM_CS2;
-		MV_DRAM_CS_order[3] = SDRAM_CS3;
-		DRAM_CS_Order[2] = SDRAM_CS2;
-		DRAM_CS_Order[3] = SDRAM_CS3;
-#endif
-	}
-
-	for(j = 0; j < MV_DRAM_MAX_CS; j++)
-	{
-		i = MV_DRAM_CS_order[j];
-		
-        	if (0 == bankInfo[i].size)
-			continue;
-
-			/* Init the CPU window decode */
-			/* Note that the Dimm width might be different then the device DRAM width */
-#ifdef MV78XX0	
-			temp = MV_REG_READ(SDRAM_CONFIG_REG);
-			deviceW = ((temp & SDRAM_DWIDTH_MASK) == SDRAM_DWIDTH_32BIT )? 32 : 64;
-#else
-			deviceW = 16 /* KW family */;
-#endif
-			dimmW = bankInfo[0].dataWidth - (bankInfo[0].dataWidth % 16);
-			size = ((bankInfo[i].size << 20) / (dimmW/deviceW)); 
-		
-			/* We can not change DRAM window settings while excecuting  	*/
-			/* code from it. That is why we skip the DRAM CS[0], saving     */
-			/* it to the ROM configuration routine				*/
-
-			numOfAllDevices += bankInfo[i].numberOfDevices;
-			if (i == MV_DRAM_CS_order[0])
-			{
-				MV_U32 sizeToReg;
-				/* Translate the given window size to register format		*/
-				sizeToReg = ctrlSizeToReg(size, SCSR_SIZE_ALIGNMENT);
-				/* Size parameter validity check.                           */
-				if (-1 == sizeToReg)
-				{
-					mvOsOutput("DRAM: ctrlSizeToReg: ERR. Win %d size invalid.\n"
-							   ,i);
-					return MV_BAD_PARAM;
-				}
-
-				DB(mvOsPrintf("Dram: Bank 0 Size - %x\n",sizeToReg);)
-				sizeToReg = (sizeToReg << SCSR_SIZE_OFFS);
-				sizeToReg |= SCSR_WIN_EN;
-				MV_REG_WRITE(DRAM_BUF_REG0, sizeToReg);
-			}
-			else
-			{
-				dramDecWin.addrWin.baseLow = base;
-				dramDecWin.addrWin.size = size;
-				dramDecWin.enable = MV_TRUE;
-				DB(mvOsPrintf("Dram: Enable window %d base 0x%x, size=0x%x\n",i, base, size));
-				
-				/* Check if the DRAM size is more then 3GByte */
-				if (base < 0xC0000000)
-				{
-					DB(mvOsPrintf("Dram: Enable window %d base 0x%x, size=0x%x\n",i, base, size));
-					if (MV_OK != mvDramIfWinSet(i, &dramDecWin))
-					{
-						mvOsPrintf("Dram: ERR. Fail to set bank %d!!!\n", SDRAM_CS0 + i);
-						return 	MV_ERROR;
-					}
-				}
-			}
-			
-			base += size;
-
-			/* update the suportedCasLatencies mask */
-			bankInfo[0].suportedCasLatencies &= bankInfo[i].suportedCasLatencies;
-	}
-
-	/* calculate minimum CAS */
-	minCas = minCasCalc(&bankInfo[0], &bankInfo[2], busClk, forcedCl);
-	if (0 == minCas) 
-	{
-		mvOsOutput("Dram: Warn: Could not find CAS compatible to SysClk %dMhz\n",
-				   (busClk / 1000000));
-
-		minCas = DDR2_CL_4; /* Continue with this CAS */
-		mvOsOutput("Set default CAS latency 4\n");
-	}
-
-	/* calc SDRAM_CONFIG_REG  and save it to temp register */
-	temp = sdramConfigRegCalc(&bankInfo[0],&bankInfo[2], busClk);
-	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. sdramConfigRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-
-	/* check if ECC is enabled by the user */
-	if(eccDisable)	
-	{	
-		/* turn off ECC*/
-		temp &= ~BIT18;
-	}
-	DB(mvOsPrintf("Dram: sdramConfigRegCalc - %x\n",temp);)
-	MV_REG_WRITE(DRAM_BUF_REG1, temp);
-	
-	/* calc SDRAM_MODE_REG  and save it to temp register */ 
-	temp = sdramModeRegCalc(minCas);
-    	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. sdramModeRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: sdramModeRegCalc - %x\n",temp);)
-	MV_REG_WRITE(DRAM_BUF_REG2, temp);
-
-	/* calc SDRAM_EXTENDED_MODE_REG  and save it to temp register */ 
-	temp = sdramExtModeRegCalc(&bankInfo[0], busClk);
-	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. sdramExtModeRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: sdramExtModeRegCalc - %x\n",temp);)
-	MV_REG_WRITE(DRAM_BUF_REG10, temp);
-
-	/* calc D_UNIT_CONTROL_LOW  and save it to temp register */
-	TTMode = MV_FALSE;
-	DB(mvOsPrintf("Dram: numOfAllDevices = %x\n",numOfAllDevices);)
-	if( (numOfAllDevices > 9) && (bankInfo[0].registeredAddrAndControlInputs == MV_FALSE) )
-	{
-		if ( ( (numOfAllDevices > 9) && (busClk > MV_BOARD_SYSCLK_200MHZ) ) ||
-			(numOfAllDevices > 18) )
-		{
-			mvOsOutput("Enable 2T ");
-			TTMode = MV_TRUE;
-		}
-	}
-
-  	temp = dunitCtrlLowRegCalc(&bankInfo[0], minCas, busClk, TTMode ); 
-   	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. dunitCtrlLowRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: dunitCtrlLowRegCalc - %x\n",temp);)
-  	MV_REG_WRITE(DRAM_BUF_REG3, temp); 
-
-	/* calc D_UNIT_CONTROL_HIGH  and save it to temp register */
-  	temp = dunitCtrlHighRegCalc(&bankInfo[0], busClk); 
-   	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. dunitCtrlHighRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: dunitCtrlHighRegCalc - %x\n",temp);)
-	/* check if ECC is enabled by the user */
-	if(eccDisable)	
-	{	
-		/* turn off sample stage if no ecc */
-		temp &= ~SDRAM__D2P_EN;;
-	}
-  	MV_REG_WRITE(DRAM_BUF_REG13, temp); 
-
-	/* calc SDRAM_ADDR_CTRL_REG  and save it to temp register */
-	temp = sdramAddrCtrlRegCalc(&bankInfo[0],&bankInfo[2]);
-    	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. sdramAddrCtrlRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: sdramAddrCtrlRegCalc - %x\n",temp);)
-	MV_REG_WRITE(DRAM_BUF_REG4, temp);
-
-	/* calc SDRAM_TIMING_CTRL_LOW_REG  and save it to temp register */
-	temp = sdramTimeCtrlLowRegCalc(&bankInfo[0], minCas, busClk);
-    	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. sdramTimeCtrlLowRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: sdramTimeCtrlLowRegCalc - %x\n",temp);)
-	MV_REG_WRITE(DRAM_BUF_REG5, temp);
-
-	/* calc SDRAM_TIMING_CTRL_HIGH_REG  and save it to temp register */
-	temp = sdramTimeCtrlHighRegCalc(&bankInfo[0], busClk);
-    	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. sdramTimeCtrlHighRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: sdramTimeCtrlHighRegCalc - %x\n",temp);)
-	MV_REG_WRITE(DRAM_BUF_REG6, temp);
-
-	sdramDDr2OdtConfig(bankInfo);
-
-	/* calc DDR2_SDRAM_TIMING_LOW_REG  and save it to temp register */
-	temp = sdramDdr2TimeLoRegCalc(minCas);
-	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. sdramDdr2TimeLoRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: sdramDdr2TimeLoRegCalc - %x\n",temp);)
-	MV_REG_WRITE(DRAM_BUF_REG11, temp);
-
-	/* calc DDR2_SDRAM_TIMING_HIGH_REG  and save it to temp register */
-	temp = sdramDdr2TimeHiRegCalc(minCas);
-	if(-1 == temp)
-	{
-		mvOsOutput("Dram: ERR. sdramDdr2TimeHiRegCalc failed !!!\n");
-		return MV_ERROR;
-	}
-	DB(mvOsPrintf("Dram: sdramDdr2TimeHiRegCalc - %x\n",temp);)
-	MV_REG_WRITE(DRAM_BUF_REG12, temp);
-#endif
-	
-	/* Note that DDR SDRAM Address/Control and Data pad calibration     */
-	/* settings is done in mvSdramIfConfig.s                            */
-
- 	return MV_OK;
-}
-
-
-/*******************************************************************************
-* mvDramIfBankBaseGet - Get DRAM interface bank base.
-*
-* DESCRIPTION:
-*       This function returns the 32 bit base address of a given DRAM bank.
-*
-* INPUT:
-*       bankNum - Bank number.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       DRAM bank size. If bank is disabled or paramter is invalid, the 
-*		function returns -1.
-*
-*******************************************************************************/
-MV_U32 mvDramIfBankBaseGet(MV_U32 bankNum)
-{
-	MV_DRAM_DEC_WIN addrDecWin;
-	MV_U32	result = 0xFFFFFFFF;
-
-	if(mvDramIfWinGet(SDRAM_CS0 + bankNum, &addrDecWin) == MV_OK) {
-		if(addrDecWin.enable == MV_TRUE)
-			result = addrDecWin.addrWin.baseLow;
-	}
-
-	DB(mvOsPrintf("Dram: mvDramIfBankBaseGet Bank %d base addr is %x \n",
-				  bankNum, result));
-	return result;
-}
-
-/*******************************************************************************
-* mvDramIfBankSizeGet - Get DRAM interface bank size.
-*
-* DESCRIPTION:
-*       This function returns the size of a given DRAM bank.
-*
-* INPUT:
-*       bankNum - Bank number.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       DRAM bank size. If bank is disabled the function return '0'. In case 
-*		or paramter is invalid, the function returns -1.
-*
-*******************************************************************************/
-MV_U32 mvDramIfBankSizeGet(MV_U32 bankNum)
-{
-	MV_DRAM_DEC_WIN addrDecWin;
-	MV_U32	result = 0;
-
-	if(mvDramIfWinGet(SDRAM_CS0 + bankNum, &addrDecWin) == MV_OK) {
-		if(addrDecWin.enable == MV_TRUE)
-			result = addrDecWin.addrWin.size;
-	}
-
-	DB(mvOsPrintf("Dram: mvDramIfBankSizeGet Bank %d size is %x \n",
-				  bankNum, result));
-	return result;
-}
-
-
-/*******************************************************************************
-* mvDramIfSizeGet - Get DRAM interface total size.
-*
-* DESCRIPTION:
-*       This function get the DRAM total size.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       DRAM total size. In case or paramter is invalid, the function 
-*		returns -1.
-*
-*******************************************************************************/
-MV_U32 mvDramIfSizeGet(MV_VOID)
-{
-	MV_U32 size = 0, i;
-	
-	for(i = 0; i < MV_DRAM_MAX_CS; i++)
-		size += mvDramIfBankSizeGet(i);
-	
-	DB(mvOsPrintf("Dram: mvDramIfSizeGet size is %x \n",size));
-	return size;
-}
-
-/*******************************************************************************
-* mvDramIfSingleBitErrThresholdSet - Set single bit ECC threshold.
-*
-* DESCRIPTION:
-*       The ECC single bit error threshold is the number of single bit 
-*       errors to happen before the Dunit generates an interrupt.
-*       This function set single bit ECC threshold.
-*
-* INPUT:
-*       threshold - threshold.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_BAD_PARAM if threshold is to big, MV_OK otherwise.
-*
-*******************************************************************************/
-MV_STATUS mvDramIfSingleBitErrThresholdSet(MV_U32 threshold)
-{
-    MV_U32 regVal; 
-
-    if (threshold > SECR_THRECC_MAX)
-    {
-        return MV_BAD_PARAM;
-    }
-
-    regVal = MV_REG_READ(SDRAM_ECC_CONTROL_REG);
-    regVal &= ~SECR_THRECC_MASK;
-    regVal |= ((SECR_THRECC(threshold) & SECR_THRECC_MASK));
-    MV_REG_WRITE(SDRAM_ECC_CONTROL_REG, regVal);
-
-    return MV_OK;
-}
-
-#ifndef MV_STATIC_DRAM_ON_BOARD
-/*******************************************************************************
-* minCasCalc - Calculate the Minimum CAS latency which can be used.
-*
-* DESCRIPTION:
-*	Calculate the minimum CAS latency that can be used, base on the DRAM
-*	parameters and the SDRAM bus Clock freq.
-*
-* INPUT:
-*	busClk    - the DRAM bus Clock.
-*	pBankInfo - bank info parameters.
-*	forcedCl - Forced CAS Latency multiplied by 10. If equal to zero, do not force.
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       The minimum CAS Latency. The function returns 0 if max CAS latency
-*		supported by banks is incompatible with system bus clock frequancy.
-*
-*******************************************************************************/
-
-static MV_U32 minCasCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO *pBankInfo2, MV_U32 busClk, MV_U32 forcedCl)
-{
-	MV_U32 count = 1, j;
-	MV_U32 busClkPs = 1000000000 / (busClk / 1000);  /* in ps units */
-	MV_U32 startBit, stopBit;
-	MV_U32 minCas0 = 0, minCas2 = 0;
-	
-	
-	/*     DDR 2:
-			*******-******-******-******-******-******-******-******* 
-			* bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-			*******-******-******-******-******-******-******-******* 
-	CAS	=	* TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
-	Disco VI=	* TBD  | TBD  |  5   |  4   |  3   |  TBD   | TBD | TBD * 
-	Disco Duo=	* TBD  |   6  |  5   |  4   |  3   |  TBD   | TBD | TBD * 
-			*********************************************************/
-	
-	
-	/* If we are asked to use the forced CAL  we change the suported CAL to be forcedCl only */
-	if (forcedCl)
-	{
-		mvOsOutput("DRAM: Using forced CL %d.%d\n", (forcedCl / 10), (forcedCl % 10));
-	
-			if (forcedCl == 30)
-				pBankInfo->suportedCasLatencies = 0x08;
-			else if (forcedCl == 40)
-				pBankInfo->suportedCasLatencies = 0x10;
-			else if (forcedCl == 50)
-				pBankInfo->suportedCasLatencies = 0x20;
-			else if (forcedCl == 60)
-				pBankInfo->suportedCasLatencies = 0x40;
-			else
-			{
-				mvOsPrintf("Forced CL %d.%d not supported. Set default CL 4\n", 
-						   (forcedCl / 10), (forcedCl % 10));
-				pBankInfo->suportedCasLatencies = 0x10;
-			}
-
-		return pBankInfo->suportedCasLatencies;        
-	}   
-	
-	/* go over the supported cas mask from Max Cas down and check if the 	*/
-	/* SysClk stands in its time requirments.				*/
-
-	DB(mvOsPrintf("Dram: minCasCalc supported mask = %x busClkPs = %x \n",
-								pBankInfo->suportedCasLatencies,busClkPs ));
-	count = 1;
-	for(j = 7; j > 0; j--)
-	{
-		if((pBankInfo->suportedCasLatencies >> j) & BIT0 )
-		{
-			/* Reset the bits for CL incompatible for the sysClk */
-			switch (count)
-			{
-				case 1: 
-					if (pBankInfo->minCycleTimeAtMaxCasLatPs > busClkPs) 
-						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
-					count++;
-					break;
-				case 2: 
-					if (pBankInfo->minCycleTimeAtMaxCasLatMinus1Ps > busClkPs)
-						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
-					count++;
-					break;
-				case 3: 
-					if (pBankInfo->minCycleTimeAtMaxCasLatMinus2Ps > busClkPs)
-						pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
-					count++;
-					break;
-				default: 
-					pBankInfo->suportedCasLatencies &= ~(BIT0 << j);
-					break;
-			}
-		}
-	}
-	
-	DB(mvOsPrintf("Dram: minCasCalc support = %x (after SysCC calc)\n",
-											pBankInfo->suportedCasLatencies ));
-
-	count = 1;
-	DB(mvOsPrintf("Dram2: minCasCalc supported mask = %x busClkPs = %x \n",
-								pBankInfo2->suportedCasLatencies,busClkPs ));
-	for(j = 7; j > 0; j--)
-	{
-		if((pBankInfo2->suportedCasLatencies >> j) & BIT0 )
-		{
-			/* Reset the bits for CL incompatible for the sysClk */
-			switch (count)
-			{
-				case 1: 
-					if (pBankInfo2->minCycleTimeAtMaxCasLatPs > busClkPs) 
-						pBankInfo2->suportedCasLatencies &= ~(BIT0 << j);
-					count++;
-					break;
-				case 2: 
-					if (pBankInfo2->minCycleTimeAtMaxCasLatMinus1Ps > busClkPs)
-						pBankInfo2->suportedCasLatencies &= ~(BIT0 << j);
-					count++;
-					break;
-				case 3: 
-					if (pBankInfo2->minCycleTimeAtMaxCasLatMinus2Ps > busClkPs)
-						pBankInfo2->suportedCasLatencies &= ~(BIT0 << j);
-					count++;
-					break;
-				default: 
-					pBankInfo2->suportedCasLatencies &= ~(BIT0 << j);
-					break;
-			}
-		}
-	}
-	
-	DB(mvOsPrintf("Dram2: minCasCalc support = %x (after SysCC calc)\n",
-									pBankInfo2->suportedCasLatencies ));
-
-	startBit = 3;   /* DDR2 support CL start with CL3 (bit 3) */
-	stopBit  = 6;   /* DDR2 support CL stops with CL6 (bit 6) */
-
-	for(j = startBit; j <= stopBit ; j++)
-	{
-		if((pBankInfo->suportedCasLatencies >> j) & BIT0 )
-		{
-			DB(mvOsPrintf("Dram: minCasCalc choose CAS %x \n",(BIT0 << j)));
-			minCas0 = (BIT0 << j);
-			break;
-		}
-	}
-
-	for(j = startBit; j <= stopBit ; j++)
-	{
-		if((pBankInfo2->suportedCasLatencies >> j) & BIT0 )
-		{
-			DB(mvOsPrintf("Dram: minCasCalc choose CAS %x \n",(BIT0 << j)));
-			minCas2 = (BIT0 << j);
-			break;
-		}
-	}
-	
-	if (minCas2 > minCas0)
-		return minCas2;
-	else
-		return minCas0;
-	
-	return 0; 
-}
-
-/*******************************************************************************
-* sdramConfigRegCalc - Calculate sdram config register
-*
-* DESCRIPTION: Calculate sdram config register optimized value based
-*			on the bank info parameters.
-*
-* INPUT:
-*	busClk    - the DRAM bus Clock.
-*	pBankInfo - sdram bank parameters
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       sdram config reg value.
-*
-*******************************************************************************/
-static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO *pBankInfo2, MV_U32 busClk)
-{
-	MV_U32 sdramConfig = 0;
-	MV_U32 refreshPeriod;
-	
-	busClk /= 1000000; /* we work with busClk in MHz */
-	
-	sdramConfig = MV_REG_READ(SDRAM_CONFIG_REG);
-	
-	/* figure out the memory refresh internal */
-	switch (pBankInfo->refreshInterval & 0xf)
-	{
-		case 0x0: /* refresh period is 15.625 usec */
-				refreshPeriod = 15625;
-				break;
-		case 0x1: /* refresh period is 3.9 usec  	*/
-				refreshPeriod = 3900;
-				break;
-		case 0x2: /* refresh period is 7.8 usec 	*/
-				refreshPeriod = 7800;
-				break;
-		case 0x3: /* refresh period is 31.3 usec	*/
-				refreshPeriod = 31300;
-				break;
-		case 0x4: /* refresh period is 62.5 usec	*/
-				refreshPeriod = 62500;
-				break;
-		case 0x5: /* refresh period is 125 usec 	*/
-				refreshPeriod = 125000;
-				break;
-		default:  /* refresh period undefined 					*/
-				mvOsPrintf("Dram: ERR. DRAM refresh period is unknown!\n");
-				return -1;
-    }
-	
-	/* Now the refreshPeriod is in register format value */
-	refreshPeriod = (busClk * refreshPeriod) / 1000;
-	
-	DB(mvOsPrintf("Dram: sdramConfigRegCalc calculated refresh interval %0x\n", 
-				  refreshPeriod));
-
-	/* make sure the refresh value is only 14 bits */
-	if(refreshPeriod > SDRAM_REFRESH_MAX)
-	{
-		refreshPeriod = SDRAM_REFRESH_MAX;
-		DB(mvOsPrintf("Dram: sdramConfigRegCalc adjusted refresh interval %0x\n", 
-					  refreshPeriod));
-	}
-	
-	/* Clear the refresh field */
-	sdramConfig &= ~SDRAM_REFRESH_MASK;
-	
-	/* Set new value to refresh field */
-	sdramConfig |= (refreshPeriod & SDRAM_REFRESH_MASK);
-	
-	/*  registered DRAM ? */
-	if ( pBankInfo->registeredAddrAndControlInputs )
-	{
-		/* it's registered DRAM, so set the reg. DRAM bit */
-		sdramConfig |= SDRAM_REGISTERED;
-		DB(mvOsPrintf("DRAM Attribute: Registered address and control inputs.\n");)
-	}
-
-	/* ECC and IERR support */
-	sdramConfig &= ~SDRAM_ECC_MASK;    /* Clear ECC field */
-	sdramConfig &= ~SDRAM_IERR_MASK;    /* Clear IErr field */
-
-	if ( pBankInfo->errorCheckType ) 
-	{
-		sdramConfig |= SDRAM_ECC_EN;
-		sdramConfig |= SDRAM_IERR_REPORTE; 
-                DB(mvOsPrintf("Dram: mvDramIfDetect Enabling ECC\n"));
-	}
-	else
-	{
-                sdramConfig |= SDRAM_ECC_DIS;
-		sdramConfig |= SDRAM_IERR_IGNORE; 
-                DB(mvOsPrintf("Dram: mvDramIfDetect Disabling ECC!\n"));
-	}
-	/* Set static default settings */
-	sdramConfig |= SDRAM_CONFIG_DV;
-	
-	DB(mvOsPrintf("Dram: sdramConfigRegCalc set sdramConfig to 0x%x\n",
-				  sdramConfig));
-	
- 	return sdramConfig;  
-}
-
-/*******************************************************************************
-* sdramModeRegCalc - Calculate sdram mode register
-*
-* DESCRIPTION: Calculate sdram mode register optimized value based
-*			on the bank info parameters and the minCas.
-*
-* INPUT:
-*	minCas	  - minimum CAS supported. 
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       sdram mode reg value.
-*
-*******************************************************************************/
-static MV_U32 sdramModeRegCalc(MV_U32 minCas)
-{
-	MV_U32 sdramMode;
-		
-	sdramMode = MV_REG_READ(SDRAM_MODE_REG);
-	
-	/* Clear CAS Latency field */
-	sdramMode &= ~SDRAM_CL_MASK;
-	
-	DB(mvOsPrintf("DRAM CAS Latency ");)
-	
-		switch (minCas)
-		{
-			case DDR2_CL_3: 
-				sdramMode |= SDRAM_DDR2_CL_3;
-				DB(mvOsPrintf("3.\n");)
-				break;
-			case DDR2_CL_4: 
-				sdramMode |= SDRAM_DDR2_CL_4;
-				DB(mvOsPrintf("4.\n");)
-				break;
-			case DDR2_CL_5: 
-				sdramMode |= SDRAM_DDR2_CL_5;
-				DB(mvOsPrintf("5.\n");)
-				break;
-			case DDR2_CL_6: 
-				sdramMode |= SDRAM_DDR2_CL_6;
-				DB(mvOsPrintf("6.\n");)
-				break;
-			default:
-				mvOsOutput("\nsdramModeRegCalc ERROR: Max. CL out of range\n");
-				return -1;
-        }
-
-	DB(mvOsPrintf("\nsdramModeRegCalc register 0x%x\n", sdramMode ));
-
-	return sdramMode;
-}
-/*******************************************************************************
-* sdramExtModeRegCalc - Calculate sdram Extended mode register
-*
-* DESCRIPTION: 
-*		Return sdram Extended mode register value based
-*		on the bank info parameters and bank presence.
-*
-* INPUT:
-*	pBankInfo - sdram bank parameters
-*	busClk - DRAM frequency
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       sdram Extended mode reg value.
-*
-*******************************************************************************/
-static MV_U32 sdramExtModeRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
-{
-	MV_U32 populateBanks = 0;
-	int bankNum;
-
-		/* Represent the populate banks in binary form */
-		for(bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
-		{
-			if (0 != pBankInfo[bankNum].size)
-			{
-				populateBanks |= (1 << bankNum);
-			}
-		}
-	
-		switch(populateBanks)
-		{
-			case(BANK_PRESENT_CS0):
-			case(BANK_PRESENT_CS0_CS1):
-				return DDR_SDRAM_EXT_MODE_CS0_CS1_DV;
-		
-			case(BANK_PRESENT_CS0_CS2):
-			case(BANK_PRESENT_CS0_CS1_CS2):
-			case(BANK_PRESENT_CS0_CS2_CS3):
-			case(BANK_PRESENT_CS0_CS2_CS3_CS4):
-				if (busClk >= MV_BOARD_SYSCLK_267MHZ)
-				    return DDR_SDRAM_EXT_MODE_FAST_CS0_CS1_CS2_CS3_DV;
-				else
-				    return DDR_SDRAM_EXT_MODE_CS0_CS1_CS2_CS3_DV;
-		
-			default:
-				mvOsOutput("sdramExtModeRegCalc: Invalid DRAM bank presence\n");
-				return -1;
-		} 
-	return 0;
-}
-
-/*******************************************************************************
-* dunitCtrlLowRegCalc - Calculate sdram dunit control low register
-*
-* DESCRIPTION: Calculate sdram dunit control low register optimized value based
-*			on the bank info parameters and the minCas.
-*
-* INPUT:
-*	pBankInfo - sdram bank parameters
-*	minCas	  - minimum CAS supported. 
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       sdram dunit control low reg value.
-*
-*******************************************************************************/
-static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, MV_U32  busClk, MV_STATUS TTMode)
-{
-	MV_U32 dunitCtrlLow, cl;
-	MV_U32 sbOutR[4]={3,5,7,9} ;
-	MV_U32 sbOutU[4]={1,3,5,7} ;
-	
-    	dunitCtrlLow = MV_REG_READ(SDRAM_DUNIT_CTRL_REG);
-
-        DB(mvOsPrintf("Dram: dunitCtrlLowRegCalc\n"));
-
-	/* Clear StBurstOutDel field */
-	dunitCtrlLow &= ~SDRAM_SB_OUT_MASK;
-	
-	/* Clear StBurstInDel field */
-	dunitCtrlLow &= ~SDRAM_SB_IN_MASK;
-
-	/* Clear CtrlPos field */
-	dunitCtrlLow &= ~SDRAM_CTRL_POS_MASK;
-
-	/* Clear 2T field */
-	dunitCtrlLow &= ~SDRAM_2T_MASK;
-	if (TTMode == MV_TRUE)
-	{
-		dunitCtrlLow |= SDRAM_2T_MODE;
-	}
-	
-	/* For proper sample of read data set the Dunit Control register's      */
-	/* stBurstInDel bits [27:24]                                            */
-	/*		200MHz - 267MHz None reg  = CL + 1			*/
-	/*		200MHz - 267MHz reg	  = CL + 2			*/
-	/*		> 267MHz None reg  = CL + 2			*/
-	/*		> 267MHz reg	  = CL + 3			*/
-	
-	/* For proper sample of read data set the Dunit Control register's      */
-	/* stBurstOutDel bits [23:20]                                           */
-			/********-********-********-********-
-			*  CL=3  |  CL=4  |  CL=5  |  CL=6  |
-			*********-********-********-********-
-	Not Reg.	*  0001  |  0011  |  0101  |  0111  |
-			*********-********-********-********-
-	Registered	*  0011  |  0101  |  0111  |  1001  |
-			*********-********-********-********/
-    
-		/* Set Dunit Control low default value */
-		dunitCtrlLow |= SDRAM_DUNIT_CTRL_LOW_DDR2_DV; 
-
-		switch (minCas)
-		{
-			case DDR2_CL_3: cl = 3; break;
-			case DDR2_CL_4: cl = 4; break;
-			case DDR2_CL_5: cl = 5; break;
-			case DDR2_CL_6: cl = 6; break;
-			default:
-				mvOsOutput("Dram: dunitCtrlLowRegCalc Max. CL out of range %d\n", minCas);
-				return -1;
-		}
-
-		/* registerd DDR SDRAM? */
-		if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
-		{
-			dunitCtrlLow |= (sbOutR[cl-3]) << SDRAM_SB_OUT_DEL_OFFS;
-		}
-		else
-		{
-			dunitCtrlLow |= (sbOutU[cl-3]) << SDRAM_SB_OUT_DEL_OFFS;
-		}
-
-		DB(mvOsPrintf("\n\ndunitCtrlLowRegCalc: CL = %d, frequencies=%d\n", cl, busClk));
-
-		if (busClk <= MV_BOARD_SYSCLK_267MHZ)
-		{
-			if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
-				cl = cl + 2;
-			else
-				cl = cl + 1;
-		}
-		else
-		{
-			if (pBankInfo->registeredAddrAndControlInputs == MV_TRUE)
-				cl = cl + 3;
-			else
-				cl = cl + 2;
-		}
-		
-        DB(mvOsPrintf("dunitCtrlLowRegCalc: SDRAM_SB_IN_DEL_OFFS = %d \n", cl));
-		dunitCtrlLow |= cl << SDRAM_SB_IN_DEL_OFFS;
-
-	DB(mvOsPrintf("Dram: Reg dunit control low = %x\n", dunitCtrlLow ));
-
-	return dunitCtrlLow;
-}  
-
-/*******************************************************************************
-* dunitCtrlHighRegCalc - Calculate sdram dunit control high register
-*
-* DESCRIPTION: Calculate sdram dunit control high register optimized value based
-*			on the bus clock.
-*
-* INPUT:
-*	busClk	  - DRAM frequency. 
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       sdram dunit control high reg value.
-*
-*******************************************************************************/
-static MV_U32 dunitCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32  busClk)
-{
-	MV_U32 dunitCtrlHigh;
-	dunitCtrlHigh = MV_REG_READ(SDRAM_DUNIT_CTRL_HI_REG);
-	if(busClk > MV_BOARD_SYSCLK_300MHZ) 
-		dunitCtrlHigh |= SDRAM__P2D_EN;
-	else
-		dunitCtrlHigh &= ~SDRAM__P2D_EN;
-
-	if(busClk > MV_BOARD_SYSCLK_267MHZ) 
-	    dunitCtrlHigh |= (SDRAM__WR_MESH_DELAY_EN | SDRAM__PUP_ZERO_SKEW_EN | SDRAM__ADD_HALF_FCC_EN);
-
-	/* If ECC support we turn on D2P sample */
-	dunitCtrlHigh &= ~SDRAM__D2P_EN;    /* Clear D2P bit */
-	if (( pBankInfo->errorCheckType ) && (busClk > MV_BOARD_SYSCLK_267MHZ))
-		dunitCtrlHigh |= SDRAM__D2P_EN;
-
-	return dunitCtrlHigh;
-}
-
-/*******************************************************************************
-* sdramAddrCtrlRegCalc - Calculate sdram address control register
-*
-* DESCRIPTION: Calculate sdram address control register optimized value based
-*			on the bank info parameters and the minCas.
-*
-* INPUT:
-*	pBankInfo - sdram bank parameters
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       sdram address control reg value.
-*
-*******************************************************************************/
-static MV_U32 sdramAddrCtrlRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_DRAM_BANK_INFO *pBankInfoDIMM1)
-{
-	MV_U32 addrCtrl = 0;
-	
-	if (pBankInfoDIMM1->size)
-	{
-		switch (pBankInfoDIMM1->sdramWidth)
-		{
-			case 4:  /* memory is x4 */
-				mvOsOutput("sdramAddrCtrlRegCalc: Error - x4 not supported!\n");
-				return -1;
-				break;
-			case 8:  /* memory is x8 */
-				addrCtrl |= SDRAM_ADDRSEL_X8(2) | SDRAM_ADDRSEL_X8(3);
-				DB(mvOsPrintf("sdramAddrCtrlRegCalc: sdramAddrCtrlRegCalc SDRAM device DIMM2 width x8\n"));
-				break;
-			case 16:
-				addrCtrl |= SDRAM_ADDRSEL_X16(2) | SDRAM_ADDRSEL_X16(3);
-				DB(mvOsPrintf("sdramAddrCtrlRegCalc: sdramAddrCtrlRegCalc SDRAM device DIMM2 width x16\n"));
-				break;
-			default: /* memory width unsupported */
-				mvOsOutput("sdramAddrCtrlRegCalc: ERR. DRAM chip width is unknown!\n");
-				return -1;
-		}
-	}
-
-	switch (pBankInfo->sdramWidth)
-	{
-		case 4:  /* memory is x4 */
-			mvOsOutput("sdramAddrCtrlRegCalc: Error - x4 not supported!\n");
-			return -1;
-			break;
-		case 8:  /* memory is x8 */
-			addrCtrl |= SDRAM_ADDRSEL_X8(0) | SDRAM_ADDRSEL_X8(1);
-			DB(mvOsPrintf("sdramAddrCtrlRegCalc: sdramAddrCtrlRegCalc SDRAM device width x8\n"));
-			break;
-		case 16:
-			addrCtrl |= SDRAM_ADDRSEL_X16(0) | SDRAM_ADDRSEL_X16(1);
-			DB(mvOsPrintf("sdramAddrCtrlRegCalc: sdramAddrCtrlRegCalc SDRAM device width x16\n"));
-			break;
-		default: /* memory width unsupported */
-			mvOsOutput("sdramAddrCtrlRegCalc: ERR. DRAM chip width is unknown!\n");
-			return -1;
-	}
-
-	/* Note that density is in MB units */
-	switch (pBankInfo->deviceDensity) 
-	{
-		case 256:                 /* 256 Mbit */
-			DB(mvOsPrintf("DRAM Device Density 256Mbit\n"));
-			addrCtrl |= SDRAM_DSIZE_256Mb(0) | SDRAM_DSIZE_256Mb(1);
-			break;
-		case 512:                /* 512 Mbit */
-			DB(mvOsPrintf("DRAM Device Density 512Mbit\n"));
-			addrCtrl |= SDRAM_DSIZE_512Mb(0) | SDRAM_DSIZE_512Mb(1);
-			break;
-		case 1024:                /* 1 Gbit */
-			DB(mvOsPrintf("DRAM Device Density 1Gbit\n"));
-			addrCtrl |= SDRAM_DSIZE_1Gb(0) | SDRAM_DSIZE_1Gb(1);
-			break;
-		case 2048:                /* 2 Gbit */
-			DB(mvOsPrintf("DRAM Device Density 2Gbit\n"));
-			addrCtrl |= SDRAM_DSIZE_2Gb(0) | SDRAM_DSIZE_2Gb(1);
-			break;
-		default:
-			mvOsOutput("Dram: sdramAddrCtrl unsupported RAM-Device size %d\n",
-                       pBankInfo->deviceDensity);
-			return -1;
-        }
-
-	if (pBankInfoDIMM1->size)
-	{
-		switch (pBankInfoDIMM1->deviceDensity) 
-		{
-			case 256:                 /* 256 Mbit */
-				DB(mvOsPrintf("DIMM2: DRAM Device Density 256Mbit\n"));
-				addrCtrl |= SDRAM_DSIZE_256Mb(2) | SDRAM_DSIZE_256Mb(3);
-				break;
-			case 512:                /* 512 Mbit */
-				DB(mvOsPrintf("DIMM2: DRAM Device Density 512Mbit\n"));
-				addrCtrl |= SDRAM_DSIZE_512Mb(2) | SDRAM_DSIZE_512Mb(3);
-				break;
-			case 1024:                /* 1 Gbit */
-				DB(mvOsPrintf("DIMM2: DRAM Device Density 1Gbit\n"));
-				addrCtrl |= SDRAM_DSIZE_1Gb(2) | SDRAM_DSIZE_1Gb(3);
-				break;
-			case 2048:                /* 2 Gbit */
-				DB(mvOsPrintf("DIMM2: DRAM Device Density 2Gbit\n"));
-				addrCtrl |= SDRAM_DSIZE_2Gb(2) | SDRAM_DSIZE_2Gb(3);
-				break;
-			default:
-				mvOsOutput("DIMM2: Dram: sdramAddrCtrl unsupported RAM-Device size %d\n",
-						   pBankInfoDIMM1->deviceDensity);
-				return -1;
-		}
-	}
-	/* SDRAM address control */
-	DB(mvOsPrintf("Dram: setting sdram address control with: %x \n", addrCtrl));
-
-	return addrCtrl;
-}
-
-/*******************************************************************************
-* sdramTimeCtrlLowRegCalc - Calculate sdram timing control low register
-*
-* DESCRIPTION: 
-*       This function calculates sdram timing control low register 
-*       optimized value based on the bank info parameters and the minCas.
-*
-* INPUT:
-*	    pBankInfo - sdram bank parameters
-*	minCas	  - minimum CAS supported. 
-*       busClk    - Bus clock
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       sdram timing control low reg value.
-*
-*******************************************************************************/
-static MV_U32 sdramTimeCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, MV_U32 busClk)
-{
-    MV_U32 tRp  = 0;
-    MV_U32 tRrd = 0;
-    MV_U32 tRcd = 0;
-    MV_U32 tRas = 0;
-    MV_U32 tWr  = 0;
-    MV_U32 tWtr = 0;
-    MV_U32 tRtp = 0;
-    MV_U32 timeCtrlLow = 0;
-	
-    MV_U32 bankNum;
-    
-    busClk = busClk / 1000000;    /* In MHz */
-
-    /* Scan all DRAM banks to find maximum timing values */
-    for (bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
-    {
-        tRp  = MV_MAX(tRp,  pBankInfo[bankNum].minRowPrechargeTime);
-        tRrd = MV_MAX(tRrd, pBankInfo[bankNum].minRowActiveToRowActive);
-        tRcd = MV_MAX(tRcd, pBankInfo[bankNum].minRasToCasDelay);
-        tRas = MV_MAX(tRas, pBankInfo[bankNum].minRasPulseWidth);
-    }
-
-    /* Extract timing (in ns) from SPD value. We ignore the tenth ns part.  */
-    /* by shifting the data two bits right.                                 */
-    tRp  = tRp  >> 2;    /* For example 0x50 -> 20ns                        */
-    tRrd = tRrd >> 2;
-    tRcd = tRcd >> 2;
-	
-    /* Extract clock cycles from time parameter. We need to round up        */
-    tRp  = ((busClk * tRp)  / 1000) + (((busClk * tRp)  % 1000) ? 1 : 0);
-    DB(mvOsPrintf("Dram  Timing Low: tRp = %d ", tRp));
-    tRrd = ((busClk * tRrd) / 1000) + (((busClk * tRrd) % 1000) ? 1 : 0);
-	/* JEDEC min reqeirments tRrd = 2 */
-	if (tRrd < 2)
-		tRrd = 2;
-    DB(mvOsPrintf("tRrd = %d ", tRrd));
-    tRcd = ((busClk * tRcd) / 1000) + (((busClk * tRcd) % 1000) ? 1 : 0);
-    DB(mvOsPrintf("tRcd = %d ", tRcd));
-    tRas = ((busClk * tRas) / 1000) + (((busClk * tRas) % 1000) ? 1 : 0);
-    DB(mvOsPrintf("tRas = %d ", tRas));
-
-    /* tWr and tWtr is different for DDR1 and DDR2. tRtp is only for DDR2   */
-	/* Scan all DRAM banks to find maximum timing values */
-	for (bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
-	{
-	    tWr  = MV_MAX(tWr,  pBankInfo[bankNum].minWriteRecoveryTime);
-	    tWtr = MV_MAX(tWtr, pBankInfo[bankNum].minWriteToReadCmdDelay);
-	    tRtp = MV_MAX(tRtp, pBankInfo[bankNum].minReadToPrechCmdDelay);
-	}
-	
-	/* Extract timing (in ns) from SPD value. We ignore the tenth ns    */
-	/* part by shifting the data two bits right.                        */
-	tWr  = tWr  >> 2;    /* For example 0x50 -> 20ns                    */
-	tWtr = tWtr >> 2;
-	tRtp = tRtp >> 2;
-	/* Extract clock cycles from time parameter. We need to round up    */
-	tWr  = ((busClk * tWr)  / 1000) + (((busClk * tWr)  % 1000) ? 1 : 0);
-	DB(mvOsPrintf("tWr = %d ", tWr));
-	tWtr = ((busClk * tWtr) / 1000) + (((busClk * tWtr) % 1000) ? 1 : 0);
-	/* JEDEC min reqeirments tWtr = 2 */
-	if (tWtr < 2)
-		tWtr = 2;
-	DB(mvOsPrintf("tWtr = %d ", tWtr));
-	tRtp = ((busClk * tRtp) / 1000) + (((busClk * tRtp) % 1000) ? 1 : 0);
-	/* JEDEC min reqeirments tRtp = 2 */
-	if (tRtp < 2)
-	tRtp = 2;
-	DB(mvOsPrintf("tRtp = %d ", tRtp));
-
-	/* Note: value of 0 in register means one cycle, 1 means two and so on  */
-	timeCtrlLow = (((tRp  - 1) << SDRAM_TRP_OFFS) |
-		    ((tRrd - 1) << SDRAM_TRRD_OFFS) |
-		    ((tRcd - 1) << SDRAM_TRCD_OFFS) |
-		    (((tRas - 1) << SDRAM_TRAS_OFFS) & SDRAM_TRAS_MASK)|
-		    ((tWr  - 1) << SDRAM_TWR_OFFS)  |
-		    ((tWtr - 1) << SDRAM_TWTR_OFFS)	|
-		    ((tRtp - 1) << SDRAM_TRTP_OFFS));
-	
-	/* Check extended tRas bit */
-	if ((tRas - 1) & BIT4)
-	    timeCtrlLow |= (1 << SDRAM_EXT_TRAS_OFFS);
-
-	return timeCtrlLow;
-}
-
-/*******************************************************************************
-* sdramTimeCtrlHighRegCalc - Calculate sdram timing control high register
-*
-* DESCRIPTION: 
-*       This function calculates sdram timing control high register 
-*       optimized value based on the bank info parameters and the bus clock.
-*
-* INPUT:
-*	    pBankInfo - sdram bank parameters
-*       busClk    - Bus clock
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       sdram timing control high reg value.
-*
-*******************************************************************************/
-static MV_U32 sdramTimeCtrlHighRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 busClk)
-{
-	MV_U32 tRfc;
-	MV_U32 timingHigh;
-	MV_U32 timeNs = 0;
-	MV_U32 bankNum;
-	
-	busClk = busClk / 1000000;    /* In MHz */
-
-	/* Set DDR timing high register static configuration bits */
-	timingHigh = MV_REG_READ(SDRAM_TIMING_CTRL_HIGH_REG);
-	
-	/* Set DDR timing high register default value */
-	timingHigh |= SDRAM_TIMING_CTRL_HIGH_REG_DV;  
-	
-	/* Clear tRfc field */
-	timingHigh &= ~SDRAM_TRFC_MASK;
-
-	/* Scan all DRAM banks to find maximum timing values */
-	for (bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
-	{
-		timeNs = MV_MAX(timeNs,  pBankInfo[bankNum].minRefreshToActiveCmd);
-		DB(mvOsPrintf("Dram:  Timing High: minRefreshToActiveCmd = %d\n", 
-				pBankInfo[bankNum].minRefreshToActiveCmd));
-	}
-	if(busClk >= 333 && mvCtrlModelGet() == MV_78XX0_A1_REV)
-    {
-        timingHigh |= 0x1 << SDRAM_TR2W_W2R_OFFS;
-    }
-
-	tRfc = ((busClk * timeNs)  / 1000) + (((busClk * timeNs)  % 1000) ? 1 : 0);
-	/* Note: value of 0 in register means one cycle, 1 means two and so on  */
-	DB(mvOsPrintf("Dram:  Timing High: tRfc = %d\n", tRfc));
-	timingHigh |= (((tRfc - 1) & SDRAM_TRFC_MASK) << SDRAM_TRFC_OFFS);
-	DB(mvOsPrintf("Dram:  Timing High: tRfc = %d\n", tRfc));
-	
-	/* SDRAM timing high */
-	DB(mvOsPrintf("Dram: setting timing high with: %x \n", timingHigh));
-
-	return timingHigh;
-}
-/*******************************************************************************
-* sdramDDr2OdtConfig - Set DRAM DDR2 On Die Termination registers.
-*
-* DESCRIPTION: 
-*       This function config DDR2 On Die Termination (ODT) registers.
-*	
-* INPUT:
-*		pBankInfo - bank info parameters.
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       None
-*******************************************************************************/
-static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
-{
-	MV_U32 populateBanks = 0;
-	MV_U32 odtCtrlLow, odtCtrlHigh, dunitOdtCtrl;
-	int bankNum;
-	
-	/* Represent the populate banks in binary form */
-	for(bankNum = 0; bankNum < MV_DRAM_MAX_CS; bankNum++)
-	{
-		if (0 != pBankInfo[bankNum].size)
-		{
-				populateBanks |= (1 << bankNum);
-			}
-		}
-	
-	switch(populateBanks)
-	{
-		case(BANK_PRESENT_CS0):
-		case(BANK_PRESENT_CS0_CS1):
-			odtCtrlLow   = DDR2_ODT_CTRL_LOW_CS0_CS1_DV;
-			odtCtrlHigh  = DDR2_ODT_CTRL_HIGH_CS0_CS1_DV;
-			dunitOdtCtrl = DDR2_DUNIT_ODT_CTRL_CS0_CS1_DV;
-			break;
-		case(BANK_PRESENT_CS0_CS2):
-		case(BANK_PRESENT_CS0_CS1_CS2):
-		case(BANK_PRESENT_CS0_CS2_CS3):
-		case(BANK_PRESENT_CS0_CS2_CS3_CS4):
-			odtCtrlLow   = DDR2_ODT_CTRL_LOW_CS0_CS1_CS2_CS3_DV;
-			odtCtrlHigh  = DDR2_ODT_CTRL_HIGH_CS0_CS1_CS2_CS3_DV;
-			dunitOdtCtrl = DDR2_DUNIT_ODT_CTRL_CS0_CS1_CS2_CS3_DV;
-			break;
-		default:
-			DB(mvOsPrintf("sdramDDr2OdtConfig: Invalid DRAM bank presence\n"));
-			return;
-	}
- 	/* DDR2 SDRAM ODT ctrl low  */
-	DB(mvOsPrintf("Dram: DDR2 setting ODT ctrl low with: %x \n", odtCtrlLow));
-	MV_REG_WRITE(DRAM_BUF_REG7, odtCtrlLow);
-
- 	/* DDR2 SDRAM ODT ctrl high  */
-	DB(mvOsPrintf("Dram: DDR2 setting ODT ctrl high with: %x \n", odtCtrlHigh));
-	MV_REG_WRITE(DRAM_BUF_REG8, odtCtrlHigh);
-
-	/* DDR2 DUNIT ODT ctrl  */
-	if ( ((mvCtrlModelGet() == MV_78XX0_DEV_ID) && (mvCtrlRevGet() == MV_78XX0_Y0_REV)) ||
-		(mvCtrlModelGet() == MV_76100_DEV_ID) ||
-		(mvCtrlModelGet() == MV_78100_DEV_ID) ||
-		(mvCtrlModelGet() == MV_78200_DEV_ID) )
-		dunitOdtCtrl &= ~(BIT9|BIT8); /* Clear ODT always on */
-
-	DB(mvOsPrintf("DUNIT: DDR2 setting ODT ctrl with: %x \n", dunitOdtCtrl));
-	MV_REG_WRITE(DRAM_BUF_REG9, dunitOdtCtrl);
-	return;
-}
-/*******************************************************************************
-* sdramDdr2TimeLoRegCalc - Set DDR2 DRAM Timing Low registers.
-*
-* DESCRIPTION: 
-*       This function config DDR2 DRAM Timing low registers.
-*	
-* INPUT:
-*	minCas	  - minimum CAS supported. 
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       DDR2 sdram timing low reg value.
-*******************************************************************************/
-static MV_U32 sdramDdr2TimeLoRegCalc(MV_U32 minCas)
-{
-	MV_U8 cl = -1;
-	MV_U32 ddr2TimeLoReg;
-
-	/* read and clear the feilds we are going to set */
-	ddr2TimeLoReg = MV_REG_READ(SDRAM_DDR2_TIMING_LO_REG);
-	ddr2TimeLoReg &= ~(SD2TLR_TODT_ON_RD_MASK	| 
-			   SD2TLR_TODT_OFF_RD_MASK	| 
-			   SD2TLR_TODT_ON_CTRL_RD_MASK	|
-			   SD2TLR_TODT_OFF_CTRL_RD_MASK);
-
-	if( minCas == DDR2_CL_3 )
-	{
-		cl = 3;
-	}
-	else if( minCas == DDR2_CL_4 )
-	{
-		cl = 4;
-	}
-	else if( minCas == DDR2_CL_5 )
-	{
-		cl = 5;
-	}
-	else if( minCas == DDR2_CL_6 )
-	{
-		cl = 6;
-	}
-	else
-	{
-		DB(mvOsPrintf("sdramDdr2TimeLoRegCalc: CAS latency %d unsupported. using CAS latency 4\n",
-				minCas));
-		cl = 4;
-	}
-
-	ddr2TimeLoReg |= ((cl-3) << SD2TLR_TODT_ON_RD_OFFS);
-	ddr2TimeLoReg |= ( cl << SD2TLR_TODT_OFF_RD_OFFS);
-	ddr2TimeLoReg |= ( cl << SD2TLR_TODT_ON_CTRL_RD_OFFS);
-	ddr2TimeLoReg |= ((cl+3) << SD2TLR_TODT_OFF_CTRL_RD_OFFS);
-
-	/* DDR2 SDRAM timing low */
-	DB(mvOsPrintf("Dram: DDR2 setting timing low with: %x \n", ddr2TimeLoReg));
-
-	return ddr2TimeLoReg;
-}
-
-/*******************************************************************************
-* sdramDdr2TimeHiRegCalc - Set DDR2 DRAM Timing High registers.
-*
-* DESCRIPTION: 
-*       This function config DDR2 DRAM Timing high registers.
-*	
-* INPUT:
-*	minCas	  - minimum CAS supported. 
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       DDR2 sdram timing high reg value.
-*******************************************************************************/
-static MV_U32 sdramDdr2TimeHiRegCalc(MV_U32 minCas)
-{
-	MV_U8 cl = -1;
-	MV_U32 ddr2TimeHiReg;
-
-	/* read and clear the feilds we are going to set */
-	ddr2TimeHiReg = MV_REG_READ(SDRAM_DDR2_TIMING_HI_REG);
-	ddr2TimeHiReg &= ~(SD2THR_TODT_ON_WR_MASK	|
-			   SD2THR_TODT_OFF_WR_MASK	|
-			   SD2THR_TODT_ON_CTRL_WR_MASK	|
-			   SD2THR_TODT_OFF_CTRL_WR_MASK);
-
-	if( minCas == DDR2_CL_3 )
-	{
-		cl = 3;
-	}
-	else if( minCas == DDR2_CL_4 )
-	{
-		cl = 4;
-	}
-	else if( minCas == DDR2_CL_5 )
-	{
-		cl = 5;
-	}
-	else if( minCas == DDR2_CL_6 )
-	{
-		cl = 6;
-	}
-	else
-	{
-		mvOsOutput("sdramDdr2TimeHiRegCalc: CAS latency %d unsupported. using CAS latency 4\n", 
-				minCas);
-		cl = 4;
-	}
-
-	ddr2TimeHiReg |= ((cl-3) << SD2THR_TODT_ON_WR_OFFS);
-	ddr2TimeHiReg |= ( cl << SD2THR_TODT_OFF_WR_OFFS);
-	ddr2TimeHiReg |= ( cl << SD2THR_TODT_ON_CTRL_WR_OFFS);
-	ddr2TimeHiReg |= ((cl+3) << SD2THR_TODT_OFF_CTRL_WR_OFFS);
-
-	/* DDR2 SDRAM timin high  */
-	DB(mvOsPrintf("Dram: DDR2 setting timing high with: %x \n", ddr2TimeHiReg));
-
-	return ddr2TimeHiReg;
-}
-#endif
-
-/*******************************************************************************
-* mvDramIfCalGet - Get CAS Latency
-*
-* DESCRIPTION: 
-*       This function get the CAS Latency.
-*
-* INPUT:
-*       None
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       CAS latency times 10 (to avoid using floating point).
-*
-*******************************************************************************/
-MV_U32 mvDramIfCalGet(void)
-{
-	MV_U32 sdramCasLat, casLatMask;
-	
-    casLatMask = (MV_REG_READ(SDRAM_MODE_REG) & SDRAM_CL_MASK);
-
-    switch (casLatMask)
-    {
-        case SDRAM_DDR2_CL_3: 
-            sdramCasLat = 30;
-            break;
-        case SDRAM_DDR2_CL_4: 
-            sdramCasLat = 40;
-            break;
-        case SDRAM_DDR2_CL_5: 
-            sdramCasLat = 50;
-            break;
-        case SDRAM_DDR2_CL_6: 
-            sdramCasLat = 60;
-            break;
-        default:
-            mvOsOutput("mvDramIfCalGet: Err, unknown DDR2 CAL\n");
-            return -1;
-    }                                  
-    
-    return sdramCasLat;
-}
-
-
-/*******************************************************************************
-* mvDramIfSelfRefreshSet - Put the dram in self refresh mode - 
-*
-* DESCRIPTION: 
-*               add support in power management.
-*                          
-*
-* INPUT:
-*       None
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       None
-*
-*******************************************************************************/
-
-MV_VOID mvDramIfSelfRefreshSet()
-{
-    MV_U32 operReg;
-
-      operReg =  MV_REG_READ(SDRAM_OPERATION_REG);
-      MV_REG_WRITE(SDRAM_OPERATION_REG ,operReg |SDRAM_CMD_SLF_RFRSH);
-      /* Read until register is reset to 0 */
-      while(MV_REG_READ(SDRAM_OPERATION_REG));
-}
-/*******************************************************************************
-* mvDramIfDimGetSPDversion - return DIMM SPD version.
-*
-* DESCRIPTION:
-*		This function prints the DRAM controller information.
-*
-* INPUT:
-*		None.
-*
-* OUTPUT:
-*		None.
-*
-* RETURN:
-*		None.
-*
-*******************************************************************************/
-static void mvDramIfDimGetSPDversion(MV_U32 *pMajor, MV_U32 *pMinor, MV_U32 bankNum)
-{
-	MV_DIMM_INFO dimmInfo;
-	if (bankNum >= MV_DRAM_MAX_CS )
-	{
-		DB(mvOsPrintf("Dram: mvDramIfDimGetSPDversion bad params \n")); 
-		return ;
-	}
-	memset(&dimmInfo,0,sizeof(dimmInfo));
-	if ( MV_OK != dimmSpdGet((MV_U32)(bankNum/2), &dimmInfo))
-	{
-		DB(mvOsPrintf("Dram: ERR dimmSpdGet failed to get dimm info \n"));
-		return ;
-	}
-	*pMajor = dimmInfo.spdRawData[DIMM_SPD_VERSION]/10;
-	*pMinor = dimmInfo.spdRawData[DIMM_SPD_VERSION]%10;
-}
-/*******************************************************************************
-* mvDramIfShow - Show DRAM controller information.
-*
-* DESCRIPTION:
-*		This function prints the DRAM controller information.
-*
-* INPUT:
-*		None.
-*
-* OUTPUT:
-*		None.
-*
-* RETURN:
-*		None.
-*
-*******************************************************************************/
-void mvDramIfShow(void)
-{
-    int i, sdramCasLat, sdramCsSize;
-	MV_U32 Major=0, Minor=0;
-    
-    mvOsOutput("DRAM Controller info:\n");
-    
-    mvOsOutput("Total DRAM ");
-    mvSizePrint(mvDramIfSizeGet());
-    mvOsOutput("\n");
-
-	for(i = 0; i < MV_DRAM_MAX_CS; i++)
-	{ 
-        sdramCsSize = mvDramIfBankSizeGet(i);
-        if (sdramCsSize)
-        {
-			if (0 == (i & 1))
-			{
-				mvDramIfDimGetSPDversion(&Major, &Minor,i);
-				mvOsOutput("DIMM %d version %d.%d\n", i/2, Major, Minor);
-			}
-            mvOsOutput("\tDRAM CS[%d] ", i);
-            mvSizePrint(sdramCsSize);
-            mvOsOutput("\n");
-        }
-    }
-    sdramCasLat = mvDramIfCalGet();
-
-    if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_ECC_EN)
-    {
-        mvOsOutput("ECC enabled, ");
-    }
-    else
-    {
-        mvOsOutput("ECC Disabled, ");
-    }
-    
-    if (MV_REG_READ(SDRAM_CONFIG_REG) & SDRAM_REGISTERED)
-    {
-        mvOsOutput("Registered DIMM\n");
-    }
-    else
-    {
-        mvOsOutput("Non registered DIMM\n");
-    }
-
-    mvOsOutput("Configured CAS Latency %d.%d\n", sdramCasLat/10, sdramCasLat%10);
-}
-/*******************************************************************************
-* mvDramIfGetFirstCS - find the  DRAM bank on the lower address
-* 
-*
-* DESCRIPTION:
-*       This function return the fisrt CS on address 0
-*
-* INPUT:
-*		None.
-*
-* OUTPUT:
-*		None.
-*
-* RETURN:
-*       SDRAM_CS0 or SDRAM_CS2
-*
-*******************************************************************************/
-MV_U32 mvDramIfGetFirstCS(void)
-{
-	MV_DRAM_BANK_INFO bankInfo[MV_DRAM_MAX_CS];
-
-	if (DRAM_CS_Order[0] == N_A)
-	{
-		mvDramBankInfoGet(SDRAM_CS0, &bankInfo[SDRAM_CS0]);
-#ifdef MV_INCLUDE_SDRAM_CS2
-		mvDramBankInfoGet(SDRAM_CS2, &bankInfo[SDRAM_CS2]);
-#endif 
-		
-#ifdef MV_INCLUDE_SDRAM_CS2
-		if (bankInfo[SDRAM_CS0].size <  bankInfo[SDRAM_CS2].size)
-		{
-			DRAM_CS_Order[0] = SDRAM_CS2;
-			DRAM_CS_Order[1] = SDRAM_CS3;
-			DRAM_CS_Order[2] = SDRAM_CS0;
-			DRAM_CS_Order[3] = SDRAM_CS1;
-
-			return SDRAM_CS2;
-		}
-#endif
-		DRAM_CS_Order[0] = SDRAM_CS0;
-		DRAM_CS_Order[1] = SDRAM_CS1;
-#ifdef MV_INCLUDE_SDRAM_CS2
-		DRAM_CS_Order[2] = SDRAM_CS2;
-		DRAM_CS_Order[3] = SDRAM_CS3;
-#endif	
-		return SDRAM_CS0;
-	}
-	return DRAM_CS_Order[0];
-}
-/*******************************************************************************
-* mvDramIfGetCSorder - 
-* 
-*
-* DESCRIPTION:
-*       This function return the fisrt CS on address 0
-*
-* INPUT:
-*		CS number.
-*
-* OUTPUT:
-*		CS order.
-*
-* RETURN:
-*       SDRAM_CS0 or SDRAM_CS2
-* 
-* NOTE: mvDramIfGetFirstCS must be caled before this subroutine
-*******************************************************************************/
-MV_U32 mvDramIfGetCSorder(MV_U32 csOrder )
-{
-	return DRAM_CS_Order[csOrder];
-}
-
-/*******************************************************************************
-* sdramIfWinOverlap - Check if an address window overlap an SDRAM address window
-*
-* DESCRIPTION:
-*		This function scan each SDRAM address decode window to test if it 
-*		overlapps the given address windoow 
-*
-* INPUT:
-*       target      - SDRAM target where the function skips checking.
-*       pAddrDecWin - The tested address window for overlapping with 
-*					  SDRAM windows.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if the given address window overlaps any enabled address
-*       decode map, MV_FALSE otherwise.
-*
-*******************************************************************************/
-static MV_BOOL sdramIfWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
-{
-	MV_TARGET	targetNum;
-	MV_DRAM_DEC_WIN 	addrDecWin;
-
-	for(targetNum = SDRAM_CS0; targetNum < MV_DRAM_MAX_CS ; targetNum++)
-	{
-		/* don't check our winNum or illegal targets */
-		if (targetNum == target)
-		{
-			continue;
-		}
-
-		/* Get window parameters 	*/
-		if (MV_OK != mvDramIfWinGet(targetNum, &addrDecWin))
-		{
-			mvOsPrintf("sdramIfWinOverlap: ERR. TargetWinGet failed\n");
-			return MV_ERROR;
-		}
-
-		/* Do not check disabled windows	*/
-		if (MV_FALSE == addrDecWin.enable)
-		{
-			continue;
-		}
-
-		if(MV_TRUE == mvWinOverlapTest(pAddrWin, &addrDecWin.addrWin))
-		{                    
-			mvOsPrintf(
-			"sdramIfWinOverlap: Required target %d overlap winNum %d\n", 
-			target, targetNum);
-			return MV_TRUE;           
-		}
-	}
-
-	return MV_FALSE;
-}
-
-/*******************************************************************************
-* mvDramIfWinSet - Set DRAM interface address decode window
-*
-* DESCRIPTION: 
-*       This function sets DRAM interface address decode window.
-*
-* INPUT:
-*	    target      - System target. Use only SDRAM targets.
-*       pAddrDecWin - SDRAM address window structure.
-*
-* OUTPUT:
-*       None
-*
-* RETURN:
-*       MV_BAD_PARAM if parameters are invalid or window is invalid, MV_OK
-*       otherwise.
-*******************************************************************************/
-MV_STATUS mvDramIfWinSet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
-{
-	MV_U32 baseReg=0,sizeReg=0;
-	MV_U32 sizeToReg=0;
-
-	/* Check if the requested window overlaps with current enabled windows	*/
-	if (MV_TRUE == sdramIfWinOverlap(target, &pAddrDecWin->addrWin))
-	{
-		mvOsPrintf("mvDramIfWinSet: ERR. Target %d overlaps\n", target);
-		return MV_BAD_PARAM;
-	}
-
-	/* check if address is aligned to the size */
-	if(MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size))
-	{
-		mvOsPrintf("mvDramIfWinSet:Error setting DRAM interface window %d."\
-				   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
-                   target, 
-				   pAddrDecWin->addrWin.baseLow,
-				   pAddrDecWin->addrWin.size);
-		return MV_ERROR;
-	}
-
-	/* read base register*/
-	baseReg = MV_REG_READ(SDRAM_BASE_ADDR_REG(0,target));
-
-	/* read size register */
-	sizeReg = MV_REG_READ(SDRAM_SIZE_REG(0,target));
-
-	/* Write to address decode Base Address Register                  */
-	baseReg &= ~SCBAR_BASE_MASK;
-	baseReg |= (pAddrDecWin->addrWin.baseLow & SCBAR_BASE_MASK);
-
-	/* Translate the given window size to register format			*/
-	sizeToReg = (pAddrDecWin->addrWin.size / SCSR_SIZE_ALIGNMENT) - 1;
-
-	/* set size */
-	sizeReg &= ~SCSR_SIZE_MASK;
-	/* Size is located at upper 16 bits */
-	sizeReg |= (sizeToReg << SCSR_SIZE_OFFS);
-
-	/* enable/Disable */
-	if (MV_TRUE == pAddrDecWin->enable)
-	{
-		sizeReg |= SCSR_WIN_EN;
-	}
-	else
-	{
-		sizeReg &= ~SCSR_WIN_EN;
-	}
-
-	/* 3) Write to address decode Base Address Register.		*/
-	MV_REG_WRITE(SDRAM_BASE_ADDR_REG(0,target), baseReg);
-
-	/* Write to address decode Size Register.			*/
-	MV_REG_WRITE(SDRAM_SIZE_REG(0,target), sizeReg);
-
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvDramIfWinGet - Get DRAM interface address decode window
-*
-* DESCRIPTION: 
-*       This function gets DRAM interface address decode window.
-*
-* INPUT:
-*	    target - System target. Use only SDRAM targets.
-*
-* OUTPUT:
-*       pAddrDecWin - SDRAM address window structure.
-*
-* RETURN:
-*       MV_BAD_PARAM if parameters are invalid or window is invalid, MV_OK
-*       otherwise.
-*******************************************************************************/
-MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
-{
-	MV_U32 baseReg,sizeReg;
-	MV_U32 sizeRegVal;
-
-	/* Read base and size registers */
-	sizeReg = MV_REG_READ(SDRAM_SIZE_REG(0,target));
-	baseReg = MV_REG_READ(SDRAM_BASE_ADDR_REG(0,target));
-
-	sizeRegVal = (sizeReg & SCSR_SIZE_MASK) >> SCSR_SIZE_OFFS;
-
-	pAddrDecWin->addrWin.size = (sizeRegVal + 1) * SCSR_SIZE_ALIGNMENT;
-
-    	/* Check if ctrlRegToSize returned OK */
-	if (-1 == pAddrDecWin->addrWin.size)
-	{
-		mvOsPrintf("mvDramIfWinGet: size of target %d is Illigal\n", target);
-		return MV_ERROR;
-	}
-
-	/* Extract base address						*/
-	/* Base register [31:16] ==> baseLow[31:16] 		*/
-	pAddrDecWin->addrWin.baseLow = baseReg & SCBAR_BASE_MASK;
-	pAddrDecWin->addrWin.baseHigh =  0;
-
-	if (sizeReg & SCSR_WIN_EN)
-	{
-		pAddrDecWin->enable = MV_TRUE;
-	}
-	else
-	{
-		pAddrDecWin->enable = MV_FALSE;			
-	}
-
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvDramIfWinEnable - Enable/Disable SDRAM address decode window
-*
-* DESCRIPTION: 
-*		This function enable/Disable SDRAM address decode window.
-*
-* INPUT:
-*	    target - System target. Use only SDRAM targets.
-*
-* OUTPUT:
-*		None.
-*
-* RETURN:
-*		MV_ERROR in case function parameter are invalid, MV_OK otherewise.
-*
-*******************************************************************************/
-MV_STATUS mvDramIfWinEnable(MV_TARGET target, MV_BOOL enable)
-{
-	MV_DRAM_DEC_WIN 	addrDecWin;
-
-	if (enable == MV_TRUE) 
-	{
-		/* First check for overlap with other enabled windows				*/
-		if (MV_OK != mvDramIfWinGet(target, &addrDecWin))
-		{
-			mvOsPrintf("mvDramIfWinEnable:ERR. Getting target %d failed.\n", 
-                                                                        target);
-			return MV_ERROR;
-		}
-		/* Check for overlapping */
-		if (MV_FALSE == sdramIfWinOverlap(target, &(addrDecWin.addrWin)))
-		{
-			/* No Overlap. Enable address decode winNum window              */
-			MV_REG_BIT_SET(SDRAM_SIZE_REG(0,target), SCSR_WIN_EN);
-		}
-		else
-		{   /* Overlap detected	*/
-			mvOsPrintf("mvDramIfWinEnable: ERR. Target %d overlap detect\n",
-                                                                        target);
-			return MV_ERROR;
-		}
-	}
-	else
-	{   /* Disable address decode winNum window                             */
-		MV_REG_BIT_RESET(SDRAM_SIZE_REG(0, target), SCSR_WIN_EN);
-	}
-
-	return MV_OK;
-}
-
-MV_VOID mvDdrPhyRegRead(MV_U8 regNum, MV_U8 pupNum, MV_U16 *value)
-{
-	MV_U32 regAddr;
-	MV_U32 reg;
-
-	regAddr = (BIT31 | ((regNum & 0x3F) << 16) | ((pupNum & 0xF) << 22));
-	MV_REG_WRITE(SDRAM_PHY_REGISTER_FILE_ACCESS, regAddr);
-
-	do {
-		reg = MV_REG_READ(SDRAM_PHY_REGISTER_FILE_ACCESS);
-	} while ((reg & BIT31) != 0);
-
-	*value = (reg & 0xFFFF);
-}
-
-MV_VOID mvDdrPhyRegWrite(MV_U8 regNum, MV_U8 pupNum, MV_U16 value)
-{
-	MV_U32 regAddr;
-	MV_U32 reg;
-
-	regAddr = (BIT31 | BIT30 | ((regNum & 0x3F) << 16) | ((pupNum & 0xF) << 22) | value);
-	MV_REG_WRITE(SDRAM_PHY_REGISTER_FILE_ACCESS, regAddr);
-
-	do {
-		reg = MV_REG_READ(SDRAM_PHY_REGISTER_FILE_ACCESS);
-	} while ((reg & BIT31) != 0);
-}
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIf.h
+++ /dev/null
@@ -1,186 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-
-#ifndef __INCmvDramIfh
-#define __INCmvDramIfh
-
-#include "mvCommon.h"
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-/* includes */
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-//#include "ddr2_3/mvDramIfRegs.h"
-//#include "ddr2_3/mvDramIfConfig.h"
-#include "mvSysDdrConfig.h"
-
-/* defines  */
-/* DRAM Timing parameters */
-#define SDRAM_TWR                    15  /* ns tWr */
-#define SDRAM_TRFC_64_512M_AT_200MHZ 70  /* ns tRfc for dens 64-512 @ 200MHz */
-#define SDRAM_TRFC_64_512M           75  /* ns tRfc for dens 64-512          */
-#define SDRAM_TRFC_1G                120 /* ns tRfc for dens 1GB             */
-#define SDRAM_TR2R_CYC               1   /* cycle for tR2r                   */
-
-#define CAL_AUTO_DETECT     0   /* Do not force CAS latancy (mvDramIfDetect) */
-#define ECC_DISABLE         1   /* Force ECC to Disable                      */
-#define ECC_ENABLE          0   /* Force ECC to ENABLE                       */
-
-/* typedefs */
-/* enumeration for memory types */
-typedef enum _mvMemoryType
-{
-    MEM_TYPE_SDRAM,
-    MEM_TYPE_DDR1,
-    MEM_TYPE_DDR2
-} MV_MEMORY_TYPE;
-
-/* enumeration for DDR2 supported CAS Latencies */
-typedef enum _mvDimmDdr2Cas
-{
-    DDR2_CL_3    = 0x08, 
-    DDR2_CL_4    = 0x10, 
-    DDR2_CL_5    = 0x20, 
-    DDR2_CL_6    = 0x40, 
-    DDR2_CL_FAULT
-} MV_DIMM_DDR2_CAS;
-
-
-typedef struct _mvDramBankInfo
-{
-    MV_MEMORY_TYPE  memoryType; 	/* DDR1, DDR2 or SDRAM */
-
-    /* DIMM dimensions */
-    MV_U32  numOfRowAddr;
-    MV_U32  numOfColAddr;
-    MV_U32  dataWidth;
-    MV_U32  errorCheckType;             /* ECC , PARITY..*/
-    MV_U32  sdramWidth;                 /* 4,8,16 or 32 */
-    MV_U32  errorCheckDataWidth;        /* 0 - no, 1 - Yes */
-    MV_U32  burstLengthSupported;
-    MV_U32  numOfBanksOnEachDevice;
-    MV_U32  suportedCasLatencies;
-    MV_U32  refreshInterval;
-
-    /* DIMM timing parameters */
-    MV_U32  minCycleTimeAtMaxCasLatPs;	
-    MV_U32  minCycleTimeAtMaxCasLatMinus1Ps;
-    MV_U32  minCycleTimeAtMaxCasLatMinus2Ps;
-    MV_U32  minRowPrechargeTime;
-    MV_U32  minRowActiveToRowActive;
-    MV_U32  minRasToCasDelay;
-    MV_U32  minRasPulseWidth;
-    MV_U32  minWriteRecoveryTime;   /* DDR2 only */
-    MV_U32  minWriteToReadCmdDelay; /* DDR2 only */
-    MV_U32  minReadToPrechCmdDelay; /* DDR2 only */
-    MV_U32  minRefreshToActiveCmd;  /* DDR2 only */
-                      
-    /* Parameters calculated from the extracted DIMM information */
-    MV_U32  size;
-    MV_U32  deviceDensity;           	/* 16,64,128,256 or 512 Mbit */
-    MV_U32  numberOfDevices;
-
-    /* DIMM attributes (MV_TRUE for yes) */
-    MV_BOOL registeredAddrAndControlInputs;
-    MV_BOOL registeredDQMBinputs;
-     
-}MV_DRAM_BANK_INFO;
-
-typedef struct _mvDramIfDecWin 
-{
-	MV_ADDR_WIN   addrWin;    /* An address window*/
-	MV_BOOL       enable;     /* Address decode window is enabled/disabled    */
-}MV_DRAM_DEC_WIN;
-
-//#include "ddr2_3/spd/mvSpd.h"
-
-/* mvDramIf.h API list */
-MV_STATUS mvDramIfWinSet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin);
-MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin);
-MV_STATUS mvDramIfWinEnable(MV_TARGET target,MV_BOOL enable);
-MV_VOID   mvDramIfBasicAsmInit(MV_VOID);
-MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable, MV_U32 sysClk);
-MV_VOID   _mvDramIfConfig(int entryNum);
-
-MV_U32 mvDramIfBankSizeGet(MV_U32 bankNum);
-MV_U32 mvDramIfBankBaseGet(MV_U32 bankNum);
-MV_U32 mvDramIfSizeGet(MV_VOID);
-MV_U32 mvDramIfCalGet(void);
-MV_STATUS mvDramIfSingleBitErrThresholdSet(MV_U32 threshold);
-MV_VOID mvDramIfSelfRefreshSet(void);
-void mvDramIfShow(void);
-MV_U32 mvDramIfGetFirstCS(void);
-MV_U32 mvDramIfGetCSorder(MV_U32 csOrder );
-MV_U32 mvDramCsSizeGet(MV_U32 csNum);
-MV_VOID mvDdrPhyRegRead(MV_U8 regNum, MV_U8 pupNum, MV_U16 *value);
-MV_VOID mvDdrPhyRegWrite(MV_U8 regNum, MV_U8 pupNum, MV_U16 value);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* __INCmvDramIfh */
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfBasicInit.S
+++ /dev/null
@@ -1,1027 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#define	_ASMLANGUAGE
-#define MV_ASMLANGUAGE
-#include "mvSysHwConfig.h"
-#include "mvOsAsm.h"
-#include "boardEnv/mvBoardEnvSpec.h"
-#include "ctrlEnv/sys/mvCpuIfRegs.h"
-#include "mvDramIfConfig.h"
-#include "mvDramIfRegs.h"
-#include "pex/mvPexRegs.h"
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "ctrlEnv/mvCtrlEnvAsm.h"
-#include "mvCommon.h"
-
-/* defines */
-#if defined(MV_STATIC_DRAM_ON_BOARD) 
-/******************************************************************************
-* static definitions for several dimms
-*******************************************************************************/
-#if defined(DB_MV78XX0) || defined(DB_MV88F632X)
-#if defined(MV78100) 
-/* DDR2 boards 512MB 333MHz */
-#define STATIC_SDRAM0_BANK0_SIZE		0x1ffffff1 /*	0x1504	*/ 
-#define STATIC_SDRAM_CONFIG	     		0x43048C30 /*	0x1400  */	
-#define STATIC_DUNIT_CTRL_LOW			0x38543000 /*   0x1404  */  
-#define STATIC_SDRAM_TIME_CTRL_LOW		0x22125441 /*   0x1408  */  
-#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A29 /*   0x140c  */  
-#define STATIC_SDRAM_ADDR_CTRL			0x00000088 /*   0x1410  */  
-#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */	
-#define STATIC_SDRAM_EXT_MODE          	0x00000040 /*   0x1420  */  
-#define STATIC_DUNIT_CTRL_HI			0x0000FFFF /*   0x1424  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */  
-#define STATIC_SDRAM_ODT_CTRL_LOW	    0x84210000 /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	    0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    	0x0000E80F /*   0x149c  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */  
-
-#elif defined(MV78200) 
-/*  512MB per CD,  800Mhz cl5  */
-#define	STATIC_DRAM_BANK_CS0
-#define	STATIC_DRAM_BANK_CS2
-
-#define STATIC_SDRAM0_BANK0_SIZE		0x1ffffff1 /*	0x1504	*/ 
-#define STATIC_SDRAM1_BANK0_SIZE		0x1ffffff9  /*  0x1514  */
-#define STATIC_SDRAM1_BANK0_BASE		0x20000000 /*   0x1510  */
-
-
-#define STATIC_SDRAM_CONFIG	     		0x43008C30 /*	0x1400  */	
-#define STATIC_DUNIT_CTRL_LOW			0x37543010 /*   0x1404  */  
-#define STATIC_SDRAM_TIME_CTRL_LOW		0x22125441 /*   0x1408  */  
-#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A29 /*   0x140c  */  
-
-#define STATIC_SDRAM_ADDR_CTRL			0x00008888 /*   0x1410  */  
-#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */	
-
-#define STATIC_SDRAM_EXT_MODE          	0x00000044 /*   0x1420  */  
-#define STATIC_DUNIT_CTRL_HI			0x0000FF7F /*   0x1424  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */  
-
-#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */  
-
-#define STATIC_SDRAM_ODT_CTRL_LOW	    0x030C030C /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	    0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    	0x0000F40F /*   0x149c  */  
-
-#endif
-
-#elif defined(RD_MV78XX0_AMC)
-/* On board DDR2 512MB 400MHz CL5 */
-#define STATIC_SDRAM0_BANK0_SIZE		0x1ffffff1 /*	0x1504	*/ 
-#define STATIC_SDRAM_CONFIG	     		0x43008C30 /*	0x1400  */	
-#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */	
-#define STATIC_DUNIT_CTRL_LOW			0x38543000 /*   0x1404  */  
-#define STATIC_DUNIT_CTRL_HI			0x0000F07F /*   0x1424  */  
-#define STATIC_SDRAM_ADDR_CTRL			0x000000DD /*   0x1410  */  
-#define STATIC_SDRAM_TIME_CTRL_LOW		0x23135441 /*   0x1408  */  
-#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A32 /*   0x140c  */  
-#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000EB0F /*   0x149c  */  
-#define STATIC_SDRAM_EXT_MODE          		0x00000040 /*   0x1420  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */  
-
-#define STATIC_SDRAM1_BANK0_SIZE       0x0FFFFFF1 /*  0x1514  */
-#define STATIC_SDRAM1_BANK0_BASE       0x10000000 /*   0x1510  */
-
-#elif defined(RD_MV78XX0_H3C)
-/* DDR2 boards 512MB 333MHz */
-#define STATIC_SDRAM0_BANK0_SIZE		0x1ffffff1 /*	0x1504	*/ 
-
-#define STATIC_SDRAM_CONFIG	     		0x43048a25 /*	0x1400  */	
-#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */	
-#define STATIC_DUNIT_CTRL_LOW			0x38543000 /*   0x1404  */  
-#define STATIC_DUNIT_CTRL_HI			0x0000F07F /*   0x1424  */  
-#define STATIC_SDRAM_ADDR_CTRL			0x00000088 /*   0x1410  */  
-#define STATIC_SDRAM_TIME_CTRL_LOW		0x2202444e /*   0x1408  */  
-#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A22 /*   0x140c  */  
-#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000EB0F /*   0x149c  */  
-#define STATIC_SDRAM_EXT_MODE          		0x00000040 /*   0x1420  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */  
-
-#elif defined(RD_MV78XX0_PCAC)
-/* DDR2 boards 256MB 200MHz */
-#define STATIC_SDRAM0_BANK0_SIZE		0x0ffffff1 /*	0x1504	*/ 
-#define STATIC_SDRAM_CONFIG	     		0x43000a25 /*	0x1400  */	
-#define STATIC_SDRAM_MODE	     		0x00000652 /*	0x141c  */	
-#define STATIC_DUNIT_CTRL_LOW			0x38543000 /*   0x1404  */  
-#define STATIC_DUNIT_CTRL_HI			0x0000F07F /*   0x1424  */  
-#define STATIC_SDRAM_ADDR_CTRL			0x000000DD /*   0x1410  */  
-#define STATIC_SDRAM_TIME_CTRL_LOW		0x2202444e /*   0x1408  */  
-#define STATIC_SDRAM_TIME_CTRL_HI		0x00000822 /*   0x140c  */  
-#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000EB0F /*   0x149c  */  
-#define STATIC_SDRAM_EXT_MODE          		0x00000040 /*   0x1420  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */  
-
-#else
-/* DDR2 MV88F6281 boards 256MB 400MHz */
-#define STATIC_SDRAM0_BANK0_SIZE		0x0FFFFFF1 /*	0x1504	*/ 
-#define STATIC_SDRAM_CONFIG	     		0x43000c30 /*	0x1400  */	
-#define STATIC_SDRAM_MODE	     		0x00000C52 /*	0x141c  */	
-#define STATIC_DUNIT_CTRL_LOW			0x39543000 /*   0x1404  */  
-#define STATIC_DUNIT_CTRL_HI			0x0000F1FF /*   0x1424  */  
-#define STATIC_SDRAM_ADDR_CTRL			0x000000cc /*   0x1410  */  
-#define STATIC_SDRAM_TIME_CTRL_LOW		0x22125451 /*   0x1408  */  
-#define STATIC_SDRAM_TIME_CTRL_HI		0x00000A33 /*   0x140c  */  
-#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x003C0000 /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000F80F /*   0x149c  */  
-#define STATIC_SDRAM_EXT_MODE          		0x00000042 /*   0x1420  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO		0x00085520 /*   0x1428  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI		0x00008552 /*   0x147C  */  
-#endif /* MV78XX0 */
-
-#endif /* MV_STATIC_DRAM_ON_BOARD */
-
-.globl dramBoot1
-dramBoot1:
-        .word   0
-/*************************************************************
-* basic timing init 
-**************************************************************/
-	.globl _mvDramInitTiming
-_mvDramInitTiming:
-	/* Set Dunit high control register	      */
-        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_HI_REG)
-		orr		r6, r6, #BIT7 /* SDRAM__D2P_EN */
-		orr		r6, r6, #BIT8 /* SDRAM__P2D_EN */
-#ifdef MV78XX0
-		orr		r6, r6, #BIT9 /* SDRAM__ADD_HALF_FCC_EN */
-		orr		r6, r6, #BIT10 /* SDRAM__PUP_ZERO_SKEW_EN */
-		orr		r6, r6, #BIT11 /* SDRAM__WR_MASH_DELAY_EN */
-#endif
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_DUNIT_CTRL_HI_REG)
-
-#ifdef MV78XX0
-        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
-		orr		r6, r6, #BIT4	/* Enable 2T mode */
-		bic		r6, r6, #BIT6	/* clear ctrlPos */
-		MV_REG_WRITE_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
-#endif
-
-
-     	/*DDR SDRAM Initialization Control */
-		ldr	r6, =DSICR_INIT_EN
-		MV_REG_WRITE_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
-2:		MV_REG_READ_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
-		and    	r6, r6, #DSICR_INIT_EN
-		cmp    	r6, #0
-		bne 	2b
-		mov		pc, lr
-
-
-#if defined(MV_STATIC_DRAM_ON_BOARD) 
-/*************************************************************
-* basic init for static DRAM (on board dram no SPD)
-**************************************************************/
-
-	.globl _mvDramIfStaticInit
-_mvDramIfStaticInit:
-
-		mov     r11, LR     		/* Save link register */
-		mov		r10, r2
-		bl	    _mvDramInitTiming
-
-        /* If we boot from NAND jump to DRAM address */
-        mov     r5, #1
-        ldr     r6, =dramBoot1
-        str     r5, [r6]                /* We started executing from DRAM */
-
-        ldr     r6, dramBoot1
-        cmp     r6, #0
-        bne     1f
-
-	/* set all dram windows to 0 */
-		mov		r6, #0
-		MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,0))
-		MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,1))
-		MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,2))
-		MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,3))
-		ldr		r6, = STATIC_SDRAM0_BANK0_SIZE
-		MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,0))
-
-#ifdef STATIC_DRAM_BANK_CS2
-		ldr 	r6, = STATIC_SDRAM1_BANK0_SIZE
-		MV_REG_WRITE_ASM(r6, r5, SDRAM_SIZE_REG(0,2))
-		ldr		r6, = STATIC_SDRAM1_BANK0_BASE
-		MV_REG_WRITE_ASM(r6, r5, SDRAM_BASE_ADDR_REG (0,2))
-#endif
-
-
-	/* set all dram configuration in temp registers */
-		ldr		r6, = STATIC_SDRAM0_BANK0_SIZE
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG0)
-		ldr		r6, = STATIC_SDRAM_CONFIG
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG1)
-		ldr		r6, = STATIC_SDRAM_MODE
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG2)
-		ldr		r6, = STATIC_DUNIT_CTRL_LOW
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG3)
-		ldr		r6, = STATIC_SDRAM_ADDR_CTRL
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG4)
-		ldr		r6, = STATIC_SDRAM_TIME_CTRL_LOW
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG5)
-		ldr		r6, = STATIC_SDRAM_TIME_CTRL_HI
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG6)
-		ldr		r6, = STATIC_SDRAM_ODT_CTRL_LOW
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG7)
-		ldr		r6, = STATIC_SDRAM_ODT_CTRL_HI
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG8)
-		ldr		r6, = STATIC_SDRAM_DUNIT_ODT_CTRL
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG9)
-		ldr		r6, = STATIC_SDRAM_EXT_MODE
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG10)
-		ldr		r6, = STATIC_SDRAM_DDR2_TIMING_LO
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG11)
-		ldr		r6, = STATIC_SDRAM_DDR2_TIMING_HI
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG12)
-#ifndef MTD_NAND_LNC_BOOT
-		ldr		r6, = STATIC_DUNIT_CTRL_HI
-		MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG13)
-#endif
-
-		ldr		sp,=0
-		bl		_mvDramIfConfig
-		ldr		r0, =0
-#ifdef MV78XX0
-		bl	_mvDramIfEccMemInit 
-#ifdef STATIC_DRAM_BANK_CS2
-		ldr 	r0, =2
-		bl 		_mvDramIfEccMemInit
-#endif
-		ldr 	r0, =0
-#endif
-1:
-		mov 	r2, r10
-		mov     PC, r11         	/* r11 is saved link register */
-
-#else  /* #if defined(MV_STATIC_DRAM_ON_BOARD) */
-
-/*******************************************************************************
-* mvDramIfBasicInit - Basic initialization of DRAM interface
-*
-* DESCRIPTION:
-*       The function will initialize the DRAM for basic usage. The function
-*       will use the TWSI assembly API to extract DIMM parameters according
-*       to which DRAM interface will be initialized.
-*       The function referes to the following DRAM parameters:
-*       1) DIMM is registered or not.
-*       2) DIMM width detection.
-*       3) DIMM density.
-*
-* INPUT:
-*       r3 - required size for initial DRAM.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*       Note:
-*       r4 holds I2C EEPROM address
-*       r5 holds SDRAM register base address
-*	r7 holds returned values
-*       r8 holds SDRAM various configuration registers value.
-*       r11 holds return function address.
-*******************************************************************************/
-/* Setting the offsets of the I2C registers */
-#define DIMM_TYPE_OFFSET	      2
-#define NUM_OF_ROWS_OFFSET            3
-#define NUM_OF_COLS_OFFSET            4
-#define NUM_OF_RANKS		      5
-#define DIMM_CONFIG_TYPE             11
-#define SDRAM_WIDTH_OFFSET           13
-#define NUM_OF_BANKS_OFFSET          17
-#define SUPPORTED_CL_OFFSET          18
-#define DIMM_TYPE_INFO_OFFSET        20         /* DDR2 only    */
-#define SDRAM_MODULES_ATTR_OFFSET    21
-#define RANK_SIZE_OFFSET             31
-
-#define DRAM_DEV_DENSITY_128M         128
-#define DRAM_DEV_DENSITY_256M         256
-#define DRAM_DEV_DENSITY_512M         512
-#define DRAM_DEV_DENSITY_1G          1024
-#define DRAM_DEV_DENSITY_2G          2048
-
-#define DRAM_RANK_DENSITY_128M       0x20
-#define DRAM_RANK_DENSITY_256M       0x40
-#define DRAM_RANK_DENSITY_512M       0x80
-#define DRAM_RANK_DENSITY_1G	     0x1
-#define DRAM_RANK_DENSITY_2G	     0x2
-
-       .globl _mvDramIfBasicInit
-       .extern _i2cInit
-_mvDramIfBasicInit:
-
-        mov     r11, LR     		/* Save link register */
-
-		bl	    _mvDramInitTiming
-
-        mov     r5, #1
-        ldr     r8, =dramBoot1
-        str     r5, [r8]                /* We started executing from DRAM */
-
-        /* If we boot from NAND jump to DRAM address */
-        ldr     r8, dramBoot1
-        cmp     r8, #0
-        movne   pc, r11
-
-        bl      _i2cInit                /* Initialize TWSI master             */
-
-        /* Check if we have more then 1 dimm */
-		ldr		r6, =0
-		MV_REG_WRITE_ASM (r6, r1, DRAM_BUF_REG14)
-#ifdef MV78XX0
-		bl		_is_Second_Dimm_Exist
-		beq 	single_dimm
-		ldr		r6, =1
-		MV_REG_WRITE_ASM (r6, r1, DRAM_BUF_REG14)
-single_dimm:
-        bl      _i2cInit                /* Initialize TWSI master             */
-#endif
-
-        /* Get default SDRAM Config values */
-        MV_REG_READ_ASM (r8, r5, SDRAM_CONFIG_REG)
-
-        /* Get registered/non registered info from DIMM */
-		bl  	_is_Registered
-        beq     nonRegistered
-
-setRegistered:
-        orr     r8, r8, #SDRAM_REGISTERED   /* Set registered bit(17)         */
-nonRegistered:
-#if defined(MV78XX0) && !defined(MV632X)
-        /* Get ECC/non ECC info from DIMM */
-		bl  	_is_Ecc
-        beq     setConfigReg
-
-setEcc:        
-        orr     r8, r8, #SDRAM_ECC_EN   /* Set ecc bit(18)         */
-#endif
-setConfigReg:
-        MV_REG_WRITE_ASM (r8, r5, DRAM_BUF_REG1)
-
-        /* Set maximum CL supported by DIMM */
-		bl	_get_CAL
-
-        /* r7 is DIMM supported CAS (e.g: 3 --> 0x1C)                         */
-        clz     r6, r7
-        rsb     r6, r6, #31     /* r6 = the bit number of MAX CAS supported   */
-
-casDdr2:
-		ldr     r7, =0x41        /* stBurstInDel|stBurstOutDel field value     */
-		ldr     r3, =0x53       /* stBurstInDel|stBurstOutDel registered value*/
-		ldr     r8, =0x32      /* Assuming MAX CL = 3           */
-        cmp     r6, #3          /* If CL = 3 break              */
-        beq     casDdr2Cont
-
-		ldr     r7, =0x53        /* stBurstInDel|stBurstOutDel field value     */
-		ldr     r3, =0x65       /* stBurstInDel|stBurstOutDel registered value*/
-		ldr     r8, =0x42      /* Assuming MAX CL = 4           */
-        cmp     r6, #4          /* If CL = 4 break              */
-        beq     casDdr2Cont
-
-		ldr     r7, =0x65        /* stBurstInDel|stBurstOutDel field value     */
-		ldr     r3, =0x77       /* stBurstInDel|stBurstOutDel registered value*/
-		ldr     r8, =0x52      /* Assuming MAX CL = 5           */
-        cmp     r6, #5          /* If CL = 5 break              */
-        beq     casDdr2Cont
-
-		ldr     r7, =0x77        /* stBurstInDel|stBurstOutDel field value     */
-		ldr     r3, =0x89       /* stBurstInDel|stBurstOutDel registered value*/
-		ldr     r8, =0x62      /* Assuming MAX CL = 6           */
-        cmp     r6, #6          /* If CL = 5 break              */
-        beq     casDdr2Cont                
-
-        /* This is an error. return */
-        b       exit_ddrAutoConfig      /* This is an error !!  */
-casDdr2Cont:
-
-        /* Get default SDRAM Mode values */
-        MV_REG_READ_ASM (r6, r5, SDRAM_MODE_REG)
-        bic     r6, r6, #(BIT6 | BIT5 | BIT4) /* Clear CL filed */
-		orr		r6, r6, r8
-        MV_REG_WRITE_ASM (r6, r5, DRAM_BUF_REG2)
-
-	/* Set Dunit control register according to max CL detected	      */
-        MV_REG_READ_ASM (r6, r5, DRAM_BUF_REG1)
-		tst		r6, #SDRAM_REGISTERED
-		beq		setDunitReg
-		mov		r7, r3
-
-setDunitReg:
-#ifdef MV78XX0
-        /* Set SDRAM Extended Mode register for double DIMM */
-	/* Check DRAM frequency for more then 267MHz set ODT Rtt to 50ohm */
-
-        MV_REG_READ_ASM (r4, r5, CPU_RESET_SAMPLE_L_REG)
-		ldr		r5, =MSAR_SYSCLCK_MASK
-		and		r4, r4, r5	
-		ldr		r5, =MSAR_SYSCLCK_333
-		cmp		r4, r5
-		ble		Clock333
-		add 	r7, r7, #0x10
-Clock333:
-#endif
-
-        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
-		bic		r6, r6, #(0xff << 20) /* Clear SBout and SBin */
-		orr		r6, r6, #BIT4	/* Enable 2T mode */
-		bic		r6, r6, #BIT6	/* clear ctrlPos */
-		orr		r6, r6, r7, LSL #20
-        MV_REG_WRITE_ASM (r6, r5, DRAM_BUF_REG3)
-
-	/* Set Dunit high control register	      */
-        MV_REG_READ_ASM (r6, r5, SDRAM_DUNIT_CTRL_HI_REG)
-		orr		r6, r6, #BIT7 /* SDRAM__D2P_EN */
-		orr		r6, r6, #BIT8 /* SDRAM__P2D_EN */
-#ifdef MV78XX0
-		orr		r6, r6, #BIT9 /* SDRAM__ADD_HALF_FCC_EN */
-		orr		r6, r6, #BIT10 /* SDRAM__PUP_ZERO_SKEW_EN */
-		orr		r6, r6, #BIT11 /* SDRAM__WR_MASH_DELAY_EN */
-#endif
-        MV_REG_WRITE_ASM (r6, r5, DRAM_BUF_REG13)
-
-        /* DIMM density configuration*/
-        /* Density = (1 << (rowNum + colNum)) * dramWidth * dramBankNum       */
-Density:
-	/* Get bank 0 and 1 density */
-		ldr		r6, =0
-		bl 		_getDensity
-
-		mov 	r8, r7
-        mov     r8, r8, LSR #20 /* Move density 20 bits to the right  */
-                                /* For example 0x10000000 --> 0x1000 */
-
-        mov     r3, #(SDRAM_DSIZE_256Mb(0) | SDRAM_DSIZE_256Mb(1))
-        cmp     r8, #DRAM_DEV_DENSITY_256M
-        beq     get_bank_2_density
-
-        mov     r3, #(SDRAM_DSIZE_512Mb(0) | SDRAM_DSIZE_512Mb(1))
-        cmp     r8, #DRAM_DEV_DENSITY_512M
-        beq     get_bank_2_density
-
-        mov     r3, #(SDRAM_DSIZE_1Gb(0) | SDRAM_DSIZE_1Gb(1))
-        cmp     r8, #DRAM_DEV_DENSITY_1G
-        beq     get_bank_2_density
-
-        mov     r3, #(SDRAM_DSIZE_2Gb(0) | SDRAM_DSIZE_2Gb(1))
-        cmp     r8, #DRAM_DEV_DENSITY_2G
-        beq     get_bank_2_density
-
-        /* This is an error. return */
-        b       exit_ddrAutoConfig
-
-get_bank_2_density:
-	/* Check for second dimm */
-	MV_REG_READ_ASM (r6, r1, DRAM_BUF_REG14)
-		cmp		r6, #1
-		bne 	get_width
-
-	/* Get bank 2 and 3 density */
-		ldr		r6, =2
-		bl 		_getDensity
-	
-		mov 	r8, r7
-        mov     r8, r8, LSR #20 /* Move density 20 bits to the right  */
-                                /* For example 0x10000000 --> 0x1000 */
-
-        orr     r3, r3, #(SDRAM_DSIZE_256Mb(2) | SDRAM_DSIZE_256Mb(3))
-        cmp     r8, #DRAM_DEV_DENSITY_256M
-        beq     get_width
-
-        and     r3, r3, #~(SDRAM_DSIZE_MASK(2) | SDRAM_DSIZE_MASK(3))
-        orr     r3, r3, #(SDRAM_DSIZE_512Mb(2) | SDRAM_DSIZE_512Mb(3))
-        cmp     r8, #DRAM_DEV_DENSITY_512M
-        beq     get_width
-
-        and     r3, r3, #~(SDRAM_DSIZE_MASK(2) | SDRAM_DSIZE_MASK(3))
-        orr     r3, r3, #(SDRAM_DSIZE_1Gb(2) | SDRAM_DSIZE_1Gb(3))
-        cmp     r8, #DRAM_DEV_DENSITY_1G
-        beq     get_width
-
-        and     r3, r3, #~(SDRAM_DSIZE_MASK(2) | SDRAM_DSIZE_MASK(3))
-        orr     r3, r3, #(SDRAM_DSIZE_2Gb(2) | SDRAM_DSIZE_2Gb(3))
-        cmp     r8, #DRAM_DEV_DENSITY_2G
-        beq     get_width
-
-        /* This is an error. return */
-        b       exit_ddrAutoConfig
-
-	/* Get SDRAM width */
-get_width: 
-	/* Get bank 0 and 1 width */
-		ldr		r6, =0
-		bl 		_get_width
-
-        cmp     r7, #8           /* x8 devices   */  
-        beq     get_bank_2_width
-
-        orr     r3, r3, #(SDRAM_ADDRSEL_X16(0) | SDRAM_ADDRSEL_X16(1)) /* x16 devices  */
-        cmp     r7, #16
-        beq     get_bank_2_width
-
-        /* This is an error. return */
-        b       exit_ddrAutoConfig
-
-get_bank_2_width:
-	/* Check for second dimm */
-	MV_REG_READ_ASM (r6, r1, DRAM_BUF_REG14)
-		cmp		r6, #1
-		bne 	densCont
-
-	/* Get bank 2 and 3 width */
-		ldr		r6, =2
-		bl 		_get_width
-
-        cmp     r7, #8           /* x8 devices   */  
-        beq     densCont
-
-        orr     r3, r3, #(SDRAM_ADDRSEL_X16(2) | SDRAM_ADDRSEL_X16(3)) /* x16 devices  */
-        cmp     r7, #16
-        beq     densCont
-
-        /* This is an error. return */
-        b       exit_ddrAutoConfig
-
-densCont:
-        MV_REG_WRITE_ASM (r3, r5, DRAM_BUF_REG4)
-
-        /* Set SDRAM timing control low register */
-		ldr		r4, =SDRAM_TIMING_CTRL_LOW_REG_DEFAULT
-        /* MV_REG_READ_ASM (r4, r5, SDRAM_TIMING_CTRL_LOW_REG) */
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG5)
-
-        /* Set SDRAM timing control high register */
-		ldr		r6, =SDRAM_TIMING_CTRL_HIGH_REG_DEFAULT
-	
-		MV_REG_READ_ASM (r4, r5, CPU_RESET_SAMPLE_L_REG)
-		ldr		r5, =MSAR_SYSCLCK_MASK
-		and		r4, r4, r5	
-		ldr		r5, =MSAR_SYSCLCK_333
-		cmp		r4, r5
-		blt		timingHighClock333
-		orr 	r6, r6, #BIT9
-
-timingHighClock333:
-    /* MV_REG_READ_ASM (r6, r5, SDRAM_TIMING_CTRL_HIGH_REG) */
-    MV_REG_WRITE_ASM(r6, r5, DRAM_BUF_REG6)
-
-	/* Check for second dimm */
-	MV_REG_READ_ASM (r6, r1, DRAM_BUF_REG14)
-		cmp		r6, #1
-		bne 	single_dimm_odt
-
-        /* Set SDRAM ODT control low register for double DIMM*/        
-        ldr		r4, =DDR2_ODT_CTRL_LOW_CS0_CS1_CS2_CS3_DV
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG7)
-
-        /* Set DUNIT ODT control register for double DIMM */
-        ldr		r4, =DDR2_DUNIT_ODT_CTRL_CS0_CS1_CS2_CS3_DV
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG9)
-
-#ifdef MV78XX0
-        /* Set SDRAM Extended Mode register for double DIMM */
-	/* Check DRAM frequency for more then 267MHz set ODT Rtt to 50ohm */
-
-        MV_REG_READ_ASM (r4, r5, CPU_RESET_SAMPLE_L_REG)
-		ldr		r5, =MSAR_SYSCLCK_MASK
-		and		r4, r4, r5	
-		ldr		r5, =MSAR_SYSCLCK_267
-		cmp		r4, r5
-		beq		slow_dram_clock_rtt
-		ldr		r5, =MSAR_SYSCLCK_300
-		cmp		r4, r5
-		beq		slow_dram_clock_rtt
-		ldr		r5, =MSAR_SYSCLCK_333
-		cmp		r4, r5
-		beq		fast_dram_clock_rtt
-		ldr		r5, =MSAR_SYSCLCK_400
-		cmp		r4, r5
-		beq		fast_dram_clock_rtt
-		
-		b		slow_dram_clock_rtt
-
-fast_dram_clock_rtt:
-        ldr		r4, =DDR_SDRAM_EXT_MODE_FAST_CS0_CS1_CS2_CS3_DV
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG10)
-		b 		odt_config_end
-#endif
-slow_dram_clock_rtt:
-        ldr	r4, =DDR_SDRAM_EXT_MODE_CS0_CS1_CS2_CS3_DV
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG10)
-		b 		odt_config_end
-
-single_dimm_odt:
-        /* Set SDRAM ODT control low register */        
-        ldr		r4, =DDR2_ODT_CTRL_LOW_CS0_CS1_DV
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG7)
-
-        /* Set DUNIT ODT control register */
-        ldr		r4, =DDR2_DUNIT_ODT_CTRL_CS0_CS1_DV
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG9)
-
-        /* Set SDRAM Extended Mode register */
-        ldr		r4, =DDR_SDRAM_EXT_MODE_CS0_CS1_DV
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG10)
-
-odt_config_end:
-        /* SDRAM ODT control high register is left as default */
-        MV_REG_READ_ASM (r4, r5, DDR2_SDRAM_ODT_CTRL_HIGH_REG)
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG8)
-
-        /*Read CL and set the DDR2 registers accordingly */
-        MV_REG_READ_ASM (r6, r5, DRAM_BUF_REG2)
-        and 	r6, r6, #SDRAM_CL_MASK
-        mov 	r4, r6
-        orr 	r4, r4, r6, LSL #4
-        orr 	r4, r4, r6, LSL #8
-        orr 	r4, r4, r6, LSL #12
-        mov 	r5, #0x30000
-        add 	r4, r4, r5
-        sub 	r4, r4, #0x30
-        /* Set SDRAM Ddr2 Timing Low register */
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG11)
-
-        /* Set SDRAM Ddr2 Timing High register */
-        mov 	r4, r4, LSR #4
-        MV_REG_WRITE_ASM(r4, r5, DRAM_BUF_REG12)
-
-timeParamDone:        
-	/* Close all windows */
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
-        and		r6, r6,#~SCSR_SIZE_MASK
-        and		r6, r6,#~1
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,1))
-        and		r6, r6,#~SCSR_SIZE_MASK
-        and		r6, r6,#~1
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,1))
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
-        and		r6, r6,#~SCSR_SIZE_MASK
-        and		r6, r6,#~1
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,3))
-        and		r6, r6,#~SCSR_SIZE_MASK
-        and		r6, r6,#~1
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,3))
-
-        /* Set sdram bank 0 size and enable it */
-		ldr		r6, =0
-		bl 		_mvDramIfGetDimmSizeFromSpd
-#ifdef MV78XX0
-	/* Check DRAM width */
-        MV_REG_READ_ASM (r4, r5, SDRAM_CONFIG_REG)
-		ldr		r5, =SDRAM_DWIDTH_MASK
-		and		r4, r4, r5	
-		ldr		r5, =SDRAM_DWIDTH_64BIT
-		cmp		r4, r5
-		beq		dram_64bit_width
-		/* Utilize only 32bit width */
-		mov		r8, r8, LSR #1
-#else
-	/* Utilize only 16bit width */
-	mov	r8, r8, LSR #2
-#endif
-dram_64bit_width:
-	/* Update first dimm size return value R8 */
-        MV_REG_READ_ASM (r5, r6, SDRAM_SIZE_REG(0,0))
-        ldr		r6, =~SCSR_SIZE_MASK	
-		and		r5, r5, r6
-		orr		r5, r5, r8
-        MV_REG_WRITE_ASM(r5, r8, SDRAM_SIZE_REG(0,0))
-
-	/* Clear bank 2 size */
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
-        and		r6, r6,#~SCSR_SIZE_MASK	
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
-
-	/* Check for second dimm */
-	MV_REG_READ_ASM (r6, r1, DRAM_BUF_REG14)
-		cmp		r6, #1
-		bne 	defualt_order
-
-        /* Set sdram bank 2 size */
-	ldr	r6, =2
-	bl _mvDramIfGetDimmSizeFromSpd
-#ifdef MV78XX0
-	/* Check DRAM width */
-        MV_REG_READ_ASM (r4, r5, SDRAM_CONFIG_REG)
-		ldr		r5, =SDRAM_DWIDTH_MASK
-		and		r4, r4, r5	
-		ldr		r5, =SDRAM_DWIDTH_64BIT
-		cmp		r4, r5
-		beq		dram_64bit_width2
-	/* Utilize only 32bit width */
-		mov		r8, r8, LSR #1
-#else
-	/* Utilize only 16bit width */
-		mov		r8, r8, LSR #2
-#endif
-dram_64bit_width2:
-	/* Update first dimm size return value R8 */
-        MV_REG_READ_ASM (r5, r6, SDRAM_SIZE_REG(0,2))
-        ldr		r6, =~SCSR_SIZE_MASK	
-		and		r5, r5, r6
-		orr		r5, r5, r8
-        MV_REG_WRITE_ASM(r5, r8, SDRAM_SIZE_REG(0,2))
-
-	/* Close windows 1 and 3 */
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,1))
-        and		r6, r6,#~1
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,1))
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,3))
-        and		r6, r6,#~1
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,3))
-
-	/* Check dimm size for setting dram bank order */
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
-        MV_REG_READ_ASM (r4, r5, SDRAM_SIZE_REG(0,2))
-        and		r6, r6,#SCSR_SIZE_MASK	
-        and		r4, r4,#SCSR_SIZE_MASK	
-		cmp		r6, r4
-		bge		defualt_order
-
-	/* Bank 2 is biger then bank 0 */
-		ldr		r6,=0
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_BASE_ADDR_REG(0,2))
-
-	/* Open win 2 */
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
-        orr		r6, r6,#1
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,2))
-
-		ldr		sp,=0
-		bl		_mvDramIfConfig
-#ifdef MV78XX0
-	/* Init ECC on CS 2 */
-		ldr		r0, =2
-		bl		_mvDramIfEccMemInit
-#endif
-        mov     PC, r11         /* r11 is saved link register */
-
-defualt_order:
-
-	/* Open win 0 */
-        MV_REG_READ_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
-        orr		r6, r6,#1
-        MV_REG_WRITE_ASM (r6, r5, SDRAM_SIZE_REG(0,0))
-
-		ldr		sp,=0
-		bl		_mvDramIfConfig
-#ifdef MV78XX0
-	/* Init ECC on CS 0 */
-		ldr		r0, =0
-		bl		_mvDramIfEccMemInit
-#endif
-exit_ddrAutoConfig:
-        mov     PC, r11         /* r11 is saved link register */
-
-
-/***************************************************************************************/
-/*       r4 holds I2C EEPROM address
- *       r7 holds I2C EEPROM offset parameter for i2cRead and its --> returned value
- *       r8 holds SDRAM various configuration registers value.
- *	r13 holds Link register
- */
-/**************************/
-_getDensity:
-		mov     r13, LR                            /* Save link register */
-
-	/* Read SPD rank size from DIMM0 */
-        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR       /* reading from DIMM0      */
-
-		cmp		r6, #0
-		beq		1f
-
-	/* Read SPD rank size from DIMM1 */
-        mov     r4, #MV_BOARD_DIMM1_I2C_ADDR /* reading from DIMM1            */
-
-1:
-        mov     r7, #NUM_OF_ROWS_OFFSET            /* offset  3               */
-        bl      _i2cRead
-        mov     r8, r7                             /* r8 save number of rows  */
-
-        mov     r7, #NUM_OF_COLS_OFFSET            /* offset  4               */
-        bl      _i2cRead
-        add     r8, r8, r7                         /* r8 = number of rows + number of col */
-
-        mov     r7, #0x1
-        mov     r8, r7, LSL r8                     /* r8 = (1 << r8)          */
-
-        mov     r7, #SDRAM_WIDTH_OFFSET            /* offset 13 */
-        bl      _i2cRead
-        mul     r8, r7, r8
-
-        mov     r7, #NUM_OF_BANKS_OFFSET           /* offset 17               */
-        bl      _i2cRead
-        mul     r7, r8, r7
-
-		mov     PC, r13
-
-/**************************/
-_get_width:
-		mov     r13, LR                 /* Save link register */
-
-	/* Read SPD rank size from DIMM0 */
-        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
-
-		cmp		r6, #0
-		beq		1f
-
-	/* Read SPD rank size from DIMM1 */
-        mov     r4, #MV_BOARD_DIMM1_I2C_ADDR /* reading from DIMM1            */
-
-1:
-        /* Get SDRAM width (SPD offset 13) */
-        mov     r7, #SDRAM_WIDTH_OFFSET
-        bl      _i2cRead                /* result in r7                       */
-
-		mov     PC, r13
-
-/**************************/
-_get_CAL:
-		mov     r13, LR                 /* Save link register */
-
-        /* Set maximum CL supported by DIMM */
-        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
-        mov     r7, #SUPPORTED_CL_OFFSET     /* offset  18 */
-        bl      _i2cRead
-
-		mov     PC, r13
-
-/**************************/
-/* R8 - sdram configuration register.
- * Return value in flag if no-registered then Z-flag is set
- */
-_is_Registered:
-		mov     r13, LR                 /* Save link register */
-#if defined(MV645xx)
-        /* Get registered/non registered info from DIMM */
-        tst     r8, #SDRAM_DTYPE_DDR2
-        bne     regDdr2
-
-regDdr1:
-        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
-        mov     r7, #SDRAM_MODULES_ATTR_OFFSET
-        bl      _i2cRead                /* result in r7                       */
-
-        tst     r7, #0x2
-		b	exit
-#endif
-regDdr2:
-        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
-        mov     r7, #DIMM_TYPE_INFO_OFFSET
-        bl      _i2cRead                /* result in r7                       */
-
-        tst     r7, #0x11               /* DIMM type = regular RDIMM (0x01)   */
-                                        /* or Mini-RDIMM (0x10)               */
-exit:
-        mov     PC, r13
-
-
-/**************************/
-/* Return value in flag if no-Ecc then Z-flag is set */
-_is_Ecc:
-		mov     r13, LR                 /* Save link register */
-
-        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
-        mov     r7, #DIMM_CONFIG_TYPE
-        bl      _i2cRead                /* result in r7                       */
-
-        tst     r7, #0x2               /* bit 1 -> Data ECC */
-        mov     PC, r13
-
-/**************************/
-/* Return value in flag if no second DIMM then Z-flag is set */
-_is_Second_Dimm_Exist:
-		mov     r13, LR                 /* Save link register */
-
-        mov     r4, #MV_BOARD_DIMM1_I2C_ADDR /* reading from DIMM0            */
-        mov     r7, #DIMM_TYPE_OFFSET
-        bl      _i2cRead                /* result in r7                       */
-
-     	tst     r7, #0x8               /* bit3 is '1' -> DDR 2 */
-        mov     PC, r13
-
-/*******************************************************************************
-* _mvDramIfGetDimmSizeFromSpd  - read bank 0 dram's size
-*
-* DESCRIPTION:
-*       The function will read the bank 0 dram size(SPD version 1.0 and above )  
-*
-* INPUT:
-*       r6 - dram bank number.
-*
-* OUTPUT:
-*	none
-*/
-_mvDramIfGetDimmSizeFromSpd:
-
-	mov     r13, LR                 /* Save link register */
-	
-	/* Read SPD rank size from DIMM0 */
-        mov     r4, #MV_BOARD_DIMM0_I2C_ADDR /* reading from DIMM0            */
-
-		cmp		r6, #0
-		beq		1f
-
-	/* Read SPD rank size from DIMM1 */
-        mov     r4, #MV_BOARD_DIMM1_I2C_ADDR /* reading from DIMM1            */
-
-1:
-        mov     r7, #RANK_SIZE_OFFSET	/* offset  31 */
-        bl      _i2cRead  
-	
-pass_read:
-      	ldr     r8, =(0x7 << SCSR_SIZE_OFFS)
-        cmp		r7, #DRAM_RANK_DENSITY_128M
-        beq     endDimmSize
-
-      	ldr     r8, =(0xf << SCSR_SIZE_OFFS)
-        cmp		r7, #DRAM_RANK_DENSITY_256M
-        beq     endDimmSize
-        
-        ldr     r8, =(0x1f << SCSR_SIZE_OFFS)
-        cmp		r7, #DRAM_RANK_DENSITY_512M
-        beq     endDimmSize
-        
-        ldr     r8, =(0x3f << SCSR_SIZE_OFFS)
-        cmp		r7, #DRAM_RANK_DENSITY_1G
-        beq     endDimmSize
-
-        ldr     r8, =(0x7f  << SCSR_SIZE_OFFS)     /* DRAM_RANK_DENSITY_2G */
-endDimmSize:
-        mov     PC, r13
-#endif
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfConfig.S
+++ /dev/null
@@ -1,528 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-/*******************************************************************************
-* mvDramIfBasicAsm.s
-*
-* DESCRIPTION:
-*       Memory full detection and best timing configuration is done in 
-*       C code. C runtime environment requires a stack. This module API 
-*       initialize DRAM interface chip select 0 for basic functionality for 
-*       the use of stack.
-*       The module API assumes DRAM information is stored in I2C EEPROM reside
-*       in a given I2C address MV_BOARD_DIMM0_I2C_ADDR. The I2C EEPROM 
-*       internal data structure is assumed to be orgenzied in common DRAM 
-*       vendor SPD structure.
-*       NOTE: DFCDL values are assumed to be already initialized prior to 
-*       this module API activity.
-*       
-*
-* DEPENDENCIES:
-*       None.
-*
-*******************************************************************************/
-
-/* includes */
-#define	_ASMLANGUAGE
-#define MV_ASMLANGUAGE
-#include "mvOsAsm.h"
-#include "mvSysHwConfig.h"
-#include "mvDramIfRegs.h"
-#include "mvDramIfConfig.h"
-#include "mvCpuIfRegs.h"
-#include "pex/mvPexRegs.h"
-#include "mvCtrlEnvSpec.h"
-#include "mvCommon.h"
-#include "mvSysXorConfig.h"
-
-/* defines  */
-
-/* locals   */
-.data
-.globl _mvDramIfConfig
-.text
-.globl _mvDramIfMemInit
-
-/*******************************************************************************
-* _mvDramIfConfig - Basic DRAM interface initialization.
-*
-* DESCRIPTION:
-*       The function will initialize the following DRAM parameters using the
-*       values prepared by mvDramIfDetect routine. Values are located
-*       in predefined registers.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-
-_mvDramIfConfig:      
-        
-        /* Save register on stack */
-	cmp	sp, #0
-	beq	no_stack_s
-save_on_stack:
-        stmdb	sp!, {r1, r2, r3, r4}
-no_stack_s:
-
-	/* Dunit FTDLL Configuration Register */
-	/* 0) Write to SDRAM FTDLL coniguration register */
-        ldr     r4, = SDRAM_FTDLL_REG_DEFAULT_LEFT;
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_FTDLL_CONFIG_LEFT_REG)
-        str     r4, [r1]
-        ldr     r4, = SDRAM_FTDLL_REG_DEFAULT_RIGHT;
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_FTDLL_CONFIG_RIGHT_REG)
-        str     r4, [r1]
-        ldr     r4, = SDRAM_FTDLL_REG_DEFAULT_UP;
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_FTDLL_CONFIG_UP_REG)
-        str     r4, [r1]
-
-	/* 1) Write to SDRAM coniguration register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG1)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_CONFIG_REG)
-        str     r4, [r1]
-        
-	/* 2) Write Dunit control low register */ 
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG3)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_DUNIT_CTRL_REG)
-        str     r4, [r1]
-        
-	/* 2) Write Dunit control high register */ 
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG13)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_DUNIT_CTRL_HI_REG)
-        str     r4, [r1]
-        
-        /* 3) Write SDRAM address control register */ 
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG4)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_ADDR_CTRL_REG)
-        str     r4, [r1]
-#if defined(MV_STATIC_DRAM_ON_BOARD)
-        /* 4) Write SDRAM bank 0 size register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG0)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_SIZE_REG(0,0))
-        str     r4, [r1]
-#endif
-                          
-        /* 5) Write SDRAM open pages control register */
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_OPEN_PAGE_CTRL_REG)
-        ldr     r4, =SDRAM_OPEN_PAGES_CTRL_REG_DV
-        str     r4, [r1]
-                          
-        /* 6) Write SDRAM timing Low register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG5)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_TIMING_CTRL_LOW_REG)
-        str     r4, [r1]
-        
-        /* 7) Write SDRAM timing High register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG6)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_TIMING_CTRL_HIGH_REG)
-        str     r4, [r1]
-                
-        /* Config DDR2 On Die Termination (ODT) registers */
-        /* Write SDRAM DDR2 ODT control low register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG7)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + DDR2_SDRAM_ODT_CTRL_LOW_REG)
-        str     r4, [r1]
-        
-        /* Write SDRAM DDR2 ODT control high register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG8)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + DDR2_SDRAM_ODT_CTRL_HIGH_REG)
-        str     r4, [r1]
-        
-        /* Write SDRAM DDR2 Dunit ODT control register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG9)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + DDR2_DUNIT_ODT_CONTROL_REG)
-        str     r4, [r1]
-        
-        /* Write DDR2 SDRAM timing Low register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG11)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_DDR2_TIMING_LO_REG)
-        str     r4, [r1]
-                                   
-        /* Write DDR2 SDRAM timing High register */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG12)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_DDR2_TIMING_HI_REG)
-        str     r4, [r1]
-
-        /* 8) Write SDRAM mode register */ 
-        /* The CPU must not attempt to change the SDRAM Mode register setting */
-        /* prior to DRAM controller completion of the DRAM initialization     */
-        /* sequence. To guarantee this restriction, it is recommended that    */
-        /* the CPU sets the SDRAM Operation register to NOP command, performs */
-        /* read polling until the register is back in Normal operation value, */
-        /* and then sets SDRAM Mode register to its new value.               */
-        
-	/* 8.1 write 'nop' to SDRAM operation */
-        mov     r4, #0x5                 /* 'NOP' command              */
-        MV_REG_WRITE_ASM(r4, r1, SDRAM_OPERATION_REG)
-       
-        /* 8.2 poll SDRAM operation. Make sure its back to normal operation   */
-_sdramOpPoll1:        
-        ldr     r4, [r1]
-        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
-        bne     _sdramOpPoll1
-
-        /* 8.3 Now its safe to write new value to SDRAM Mode register         */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG2)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_MODE_REG)
-        str     r4, [r1]
-
-        /* 8.4 Make the Dunit write the DRAM its new mode                     */       
-        mov     r4, #0x3                 /* Mode Register Set command  */
-        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
-               
-        /* 8.5 poll SDRAM operation. Make sure its back to normal operation   */
-_sdramOpPoll2:        
-        ldr     r4, [r1]                     
-        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
-        bne     _sdramOpPoll2
-
-        /* Now its safe to write new value to SDRAM Extended Mode regist */
-        ldr     r1, =(INTER_REGS_BASE + DRAM_BUF_REG10)
-        ldr     r4, [r1]
-        ldr     r1, =(INTER_REGS_BASE + SDRAM_EXTENDED_MODE_REG)
-        str     r4, [r1]
-
-        /* 9) Write SDRAM Extended mode register This operation should be     */
-        /*    done for each memory bank                                       */ 
-        /* write 'nop' to SDRAM operation */
-        mov     r4, #0x5                 /* 'NOP' command              */
-        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
-       
-        /* poll SDRAM operation. Make sure its back to normal operation   */
-_sdramOpPoll3:        
-        ldr     r4, [r1]
-        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
-        bne     _sdramOpPoll3
-        /* Go over each of the Banks */
-        ldr     r3, =0          /* r3 = DRAM bank Num */
-
-extModeLoop:        
-        /* Set the SDRAM Operation Control to each of the DRAM banks          */
-        mov     r4, r3   /* Do not swap the bank counter value */
-        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_CTRL_REG)
-        
-        /* Make the Dunit write the DRAM its new mode                     */       
-        mov     r4, #0x4        /* Extended Mode Register Set command  */
-        MV_REG_WRITE_ASM (r4, r1, SDRAM_OPERATION_REG)
-               
-        /* poll SDRAM operation. Make sure its back to normal operation   */
-_sdramOpPoll4:        
-        ldr     r4, [r1]                     
-        cmp     r4, #0                          /* '0' = Normal SDRAM Mode    */
-        bne     _sdramOpPoll4
-
-        add     r3, r3, #1
-        cmp     r3, #4         /* 4 = Number of banks */
-        bne     extModeLoop
-        
-extModeEnd:	
-cmp	sp, #0
-	beq	no_stack_l
-	mov     r1, LR                        	/* Save link register */
-#if defined(MV78XX0)
-	bl   	_mvDramIfMemInit 
-#endif
-	mov	LR,r1				/* restore link register */
-load_from_stack:
-	/* Restore registers */
-        ldmia	sp!, {r1, r2, r3, r4}
-no_stack_l:
-           
-        mov     pc, lr
-
-
-/*******************************************************************************
-* _mvDramIfEccMemInit - Basic DRAM ECC initialization.
-*
-* DESCRIPTION:
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-#define XOR_CHAN0         0   /* XOR channel 0 used for memory initialization */
-#define XOR_UNIT0         0   /* XOR unit 0 used for memory initialization */
-#define XOR_ADDR_DEC_WIN0 0   /* Enable DRAM access using XOR decode window 0 */ 
-/* XOR engine register offsets macros */
-#define XOR_CONFIG_REG(chan)                (MV_XOR_REGS_BASE(0) + 0x10 + ((chan)    * 4))
-#define XOR_ACTIVATION_REG(chan)            (MV_XOR_REGS_BASE(0) + 0x20 + ((chan)    * 4))
-#define XOR_CAUSE_REG			    (MV_XOR_REGS_BASE(0) + 0x30)
-#define XOR_ERROR_CAUSE_REG                 (MV_XOR_REGS_BASE(0) + 0x50)             
-#define XOR_ERROR_ADDR_REG                  (MV_XOR_REGS_BASE(0) + 0x60)             
-#define XOR_WINDOW_CTRL_REG(chan)           (MV_XOR_REGS_BASE(0) + 0x240 + ((chan)    * 4))
-#define XOR_BASE_ADDR_REG(winNum)     	    (MV_XOR_REGS_BASE(0) + 0x250 + ((winNum)  * 4))
-#define XOR_SIZE_MASK_REG(winNum)           (MV_XOR_REGS_BASE(0) + 0x270 + ((winNum)  * 4))
-#define XOR_INIT_VAL_LOW_REG                (MV_XOR_REGS_BASE(0) + 0x2E0)
-#define XOR_INIT_VAL_HIGH_REG               (MV_XOR_REGS_BASE(0) + 0x2E4)
-#define XOR_DST_PTR_REG(chan)               (MV_XOR_REGS_BASE(0) + 0x2B0 + ((chan)    * 4))
-#define XOR_BLOCK_SIZE_REG(chan)            (MV_XOR_REGS_BASE(0) + 0x2C0 + ((chan)    * 4))
-
-.globl _mvDramIfEccMemInit
-/*******************************************************************************
-* _mvDramIfEccMemInit  - mem init for dram cs
-*
-* DESCRIPTION:
-*       This function will clean the cs by ussing the XOR mem init.  
-*
-* INPUT:
-*       r0 - dram bank number.
-*
-* OUTPUT:
-*	none
-*/
-_mvDramIfEccMemInit:      
-        
-        /* Save register on stack */
-	cmp	sp, #0
-	beq	no_stack_s1
-save_on_stack1:
-        stmdb	sp!, {r0,r1, r2, r3, r4, r5, r6}
-no_stack_s1:
-
-	ldr	r1, = 0             
-
-        /* Disable all XOR address decode windows to avoid possible overlap */
-        MV_REG_WRITE_ASM (r1, r5, (XOR_WINDOW_CTRL_REG(XOR_CHAN0)))
-
-        /* Init r5 to first XOR_SIZE_MASK_REG */
-		mov		r5, r0, LSL #3
-        add     r5, r5,#0x1500
-        add     r5, r5,#0x04
-        add     r5, r5,#(INTER_REGS_BASE)
-        ldr     r6, [r5]
-        HTOLL(r6,r5)
-        MV_REG_WRITE_ASM (r6, r5, XOR_SIZE_MASK_REG(XOR_ADDR_DEC_WIN0))
-       
-	mov		r5, r0, LSL #3
-        add     r5, r5,#0x1500
-        add     r5, r5,#(INTER_REGS_BASE)
-        ldr     r6, [r5]
-        HTOLL(r6,r5)
-        /* Update destination & size */
-        MV_REG_WRITE_ASM(r6, r5, XOR_DST_PTR_REG(XOR_CHAN0))
-        HTOLL(r6,r5)
-        /* Init r6 to first XOR_BASE_ADDR_REG */
-	ldr	r4, = 0xf              
-	ldr	r5, = 0x1
-	mov	r5, r5, LSL r0
-	bic	r4, r4, r5
-	mov 	r4, r4, LSL #8
-
-        orr	r6, r6, r4
-        MV_REG_WRITE_ASM (r6, r5, XOR_BASE_ADDR_REG(XOR_ADDR_DEC_WIN0))
-        
-	ldr	r6, = 0xff0001              
-        MV_REG_WRITE_ASM (r6, r5, XOR_WINDOW_CTRL_REG(XOR_CHAN0))        
-
-        /* Configure XOR engine for memory init function.           */
-        MV_REG_READ_ASM (r6, r5, XOR_CONFIG_REG(XOR_CHAN0))
-        and	r6, r6, #~0x7        	/* Clear operation mode field      */
-        orr     r6, r6, #0x4             /* Set operation to memory init    */
-        MV_REG_WRITE_ASM(r6, r5, XOR_CONFIG_REG(XOR_CHAN0))
-               
-        /* Set initVal in the XOR Engine Initial Value Registers       */
-	ldr	r6, = 0xfeedfeed              
-        MV_REG_WRITE_ASM(r6, r5, XOR_INIT_VAL_LOW_REG)
-	ldr	r6, = 0xfeedfeed              
-        MV_REG_WRITE_ASM(r6, r5, XOR_INIT_VAL_HIGH_REG)
-
-        /* Set block size using DRAM bank size  */
-
-	mov	r5, r0, LSL #3
-        add     r5, r5,#0x1500
-        add     r5, r5,#0x04
-        add     r5, r5,#(INTER_REGS_BASE)
-
-        ldr     r6, [r5]
-        HTOLL(r6,r5)
-	and	r6, r6, #SCSR_SIZE_MASK
-	mov	r5, r6, LSR #SCSR_SIZE_OFFS
-        add	r5, r5, #1
-	mov	r6, r5, LSL #SCSR_SIZE_OFFS
-        MV_REG_WRITE_ASM(r6, r5, XOR_BLOCK_SIZE_REG(XOR_CHAN0))
-        
-        /* Clean interrupt cause*/
-        MV_REG_WRITE_ASM(r1, r5, XOR_CAUSE_REG)
-
-        /* Clean error interrupt cause*/
-        MV_REG_READ_ASM(r6, r5, XOR_ERROR_CAUSE_REG)
-        MV_REG_READ_ASM(r6, r5, XOR_ERROR_ADDR_REG)
-
-        /* Start transfer */
-        MV_REG_READ_ASM (r6, r5, XOR_ACTIVATION_REG(XOR_CHAN0))
-        orr     r6, r6, #0x1 /* Preform start command      */
-        MV_REG_WRITE_ASM(r6, r5, XOR_ACTIVATION_REG(XOR_CHAN0))
-
-        /* Wait for engine to finish */
-waitForComplete:        
-        MV_REG_READ_ASM(r6, r5, XOR_CAUSE_REG)
-        and   	r6, r6, #2
-	cmp	r6, #0
-        beq     waitForComplete
-
-        /* Clear all error report registers */
-        MV_REG_WRITE_ASM(r1, r5, SDRAM_SINGLE_BIT_ERR_CNTR_REG)
-        MV_REG_WRITE_ASM(r1, r5, SDRAM_DOUBLE_BIT_ERR_CNTR_REG)
-
-        MV_REG_WRITE_ASM(r1, r5, SDRAM_ERROR_CAUSE_REG)
-
-	cmp	sp, #0
-	beq	no_stack_l1
-load_from_stack1:
-        ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6}
-no_stack_l1:
-        mov     pc, lr
-
-
-/*******************************************************************************
-* mvDramIfMemInit - Use XOR to clear all memory.
-*
-* DESCRIPTION:
-*       Use assembler function _mvDramIfEccMemInit to fill all memory with FEADFEAD pattern.
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-#if defined(MV78XX0)
-
-_mvDramIfMemInit:
-        stmdb	sp!, {r0,r1, r2, r3, r4, r5, r6}
-	mov     r6, LR                 /* Save link register */
-    	/* Check if dram bank 0 has to be init for ECC */
-	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,0))
-	and 	r3, r0, #SCSR_WIN_EN
-        cmp     r3, #0 
-	beq   	no_bank_0
-	MV_REG_READ_ASM(r0, r5,  SDRAM_BASE_ADDR_REG(0,0))
-        cmp     r0, #0 
-	beq   	no_bank_0
-	mov	r0,#0
-	bl	_mvDramIfEccMemInit
-
-no_bank_0:
-    	/* Check if dram bank 1 has to be init for ECC */
-        MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,1))
-	and 	r0, r0, #SCSR_WIN_EN
-        cmp     r0, #0 
-	beq   	no_bank_1
-	mov	r0,#1
-	bl	_mvDramIfEccMemInit
-no_bank_1:
-    	/* Check if dram bank 2 has to be init for ECC */
-    	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,2))
-	and 	r0, r0, #SCSR_WIN_EN
-        cmp     r0, #0 
-	beq   	no_bank_2
-	MV_REG_READ_ASM(r0, r5,  SDRAM_BASE_ADDR_REG(0,2))
-        cmp     r0, #0 
-	beq   	no_bank_2
-	mov	r0,#2
-	bl	_mvDramIfEccMemInit
-
-no_bank_2:
-    	/* Check if dram bank 3 has to be init for ECC */
-	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,3))
-	and 	r0, r0, #SCSR_WIN_EN
-	cmp     r0, #0 
-	beq   	no_bank_3
-	mov	r0,#3
-	bl	_mvDramIfEccMemInit
-no_bank_3:
-	mov     LR ,r6                /* restore link register */
-	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6}
-	mov     pc, lr
-#endif
-
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfConfig.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-
-#ifndef __INCmvDramIfConfigh
-#define __INCmvDramIfConfigh
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* includes */
-
-/* defines  */
-
-/* registers defaults values */
-
-#define SDRAM_CONFIG_DV 	(SDRAM_SRMODE_DRAM | BIT25 | BIT30)
-
-#define SDRAM_DUNIT_CTRL_LOW_DDR2_DV			\
-		(SDRAM_SRCLK_KEPT		|	\
-		 SDRAM_CLK1DRV_NORMAL		|	\
-		 (BIT28 | BIT29))
-
-#define SDRAM_ADDR_CTRL_DV	    2
-		
-#define SDRAM_TIMING_CTRL_LOW_REG_DV 	\
-		((0x2 << SDRAM_TRCD_OFFS) | 	\
-		 (0x2 << SDRAM_TRP_OFFS)  | 	\
-		 (0x1 << SDRAM_TWR_OFFS)  | 	\
-		 (0x0 << SDRAM_TWTR_OFFS) | 	\
-		 (0x5 << SDRAM_TRAS_OFFS) | 	\
-		 (0x1 << SDRAM_TRRD_OFFS))
-
-/* Note: value of 0 in register means one cycle, 1 means two and so on  */
-#define SDRAM_TIMING_CTRL_HIGH_REG_DV 	\
-		((0x0 << SDRAM_TR2R_OFFS)	|	\
-		 (0x0 << SDRAM_TR2W_W2R_OFFS)	|	\
-		 (0x1 << SDRAM_TW2W_OFFS))
-
-#define SDRAM_OPEN_PAGES_CTRL_REG_DV 	SDRAM_OPEN_PAGE_EN	
-
-/* Presence	     Ctrl Low    Ctrl High  Dunit Ctrl   Ext Mode     */
-/* CS0              0x84210000  0x00000000  0x0000780F  0x00000440    */
-/* CS0+CS1          0x84210000  0x00000000  0x0000780F  0x00000440    */
-/* CS0+CS2          0x030C030C  0x00000000  0x0000740F  0x00000404    */
-/* CS0+CS1+CS2      0x030C030C  0x00000000  0x0000740F  0x00000404    */
-/* CS0+CS2+CS3      0x030C030C  0x00000000  0x0000740F  0x00000404    */
-/* CS0+CS1+CS2+CS3  0x030C030C  0x00000000  0x0000740F  0x00000404    */
-
-#define DDR2_ODT_CTRL_LOW_CS0_CS1_DV		0x84210000
-#define DDR2_ODT_CTRL_HIGH_CS0_CS1_DV		0x00000000
-#define DDR2_DUNIT_ODT_CTRL_CS0_CS1_DV		0x0000E80F
-#ifdef MV78XX0
-#define DDR_SDRAM_EXT_MODE_CS0_CS1_DV		0x00000040
-#else
-#define DDR_SDRAM_EXT_MODE_CS0_CS1_DV		0x00000440
-#endif
-
-#define DDR2_ODT_CTRL_LOW_CS0_CS1_CS2_CS3_DV	0x030C030C
-#define DDR2_ODT_CTRL_HIGH_CS0_CS1_CS2_CS3_DV	0x00000000
-#define DDR2_DUNIT_ODT_CTRL_CS0_CS1_CS2_CS3_DV	0x0000F40F
-#ifdef MV78XX0
-#define DDR_SDRAM_EXT_MODE_CS0_CS1_CS2_CS3_DV	0x00000004
-#define DDR_SDRAM_EXT_MODE_FAST_CS0_CS1_CS2_CS3_DV	0x00000044
-#else
-#define DDR_SDRAM_EXT_MODE_CS0_CS1_CS2_CS3_DV	0x00000404
-#define DDR_SDRAM_EXT_MODE_FAST_CS0_CS1_CS2_CS3_DV	0x00000444
-#endif
-
-/* DDR SDRAM Adderss/Control and Data Pads Calibration default values */
-#define DDR2_ADDR_CTRL_PAD_STRENGTH_TYPICAL_DV	\
-		(3 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
-		
-#define DDR2_DATA_PAD_STRENGTH_TYPICAL_DV		\
-		(3 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
-
-/* DDR SDRAM Mode Register default value */
-#define DDR2_MODE_REG_DV		(SDRAM_BURST_LEN_4 | SDRAM_WR_3_CYC)
-/* DDR SDRAM Timing parameter default values */
-#define SDRAM_TIMING_CTRL_LOW_REG_DEFAULT  	0x33136552
-#define SDRAM_TRFC_DEFAULT_VALUE		0x34
-#define SDRAM_TRFC_DEFAULT		SDRAM_TRFC_DEFAULT_VALUE
-#define SDRAM_TW2W_DEFALT		(0x1 << SDRAM_TW2W_OFFS)
-
-#define SDRAM_TIMING_CTRL_HIGH_REG_DEFAULT  (SDRAM_TRFC_DEFAULT | SDRAM_TW2W_DEFALT)
-
-#define SDRAM_FTDLL_REG_DEFAULT_LEFT  		0x88C800
-#define SDRAM_FTDLL_REG_DEFAULT_RIGHT  		0x88C800
-#define SDRAM_FTDLL_REG_DEFAULT_UP  		0x88C800
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* __INCmvDramIfh */
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfRegs.h
+++ /dev/null
@@ -1,428 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef __INCmvDramIfRegsh
-#define __INCmvDramIfRegsh
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "mvSysDdrConfig.h"
-
-/* DDR SDRAM Controller Address Decode Registers */
- /* SDRAM CSn Base Address Register (SCBAR) */
-#define SDRAM_BASE_ADDR_REG(cpu,csNum)	(0x1500 + ((csNum) * 8) + ((cpu) * 0x70))
-#define SCBAR_BASE_OFFS			16 
-#define SCBAR_BASE_MASK			(0xffff << SCBAR_BASE_OFFS)
-#define SCBAR_BASE_ALIGNMENT		0x10000 
-
-/* SDRAM CSn Size Register (SCSR) */		  
-#define SDRAM_SIZE_REG(cpu,csNum)	(0x1504 + ((csNum) * 8) + ((cpu) * 0x70)) 
-#define SCSR_SIZE_OFFS			24
-#define SCSR_SIZE_MASK			(0xff << SCSR_SIZE_OFFS)
-#define SCSR_SIZE_ALIGNMENT		0x1000000
-#define SCSR_WIN_EN			BIT0
-
-/* configuration register */
-#define SDRAM_CONFIG_REG   		(MV_DDR_REGS_BASE + 0x1400)
-#define SDRAM_REFRESH_OFFS 		0
-#define SDRAM_REFRESH_MAX  		0x3FFF
-#define SDRAM_REFRESH_MASK 		(SDRAM_REFRESH_MAX << SDRAM_REFRESH_OFFS)
-#define SDRAM_DWIDTH_OFFS       	15
-#define SDRAM_DWIDTH_MASK       	(1 << SDRAM_DWIDTH_OFFS)
-#define SDRAM_DWIDTH_32BIT      	(0 << SDRAM_DWIDTH_OFFS)
-#define SDRAM_DWIDTH_64BIT      	(1 << SDRAM_DWIDTH_OFFS)
-#define SDRAM_REGISTERED   		(1 << 17)
-#define SDRAM_ECC_OFFS    		18
-#define SDRAM_ECC_MASK    		(1 << SDRAM_ECC_OFFS)
-#define SDRAM_ECC_DIS     		(0 << SDRAM_ECC_OFFS)
-#define SDRAM_ECC_EN        		(1 << SDRAM_ECC_OFFS)
-#define SDRAM_IERR_OFFS    		19
-#define SDRAM_IERR_MASK    		(1 << SDRAM_IERR_OFFS)
-#define SDRAM_IERR_REPORTE     		(0 << SDRAM_IERR_OFFS)
-#define SDRAM_IERR_IGNORE      		(1 << SDRAM_IERR_OFFS)
-#define SDRAM_SRMODE_OFFS       	24
-#define SDRAM_SRMODE_MASK       	(1 << SDRAM_SRMODE_OFFS)
-#define SDRAM_SRMODE_POWER      	(0 << SDRAM_SRMODE_OFFS)
-#define SDRAM_SRMODE_DRAM       	(1 << SDRAM_SRMODE_OFFS)
-
-/* dunit control low register */
-#define SDRAM_DUNIT_CTRL_REG  		(MV_DDR_REGS_BASE + 0x1404)
-#define SDRAM_2T_OFFS			4
-#define SDRAM_2T_MASK			(1 << SDRAM_2T_OFFS)
-#define SDRAM_2T_MODE			(1 << SDRAM_2T_OFFS)
-
-#define SDRAM_SRCLK_OFFS		5
-#define SDRAM_SRCLK_MASK		(1 << SDRAM_SRCLK_OFFS)
-#define SDRAM_SRCLK_KEPT		(0 << SDRAM_SRCLK_OFFS)
-#define SDRAM_SRCLK_GATED		(1 << SDRAM_SRCLK_OFFS)
-#define SDRAM_CTRL_POS_OFFS	   	6
-#define SDRAM_CTRL_POS_MASK		(1 << SDRAM_CTRL_POS_OFFS)
-#define SDRAM_CTRL_POS_FALL	   	(0 << SDRAM_CTRL_POS_OFFS)
-#define SDRAM_CTRL_POS_RISE	   	(1 << SDRAM_CTRL_POS_OFFS)
-#define SDRAM_CLK1DRV_OFFS      	12
-#define SDRAM_CLK1DRV_MASK      	(1 << SDRAM_CLK1DRV_OFFS)
-#define SDRAM_CLK1DRV_HIGH_Z    	(0 << SDRAM_CLK1DRV_OFFS)
-#define SDRAM_CLK1DRV_NORMAL    	(1 << SDRAM_CLK1DRV_OFFS)
-#define SDRAM_CLK2DRV_OFFS      	13
-#define SDRAM_CLK2DRV_MASK      	(1 << SDRAM_CLK2DRV_OFFS)
-#define SDRAM_CLK2DRV_HIGH_Z    	(0 << SDRAM_CLK2DRV_OFFS)
-#define SDRAM_CLK2DRV_NORMAL    	(1 << SDRAM_CLK2DRV_OFFS)
-#define SDRAM_SB_OUT_DEL_OFFS 		20
-#define SDRAM_SB_OUT_DEL_MAX 		0xf
-#define SDRAM_SB_OUT_MASK 		(SDRAM_SB_OUT_DEL_MAX<<SDRAM_SB_OUT_DEL_OFFS)
-#define SDRAM_SB_IN_DEL_OFFS 		24
-#define SDRAM_SB_IN_DEL_MAX 		0xf
-#define SDRAM_SB_IN_MASK 		(SDRAM_SB_IN_DEL_MAX<<SDRAM_SB_IN_DEL_OFFS)
-
-/* dunit control hight register */
-#define SDRAM_DUNIT_CTRL_HI_REG  	(MV_DDR_REGS_BASE + 0x1424)
-#define SDRAM__D2P_OFFS			7
-#define SDRAM__D2P_EN			(1 << SDRAM__D2P_OFFS)
-#define SDRAM__P2D_OFFS			8
-#define SDRAM__P2D_EN			(1 << SDRAM__P2D_OFFS)
-#define SDRAM__ADD_HALF_FCC_OFFS	9
-#define SDRAM__ADD_HALF_FCC_EN		(1 << SDRAM__ADD_HALF_FCC_OFFS)
-#define SDRAM__PUP_ZERO_SKEW_OFFS	10
-#define SDRAM__PUP_ZERO_SKEW_EN		(1 << SDRAM__PUP_ZERO_SKEW_OFFS)
-#define SDRAM__WR_MESH_DELAY_OFFS	11
-#define SDRAM__WR_MESH_DELAY_EN		(1 << SDRAM__WR_MESH_DELAY_OFFS)
-
-/* sdram timing control low register */
-#define SDRAM_TIMING_CTRL_LOW_REG	(MV_DDR_REGS_BASE + 0x1408)
-#define SDRAM_TRCD_OFFS 		4
-#define SDRAM_TRCD_MASK 		(0xF << SDRAM_TRCD_OFFS)
-#define SDRAM_TRP_OFFS 			8
-#define SDRAM_TRP_MASK 			(0xF << SDRAM_TRP_OFFS)
-#define SDRAM_TWR_OFFS 			12
-#define SDRAM_TWR_MASK 			(0xF << SDRAM_TWR_OFFS)
-#define SDRAM_TWTR_OFFS 		16
-#define SDRAM_TWTR_MASK 		(0xF << SDRAM_TWTR_OFFS)
-#define SDRAM_TRAS_OFFS 		0
-#define SDRAM_TRAS_MASK 		(0xF << SDRAM_TRAS_OFFS)
-#define SDRAM_EXT_TRAS_OFFS 		20
-#define SDRAM_EXT_TRAS_MASK 		(0x1 << SDRAM_EXT_TRAS_OFFS)
-#define SDRAM_TRRD_OFFS 		24
-#define SDRAM_TRRD_MASK 		(0xF << SDRAM_TRRD_OFFS)
-#define SDRAM_TRTP_OFFS			28
-#define SDRAM_TRTP_MASK			(0xF << SDRAM_TRTP_OFFS)
-#define SDRAM_TRTP_DDR1 		(0x1 << SDRAM_TRTP_OFFS)
-
-/* sdram timing control high register */
-#define SDRAM_TIMING_CTRL_HIGH_REG	(MV_DDR_REGS_BASE + 0x140c)
-#define SDRAM_TRFC_OFFS 		0
-#define SDRAM_TRFC_MASK 		(0x3F << SDRAM_TRFC_OFFS)
-#define SDRAM_TR2R_OFFS 		7
-#define SDRAM_TR2R_MASK 		(0x3 << SDRAM_TR2R_OFFS)
-#define SDRAM_TR2W_W2R_OFFS		9
-#define SDRAM_TR2W_W2R_MASK		(0x3 << SDRAM_TR2W_W2R_OFFS)
-#define SDRAM_TW2W_OFFS			11
-#define SDRAM_TW2W_MASK			(0x3 << SDRAM_TW2W_OFFS)
-
-/* sdram DDR2 timing low register (SD2TLR) */
-#define SDRAM_DDR2_TIMING_LO_REG	(MV_DDR_REGS_BASE + 0x1428)
-#define SD2TLR_TODT_ON_RD_OFFS		4
-#define SD2TLR_TODT_ON_RD_MASK		(0xF << SD2TLR_TODT_ON_RD_OFFS)
-#define SD2TLR_TODT_OFF_RD_OFFS		8
-#define SD2TLR_TODT_OFF_RD_MASK		(0xF << SD2TLR_TODT_OFF_RD_OFFS)
-#define SD2TLR_TODT_ON_CTRL_RD_OFFS	12
-#define SD2TLR_TODT_ON_CTRL_RD_MASK	(0xF << SD2TLR_TODT_ON_CTRL_RD_OFFS)
-#define SD2TLR_TODT_OFF_CTRL_RD_OFFS	16
-#define SD2TLR_TODT_OFF_CTRL_RD_MASK	(0xF << SD2TLR_TODT_OFF_CTRL_RD_OFFS)
-
-/* sdram DDR2 timing high register (SD2TLR) */
-#define SDRAM_DDR2_TIMING_HI_REG	(MV_DDR_REGS_BASE + 0x147C)
-#define SD2THR_TODT_ON_WR_OFFS		0
-#define SD2THR_TODT_ON_WR_MASK		(0xF << SD2THR_TODT_ON_WR_OFFS)
-#define SD2THR_TODT_OFF_WR_OFFS		4
-#define SD2THR_TODT_OFF_WR_MASK		(0xF << SD2THR_TODT_OFF_WR_OFFS)
-#define SD2THR_TODT_ON_CTRL_WR_OFFS	8
-#define SD2THR_TODT_ON_CTRL_WR_MASK	(0xF << SD2THR_TODT_ON_CTRL_WR_OFFS)
-#define SD2THR_TODT_OFF_CTRL_WR_OFFS	12
-#define SD2THR_TODT_OFF_CTRL_WR_MASK	(0xF << SD2THR_TODT_OFF_CTRL_WR_OFFS)
-
-/* address control register */
-#define SDRAM_ADDR_CTRL_REG		(MV_DDR_REGS_BASE + 0x1410)
-#define SDRAM_ADDRSEL_OFFS(cs)		(4 * (cs))
-#define SDRAM_ADDRSEL_MASK(cs)		(0x3 << SDRAM_ADDRSEL_OFFS(cs))
-#define SDRAM_ADDRSEL_X8(cs)		(0x0 << SDRAM_ADDRSEL_OFFS(cs))
-#define SDRAM_ADDRSEL_X16(cs)		(0x1 << SDRAM_ADDRSEL_OFFS(cs))
-#define SDRAM_DSIZE_OFFS(cs)   	    	(2 + 4 * (cs))
-#define SDRAM_DSIZE_MASK(cs)   	    	(0x3 << SDRAM_DSIZE_OFFS(cs))
-#define SDRAM_DSIZE_256Mb(cs) 	    	(0x1 << SDRAM_DSIZE_OFFS(cs))
-#define SDRAM_DSIZE_512Mb(cs)  	    	(0x2 << SDRAM_DSIZE_OFFS(cs))
-#define SDRAM_DSIZE_1Gb(cs)  	    	(0x3 << SDRAM_DSIZE_OFFS(cs))
-#define SDRAM_DSIZE_2Gb(cs)  	    	(0x0 << SDRAM_DSIZE_OFFS(cs))
-
-/* SDRAM Open Pages Control registers */
-#define SDRAM_OPEN_PAGE_CTRL_REG	(MV_DDR_REGS_BASE + 0x1414)
-#define SDRAM_OPEN_PAGE_EN			(0 << 0)
-#define SDRAM_OPEN_PAGE_DIS			(1 << 0)
-
-/* sdram opertion register */
-#define SDRAM_OPERATION_REG 		(MV_DDR_REGS_BASE + 0x1418)
-#define SDRAM_CMD_OFFS  			0
-#define SDRAM_CMD_MASK   			(0xF << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_NORMAL 			(0x0 << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_PRECHARGE_ALL 	(0x1 << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_REFRESH_ALL 		(0x2 << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_REG_SET_CMD 		(0x3 << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_EXT_MODE_SET 		(0x4 << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_NOP 				(0x5 << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_SLF_RFRSH 		(0x7 << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_EMRS2_CMD  		(0x8 << SDRAM_CMD_OFFS)
-#define SDRAM_CMD_EMRS3_CMD  		(0x9 << SDRAM_CMD_OFFS)
-
-/* sdram mode register */
-#define SDRAM_MODE_REG 				(MV_DDR_REGS_BASE + 0x141c)
-#define SDRAM_BURST_LEN_OFFS 		0
-#define SDRAM_BURST_LEN_MASK 		(0x7 << SDRAM_BURST_LEN_OFFS)
-#define SDRAM_BURST_LEN_4    		(0x2 << SDRAM_BURST_LEN_OFFS)
-#define SDRAM_CL_OFFS   			4
-#define SDRAM_CL_MASK   			(0x7 << SDRAM_CL_OFFS)
-#define SDRAM_DDR2_CL_3      		(0x3 << SDRAM_CL_OFFS)
-#define SDRAM_DDR2_CL_4      		(0x4 << SDRAM_CL_OFFS)
-#define SDRAM_DDR2_CL_5    		    (0x5 << SDRAM_CL_OFFS)
-#define SDRAM_DDR2_CL_6    		    (0x6 << SDRAM_CL_OFFS)
-
-#define SDRAM_TM_OFFS           	7
-#define SDRAM_TM_MASK           	(1 << SDRAM_TM_OFFS)
-#define SDRAM_TM_NORMAL         	(0 << SDRAM_TM_OFFS)
-#define SDRAM_TM_TEST_MODE      	(1 << SDRAM_TM_OFFS)
-#define SDRAM_DLL_OFFS         		8
-#define SDRAM_DLL_MASK          	(1 << SDRAM_DLL_OFFS)
-#define SDRAM_DLL_NORMAL        	(0 << SDRAM_DLL_OFFS)
-#define SDRAM_DLL_RESET 			(1 << SDRAM_DLL_OFFS)
-#define SDRAM_WR_OFFS				9
-#define SDRAM_WR_MAX				7
-#define SDRAM_WR_MASK				(SDRAM_WR_MAX << SDRAM_WR_OFFS)
-#define SDRAM_WR_2_CYC				(1 << SDRAM_WR_OFFS)
-#define SDRAM_WR_3_CYC				(2 << SDRAM_WR_OFFS)
-#define SDRAM_WR_4_CYC				(3 << SDRAM_WR_OFFS)
-#define SDRAM_WR_5_CYC				(4 << SDRAM_WR_OFFS)
-#define SDRAM_WR_6_CYC				(5 << SDRAM_WR_OFFS)
-#define SDRAM_PD_OFFS				12
-#define SDRAM_PD_MASK				(1 << SDRAM_PD_OFFS) 
-#define SDRAM_PD_FAST_EXIT			(0 << SDRAM_PD_OFFS) 
-#define SDRAM_PD_SLOW_EXIT			(1 << SDRAM_PD_OFFS) 
-
-/* DDR SDRAM Extended Mode register (DSEMR) */
-#define SDRAM_EXTENDED_MODE_REG		(MV_DDR_REGS_BASE + 0x1420)
-#define DSEMR_DLL_ENABLE			0
-#define DSEMR_DLL_DISABLE			1
-#define DSEMR_DS_OFFS				1
-#define DSEMR_DS_MASK				(1 << DSEMR_DS_OFFS)
-#define DSEMR_DS_NORMAL				(0 << DSEMR_DS_OFFS)
-#define DSEMR_DS_REDUCED			(1 << DSEMR_DS_OFFS)
-#define DSEMR_QOFF_OUTPUT_BUFF_EN	(0 << 12)
-#define DSEMR_RTT0_OFFS				2
-#define DSEMR_RTT1_OFFS				6
-#define DSEMR_RTT_ODT_DISABLE		((0 << DSEMR_RTT0_OFFS)||(0 << DSEMR_RTT1_OFFS))
-#define DSEMR_RTT_ODT_75_OHM		((1 << DSEMR_RTT0_OFFS)||(0 << DSEMR_RTT1_OFFS))
-#define DSEMR_RTT_ODT_150_OHM		((0 << DSEMR_RTT0_OFFS)||(1 << DSEMR_RTT1_OFFS))
-#define DSEMR_RTT_ODT_50_OHM		((1 << DSEMR_RTT0_OFFS)||(1 << DSEMR_RTT1_OFFS))
-#define DSEMR_DQS_OFFS				10
-#define DSEMR_DQS_MASK				(1 << DSEMR_DQS_OFFS)
-#define DSEMR_DQS_DIFFERENTIAL		(0 << DSEMR_DQS_OFFS)
-#define DSEMR_DQS_SINGLE_ENDED		(1 << DSEMR_DQS_OFFS)
-#define DSEMR_RDQS_ENABLE			(1 << 11)
-#define DSEMR_QOFF_OUTPUT_BUFF_EN	(0 << 12)
-#define DSEMR_QOFF_OUTPUT_BUFF_DIS	(1 << 12)
-
-/* DDR SDRAM Operation Control Register */
-#define SDRAM_OPERATION_CTRL_REG	(MV_DDR_REGS_BASE + 0x142c)
-
-/* Dunit FTDLL Configuration Register */
-#define SDRAM_FTDLL_CONFIG_LEFT_REG		(MV_DDR_REGS_BASE + 0x1484)
-#define SDRAM_FTDLL_CONFIG_RIGHT_REG		(MV_DDR_REGS_BASE + 0x161C)
-#define SDRAM_FTDLL_CONFIG_UP_REG		(MV_DDR_REGS_BASE + 0x1620)
-  
-/* Pads Calibration register */
-#define SDRAM_ADDR_CTRL_PADS_CAL_REG	(MV_DDR_REGS_BASE + 0x14c0)
-#define SDRAM_DATA_PADS_CAL_REG		    (MV_DDR_REGS_BASE + 0x14c4)
-#define SDRAM_DRVN_OFFS 			0
-#define SDRAM_DRVN_MASK 			(0x3F << SDRAM_DRVN_OFFS)
-#define SDRAM_DRVP_OFFS 			6
-#define SDRAM_DRVP_MASK 			(0x3F << SDRAM_DRVP_OFFS)
-#define SDRAM_PRE_DRIVER_STRENGTH_OFFS		12
-#define SDRAM_PRE_DRIVER_STRENGTH_MASK		(3 << SDRAM_PRE_DRIVER_STRENGTH_OFFS)
-#define SDRAM_TUNE_EN   		BIT16
-#define SDRAM_LOCKN_OFFS 			17
-#define SDRAM_LOCKN_MAKS 			(0x3F << SDRAM_LOCKN_OFFS)
-#define SDRAM_LOCKP_OFFS 			23
-#define SDRAM_LOCKP_MAKS 			(0x3F << SDRAM_LOCKP_OFFS)
-#define SDRAM_WR_EN     			(1 << 31)
-
-/* DDR2 SDRAM ODT Control (Low) Register (DSOCLR) */
-#define DDR2_SDRAM_ODT_CTRL_LOW_REG (MV_DDR_REGS_BASE + 0x1494)
-#define DSOCLR_ODT_RD_OFFS(odtNum)  (odtNum * 4)
-#define DSOCLR_ODT_RD_MASK(odtNum)  (0xf << DSOCLR_ODT_RD_OFFS(odtNum))
-#define DSOCLR_ODT_RD(odtNum, bank) ((1 << bank) << DSOCLR_ODT_RD_OFFS(odtNum))
-#define DSOCLR_ODT_WR_OFFS(odtNum)  (16 + (odtNum * 4))
-#define DSOCLR_ODT_WR_MASK(odtNum)  (0xf << DSOCLR_ODT_WR_OFFS(odtNum))
-#define DSOCLR_ODT_WR(odtNum, bank) ((1 << bank) << DSOCLR_ODT_WR_OFFS(odtNum))
-
-/* DDR2 SDRAM ODT Control (High) Register (DSOCHR) */
-#define DDR2_SDRAM_ODT_CTRL_HIGH_REG    	(MV_DDR_REGS_BASE + 0x1498)
-/* Optional control values to DSOCHR_ODT_EN macro */
-#define DDR2_ODT_CTRL_DUNIT         0
-#define DDR2_ODT_CTRL_NEVER         1
-#define DDR2_ODT_CTRL_ALWAYS        3
-#define DSOCHR_ODT_EN_OFFS(odtNum)  (odtNum * 2)
-#define DSOCHR_ODT_EN_MASK(odtNum)  (0x3 << DSOCHR_ODT_EN_OFFS(odtNum))
-#define DSOCHR_ODT_EN(odtNum, ctrl) (ctrl << DSOCHR_ODT_EN_OFFS(odtNum))
-
-/* DDR2 Dunit ODT Control Register (DDOCR)*/
-#define DDR2_DUNIT_ODT_CONTROL_REG  (MV_DDR_REGS_BASE + 0x149c)
-#define DDOCR_ODT_RD_OFFS          	0
-#define DDOCR_ODT_RD_MASK           (0xf << DDOCR_ODT_RD_OFFS)
-#define DDOCR_ODT_RD(bank)          ((1 << bank) << DDOCR_ODT_RD_OFFS)
-#define DDOCR_ODT_WR_OFFS           4
-#define DDOCR_ODT_WR_MASK           (0xf << DDOCR_ODT_WR_OFFS)
-#define DDOCR_ODT_WR(bank)          ((1 << bank) << DDOCR_ODT_WR_OFFS)
-#define DSOCR_ODT_EN_OFFS           8
-#define DSOCR_ODT_EN_MASK           (0x3 << DSOCR_ODT_EN_OFFS)
-/* For ctrl parameters see DDR2 SDRAM ODT Control (High) Register (0x1498) above. */
-#define DSOCR_ODT_EN(ctrl)         	(ctrl << DSOCR_ODT_EN_OFFS)
-#define DSOCR_ODT_SEL_DISABLE	    0	
-#define DSOCR_ODT_SEL_75_OHM	    2	
-#define DSOCR_ODT_SEL_150_OHM	    1
-#define DSOCR_ODT_SEL_50_OHM        3
-#define DSOCR_DQ_ODT_SEL_OFFS       10
-#define DSOCR_DQ_ODT_SEL_MASK       (0x3 << DSOCR_DQ_ODT_SEL_OFFS)
-#define DSOCR_DQ_ODT_SEL(odtSel)    (odtSel << DSOCR_DQ_ODT_SEL_OFFS)
-#define DSOCR_ST_ODT_SEL_OFFS       12
-#define DSOCR_ST_ODT_SEL_MASK       (0x3 << DSOCR_ST_ODT_SEL_OFFS)
-#define DSOCR_ST_ODT_SEL(odtSel)    (odtSel << DSOCR_ST_ODT_SEL_OFFS)
-#define DSOCR_ST_ODT_EN             (1 << 14)
-
-/* DDR SDRAM Initialization Control Register (DSICR) */
-#define DDR_SDRAM_INIT_CTRL_REG	    (MV_DDR_REGS_BASE + 0x1480)
-#define DSICR_INIT_EN		    	(1 << 0)
-#define DSICR_T200_SET		    	(1 << 8)
-
-/* sdram extended mode2 register (SEM2R) */
-#define SDRAM_EXTENDED_MODE2_REG	(MV_DDR_REGS_BASE + 0x148C)
-#define SEM2R_EMRS2_DDR2_OFFS		0
-#define SEM2R_EMRS2_DDR2_MASK		(0x7FFF << SEM2R_EMRS2_DDR2_OFFS)
-
-/* sdram extended mode3 register (SEM3R) */
-#define SDRAM_EXTENDED_MODE3_REG	(MV_DDR_REGS_BASE + 0x1490)
-#define SEM3R_EMRS3_DDR2_OFFS		0
-#define SEM3R_EMRS3_DDR2_MASK		(0x7FFF << SEM3R_EMRS3_DDR2_OFFS)
-
-/* sdram error registers */
-#define SDRAM_ERROR_CAUSE_REG               	(MV_DDR_REGS_BASE + 0x14d0)
-#define SDRAM_ERROR_MASK_REG                	(MV_DDR_REGS_BASE + 0x14d4)
-#define SDRAM_ERROR_DATA_LOW_REG            	(MV_DDR_REGS_BASE + 0x1444)
-#define SDRAM_ERROR_DATA_HIGH_REG           	(MV_DDR_REGS_BASE + 0x1440)
-#define SDRAM_ERROR_ADDR_REG                	(MV_DDR_REGS_BASE + 0x1450)
-#define SDRAM_ERROR_ECC_REG                 	(MV_DDR_REGS_BASE + 0x1448)
-#define SDRAM_CALC_ECC_REG                  	(MV_DDR_REGS_BASE + 0x144c)
-#define SDRAM_ECC_CONTROL_REG               	(MV_DDR_REGS_BASE + 0x1454)
-#define SDRAM_SINGLE_BIT_ERR_CNTR_REG 		(MV_DDR_REGS_BASE + 0x1458)
-#define SDRAM_DOUBLE_BIT_ERR_CNTR_REG 		(MV_DDR_REGS_BASE + 0x145c)
-
-/* SDRAM Error Cause Register (SECR) */
-#define SECR_SINGLE_BIT_ERR			BIT0
-#define SECR_DOUBLE_BIT_ERR			BIT1
-#define SECR_DATA_PATH_PARITY_ERR	BIT2
-/* SDRAM Error Address Register (SEAR) */
-#define SEAR_ERR_TYPE_OFFS			0
-#define SEAR_ERR_TYPE_MASK      	(1 << SEAR_ERR_TYPE_OFFS)
-#define SEAR_ERR_TYPE_SINGLE    	0	
-#define SEAR_ERR_TYPE_DOUBLE    	(1 << SEAR_ERR_TYPE_OFFS)
-#define SEAR_ERR_CS_OFFS			1
-#define SEAR_ERR_CS_MASK			(3 << SEAR_ERR_CS_OFFS)
-#define SEAR_ERR_CS(csNum)			(csNum << SEAR_ERR_CS_OFFS)
-#define SEAR_ERR_ADDR_OFFS      	3
-#define SEAR_ERR_ADDR_MASK      	(0x1FFFFFFF << SEAR_ERR_ADDR_OFFS)
-
-/* SDRAM ECC Control Register (SECR) */
-#define SECR_FORCEECC_OFFS          0
-#define SECR_FORCEECC_MASK          (0xFF << SECR_FORCEECC_OFFS)
-#define SECR_FORCEEN_OFFS           8
-#define SECR_FORCEEN_MASK           (1 << SECR_FORCEEN_OFFS)
-#define SECR_ECC_CALC_MASK          (0 << SECR_FORCEEN_OFFS)
-#define SECR_ECC_USER_MASK          (1 << SECR_FORCEEN_OFFS)
-#define SECR_PERRPROP_EN            BIT9
-#define SECR_CNTMODE_OFFS           10
-#define SECR_CNTMODE_MASK           (1 << SECR_CNTMODE_OFFS)
-#define SECR_ALL_IN_CS0             (0 << SECR_CNTMODE_OFFS)
-#define SECR_NORMAL_COUNTER         (1 << SECR_CNTMODE_OFFS)
-#define SECR_THRECC_OFFS            16
-#define SECR_THRECC_MAX             0xFF
-#define SECR_THRECC_MASK            (SECR_THRECC_MAX << SECR_THRECC_OFFS)
-#define SECR_THRECC(threshold)      (threshold << SECR_THRECC_OFFS)
-
-/* sdram extended mode2 register (SEM2R) */
-#define SDRAM_PHY_REGISTER_FILE_ACCESS	(MV_DDR_REGS_BASE + 0x16A0)
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* __INCmvDramIfRegsh */
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvDramIfStaticInit.h
+++ /dev/null
@@ -1,192 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-
-#ifndef __INCmvDramIfStaticInith
-#define __INCmvDramIfStaticInith
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#ifdef MV_STATIC_DRAM_ON_BOARD
-#define STATIC_DRAM_BANK_1
-#undef	STATIC_DRAM_BANK_2             
-#undef	STATIC_DRAM_BANK_3                         
-#undef 	STATIC_DRAM_BANK_4             
-
-
-#ifdef MV_DIMM_TS256MLQ72V5U
-#define	STATIC_DRAM_BANK_2             
-#define	STATIC_DRAM_BANK_3                         
-#undef 	STATIC_DRAM_BANK_4             
-
-#define STATIC_SDRAM_CONFIG_REG		    0x4724481A  /* offset 0x1400 - DMA reg-0xf1000814 */ 
-#define STATIC_SDRAM_DUNIT_CTRL_REG         0x37707450  /* offset 0x1404 - DMA reg-0xf100081c */ 
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x11A13330  /* offset 0x1408 - DMA reg-0xf1000824 */ 
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x00000601  /* offset 0x140c - DMA reg-0xf1000828 */ 
-#define STATIC_SDRAM_ADDR_CTRL_REG          0x00001CB2  /* offset 0x1410 - DMA reg-0xf1000820 */ 
-#define STATIC_SDRAM_MODE_REG               0x00000642  /* offset 0x141c - DMA reg-0xf1000818 */ 
-#define STATIC_SDRAM_ODT_CTRL_LOW	    0x030C030C /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	    0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    	    0x0000740F /*   0x149c  */  
-#define STATIC_SDRAM_EXT_MODE          	    0x00000404 /*   0x1420  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO         0x00074410 /*   0x1428  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI         0x00007441 /*   0x147C  */  
-
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x3FFF /* size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_RANK1_SIZE_DIMM0       0x3FFF /* size bank1 dimm0   */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x3FFF /* size bank0 dimm1   */ 
-#define STATIC_SDRAM_RANK1_SIZE_DIMM1       0x0	   /* size bank1 dimm1   */ 
-
-#endif /* TS256MLQ72V5U */
-
-
-#ifdef MV_MT9VDDT3272AG
-/* one DIMM 256M  */
-#define STATIC_SDRAM_CONFIG_REG		    0x5820040d  /* offset 0x1400 - DMA reg-0xf1000814 */ 
-#define STATIC_SDRAM_DUNIT_CTRL_REG         0xC4000540  /* offset 0x1404 - DMA reg-0xf100081c */ 
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x01602220  /* offset 0x1408 - DMA reg-0xf1000824 */ 
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x0000000b  /* offset 0x140c - DMA reg-0xf1000828 */ 
-#define STATIC_SDRAM_ADDR_CTRL_REG          0x00000012  /* offset 0x1410 - DMA reg-0xf1000820 */ 
-#define STATIC_SDRAM_MODE_REG               0x00000062  /* offset 0x141c - DMA reg-0xf1000818 */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x0fff /* size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x0    /* size bank0 dimm1   */ 
-
-#endif /* MV_MT9VDDT3272AG */
-
-
-
-#ifdef MV_D27RB12P
-/* 
-Two DIMM 512M + ECC enabled, Registered DIMM  CAS Latency 2.5
-*/
-
-#define STATIC_SDRAM_CONFIG_REG		    0x6826081E  /* offset 0x1400 - DMA reg-0xf1000814 */ 
-#define STATIC_SDRAM_DUNIT_CTRL_REG         0xC5000540  /* offset 0x1404 - DMA reg-0xf100081c */ 
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    0x01501220  /* offset 0x1408 - DMA reg-0xf1000824 */ 
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG   0x00000009  /* offset 0x140c - DMA reg-0xf1000828 */ 
-#define STATIC_SDRAM_ADDR_CTRL_REG          0x00000012  /* offset 0x1410 - DMA reg-0xf1000820 */ 
-#define STATIC_SDRAM_MODE_REG               0x00000062  /* offset 0x141c - DMA reg-0xf1000818 */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0       0x0FFF /* size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_RANK0_SIZE_DIMM1       0x0FFF    /* size bank0 dimm1   */ 
-
-#define STATIC_DRAM_BANK_2             
-
-#define STATIC_DRAM_BANK_3                         
-#define STATIC_DRAM_BANK_4             
-
-#endif /*  mv_D27RB12P  */
-
-#ifdef RD_MV645XX
-
-#define STATIC_MEM_TYPE				MEM_TYPE_DDR2
-#define STATIC_DIMM_INFO_BANK0_SIZE		256
-/* DDR2 boards 256 MB*/
-
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0       	0x00000fff /* size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_CONFIG_REG	     		0x07190618	
-#define STATIC_SDRAM_MODE_REG	     		0x00000432	
-#define STATIC_SDRAM_DUNIT_CTRL_REG     	0xf4a03440
-#define STATIC_SDRAM_ADDR_CTRL_REG	     	0x00000022
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG    	0x11712220
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG	0x00000504
-#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000
-#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000780f
-#define STATIC_SDRAM_EXT_MODE          		0x00000440
-#define STATIC_SDRAM_DDR2_TIMING_LO         	0x00063300
-#define STATIC_SDRAM_DDR2_TIMING_HI         	0x00006330
-#endif /* RD_MV645XX */
-
-#ifdef MV_DIMM_M3783354CZ3_CE6 
-
-#define STATIC_SDRAM_RANK0_SIZE_DIMM0		0x00000FFF /* 0x2010 size bank0 dimm0   - DMA reg-0xf1000810 */ 
-#define STATIC_SDRAM_CONFIG_REG	     		0x07190618 /*   0x1400  */ 
-#define STATIC_SDRAM_MODE_REG	     		0x00000432 /*   0x141c  */  
-#define STATIC_SDRAM_DUNIT_CTRL_REG     	0xf4a03440 /*   0x1404  */  
-#define STATIC_SDRAM_ADDR_CTRL_REG	     	0x00000022 /*   0x1410  */  
-#define STATIC_SDRAM_TIMING_CTRL_LOW_REG	0x11712220 /*   0x1408  */  
-#define STATIC_SDRAM_TIMING_CTRL_HIGH_REG	0x00000504 /*   0x140c  */  
-#define STATIC_SDRAM_ODT_CTRL_LOW	     	0x84210000 /*   0x1494  */  
-#define STATIC_SDRAM_ODT_CTRL_HI	     	0x00000000 /*   0x1498  */  
-#define STATIC_SDRAM_DUNIT_ODT_CTRL    		0x0000780f /*   0x149c  */  
-#define STATIC_SDRAM_EXT_MODE          		0x00000440 /*   0x1420  */  
-#define STATIC_SDRAM_DDR2_TIMING_LO		0x00063300 /*   0x1428  */  
-#define STATIC_SDRAM_DDR2_TIMING_HI		0x00006330 /*   0x147C  */  
-
-#endif /* MV_DIMM_M3783354CZ3_CE6 */
-
-#endif /* MV_STATIC_DRAM_ON_BOARD */
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif /* __INCmvDramIfStaticInith */
-
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/mvSysDdr.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef __mvSysDdr_h__
-#define __mvSysDdr_h__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/*******************************************************************************
-* mvSysDdrSpdRead
-*
-* DESCRIPTION:
-*	System interface for reading DDR SPD contents.
-*
-* INPUT:
-*       data:	Buffer to read data into.
-*       size:	Number of bytes to read.
-*
-* OUTPUT:
-*       data:	SPD data.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*
-*******************************************************************************/
-MV_STATUS mvSysDdrSpdRead(MV_U8 *data, MV_U32 size);
-
-
-/*******************************************************************************
-* mvSysDdrSpdWrite
-*
-* DESCRIPTION:
-*	System interface for writing DDR SPD contents.
-*
-* INPUT:
-*       data:	Buffer holding the data to be written.
-*       size:	Number of bytes to write.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*
-*******************************************************************************/
-MV_STATUS mvSysDdrSpdWrite(MV_U8 *data, MV_U32 size);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/spd/mvSpd.c
+++ /dev/null
@@ -1,1460 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#include "mvCommon.h"
-#include "mvOs.h"
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "mvSysRtcConfig.h"
-#include "ddr2_3/mvDramIf.h"
-#include "mvSpd.h"
-#include "boardEnv/mvBoardEnvLib.h"
-#include "ddr2_3/mvSysDdr.h"
-
-/* #define MV_DEBUG */
-#ifdef MV_DEBUG
-#define DB(x) x
-#else
-#define DB(x)
-#endif
-
-static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo, 
-                                            MV_DRAM_BANK_INFO *pBankInfo);
-static MV_U32  cas2ps(MV_U8 spd_byte);
-/*******************************************************************************
-* mvDramBankGet - Get the DRAM bank paramters.
-*
-* DESCRIPTION:
-*       This function retrieves DRAM bank parameters as described in 
-*       DRAM_BANK_INFO struct to the controller DRAM unit. In case the board 
-*       has its DRAM on DIMMs it will use its EEPROM to extract SPD data
-*       from it. Otherwise, if the DRAM is soldered on board, the function 
-*       should insert its bank information into MV_DRAM_BANK_INFO struct.
-*
-* INPUT:
-*       bankNum  - Board DRAM bank number.
-*
-* OUTPUT:
-*       pBankInfo  - DRAM bank information struct.
-*
-* RETURN:
-*       MV_FAIL - Bank parameters could not be read.
-*
-*******************************************************************************/
-MV_STATUS mvDramBankInfoGet(MV_U32 bankNum, MV_DRAM_BANK_INFO *pBankInfo)
-{
-    MV_DIMM_INFO dimmInfo;
-
-    DB(mvOsPrintf("Dram: mvDramBankInfoGet bank %d\n", bankNum)); 
-    /* zero pBankInfo structure */
-
-    if((NULL == pBankInfo) || (bankNum >= MV_DRAM_MAX_CS ))
-    {
-        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n")); 
-        return MV_BAD_PARAM;
-    }
-    memset(pBankInfo, 0, sizeof(*pBankInfo));
-
-	if ( MV_OK != dimmSpdGet((MV_U32)(bankNum/2), &dimmInfo))
-	{
-		DB(mvOsPrintf("Dram: ERR dimmSpdGet failed to get dimm info \n"));
-		return MV_FAIL;
-	}
-	if ((dimmInfo.numOfModuleBanks == 1) && ((bankNum % 2) == 1))
-	{
-		DB(mvOsPrintf("Dram: ERR dimmSpdGet. Can't find DIMM bank 2 \n"));
-		return MV_FAIL;
-	}
-	/* convert Dimm info to Bank info */
-    cpyDimm2BankInfo(&dimmInfo, pBankInfo);
-    return MV_OK;
-}
-
-/*******************************************************************************
-* cpyDimm2BankInfo - Convert a Dimm info struct into a bank info struct.
-*
-* DESCRIPTION:
-*       Convert a Dimm info struct into a bank info struct.
-*
-* INPUT:
-*       pDimmInfo - DIMM information structure.
-*
-* OUTPUT:
-*       pBankInfo  - DRAM bank information struct.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-static MV_VOID cpyDimm2BankInfo(MV_DIMM_INFO *pDimmInfo, 
-                                                MV_DRAM_BANK_INFO *pBankInfo)
-{
-    pBankInfo->memoryType = pDimmInfo->memoryType;        
-
-    /* DIMM dimensions */
-    pBankInfo->numOfRowAddr = pDimmInfo->numOfRowAddr;
-    pBankInfo->numOfColAddr = pDimmInfo->numOfColAddr;
-    pBankInfo->dataWidth = pDimmInfo->dataWidth;
-    pBankInfo->errorCheckType = pDimmInfo->errorCheckType;             
-    pBankInfo->sdramWidth = pDimmInfo->sdramWidth;
-    pBankInfo->errorCheckDataWidth = pDimmInfo->errorCheckDataWidth;   
-    pBankInfo->numOfBanksOnEachDevice = pDimmInfo->numOfBanksOnEachDevice;
-    pBankInfo->suportedCasLatencies = pDimmInfo->suportedCasLatencies;
-    pBankInfo->refreshInterval = pDimmInfo->refreshInterval;
- 
-    /* DIMM timing parameters */
-    pBankInfo->minCycleTimeAtMaxCasLatPs = pDimmInfo->minCycleTimeAtMaxCasLatPs;
-    pBankInfo->minCycleTimeAtMaxCasLatMinus1Ps = 
-                                    pDimmInfo->minCycleTimeAtMaxCasLatMinus1Ps;
-    pBankInfo->minCycleTimeAtMaxCasLatMinus2Ps = 
-                                    pDimmInfo->minCycleTimeAtMaxCasLatMinus2Ps;
-
-    pBankInfo->minRowPrechargeTime     = pDimmInfo->minRowPrechargeTime;     
-    pBankInfo->minRowActiveToRowActive = pDimmInfo->minRowActiveToRowActive;
-    pBankInfo->minRasToCasDelay        = pDimmInfo->minRasToCasDelay;       
-    pBankInfo->minRasPulseWidth        = pDimmInfo->minRasPulseWidth;       
-    pBankInfo->minWriteRecoveryTime    = pDimmInfo->minWriteRecoveryTime;
-    pBankInfo->minWriteToReadCmdDelay  = pDimmInfo->minWriteToReadCmdDelay;
-    pBankInfo->minReadToPrechCmdDelay  = pDimmInfo->minReadToPrechCmdDelay;
-    pBankInfo->minRefreshToActiveCmd   = pDimmInfo->minRefreshToActiveCmd;
-               
-    /* Parameters calculated from the extracted DIMM information */
-    pBankInfo->size = pDimmInfo->size/pDimmInfo->numOfModuleBanks;
-    pBankInfo->deviceDensity = pDimmInfo->deviceDensity;              
-    pBankInfo->numberOfDevices = pDimmInfo->numberOfDevices /
-                                 pDimmInfo->numOfModuleBanks;
- 
-    /* DIMM attributes (MV_TRUE for yes) */
-
-    if ((pDimmInfo->memoryType == MEM_TYPE_SDRAM) ||
-        (pDimmInfo->memoryType == MEM_TYPE_DDR1)   )
-    {   
-        if (pDimmInfo->dimmAttributes & BIT1)
-            pBankInfo->registeredAddrAndControlInputs = MV_TRUE;
-        else
-            pBankInfo->registeredAddrAndControlInputs = MV_FALSE;
-    }
-    else /* pDimmInfo->memoryType == MEM_TYPE_DDR2 */
-    {
-        if (pDimmInfo->dimmTypeInfo & (BIT0 | BIT4))
-            pBankInfo->registeredAddrAndControlInputs = MV_TRUE;
-        else
-            pBankInfo->registeredAddrAndControlInputs = MV_FALSE;
-    }
-
-    return;
-}
-/*******************************************************************************
-* dimmSpdCpy - Cpy SPD parameters from dimm 0 to dimm 1.
-*
-* DESCRIPTION:
-*       Read the DIMM SPD parameters from dimm 0 into dimm 1 SPD.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if function could read DIMM parameters, MV_FALSE otherwise.
-*
-*******************************************************************************/
-MV_STATUS dimmSpdCpy(MV_VOID)
-{
-    MV_U32 i;
-    MV_U32 spdChecksum;
-     
-    MV_U8 data[SPD_SIZE];
-
-    /* zero dimmInfo structure */
-    memset(data, 0, SPD_SIZE);
-
-    /* read the dimm eeprom */
-    DB(mvOsPrintf("DRAM: Read Dimm eeprom\n"));
-
-    if (MV_OK != mvSysDdrSpdRead(data, SPD_SIZE) )
-    {
-        DB(mvOsPrintf("DRAM: ERR. no DIMM in dimmNum 0\n"));
-        return MV_FAIL;
-    }
-
-    DB(puts("DRAM: Reading dimm info succeded.\n"));
-    
-    /* calculate SPD checksum */
-    spdChecksum = 0;
-    
-    for(i = 0 ; i <= 62 ; i++)
-    {
-        spdChecksum += data[i];
-    }
-    
-    if ((spdChecksum & 0xff) != data[63])
-    {
-        DB(mvOsPrintf("DRAM: Warning. Wrong SPD Checksum %2x, expValue=%2x\n",
-                            (MV_U32)(spdChecksum & 0xff), data[63]));
-    }
-    else
-    {
-        DB(mvOsPrintf("DRAM: SPD Checksum ok!\n"));
-    }
-
-    /* copy the SPD content 1:1 into the DIMM 1 SPD */
-    for(i = 0 ; i < SPD_SIZE ; i++)
-    {
-	if( MV_OK != mvSysDdrSpdWrite(&data[i], 1) )
-	{
-	    mvOsPrintf("DRAM: ERR. no DIMM in dimmNum 1 byte %d \n",i);
-	    return MV_FAIL;
-	}
-	mvOsDelay(5);
-    }
-    
-    DB(puts("DRAM: Reading dimm info succeded.\n"));
-    return MV_OK;
-}
-
-/*******************************************************************************
-* dimmSpdGet - Get the SPD parameters.
-*
-* DESCRIPTION:
-*       Read the DIMM SPD parameters into given struct parameter.
-*
-* INPUT:
-*       dimmNum - DIMM number. See MV_BOARD_DIMM_NUM enumerator.
-*
-* OUTPUT:
-*       pDimmInfo - DIMM information structure.
-*
-* RETURN:
-*       MV_TRUE if function could read DIMM parameters, MV_FALSE otherwise.
-*
-*******************************************************************************/
-MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo)
-{
-    MV_U32 i;
-    MV_U32 density = 1;
-    MV_U32 spdChecksum;
-     
-    MV_U8 data[SPD_SIZE];
-
-    if((NULL == pDimmInfo)|| (dimmNum >= MAX_DIMM_NUM))
-    {
-        DB(mvOsPrintf("Dram: mvDramBankInfoGet bad params \n")); 
-        return MV_BAD_PARAM;
-    }
-
-    /* zero dimmInfo structure */
-    memset(data, 0, SPD_SIZE);
-
-    /* read the dimm eeprom */
-    DB(mvOsPrintf("DRAM: Read Dimm eeprom\n"));
-    if( MV_OK != mvSysDdrSpdRead(data, SPD_SIZE) )
-    {
-        DB(mvOsPrintf("DRAM: ERR. no DIMM in dimmNum %d \n", dimmNum));
-        return MV_FAIL;
-    }
-    DB(puts("DRAM: Reading dimm info succeded.\n"));
-    
-    /* calculate SPD checksum */
-    spdChecksum = 0;
-    
-        for(i = 0 ; i <= 62 ; i++)
-        {
-        spdChecksum += data[i];
-    }
-    
-    if ((spdChecksum & 0xff) != data[63])
-    {
-        DB(mvOsPrintf("DRAM: Warning. Wrong SPD Checksum %2x, expValue=%2x\n",
-                            (MV_U32)(spdChecksum & 0xff), data[63]));
-    }
-    else
-    {
-        DB(mvOsPrintf("DRAM: SPD Checksum ok!\n"));
-    }
-
-    /* copy the SPD content 1:1 into the dimmInfo structure*/
-    for(i = 0 ; i < SPD_SIZE ; i++)
-    {
-        pDimmInfo->spdRawData[i] = data[i];
-        DB(mvOsPrintf("SPD-EEPROM Byte %3d = %3x (%3d)\n",i, data[i], data[i]));
-    }
-
-    DB(mvOsPrintf("DRAM SPD Information:\n"));
-
-    /* Memory type (DDR / SDRAM) */
-    switch (data[DIMM_MEM_TYPE])
-    {
-        case (DIMM_MEM_TYPE_SDRAM):
-            pDimmInfo->memoryType = MEM_TYPE_SDRAM;
-            DB(mvOsPrintf("DRAM Memeory type SDRAM\n"));
-            break;
-        case (DIMM_MEM_TYPE_DDR1):
-            pDimmInfo->memoryType = MEM_TYPE_DDR1;
-            DB(mvOsPrintf("DRAM Memeory type DDR1\n"));
-            break;
-        case (DIMM_MEM_TYPE_DDR2):
-            pDimmInfo->memoryType = MEM_TYPE_DDR2;
-            DB(mvOsPrintf("DRAM Memeory type DDR2\n"));
-            break;
-        default:
-            mvOsPrintf("ERROR: Undefined memory type!\n");
-            return MV_ERROR;
-    }
-
-    
-    /* Number Of Row Addresses */
-    pDimmInfo->numOfRowAddr = data[DIMM_ROW_NUM];
-    DB(mvOsPrintf("DRAM numOfRowAddr[3]         %d\n",pDimmInfo->numOfRowAddr));
-        
-    /* Number Of Column Addresses */
-    pDimmInfo->numOfColAddr = data[DIMM_COL_NUM];
-    DB(mvOsPrintf("DRAM numOfColAddr[4]         %d\n",pDimmInfo->numOfColAddr));
-        
-    /* Number Of Module Banks */
-    pDimmInfo->numOfModuleBanks = data[DIMM_MODULE_BANK_NUM];
-    DB(mvOsPrintf("DRAM numOfModuleBanks[5]     0x%x\n", 
-                                                  pDimmInfo->numOfModuleBanks));
-        
-    /* Number of module banks encoded differently for DDR2 */
-    if (pDimmInfo->memoryType == MEM_TYPE_DDR2)
-        pDimmInfo->numOfModuleBanks = (pDimmInfo->numOfModuleBanks & 0x7)+1;
-
-    /* Data Width */
-    pDimmInfo->dataWidth = data[DIMM_DATA_WIDTH];
-    DB(mvOsPrintf("DRAM dataWidth[6]            0x%x\n", pDimmInfo->dataWidth));
-        
-    /* Minimum Cycle Time At Max CasLatancy */
-    pDimmInfo->minCycleTimeAtMaxCasLatPs = cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS]);
-
-    /* Error Check Type */
-    pDimmInfo->errorCheckType = data[DIMM_ERR_CHECK_TYPE];
-    DB(mvOsPrintf("DRAM errorCheckType[11]      0x%x\n", 
-                                                    pDimmInfo->errorCheckType));
-
-    /* Refresh Interval */
-    pDimmInfo->refreshInterval = data[DIMM_REFRESH_INTERVAL];
-    DB(mvOsPrintf("DRAM refreshInterval[12]     0x%x\n", 
-                                                   pDimmInfo->refreshInterval));
-    
-    /* Sdram Width */
-    pDimmInfo->sdramWidth = data[DIMM_SDRAM_WIDTH];
-    DB(mvOsPrintf("DRAM sdramWidth[13]          0x%x\n",pDimmInfo->sdramWidth));
-        
-    /* Error Check Data Width */
-    pDimmInfo->errorCheckDataWidth = data[DIMM_ERR_CHECK_DATA_WIDTH];
-    DB(mvOsPrintf("DRAM errorCheckDataWidth[14] 0x%x\n", 
-                                               pDimmInfo->errorCheckDataWidth));
-    
-    /* Burst Length Supported */
-    /*     SDRAM/DDR1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  * 
-                    *********************************************************/ 
-    /*     DDR2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  * 
-                    *********************************************************/ 
-
-    pDimmInfo->burstLengthSupported = data[DIMM_BURST_LEN_SUP];
-    DB(mvOsPrintf("DRAM burstLengthSupported[16] 0x%x\n", 
-                                              pDimmInfo->burstLengthSupported));
-    
-    /* Number Of Banks On Each Device */
-    pDimmInfo->numOfBanksOnEachDevice = data[DIMM_DEV_BANK_NUM];
-    DB(mvOsPrintf("DRAM numOfBanksOnEachDevice[17] 0x%x\n", 
-                                            pDimmInfo->numOfBanksOnEachDevice));
-    
-    /* Suported Cas Latencies */
-                   
-    /*      SDRAM:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  * 
-            ********************************************************/ 
-
-    /*     DDR 1:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  * 
-            *********************************************************/
-
-    /*     DDR 2:
-            *******-******-******-******-******-******-******-******* 
-            * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-            *******-******-******-******-******-******-******-******* 
-    CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
-            *********************************************************/
-    
-    pDimmInfo->suportedCasLatencies = data[DIMM_SUP_CAL];
-    DB(mvOsPrintf("DRAM suportedCasLatencies[18]    0x%x\n", 
-                                              pDimmInfo->suportedCasLatencies));
-
-    /* For DDR2 only, get the DIMM type information */
-    if (pDimmInfo->memoryType == MEM_TYPE_DDR2)
-    {   
-        pDimmInfo->dimmTypeInfo = data[DIMM_DDR2_TYPE_INFORMATION];
-        DB(mvOsPrintf("DRAM dimmTypeInfo[20] (DDR2) 0x%x\n", 
-                                                      pDimmInfo->dimmTypeInfo));
-    }
-
-    /* SDRAM Modules Attributes */
-    pDimmInfo->dimmAttributes = data[DIMM_BUF_ADDR_CONT_IN];
-    DB(mvOsPrintf("DRAM dimmAttributes[21]          0x%x\n",    
-                                                    pDimmInfo->dimmAttributes));
-    
-    /* Minimum Cycle Time At Max CasLatancy Minus 1*/
-    pDimmInfo->minCycleTimeAtMaxCasLatMinus1Ps = 
-                                    cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS_MINUS1]);
-
-    /* Minimum Cycle Time At Max CasLatancy Minus 2*/
-    pDimmInfo->minCycleTimeAtMaxCasLatMinus2Ps = 
-                                    cas2ps(data[DIMM_MIN_CC_AT_MAX_CAS_MINUS2]);
-
-    pDimmInfo->minRowPrechargeTime = data[DIMM_MIN_ROW_PRECHARGE_TIME];
-    DB(mvOsPrintf("DRAM minRowPrechargeTime[27]     0x%x\n", 
-                                               pDimmInfo->minRowPrechargeTime));
-    pDimmInfo->minRowActiveToRowActive = data[DIMM_MIN_ROW_ACTIVE_TO_ROW_ACTIVE];
-    DB(mvOsPrintf("DRAM minRowActiveToRowActive[28] 0x%x\n", 
-                                           pDimmInfo->minRowActiveToRowActive));
-    pDimmInfo->minRasToCasDelay = data[DIMM_MIN_RAS_TO_CAS_DELAY];
-    DB(mvOsPrintf("DRAM minRasToCasDelay[29]        0x%x\n", 
-                                                  pDimmInfo->minRasToCasDelay));
-    pDimmInfo->minRasPulseWidth = data[DIMM_MIN_RAS_PULSE_WIDTH];
-    DB(mvOsPrintf("DRAM minRasPulseWidth[30]        0x%x\n", 
-                                                  pDimmInfo->minRasPulseWidth));
-        
-    /* DIMM Bank Density */
-    pDimmInfo->dimmBankDensity = data[DIMM_BANK_DENSITY];
-    DB(mvOsPrintf("DRAM dimmBankDensity[31]         0x%x\n", 
-                                                   pDimmInfo->dimmBankDensity));
-
-    /* Only DDR2 includes Write Recovery Time field. Other SDRAM ignore     */
-    pDimmInfo->minWriteRecoveryTime = data[DIMM_MIN_WRITE_RECOVERY_TIME];
-    DB(mvOsPrintf("DRAM minWriteRecoveryTime[36]    0x%x\n", 
-                                              pDimmInfo->minWriteRecoveryTime));
-    
-    /* Only DDR2 includes Internal Write To Read Command Delay field.       */
-    pDimmInfo->minWriteToReadCmdDelay = data[DIMM_MIN_WRITE_TO_READ_CMD_DELAY];
-    DB(mvOsPrintf("DRAM minWriteToReadCmdDelay[37]  0x%x\n", 
-                                            pDimmInfo->minWriteToReadCmdDelay));
-    
-    /* Only DDR2 includes Internal Read To Precharge Command Delay field.   */
-    pDimmInfo->minReadToPrechCmdDelay = data[DIMM_MIN_READ_TO_PRECH_CMD_DELAY];
-    DB(mvOsPrintf("DRAM minReadToPrechCmdDelay[38]  0x%x\n",    
-                                            pDimmInfo->minReadToPrechCmdDelay));
-    
-    /* Only DDR2 includes Minimum Refresh to Activate/Refresh Command field */
-    pDimmInfo->minRefreshToActiveCmd = data[DIMM_MIN_REFRESH_TO_ACTIVATE_CMD];
-    DB(mvOsPrintf("DRAM minRefreshToActiveCmd[42]   0x%x\n", 
-                                             pDimmInfo->minRefreshToActiveCmd));
-                 
-    /* calculating the sdram density. Representing device density from      */
-    /* bit 20 to allow representation of 4GB and above.                     */
-    /* For example, if density is 512Mbit 0x20000000, will be represent in  */
-    /* deviceDensity by 0x20000000 >> 16 --> 0x00000200. Another example    */
-    /* is density 8GB 0x200000000 >> 16 --> 0x00002000.                     */
-    density = (1 << ((pDimmInfo->numOfRowAddr + pDimmInfo->numOfColAddr) - 20));
-    pDimmInfo->deviceDensity = density * 
-                                pDimmInfo->numOfBanksOnEachDevice * 
-                                pDimmInfo->sdramWidth;
-    DB(mvOsPrintf("DRAM deviceDensity           %d\n",pDimmInfo->deviceDensity));
-    
-    /* Number of devices includeing Error correction */
-    pDimmInfo->numberOfDevices = (pDimmInfo->dataWidth/pDimmInfo->sdramWidth) * 
-                                  pDimmInfo->numOfModuleBanks;
-    DB(mvOsPrintf("DRAM numberOfDevices         %d\n",  
-                                                   pDimmInfo->numberOfDevices));
-
-    pDimmInfo->size = 0; 
-
-    /* Note that pDimmInfo->size is in MB units */
-    if (pDimmInfo->memoryType == MEM_TYPE_SDRAM)
-    {
-        if (pDimmInfo->dimmBankDensity & BIT0)
-            pDimmInfo->size += 1024;                /* Equal to 1GB     */
-        else if (pDimmInfo->dimmBankDensity & BIT1)
-            pDimmInfo->size += 8;                   /* Equal to 8MB     */
-        else if (pDimmInfo->dimmBankDensity & BIT2)
-            pDimmInfo->size += 16;                  /* Equal to 16MB    */
-        else if (pDimmInfo->dimmBankDensity & BIT3)
-            pDimmInfo->size += 32;                  /* Equal to 32MB    */
-        else if (pDimmInfo->dimmBankDensity & BIT4)
-            pDimmInfo->size += 64;                  /* Equal to 64MB    */
-        else if (pDimmInfo->dimmBankDensity & BIT5)
-            pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
-            pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
-            pDimmInfo->size += 512;                 /* Equal to 512MB   */
-    }
-    else if (pDimmInfo->memoryType == MEM_TYPE_DDR1)
-    {
-        if (pDimmInfo->dimmBankDensity & BIT0)
-            pDimmInfo->size += 1024;                /* Equal to 1GB     */
-        else if (pDimmInfo->dimmBankDensity & BIT1)
-            pDimmInfo->size += 2048;                /* Equal to 2GB     */
-        else if (pDimmInfo->dimmBankDensity & BIT2)
-            pDimmInfo->size += 16;                  /* Equal to 16MB    */
-        else if (pDimmInfo->dimmBankDensity & BIT3)
-            pDimmInfo->size += 32;                  /* Equal to 32MB    */
-        else if (pDimmInfo->dimmBankDensity & BIT4)
-            pDimmInfo->size += 64;                  /* Equal to 64MB    */
-        else if (pDimmInfo->dimmBankDensity & BIT5)
-            pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
-            pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
-            pDimmInfo->size += 512;                 /* Equal to 512MB   */
-    }
-    else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
-    {
-        if (pDimmInfo->dimmBankDensity & BIT0)
-            pDimmInfo->size += 1024;                /* Equal to 1GB     */
-        else if (pDimmInfo->dimmBankDensity & BIT1)
-            pDimmInfo->size += 2048;                /* Equal to 2GB     */
-        else if (pDimmInfo->dimmBankDensity & BIT2)
-            pDimmInfo->size += 4096;                /* Equal to 4GB     */
-        else if (pDimmInfo->dimmBankDensity & BIT3)
-            pDimmInfo->size += 8192;                /* Equal to 8GB     */
-        else if (pDimmInfo->dimmBankDensity & BIT4)
-            pDimmInfo->size += 16384;               /* Equal to 16GB    */
-        else if (pDimmInfo->dimmBankDensity & BIT5)
-            pDimmInfo->size += 128;                 /* Equal to 128MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT6) 
-            pDimmInfo->size += 256;                 /* Equal to 256MB   */
-        else if (pDimmInfo->dimmBankDensity & BIT7) 
-            pDimmInfo->size += 512;                 /* Equal to 512MB   */
-    }
-    
-    pDimmInfo->size *= pDimmInfo->numOfModuleBanks;
-
-    DB(mvOsPrintf("Dram: dimm size    %dMB \n",pDimmInfo->size));
-
-    return MV_OK;
-}
-
-/*******************************************************************************
-* dimmSpdPrint - Print the SPD parameters.
-*
-* DESCRIPTION:
-*       Print the Dimm SPD parameters.
-*
-* INPUT:
-*       pDimmInfo - DIMM information structure.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-MV_VOID dimmSpdPrint(MV_U32 dimmNum, MV_U32 sysClock)
-{
-    MV_DIMM_INFO dimmInfo;
-    MV_U32  i, temp = 0;
-    MV_U32  k, maskLeftOfPoint = 0, maskRightOfPoint = 0;
-    MV_U32  rightOfPoint = 0,leftOfPoint = 0, div, time_tmp, shift;
-    MV_U32  busClkPs;
-    MV_U8   trp_clocks=0, trcd_clocks, tras_clocks, trrd_clocks,
-            temp_buf[40], *spdRawData;
-
-    busClkPs = 1000000000 / (sysClock / 100);  /* in 10 ps units */
-
-    spdRawData = dimmInfo.spdRawData;
-    
-    if(MV_OK != dimmSpdGet(dimmNum, &dimmInfo))
-    {
-        mvOsOutput("ERROR: Could not read SPD information!\n");
-        return;
-    }
-
-    /* find Manufactura of Dimm Module */
-    mvOsOutput("\nManufacturer's JEDEC ID Code:   ");
-    for(i = 0 ; i < DIMM_MODULE_MANU_SIZE ; i++)
-    {
-        mvOsOutput("%x",spdRawData[DIMM_MODULE_MANU_OFFS + i]);
-    }
-    mvOsOutput("\n");
-
-    /* Manufacturer's Specific Data */
-    for(i = 0 ; i < DIMM_MODULE_ID_SIZE ; i++)
-    {
-        temp_buf[i] = spdRawData[DIMM_MODULE_ID_OFFS + i];
-    }
-    mvOsOutput("Manufacturer's Specific Data:   %s\n", temp_buf);
-
-    /* Module Part Number */
-    for(i = 0 ; i < DIMM_MODULE_VEN_SIZE ; i++)
-    {
-        temp_buf[i] = spdRawData[DIMM_MODULE_VEN_OFFS + i];
-    }
-    mvOsOutput("Module Part Number:             %s\n", temp_buf);
-
-    /* Module Serial Number */
-    for(i = 0; i < sizeof(MV_U32); i++)
-    {
-    	temp |= spdRawData[95+i] << 8*i;
-    }
-    mvOsOutput("DIMM Serial No.                 %ld (%lx)\n", (long)temp, 
-                                    (long)temp);
-
-    /* find Manufac-Data of Dimm Module */
-    mvOsOutput("Manufactoring Date:             Year 20%d%d/ ww %d%d\n", 
-                        ((spdRawData[93] & 0xf0) >> 4), (spdRawData[93] & 0xf), 
-                        ((spdRawData[94] & 0xf0) >> 4), (spdRawData[94] & 0xf)); 
-    /* find modul_revision of Dimm Module */
-    mvOsOutput("Module Revision:                %d.%d\n", 
-               spdRawData[62]/10, spdRawData[62]%10); 
-
-    /* find manufac_place of Dimm Module */
-    mvOsOutput("manufac_place:                  %d\n", spdRawData[72]);
-    
-    /* go over the first 35 I2C data bytes */
-    for(i = 2 ; i <= 35 ; i++)
-       switch(i)
-        {
-            case 2:  /* Memory type (DDR1/2 / SDRAM) */
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                    mvOsOutput("Dram Type is:                   SDRAM\n");
-                else if (dimmInfo.memoryType == MEM_TYPE_DDR1)
-                    mvOsOutput("Dram Type is:                   SDRAM DDR1\n");
-                else if (dimmInfo.memoryType == MEM_TYPE_DDR2)
-                    mvOsOutput("Dram Type is:                   SDRAM DDR2\n");
-                else
-                    mvOsOutput("Dram Type unknown\n");
-                break;
-/*----------------------------------------------------------------------------*/
-
-            case 3:  /* Number Of Row Addresses */
-                mvOsOutput("Module Number of row addresses: %d\n", 
-                                                        dimmInfo.numOfRowAddr);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 4:  /* Number Of Column Addresses */
-                mvOsOutput("Module Number of col addresses: %d\n", 
-                                                        dimmInfo.numOfColAddr);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 5:  /* Number Of Module Banks */
-                mvOsOutput("Number of Banks on Mod.:        %d\n",  
-                                                    dimmInfo.numOfModuleBanks);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 6:  /* Data Width */
-                mvOsOutput("Module Data Width:              %d bit\n",  
-                                                           dimmInfo.dataWidth);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 8:  /* Voltage Interface */
-                switch(spdRawData[i])
-                {
-                    case 0x0:
-                        mvOsOutput("Module is               TTL_5V_TOLERANT\n");
-                        break;
-                    case 0x1:
-                        mvOsOutput("Module is               LVTTL\n");
-                        break;
-                    case 0x2:
-                        mvOsOutput("Module is               HSTL_1_5V\n");
-                        break;
-                    case 0x3:
-                        mvOsOutput("Module is               SSTL_3_3V\n");
-                        break;
-                    case 0x4:
-                        mvOsOutput("Module is               SSTL_2_5V\n");
-                        break;
-                    case 0x5:
-                        if (dimmInfo.memoryType != MEM_TYPE_SDRAM)
-                        {
-                            mvOsOutput("Module is                 SSTL_1_8V\n");
-                            break;
-                        }
-                    default:
-                        mvOsOutput("Module is               VOLTAGE_UNKNOWN\n");
-                        break;
-                }
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 9:  /* Minimum Cycle Time At Max CasLatancy */
-                leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
-                rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                
-                /* DDR2 addition of right of point */
-                if ((spdRawData[i] & 0x0f) == 0xA)
-                {
-                    rightOfPoint = 25;
-                }
-                if ((spdRawData[i] & 0x0f) == 0xB)
-                {
-                    rightOfPoint = 33;
-                }
-                if ((spdRawData[i] & 0x0f) == 0xC)
-                {
-                    rightOfPoint = 66;
-                }
-                if ((spdRawData[i] & 0x0f) == 0xD)
-                {
-                    rightOfPoint = 75;
-                }
-                mvOsOutput("Minimum Cycle Time At Max CL:   %d.%d [ns]\n",
-                                                    leftOfPoint, rightOfPoint);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 10: /* Clock To Data Out */
-                div = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 10:100;
-                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
-                                                      ((spdRawData[i] & 0x0f));
-                leftOfPoint     = time_tmp / div;
-                rightOfPoint    = time_tmp % div;
-                mvOsOutput("Clock To Data Out:              %d.%d [ns]\n",
-                                                    leftOfPoint, rightOfPoint);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 11: /* Error Check Type */
-                mvOsOutput("Error Check Type (0=NONE):      %d\n", 
-                                                      dimmInfo.errorCheckType);
-                break;
-/*----------------------------------------------------------------------------*/
-
-            case 12: /* Refresh Interval */
-                mvOsOutput("Refresh Rate:                   %x\n", 
-                                                     dimmInfo.refreshInterval);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 13: /* Sdram Width */
-                mvOsOutput("Sdram Width:                    %d bits\n",     
-                                                          dimmInfo.sdramWidth);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 14: /* Error Check Data Width */
-                mvOsOutput("Error Check Data Width:         %d bits\n", 
-                                                 dimmInfo.errorCheckDataWidth);
-                break;
-/*----------------------------------------------------------------------------*/
-
-           case 15: /* Minimum Clock Delay is unsupported */
-                if ((dimmInfo.memoryType == MEM_TYPE_SDRAM) ||
-                    (dimmInfo.memoryType == MEM_TYPE_DDR1))
-                {
-                    mvOsOutput("Minimum Clk Delay back to back: %d\n", 
-                                                                spdRawData[i]);
-                }
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 16: /* Burst Length Supported */
-    /*     SDRAM/DDR1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   |  2   |   1  * 
-                    *********************************************************/ 
-    /*     DDR2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-    burst length =  * Page | TBD  | TBD  | TBD  |  8   |  4   | TBD  | TBD  * 
-                    *********************************************************/ 
-                mvOsOutput("Burst Length Supported: ");
-                if ((dimmInfo.memoryType == MEM_TYPE_SDRAM) ||
-                    (dimmInfo.memoryType == MEM_TYPE_DDR1))
-                {
-                    if (dimmInfo.burstLengthSupported & BIT0)
-                        mvOsOutput("1, ");
-                    if (dimmInfo.burstLengthSupported & BIT1)
-                        mvOsOutput("2, ");
-                }
-                if (dimmInfo.burstLengthSupported & BIT2)
-                    mvOsOutput("4, ");
-                if (dimmInfo.burstLengthSupported & BIT3) 
-                    mvOsOutput("8, ");
-                
-                mvOsOutput(" Bit \n");
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 17: /* Number Of Banks On Each Device */
-                mvOsOutput("Number Of Banks On Each Chip:   %d\n",  
-                                              dimmInfo.numOfBanksOnEachDevice);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 18: /* Suported Cas Latencies */
-                   
-            /*      SDRAM:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  |  7   |  6   |  5   |  4   |  3   |   2  |   1  * 
-                    ********************************************************/ 
-
-            /*     DDR 1:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  |  4   | 3.5  |   3  | 2.5  |  2   | 1.5  |   1  * 
-                    *********************************************************/
-
-            /*     DDR 2:
-                    *******-******-******-******-******-******-******-******* 
-                    * bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 * 
-                    *******-******-******-******-******-******-******-******* 
-            CAS =   * TBD  | TBD  |  5   |  4   |  3   |  2   | TBD  | TBD  * 
-                    *********************************************************/
-
-                mvOsOutput("Suported Cas Latencies: (CL) 			");
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    for (k = 0; k <=7; k++)
-                    {
-                        if (dimmInfo.suportedCasLatencies & (1 << k))
-                            mvOsOutput("%d,             ", k+1);
-                    }
-                }
-                else if (dimmInfo.memoryType == MEM_TYPE_DDR1)
-                {
-                    if (dimmInfo.suportedCasLatencies & BIT0)
-                        mvOsOutput("1, ");
-                    if (dimmInfo.suportedCasLatencies & BIT1)
-                        mvOsOutput("1.5, ");
-                    if (dimmInfo.suportedCasLatencies & BIT2)
-                        mvOsOutput("2, ");
-                    if (dimmInfo.suportedCasLatencies & BIT3)
-                        mvOsOutput("2.5, ");
-                    if (dimmInfo.suportedCasLatencies & BIT4)
-                        mvOsOutput("3, ");
-                    if (dimmInfo.suportedCasLatencies & BIT5)
-                        mvOsOutput("3.5, ");
-                }
-                else if (dimmInfo.memoryType == MEM_TYPE_DDR2)
-                {
-                    if (dimmInfo.suportedCasLatencies & BIT2)
-                        mvOsOutput("2, ");
-                    if (dimmInfo.suportedCasLatencies & BIT3)
-                        mvOsOutput("3, ");
-                    if (dimmInfo.suportedCasLatencies & BIT4)
-                        mvOsOutput("4, ");
-                    if (dimmInfo.suportedCasLatencies & BIT5)
-                        mvOsOutput("5, ");		
-                }
-                else
-                    mvOsOutput("?.?, ");		
-                mvOsOutput("\n");
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 20:   /* DDR2 DIMM type info */
-                if (dimmInfo.memoryType == MEM_TYPE_DDR2)
-                {
-                    if (dimmInfo.dimmTypeInfo & (BIT0 | BIT4))
-                        mvOsOutput("Registered DIMM (RDIMM)\n");
-                    else if (dimmInfo.dimmTypeInfo & (BIT1 | BIT5))
-                        mvOsOutput("Unbuffered DIMM (UDIMM)\n");
-                    else 
-                        mvOsOutput("Unknown DIMM type.\n");
-                }
-
-                break;
-/*----------------------------------------------------------------------------*/
-   
-            case 21: /* SDRAM Modules Attributes */
-                mvOsOutput("\nModule Attributes (SPD Byte 21): \n");
-                
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    if (dimmInfo.dimmAttributes & BIT0)
-                        mvOsOutput(" Buffered Addr/Control Input:   Yes\n");
-                    else
-                        mvOsOutput(" Buffered Addr/Control Input:   No\n");
-
-                    if (dimmInfo.dimmAttributes & BIT1)
-                        mvOsOutput(" Registered Addr/Control Input: Yes\n");
-                    else
-                        mvOsOutput(" Registered Addr/Control Input: No\n");
-   
-                    if (dimmInfo.dimmAttributes & BIT2)
-                        mvOsOutput(" On-Card PLL (clock):           Yes \n");
-                    else
-                        mvOsOutput(" On-Card PLL (clock):           No \n");
-
-                    if (dimmInfo.dimmAttributes & BIT3)
-                        mvOsOutput(" Bufferd DQMB Input:            Yes \n");
-                    else
-                        mvOsOutput(" Bufferd DQMB Inputs:           No \n");
-   
-                    if (dimmInfo.dimmAttributes & BIT4)
-                        mvOsOutput(" Registered DQMB Inputs:        Yes \n");
-                    else
-                        mvOsOutput(" Registered DQMB Inputs:        No \n");
- 
-                    if (dimmInfo.dimmAttributes & BIT5)
-                        mvOsOutput(" Differential Clock Input:      Yes \n");
-                    else
-                        mvOsOutput(" Differential Clock Input:      No \n");
-   
-                    if (dimmInfo.dimmAttributes & BIT6)
-                        mvOsOutput(" redundant Row Addressing:      Yes \n");
-                    else
-                        mvOsOutput(" redundant Row Addressing:      No \n");
-                }
-                else if (dimmInfo.memoryType == MEM_TYPE_DDR1)
-                {
-                    if (dimmInfo.dimmAttributes & BIT0)
-                        mvOsOutput(" Buffered Addr/Control Input:   Yes\n");
-                    else 
-                        mvOsOutput(" Buffered Addr/Control Input:   No\n");
-   
-                    if (dimmInfo.dimmAttributes & BIT1)
-                        mvOsOutput(" Registered Addr/Control Input: Yes\n");
-                    else
-                        mvOsOutput(" Registered Addr/Control Input: No\n");
-   
-                    if (dimmInfo.dimmAttributes & BIT2)
-                        mvOsOutput(" On-Card PLL (clock):           Yes \n");
-                    else
-                        mvOsOutput(" On-Card PLL (clock):           No \n");
-            
-                    if (dimmInfo.dimmAttributes & BIT3)
-                        mvOsOutput(" FET Switch On-Card Enabled:    Yes \n");
-                    else
-                        mvOsOutput(" FET Switch On-Card Enabled:    No \n");
-                    
-                    if (dimmInfo.dimmAttributes & BIT4)
-                        mvOsOutput(" FET Switch External Enabled:   Yes \n");
-                    else
-                        mvOsOutput(" FET Switch External Enabled:   No \n");
-
-                    if (dimmInfo.dimmAttributes & BIT5)
-                        mvOsOutput(" Differential Clock Input:      Yes \n");
-                    else
-                        mvOsOutput(" Differential Clock Input:      No \n");
-                }
-                else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
-                {
-                    mvOsOutput(" Number of Active Registers on the DIMM: %d\n", 
-                                        (dimmInfo.dimmAttributes & 0x3) + 1);
-            
-                    mvOsOutput(" Number of PLLs on the DIMM: %d\n", 
-                                      ((dimmInfo.dimmAttributes) >> 2) & 0x3);
-               
-                    if (dimmInfo.dimmAttributes & BIT4)
-                        mvOsOutput(" FET Switch External Enabled:   Yes \n");
-                    else
-                        mvOsOutput(" FET Switch External Enabled:   No \n");
-
-                    if (dimmInfo.dimmAttributes & BIT6)
-                        mvOsOutput(" Analysis probe installed:      Yes \n");
-                    else
-                        mvOsOutput(" Analysis probe installed:      No \n");
-                }
-                
-                break;
-/*----------------------------------------------------------------------------*/
-
-            case 22: /* Suported AutoPreCharge */
-                mvOsOutput("\nModul Attributes (SPD Byte 22): \n");
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    if ( spdRawData[i] & BIT0 )
-                        mvOsOutput(" Early Ras Precharge:           Yes \n");
-                    else
-                        mvOsOutput(" Early Ras Precharge:           No \n");
-                                                        
-                    if ( spdRawData[i] & BIT1 )                 
-                        mvOsOutput(" AutoPreCharge:                 Yes \n");
-                    else
-                        mvOsOutput(" AutoPreCharge:                 No \n");
-                                                            
-                    if ( spdRawData[i] & BIT2 )                 
-                        mvOsOutput(" Precharge All:                 Yes \n");
-                    else
-                        mvOsOutput(" Precharge All:                 No \n");
-                                                        
-                    if ( spdRawData[i] & BIT3 )                 
-                        mvOsOutput(" Write 1/ReadBurst:             Yes \n");
-                    else
-                        mvOsOutput(" Write 1/ReadBurst:             No \n");
-                                                        
-                    if ( spdRawData[i] & BIT4 )                 
-                        mvOsOutput(" lower VCC tolerance:           5%%\n");
-                    else
-                        mvOsOutput(" lower VCC tolerance:           10%%\n");
-                                                        
-                    if ( spdRawData[i] & BIT5 )                 
-                        mvOsOutput(" upper VCC tolerance:           5%%\n");
-                    else
-                        mvOsOutput(" upper VCC tolerance:           10%%\n");
-                }
-                else if (dimmInfo.memoryType == MEM_TYPE_DDR1)
-                {
-                    if ( spdRawData[i] & BIT0 )
-                        mvOsOutput(" Supports Weak Driver:          Yes \n");
-                    else
-                        mvOsOutput(" Supports Weak Driver:          No \n");
-
-                    if ( !(spdRawData[i] & BIT4) )
-                        mvOsOutput(" lower VCC tolerance:           0.2V\n");
-   
-                    if ( !(spdRawData[i] & BIT5) )
-                        mvOsOutput(" upper VCC tolerance:           0.2V\n");
-
-                    if ( spdRawData[i] & BIT6 )
-                        mvOsOutput(" Concurrent Auto Preharge:      Yes \n");
-                    else
-                        mvOsOutput(" Concurrent Auto Preharge:      No \n");
-
-                    if ( spdRawData[i] & BIT7 )
-                        mvOsOutput(" Supports Fast AP:              Yes \n");
-                    else
-                        mvOsOutput(" Supports Fast AP:              No \n");
-                }
-                else if (dimmInfo.memoryType == MEM_TYPE_DDR2)
-                {
-                    if ( spdRawData[i] & BIT0 )
-                        mvOsOutput(" Supports Weak Driver:          Yes \n");
-                    else
-                        mvOsOutput(" Supports Weak Driver:          No \n");
-                }
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 23:
-            /* Minimum Cycle Time At Maximum Cas Latancy Minus 1 (2nd highest CL) */
-                leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
-                rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                
-                /* DDR2 addition of right of point */
-                if ((spdRawData[i] & 0x0f) == 0xA)
-                {
-                    rightOfPoint = 25;
-                }
-                if ((spdRawData[i] & 0x0f) == 0xB)
-                {
-                    rightOfPoint = 33;
-                }
-                if ((spdRawData[i] & 0x0f) == 0xC)
-                {
-                    rightOfPoint = 66;
-                }
-                if ((spdRawData[i] & 0x0f) == 0xD)
-                {
-                    rightOfPoint = 75;
-                }
-
-                mvOsOutput("Minimum Cycle Time At 2nd highest CasLatancy"
-                           "(0 = Not supported): %d.%d [ns]\n",
-                           leftOfPoint, rightOfPoint );
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 24: /* Clock To Data Out 2nd highest Cas Latency Value*/
-                div = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 10:100;
-                time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
-                                                    ((spdRawData[i] & 0x0f));
-                leftOfPoint     = time_tmp / div;
-                rightOfPoint    = time_tmp % div;
-                mvOsOutput("Clock To Data Out (2nd CL value): 		%d.%d [ns]\n",
-                                                    leftOfPoint, rightOfPoint);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 25: 
-            /* Minimum Cycle Time At Maximum Cas Latancy Minus 2 (3rd highest CL) */
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    leftOfPoint = (spdRawData[i] & 0xfc) >> 2;
-                    rightOfPoint = (spdRawData[i] & 0x3) * 25;
-                }
-                else    /* DDR1 or DDR2 */ 
-                {
-                    leftOfPoint = (spdRawData[i] & 0xf0) >> 4;
-                    rightOfPoint = (spdRawData[i] & 0x0f) * 10;
-                    
-                    /* DDR2 addition of right of point */
-                    if ((spdRawData[i] & 0x0f) == 0xA)
-                    {
-                        rightOfPoint = 25;
-                    }
-                    if ((spdRawData[i] & 0x0f) == 0xB)
-                    {
-                        rightOfPoint = 33;
-                    }
-                    if ((spdRawData[i] & 0x0f) == 0xC)
-                    {
-                        rightOfPoint = 66;
-                    }
-                    if ((spdRawData[i] & 0x0f) == 0xD)
-                    {
-                        rightOfPoint = 75;
-                    }
-                }
-                mvOsOutput("Minimum Cycle Time At 3rd highest CasLatancy" 
-                           "(0 = Not supported): %d.%d [ns]\n",
-                           leftOfPoint, rightOfPoint );
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 26: /* Clock To Data Out 3rd highest Cas Latency Value*/
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    leftOfPoint = (spdRawData[i] & 0xfc) >> 2;
-                    rightOfPoint = (spdRawData[i] & 0x3) * 25;
-                }
-                else    /* DDR1 or DDR2 */ 
-                {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
-                                                      ((spdRawData[i] & 0x0f));
-                    leftOfPoint     = 0;
-                    rightOfPoint    = time_tmp;
-                }
-                mvOsOutput("Clock To Data Out (3rd CL value): 		%d.%2d[ns]\n",
-                                                  leftOfPoint, rightOfPoint );
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 27: /* Minimum Row Precharge Time */
-                shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
-                                                                    0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
-                                                                    0x00 : 0x03;
-                leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
-                rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;
-                temp = ((leftOfPoint*100) + rightOfPoint);/* in 10ps Intervals*/
-                trp_clocks = (temp + (busClkPs-1)) /  busClkPs;    
-                mvOsOutput("Minimum Row Precharge Time [ns]: 		%d.%d = " 
-                           "in Clk cycles %d\n", 
-                           leftOfPoint, rightOfPoint, trp_clocks);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 28: /* Minimum Row Active to Row Active Time */
-                shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
-                                                                    0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
-                                                                    0x00 : 0x03;
-                leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
-                rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;
-                temp = ((leftOfPoint*100) + rightOfPoint);/* in 100ns Interval*/
-                trrd_clocks = (temp + (busClkPs-1)) / busClkPs;
-                mvOsOutput("Minimum Row Active -To- Row Active Delay [ns]: " 
-                           "%d.%d = in Clk cycles %d\n",
-                            leftOfPoint, rightOfPoint, trp_clocks);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 29: /* Minimum Ras-To-Cas Delay */
-                shift = (dimmInfo.memoryType == MEM_TYPE_SDRAM)? 0:2;
-                maskLeftOfPoint  = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
-                                                                    0xff : 0xfc;
-                maskRightOfPoint = (dimmInfo.memoryType == MEM_TYPE_SDRAM) ? 
-                                                                    0x00 : 0x03;
-                leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> shift);
-                rightOfPoint = (spdRawData[i] & maskRightOfPoint)*25;  
-                temp = ((leftOfPoint*100) + rightOfPoint);/* in 100ns Interval*/
-                trcd_clocks = (temp + (busClkPs-1) )/ busClkPs;
-                mvOsOutput("Minimum Ras-To-Cas Delay [ns]: 			%d.%d = "
-                           "in Clk cycles %d\n", 
-                           leftOfPoint, rightOfPoint, trp_clocks);
-                break;
-/*----------------------------------------------------------------------------*/
-   
-            case 30: /* Minimum Ras Pulse Width */
-                tras_clocks = (cas2ps(spdRawData[i])+(busClkPs-1)) / busClkPs;
-                mvOsOutput("Minimum Ras Pulse Width [ns]: 			%d = "
-                           "in Clk cycles %d\n", spdRawData[i], tras_clocks);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 31: /* Module Bank Density */
-                mvOsOutput("Module Bank Density (more than 1= Multisize-Module):");
-
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    if (dimmInfo.dimmBankDensity & BIT0)
-                        mvOsOutput("1GB, ");
-                    if (dimmInfo.dimmBankDensity & BIT1)
-                        mvOsOutput("8MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT2)
-                        mvOsOutput("16MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT3)
-                        mvOsOutput("32MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT4)
-                        mvOsOutput("64MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT5)
-                        mvOsOutput("128MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT6) 
-                        mvOsOutput("256MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT7) 
-                        mvOsOutput("512MB, ");
-                }
-                else if (dimmInfo.memoryType == MEM_TYPE_DDR1)
-                {
-                    if (dimmInfo.dimmBankDensity & BIT0)
-                        mvOsOutput("1GB, ");
-                    if (dimmInfo.dimmBankDensity & BIT1)
-                        mvOsOutput("2GB, ");
-                    if (dimmInfo.dimmBankDensity & BIT2)
-                        mvOsOutput("16MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT3)
-                        mvOsOutput("32MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT4)
-                        mvOsOutput("64MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT5)
-                        mvOsOutput("128MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT6) 
-                        mvOsOutput("256MB, ");
-                    if (dimmInfo.dimmBankDensity & BIT7) 
-                        mvOsOutput("512MB, ");
-                }
-                else /* if (dimmInfo.memoryType == MEM_TYPE_DDR2) */
-                {
-                    if (dimmInfo.dimmBankDensity & BIT0)
-                        mvOsOutput("1GB, ");
-                    if (dimmInfo.dimmBankDensity & BIT1)
-                        mvOsOutput("2GB, ");
-                    if (dimmInfo.dimmBankDensity & BIT2)
-                        mvOsOutput("4GB, ");
-                    if (dimmInfo.dimmBankDensity & BIT3)
-                        mvOsOutput("8GB, ");
-                    if (dimmInfo.dimmBankDensity & BIT4)
-                        mvOsOutput("16GB, ");
-                    if (dimmInfo.dimmBankDensity & BIT5)
-                    mvOsOutput("128MB, ");
-                        if (dimmInfo.dimmBankDensity & BIT6) 
-                    mvOsOutput("256MB, ");
-                        if (dimmInfo.dimmBankDensity & BIT7) 
-                    mvOsOutput("512MB, ");
-                }
-                mvOsOutput("\n");
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 32: /* Address And Command Setup Time (measured in ns/1000) */
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    rightOfPoint = (spdRawData[i] & 0x0f);
-                    leftOfPoint  = (spdRawData[i] & 0xf0) >> 4;
-                    if(leftOfPoint > 7)
-                    {
-                    leftOfPoint *= -1;
-                    }
-                }
-                else /* DDR1 or DDR2 */
-                {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
-                                                      ((spdRawData[i] & 0x0f));
-                    leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100; 
-                }
-                mvOsOutput("Address And Command Setup Time [ns]: 		%d.%d\n",
-                                                     leftOfPoint, rightOfPoint);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 33: /* Address And Command Hold Time */
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    rightOfPoint = (spdRawData[i] & 0x0f);
-                    leftOfPoint  = (spdRawData[i] & 0xf0) >> 4;
-                    if(leftOfPoint > 7)
-                    {
-                    leftOfPoint *= -1;
-                    }
-                }
-                else /* DDR1 or DDR2 */
-                {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
-                                                      ((spdRawData[i] & 0x0f));
-                    leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
-                }
-                mvOsOutput("Address And Command Hold Time [ns]: 		%d.%d\n",
-                                                   leftOfPoint, rightOfPoint);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 34: /* Data Input Setup Time */
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    rightOfPoint = (spdRawData[i] & 0x0f);
-                    leftOfPoint  = (spdRawData[i] & 0xf0) >> 4;
-                    if(leftOfPoint > 7)
-                    {
-                        leftOfPoint *= -1;
-                    }
-                }
-                else /* DDR1 or DDR2 */
-                {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
-                                                      ((spdRawData[i] & 0x0f));
-                    leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
-                }
-                mvOsOutput("Data Input Setup Time [ns]: 			%d.%d\n", 
-                                                    leftOfPoint, rightOfPoint);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 35: /* Data Input Hold Time */
-                if (dimmInfo.memoryType == MEM_TYPE_SDRAM)
-                {
-                    rightOfPoint = (spdRawData[i] & 0x0f);
-                    leftOfPoint  = (spdRawData[i] & 0xf0) >> 4;
-                    if(leftOfPoint > 7)
-                    {
-                        leftOfPoint *= -1;
-                    }
-                }
-                else /* DDR1 or DDR2 */
-                {
-                    time_tmp = (((spdRawData[i] & 0xf0) >> 4)*10) + 
-                                                      ((spdRawData[i] & 0x0f));
-                    leftOfPoint = time_tmp / 100;
-                    rightOfPoint = time_tmp % 100;                 
-                }
-                mvOsOutput("Data Input Hold Time [ns]: 			%d.%d\n\n", 
-                                                    leftOfPoint, rightOfPoint);
-                break;
-/*----------------------------------------------------------------------------*/
-    
-            case 36: /* Relevant for DDR2 only: Write Recovery Time */
-                leftOfPoint = ((spdRawData[i] & maskLeftOfPoint) >> 2);
-                rightOfPoint = (spdRawData[i] & maskRightOfPoint) * 25;  
-                mvOsOutput("Write Recovery Time [ns]: 			%d.%d\n", 
-                                                    leftOfPoint, rightOfPoint);
-                break;
-/*----------------------------------------------------------------------------*/
-        }
-    
-}
-
-
-/*
- * translate ns.ns/10 coding of SPD timing values
- * into ps unit values
- */
-/*******************************************************************************
-*  cas2ps - Translate x.y ns parameter to pico-seconds values
-*
-* DESCRIPTION:
-*       This function translates x.y nano seconds to its value in pico seconds.
-*       For example 3.75ns will return 3750.
-*
-* INPUT:
-*       spd_byte - DIMM SPD byte.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       value in pico seconds.
-*
-*******************************************************************************/
-static MV_U32  cas2ps(MV_U8 spd_byte)
-{
-    MV_U32 ns, ns10;
-    
-    /* isolate upper nibble */
-    ns = (spd_byte >> 4) & 0x0F;
-    /* isolate lower nibble */
-    ns10 = (spd_byte & 0x0F);
-    
-    if( ns10 < 10 ) {
-        ns10 *= 10;
-    }
-    else if( ns10 == 10 )
-        ns10 = 25;
-    else if( ns10 == 11 )
-        ns10 = 33;
-    else if( ns10 == 12 )
-        ns10 = 66;
-    else if( ns10 == 13 )
-        ns10 = 75;
-    else 
-    {
-        mvOsOutput("cas2ps Err. unsupported cycle time.\n");
-    }
-    
-    return (ns*1000 + ns10*10);
-}
-
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/bak/spd/mvSpd.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell 
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#ifndef __INCmvDram
-#define __INCmvDram
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "ddr2_3/mvDramIf.h"
-
-#define MAX_DIMM_NUM 			2
-#define SPD_SIZE			128
-
-/* Dimm spd offsets */
-#define DIMM_MEM_TYPE 					2
-#define DIMM_ROW_NUM 					3
-#define DIMM_COL_NUM 					4
-#define DIMM_MODULE_BANK_NUM 				5
-#define DIMM_DATA_WIDTH 				6
-#define DIMM_VOLT_IF 					8
-#define DIMM_MIN_CC_AT_MAX_CAS 				9
-#define DIMM_ERR_CHECK_TYPE 				11
-#define DIMM_REFRESH_INTERVAL 				12
-#define DIMM_SDRAM_WIDTH 				13
-#define DIMM_ERR_CHECK_DATA_WIDTH 			14
-#define DIMM_MIN_CLK_DEL 				15
-#define DIMM_BURST_LEN_SUP 				16
-#define DIMM_DEV_BANK_NUM 				17
-#define DIMM_SUP_CAL 					18
-#define DIMM_DDR2_TYPE_INFORMATION          		20      /* DDR2 only */
-#define DIMM_BUF_ADDR_CONT_IN 				21
-#define DIMM_MIN_CC_AT_MAX_CAS_MINUS1			23
-#define DIMM_MIN_CC_AT_MAX_CAS_MINUS2			25
-#define DIMM_MIN_ROW_PRECHARGE_TIME			27
-#define DIMM_MIN_ROW_ACTIVE_TO_ROW_ACTIVE		28
-#define DIMM_MIN_RAS_TO_CAS_DELAY			29
-#define DIMM_MIN_RAS_PULSE_WIDTH			30
-#define DIMM_BANK_DENSITY				31
-#define DIMM_MIN_WRITE_RECOVERY_TIME        		36
-#define DIMM_MIN_WRITE_TO_READ_CMD_DELAY    		37
-#define DIMM_MIN_READ_TO_PRECH_CMD_DELAY    		38
-#define DIMM_MIN_REFRESH_TO_ACTIVATE_CMD    		42
-#define DIMM_SPD_VERSION    				62
-
-/* Dimm Memory Type values */
-#define DIMM_MEM_TYPE_SDRAM					0x4
-#define DIMM_MEM_TYPE_DDR1 					0x7
-#define DIMM_MEM_TYPE_DDR2 					0x8
-        
-#define DIMM_MODULE_MANU_OFFS 		64
-#define DIMM_MODULE_MANU_SIZE 		8
-#define DIMM_MODULE_VEN_OFFS 		73 
-#define DIMM_MODULE_VEN_SIZE 		25
-#define DIMM_MODULE_ID_OFFS 		99
-#define DIMM_MODULE_ID_SIZE 		18
-
-/* enumeration for voltage levels. */
-typedef enum _mvDimmVoltageIf
-{
-    TTL_5V_TOLERANT, 
-    LVTTL, 
-    HSTL_1_5V, 
-    SSTL_3_3V, 
-    SSTL_2_5V, 
-    VOLTAGE_UNKNOWN, 
-} MV_DIMM_VOLTAGE_IF;
-
-
-/* enumaration for SDRAM CAS Latencies. */
-typedef enum _mvDimmSdramCas
-{
-    SD_CL_1 =1,  
-    SD_CL_2,  
-    SD_CL_3, 
-    SD_CL_4, 
-    SD_CL_5, 
-    SD_CL_6, 
-    SD_CL_7, 
-    SD_FAULT
-}MV_DIMM_SDRAM_CAS;
-
-
-/* DIMM information structure */                                                    
-typedef struct _mvDimmInfo
-{
-    MV_MEMORY_TYPE  memoryType; 	/* DDR or SDRAM */
-
-    MV_U8       spdRawData[SPD_SIZE];  	/* Content of SPD-EEPROM copied 1:1  */
-
-    /* DIMM dimensions */
-    MV_U32  numOfRowAddr;
-    MV_U32  numOfColAddr;
-    MV_U32  numOfModuleBanks;
-    MV_U32  dataWidth;
-    MV_U32  errorCheckType;             /* ECC , PARITY..*/
-    MV_U32  sdramWidth;                 /* 4,8,16 or 32 */
-    MV_U32  errorCheckDataWidth;        /* 0 - no, 1 - Yes */
-    MV_U32  burstLengthSupported;
-    MV_U32  numOfBanksOnEachDevice;
-    MV_U32  suportedCasLatencies;
-    MV_U32  refreshInterval;
-    MV_U32  dimmBankDensity;
-    MV_U32  dimmTypeInfo;           /* DDR2 only */
-    MV_U32  dimmAttributes;
-
-    /* DIMM timing parameters */
-    MV_U32  minCycleTimeAtMaxCasLatPs;	
-    MV_U32  minCycleTimeAtMaxCasLatMinus1Ps;
-    MV_U32  minCycleTimeAtMaxCasLatMinus2Ps;
-	MV_U32  minRowPrechargeTime;
-	MV_U32  minRowActiveToRowActive;
-	MV_U32  minRasToCasDelay;
-	MV_U32  minRasPulseWidth;
-    MV_U32  minWriteRecoveryTime;   /* DDR2 only */
-    MV_U32  minWriteToReadCmdDelay; /* DDR2 only */
-    MV_U32  minReadToPrechCmdDelay; /* DDR2 only */
-    MV_U32  minRefreshToActiveCmd;  /* DDR2 only */
-
-    /* Parameters calculated from the extracted DIMM information */
-    MV_U32  size;               /* 16,64,128,256 or 512 MByte in MB units */
-    MV_U32  deviceDensity;      /* 16,64,128,256 or 512 Mbit in MB units  */
-    MV_U32  numberOfDevices;
-
-} MV_DIMM_INFO;
-
-
-MV_STATUS mvDramBankInfoGet(MV_U32 bankNum, MV_DRAM_BANK_INFO *pBankInfo);
-MV_STATUS dimmSpdGet(MV_U32 dimmNum, MV_DIMM_INFO *pDimmInfo);
-MV_VOID dimmSpdPrint(MV_U32 dimmNum, MV_U32 sysClock);
-MV_STATUS dimmSpdCpy(MV_VOID);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __INCmvDram */
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c
+++ b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c
@@ -135,6 +135,35 @@ MV_U32 mvDramIfSizeGet(MV_VOID)
 	DB(mvOsPrintf("Dram: mvDramIfSizeGet size is %x \n", size));
 	return size;
 }
+MV_U32 mvDramIfHwSizeGet(MV_VOID)
+{
+	MV_U32 base = 0;
+	MV_U32 size, cs, totalSize = 0;
+
+	for (cs = 0; cs < SDRAM_MAX_CS; cs++) {
+		size = MV_REG_READ(SDRAM_SIZE_REG(cs)) & SDRAM_ADDR_MASK;
+		if ((size > 0) && (base < SDRAM_MAX_ADDR)) {
+			size |= ~(SDRAM_ADDR_MASK);
+
+			/* Check if out of max window size and resize the window */
+			if (base+size > SDRAM_MAX_ADDR)
+				size = SDRAM_MAX_ADDR - base - 1;
+
+			base += (size + 1);
+			totalSize += size;
+		}
+	}
+	return totalSize;
+}
+MV_U32 mvDramIfHwCsSizeGet(MV_U32 cs)
+{
+	MV_U32 size;
+
+	size = MV_REG_READ(SDRAM_SIZE_REG(cs)) & SDRAM_ADDR_MASK;
+	if (size > 0)
+		size |= ~(SDRAM_ADDR_MASK);
+	return size;
+}
 
 /*******************************************************************************
 * sdramIfWinOverlap - Check if an address window overlap an SDRAM address window
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.h
+++ b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.h
@@ -160,11 +160,14 @@ MV_STATUS mvDramIfWinGet(MV_TARGET targe
 MV_STATUS mvDramIfWinEnable(MV_TARGET target, MV_BOOL enable);
 MV_VOID   mvDramIfBasicAsmInit(MV_VOID);
 MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable, MV_U32 sysClk);
-MV_VOID   _mvDramIfConfig(int entryNum);
+MV_VOID   mvDramIfConfig(int entryNum);
 
 MV_U32 mvDramIfBankSizeGet(MV_U32 bankNum);
 MV_U32 mvDramIfBankBaseGet(MV_U32 bankNum);
 MV_U32 mvDramIfSizeGet(MV_VOID);
+MV_U32 mvDramIfHwSizeGet(MV_VOID);
+MV_U32 mvDramIfHwCsSizeGet(MV_U32 cs);
+
 MV_U32 mvDramIfCalGet(void);
 MV_STATUS mvDramIfSingleBitErrThresholdSet(MV_U32 threshold);
 MV_VOID mvDramIfSelfRefreshSet(void);
--- a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
+++ b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
@@ -1117,45 +1117,8 @@ MV_VOID mvEth1145PhyBasicInit(MV_U32 por
     mvEthPhyRegRead(ethphyHalData.phyAddr[port], 0x14, &value);
     mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x14, (value | BIT1 | BIT7));
     mvOsDelay(10);
-#if 0 /* Fix by yotam */
-    if (boardId != RD_78XX0_AMC_ID &&
-	    boardId != RD_78XX0_H3C_ID) {
-	    /* Set port 2 - Phy addr 9 to RGMII */
-	if (port == 2) {
-		mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x1b, 0x808b);
-		mvOsDelay(10);
-	}
-
-	/* Set port 1 - Phy addr a to SGMII */
-	if (port == 1) {
-	    mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x1b, 0x8084);
-	    mvOsDelay(10);
-
-		/* Reset Phy */
-	    mvEthPhyRegRead(ethphyHalData.phyAddr[port], 0x00, &value);
-	    mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x00, (value | BIT15));
-	    mvOsDelay(10);
-	#if defined(SGMII_OUTBAND_AN)
-		/* Set port 1 - Phy addr A Page 1 */
-		mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x16, 0x1);
-		mvOsDelay(10);
-
-		/* Set port 1 - Phy addr A disable A.N. */
-		mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x0, 0x140);
-		mvOsDelay(10);
-
-		/* Set port 1 - Phy addr A reset */
-		mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x0, 0x8140);
-		mvOsDelay(10);
-
-		mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x16, 0x0);
-		mvOsDelay(10);
-	#endif
-	}
-    }
-#endif
 
-	    /* Set Phy TPVL to 0 */
+    /* Set Phy TPVL to 0 */
     mvEthPhyRegWrite(ethphyHalData.phyAddr[port], 0x10, 0x60);
     mvOsDelay(10);
 
@@ -1248,14 +1211,6 @@ MV_VOID mvEth1540Y0PhyBasicInit(MV_U32 e
 	/* Set page to 1. */
 	mvEthPhyRegWrite(i, 0x16, 1);
 
-#if 0
-	/* Phy C_ANEG */
-	mvEthPhyRegRead(i, 0x4, &reg);
-	reg &= ~(0x60);
-	reg |= 0x20;
-	mvEthPhyRegWrite(i, 0x4, reg);
-#endif
-
 	/* Enable SGMII AN */
 	mvEthPhyRegWrite(i, 0x0, 0x1140);
 
@@ -1708,11 +1663,13 @@ MV_VOID mvEth1540A0PhyBasicInit(MV_U32 e
 	/* Set page to 0. */
 	mvEthPhyRegWrite(i, 0x16, 0);
 
-	/* Power up the phy */
+	/* Phy C_ANEG */
 	mvEthPhyRegRead(i, 0x4, &reg);
 	reg |= 0x1E0;
 	mvEthPhyRegWrite(i, 0x4, reg);
-       mvEthPhyRegWrite(i, 0x16, 1);
+
+	/* Set page to 1. */
+	mvEthPhyRegWrite(i, 0x16, 1);
 
 	/* Disable Drop BadTag */
 	mvEthPhyRegWrite(i, 22, 0x0010);
@@ -1806,6 +1763,37 @@ MV_VOID mvEth1540A0PhyBasicInit(MV_U32 e
 		mvEthPhyRegWrite(i, 3, 0x0000);
 		mvEthPhyRegWrite(i, 22, 0x0000);
 	}
+/* Configuring the PHY for jumbo packets  */
+	mvEthPhyRegWrite(i, 0x16, 0x02);
+	mvEthPhyRegRead(i, 0x10, &reg);
+	reg |= (1<<14) | (1<<15);
+	mvEthPhyRegWrite(i, 0x10, reg);
+	mvEthPhyRegWrite(i, 0x16, 0x0);
+
+	if (0 == initJumboPackets) {
+		initJumboPackets = 1;
+
+		mvEthPhyRegWrite(0x18, 0x16, 0x10);
+		mvEthPhyRegWrite(0x18, 0x01, 0x40);
+		mvEthPhyRegWrite(0x18, 0x02, 0xFFF9);
+		mvEthPhyRegWrite(0x18, 0x03, 0x1);
+
+		mvEthPhyRegWrite(0x18, 0x01, 0x840);
+		mvEthPhyRegWrite(0x18, 0x02, 0xFFF9);
+		mvEthPhyRegWrite(0x18, 0x03, 0x1);
+
+		mvEthPhyRegWrite(0x18, 0x01, 0x1040);
+		mvEthPhyRegWrite(0x18, 0x02, 0xFFF9);
+		mvEthPhyRegWrite(0x18, 0x03, 0x1);
+
+		mvEthPhyRegWrite(0x18, 0x01, 0x1840);
+		mvEthPhyRegWrite(0x18, 0x02, 0xFFF9);
+		mvEthPhyRegWrite(0x18, 0x03, 0x1);
+
+		mvEthPhyRegWrite(0x18, 0x16, 0x0);
+	}
+
+
 	/* Configure LED */
 	mvEthPhyRegWrite(i, 22, 3);
 	mvEthPhyRegWrite(i, 16, 0x1111);
@@ -1813,12 +1801,12 @@ MV_VOID mvEth1540A0PhyBasicInit(MV_U32 e
 	mvEthPhyRegWrite(i, 22, 0x0000);
 	mvEthPhyRegWrite(i, 0, 0x9140);
 
+	/* Power up the phy */
 	mvEthPhyRegRead(i, ETH_PHY_CTRL_REG, &reg);
 	reg &= ~(ETH_PHY_CTRL_POWER_DOWN_MASK);
 	mvEthPhyRegWrite(i, ETH_PHY_CTRL_REG, reg);
+
 	mvOsDelay(100);
-	/*  Sleep 3000 */
-	/* mvOsDelay(300); */
 }
 
 MV_VOID mvEth1540PhyBasicInit(MV_U32 ethPortNum, MV_BOOL eeeEnable)
@@ -1872,9 +1860,6 @@ MV_VOID mvEth1340PhyBasicInit(void)
 		reg &= ~(ETH_PHY_CTRL_POWER_DOWN_MASK);
 		reg |= 0x1<<9;	/* workaround - restart workaround - restart workaround - restart workaround - restart */
 		mvEthPhyRegWrite(i, ETH_PHY_CTRL_REG, reg);
-
-
-
 	}
 }
 /*******************************************************************************
--- a/arch/arm/plat-armada/mv_hal/gpp/mvGpp.h
+++ b/arch/arm/plat-armada/mv_hal/gpp/mvGpp.h
@@ -121,7 +121,6 @@ extern "C" {
 	MV_STATUS mvGppValueSet(MV_U32 group, MV_U32 mask, MV_U32 value);
 
 	MV_STATUS mvGppAtomicValueSet(MV_U32 gpionumber);
-
 	MV_STATUS mvGppAtomicValueClear(MV_U32 gpionumber);
 #ifdef __cplusplus
 }
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c
@@ -781,10 +781,10 @@ void mvNetaCpuDump(int port, int cpu, in
 		if (regVal & 1)
 			mvOsPrintf("%s-%d ", qType[rxTx], j);
 		else
-			printk("       ");
+			mvOsPrintf("       ");
 	regVal >>= 1;
 	}
-	printk(KERN_INFO "\n");
+	mvOsPrintf("\n");
 }
 
 #ifdef CONFIG_MV_PON
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.c
@@ -0,0 +1,2784 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvNfp.c - Marvell Network Fast Processing
+*
+* DESCRIPTION:
+*
+*       Supported Features:
+*       - OS independent.
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvOs.h"
+#include "mv802_3.h"
+#include "mvDebug.h"
+#include "gbe/mvEthRegs.h"
+#include "gbe/mvNetaRegs.h"
+#include "gbe/mvNeta.h"
+#include "mvNfp.h"
+
+/* Set Debug Level */
+MV_U32 nfpDebugLevel;
+
+MV_U32 nfp_ports[NFP_MAX_PORTS];
+
+NFP_IF_MAP *nfp_if_map[NFP_DEV_HASH_SZ];
+NFP_IF_MAP *nfp_if_real_map[NFP_MAX_PORTS][NFP_MAX_SWITCH_GROUPS];
+
+unsigned int nfp_jhash_iv;
+
+#if (CONFIG_MV_ETH_NFP_DEF == 0)
+static int nfpMode = MV_NFP_DISABLED;
+#else
+static int nfpMode = CONFIG_MV_ETH_NFP_MODE_DEF;
+#endif
+static int nfpFreeExtPort = MV_ETH_MAX_PORTS;
+static NFP_STATS nfp_stats[NFP_MAX_PORTS];
+
+#ifdef NFP_CLASSIFY
+MV_NFP_CLASSIFY_MODE classifyMode[MV_NFP_CLASSIFY_FEATURES];
+MV_NFP_CLASSIFY_POLICY exactPolicy[MV_NFP_CLASSIFY_FEATURES];
+MV_NFP_CLASSIFY_POLICY prioPolicy = MV_NFP_CLASSIFY_POLICY_HIGHEST;
+#endif /* NFP_CLASSIFY */
+
+#ifdef NFP_STAT
+#define NFP_INC(p, s) nfp_stats[p].s++;
+#else
+#define NFP_INC(p, s)
+#endif
+
+/*
+ * Init
+ */
+MV_VOID _INIT mvNfpInit(MV_VOID)
+{
+	int i;
+
+	mvOsMemset(nfp_ports, 0, sizeof(MV_U32) * NFP_MAX_PORTS);
+	mvOsMemset(nfp_stats, 0, sizeof(NFP_STATS) * NFP_MAX_PORTS);
+	mvOsMemset(nfp_if_real_map, 0, sizeof(nfp_if_real_map));
+	mvOsMemset(nfp_if_map, 0, sizeof(nfp_if_map));
+	nfpDebugLevel = NFP_WARN_PRINT; /* Note: can also be (NFP_DBG_PRINT | NFP_WARN_PRINT) */
+
+#ifdef NFP_CLASSIFY
+	for (i = 0; i < MV_NFP_CLASSIFY_FEATURES; i++) {
+		classifyMode[i] = MV_NFP_CLASSIFY_MODE_DISABLED;
+		exactPolicy[i] = MV_NFP_CLASSIFY_POLICY_HIGHEST;
+	}
+#endif /* NFP_CLASSIFY */
+}
+
+MV_VOID   mvNfpModeSet(int mode)
+{
+	nfpMode = mode;
+}
+
+MV_U32 mvNfpPortCapGet(MV_U32 port)
+{
+	return nfp_ports[port];
+}
+
+MV_VOID mvNfpDebugLevelSet(int dbgLevelFlags)
+{
+	nfpDebugLevel = dbgLevelFlags;
+}
+
+static INLINE int needFragment(MV_IP_HEADER_INFO *pIpInfo, NFP_IF_MAP *pOutIf)
+{
+	return (pIpInfo->ipLen > pOutIf->mtu);
+}
+
+/* Update packet's MAC header, including Marvell Header, DA and SA */
+static INLINE void mvNfpFibMacUpdate(MV_U8 *pData, NFP_RULE_FIB *pFib)
+{
+	*(MV_U32 *) (pData + 0) = *(MV_U32 *) (&pFib->mh);
+	*(MV_U32 *) (pData + 4) = *(MV_U32 *) (&pFib->da[2]);
+	*(MV_U32 *) (pData + 8) = *(MV_U32 *) (&pFib->sa[0]);
+	*(MV_U16 *) (pData + 12) = *(MV_U16 *) (&pFib->sa[4]);
+}
+
+/* Update packet's IPv4 Header (decrement TTL field) */
+static INLINE void mvNfpFibIpUpdate(MV_IP_HEADER_INFO *pIpInfo)
+{
+	if (pIpInfo->family == MV_INET)
+		pIpInfo->ip_hdr.ip4->ttl--;
+	else
+		pIpInfo->ip_hdr.ip6->hoplimit--;
+}
+
+#ifdef NFP_CLASSIFY
+static INLINE MV_VOID mvNfpClassifyInit(NFP_CLASSIFY_INFO *info)
+{
+	info->flags = 0;
+	info->pkt_vlan_prio = NFP_INVALID_VPRIO;
+	info->bridge_vlan_prio = NFP_INVALID_VPRIO;
+	info->ct_vlan_prio = NFP_INVALID_VPRIO;
+	info->pkt_dscp = NFP_INVALID_DSCP;
+	info->ct_dscp = NFP_INVALID_DSCP;
+	info->iif_prio = NFP_PRIO_INVALID;
+	info->iif_vlan_prio = NFP_PRIO_INVALID;
+	info->iif_dscp_prio = NFP_PRIO_INVALID;
+}
+
+static INLINE MV_VOID mvNfpVpriPktClassifySave(MV_U16 vlanId, NFP_CLASSIFY_INFO *info)
+{
+	info->pkt_vlan_prio = (vlanId >> 13); /* save 3 MSBits in VLAN ID */
+}
+
+static INLINE MV_VOID mvNfpVpriBridgeClassifySave(MV_U8 *pData, NFP_RULE_BRIDGE	*bridgeRule, NFP_CLASSIFY_INFO *info)
+{
+	int i;
+	MV_U16 eth_type;
+
+	if (info->pkt_vlan_prio != NFP_INVALID_VPRIO)
+		eth_type = MV_16BIT_BE(*(MV_U16 *)(pData + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE +
+							   MV_MAC_ADDR_SIZE + MV_VLAN_HLEN));
+	else
+		eth_type = MV_16BIT_BE(*(MV_U16 *)(pData + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE));
+
+	for (i = 0; i < NFP_VPRI_MAP_GLOBAL; i++) {
+		if ((bridgeRule->vpri_map[i].eth_type == eth_type) && bridgeRule->vpri_map[i].valid) {
+			info->bridge_vlan_prio = bridgeRule->vpri_map[i].new_prio;
+			info->flags |= NFP_F_SET_EXACT_VLAN_PRIO;
+			info->flags |= NFP_F_SET_VLAN_PRIO;
+			return;
+		}
+	}
+	if (bridgeRule->vpri_map[NFP_VPRI_MAP_GLOBAL].valid) {
+		info->bridge_vlan_prio = bridgeRule->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio;
+		info->flags |= NFP_F_SET_EXACT_VLAN_PRIO;
+		info->flags |= NFP_F_SET_VLAN_PRIO;
+	}
+}
+
+#ifdef NFP_CT
+static INLINE MV_VOID mvNfpPktDscpClassifySave(MV_IP_HEADER_INFO *pIpHdr, NFP_CLASSIFY_INFO *info)
+{
+		MV_IP6_HEADER *pIp6Hdr = pIpHdr->ip_hdr.ip6;
+		MV_IP_HEADER *pIph = pIpHdr->ip_hdr.ip4;
+		MV_U8 *pIp6 = (char *)pIp6Hdr;
+
+		/* First get the packet's original DSCP */
+		if (pIpHdr->family == MV_INET) {
+			/* 6 MSBits of the TOS field are DSCP, 2 LSBits are ECN */
+			info->pkt_dscp = ((pIph->tos) >> 2);
+			info->pkt_ecn = (pIph->tos & 0x3);
+		} else {
+			/* TC field is divided on the first 2 bytes of IPv6 header */
+			info->pkt_dscp = (((*pIp6 & 0xF) << 4) | (*(pIp6 + 1) >> 6));
+			info->pkt_ecn = ((*(pIp6 + 1) >> 4) & 0x3);
+		}
+}
+
+static INLINE MV_VOID mvNfpDscpClassifySave(NFP_RULE_CT *pCt, NFP_CLASSIFY_INFO *info)
+{
+		/* Now get the DSCP value from the 5 tuple rule */
+		if (pCt->dscp_map[info->pkt_dscp].valid) {
+			info->ct_dscp = pCt->dscp_map[info->pkt_dscp].new_dscp;
+			info->flags |= NFP_F_SET_EXACT_DSCP;
+			info->flags |= NFP_F_SET_DSCP;
+		} else if (pCt->dscp_map[NFP_DSCP_MAP_GLOBAL].valid) {
+			info->ct_dscp = pCt->dscp_map[NFP_DSCP_MAP_GLOBAL].new_dscp;
+			info->flags |= NFP_F_SET_EXACT_DSCP;
+			info->flags |= NFP_F_SET_DSCP;
+		}
+}
+
+static INLINE MV_VOID mvNfpVpriCtClassifySave(NFP_RULE_CT *pCt, NFP_CLASSIFY_INFO *info)
+{
+	if (info->pkt_vlan_prio != NFP_INVALID_VPRIO) {
+		if (pCt->vpri_map[info->pkt_vlan_prio].valid) {
+			info->ct_vlan_prio = pCt->vpri_map[info->pkt_vlan_prio].new_prio;
+			info->flags |= NFP_F_SET_EXACT_VLAN_PRIO;
+			info->flags |= NFP_F_SET_VLAN_PRIO;
+			return;
+		}
+	}
+	if (pCt->vpri_map[NFP_VPRI_MAP_GLOBAL].valid) {
+		info->ct_vlan_prio = pCt->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio;
+		info->flags |= NFP_F_SET_EXACT_VLAN_PRIO;
+		info->flags |= NFP_F_SET_VLAN_PRIO;
+	}
+}
+#endif /* NFP_CT */
+
+static INLINE MV_VOID mvNfpTxqClassifySave(int txq, NFP_CLASSIFY_INFO *info)
+{
+	if (info->flags & NFP_F_SET_EXACT_TXQ) {
+		/* update info->txq according to policy */
+		switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_TXQ]) {
+		case MV_NFP_CLASSIFY_POLICY_FIRST:
+			/* do nothing - this is not the first time this function was called */
+			break;
+		case MV_NFP_CLASSIFY_POLICY_LAST:
+			info->txq = txq;
+			break;
+		case MV_NFP_CLASSIFY_POLICY_HIGHEST:
+			if (txq > info->txq)
+				info->txq = txq;
+			break;
+		case MV_NFP_CLASSIFY_POLICY_LOWEST:
+			if (txq < info->txq)
+				info->txq = txq;
+			break;
+		default:
+			NFP_WARN("%s: unknown txq policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_TXQ]);
+			return;
+		}
+	} else {
+		info->flags |= NFP_F_SET_EXACT_TXQ;
+		info->flags |= NFP_F_SET_TXQ;
+		info->txq = txq;
+	}
+}
+
+static INLINE MV_VOID mvNfpTxpClassifySave(MV_U8 txp, NFP_CLASSIFY_INFO *info)
+{
+	if (info->flags & NFP_F_SET_EXACT_TXP) {
+		/* update info->txp according to policy */
+		switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_TXP]) {
+		case MV_NFP_CLASSIFY_POLICY_FIRST:
+			/* do nothing - this is not the first time this function was called */
+			break;
+		case MV_NFP_CLASSIFY_POLICY_LAST:
+			info->txp = txp;
+			break;
+		case MV_NFP_CLASSIFY_POLICY_HIGHEST:
+			if (txp > info->txp)
+				info->txp = txp;
+			break;
+		case MV_NFP_CLASSIFY_POLICY_LOWEST:
+			if (txp < info->txp)
+				info->txp = txp;
+			break;
+		default:
+			NFP_WARN("%s: unknown txp policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_TXP]);
+			return;
+		}
+	} else {
+		info->flags |= NFP_F_SET_EXACT_TXP;
+		info->flags |= NFP_F_SET_TXP;
+		info->txp = txp;
+	}
+}
+
+static INLINE MV_VOID mvNfpMhClassifySave(MV_U16 mh, NFP_CLASSIFY_INFO *info)
+{
+	if (info->flags & NFP_F_SET_EXACT_MH) {
+		/* update info->mh according to policy */
+		switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_MH]) {
+		case MV_NFP_CLASSIFY_POLICY_FIRST:
+			/* do nothing - this is not the first time this function was called */
+			break;
+		case MV_NFP_CLASSIFY_POLICY_LAST:
+			info->mh = mh;
+			break;
+		case MV_NFP_CLASSIFY_POLICY_HIGHEST:
+			if (mh > info->mh)
+				info->mh = mh;
+			break;
+		case MV_NFP_CLASSIFY_POLICY_LOWEST:
+			if (mh < info->mh)
+				info->mh = mh;
+			break;
+		default:
+			NFP_WARN("%s: unknown MH policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_MH]);
+			return;
+		}
+	} else {
+		info->flags |= NFP_F_SET_EXACT_MH;
+		info->flags |= NFP_F_SET_MH;
+		info->mh = mh;
+	}
+}
+
+#ifdef NFP_CT
+static INLINE int mvNfpClassifyExactDscpGet(NFP_CLASSIFY_INFO *info)
+{
+	int newDscp = NFP_INVALID_DSCP;
+	/* use dscp from exact match classification */
+	switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_DSCP]) {
+	case MV_NFP_CLASSIFY_POLICY_FIRST:
+		newDscp = info->pkt_dscp; /* should always be valid */
+		break;
+	case MV_NFP_CLASSIFY_POLICY_LAST:
+		if (info->ct_dscp != NFP_INVALID_DSCP)
+			newDscp = info->ct_dscp;
+		else
+			newDscp = info->pkt_dscp;
+		break;
+	case MV_NFP_CLASSIFY_POLICY_HIGHEST:
+		newDscp = (info->ct_dscp > info->pkt_dscp) ? info->ct_dscp : info->pkt_dscp;
+		break;
+	case MV_NFP_CLASSIFY_POLICY_LOWEST:
+		if (info->ct_dscp != NFP_INVALID_DSCP)
+			newDscp = (info->ct_dscp < info->pkt_dscp) ? info->ct_dscp : info->pkt_dscp;
+		else
+			newDscp = info->pkt_dscp;
+		break;
+	default:
+		NFP_WARN("%s: unknown DSCP policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_DSCP]);
+		return NFP_INVALID_DSCP;
+	}
+	return newDscp;
+}
+
+static INLINE int mvNfpClassifyFeatureGetVal(int exactVal, int priorityVal, MV_NFP_CLASSIFY_MODE mode)
+{
+	if (mode == MV_NFP_CLASSIFY_MODE_HIGHEST)
+		return (exactVal > priorityVal) ? exactVal : priorityVal;
+	else
+		return (exactVal < priorityVal) ? exactVal : priorityVal;
+}
+
+
+static INLINE MV_VOID mvNfpDscpClassifyUpdate(MV_IP_HEADER_INFO *pIpHdr, NFP_CLASSIFY_INFO *info)
+{
+	MV_IP6_HEADER *pIp6Hdr = pIpHdr->ip_hdr.ip6;
+	MV_IP_HEADER *pIph = pIpHdr->ip_hdr.ip4;
+	MV_U8 *pIp6 = (char *)pIp6Hdr;
+	int newDscp;
+	MV_U16 exactDscpFlag , prioDscpFlag;
+	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_DSCP);
+
+	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
+		return;
+
+	if (!(info->flags & NFP_F_SET_DSCP))
+		/* both exact and priority values are invalid */
+		return;
+
+	exactDscpFlag = info->flags & NFP_F_SET_EXACT_DSCP;
+	prioDscpFlag = info->flags & NFP_F_SET_PRIO_DSCP;
+
+	switch (mode) {
+	case MV_NFP_CLASSIFY_MODE_EXACT:
+		if (exactDscpFlag)
+			newDscp = mvNfpClassifyExactDscpGet(info);
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_PRIO:
+		if (prioDscpFlag)
+			newDscp = info->prio_dscp;
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_HIGHEST:
+	case MV_NFP_CLASSIFY_MODE_LOWEST:
+		if (!exactDscpFlag) {
+			if (!prioDscpFlag)
+				return;/*both valid*/
+			newDscp = info->prio_dscp;
+		} else if (!prioDscpFlag)
+			newDscp = mvNfpClassifyExactDscpGet(info);
+		else/*both valid*/
+			newDscp =  mvNfpClassifyFeatureGetVal(mvNfpClassifyExactDscpGet(info), info->prio_dscp, mode);
+		break;
+	default:
+		NFP_WARN("%s: unknown DSCP mode %d\n", __func__, mode);
+		return;
+	}
+
+	if  (newDscp != info->pkt_dscp) {
+		if (pIpHdr->family == MV_INET) {
+			pIph->tos = ((newDscp << 2) | info->pkt_ecn);
+		} else {
+			*pIp6 &= ~0xF;			/* Clear 4 LSBits of 1st byte of IPv6 header */
+			*pIp6 |= (newDscp >> 4);	/* Set 4 MSBits of new Traffic Class value */
+			pIp6++;
+			*pIp6 &= ~0xF0;			/* Clear 4 MSBits of 2nd byte of IPv6 header */
+			*pIp6 |= (((newDscp & 0x3) << 6) | (info->pkt_ecn << 4));	/* Set 4 LSBits of new Traffic Class value */
+		}
+	}
+}
+#endif /* NFP_CT */
+
+static INLINE int mvNfpClassifyExactVprioGet(NFP_CLASSIFY_INFO *info)
+{
+	int exactVprio = NFP_INVALID_VPRIO;
+	switch (exactPolicy[MV_NFP_CLASSIFY_FEATURE_VPRIO]) {
+	case MV_NFP_CLASSIFY_POLICY_FIRST:
+		if (info->pkt_vlan_prio != NFP_INVALID_VPRIO)
+			exactVprio = info->pkt_vlan_prio;
+		else if (info->bridge_vlan_prio != NFP_INVALID_VPRIO)
+			exactVprio = info->bridge_vlan_prio;
+		else if (info->ct_vlan_prio != NFP_INVALID_VPRIO)
+			exactVprio = info->ct_vlan_prio;
+		break;
+	case MV_NFP_CLASSIFY_POLICY_LAST:
+		if (info->ct_vlan_prio != NFP_INVALID_VPRIO)
+			exactVprio = info->ct_vlan_prio;
+		else if (info->bridge_vlan_prio != NFP_INVALID_VPRIO)
+			exactVprio = info->bridge_vlan_prio;
+		else if (info->pkt_vlan_prio != NFP_INVALID_VPRIO)
+			exactVprio = info->pkt_vlan_prio;
+		break;
+	case MV_NFP_CLASSIFY_POLICY_HIGHEST:
+		exactVprio = info->pkt_vlan_prio;
+		if (info->bridge_vlan_prio > exactVprio)
+			exactVprio = info->bridge_vlan_prio;
+		if (info->ct_vlan_prio > exactVprio)
+			exactVprio = info->ct_vlan_prio;
+		break;
+	case MV_NFP_CLASSIFY_POLICY_LOWEST:
+		exactVprio = info->pkt_vlan_prio;
+		if ((info->bridge_vlan_prio != NFP_INVALID_VPRIO) && (info->bridge_vlan_prio < exactVprio))
+			exactVprio = info->bridge_vlan_prio;
+		if ((info->ct_vlan_prio != NFP_INVALID_VPRIO) && (info->ct_vlan_prio < exactVprio))
+			exactVprio = info->ct_vlan_prio;
+		break;
+	default:
+		NFP_WARN("%s: unknown VLAN Priority policy %d\n", __func__, exactPolicy[MV_NFP_CLASSIFY_FEATURE_VPRIO]);
+		return NFP_INVALID_VPRIO;
+	}
+	return exactVprio;
+}
+
+
+static INLINE MV_VOID mvNfpVpriClassifyUpdate(MV_U16 *vid, NFP_CLASSIFY_INFO *info)
+{
+	int vprio;
+	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_VPRIO);
+	MV_U16 exactVlanPrioFlag , prioVlanPrioFlag;
+
+	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
+		return;
+
+	if (!(info->flags & NFP_F_SET_VLAN_PRIO))
+		/* both exact and priority values are invalid */
+		return;
+
+	exactVlanPrioFlag = info->flags & NFP_F_SET_EXACT_VLAN_PRIO;
+	prioVlanPrioFlag = info->flags & NFP_F_SET_PRIO_VLAN_PRIO;
+
+	switch (mode) {
+	case MV_NFP_CLASSIFY_MODE_EXACT:
+		if (exactVlanPrioFlag)
+			vprio = mvNfpClassifyExactVprioGet(info);
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_PRIO:
+		if (prioVlanPrioFlag)
+			vprio =  info->prio_vprio;
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_HIGHEST:
+	case MV_NFP_CLASSIFY_MODE_LOWEST:
+		if (!exactVlanPrioFlag) {
+			if (!prioVlanPrioFlag)
+				return;
+			vprio = info->prio_vprio;
+		} else if (!prioVlanPrioFlag)
+			vprio = mvNfpClassifyExactVprioGet(info);
+		else/*both valid*/
+			vprio = mvNfpClassifyFeatureGetVal(mvNfpClassifyExactVprioGet(info), info->prio_vprio, mode);
+		break;
+	default:
+		NFP_WARN("%s: unknown VLAN_PRIO mode %d\n", __func__, mode);
+		return;
+	}
+
+	(*vid) &= ~0xE000;
+	(*vid) |= (vprio << 13); /* Set 3 MSBits */
+}
+
+static INLINE MV_VOID mvNfpMhClassifyUpdate(MV_U8 *pData, NFP_CLASSIFY_INFO *info)
+{
+	MV_U16 mh;
+	MV_U16 exactMhFlag , prioMhFlag;
+	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_MH);
+
+	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
+		return;
+
+	if (!(info->flags & NFP_F_SET_MH))
+		/* both exact and priority values are invalid */
+		return;
+
+	exactMhFlag = info->flags & NFP_F_SET_EXACT_MH;
+	prioMhFlag = info->flags & NFP_F_SET_PRIO_MH;
+
+	switch (mode) {
+	case MV_NFP_CLASSIFY_MODE_EXACT:
+		if (exactMhFlag)
+			mh = info->mh;
+		else
+			return;
+		break;
+	case NFP_F_SET_PRIO_MH:
+		if (prioMhFlag)
+			mh = info->prio_mh;
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_HIGHEST:
+	case MV_NFP_CLASSIFY_MODE_LOWEST:
+		if (!exactMhFlag) {
+			if (!prioMhFlag)
+				return;
+			mh = info->prio_mh;
+		} else if (!prioMhFlag)
+			mh = info->mh;
+		else/*both valid*/
+			mh = mvNfpClassifyFeatureGetVal(info->mh, info->prio_mh, mode);
+		break;
+	default:
+		NFP_WARN("%s: unknown MH mode %d\n", __func__, mode);
+		return;
+	}
+
+	*(MV_U16 *)(pData) = MV_16BIT_BE(mh);
+}
+
+static INLINE MV_VOID mvNfpTxpClassifyUpdate(MV_NFP_RESULT *pRes, NFP_CLASSIFY_INFO *info)
+{
+	MV_U8 newTxp;
+	MV_U16 exactTxpFlag , prioTxpFlag;
+	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_TXP);
+
+	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
+		return;
+
+	if (!(info->flags & NFP_F_SET_TXP))
+		/* both exact and priority values are invalid */
+		return;
+
+	exactTxpFlag = info->flags & NFP_F_SET_EXACT_TXP;
+	prioTxpFlag = info->flags & NFP_F_SET_PRIO_TXP;
+
+	switch (mode) {
+	case MV_NFP_CLASSIFY_MODE_EXACT:
+		if (exactTxpFlag)
+			newTxp = info->txp;
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_PRIO:
+		if (prioTxpFlag)
+			newTxp = info->prio_txp;
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_HIGHEST:
+	case MV_NFP_CLASSIFY_MODE_LOWEST:
+		if (!exactTxpFlag) {
+			if (!prioTxpFlag)
+				return;
+			newTxp = info->prio_txp;
+		} else if (!prioTxpFlag)
+			newTxp = info->txp;
+		else/*both valid*/
+			newTxp = mvNfpClassifyFeatureGetVal(info->txp, info->prio_txp, mode);
+		break;
+	default:
+		NFP_WARN("%s: unknown TPX mode %d\n", __func__, mode);
+		return;
+	}
+
+	pRes->flags |= MV_NFP_RES_TXP_VALID;
+	pRes->txp = newTxp;
+}
+
+static INLINE MV_VOID mvNfpTxqClassifyUpdate(MV_NFP_RESULT *pRes, NFP_CLASSIFY_INFO *info)
+{
+	MV_U8 newTxq;
+	MV_U16 exactTxqFlag , prioTxqFlag;
+	MV_NFP_CLASSIFY_MODE mode = mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE_TXQ);
+
+	if (mode == MV_NFP_CLASSIFY_MODE_DISABLED)
+		return;
+
+	if (!(info->flags & NFP_F_SET_TXQ))
+		/* both exact and priority values are invalid */
+		return;
+
+	exactTxqFlag = info->flags & NFP_F_SET_EXACT_TXQ;
+	prioTxqFlag = info->flags & NFP_F_SET_PRIO_TXQ;
+
+	switch (mode) {
+	case MV_NFP_CLASSIFY_MODE_EXACT:
+		if (exactTxqFlag)
+			newTxq = info->txq;
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_PRIO:
+		if (prioTxqFlag)
+			newTxq = info->prio_txq;
+		else
+			return;
+		break;
+	case MV_NFP_CLASSIFY_MODE_HIGHEST:
+	case MV_NFP_CLASSIFY_MODE_LOWEST:
+		if (!exactTxqFlag) {
+			if (!prioTxqFlag)
+				return;
+			newTxq = info->prio_txq;
+		} else if (!prioTxqFlag)
+			newTxq = info->txq;
+		else/*both valid*/
+			newTxq = mvNfpClassifyFeatureGetVal(info->txq, info->prio_txq, mode);
+		break;
+	default:
+		NFP_WARN("%s: unknown TPX mode 3 %d\n", __func__, mode);
+		return;
+	}
+
+	pRes->flags |= MV_NFP_RES_TXQ_VALID;
+	pRes->txq = newTxq;
+}
+
+
+/* Get classification priority according to policy
+ * Priority can come from:
+ *	1. iif => prio
+ *	2. iif + vprio => prio
+ *	3. iif + dscp => prio
+ * Policy can be Highest or Lowest.
+ * Return correct priority, or NFP_PRIO_INVALID if no priority is available */
+static INLINE int mvNfpClassifyPrioGet(NFP_CLASSIFY_INFO *info)
+{
+	MV_NFP_CLASSIFY_POLICY prioPolicy = mvNfpPrioPolicyGet();
+	int prio;
+
+	if (!info)
+		return NFP_PRIO_INVALID;
+
+	/* get priority from iif/(iif+vprio)/(iif+dscp) according to priority policy (highest/lowest) */
+	prio = info->iif_prio;
+
+	if ((info->iif_vlan_prio != NFP_PRIO_INVALID) &&
+		((prio == NFP_PRIO_INVALID) ||
+		((prioPolicy == MV_NFP_CLASSIFY_POLICY_HIGHEST) && (prio < info->iif_vlan_prio)) ||
+		((prioPolicy == MV_NFP_CLASSIFY_POLICY_LOWEST) && (prio > info->iif_vlan_prio))))
+		prio = info->iif_vlan_prio;
+	if ((info->iif_dscp_prio != NFP_PRIO_INVALID) &&
+		((prio == NFP_PRIO_INVALID) ||
+		((prioPolicy == MV_NFP_CLASSIFY_POLICY_HIGHEST) && (prio < info->iif_dscp_prio)) ||
+		((prioPolicy == MV_NFP_CLASSIFY_POLICY_LOWEST) && (prio > info->iif_dscp_prio))))
+		prio = info->iif_dscp_prio;
+
+	return prio;
+}
+
+/* save classification data, from priority */
+static INLINE MV_VOID mvNfpClassifyPrioSave(NFP_IF_MAP *pOutIf, NFP_CLASSIFY_INFO *info, int prio)
+{
+	NFP_PRIO_CLASSIFY_INFO *classifyFromOif = NULL;
+
+	if (!pOutIf || !info || (prio == NFP_PRIO_INVALID))
+		return;
+
+	classifyFromOif = &(pOutIf->prio_to_classify[prio]);
+
+	/* for each feature, save classify data */
+	if (classifyFromOif->flags & NFP_F_PRIO_DSCP) {
+		info->prio_dscp = classifyFromOif->dscp;
+		info->flags |= NFP_F_SET_PRIO_DSCP;
+		info->flags |= NFP_F_SET_DSCP;
+	} else
+		info->flags &= ~NFP_F_SET_PRIO_DSCP;
+
+	if (classifyFromOif->flags & NFP_F_PRIO_VPRIO) {
+		info->prio_vprio = classifyFromOif->vprio;
+		info->flags |= NFP_F_SET_PRIO_VLAN_PRIO;
+		info->flags |= NFP_F_SET_VLAN_PRIO;
+	} else
+		info->flags &= ~NFP_F_SET_PRIO_VLAN_PRIO;
+
+	if (classifyFromOif->flags & NFP_F_PRIO_TXQ) {
+		info->prio_txq = classifyFromOif->txq;
+		info->flags |= NFP_F_SET_PRIO_TXQ;
+		info->flags |= NFP_F_SET_TXQ;
+	} else
+		info->flags &= ~NFP_F_SET_PRIO_TXQ;
+
+	if (classifyFromOif->flags & NFP_F_PRIO_TXP) {
+		info->prio_txp = classifyFromOif->txp;
+		info->flags |= NFP_F_SET_PRIO_TXP;
+		info->flags |= NFP_F_SET_TXP;
+	} else
+		info->flags &= ~NFP_F_SET_PRIO_TXP;
+
+	if (classifyFromOif->flags & NFP_F_PRIO_MH) {
+		info->prio_mh = classifyFromOif->mh;
+		info->flags |= NFP_F_SET_PRIO_MH;
+		info->flags |= NFP_F_SET_MH;
+	} else
+		info->flags &= ~NFP_F_SET_PRIO_MH;
+
+}
+#endif /* NFP_CLASSIFY */
+
+#ifdef NFP_VLAN
+MV_STATUS mvNfpVlanPvidSet(int if_index, MV_U16 pvid)
+{
+	NFP_IF_MAP *vlanIf = mvNfpIfMapGet(if_index);
+
+	if (vlanIf == NULL) {
+		mvOsPrintf("%s: interface %d is not valid\n", __func__, if_index);
+		return MV_NOT_FOUND;
+	}
+
+	if (pvid == NFP_INVALID_VLAN)
+		vlanIf->flags &= ~NFP_F_MAP_VLAN_PVID;
+	else
+		vlanIf->flags |= NFP_F_MAP_VLAN_PVID;
+
+	vlanIf->pvid = pvid;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpVlanVidSet(int if_index, MV_U16 vid)
+{
+	NFP_IF_MAP *vlanIf = mvNfpIfMapGet(if_index);
+
+	if (vlanIf == NULL) {
+		mvOsPrintf("%s: interface %d is not valid\n", __func__, if_index);
+		return MV_NOT_FOUND;
+	}
+	vlanIf->vlanId = vid;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpVlanVidGet(int if_index, MV_U16 *vid)
+{
+	NFP_IF_MAP *vlanIf = mvNfpIfMapGet(if_index);
+
+	if (vlanIf == NULL) {
+		mvOsPrintf("%s: interface %d is not valid\n", __func__, if_index);
+		return MV_NOT_FOUND;
+	}
+	*vid = vlanIf->vlanId;
+
+	return MV_OK;
+}
+
+/* Find virtual interface match vlanId */
+static INLINE NFP_IF_MAP *mvNfpVlanIfFind(NFP_IF_MAP *ifMap, MV_U16 vlanId)
+{
+	NFP_IF_MAP *vlanIf;
+
+	if (ifMap->vlanId == vlanId)
+		return ifMap;
+
+	vlanIf = ifMap->virtIf;
+	while (vlanIf != NULL) {
+		if ((vlanIf->vlanId == vlanId))
+			return vlanIf;
+
+		vlanIf = vlanIf->virtNext;
+	}
+	return NULL;
+}
+
+static INLINE MV_STATUS mvNfpVlanRx(int port, NETA_RX_DESC *pRxDesc, MV_U8 *pData,
+				    MV_ETH_PKT *pPkt, NFP_IF_MAP **ppIfMap,
+				    MV_NFP_RESULT *pRes)
+{
+	MV_U16     vlanId;
+	NFP_IF_MAP *vlanIfMap = NULL, *ifMap = *ppIfMap;
+
+	/* PVID processing */
+	if (NETA_RX_IS_VLAN(pRxDesc)) {
+		/* tagged packets */
+		if (ifMap->flags & NFP_F_MAP_VLAN_RX_DROP_TAGGED) {
+			/* Drop tagged packets */
+			NFP_INC(port, vlan_rx_tag_drop);
+			return MV_DROPPED;
+		}
+		vlanId = *((MV_U16 *)(pData + MV_ETH_MH_SIZE + sizeof(MV_802_3_HEADER)));
+		vlanId = MV_16BIT_BE(vlanId);
+#ifdef NFP_CLASSIFY
+		mvNfpVpriPktClassifySave(vlanId, (NFP_CLASSIFY_INFO *)(pRes->privateData));
+#endif /* NFP_CLASSIFY */
+		vlanId &= 0xFFF;
+	} else {
+		/* Untagged packet */
+		if (ifMap->flags & NFP_F_MAP_VLAN_RX_DROP_UNTAGGED) {
+			/* Drop untagged packets */
+			NFP_INC(port, vlan_rx_untag_drop);
+			return MV_DROPPED;
+		}
+		if (ifMap->flags & NFP_F_MAP_VLAN_PVID)
+			vlanId = ifMap->pvid;
+		else
+			vlanId = NFP_INVALID_VLAN;
+	}
+	pPkt->vlanId = vlanId;
+
+	if (vlanId != NFP_INVALID_VLAN) {
+		/* Tagged packet */
+		/* look for vlanId through virtual interfaces mapped to this ifMap */
+		vlanIfMap = mvNfpVlanIfFind(ifMap, vlanId);
+		if (vlanIfMap) {
+			/* found */
+			NFP_INC(port, vlan_rx_found);
+			*ppIfMap = vlanIfMap;
+			return MV_CONTINUE;
+		}
+		/* not found */
+		if (ifMap->flags & NFP_F_MAP_VLAN_RX_DROP_UNKNOWN) {
+			/* Drop packets with unknown VIDs */
+			NFP_INC(port, vlan_rx_unknown_drop);
+			return MV_DROPPED;
+		}
+	}
+	/* Default - Transparent mode */
+	NFP_INC(port, vlan_rx_trans);
+	return MV_CONTINUE;
+}
+
+static INLINE int mvNfpVlanAdd(int port, MV_U8 *pData, MV_U16 vid, MV_BOOL moveMac, MV_NFP_RESULT *pRes)
+{
+	MV_U8  *pNew;
+	MV_U16 *pVlan;
+
+	NFP_INC(port, vlan_tx_add);
+
+	pNew = pData - MV_VLAN_HLEN;
+	if (moveMac) {
+		/* move MAC header 4 bytes left. Copy 12 bytes (DA + SA) */
+		*(MV_U32 *)(pNew + 2) = *(MV_U32 *)(pData + 2);
+		*(MV_U32 *)(pNew + 2 + 4) = *(MV_U32 *)(pData + 2 + 4);
+		*(MV_U32 *)(pNew + 2 + 4 + 4) = *(MV_U32 *)(pData + 2 + 4 + 4);
+	}
+	pVlan = (MV_U16 *)(pNew + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE);
+	/* Set VLAN Type - 0x8100 */
+	*pVlan = MV_16BIT_BE(MV_VLAN_TYPE);
+	pVlan++;
+	/* Set VID + priority */
+#ifdef NFP_CLASSIFY
+	mvNfpVpriClassifyUpdate(&vid, (NFP_CLASSIFY_INFO *)(pRes->privateData));
+#endif /* NFP_CLASSIFY */
+	*pVlan = MV_16BIT_BE(vid);
+
+	return -MV_VLAN_HLEN;
+}
+
+static INLINE int mvNfpVlanRemove(int port, MV_U8 *pData, MV_BOOL moveMac)
+{
+	MV_U8  *pNew;
+
+	NFP_INC(port, vlan_tx_remove);
+
+	if (moveMac) {
+		/* move MAC header 4 bytes right. Copy 12 bytes (DA + SA) */
+		pNew = pData + MV_VLAN_HLEN;
+		*(MV_U32 *)(pNew + 2 + 4 + 4) = *(MV_U32 *)(pData + 2 + 4 + 4);
+		*(MV_U32 *)(pNew + 2 + 4) = *(MV_U32 *)(pData + 2 + 4);
+		*(MV_U32 *)(pNew + 2) = *(MV_U32 *)(pData + 2);
+	}
+	return MV_VLAN_HLEN;
+}
+
+static INLINE int mvNfpVlanReplace(int port, MV_U8 *pData, MV_U16 vid, MV_NFP_RESULT *pRes)
+{
+	MV_U16 *pVlan;
+
+	NFP_INC(port, vlan_tx_replace);
+
+	pVlan = (MV_U16 *)(pData + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE);
+	/* Set VLAN Type - 0x8100 */
+	*pVlan = MV_16BIT_BE(MV_VLAN_TYPE);
+	pVlan++;
+	/* Set VID + priority */
+#ifdef NFP_CLASSIFY
+	mvNfpVpriClassifyUpdate(&vid, (NFP_CLASSIFY_INFO *)(pRes->privateData));
+#endif /* NFP_CLASSIFY */
+	*pVlan = MV_16BIT_BE(vid);
+
+	return 0;
+}
+
+static INLINE int mvNfpVlanTxUpdate(int port, NETA_RX_DESC *pRxDesc, NFP_IF_MAP *pOutIf,
+					MV_U8 *pData, MV_ETH_PKT *pPkt, MV_BOOL saveMac,
+					MV_NFP_RESULT *pRes)
+{
+	int vlanShift = 0;
+
+	if (NETA_RX_IS_VLAN(pRxDesc)) {
+		/* Original packet was tagged */
+		if (pOutIf->flags & NFP_F_MAP_VLAN_TX_UNTAGGED)
+			vlanShift = mvNfpVlanRemove(port, pData, saveMac);
+		else if (pOutIf->flags & NFP_F_MAP_VLAN_TX_TAGGED)
+			vlanShift = mvNfpVlanReplace(port, pData, pOutIf->vlanId, pRes);
+	} else {
+		/* Original packet was untagged */
+		if (pOutIf->flags & NFP_F_MAP_VLAN_TX_TAGGED)
+			vlanShift = mvNfpVlanAdd(port, pData, pOutIf->vlanId, saveMac, pRes);
+		else if (pPkt->vlanId != NFP_INVALID_VLAN) /* PVID case */
+			vlanShift = mvNfpVlanAdd(port, pData, pPkt->vlanId, saveMac, pRes);
+	}
+	pPkt->bytes -= vlanShift;
+	return vlanShift;
+}
+#endif /* NFP_VLAN */
+
+#ifdef NFP_PPP
+/* Find PPPoE interface with the "sid" */
+static INLINE NFP_IF_MAP *mvNfpPppIfFind(NFP_IF_MAP *ifMap, MV_U16 sid)
+{
+	NFP_IF_MAP *virtIf;
+
+	if ((ifMap->flags & NFP_F_MAP_PPPOE) && (ifMap->sid == sid))
+		return ifMap;
+
+	virtIf = ifMap->virtIf;
+	while (virtIf != NULL) {
+		if ((virtIf->flags & NFP_F_MAP_PPPOE) && (virtIf->sid == sid))
+			return virtIf;
+
+		virtIf = virtIf->virtNext;
+	}
+	return NULL;
+}
+
+MV_STATUS mvNfpPppAdd(int ifIndex, MV_U16 sid, MV_U8 *remoteMac)
+{
+	NFP_IF_MAP *pppIf = mvNfpIfMapGet(ifIndex);
+
+	if (pppIf == NULL) {
+		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIndex);
+		return MV_NOT_FOUND;
+	}
+	/* Copy SA MAC address from parent interface */
+	memcpy(pppIf->mac, pppIf->parentIf->mac, MV_MAC_ADDR_SIZE);
+
+	memcpy(pppIf->remoteMac, remoteMac, MV_MAC_ADDR_SIZE);
+	pppIf->sid = MV_16BIT_BE(sid);
+	pppIf->flags |= NFP_F_MAP_PPPOE;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPppDel(int ifIndex)
+{
+	NFP_IF_MAP *pppIf = mvNfpIfMapGet(ifIndex);
+
+	if (pppIf == NULL) {
+		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIndex);
+		return MV_NOT_FOUND;
+	}
+	pppIf->flags &= ~NFP_F_MAP_PPPOE;
+	pppIf->sid = 0;
+	mvOsMemset(pppIf->remoteMac, 0, MV_MAC_ADDR_SIZE);
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPppRx(int port, NETA_RX_DESC *pRxDesc, MV_U8 *pData, MV_ETH_PKT *pPkt ,
+					 NFP_IF_MAP **ppIfMap, MV_IP_HEADER_INFO *pIpHdrInfo)
+{
+	unsigned char *pIpHdr;
+	PPPoE_HEADER  *pPppHdr;
+	NFP_IF_MAP    *ifMap = *ppIfMap;
+	NFP_IF_MAP    *ifPppMap = NULL;
+
+	if (NETA_RX_IS_PPPOE(pRxDesc)) {
+		pIpHdr = (unsigned char *)pIpHdrInfo->ip_hdr.ip4;
+		pPppHdr = (PPPoE_HEADER *)(pIpHdr - MV_PPPOE_HDR_SIZE);
+
+		ifPppMap = mvNfpPppIfFind(ifMap, pPppHdr->session);
+		if (ifPppMap == NULL) {
+			NFP_WARN("%s: PPPoE sid=%d not found; ifMap->name=%s\n",
+				__func__, MV_16BIT_BE(pPppHdr->session), ifMap->name);
+			NFP_INC(port, pppoe_rx_not_found);
+			return MV_TERMINATE;
+		}
+		NFP_INC(port, pppoe_rx_found);
+	}
+	return MV_CONTINUE;
+}
+#endif /* NFP_PPP */
+
+
+#ifdef NFP_BRIDGE
+/* Do bridging: MV_OK - bridging, MV_TERMINATE - slow path, MV_CONTINUE - Routing */
+static INLINE MV_STATUS  mvNfpBridgeRx(int port, NETA_RX_DESC *pRxDesc, NFP_IF_MAP *inIfMap, MV_ETH_PKT *pPkt,
+				       MV_NFP_RESULT *pRes)
+{
+	int             shift = 0;
+	MV_U8           *pData;
+	MV_U8           *da, *sa;
+	NFP_IF_MAP      *outIfMap;
+#ifdef NFP_FDB_MODE
+	NFP_RULE_FDB	*fdbRule;
+#else
+	NFP_RULE_BRIDGE	*bridgeRule;
+#endif
+#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
+	int prio;
+	NFP_CLASSIFY_INFO *classifyInfo = (NFP_CLASSIFY_INFO *)(pRes->privateData);
+#endif /* NFP_CLASSIFY */
+
+	pData = pPkt->pBuf + pPkt->offset;
+	da = pData + MV_ETH_MH_SIZE;
+	sa = da + MV_MAC_ADDR_SIZE;
+
+#ifdef NFP_FDB_MODE
+	/* BridgeIf + SA lookup */
+	fdbRule = mvNfpFdbLookup(inIfMap->bridgeIf, pData + MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE);
+	if (fdbRule == NULL) {
+		NFP_INC(port, fdb_sa_miss);
+		return MV_TERMINATE;
+	}
+	/* Check if FDB entry move to other port of the bridge */
+	if (fdbRule->if_index != inIfMap->ifIdx) {
+		NFP_INC(port, fdb_port_miss);
+		return MV_TERMINATE;
+	}
+
+	/* BridgeIf + DA lookup */
+	fdbRule = mvNfpFdbLookup(inIfMap->bridgeIf, pData + MV_ETH_MH_SIZE);
+	if (fdbRule == NULL) {
+		NFP_INC(port, fdb_da_miss);
+		return MV_TERMINATE;
+	}
+	fdbRule->age++;
+
+	if (fdbRule->status == NFP_BRIDGE_LOCAL) {
+		NFP_INC(port, fdb_local);
+		return MV_CONTINUE;
+	}
+	outIfMap = mvNfpIfMapGet(fdbRule->if_index);
+	if (outIfMap == NULL) {
+		mvOsPrintf("%s: bridge rule interface %d is not valid\n", __func__, fdbRule->if_index);
+		NFP_INC(port, oif_err);
+		return MV_TERMINATE;
+	}
+	NFP_INC(port, fdb_hit);
+#else
+	bridgeRule = mvNfpBridgeLookup(da, sa, inIfMap->ifIdx);
+	if (bridgeRule == NULL) {
+		NFP_INC(port, bridge_miss);
+		return MV_TERMINATE;
+	}
+	bridgeRule->age++;
+
+#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
+	if (bridgeRule->flags & NFP_F_BR_SET_VLAN_PRIO)
+		mvNfpVpriBridgeClassifySave(pData, bridgeRule, classifyInfo);
+	if (bridgeRule->flags & NFP_F_BR_SET_TXQ)
+		mvNfpTxqClassifySave(bridgeRule->txq, classifyInfo);
+	if (bridgeRule->flags & NFP_F_BR_SET_TXP)
+		mvNfpTxpClassifySave(bridgeRule->txp, classifyInfo);
+	if (bridgeRule->flags & NFP_F_BR_SET_MH)
+		mvNfpMhClassifySave(bridgeRule->mh, classifyInfo);
+#endif /* NFP_CLASSIFY */
+
+	/* Check if this is a local bridge rule (DA is "to me") */
+	if (inIfMap->bridgeIf == bridgeRule->oif) {
+		NFP_INC(port, bridge_local);
+		return MV_CONTINUE;
+	}
+	outIfMap = mvNfpIfMapGet(bridgeRule->oif);
+	if (outIfMap == NULL) {
+		mvOsPrintf("%s: bridge rule out interface %d is not valid\n", __func__, bridgeRule->oif);
+		NFP_INC(port, oif_err);
+		return MV_TERMINATE;
+	}
+#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
+	prio = mvNfpClassifyPrioGet(classifyInfo);
+	if (prio != NFP_PRIO_INVALID)
+		mvNfpClassifyPrioSave(outIfMap, classifyInfo, prio);
+#endif /* NFP_CLASSIFY */
+
+	NFP_INC(port, bridge_hit);
+#endif /* NFP_FDB_MODE */
+
+#ifdef NFP_VLAN
+	/* Process VLAN tag */
+	shift += mvNfpVlanTxUpdate(port, pRxDesc, outIfMap, pData + shift, pPkt, MV_TRUE, pRes);
+#endif /* NFP_VLAN */
+
+	while (outIfMap->parentIf)
+		outIfMap = outIfMap->parentIf;
+
+	/* Update pPkt for bridging TX */
+	pRes->dev = outIfMap->dev;
+	if (outIfMap->flags & NFP_F_MAP_EXT)
+		pRes->flags |= MV_NFP_RES_NETDEV_EXT;
+
+	/* Process 2B of MH */
+	if (outIfMap->flags & NFP_F_MAP_TX_MH) {
+		/* Transmit with MH */
+		*(MV_U16 *)(pData + shift) = outIfMap->txMh;
+#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
+		/* allow setting MH only for PON ports */
+		if (MV_PON_PORT(outIfMap->port))
+			mvNfpMhClassifyUpdate(pData + shift, classifyInfo);
+#endif /* NFP_CLASSIFY */
+	} else {
+		/* Transmit without MH */
+		shift += MV_ETH_MH_SIZE;
+		pPkt->bytes -= MV_ETH_MH_SIZE;
+	}
+
+	pRes->shift = shift;
+
+#if defined(NFP_CLASSIFY) && !defined(NFP_FDB_MODE)
+	mvNfpTxqClassifyUpdate(pRes, classifyInfo);
+
+	/* allow setting txp only for PON ports */
+	if (MV_PON_PORT(outIfMap->port))
+		mvNfpTxpClassifyUpdate(pRes, classifyInfo);
+
+#endif /* NFP_CLASSIFY */
+
+	pRes->tx_cmd = NETA_TX_L4_CSUM_NOT;
+
+	if ((pRes->flags & MV_NFP_RES_NETDEV_EXT) == 0)
+		mvOsCacheLineFlush(NULL, pData);
+	return MV_OK;
+}
+#endif /* NFP_BRIDGE */
+
+#ifdef NFP_NAT
+static INLINE void mvNfpNatUpdate(MV_IP_HEADER_INFO *pIpInfo, NFP_RULE_CT *pCt, MV_NFP_RESULT *pRes, NFP_IF_MAP *pOutIf)
+{
+	MV_IP_HEADER *pIpHdr = pIpInfo->ip_hdr.ip4;
+	char          *l4Hdr = ((char *)pIpHdr + pIpInfo->ipHdrLen);
+	MV_U16        *pPort;
+	MV_U32        old_val = 0, new_val = 0;
+	int           csum;
+
+	if ((pIpHdr->protocol == MV_IP_PROTO_UDP) && (((MV_UDP_HEADER *)l4Hdr)->check == 0)) {
+		/* skip L4 csum */
+		csum = 0;
+	} else if ((pOutIf->flags & NFP_F_MAP_EXT) ||
+			needFragment(pIpInfo, pOutIf) ||
+			(pIpInfo->ipLen > MV_ETH_TX_CSUM_MAX_SIZE)) {
+		/* L4 checksum must be calculated by SW */
+		csum = 1;
+	} else {
+		/* L4 checksum can be calculated by HW */
+		csum = 2;
+	}
+
+	if (pCt->flags & NFP_F_CT_SNAT) {
+		pPort = (MV_U16 *)l4Hdr;
+
+		if (csum == 1) {
+			old_val = pIpHdr->srcIP + *pPort;
+			new_val = pCt->new_sip + pCt->new_sport;
+		}
+		pIpHdr->srcIP = pCt->new_sip;
+		*pPort = pCt->new_sport;
+	}
+
+	if (pCt->flags & NFP_F_CT_DNAT) {
+		pPort = (MV_U16 *)(l4Hdr + 2);
+
+		if (csum == 1) {
+			old_val += pIpHdr->dstIP + *pPort;
+			new_val += pCt->new_dip + pCt->new_dport;
+		}
+		pIpHdr->dstIP = pCt->new_dip;
+		*pPort = pCt->new_dport;
+	}
+
+	switch (csum) {
+	case 0:
+		pRes->pWrite = l4Hdr + sizeof(MV_UDP_HEADER);
+		break;
+
+	case 1:
+		pRes->diffL4[0] = ~old_val;
+		pRes->diffL4[1] = new_val;
+
+		pRes->flags |= MV_NFP_RES_L4_CSUM_NEEDED;
+		break;
+
+	case 2:
+		pRes->tx_cmd &= ~NETA_TX_L4_CSUM_MASK;
+		if (pIpHdr->protocol == MV_IP_PROTO_TCP) {
+			pRes->pWrite = l4Hdr + 4;
+			pRes->tx_cmd |= NETA_TX_L4_TCP | NETA_TX_L4_CSUM_FULL;
+		} else if (pIpHdr->protocol == MV_IP_PROTO_UDP) {
+			pRes->pWrite = l4Hdr + sizeof(MV_UDP_HEADER);
+			pRes->tx_cmd |= NETA_TX_L4_UDP | NETA_TX_L4_CSUM_FULL;
+		}
+		break;
+	}
+}
+#endif /* NFP_NAT */
+
+#ifdef NFP_PPP
+static INLINE int removePppoeHeader(MV_IP_HEADER_INFO *pIpHdrInfo)
+{
+	unsigned char *pIpHdr;
+
+	/* writing IP ethertype to the new location of ether header */
+	if (pIpHdrInfo->family == MV_INET) {
+		pIpHdr = (unsigned char *)(pIpHdrInfo->ip_hdr.ip4);
+		*(pIpHdr - 1) = 0x00;
+		*(pIpHdr - 2) = 0x08;
+	} else {
+		pIpHdr = (unsigned char *)(pIpHdrInfo->ip_hdr.ip6);
+	  *(pIpHdr - 1) = 0xDD;
+	  *(pIpHdr - 2) = 0x86;
+	}
+	return MV_PPPOE_HDR_SIZE;
+}
+
+static INLINE int addPppoeHeader(NFP_IF_MAP *pOutIf, MV_IP_HEADER_INFO *pIpHdrInfo)
+{
+	unsigned char *pIpHdr;
+	PPPoE_HEADER *pPPPNew;
+
+	if (pIpHdrInfo->family == MV_INET)
+		pIpHdr = (unsigned char *)pIpHdrInfo->ip_hdr.ip4;
+	else
+		pIpHdr = (unsigned char *)pIpHdrInfo->ip_hdr.ip6;
+
+	/* Keep VLAN fields*/
+	*(pIpHdr - MV_PPPOE_HDR_SIZE - 3) = *(pIpHdr - 3);
+	*(pIpHdr - MV_PPPOE_HDR_SIZE - 4) = *(pIpHdr - 4);
+	*(pIpHdr - MV_PPPOE_HDR_SIZE - 5) = *(pIpHdr - 5);
+	*(pIpHdr - MV_PPPOE_HDR_SIZE - 6) = *(pIpHdr - 6);
+
+	*(pIpHdr - MV_PPPOE_HDR_SIZE - 1) = 0x64;
+	*(pIpHdr - MV_PPPOE_HDR_SIZE - 2) = 0x88;
+
+	pPPPNew = (PPPoE_HEADER *)(pIpHdr - MV_PPPOE_HDR_SIZE);
+	pPPPNew->version = 0x11;
+	pPPPNew->code = 0x0;
+	pPPPNew->session = pOutIf->sid;
+
+	/* calculate PPPoE payload len considering padding for short packets */
+	if (pIpHdrInfo->family == MV_INET) {
+		pPPPNew->proto =  MV_16BIT_BE(MV_IP_PPP);
+		pPPPNew->len = MV_16BIT_BE(pIpHdrInfo->ipLen + MV_PPP_HDR_SIZE);
+	} else {
+		pPPPNew->proto = MV_16BIT_BE(MV_IP6_PPP);
+		pPPPNew->len = MV_16BIT_BE(pIpHdrInfo->ipLen + MV_PPP_HDR_SIZE + pIpHdrInfo->ipHdrLen);
+	}
+	return -MV_PPPOE_HDR_SIZE;
+}
+
+
+static INLINE void replacePppoeHeader(NFP_IF_MAP *pOutIf, MV_IP_HEADER_INFO *pIpHdrInfo)
+{
+	PPPoE_HEADER *pPPPHdr;
+	unsigned char *pIpHdr;
+
+	pIpHdr = (unsigned char *)pIpHdrInfo->ip_hdr.ip4;
+	pPPPHdr = (PPPoE_HEADER *)(pIpHdr - MV_PPPOE_HDR_SIZE);
+	if (pPPPHdr)
+		pPPPHdr->session = pOutIf->sid;
+}
+
+
+static INLINE int mvNfpPppTxUpdate(MV_U32 port, NETA_RX_DESC *pRxDesc,
+					NFP_IF_MAP *pOutIf, MV_ETH_PKT *pPkt,
+					MV_IP_HEADER_INFO *pIpHdrInfo)
+{
+	int pppShift = 0;
+
+	if (NETA_RX_IS_PPPOE(pRxDesc)) {
+		/* Ingress packet has PPPoE header */
+		if (pOutIf->flags & NFP_F_MAP_PPPOE) {
+			replacePppoeHeader(pOutIf, pIpHdrInfo);
+			NFP_INC(port, pppoe_tx_replace);
+		} else {
+			/* remove pppoe header */
+			pppShift = removePppoeHeader(pIpHdrInfo);
+			pPkt->bytes -= pppShift;
+			NFP_INC(port, pppoe_tx_remove);
+		}
+	} else {
+		/* Ingress packet doesn't have PPPoE header */
+		if (pOutIf->flags & NFP_F_MAP_PPPOE) {
+			/* add pppoe header */
+			pppShift = addPppoeHeader(pOutIf, pIpHdrInfo);
+			pPkt->bytes -= pppShift;
+			NFP_INC(port, pppoe_tx_add);
+		}
+	}
+	return pppShift;
+}
+#endif /* NFP_PPP */
+
+
+static INLINE MV_STATUS mvNfpStatusCheck(MV_U32 port, const NETA_RX_DESC *pRxDesc)
+{
+#ifndef CONFIG_MV_ETH_PNC
+	if ((pRxDesc->status & ETH_RX_NOT_LLC_SNAP_FORMAT_MASK) == 0) {
+		NFP_INC(port, non_ip);
+		return MV_TERMINATE;
+	}
+#endif /* !CONFIG_MV_ETH_PNC */
+
+	if (NETA_RX_L3_IS_UN(pRxDesc->status)) {
+		NFP_INC(port, non_ip);
+		return MV_TERMINATE;
+	}
+	if (NETA_RX_L3_IS_IP4_ERR(pRxDesc->status)) {
+		NFP_INC(port, ipv4_csum_err);
+		return MV_TERMINATE;
+	}
+	if ((NETA_RX_L4_IS_TCP(pRxDesc->status) ||
+	     NETA_RX_L4_IS_UDP(pRxDesc->status)) &&
+	     (!NETA_RX_L4_CSUM_IS_OK(pRxDesc->status))) {
+		NFP_INC(port, l4_csum_err);
+		return MV_TERMINATE;
+	}
+
+	if (nfpMode == MV_NFP_5_TUPLE) {
+		/* Only UDP or TCP packets with correct checksum are processed in 5 tuple mode */
+		if (!NETA_RX_L4_CSUM_IS_OK(pRxDesc->status)) {
+			NFP_INC(port, l4_unknown);
+			return MV_TERMINATE;
+		}
+	}
+	return MV_CONTINUE;
+}
+
+static INLINE MV_STATUS mvNfpParseIpHeader(MV_U32 port, const NETA_RX_DESC *pRxDesc, MV_U8 *pData,
+							MV_IP_HEADER_INFO *pIpHdr)
+{
+	MV_U8 *pEth;
+
+	pEth = pData + MV_ETH_MH_SIZE;
+	if (pEth[0] & 0x01) {	/* Check multicast and broadcast */
+		NFP_INC(port, mac_mcast);
+		return MV_TERMINATE;
+	}
+
+	pIpHdr->ipOffset = NETA_RX_GET_IPHDR_OFFSET(pRxDesc);
+	pIpHdr->ipHdrLen =  NETA_RX_GET_IPHDR_HDRLEN(pRxDesc) << 2;
+
+	if (NETA_RX_L3_IS_IP6(pRxDesc->status)) {
+		pIpHdr->family = MV_INET6;
+		pIpHdr->ip_hdr.ip6 = (MV_IP6_HEADER *) (pData + pIpHdr->ipOffset);
+		if ((pIpHdr->ip_hdr.ip6)->hoplimit <= 1) {
+			NFP_INC(port, ttl_exp);
+			return MV_TERMINATE;
+		}
+		pIpHdr->ipLen = MV_16BIT_BE(pIpHdr->ip_hdr.ip6->payloadLength);
+		pIpHdr->ipProto = pIpHdr->ip_hdr.ip6->protocol;
+
+		NFP_INC(port, ipv6);
+	} else {
+		pIpHdr->family = MV_INET;
+		pIpHdr->ip_hdr.ip4 = (MV_IP_HEADER *) (pData + pIpHdr->ipOffset);
+		pIpHdr->ipLen = MV_16BIT_BE(pIpHdr->ip_hdr.ip4->totalLength);
+		pIpHdr->ipProto = pIpHdr->ip_hdr.ip4->protocol;
+
+#ifdef NFP_CT
+		if (nfpMode == MV_NFP_5_TUPLE) {
+			if (NETA_RX_IP_IS_FRAG(pRxDesc->status)) {
+				NFP_INC(port, ipv4_rx_frag);
+				return MV_TERMINATE;
+			}
+		}
+#endif /* NFP_CT */
+
+		if ((pIpHdr->ip_hdr.ip4)->ttl <= 1) {
+			NFP_INC(port, ttl_exp);
+			return MV_TERMINATE;
+		}
+		NFP_INC(port, ipv4);
+	}
+	return MV_CONTINUE;
+}
+
+static INLINE MV_STATUS mvNfpFragmentCheck(int port, MV_IP_HEADER_INFO *pIpInfo, NFP_IF_MAP *pOutIf)
+{
+	if (needFragment(pIpInfo, pOutIf)) {
+		if ((pIpInfo->family == MV_INET) &&
+			(pIpInfo->ip_hdr.ip4->fragmentCtrl & MV_16BIT_BE(MV_IP4_DF_FLAG_MASK))) {
+			NFP_INC(port, ip_tx_frag_err);
+			return MV_TERMINATE;
+		}
+		NFP_INC(port, ip_tx_frag);
+	}
+	return MV_CONTINUE;
+}
+
+#ifdef NFP_CLASSIFY
+MV_STATUS mvNfpClassifyModeSet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_MODE mode)
+{
+	if ((feature < MV_NFP_CLASSIFY_FEATURE_DSCP) || (feature > MV_NFP_CLASSIFY_FEATURE_MH)) {
+		mvOsPrintf("%s: Illegal feature value %d\n", __func__, feature);
+		return MV_BAD_PARAM;
+	}
+
+	if ((mode < MV_NFP_CLASSIFY_MODE_DISABLED) || (mode > MV_NFP_CLASSIFY_MODE_LOWEST)) {
+		mvOsPrintf("%s: Illegal mode value %d\n", __func__, mode);
+		return MV_BAD_PARAM;
+	}
+
+	classifyMode[feature] = mode;
+	return MV_OK;
+}
+
+MV_NFP_CLASSIFY_MODE mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE feature)
+{
+	if ((feature < MV_NFP_CLASSIFY_FEATURE_DSCP) || (feature >= MV_NFP_CLASSIFY_FEATURE_INVALID)) {
+		mvOsPrintf("%s: Illegal feature value %d\n", __func__, feature);
+		return MV_NFP_CLASSIFY_MODE_INVALID;
+	}
+	return classifyMode[feature];
+}
+
+MV_STATUS mvNfpExactPolicySet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_POLICY policy)
+{
+	if ((feature < MV_NFP_CLASSIFY_FEATURE_DSCP) || (feature > MV_NFP_CLASSIFY_FEATURE_MH)) {
+		mvOsPrintf("%s: Illegal feature value %d\n", __func__, feature);
+		return MV_BAD_PARAM;
+	}
+
+	if ((policy < MV_NFP_CLASSIFY_POLICY_HIGHEST) || (policy > MV_NFP_CLASSIFY_POLICY_LAST)) {
+		mvOsPrintf("%s: Illegal policy value %d\n", __func__, policy);
+		return MV_BAD_PARAM;
+	}
+
+	exactPolicy[feature] = policy;
+	return MV_OK;
+}
+
+MV_NFP_CLASSIFY_POLICY mvNfpExactPolicyGet(MV_NFP_CLASSIFY_FEATURE feature)
+{
+	if ((feature < MV_NFP_CLASSIFY_FEATURE_DSCP) || (feature > MV_NFP_CLASSIFY_FEATURE_MH)) {
+		mvOsPrintf("%s: Illegal feature value %d\n", __func__, feature);
+		return MV_NFP_CLASSIFY_POLICY_INVALID;
+	}
+
+	return exactPolicy[feature];
+}
+
+MV_STATUS mvNfpPrioPolicySet(MV_NFP_CLASSIFY_POLICY policy)
+{
+	if ((policy < MV_NFP_CLASSIFY_POLICY_HIGHEST) || (policy > MV_NFP_CLASSIFY_POLICY_LOWEST)) {
+		mvOsPrintf("%s: Illegal policy value %d\n", __func__, policy);
+		return MV_NFP_CLASSIFY_POLICY_INVALID;
+	}
+
+	prioPolicy = policy;
+	return MV_OK;
+}
+
+MV_NFP_CLASSIFY_POLICY mvNfpPrioPolicyGet(MV_VOID)
+{
+	return prioPolicy;
+}
+
+
+/* Priority classification API */
+MV_STATUS mvNfpIifToPrioSet(int iif, MV_U8 prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio < NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(iif);
+	if (!ifMap) {
+		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
+		return MV_BAD_PARAM;
+	}
+	ifMap->prio = prio;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIifVlanToPrioSet(int iif, MV_U8 vlan_prio, MV_U8 prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio < NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+	if (vlan_prio < NFP_VPRI_MIN || vlan_prio > NFP_VPRI_MAX) {
+		NFP_WARN("%s: vlan_prio #%d is invalid.\n", __func__, vlan_prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(iif);
+	if (!ifMap) {
+		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
+		return MV_BAD_PARAM;
+	}
+	ifMap->vpri_to_prio[vlan_prio].prio = prio;
+	ifMap->vpri_to_prio[vlan_prio].valid = 1;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIifDscpToPrioSet(int iif, MV_U8 dscp, MV_U8 prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio < NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+	if (dscp < NFP_DSCP_MIN || dscp > NFP_DSCP_MAX) {
+		NFP_WARN("%s: dscp #%d is invalid.\n", __func__, dscp);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(iif);
+	if (!ifMap) {
+		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
+		return MV_BAD_PARAM;
+	}
+	ifMap->dscp_to_prio[dscp].prio = prio;
+	ifMap->dscp_to_prio[dscp].valid = 1;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIifToPrioDel(int iif)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	ifMap = mvNfpIfMapGet(iif);
+	if (!ifMap) {
+		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
+		return MV_BAD_PARAM;
+	}
+	ifMap->prio = NFP_PRIO_INVALID;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIifVlanToPrioDel(int iif, MV_U8 vlan_prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (vlan_prio < NFP_VPRI_MIN || vlan_prio > NFP_VPRI_MAX) {
+		NFP_WARN("%s: vlan_prio #%d is invalid.\n", __func__, vlan_prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(iif);
+	if (!ifMap) {
+		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
+		return MV_BAD_PARAM;
+	}
+	ifMap->vpri_to_prio[vlan_prio].prio = NFP_PRIO_INVALID;
+	ifMap->vpri_to_prio[vlan_prio].valid = 0;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIifDscpToPrioDel(int iif, MV_U8 dscp)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (dscp < NFP_DSCP_MIN || dscp > NFP_DSCP_MAX) {
+		NFP_WARN("%s: dscp #%d is invalid.\n", __func__, dscp);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(iif);
+	if (!ifMap) {
+		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
+		return MV_BAD_PARAM;
+	}
+	ifMap->dscp_to_prio[dscp].prio = NFP_PRIO_INVALID;
+	ifMap->dscp_to_prio[dscp].valid = 0;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToDscpSet(int oif, MV_U8 prio, MV_U8 dscp)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+	if (dscp < NFP_DSCP_MIN || dscp > NFP_DSCP_MAX) {
+		NFP_WARN("%s: dscp #%d is invalid.\n", __func__, dscp);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].dscp = dscp;
+	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_DSCP;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToVprioSet(int oif, MV_U8 prio, MV_U8 vlan_prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+	if (vlan_prio < NFP_VPRI_MIN || vlan_prio > NFP_VPRI_MAX) {
+		NFP_WARN("%s: vlan_prio #%d is invalid.\n", __func__, vlan_prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].vprio = vlan_prio;
+	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_VPRIO;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToTxpSet(int oif, MV_U8 prio, MV_U8 txp)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].txp = txp;
+	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_TXP;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToTxqSet(int oif, MV_U8 prio, MV_U8 txq)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+	if (txq >= CONFIG_MV_ETH_TXQ) {
+		NFP_WARN("%s: txq #%d is invalid.\n", __func__, txq);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].txq = txq;
+	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_TXQ;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToMhSet(int oif, MV_U8 prio, MV_U16 mh)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].mh = mh;
+	ifMap->prio_to_classify[prio].flags |= NFP_F_PRIO_MH;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToDscpDel(int oif, MV_U8 prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_DSCP;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToVprioDel(int oif, MV_U8 prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_VPRIO;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToTxpDel(int oif, MV_U8 prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_TXP;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToTxqDel(int oif, MV_U8 prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_TXQ;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpPrioToMhDel(int oif, MV_U8 prio)
+{
+	NFP_IF_MAP *ifMap   = NULL;
+
+	if (prio <= NFP_PRIO_INVALID || prio > NFP_PRIO_MAX) {
+		NFP_WARN("%s: prio #%d is invalid.\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap) {
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+		return MV_BAD_PARAM;
+	}
+
+	ifMap->prio_to_classify[prio].flags &= ~NFP_F_PRIO_MH;
+
+	return MV_OK;
+}
+
+
+MV_VOID mvNfpIngressPrioDump(int iif)
+{
+	int i;
+	NFP_IF_MAP *ifMap   = NULL;
+
+	ifMap = mvNfpIfMapGet(iif);
+	if (!ifMap)
+		NFP_WARN("%s: iif #%d is invalid\n", __func__, iif);
+
+	mvOsPrintf("ingress interface #%d prio dump\n\n", iif);
+
+	if (ifMap->prio != NFP_PRIO_INVALID)
+		mvOsPrintf("interface priority = %d\n\n", ifMap->prio);
+	else
+		mvOsPrintf("interface priority = invalid (no priority)\n\n");
+
+
+	mvOsPrintf("interface + DSCP to priority Map: \n");
+	mvOsPrintf("      DSCP       Priority\n");
+	for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++) {
+		if (ifMap->dscp_to_prio[i].valid) {
+			if (i == NFP_DSCP_MAP_GLOBAL)
+				mvOsPrintf("      Global     %2d\n", ifMap->dscp_to_prio[i].prio);
+			else
+				mvOsPrintf("      %2d         %2d\n", i, ifMap->dscp_to_prio[i].prio);
+		}
+	}
+
+	mvOsPrintf("\ninterface + Vpri to priority Map: \n");
+	mvOsPrintf("      Vpri       Priority\n");
+	for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++) {
+		if (ifMap->vpri_to_prio[i].valid) {
+			if (i == NFP_VPRI_MAP_GLOBAL)
+				mvOsPrintf("      Global     %2d\n", ifMap->vpri_to_prio[i].prio);
+			else
+				mvOsPrintf("      %2d         %2d\n", i, ifMap->vpri_to_prio[i].prio);
+		}
+	}
+}
+
+MV_VOID mvNfpEgressPrioDump(int oif)
+{
+	int i;
+	NFP_IF_MAP *ifMap   = NULL;
+
+	ifMap = mvNfpIfMapGet(oif);
+	if (!ifMap)
+		NFP_WARN("%s: oif #%d is invalid\n", __func__, oif);
+
+	mvOsPrintf("egress interface #%d prio dump\n\n", oif);
+	mvOsPrintf("interface + prio to classification data Map: \n");
+	mvOsPrintf("      Prio        DSCP        Vpri        TXP         TXQ         MH\n");
+	for (i = 0; i < NFP_PRIO_MAP_SIZE; i++) {
+		if (ifMap->prio_to_classify[i].flags) {
+			mvOsPrintf("      %2d", i);
+
+			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_DSCP)
+				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].dscp);
+			else
+				mvOsPrintf("            ");
+			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_VPRIO)
+				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].vprio);
+			else
+				mvOsPrintf("            ");
+			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_TXP)
+				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].txp);
+			else
+				mvOsPrintf("            ");
+			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_TXQ)
+				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].txq);
+			else
+				mvOsPrintf("            ");
+			if (ifMap->prio_to_classify[i].flags & NFP_F_PRIO_MH)
+				mvOsPrintf("          %2d", ifMap->prio_to_classify[i].mh);
+			mvOsPrintf("\n");
+		}
+	}
+}
+
+static INLINE MV_VOID mvNfpClassifyIifToPrioSave(NFP_IF_MAP *pInIf, NFP_CLASSIFY_INFO *info)
+{
+	info->iif_prio = pInIf->prio;
+}
+
+static INLINE MV_VOID mvNfpClassifyIifVprioToPrioSave(NFP_IF_MAP *pInIf, NFP_CLASSIFY_INFO *info)
+{
+	MV_U8 vprio = info->pkt_vlan_prio;
+	MV_U8 valid = pInIf->vpri_to_prio[vprio].valid;
+
+	info->iif_vlan_prio = (valid) ? pInIf->vpri_to_prio[vprio].prio : NFP_PRIO_INVALID;
+
+}
+
+static INLINE MV_VOID mvNfpClassifyIifDscpToPrioSave(NFP_IF_MAP *pInIf, NFP_CLASSIFY_INFO *info)
+{
+	MV_U8 dscp = info->pkt_dscp;
+	MV_U8 valid = pInIf->dscp_to_prio[dscp].valid;
+
+	info->iif_dscp_prio = (valid) ? pInIf->dscp_to_prio[dscp].prio : NFP_PRIO_INVALID;
+}
+#endif /* NFP_CLASSIFY */
+
+
+static INLINE MV_STATUS mvNfpTwoTupleProcess(MV_U32 port, MV_IP_HEADER_INFO *pIpHdr,
+					     MV_ETH_PKT *pPkt, NFP_RULE_FIB **pFib)
+{
+	MV_U8		*srcL3, *dstL3;
+
+	if (pIpHdr->family == MV_INET) {
+		/* Remove padding */
+		pPkt->bytes = (pIpHdr->ipLen + pIpHdr->ipOffset);
+
+		dstL3 = (MV_U8 *)&(pIpHdr->ip_hdr.ip4->dstIP);
+		srcL3 = (MV_U8 *)&(pIpHdr->ip_hdr.ip4->srcIP);
+	} else {
+		dstL3 = pIpHdr->ip_hdr.ip6->dstAddr;
+		srcL3 = pIpHdr->ip_hdr.ip6->srcAddr;
+	}
+
+	*pFib = mvNfpFibLookup(pIpHdr->family, srcL3, dstL3);
+
+	if (!(*pFib)) {
+		NFP_WARN("%s failed: ", __func__);
+		mvNfp2TupleInfoPrint(NFP_WARN_PRINT, pIpHdr->family, srcL3, dstL3);
+
+		NFP_INC(port, fib_miss);
+		return MV_TERMINATE;
+	}
+	(*pFib)->age++;
+
+	NFP_INC(port, fib_hit);
+
+	return MV_CONTINUE;
+}
+
+#ifdef NFP_CT
+
+#ifdef NFP_CT_LEARN
+/* Check for FIN/RST flags in TCP header */
+static INLINE MV_U8 mvNfpTcpClose(MV_IP_HEADER_INFO *pIpHdr)
+{
+	MV_TCP_HEADER	*pTcpHdr;
+
+	if (pIpHdr->ipProto != MV_IP_PROTO_TCP)
+		return 0;
+
+	pTcpHdr = (MV_TCP_HEADER *)((unsigned)(pIpHdr->ip_hdr.l3) + pIpHdr->ipHdrLen);
+
+	return (MV_16BIT_BE(pTcpHdr->flags) & (MV_TCP_FLAG_RST | MV_TCP_FLAG_FIN));
+}
+#endif /* NFP_CT_LEARN */
+
+static INLINE MV_STATUS mvNfpFiveTupleProcess(MV_U32 port, MV_IP_HEADER_INFO *pIpHdr,
+					      MV_ETH_PKT *pPkt, NFP_RULE_CT **ppCt,
+					      MV_NFP_RESULT *pRes)
+{
+	NFP_RULE_CT	*pCt = NULL;
+	MV_U8		*srcL3, *dstL3;
+	MV_U16 		proto = 0;
+	MV_U32		ports = 0;
+
+	if (pIpHdr->family == MV_INET) {
+		MV_IP_HEADER *pIph = pIpHdr->ip_hdr.ip4;
+
+		/* Remove padding */
+		pPkt->bytes = (pIpHdr->ipLen + pIpHdr->ipOffset);
+
+		dstL3 = (MV_U8 *)&(pIph->dstIP);
+		srcL3 = (MV_U8 *)&(pIph->srcIP);
+		proto = pIph->protocol;
+		ports = *(MV_U32 *)((char *)pIph + pIpHdr->ipHdrLen);
+	} else {
+		MV_IP6_HEADER *pIp6Hdr = pIpHdr->ip_hdr.ip6;
+
+		srcL3 = pIp6Hdr->srcAddr;
+		dstL3 = pIp6Hdr->dstAddr;
+		proto = pIp6Hdr->protocol;
+		ports = *(MV_U32 *)((char *)pIp6Hdr + pIpHdr->ipHdrLen);
+	}
+	pCt = mvNfpCtLookupByTuple(pIpHdr->family, srcL3, dstL3, ports, proto);
+
+	if (!pCt) {
+		NFP_WARN("%s failed: ", __func__);
+		mvNfp5TupleInfoPrint(NFP_WARN_PRINT, pIpHdr->family, srcL3, dstL3,
+					MV_16BIT_BE(ports & 0xFFFF), MV_16BIT_BE((ports >> 16) & 0xFFFF), proto);
+
+		NFP_INC(port, ct_miss);
+		return MV_TERMINATE;
+	}
+	pCt->age++;
+	pCt->hit_cntr++;
+	NFP_INC(port, ct_hit);
+
+#ifdef NFP_CT_LEARN
+	if (mvNfpTcpClose(pIpHdr)) {
+		NFP_INC(port, ct_tcp_fin_rst);
+		return MV_TERMINATE;
+	}
+#endif /* NFP_CT_LEARN */
+
+	if (pCt->flags & NFP_F_CT_DROP)
+		return MV_DROPPED;
+
+	*ppCt = pCt;
+
+#ifdef NFP_CLASSIFY
+	{
+		int txq = 0;
+		NFP_CLASSIFY_INFO *classifyInfo = (NFP_CLASSIFY_INFO *)(pRes->privateData);
+
+		if (pCt->flags & NFP_F_CT_SET_DSCP)
+			mvNfpDscpClassifySave(pCt, classifyInfo);
+		if (pCt->flags & NFP_F_CT_SET_VLAN_PRIO)
+			mvNfpVpriCtClassifySave(pCt, classifyInfo);
+
+		/* classifyInfo->pkt_dscp is updated in mvNfpDscpClassifySave so it is valid here */
+		if (pCt->txq_map[classifyInfo->pkt_dscp].valid)
+			txq = pCt->txq_map[classifyInfo->pkt_dscp].txq;
+		else if (pCt->txq_map[NFP_DSCP_MAP_GLOBAL].valid)
+			txq = pCt->txq_map[NFP_DSCP_MAP_GLOBAL].txq;
+
+		if (pCt->flags & NFP_F_CT_SET_TXQ)
+			mvNfpTxqClassifySave(txq, classifyInfo);
+		if (pCt->flags & NFP_F_CT_SET_TXP)
+			mvNfpTxpClassifySave(pCt->txp, classifyInfo);
+		if (pCt->flags & NFP_F_CT_SET_MH)
+			mvNfpMhClassifySave(pCt->mh, classifyInfo);
+	}
+#endif /* NFP_CLASSIFY */
+#ifdef NFP_LIMIT
+	if (pCt->tbfInfo)
+		return mvNfpTbfProcess(pCt->tbfInfo, pPkt->bytes);
+#endif /* NFP_LIMIT */
+	return MV_CONTINUE;
+}
+#endif /* NFP_CT */
+
+ /* NFP Process */
+MV_STATUS mvNfpRx(MV_U32 port, NETA_RX_DESC *pRxDesc, MV_ETH_PKT *pPkt, MV_NFP_RESULT *pRes)
+{
+	NFP_RULE_FIB      *pFib;
+	MV_U8             *pData;
+	MV_IP_HEADER_INFO *ipHdrInfo = &pRes->ipInfo;
+	int               shift = 0;
+	MV_STATUS         status;
+	NFP_IF_MAP        *pInIf, *pOutIf;
+#ifdef NFP_CT
+	NFP_RULE_CT       *pCt = NULL;
+#endif /* NFP_CT */
+#ifdef NFP_CLASSIFY
+	int prio;
+	NFP_CLASSIFY_INFO classifyInfo;
+
+	mvOsMemset(&classifyInfo, 0, sizeof(NFP_CLASSIFY_INFO));
+	mvNfpClassifyInit(&classifyInfo);
+	pRes->privateData = &classifyInfo;
+#endif /* NFP_CLASSIFY */
+	NFP_INC(port, rx);
+	pData = pPkt->pBuf + pPkt->offset;
+	pRes->flags = 0;
+	pRes->shift = 0;
+	pRes->tx_cmd = NETA_TX_L4_CSUM_NOT;
+
+	/* Lookup incoming interface (port + switchGroup) */
+	pInIf = mvNfpIfMapRealGet(port, pData);
+	if (pInIf == NULL) {
+		NFP_INC(port, iif_err);
+		return MV_TERMINATE;
+	}
+
+#ifdef NFP_CLASSIFY
+	/* map iif to prio */
+	mvNfpClassifyIifToPrioSave(pInIf, &classifyInfo);
+#endif /* NFP_CLASSIFY */
+
+#ifdef NFP_VLAN
+	status = mvNfpVlanRx(port, pRxDesc, pData, pPkt, &pInIf, pRes);
+	if (status != MV_CONTINUE)
+		return status;
+#endif /* NFP_VLAN */
+
+#ifdef NFP_CLASSIFY
+	/* map iif + vlan to prio */
+	mvNfpClassifyIifVprioToPrioSave(pInIf, &classifyInfo);
+#endif /* NFP_CLASSIFY */
+
+#ifdef NFP_BRIDGE
+	if (pInIf->flags & NFP_F_MAP_BRIDGE_PORT) {
+		/* Do bridging: OK - bridging, TERMINATE - slow path, CONTINUE - Routing */
+		status = mvNfpBridgeRx(port, pRxDesc, pInIf, pPkt, pRes);
+		if (status != MV_CONTINUE)
+			return status;
+	}
+#endif /* NFP_BRIDGE */
+
+	status = mvNfpStatusCheck(port, pRxDesc);
+	if (status != MV_CONTINUE)
+		return status;
+
+	status = mvNfpParseIpHeader(port, pRxDesc, pData, ipHdrInfo);
+	if (status != MV_CONTINUE)
+		return status;
+
+	pRes->flags |= MV_NFP_RES_IP_INFO_VALID;
+
+#ifdef NFP_PPP
+		status = mvNfpPppRx(port, pRxDesc, pData, pPkt, &pInIf,  ipHdrInfo);
+		if (status != MV_CONTINUE)
+			return status;
+#endif /* NFP_PPP */
+#ifdef NFP_CLASSIFY
+	mvNfpPktDscpClassifySave(ipHdrInfo, &classifyInfo);
+#endif /* NFP_CLASSIFY */
+	if (nfpMode == MV_NFP_2_TUPLE) {
+		status = mvNfpTwoTupleProcess(port, ipHdrInfo, pPkt, &pFib);
+		if (status != MV_CONTINUE)
+			return status;
+	} else {
+#ifdef NFP_CT
+		status = mvNfpFiveTupleProcess(port, ipHdrInfo, pPkt, &pCt, pRes);
+		if (status != MV_CONTINUE)
+			return status;
+
+		pFib = pCt->fib;
+		pFib->age++;
+#else
+		return MV_TERMINATE;
+#endif /* NFP_CT */
+	}
+#ifdef NFP_CLASSIFY
+	/* map iif + dscp to prio */
+	mvNfpClassifyIifDscpToPrioSave(pInIf, &classifyInfo);
+#endif /* NFP_CLASSIFY */
+	/* At this point pFib is valid */
+	pOutIf = mvNfpIfMapGet(pFib->oif);
+	if (pOutIf == NULL) {
+		mvOsPrintf("%s: fib out interface %d is not valid\n", __func__, pFib->oif);
+		NFP_INC(port, oif_err);
+		return MV_TERMINATE;
+	}
+
+	/* Check if fragmentation needed but don't fragment bit is set */
+	status = mvNfpFragmentCheck(port, ipHdrInfo, pOutIf);
+	if (status != MV_CONTINUE)
+		return status;
+
+	pRes->mtu = pOutIf->mtu;
+	pRes->pWrite = ((MV_U8 *)ipHdrInfo->ip_hdr.l3) + ipHdrInfo->ipHdrLen;
+
+#ifdef NFP_NAT
+	if (pCt && (pCt->flags & (NFP_F_CT_SNAT | NFP_F_CT_DNAT)))
+		mvNfpNatUpdate(ipHdrInfo, pCt, pRes, pOutIf);
+#endif /* NFP_NAT */
+
+	mvNfpFibIpUpdate(ipHdrInfo);
+
+#ifdef NFP_PPP
+	shift = mvNfpPppTxUpdate(port, pRxDesc, pOutIf, pPkt, ipHdrInfo);
+	if (pOutIf->flags & NFP_F_MAP_PPPOE)
+		pOutIf = pOutIf->parentIf;
+#endif /* NFP_PPP */
+
+#ifdef NFP_CLASSIFY
+	prio = mvNfpClassifyPrioGet(&classifyInfo);
+	if (prio != NFP_PRIO_INVALID)
+		mvNfpClassifyPrioSave(pOutIf, &classifyInfo, prio);
+#endif /* NFP_CLASSIFY */
+
+#ifdef NFP_VLAN
+	shift += mvNfpVlanTxUpdate(port, pRxDesc, pOutIf, pData + shift, pPkt, MV_FALSE, pRes);
+#endif /* NFP_VLAN */
+
+	mvNfpFibMacUpdate(pData + shift, pFib);
+
+	while (pOutIf->parentIf)
+		pOutIf = pOutIf->parentIf;
+
+	pRes->dev = pOutIf->dev;
+	if (pOutIf->flags & NFP_F_MAP_EXT)
+		pRes->flags |= MV_NFP_RES_NETDEV_EXT;
+
+#ifdef NFP_CLASSIFY
+	/* Update packet according to classification results */
+
+#ifdef NFP_CT
+	mvNfpDscpClassifyUpdate(ipHdrInfo, &classifyInfo);
+#endif /* NFP_CT */
+
+	/* allow setting MH only for PON ports */
+	if (MV_PON_PORT(pOutIf->port))
+		mvNfpMhClassifyUpdate(pData + shift, &classifyInfo);
+
+	if (classifyInfo.flags & NFP_F_SET_TXQ)
+		mvNfpTxqClassifyUpdate(pRes, &classifyInfo);
+
+	/* allow setting txp only for PON ports */
+	if (MV_PON_PORT(pOutIf->port))
+		mvNfpTxpClassifyUpdate(pRes, &classifyInfo);
+
+#endif /* NFP_CLASSIFY */
+
+	/* Process 2B of MH */
+	if (!(pOutIf->flags & NFP_F_MAP_TX_MH)) {
+		shift += MV_ETH_MH_SIZE;
+		pPkt->bytes -= MV_ETH_MH_SIZE;
+	}
+	pRes->shift = shift;
+
+	if ((pRes->flags & (MV_NFP_RES_L4_CSUM_NEEDED | MV_NFP_RES_NETDEV_EXT)) == 0) {
+
+		/* Flush maximum accessed data before TX */
+		if (shift < 0)
+			pData += shift;
+
+		mvOsCacheMultiLineFlushInv(NULL, pData, (pRes->pWrite - pData));
+	}
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIfMapCreate(NFP_IF_MAP *ifMap2)
+{
+	MV_U32      flags;
+	NFP_IF_MAP  *newMap, *ifMap;
+
+	newMap = mvOsMalloc(sizeof(NFP_IF_MAP));
+	if (newMap == NULL) {
+		mvOsPrintf("%s: can't allocate NFP_IF_MAP\n", __func__);
+		return MV_NO_RESOURCE;
+	}
+	memcpy(newMap, ifMap2, sizeof(NFP_IF_MAP));
+	flags = newMap->flags;
+
+	if (!(flags & NFP_F_MAP_INT))
+		newMap->port = NFP_INVALID_PORT;
+
+	if (flags & NFP_F_MAP_EXT) {
+		if (nfpFreeExtPort >= NFP_MAX_PORTS) {
+			mvOsPrintf("%s: No free place for external interface. nfpFreeExtPort=%d\n",
+				__func__, nfpFreeExtPort);
+			mvOsFree(newMap);
+			return MV_BUSY;
+		}
+		newMap->port = nfpFreeExtPort;
+		nfpFreeExtPort++;
+	}
+
+	if (flags & NFP_F_MAP_SWITCH_PORT) {
+		/* Set MH flag for port */
+		nfp_ports[newMap->port] |= NFP_F_PORT_MH;
+	} else
+		newMap->switchGroup = NFP_INVALID_SWITCH_GROUP;
+
+	if (!(flags & NFP_F_MAP_TX_MH))
+		newMap->txMh = 0;
+
+	newMap->vlanId = NFP_INVALID_VLAN;
+#ifdef NFP_CLASSIFY
+	newMap->prio = NFP_PRIO_INVALID;
+#endif /* NFP_CLASSIFY */
+
+	/* Check if such entry already exist */
+	ifMap = nfp_if_map[newMap->ifIdx & NFP_DEV_HASH_MASK];
+	while (ifMap) {
+		if (ifMap->ifIdx == newMap->ifIdx) {
+			mvOsPrintf("%s: ifMap for ifIdx=%d already exist\n", __func__, newMap->ifIdx);
+			mvOsFree(newMap);
+			return MV_BUSY;
+		}
+		if (mvNfpIfMapCmp(newMap->port, newMap->switchGroup, ifMap)) {
+			mvOsPrintf("%s: ifMap with port=%d, switchGroup=%d already exist\n",
+					__func__, newMap->port, newMap->switchGroup);
+			mvOsFree(newMap);
+			return MV_BUSY;
+		}
+		ifMap = ifMap->nextMap;
+	}
+	/* Add to nfp_if_map */
+	newMap->nextMap = nfp_if_map[newMap->ifIdx & NFP_DEV_HASH_MASK];
+	nfp_if_map[newMap->ifIdx & NFP_DEV_HASH_MASK] = newMap;
+
+	/* Add to nfp_if_real_map */
+	if (newMap->port != NFP_INVALID_PORT) {
+		if (newMap->switchGroup == NFP_INVALID_SWITCH_GROUP)
+			nfp_if_real_map[newMap->port][0] = newMap;
+		else
+			nfp_if_real_map[newMap->port][newMap->switchGroup] = newMap;
+	}
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIfVirtMap(int ifIdx, int virtIf)
+{
+	NFP_IF_MAP *ifMap = mvNfpIfMapGet(ifIdx);
+	NFP_IF_MAP *ifVirt = mvNfpIfMapGet(virtIf);
+	NFP_IF_MAP *ifTemp;
+
+	/* parentIf and virtIf must be created */
+	if ((ifMap == NULL) || (ifVirt == NULL)) {
+		mvOsPrintf("%s: interface not valid - parent=%d (%p), virt=%d (%p)\n",
+				__func__, ifIdx, ifMap, virtIf, ifVirt);
+		return MV_NOT_FOUND;
+	}
+	/* Check validity - TBD */
+
+	/* Set MH as in parent interface */
+	ifVirt->txMh = ifMap->txMh;
+	/* Set external flag if parent is external */
+	if (ifMap->flags & NFP_F_MAP_EXT)
+		ifVirt->flags |= NFP_F_MAP_EXT;
+
+	/* Bind */
+	ifTemp = ifMap->virtIf;
+	ifMap->virtIf = ifVirt;
+	ifVirt->virtNext = ifTemp;
+
+	/* Remember parent interface */
+	ifVirt->parentIf = ifMap;
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIfVirtUnmap(int virtIf)
+{
+	NFP_IF_MAP *ifVirt = mvNfpIfMapGet(virtIf);
+	NFP_IF_MAP *ifUp, *ifTemp;
+
+	if (ifVirt == NULL) {
+		mvOsPrintf("%s: virtual interface is not valid - virt=%d\n",
+				__func__, virtIf);
+		return MV_NOT_FOUND;
+	}
+
+	if (ifVirt->virtIf != NULL) {
+		mvOsPrintf("%s: Can't unmap (%s), virtual interface %s was created\n",
+			__func__, ifVirt->name, ifVirt->virtIf->name);
+		return MV_NOT_FOUND;
+	}
+
+	ifUp = ifVirt->parentIf;
+
+	if (ifUp == NULL) {
+		mvOsPrintf("%s: Can't unmap (%s), parentIf is NULL\n", __func__, ifVirt->name);
+		return MV_NOT_FOUND;
+	}
+
+	ifTemp = ifUp->virtIf;
+	if (ifTemp == ifVirt) {
+		ifUp->virtIf = ifVirt->virtNext;
+		/* FIXME: PPPoE over VLAN */
+		return MV_OK;
+	}
+
+	while (ifTemp->virtNext != NULL) {
+		if (ifTemp->virtNext == ifVirt) {
+			ifTemp->virtNext = ifVirt->virtNext;
+			/* FIXME: PPPoE over VLAN */
+			return MV_OK;
+		}
+		ifTemp = ifTemp->virtNext;
+	}
+
+	mvOsPrintf("%s: virtual interface %d is not mapped to interface %d\n",
+				__func__, virtIf, ifUp->ifIdx);
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpIfFlagsSet(int ifIdx, MV_U32 flags)
+{
+	NFP_IF_MAP *ifMap = mvNfpIfMapGet(ifIdx);
+
+	if (ifMap == NULL) {
+		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIdx);
+		return MV_NOT_FOUND;
+	}
+	ifMap->flags |= flags;
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIfFlagsClear(int ifIdx, MV_U32 flags)
+{
+	NFP_IF_MAP *ifMap = mvNfpIfMapGet(ifIdx);
+
+	if (ifMap == NULL) {
+		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIdx);
+		return MV_NOT_FOUND;
+	}
+	ifMap->flags &= ~flags;
+	return MV_OK;
+}
+
+MV_STATUS mvNfpIfMapMacUpdate(int ifIdx, const MV_U8 *mac)
+{
+	NFP_IF_MAP *map = mvNfpIfMapGet(ifIdx);
+
+	if (map != NULL) {
+		mvOsMemcpy(map->mac, mac, MV_MAC_ADDR_SIZE);
+		return MV_OK;
+	}
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpIfMapMtuUpdate(int ifIdx, int mtu)
+{
+	NFP_IF_MAP *map = mvNfpIfMapGet(ifIdx);
+
+	if (map != NULL) {
+		map->mtu = mtu;
+		return MV_OK;
+	}
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpIfMapPortGet(int ifIdx, int *port)
+{
+	NFP_IF_MAP *ifMap = mvNfpIfMapGet(ifIdx);
+
+	if (ifMap && (ifMap->port != NFP_INVALID_PORT)) {
+		*port = ifMap->port;
+		return MV_OK;
+	}
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpIfMapDelete(int ifIdx)
+{
+	MV_U32 hash = 0;
+	NFP_IF_MAP *currMap = NULL, *prevMap = NULL;
+
+	if ((ifIdx <= 0) || (mvNfpIfMapGet(ifIdx) == NULL)) {
+		mvOsPrintf("%s: interface %d is not valid\n", __func__, ifIdx);
+		return MV_BAD_PARAM;
+	}
+	hash = (ifIdx & NFP_DEV_HASH_MASK);
+
+	/* remove from nfp_if_map */
+	for (currMap = nfp_if_map[hash]; currMap != NULL; prevMap = currMap, currMap = currMap->nextMap) {
+		if (currMap->ifIdx == ifIdx) {
+			if (prevMap == NULL)
+				nfp_if_map[hash] = currMap->nextMap;
+			else
+				prevMap->nextMap = currMap->nextMap;
+
+			/* do not delete element yet, need to remove it from nfp_if_real_map */
+			break;
+		}
+	}
+
+	if (currMap) {
+		if (currMap->port != NFP_INVALID_PORT) {
+			/* remove from nfp_if_real_map */
+			if (currMap->switchGroup == NFP_INVALID_SWITCH_GROUP)
+				nfp_if_real_map[currMap->port][0] = NULL;
+			else
+				nfp_if_real_map[currMap->port][currMap->switchGroup] = NULL;
+		}
+		/* delete element */
+		mvOsFree(currMap);
+		return MV_OK;
+	}
+	return MV_NOT_FOUND;
+}
+
+#ifdef NFP_BRIDGE
+/* There are functions common for mvNfpBridge.c and for mvNfpFdb.c */
+MV_STATUS mvNfpIfToBridgeAdd(int bridgeIf, int portIf)
+{
+	NFP_IF_MAP  *portIfMap = mvNfpIfMapGet(portIf);
+	NFP_IF_MAP  *bridgeIfMap = mvNfpIfMapGet(bridgeIf);
+
+	if (bridgeIfMap == NULL) {
+		mvOsPrintf("%s: trying to add interface (%d) to non-registered bridge (%d)\n",
+			__func__, portIf, bridgeIf);
+		return MV_NOT_FOUND;
+	}
+	if (!(bridgeIfMap->flags & NFP_F_MAP_BRIDGE) || (bridgeIfMap->ifIdx != bridgeIf)) {
+		mvOsPrintf("%s: Wrong bridgeIf=%d\n", __func__, bridgeIf);
+		return MV_FAIL;
+	}
+
+	if (portIfMap != NULL) {
+		/* Check that port_if isn't already connected to an other bridge */
+		if ((portIfMap->flags & NFP_F_MAP_BRIDGE_PORT) && (portIfMap->bridgeIf != bridgeIf))
+			return MV_BUSY;
+
+		portIfMap->flags |= NFP_F_MAP_BRIDGE_PORT;
+		portIfMap->bridgeIf = bridgeIf;
+		return MV_OK;
+	}
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpIfToBridgeDel(int bridge_if, int port_if)
+{
+	NFP_IF_MAP  *portIfMap = mvNfpIfMapGet(port_if);
+
+	if (portIfMap != NULL) {
+		/* Check that port_if is connected to this bridge */
+		if (!(portIfMap->flags & NFP_F_MAP_BRIDGE_PORT) || (portIfMap->bridgeIf != bridge_if))
+			return MV_BAD_PARAM;
+
+		portIfMap->flags &= ~NFP_F_MAP_BRIDGE_PORT;
+		portIfMap->bridgeIf = 0;
+		return MV_OK;
+	}
+	return MV_NOT_FOUND;
+}
+
+MV_BOOL mvNfpIfOnSameBridge(NFP_IF_MAP *ifMap1, NFP_IF_MAP *ifMap2)
+{
+	if ((ifMap1 != NULL) && (ifMap2 != NULL)) {
+		/* first interface is bridge and second is port on the same bridge */
+		if ((ifMap1->flags & NFP_F_MAP_BRIDGE) &&
+			(ifMap2->flags & NFP_F_MAP_BRIDGE_PORT) &&
+			(ifMap1->ifIdx == ifMap2->bridgeIf))
+			return MV_TRUE;
+
+		/* second interface is bridge and first is port on the same bridge */
+		if ((ifMap1->flags & NFP_F_MAP_BRIDGE_PORT) &&
+			(ifMap2->flags & NFP_F_MAP_BRIDGE) &&
+			(ifMap1->bridgeIf == ifMap2->ifIdx))
+			return MV_TRUE;
+
+		/* two interfaces are ports of the same bridge */
+		if ((ifMap1->flags & NFP_F_MAP_BRIDGE_PORT) &&
+		    (ifMap2->flags & NFP_F_MAP_BRIDGE_PORT) &&
+		    (ifMap1->bridgeIf == ifMap2->bridgeIf))
+			return MV_TRUE;
+	}
+	return MV_FALSE;
+}
+#endif /* NFP_BRIDGE */
+
+MV_VOID mvNfpIpInfoPrint(u32 dbgLevel, int family, u8 *ipAddr)
+{
+	if (nfpDebugLevel & dbgLevel) {
+		if (family == MV_INET)
+			mvOsPrintf("IPv4: " MV_IPQUAD_FMT "\n",	MV_IPQUAD(ipAddr));
+		else
+			mvOsPrintf("IPv6: " MV_IP6_FMT "\n", MV_IP6_ARG(ipAddr));
+	}
+}
+
+MV_VOID mvNfp2TupleInfoPrint(u32 dbgLevel, int family, u8 *srcL3, u8 *dstL3)
+{
+	if (nfpDebugLevel & dbgLevel) {
+		if (family == MV_INET)
+			mvOsPrintf("IPv4: " MV_IPQUAD_FMT "->" MV_IPQUAD_FMT"\n",
+				MV_IPQUAD(srcL3), MV_IPQUAD(dstL3));
+		else
+			mvOsPrintf("IPv6: " MV_IP6_FMT "->" MV_IP6_FMT"\n",
+				MV_IP6_ARG(srcL3), MV_IP6_ARG(dstL3));
+	}
+}
+
+
+MV_VOID mvNfp5TupleInfoPrint(u32 dbgLevel, int family, u8 *srcL3, u8 *dstL3, u16 sport, u16 dport, u8 proto)
+{
+	if (nfpDebugLevel & dbgLevel) {
+		if (family == MV_INET)
+			mvOsPrintf("IPv4: " MV_IPQUAD_FMT ":%d->" MV_IPQUAD_FMT":%d",
+				MV_IPQUAD(srcL3), sport, MV_IPQUAD(dstL3), dport);
+		else
+			mvOsPrintf("IPv6: " MV_IP6_FMT ":%d->" MV_IP6_FMT":%d",
+				MV_IP6_ARG(srcL3), sport, MV_IP6_ARG(dstL3), dport);
+
+		if (proto == MV_IP_PROTO_TCP)
+			mvOsPrintf(", proto = TCP\n");
+		else if (proto == MV_IP_PROTO_UDP)
+			mvOsPrintf(", proto = UDP\n");
+		else
+			mvOsPrintf(", proto = Unknown (%d)\n", proto);
+	}
+}
+
+static void mvNfpIfMapPrint(NFP_IF_MAP *ifMap)
+{
+	mvOsPrintf(" %8s  %3d  %3d   %3d   %4d  0x%04x  "MV_MACQUAD_FMT"  %4d  %3d  %3d    0x%04x\n",
+				ifMap->name, ifMap->ifIdx, ifMap->port, ifMap->switchGroup, ifMap->vlanId,
+				ifMap->txMh, MV_MACQUAD(ifMap->mac), ifMap->mtu,
+				ifMap->bridgeIf, ifMap->parentIf ? ifMap->parentIf->ifIdx : ifMap->ifIdx, ifMap->flags);
+	if (ifMap->virtIf) {
+		NFP_IF_MAP *ifVirt = ifMap->virtIf;
+
+		mvOsPrintf("\t Virtual list: ");
+		while (ifVirt) {
+			mvOsPrintf(" %d,", ifVirt->ifIdx);
+			ifVirt = ifVirt->virtNext;
+		}
+		mvOsPrintf("\n");
+	}
+}
+
+MV_VOID mvNfpIfMapDump(void)
+{
+	int		i;
+	NFP_IF_MAP	*ifMap;
+
+	mvOsPrintf("\n(ifMap - direct)\n");
+	mvOsPrintf("[No]:      name   idx  port  swGr  vid   txMh           mac         mtu  brIf  upIf  flags\n");
+	for (i = 0; i < NFP_DEV_HASH_SZ; i++) {
+		ifMap = nfp_if_map[i];
+
+		while (ifMap != NULL) {
+			mvOsPrintf("[%2d]: ", i);
+			mvNfpIfMapPrint(ifMap);
+			ifMap = ifMap->nextMap;
+		}
+	}
+	mvOsPrintf("\n");
+	mvOsPrintf("(ifMap - Real)\n");
+	mvOsPrintf("[Port][Group]:      name  idx\n");
+	for (i = 0; i < NFP_MAX_PORTS; i++) {
+		int j;
+
+		for (j = 0; j < NFP_MAX_SWITCH_GROUPS; j++) {
+			ifMap = nfp_if_real_map[i][j];
+			if (ifMap != NULL)
+				mvOsPrintf("[%4d][%5d]:  %8s  %3d\n", i, j, ifMap->name, ifMap->ifIdx);
+		}
+	}
+}
+
+MV_VOID mvNfpStats(MV_U32 port)
+{
+	if ((port < 0) || (port >= NFP_MAX_PORTS)) {
+		mvOsPrintf("Invalid port number %d\n", port);
+		return;
+	}
+
+	mvOsPrintf("\n====================================================\n");
+	mvOsPrintf(" NFP statistics");
+	mvOsPrintf("\n----------------------------------------------------\n");
+
+#ifdef NFP_STAT
+	mvOsPrintf("nfp_rx........................%10u\n", nfp_stats[port].rx);
+	mvOsPrintf("nfp_iif_err...................%10u\n", nfp_stats[port].iif_err);
+	mvOsPrintf("nfp_oif_err...................%10u\n", nfp_stats[port].oif_err);
+
+#ifdef NFP_VLAN
+	mvOsPrintf("nfp_vlan_rx_tag_drop..........%10u\n", nfp_stats[port].vlan_rx_tag_drop);
+	mvOsPrintf("nfp_vlan_rx_untag_drop........%10u\n", nfp_stats[port].vlan_rx_untag_drop);
+	mvOsPrintf("nfp_vlan_rx_unknown_drop......%10u\n", nfp_stats[port].vlan_rx_unknown_drop);
+	mvOsPrintf("nfp_vlan_rx_found.............%10u\n", nfp_stats[port].vlan_rx_found);
+	mvOsPrintf("nfp_vlan_rx_trans.............%10u\n", nfp_stats[port].vlan_rx_trans);
+	mvOsPrintf("nfp_vlan_tx_add...............%10u\n", nfp_stats[port].vlan_tx_add);
+	mvOsPrintf("nfp_vlan_tx_remove............%10u\n", nfp_stats[port].vlan_tx_remove);
+	mvOsPrintf("nfp_vlan_tx_replace...........%10u\n", nfp_stats[port].vlan_tx_replace);
+#endif /* NFP_VLAN */
+
+#ifdef NFP_BRIDGE
+#ifdef NFP_FDB_MODE
+	mvOsPrintf("nfp_fdb_local.................%10u\n", nfp_stats[port].fdb_local);
+	mvOsPrintf("nfp_fdb_sa_miss...............%10u\n", nfp_stats[port].fdb_sa_miss);
+	mvOsPrintf("nfp_fdb_da_miss...............%10u\n", nfp_stats[port].fdb_da_miss);
+	mvOsPrintf("nfp_fdb_port_miss.............%10u\n", nfp_stats[port].fdb_port_miss);
+	mvOsPrintf("nfp_fdb_hit...................%10u\n", nfp_stats[port].fdb_hit);
+#else
+	mvOsPrintf("nfp_bridge_miss...............%10u\n", nfp_stats[port].bridge_miss);
+	mvOsPrintf("nfp_bridge_hit................%10u\n", nfp_stats[port].bridge_hit);
+	mvOsPrintf("nfp_bridge_local..............%10u\n", nfp_stats[port].bridge_local);
+#endif /* NFP_FDB_MODE */
+#endif /* NFP_BRIDGE */
+
+	mvOsPrintf("nfp_non_ip....................%10u\n", nfp_stats[port].non_ip);
+	mvOsPrintf("nfp_ipv4_csum_err.............%10u\n", nfp_stats[port].ipv4_csum_err);
+	mvOsPrintf("nfp_mac_mcast.................%10u\n", nfp_stats[port].mac_mcast);
+	mvOsPrintf("nfp_ttl_exp...................%10u\n", nfp_stats[port].ttl_exp);
+	mvOsPrintf("nfp_l4_unknown................%10u\n", nfp_stats[port].l4_unknown);
+	mvOsPrintf("nfp_l4_csum_err...............%10u\n", nfp_stats[port].l4_csum_err);
+	mvOsPrintf("nfp_ipv4......................%10u\n", nfp_stats[port].ipv4);
+	mvOsPrintf("nfp_ipv6......................%10u\n", nfp_stats[port].ipv6);
+	mvOsPrintf("nfp_ip_rx_frag................%10u\n", nfp_stats[port].ipv4_rx_frag);
+	mvOsPrintf("nfp_ip_tx_frag................%10u\n", nfp_stats[port].ip_tx_frag);
+	mvOsPrintf("nfp_ip_tx_frag_err............%10u\n", nfp_stats[port].ip_tx_frag_err);
+
+#ifdef NFP_PPP
+	mvOsPrintf("pppoe_rx_not_found............%10u\n", nfp_stats[port].pppoe_rx_not_found);
+	mvOsPrintf("pppoe_rx_found................%10u\n", nfp_stats[port].pppoe_rx_found);
+	mvOsPrintf("pppoe_tx_add..................%10u\n", nfp_stats[port].pppoe_tx_add);
+	mvOsPrintf("pppoe_tx_remove...............%10u\n", nfp_stats[port].pppoe_tx_remove);
+	mvOsPrintf("pppoe_tx_replace..............%10u\n", nfp_stats[port].pppoe_tx_replace);
+#endif /* NFP_PPP */
+
+#ifdef NFP_FIB
+	mvOsPrintf("nfp_fib_hit...................%10u\n", nfp_stats[port].fib_hit);
+	mvOsPrintf("nfp_fib_miss..................%10u\n", nfp_stats[port].fib_miss);
+#endif /* NFP_FIB */
+
+#ifdef NFP_CT
+	mvOsPrintf("nfp_ct_hit....................%10u\n", nfp_stats[port].ct_hit);
+	mvOsPrintf("nfp_ct_miss...................%10u\n", nfp_stats[port].ct_miss);
+	mvOsPrintf("nfp_ct_tcp_fin_rst............%10u\n", nfp_stats[port].ct_tcp_fin_rst);
+#ifdef NFP_NAT
+	mvOsPrintf("nfp_dnat_hit..................%10u\n", nfp_stats[port].dnat_hit);
+	mvOsPrintf("nfp_dnat_miss.................%10u\n", nfp_stats[port].dnat_miss);
+	mvOsPrintf("nfp_dnat_inv..................%10u\n", nfp_stats[port].dnat_inv);
+
+	mvOsPrintf("nfp_snat_hit..................%10u\n", nfp_stats[port].snat_hit);
+	mvOsPrintf("nfp_snat_miss.................%10u\n", nfp_stats[port].snat_miss);
+	mvOsPrintf("nfp_snat_inv..................%10u\n", nfp_stats[port].snat_inv);
+#endif /* NFP_NAT */
+#endif /* NFP_CT */
+
+	mvOsMemset(&nfp_stats[port], 0, sizeof(NFP_STATS));
+#endif /* NFP_STAT */
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfp.h
@@ -0,0 +1,1143 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvNfp.h - Header File for Marvell NFP
+*
+* DESCRIPTION:
+*       This header file contains macros, typedefs and function declarations
+* 	specific to the Marvell Network Fast Processing.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __mvNfp_h__
+#define __mvNfp_h__
+
+#include "mvSysHwConfig.h"
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvStack.h"
+#include "mvList.h"
+#include "mv802_3.h"
+#include "gbe/mvEthRegs.h"
+#include "pnc/mvPnc.h"
+
+#include "mvNfpDefs.h"
+
+/* Enable / Disable NFP Debug Prints: */
+
+#define NFP_DBG(x...)  if (nfpDebugLevel & NFP_DBG_PRINT) mvOsPrintf(x)
+/*#define NFP_WARN(x...)*/
+
+#define NFP_WARN(x...)  if (nfpDebugLevel & NFP_WARN_PRINT) mvOsPrintf(x)
+/*#define NFP_WARN(x...)*/
+
+#define	NFP_NO_PRINT	0x0
+#define	NFP_DBG_PRINT	0x1
+#define	NFP_WARN_PRINT	0x2
+
+/* defined in mvNfp.c */
+extern MV_U32 nfpDebugLevel;
+
+extern MV_U32	 nfp_ports[];
+extern MV_U32    nfp_jhash_iv;
+
+#ifdef CONFIG_MV_ETH_SWITCH
+/* switchGroup coded by bits[4-7] of MSB in Marvell header */
+#define NFP_SWITCH_GROUP(port, mh)       	\
+		((nfp_ports[port] & NFP_F_PORT_MH) ? ((*(MV_U8 *)(mh)) >> 4) : NFP_INVALID_SWITCH_GROUP)
+#else
+# define NFP_SWITCH_GROUP(port, mh)      NFP_INVALID_SWITCH_GROUP
+#endif /* CONFIG_MV_ETH_SWITCH */
+
+/* NFP Operation Mode */
+typedef enum {
+	MV_NFP_DISABLED	= 0,
+	MV_NFP_2_TUPLE	= 1,
+	MV_NFP_5_TUPLE	= 2,
+	MV_NFP_MODE_LAST
+} MV_NFP_MODE;
+
+typedef enum {
+	MV_NFP_OFF = 0,
+	MV_NFP_ON  = 1,
+	MV_NFP_STATE_LAST
+} MV_NFP_STATE;
+
+
+static INLINE MV_U32 mv_jhash_array(const MV_U8 *k, MV_U32 length, MV_U32 initval)
+{
+	MV_U32 a, b, c, l;
+
+	l = length;
+	a = b = MV_JHASH_GOLDEN_RATIO;
+	c = initval;
+
+	while (l >= 12) {
+		a += (k[0] + ((MV_U32) k[1] << 8) + ((MV_U32) k[2] << 16) + ((MV_U32) k[3] << 24));
+		b += (k[4] + ((MV_U32) k[5] << 8) + ((MV_U32) k[6] << 16) + ((MV_U32) k[7] << 24));
+		c += (k[8] + ((MV_U32) k[9] << 8) + ((MV_U32) k[10] << 16) + ((MV_U32) k[11] << 24));
+		MV_JHASH_MIX(a, b, c);
+		k += 12;
+		l -= 12;
+	}
+
+	c += length;
+	switch (l) {
+	case 11:
+		c += ((MV_U32) k[10] << 24);
+	case 10:
+		c += ((MV_U32) k[9] << 16);
+	case 9:
+		c += ((MV_U32) k[8] << 8);
+	case 8:
+		b += ((MV_U32) k[7] << 24);
+	case 7:
+		b += ((MV_U32) k[6] << 16);
+	case 6:
+		b += ((MV_U32) k[5] << 8);
+	case 5:
+		b += k[4];
+	case 4:
+		a += ((MV_U32) k[3] << 24);
+	case 3:
+		a += ((MV_U32) k[2] << 16);
+	case 2:
+		a += ((MV_U32) k[1] << 8);
+	case 1:
+		a += k[0];
+	default:
+		/* do nothing */;
+	}
+
+	MV_JHASH_MIX(a, b, c);
+	return c;
+}
+
+
+static INLINE MV_U32 mv_jhash_2addr(int family, const MV_U8 *aa, const MV_U8 *ab, MV_U32 c, MV_U32 initval)
+{
+	MV_U32 a, b;
+
+	if (family == MV_INET6) {
+		a = mv_jhash_array(aa, 16, initval);
+		b = mv_jhash_array(ab, 16, initval);
+	} else {
+		a = *((const MV_U32 *)(aa));
+		b = *((const MV_U32 *)(ab));
+	}
+
+	return mv_jhash_3words(a, b, c, initval);
+}
+
+static INLINE MV_U32 mv_jhash_2macs(const MV_U8 *da, const MV_U8 *sa, MV_U32 c, MV_U32 initval)
+{
+	MV_U32 a, b;
+
+	a = mv_jhash_array(da, MV_MAC_ADDR_SIZE, initval);
+	b = mv_jhash_array(sa, MV_MAC_ADDR_SIZE, initval);
+
+	return mv_jhash_3words(a, b, c, initval);
+}
+
+static INLINE MV_U32 mv_jhash_1addr(int family, const MV_U8 *aa, MV_U32 b, MV_U32 c, MV_U32 initval)
+{
+	MV_U32 a;
+
+	if (family == MV_INET6)
+		a = mv_jhash_array(aa, 16, initval);
+	else
+		a = *((const MV_U32 *)(aa));
+
+	return mv_jhash_3words(a, b, c, initval);
+}
+
+/* L3 address copy. Supports AF_INET and AF_INET6 */
+static inline MV_VOID l3_addr_copy(int family, u8 *dst, const u8 *src)
+{
+	const u32 *s = (const u32 *)src;
+	u32 *d = (u32 *) dst;
+
+	*d++ = *s++;		/* 4 */
+	if (family == MV_INET)
+		return;
+
+	*d++ = *s++;		/* 8 */
+	*d++ = *s++;		/* 12 */
+	*d++ = *s++;		/* 16 */
+}
+
+static INLINE MV_U32 l3_addr_eq(int family, const MV_U8 *a, const MV_U8 *b)
+{
+	const MV_U32 *aa = (const MV_U32 *)a;
+	const MV_U32 *bb = (const MV_U32 *)b;
+	MV_U32 r;
+
+	r = *aa++ ^ *bb++;	/* 4 */
+	if (family == MV_INET)
+		return !r;
+
+	r |= *aa++ ^ *bb++;	/* 8 */
+	r |= *aa++ ^ *bb++;	/* 12 */
+	r |= *aa++ ^ *bb++;	/* 16 */
+
+	return !r;
+}
+
+/*******************************
+ * Hash tables size definitions
+ *******************************/
+
+#define NFP_DEV_HASH_BITS	7
+#define NFP_DEV_HASH_SZ		(1 << NFP_DEV_HASH_BITS)
+#define NFP_DEV_HASH_MASK	(NFP_DEV_HASH_SZ - 1)
+
+#define	NFP_FDB_HASH_BITS	14
+#define	NFP_FSB_HASH_SIZE	(1 << NFP_FDB_HASH_BITS)
+#define	NFP_FDB_HASH_MASK	(NFP_FDB_HASH_SIZE - 1)
+
+#define	NFP_BRIDGE_HASH_BITS	14
+#define	NFP_BRIDGE_HASH_SIZE	(1 << NFP_BRIDGE_HASH_BITS)
+#define	NFP_BRIDGE_HASH_MASK	(NFP_BRIDGE_HASH_SIZE - 1)
+
+#define	NFP_ARP_HASH_BITS	14
+#define	NFP_ARP_HASH_SIZE	(1 << NFP_ARP_HASH_BITS)
+#define	NFP_ARP_HASH_MASK	(NFP_ARP_HASH_SIZE - 1)
+
+#define	NFP_FIB_HASH_BITS	14
+#define	NFP_FIB_HASH_SIZE	(1 << NFP_FIB_HASH_BITS)
+#define	NFP_FIB_HASH_MASK	(NFP_FIB_HASH_SIZE - 1)
+
+#define	NFP_CT_HASH_BITS	14
+#define	NFP_CT_HASH_SIZE	(1 << NFP_CT_HASH_BITS)
+#define	NFP_CT_HASH_MASK	(NFP_CT_HASH_SIZE - 1)
+
+/*********
+ * Flags
+ *********/
+
+/* Flags relevant for port capabilities */
+#define NFP_F_PORT_MH           0x1
+
+/* Flags relevant for NFP_IF_MAP, to be used in NFP_IF_MAP flags */
+#define NFP_F_MAP_INT                    0x0001
+#define NFP_F_MAP_EXT                    0x0002
+#define NFP_F_MAP_SWITCH_PORT            0x0004
+#define NFP_F_MAP_BRIDGE                 0x0008
+#define NFP_F_MAP_BRIDGE_PORT            0x0010
+#define NFP_F_MAP_TX_MH                  0x0020
+#define NFP_F_MAP_VLAN_PVID              0x0040
+#define NFP_F_MAP_VLAN_RX_DROP_TAGGED    0x0080
+#define NFP_F_MAP_VLAN_RX_DROP_UNTAGGED  0x0100
+#define NFP_F_MAP_VLAN_RX_DROP_UNKNOWN   0x0200
+#define NFP_F_MAP_VLAN_RX_FLAGS          (NFP_F_MAP_VLAN_RX_DROP_TAGGED | NFP_F_MAP_VLAN_RX_DROP_UNTAGGED | \
+										NFP_F_MAP_VLAN_RX_DROP_UNKNOWN)
+
+#define NFP_F_MAP_VLAN_TX_TAGGED         0x0400
+#define NFP_F_MAP_VLAN_TX_UNTAGGED       0x0800
+#define NFP_F_MAP_VLAN_TX_FLAGS          (NFP_F_MAP_VLAN_TX_UNTAGGED | NFP_F_MAP_VLAN_TX_TAGGED)
+
+#define NFP_F_MAP_PPPOE                  0x1000
+
+/* Flags relevant for NFP Bridging, to be used in NFP_RULE_BRIDGE flags */
+#define NFP_F_BR_SET_VLAN_PRIO  0x1
+#define NFP_F_BR_SET_TXQ        0x2
+#define NFP_F_BR_SET_TXP        0x4
+#define NFP_F_BR_SET_MH         0x8
+#define NFP_F_BR_NOT_EXIST      0x10
+
+/* Flags relevant for NFP FIB rules, to be used in NFP_RULE_FIB flags */
+#define NFP_F_FIB_BRIDGE_INV    0x1
+#define NFP_F_FIB_ARP_INV       0x2
+#define NFP_F_FIB_HWF           0x4
+#define NFP_F_FIB_ALL_FLAGS	    (NFP_F_FIB_BRIDGE_INV | NFP_F_FIB_ARP_INV | NFP_F_FIB_HWF)
+
+/* Flags relevant for 5 Tuple NFP mode (CT), to be used in NFP_RULE_CT flags */
+#define	NFP_F_CT_SNAT           0x1
+#define	NFP_F_CT_DNAT           0x2
+#define NFP_F_CT_DROP           0x4
+#define NFP_F_CT_SET_DSCP       0x8
+#define NFP_F_CT_SET_VLAN_PRIO  0x10
+#define NFP_F_CT_SET_TXQ        0x20
+#define NFP_F_CT_SET_TXP        0x40
+#define NFP_F_CT_SET_MH         0x80
+#define NFP_F_CT_LIMIT          0x100
+#define NFP_F_CT_FIB_INV        0x200
+#define NFP_F_CT_HWF            0x400
+#define NFP_F_CT_UDP_CSUM       0x800
+#define NFP_F_CT_NOT_EXIST      0x1000
+
+
+/* Flags relevant for classification info NFP_CLASSIFY_INFO */
+#define NFP_F_SET_TXQ			0x01
+#define NFP_F_SET_TXP			0x02
+#define NFP_F_SET_MH			0x04
+#define NFP_F_SET_VLAN_PRIO		0x08
+#define NFP_F_SET_DSCP			0x10
+#define NFP_F_SET_PRIO_TXQ		0x20
+#define NFP_F_SET_PRIO_TXP		0x40
+#define NFP_F_SET_PRIO_MH		0x80
+#define NFP_F_SET_PRIO_VLAN_PRIO	0x100
+#define NFP_F_SET_PRIO_DSCP		0x200
+#define NFP_F_SET_EXACT_TXQ		0x400
+#define NFP_F_SET_EXACT_TXP		0x800
+#define NFP_F_SET_EXACT_MH		0x1000
+#define NFP_F_SET_EXACT_VLAN_PRIO	0x2000
+#define NFP_F_SET_EXACT_DSCP		0x4000
+
+#define NFP_INVALID_VLAN          4096
+#define NFP_INVALID_VPRIO         -1
+#define NFP_INVALID_DSCP          -1
+#define NFP_INVALID_TXP	          255
+#define NFP_INVALID_TXQ	          255
+#define NFP_INVALID_MH	          0xFFFF
+#define NFP_INVALID_SWITCH_GROUP  255
+#define NFP_INVALID_PORT          255
+
+/*****************************
+ * Classification definitions
+ *****************************/
+
+#ifdef NFP_CLASSIFY
+
+/* 0..7 + one cell for global mapping regardless of the old VLAN Prio value (the '-1' option) */
+#define NFP_VPRI_MAP_SIZE	9
+#define NFP_VPRI_MAP_GLOBAL	8 /* index in the array for the global mapping */
+#define NFP_VPRI_MIN		0
+#define NFP_VPRI_MAX		7
+
+typedef struct {
+	MV_U16 eth_type; /* Used for bridging VLAN priority mapping */
+	MV_U8 new_prio;
+	MV_U8 valid;
+} NFP_VPRI_MAP_INFO;
+
+
+#define	MV_ETH_NFP_GLOBAL_MAP	-1
+
+/* 0..63 + one cell for global mapping regardless of the old DSCP value (the '-1' option) */
+#define NFP_DSCP_MAP_SIZE	65
+#define NFP_DSCP_MAP_GLOBAL	64 /* index in the array for the global mapping */
+#define NFP_DSCP_MIN		0
+#define NFP_DSCP_MAX		63
+
+typedef struct {
+	MV_U8 new_dscp;
+	MV_U8 valid;
+} NFP_DSCP_MAP_INFO;
+
+typedef struct {
+	MV_U8 txq;
+	MV_U8 valid;
+} NFP_TXQ_MAP_INFO;
+
+#define MV_NFP_CLASSIFY_FEATURES	5
+
+typedef enum {
+	MV_NFP_CLASSIFY_FEATURE_DSCP		= 0,
+	MV_NFP_CLASSIFY_FEATURE_VPRIO		= 1,
+	MV_NFP_CLASSIFY_FEATURE_TXQ		= 2,
+	MV_NFP_CLASSIFY_FEATURE_TXP		= 3,
+	MV_NFP_CLASSIFY_FEATURE_MH		= 4,
+	MV_NFP_CLASSIFY_FEATURE_INVALID	= 5,
+} MV_NFP_CLASSIFY_FEATURE;
+
+typedef enum {
+	MV_NFP_CLASSIFY_MODE_DISABLED	= 0,
+	MV_NFP_CLASSIFY_MODE_EXACT	= 1,
+	MV_NFP_CLASSIFY_MODE_PRIO	= 2,
+	MV_NFP_CLASSIFY_MODE_HIGHEST	= 3,
+	MV_NFP_CLASSIFY_MODE_LOWEST	= 4,
+	MV_NFP_CLASSIFY_MODE_INVALID  = 5,
+} MV_NFP_CLASSIFY_MODE;
+
+typedef enum {
+	MV_NFP_CLASSIFY_POLICY_HIGHEST	= 0,
+	MV_NFP_CLASSIFY_POLICY_LOWEST	= 1,
+	MV_NFP_CLASSIFY_POLICY_FIRST	= 2,
+	MV_NFP_CLASSIFY_POLICY_LAST	= 3,
+	MV_NFP_CLASSIFY_POLICY_EXACT	= 4,
+	MV_NFP_CLASSIFY_POLICY_PRIORITY	= 5,
+	MV_NFP_CLASSIFY_POLICY_INVALID = 6,
+} MV_NFP_CLASSIFY_POLICY;
+
+MV_STATUS mvNfpClassifyModeSet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_MODE mode);
+MV_NFP_CLASSIFY_MODE mvNfpClassifyModeGet(MV_NFP_CLASSIFY_FEATURE feature);
+
+MV_STATUS mvNfpExactPolicySet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_POLICY policy);
+MV_NFP_CLASSIFY_POLICY mvNfpExactPolicyGet(MV_NFP_CLASSIFY_FEATURE feature);
+MV_STATUS mvNfpPrioPolicySet(MV_NFP_CLASSIFY_POLICY policy);
+MV_NFP_CLASSIFY_POLICY mvNfpPrioPolicyGet(MV_VOID);
+MV_STATUS mvNfpMixedPolicySet(MV_NFP_CLASSIFY_FEATURE feature, MV_NFP_CLASSIFY_POLICY policy);
+MV_NFP_CLASSIFY_POLICY mvNfpMixedPolicyGet(MV_NFP_CLASSIFY_FEATURE feature);
+
+/* Priority classification API */
+#define NFP_PRIO_MAP_SIZE 64
+#define NFP_PRIO_MAX 63
+#define NFP_PRIO_INVALID -1
+
+/* Flags relevant for NFP_PRIO_CLASSIFY_INFO */
+#define NFP_F_PRIO_DSCP		0x01
+#define NFP_F_PRIO_VPRIO	0x02
+#define NFP_F_PRIO_TXP		0x04
+#define NFP_F_PRIO_TXQ		0x08
+#define NFP_F_PRIO_MH		0x10
+
+typedef struct {
+	MV_U8 prio;
+	MV_U8 valid;
+} NFP_PRIO_MAP_INFO;
+
+
+typedef struct {
+	MV_U16 flags;
+	MV_U8  txp;
+	MV_U8  txq;
+	int dscp;
+	int vprio;
+	MV_U16 mh;
+} NFP_PRIO_CLASSIFY_INFO;
+
+MV_STATUS mvNfpIifToPrioSet(int iif, MV_U8 prio);
+MV_STATUS mvNfpIifVlanToPrioSet(int iif, MV_U8 vlan_prio, MV_U8 prio);
+MV_STATUS mvNfpIifDscpToPrioSet(int iif, MV_U8 dscp, MV_U8 prio);
+
+MV_STATUS mvNfpIifToPrioDel(int iif);
+MV_STATUS mvNfpIifVlanToPrioDel(int iif, MV_U8 vlan_prio);
+MV_STATUS mvNfpIifDscpToPrioDel(int iif, MV_U8 dscp);
+
+MV_STATUS mvNfpPrioToDscpSet(int oif, MV_U8 prio, MV_U8 dscp);
+MV_STATUS mvNfpPrioToVprioSet(int oif, MV_U8 prio, MV_U8 vlan_prio);
+MV_STATUS mvNfpPrioToTxpSet(int oif, MV_U8 prio, MV_U8 txp);
+MV_STATUS mvNfpPrioToTxqSet(int oif, MV_U8 prio, MV_U8 txq);
+MV_STATUS mvNfpPrioToMhSet(int oif, MV_U8 prio, MV_U16 mh);
+
+MV_STATUS mvNfpPrioToDscpDel(int oif, MV_U8 prio);
+MV_STATUS mvNfpPrioToVprioDel(int oif, MV_U8 prio);
+MV_STATUS mvNfpPrioToTxpDel(int oif, MV_U8 prio);
+MV_STATUS mvNfpPrioToTxqDel(int oif, MV_U8 prio);
+MV_STATUS mvNfpPrioToMhDel(int oif, MV_U8 prio);
+
+MV_VOID mvNfpIngressPrioDump(int iif);
+MV_VOID mvNfpEgressPrioDump(int oif);
+#endif /* NFP_CLASSIFY */
+
+
+/*****************
+ * Interface Map
+ *****************/
+
+typedef struct nfp_if_map {
+
+	struct nfp_if_map *nextMap;
+	struct nfp_if_map *parentIf;
+	struct nfp_if_map *virtIf;
+	struct nfp_if_map *virtNext;
+	int     ifIdx;
+	char    name[16];
+	MV_VOID *dev;
+	MV_U8   port;
+	MV_U8   switchGroup;
+	MV_U16  pvid;
+	MV_U16  txMh;
+	MV_U8   mac[MV_MAC_ADDR_SIZE];
+	MV_U16  vlanId;
+	int     mtu;
+	int     bridgeIf;
+	MV_U32  flags;
+#ifdef NFP_PPP
+	MV_U16  sid;
+	MV_U8   remoteMac[MV_MAC_ADDR_SIZE];
+#endif /* NFP_PPP */
+
+#ifdef NFP_CLASSIFY
+	int prio;
+	NFP_PRIO_MAP_INFO dscp_to_prio[NFP_DSCP_MAP_SIZE];
+	NFP_PRIO_MAP_INFO vpri_to_prio[NFP_VPRI_MAP_SIZE];
+	NFP_PRIO_CLASSIFY_INFO prio_to_classify[NFP_PRIO_MAP_SIZE];
+#endif /* NFP_CLASSIFY */
+} NFP_IF_MAP;
+
+extern NFP_IF_MAP  *nfp_if_map[NFP_DEV_HASH_SZ];
+extern NFP_IF_MAP  *nfp_if_real_map[NFP_MAX_PORTS][NFP_MAX_SWITCH_GROUPS];
+
+static INLINE NFP_IF_MAP *mvNfpIfMapGet(int ifIdx)
+{
+	NFP_IF_MAP *ifMap = nfp_if_map[ifIdx & NFP_DEV_HASH_MASK];
+
+	while (ifMap != NULL) {
+		if (ifMap->ifIdx == ifIdx)
+			return ifMap;
+		ifMap = ifMap->nextMap;
+	}
+	return NULL;
+}
+
+static INLINE int mvNfpIfMapCmp(int port, MV_U8 switchGroup, NFP_IF_MAP *ifMap)
+{
+	if ((ifMap->port == port) && (ifMap->switchGroup == switchGroup))
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+static INLINE NFP_IF_MAP *mvNfpIfMapRealGet(int port, MV_U8 *mh)
+{
+	MV_U8		switchGroup;
+	NFP_IF_MAP	*ifMap;
+
+	/* Support port and switchGroup */
+	switchGroup = NFP_SWITCH_GROUP(port, mh);
+	if (switchGroup == NFP_INVALID_SWITCH_GROUP)
+		ifMap = nfp_if_real_map[port][0];
+	else
+		ifMap = nfp_if_real_map[port][switchGroup];
+
+	if ((ifMap) && mvNfpIfMapCmp(port, switchGroup, ifMap))
+		return ifMap;
+
+	return NULL;
+}
+
+
+/************
+ * Bridging
+ ************/
+
+#ifdef NFP_BRIDGE
+
+#define NFP_BRIDGE_INV		0
+#define NFP_BRIDGE_LOCAL	1
+#define NFP_BRIDGE_NON_LOCAL	2
+
+typedef struct nfp_rule_fdb {
+	struct nfp_rule_fdb *next;
+	MV_U16 reserved;
+	MV_U8  mac[MV_MAC_ADDR_SIZE];
+	int    bridgeIf;
+	int    if_index;
+	MV_U32 age;
+	MV_U8  status;
+
+} NFP_RULE_FDB;
+
+extern NFP_RULE_FDB **nfp_fdb_hash;
+
+static INLINE MV_U32 mvNfpFdbRuleHash(int bridgeIf, const MV_U8 *mac)
+{
+	MV_U32 hash = 0;
+	int    align = (MV_U32)mac & 3;
+
+	switch (align) {
+	case 0:
+		/* SA - 4 byte alignement - BE support TBD */
+		hash = mv_jhash_3words(bridgeIf, *(MV_U16 *)(mac), (*(MV_U16 *)(mac + 2)) | ((*(MV_U16 *)(mac + 4)) << 16),
+							nfp_jhash_iv);
+		break;
+
+	case 2:
+		/* DA - 2 byte alignement */
+		hash = mv_jhash_3words(bridgeIf, *(MV_U16 *)(mac), *(MV_U32 *)(mac + 2), nfp_jhash_iv);
+		break;
+
+	default:
+		mvOsPrintf("%s: Unexpected alignment: mac=%p\n", __func__, mac);
+	}
+
+	hash &= NFP_BRIDGE_HASH_MASK;
+	return hash;
+}
+
+static INLINE MV_STATUS mvNfpFdbRuleCmp(MV_U16 bridgeIf, const MV_U8 *mac, NFP_RULE_FDB *rule)
+{
+	int    align = (MV_U32)mac & 3;
+
+	switch (align) {
+	case 0:
+		/* SA - 4 byte alignement */
+		if ((rule->bridgeIf == bridgeIf) &&
+			(*(MV_U16 *)(rule->mac)) == (*(MV_U16 *)(mac)) &&
+			(*(MV_U16 *)(rule->mac + 2)) == (*(MV_U16 *)(mac + 2)) &&
+			(*(MV_U16 *)(rule->mac + 4)) == (*(MV_U16 *)(mac + 4)))
+			return MV_TRUE;
+		break;
+	case 2:
+		/* DA - 2 byte alignement */
+		if ((rule->bridgeIf == bridgeIf) &&
+			(*(MV_U16 *)(rule->mac)) == (*(MV_U16 *)(mac)) &&
+			(*(MV_U32 *)(rule->mac + 2)) == (*(MV_U32 *)(mac + 2)))
+			return MV_TRUE;
+		break;
+	default:
+		mvOsPrintf("%s: Unexpected alignment: mac=%p\n", __func__, mac);
+	}
+	return MV_FALSE;
+}
+
+static INLINE NFP_RULE_FDB *mvNfpFdbLookup(MV_U16 bridgeIf, const MV_U8 *mac)
+{
+	MV_U32 hash;
+	NFP_RULE_FDB *rule;
+
+	hash = mvNfpFdbRuleHash(bridgeIf, mac);
+
+	rule = nfp_fdb_hash[hash];
+	while (rule) {
+		if (mvNfpFdbRuleCmp(bridgeIf, mac, rule))
+			return rule;
+
+		rule = rule->next;
+	}
+	return NULL;
+}
+
+typedef struct nfp_rule_bridge {
+	struct nfp_rule_bridge *next;
+	MV_U16  reserved;
+	MV_U8	da[MV_MAC_ADDR_SIZE];
+	MV_U8	sa[MV_MAC_ADDR_SIZE];
+	int	iif;
+	int	oif;
+	MV_U32	flags;
+	MV_U32	age;
+#ifdef NFP_CLASSIFY
+	NFP_VPRI_MAP_INFO  vpri_map[NFP_VPRI_MAP_SIZE];
+	MV_U8	txq;
+	MV_U8	txp;
+	MV_U16  mh;
+#endif /* NFP_CLASSIFY */
+
+} NFP_RULE_BRIDGE;
+
+extern NFP_RULE_BRIDGE **nfp_bridge_hash;
+
+
+static INLINE MV_U32 mvNfpBridgeRuleHash(const MV_U8 *da, const MV_U8 *sa, MV_U16 iif)
+{
+	MV_U32 hash = mv_jhash_2macs(da, sa, iif, nfp_jhash_iv);
+	hash &= NFP_BRIDGE_HASH_MASK;
+	return hash;
+}
+
+
+static INLINE MV_STATUS mvNfpBridgeRuleCmp(const MV_U8 *da, const MV_U8 *sa, MV_U16 iif, NFP_RULE_BRIDGE *rule)
+{
+	if ((iif == rule->iif) &&
+	    (*(MV_U16 *)(rule->da)) == (*(MV_U16 *)(da))	 &&
+	    (*(MV_U32 *)(rule->da + 2)) == (*(MV_U32 *)(da + 2)) &&
+	    (*(MV_U32 *)(rule->sa)) == (*(MV_U32 *)(sa))	 &&
+	    (*(MV_U16 *)(rule->sa + 4)) == (*(MV_U16 *)(sa + 4)))
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+static INLINE NFP_RULE_BRIDGE *mvNfpBridgeLookup(const MV_U8 *da, const MV_U8 *sa, MV_U16 iif)
+{
+	MV_U32 hash;
+	NFP_RULE_BRIDGE *rule;
+
+	hash = 	mvNfpBridgeRuleHash(da, sa, iif);
+
+	rule = nfp_bridge_hash[hash];
+	while (rule) {
+		if (mvNfpBridgeRuleCmp(da, sa, iif, rule))
+			return rule;
+
+		rule = rule->next;
+	}
+	return NULL;
+}
+#endif /* NFP_BRIDGE */
+
+typedef struct nfp_rule_arp {
+	struct nfp_rule_arp *next;
+	int	family;
+	MV_U8	nextHopL3[MV_MAX_L3_ADDR_SIZE];
+	MV_U8	da[MV_MAC_ADDR_SIZE];
+	MV_U32	age;
+
+} NFP_RULE_ARP;
+
+#ifdef NFP_FIB
+typedef struct nfp_rule_fib {
+	struct nfp_rule_fib *next;
+	int	family;
+	MV_U8	srcL3[MV_MAX_L3_ADDR_SIZE];
+	MV_U8	dstL3[MV_MAX_L3_ADDR_SIZE];
+	MV_U16	mh;
+	MV_U8	da[MV_MAC_ADDR_SIZE];
+	MV_U8	sa[MV_MAC_ADDR_SIZE];
+	MV_U32	age;
+	MV_U8	defGtwL3[MV_MAX_L3_ADDR_SIZE];
+	MV_U32	flags;
+	int     oif;
+	MV_U32	ref;
+#ifdef NFP_CT
+	MV_U16	ct_ref_count;
+	MV_U16	ct_hwf_ref_count;
+#endif /* NFP_CT */
+} NFP_RULE_FIB;
+#endif /* NFP_FIB */
+
+#ifdef NFP_LIMIT
+typedef struct {
+	MV_U32	credit;
+	MV_U32	creditMax;
+	MV_U32	creditPerTick;
+	MV_U32	lastUpdate;
+
+	MV_U32	refCnt;
+	MV_U32 	index;
+	MV_U32	maxElapsedTicks;
+} NFP_TBF_INFO;
+#endif /* NFP_LIMIT */
+
+#ifdef NFP_CT
+typedef struct {
+	int family;
+	MV_U8  src_l3[MV_MAX_L3_ADDR_SIZE];
+	MV_U8  dst_l3[MV_MAX_L3_ADDR_SIZE];
+	MV_U16 sport;
+	MV_U16 dport;
+	MV_U8  proto;
+} MV_NFP_CT_KEY;
+
+typedef struct {
+	MV_U32 flags;
+	MV_U32 new_sip;
+	MV_U32 new_dip;
+	MV_U16 new_sport;
+	MV_U16 new_dport;
+	MV_U8 sa[MV_MAC_ADDR_SIZE];
+	MV_U8 da[MV_MAC_ADDR_SIZE];
+	MV_U8 out_port;
+#ifdef NFP_CLASSIFY
+	MV_U8 txp;
+	MV_U8 txq;
+	MV_U8 dscp;
+	MV_U8 vprio;
+	MV_U16 mh;
+#endif /* NFP_CLASSIFY */
+} MV_NFP_CT_INFO;
+
+typedef struct nfp_rule_ct {
+	struct nfp_rule_ct *next;
+	/* 5 tuple key */
+	int family;
+	MV_U8 srcL3[MV_MAX_L3_ADDR_SIZE];
+	MV_U8 dstL3[MV_MAX_L3_ADDR_SIZE];
+	MV_U32 ports;
+	MV_U16 proto;
+	MV_U16 reserved;	/* for alignment */
+	NFP_RULE_FIB *fib;
+#ifdef NFP_NAT
+	MV_U32 new_sip;
+	MV_U32 new_dip;
+	MV_U16 new_sport;
+	MV_U16 new_dport;
+#endif /* NFP_NAT */
+
+#ifdef NFP_LIMIT
+	/* Token Bucket Filter information */
+	NFP_TBF_INFO *tbfInfo;
+#endif /* NFP_LIMIT */
+
+#ifdef NFP_CLASSIFY
+	/* indexes 0..63 are the old dscp, values in the array cells are the new dscp. index 64 is for global mapping */
+	NFP_DSCP_MAP_INFO  dscp_map[NFP_DSCP_MAP_SIZE];
+	NFP_VPRI_MAP_INFO  vpri_map[NFP_VPRI_MAP_SIZE];
+	NFP_TXQ_MAP_INFO   txq_map[NFP_DSCP_MAP_SIZE];
+	MV_U8 txp;
+	MV_U16 mh;
+#endif /* NFP_CLASSIFY */
+	MV_U32 flags;
+	MV_U32 age;
+	MV_U32 hit_cntr;
+	MV_U8 visited;
+} NFP_RULE_CT;
+#endif /* NFP_CT */
+
+typedef struct {
+#ifdef NFP_STAT
+	MV_U32 rx;
+	MV_U32 iif_err;
+	MV_U32 oif_err;
+	MV_U32 mac_mcast;
+	MV_U32 non_ip;
+	MV_U32 ipv4;
+	MV_U32 ipv6;
+	MV_U32 ipv4_csum_err;
+	MV_U32 ipv4_rx_frag;
+	MV_U32 ttl_exp;
+	MV_U32 l4_unknown;
+	MV_U32 l4_csum_err;
+	MV_U32 ip_tx_frag;
+	MV_U32 ip_tx_frag_err;
+
+#ifdef NFP_BRIDGE
+	MV_U32 bridge_hit;
+	MV_U32 bridge_miss;
+	MV_U32 bridge_local;
+
+	MV_U32 fdb_sa_miss;
+	MV_U32 fdb_da_miss;
+	MV_U32 fdb_port_miss;
+	MV_U32 fdb_hit;
+	MV_U32 fdb_local;
+#endif /* NFP_BRIDGE */
+
+
+#ifdef NFP_VLAN
+	MV_U32 vlan_rx_tag_drop;
+	MV_U32 vlan_rx_untag_drop;
+	MV_U32 vlan_rx_unknown_drop;
+	MV_U32 vlan_rx_found;
+	MV_U32 vlan_rx_trans;
+	MV_U32 vlan_tx_add;
+	MV_U32 vlan_tx_remove;
+	MV_U32 vlan_tx_replace;
+#endif /* NFP_VLAN */
+
+#ifdef NFP_PPP
+	MV_U32 pppoe_rx_not_found;
+	MV_U32 pppoe_rx_found;
+	MV_U32 pppoe_tx_add;
+	MV_U32 pppoe_tx_remove;
+	MV_U32 pppoe_tx_replace;
+#endif	/* NFP_PPP */
+
+#ifdef NFP_FIB
+	MV_U32 fib_hit;
+	MV_U32 fib_miss;
+	MV_U32 fib_inv;
+#endif	/* NFP_FIB */
+
+#ifdef NFP_CT
+	MV_U32 ct_hit;
+	MV_U32 ct_miss;
+	MV_U32 ct_tcp_fin_rst;
+#endif /* NFP_CT */
+
+#ifdef NFP_NAT
+	MV_U32 dnat_hit;
+	MV_U32 dnat_miss;
+	MV_U32 dnat_inv;
+	MV_U32 snat_hit;
+	MV_U32 snat_miss;
+	MV_U32 snat_inv;
+#endif	/* NFP_NAT */
+
+#endif	/* NFP_STAT */
+} NFP_STATS;
+
+MV_VOID   mvNfpInit(MV_VOID);
+
+MV_VOID   mvNfpPortCapSet(MV_U32 port, MV_U32 cap, MV_U32 on);
+MV_U32    mvNfpPortCapGet(MV_U32 port);
+MV_VOID   mvNfpDebugLevelSet(int dbgLevelFlags);
+
+MV_VOID   mvNfpStats(MV_U32);
+MV_VOID   mvNfpStats(MV_U32 port);
+
+#ifdef NFP_BRIDGE
+MV_STATUS mvNfpIfToBridgeAdd(int bridge_if, int port_if);
+MV_STATUS mvNfpIfToBridgeDel(int bridge_if, int port_if);
+MV_BOOL   mvNfpIfOnSameBridge(NFP_IF_MAP *ifMap1, NFP_IF_MAP *ifMap2);
+#ifdef NFP_FDB_MODE
+MV_STATUS _INIT mvNfpFdbInit(MV_VOID);
+void mvNfpFdbDestroy(void);
+MV_STATUS mvNfpFdbRuleAdd(NFP_RULE_FDB *rule2);
+MV_STATUS mvNfpFdbRuleDel(NFP_RULE_FDB *rule2);
+MV_STATUS mvNfpFdbRuleAge(NFP_RULE_FDB *rule2);
+MV_VOID	  mvNfpFdbDump(MV_VOID);
+MV_VOID	  mvNfpFdbFlushBridge(int ifindex);
+#else
+MV_STATUS _INIT mvNfpBridgeInit(MV_VOID);
+MV_STATUS mvNfpBridgeRuleAdd(NFP_RULE_BRIDGE *rule2);
+MV_STATUS mvNfpBridgeRuleDel(NFP_RULE_BRIDGE *rule2);
+MV_STATUS mvNfpBridgeRuleAge(NFP_RULE_BRIDGE *rule2);
+MV_VOID	  mvNfpBridgeDump(MV_VOID);
+
+#ifdef NFP_CLASSIFY
+MV_STATUS mvNfpBridgeTxqRuleAdd(NFP_RULE_BRIDGE *rule2);
+MV_STATUS mvNfpBridgeTxqRuleDel(NFP_RULE_BRIDGE *rule2);
+MV_STATUS mvNfpBridgeTxpRuleAdd(NFP_RULE_BRIDGE *rule2);
+MV_STATUS mvNfpBridgeTxpRuleDel(NFP_RULE_BRIDGE *rule2);
+MV_STATUS mvNfpBridgeMhRuleAdd(NFP_RULE_BRIDGE *rule2);
+MV_STATUS mvNfpBridgeMhRuleDel(NFP_RULE_BRIDGE *rule2);
+MV_STATUS mvNfpBridgeVlanPrioRuleAdd(NFP_RULE_BRIDGE *rule2, int eth_type, int new_prio);
+MV_STATUS mvNfpBridgeVlanPrioRuleDel(NFP_RULE_BRIDGE *rule2, int eth_type);
+#endif /* NFP_CLASSIFY */
+#endif /* NFP_FDB_MODE */
+#endif /* NFP_BRIDGE */
+
+#ifdef NFP_VLAN
+MV_STATUS mvNfpVlanPvidSet(int if_index, MV_U16 pvid);
+MV_STATUS mvNfpVlanVidSet(int if_index, MV_U16 vid);
+MV_STATUS mvNfpVlanVidGet(int if_index, MV_U16 *vid);
+#endif /* NFP_VLAN */
+
+#ifdef NFP_PPP
+MV_STATUS mvNfpPppAdd(int ifIndex, MV_U16 sid, MV_U8 *remoteMac);
+MV_STATUS mvNfpPppDel(int ifIndex);
+#endif /* NFP_PPP */
+
+#ifdef NFP_FIB
+extern NFP_RULE_FIB **fib_hash;
+extern MV_LIST_ELEMENT *fib_inv_list;
+extern NFP_RULE_ARP **nfp_arp_hash;
+
+static INLINE MV_U32 mvNfpArpRuleHash(int family, MV_U8 *nextHopL3)
+{
+	MV_U32 hash = mv_jhash_1addr(family, nextHopL3, (MV_U32)0, (MV_U32)0, nfp_jhash_iv);
+	hash &= NFP_ARP_HASH_MASK;
+	return hash;
+}
+
+static INLINE MV_STATUS mvNfpArpRuleCmp(int family, MV_U8 *nextHopL3, NFP_RULE_ARP *rule)
+{
+	if ((family == rule->family) && l3_addr_eq(family, rule->nextHopL3, nextHopL3))
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+static INLINE NFP_RULE_ARP *mvNfpArpLookup(int family, MV_U8 *nextHopL3)
+{
+	MV_U32 hash;
+	NFP_RULE_ARP *rule;
+
+	hash = mvNfpArpRuleHash(family, nextHopL3);
+
+	rule = nfp_arp_hash[hash];
+	while (rule) {
+		if (mvNfpArpRuleCmp(family, nextHopL3, rule))
+			return rule;
+
+		rule = rule->next;
+	}
+	return NULL;
+}
+
+static INLINE MV_U32 mvNfpFibRuleHash(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3)
+{
+	MV_U32 hash = mv_jhash_2addr(family, src_l3, dst_l3, (MV_U32)0, nfp_jhash_iv);
+	hash &= NFP_FIB_HASH_MASK;
+	return hash;
+}
+
+static INLINE MV_STATUS mvNfpFibRuleCmp(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3, NFP_RULE_FIB *rule)
+{
+	if ((family == rule->family) &&
+		l3_addr_eq(family, rule->srcL3, src_l3)	&&
+		l3_addr_eq(family, rule->dstL3, dst_l3))
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+static INLINE NFP_RULE_FIB *mvNfpFibLookup(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3)
+{
+	MV_U32 hash;
+	NFP_RULE_FIB *rule;
+
+	hash = mvNfpFibRuleHash(family, src_l3, dst_l3);
+	rule = fib_hash[hash];
+	while (rule) {
+		if (!(rule->family == family))
+			continue;
+		if (mvNfpFibRuleCmp(family, src_l3, dst_l3, rule))
+			return rule;
+		rule = rule->next;
+	}
+	return NULL;
+}
+
+MV_VOID   mvNfpModeSet(int mode);
+
+MV_VOID   mvNfpIpInfoPrint(u32 dbgLevel, int family, u8 *ipAddr);
+MV_VOID   mvNfp2TupleInfoPrint(u32 dbgLevel, int family, u8 *srcL3, u8 *dstL3);
+MV_VOID   mvNfp5TupleInfoPrint(u32 dbgLevel, int family, u8 *srcL3, u8 *dstL3, u16 sport, u16 dport, u8 proto);
+
+MV_STATUS mvNfpIfMapCreate(NFP_IF_MAP *ifMap);
+MV_STATUS mvNfpIfVirtMap(int parentIf, int virtIf);
+MV_STATUS mvNfpIfVirtUnmap(int virtIf);
+
+MV_STATUS mvNfpIfFlagsSet(int ifIdx, MV_U32 flags);
+MV_STATUS mvNfpIfFlagsClear(int ifIdx, MV_U32 flags);
+MV_STATUS mvNfpIfMapMacUpdate(int ifIdx, const MV_U8 *mac);
+MV_STATUS mvNfpIfMapMtuUpdate(int ifIdx, int mtu);
+MV_STATUS mvNfpIfMapDelete(int ifIdx);
+MV_VOID   mvNfpIfMapDump(MV_VOID);
+
+MV_STATUS mvNfpFibInit(MV_VOID);
+MV_VOID   mvNfpFibDump(MV_VOID);
+MV_VOID   mvNfpFibClean(MV_VOID);
+MV_VOID   mvNfpFibDestroy(MV_VOID);
+MV_STATUS mvNfpFibRuleValid(NFP_RULE_FIB *fib, MV_LIST_ELEMENT *curr);
+
+MV_STATUS mvNfpFibRuleAdd(NFP_RULE_FIB *fib2);
+MV_STATUS mvNfpFibRuleDel(NFP_RULE_FIB *fib2);
+MV_STATUS mvNfpFibRuleAge(NFP_RULE_FIB *fib2);
+
+
+MV_STATUS mvNfpArpInit(MV_VOID);
+MV_VOID   mvNfpArpDump(MV_VOID);
+MV_VOID   mvNfpArpDestroy(MV_VOID);
+MV_STATUS mvNfpArpRuleAdd(NFP_RULE_ARP *arp2);
+MV_STATUS mvNfpArpRuleDel(NFP_RULE_ARP *arp2);
+MV_STATUS mvNfpArpRuleAge(NFP_RULE_ARP *arp2);
+MV_STATUS mvNfpArpRuleUpdateFibEntries(NFP_RULE_ARP *arp);
+
+#endif /* NFP_FIB */
+
+#ifdef NFP_CT
+extern NFP_RULE_CT **ct_hash;
+
+static INLINE MV_U32 mvNfpCtHashByTuple(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3,
+					MV_U32 ports, MV_U16 proto)
+{
+	MV_U32 hash = mv_jhash_2addr(family, src_l3, dst_l3, (ports | proto), nfp_jhash_iv);
+	hash &= NFP_CT_HASH_MASK;
+	return hash;
+}
+
+static INLINE NFP_RULE_CT *mvNfpCtLookupByTuple(int family, const MV_U8 *src_l3, const MV_U8 *dst_l3,
+						 MV_U32 ports, MV_U16 proto)
+{
+	MV_U32 hash;
+	NFP_RULE_CT *ct;
+
+	hash = mvNfpCtHashByTuple(family, src_l3, dst_l3, ports, proto);
+	ct = ct_hash[hash];
+	while (ct) {
+		if ((ct->family == family) &&
+			l3_addr_eq(ct->family, ct->srcL3, src_l3) &&
+			l3_addr_eq(ct->family, ct->dstL3, dst_l3) &&
+			(ct->ports == ports) && (ct->proto == proto))
+			return ct;
+		ct = ct->next;
+	}
+
+	return NULL;
+}
+
+extern NFP_RULE_CT **ct_hash;
+MV_STATUS mvNfpCtInit(MV_VOID);
+MV_VOID mvNfpCtRuleFibUpdate(NFP_RULE_FIB *fib);
+MV_VOID mvNfpCtRuleFibInvalidate(NFP_RULE_FIB *fib);
+MV_STATUS mvNfpCtFilterModeSet(NFP_RULE_CT *ct2);
+MV_STATUS mvNfpCtRuleUdpCsumSet(NFP_RULE_CT *ct2, int mode);
+MV_STATUS mvNfpCtRateLimitSet(NFP_RULE_CT *ct2, int tbf_index);
+MV_STATUS mvNfpCtRateLimitDel(NFP_RULE_CT *ct2);
+#ifdef NFP_CLASSIFY
+MV_STATUS mvNfpCtDscpRuleAdd(NFP_RULE_CT *ct2, int dscp, int new_dscp);
+MV_STATUS mvNfpCtDscpRuleDel(NFP_RULE_CT *ct2, int dscp);
+MV_STATUS mvNfpCtVlanPrioRuleAdd(NFP_RULE_CT *ct2, int prio, int new_prio);
+MV_STATUS mvNfpCtVlanPrioRuleDel(NFP_RULE_CT *ct2, int prio);
+MV_STATUS mvNfpCtTxqRuleAdd(NFP_RULE_CT *ct2, int dscp, int txq);
+MV_STATUS mvNfpCtTxqRuleDel(NFP_RULE_CT *ct2, int dscp);
+MV_STATUS mvNfpCtTxpRuleAdd(NFP_RULE_CT *ct2);
+MV_STATUS mvNfpCtTxpRuleDel(NFP_RULE_CT *ct2);
+MV_STATUS mvNfpCtMhRuleAdd(NFP_RULE_CT *ct2);
+MV_STATUS mvNfpCtMhRuleDel(NFP_RULE_CT *ct2);
+#endif /* NFP_CLASSIFY */
+MV_STATUS mvNfpCtRuleDel(NFP_RULE_CT *rule);
+MV_STATUS mvNfpCtRuleAge(NFP_RULE_CT *rule);
+MV_VOID mvNfpCtDump(MV_VOID);
+MV_VOID mvNfpCtClean(int family);
+MV_VOID mvNfpCtDestroy(MV_VOID);
+
+MV_VOID mvNfpCtCleanVisited(MV_U32 row, MV_U32 iterator_id);
+MV_STATUS mvNfpCtFirstRuleGet(NFP_RULE_CT **rule, MV_U32 iterator_id);
+MV_STATUS mvNfpCtNextRuleGet(NFP_RULE_CT **rule, MV_U32 iterator_id);
+MV_STATUS mvNfpCtRuleMaxHitCntrGet(NFP_RULE_CT **rule);
+MV_STATUS mvNfpCtRuleHwfSet(MV_NFP_CT_KEY *key, int mode);
+MV_STATUS mvNfpCtRuleHitCntrGet(MV_NFP_CT_KEY *key, MV_U32 *hit_cntr);
+MV_STATUS mvNfpCtRuleHitCntrSet(MV_NFP_CT_KEY *key, MV_U32 val);
+MV_STATUS mvNfpCtRuleInfoGet(MV_NFP_CT_KEY *key, MV_NFP_CT_INFO *ct_info);
+#endif /* NFP_CT */
+
+#ifdef NFP_NAT
+MV_STATUS mvNfpCtNatRuleAdd(NFP_RULE_CT *rule);
+#endif /* NFP_NAT */
+
+#ifdef NFP_LIMIT
+void mvNfpCtTbfsDump(void);
+int mvNfpTbfCreate(int limit, int burst_limit);
+MV_STATUS mvNfpTbfDel(int tbf);
+MV_STATUS mvNfpTbfProcess(NFP_TBF_INFO *tbf, MV_U32 packetSize);
+#endif /* NFP_LIMIT */
+
+#ifndef NFP_FDB_MODE
+void mvNfpFlushBridge(int ifindex);
+#endif
+
+void mvNfpFlushFib(int ifindex);
+
+#endif /* __mvNfp_h__ */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpBridge.c
@@ -0,0 +1,728 @@
+/*******************************************************************************
+Copyright (C) Marvell Interfdbional Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+Interfdbional Ltd. and/or its affiliates ("Marvell") under the following
+alterfdbive licensing terms.  Once you have made an election to distribute the
+File under one of the following license alterfdbives, please (i) delete this
+introductory statement regarding license alterfdbives, (ii) delete the two
+license alterfdbives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvNfpBridge.c - Marvell Fast Network Processing
+*
+* DESCRIPTION:
+*
+*       Supported Features:
+*       - OS independent.
+*
+*******************************************************************************/
+
+#include "mvOs.h"
+#include "mvDebug.h"
+#include "mvList.h"
+#include "gbe/mvNeta.h"
+#include "mvNfpDefs.h"
+#include "mvNfp.h"
+
+NFP_RULE_BRIDGE **nfp_bridge_hash = NULL;
+#ifdef NFP_CLASSIFY
+MV_LIST_ELEMENT *bridge_inv_list = NULL;
+#endif /* NFP_CLASSIFY */
+
+MV_STATUS _INIT mvNfpBridgeInit(void)
+{
+	MV_U32 bytes = sizeof(NFP_RULE_BRIDGE *) * NFP_BRIDGE_HASH_SIZE;
+
+	nfp_bridge_hash = (NFP_RULE_BRIDGE **)mvOsMalloc(bytes);
+	if (nfp_bridge_hash == NULL) {
+		mvOsPrintf("NFP (bridge hash): not enough memory\n");
+		return MV_NO_RESOURCE;
+	}
+	mvOsMemset(nfp_bridge_hash, 0, bytes);
+#ifdef NFP_CLASSIFY
+	bridge_inv_list = mvListCreate();
+	if (bridge_inv_list == NULL) {
+		mvOsPrintf("NFP (bridge): not enough memory\n");
+		mvOsFree(nfp_bridge_hash);
+		return MV_NO_RESOURCE;
+	}
+#endif /* NFP_CLASSIFY */
+	mvOsPrintf("NFP (bridge) init %d entries, %d bytes\n", NFP_BRIDGE_HASH_SIZE, bytes);
+
+	return MV_OK;
+}
+
+/* Clear Bridge Rule Database */
+MV_STATUS mvNfpBridgeClear(void)
+{
+	int	i;
+	NFP_RULE_BRIDGE	*rule, *tmp;
+#ifdef NFP_CLASSIFY
+	MV_LIST_ELEMENT	*curr, *tmp_list;
+#endif /* NFP_CLASSIFY */
+
+	if (nfp_bridge_hash == NULL)
+		return MV_NOT_INITIALIZED;
+
+	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
+
+		rule = nfp_bridge_hash[i];
+		while (rule) {
+			tmp = rule;
+			rule = rule->next;
+			mvOsFree(tmp);
+		}
+		nfp_bridge_hash[i] = NULL;
+	}
+#ifdef NFP_CLASSIFY
+	/* Clean bridge invalid rules list */
+	if (bridge_inv_list) {
+		curr = bridge_inv_list->next;
+		while (curr) {
+			tmp_list = curr->next;
+			rule = (NFP_RULE_BRIDGE *)curr->data;
+			mvOsFree(rule);
+			mvListDel(curr);
+			curr = tmp_list;
+		}
+	}
+#endif /* NFP_CLASSIFY */
+	return MV_OK;
+}
+
+void mvNfpBridgeDestroy(void)
+{
+	if (nfp_bridge_hash != NULL)
+		mvOsFree(nfp_bridge_hash);
+#ifdef NFP_CLASSIFY
+	mvListDestroy(bridge_inv_list);
+#endif /* NFP_CLASSIFY */
+}
+
+#ifdef NFP_CLASSIFY
+static NFP_RULE_BRIDGE *mvNfpBridgeRuleInvalidLookup(NFP_RULE_BRIDGE *rule2)
+{
+	MV_LIST_ELEMENT	*curr;
+	NFP_RULE_BRIDGE *rule;
+
+	if (!bridge_inv_list)
+		return NULL;
+
+	curr = bridge_inv_list->next;
+	while (curr) {
+		rule = (NFP_RULE_BRIDGE *)curr->data;
+		if (mvNfpBridgeRuleCmp(rule2->da, rule2->sa, rule2->iif, rule))
+			return rule;
+		curr = curr->next;
+	}
+	return NULL;
+}
+
+NFP_RULE_BRIDGE *mvNfpBridgeClassifyRuleCreate(NFP_RULE_BRIDGE *rule2)
+{
+	/* rule not exist - create rule and mark it as "not exist" */
+	NFP_RULE_BRIDGE *rule = (NFP_RULE_BRIDGE *)mvOsMalloc(sizeof(NFP_RULE_BRIDGE));
+	if (!rule) {
+		mvOsPrintf("%s: OOM\n", __func__);
+		return NULL;
+	}
+
+	mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_BRIDGE));
+
+	rule->flags |= NFP_F_BR_NOT_EXIST;
+	/* this rule is invalid until mvNfpBridgeRuleAdd will be called */
+	mvListAddHead(bridge_inv_list, (MV_ULONG)rule);
+	return rule;
+}
+#endif /* NFP_CLASSIFY */
+
+void mvNfpBridgeFibUpdate(NFP_RULE_BRIDGE *rule, int prev_oif)
+{
+	MV_LIST_ELEMENT	*curr, *tmp;
+	int i;
+	NFP_RULE_FIB	*fib;
+	NFP_IF_MAP      *outIfMap;
+
+	outIfMap = mvNfpIfMapGet(rule->oif);
+	/* Update relevant FIB rules */
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+		while (fib) {
+			if ((prev_oif == fib->oif) &&
+			    (!memcmp(rule->da, fib->da, MV_MAC_ADDR_SIZE)) &&
+			    (!memcmp(rule->sa, fib->sa, MV_MAC_ADDR_SIZE))) {
+				fib->oif = outIfMap->ifIdx;
+				fib->mh = outIfMap->txMh;
+			}
+			fib = fib->next;
+		}
+	}
+
+	curr = fib_inv_list->next;
+	while (curr) {
+		fib = (NFP_RULE_FIB *)curr->data;
+		tmp = curr->next;
+		if ((prev_oif == fib->oif) &&
+		    (!memcmp(rule->da, fib->da, MV_MAC_ADDR_SIZE)) &&
+		    (!memcmp(rule->sa, fib->sa, MV_MAC_ADDR_SIZE))) {
+			fib->oif = outIfMap->ifIdx;
+			fib->mh = outIfMap->txMh;
+			fib->flags &= ~NFP_F_FIB_BRIDGE_INV;
+
+			mvNfpFibRuleValid(fib, curr);
+		}
+		curr = tmp;
+	}
+}
+
+MV_STATUS mvNfpBridgeRuleAdd(NFP_RULE_BRIDGE *rule2)
+{
+	MV_U32          hash;
+	NFP_RULE_BRIDGE *rule;
+	NFP_RULE_FIB    *fib;
+	MV_LIST_ELEMENT	*curr, *tmp;
+	NFP_IF_MAP      *inIfMap, *outIfMap;
+
+	hash = mvNfpBridgeRuleHash(rule2->da, rule2->sa, rule2->iif);
+	rule = nfp_bridge_hash[hash];
+	while (rule) {
+		if (mvNfpBridgeRuleCmp(rule2->da, rule2->sa, rule2->iif, rule)) {
+			MV_U32 age = rule->age;
+
+			/* Update rule, but save age */
+			mvNfpBridgeFibUpdate(rule2, mvNfpIfMapGet(rule->oif)->ifIdx);
+			mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_BRIDGE));
+			rule->age = age;
+			goto out;
+		}
+		rule = rule->next;
+	}
+
+	/* New rule - check that iif and oif connected to the same bridgeIf */
+	inIfMap = mvNfpIfMapGet(rule2->iif);
+	outIfMap = mvNfpIfMapGet(rule2->oif);
+
+	if (mvNfpIfOnSameBridge(inIfMap, outIfMap) == MV_FALSE) {
+		mvOsPrintf("%s: iif=%d and oif=%d are not connected to the same bridge\n",
+					__func__, rule2->iif, rule2->oif);
+		return MV_FAIL;
+	}
+#ifdef NFP_CLASSIFY
+	/* check if there is an invalid rule */
+	rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (rule && (rule->flags & NFP_F_BR_NOT_EXIST)) {
+		rule->flags &= ~NFP_F_BR_NOT_EXIST;
+		rule->oif = rule2->oif;
+		/* remove from invalid list */
+		curr = mvListFind(bridge_inv_list, (MV_ULONG)rule);
+		mvListDel(curr);
+	} else {
+#endif /* NFP_CLASSIFY */
+	rule = (NFP_RULE_BRIDGE *)mvOsMalloc(sizeof(NFP_RULE_BRIDGE));
+	if (rule == NULL) {
+		mvOsPrintf("%s: NFP (bridge rule) - OOM\n", __func__);
+		return MV_FAIL;
+	}
+
+	mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_BRIDGE));
+#ifdef NFP_CLASSIFY
+	}
+#endif /* NFP_CLASSIFY */
+
+	rule->next = nfp_bridge_hash[hash];
+	nfp_bridge_hash[hash] = rule;
+
+	/* Update incomplete FIB entries */
+	curr = fib_inv_list->next;
+	while (curr) {
+		fib = (NFP_RULE_FIB *)curr->data;
+		tmp = curr->next;
+		if ((rule->iif == fib->oif) &&
+		    (!memcmp(rule->da, fib->da, MV_MAC_ADDR_SIZE)) &&
+		    (!memcmp(rule->sa, fib->sa, MV_MAC_ADDR_SIZE))) {
+
+			/* Found incomplete FIB entry */
+			fib->oif = outIfMap->ifIdx;
+			fib->mh = outIfMap->txMh;
+			fib->flags &= ~NFP_F_FIB_BRIDGE_INV;
+
+			mvNfpFibRuleValid(fib, curr);
+		}
+		curr = tmp;
+	}
+
+out:
+	NFP_DBG("NFP (bridge) add %p\n", rule);
+	return MV_OK;
+}
+
+MV_STATUS mvNfpBridgeRuleDel(NFP_RULE_BRIDGE *rule2)
+{
+	MV_U32 hash;
+	NFP_RULE_BRIDGE *rule, *prev;
+	NFP_RULE_FIB	*fib, *fib_prev;
+	NFP_IF_MAP      *ifMap;
+	int i;
+#ifdef NFP_CLASSIFY
+	MV_LIST_ELEMENT	*element;
+#endif /* NFP_CLASSIFY */
+
+	hash = mvNfpBridgeRuleHash(rule2->da, rule2->sa, rule2->iif);
+
+	rule = nfp_bridge_hash[hash];
+	prev = NULL;
+
+	while (rule) {
+		if (mvNfpBridgeRuleCmp(rule2->da, rule2->sa, rule2->iif, rule)) {
+			/* Found: delete rule */
+			if (prev)
+				prev->next = rule->next;
+			else
+				nfp_bridge_hash[hash] = rule->next;
+
+			NFP_DBG("NFP (bridge) del %p\n", rule);
+			rule2->oif = rule->oif;
+			mvOsFree(rule);
+			break;
+		}
+		prev = rule;
+		rule = rule->next;
+	}
+#ifdef NFP_CLASSIFY
+	if (!rule) {
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+		if (rule) {
+			element = mvListFind(bridge_inv_list, (MV_ULONG)rule);
+			mvListDel(element);
+			mvOsFree(rule);
+			/* invalid bridge rules doesn't affect fib rules */
+			return MV_OK;
+		}
+	}
+#endif /* NFP_CLASSIFY */
+	if (!rule)
+		return MV_NOT_FOUND;
+
+	/* Invalidate relevant FIB rules */
+	ifMap = mvNfpIfMapGet(rule2->oif);
+
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+		fib_prev = NULL;
+		while (fib) {
+			if ((rule2->oif == fib->oif) &&
+				(!memcmp(rule2->da, fib->da, MV_MAC_ADDR_SIZE))) {
+				/* Invalidate FIB route. FIXME - update HWF rule */
+				fib->flags |= NFP_F_FIB_BRIDGE_INV;
+				fib->oif = ifMap->bridgeIf;
+
+				/* Remove FIB rule from hash table */
+				if (fib_prev)
+					fib_prev->next = fib->next;
+				else
+					fib_hash[i] = fib->next;
+
+				/* Add FIB rule to incomplete list */
+				mvListAddHead(fib_inv_list, (MV_ULONG)fib);
+#ifdef NFP_CT
+				/* Invalidate relevant CT rules */
+				mvNfpCtRuleFibInvalidate(fib);
+#endif /* NFP_CT */
+			}
+			fib_prev = fib;
+			fib = fib->next;
+		}
+	}
+	return MV_OK;
+}
+
+MV_STATUS mvNfpBridgeRuleAge(NFP_RULE_BRIDGE *rule2)
+{
+	NFP_RULE_BRIDGE *rule;
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+#ifdef NFP_CLASSIFY
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+#endif /* NFP_CLASSIFY */
+	if (rule) {
+		rule2->age = rule->age;
+		rule->age = 0;
+		return MV_OK;
+	}
+	rule2->age = 0;
+	return MV_NOT_FOUND;
+}
+
+#ifdef NFP_CLASSIFY
+MV_STATUS mvNfpBridgeTxqRuleAdd(NFP_RULE_BRIDGE *rule2)
+{
+	NFP_RULE_BRIDGE *rule;
+
+	/* sanity: chack txq parameter */
+	if ((rule2->txq < 0) || (rule2->txq >= CONFIG_MV_ETH_TXQ)) {
+		mvOsPrintf("%s Error: txq (%d) is out of range\n", __func__, rule2->txq);
+		return MV_BAD_PARAM;
+	}
+	if (!(rule2->flags & NFP_F_BR_SET_TXQ)) {
+		mvOsPrintf("%s: NFP_F_BR_SET_TXQ flag is not set\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (!rule) {
+		rule = mvNfpBridgeClassifyRuleCreate(rule2);
+		if (!rule)
+			return MV_FAIL;
+	}
+
+	/* Update rule Txq table */
+	rule->txq = rule2->txq;
+	rule->flags |= NFP_F_BR_SET_TXQ;
+
+	NFP_DBG("NFP (bridge txq) set %p\n", rule);
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpBridgeTxqRuleDel(NFP_RULE_BRIDGE *rule2)
+{
+	NFP_RULE_BRIDGE *rule;
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (rule) {
+		rule->txq = 0;
+		rule->flags &= ~NFP_F_BR_SET_TXQ;
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpBridgeTxpRuleAdd(NFP_RULE_BRIDGE *rule2)
+{
+	NFP_RULE_BRIDGE *rule;
+
+	/* sanity: chack txp parameter */
+	if (rule2->txp < 0) {
+		mvOsPrintf("%s Error: txp (%d) is out of range\n", __func__, rule2->txp);
+		return MV_BAD_PARAM;
+	}
+	if (!(rule2->flags & NFP_F_BR_SET_TXP)) {
+		mvOsPrintf("%s: NFP_F_BR_SET_TXP flag is not set\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (!rule) {
+		rule = mvNfpBridgeClassifyRuleCreate(rule2);
+		if (!rule)
+			return MV_FAIL;
+	}
+
+	/* Update rule Txp table */
+	rule->txp = rule2->txp;
+	rule->flags |= NFP_F_BR_SET_TXP;
+
+	NFP_DBG("NFP (bridge txp) set %p\n", rule);
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpBridgeTxpRuleDel(NFP_RULE_BRIDGE *rule2)
+{
+	NFP_RULE_BRIDGE *rule;
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (rule) {
+		rule->txp = 0;
+		rule->flags &= ~NFP_F_BR_SET_TXP;
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpBridgeMhRuleAdd(NFP_RULE_BRIDGE *rule2)
+{
+	NFP_RULE_BRIDGE *rule;
+
+	/* sanity: chack MH parameter */
+	if ((rule2->mh < 0) || (rule2->mh >= 0xFFFF)) {
+		mvOsPrintf("%s Error: mh (%d) is out of range\n", __func__, rule2->mh);
+		return MV_BAD_PARAM;
+	}
+	if (!(rule2->flags & NFP_F_BR_SET_MH)) {
+		mvOsPrintf("%s: NFP_F_BR_SET_MH flag is not set\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (!rule) {
+		rule = mvNfpBridgeClassifyRuleCreate(rule2);
+		if (!rule)
+			return MV_FAIL;
+	}
+
+	/* Update rule Txq table */
+	rule->mh = rule2->mh;
+	rule->flags |= NFP_F_BR_SET_MH;
+
+	NFP_DBG("NFP (bridge mh) set %p\n", rule);
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpBridgeMhRuleDel(NFP_RULE_BRIDGE *rule2)
+{
+	NFP_RULE_BRIDGE *rule;
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (rule) {
+		rule->mh = 0;
+		rule->flags &= ~NFP_F_BR_SET_MH;
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpBridgeVlanPrioRuleAdd(NFP_RULE_BRIDGE *rule2, int eth_type, int new_prio)
+{
+	NFP_RULE_BRIDGE *rule;
+	int i, first;
+
+	/* sanity: chack new_prio parameter */
+	if ((new_prio < NFP_VPRI_MIN) || (new_prio > NFP_VPRI_MAX)) {
+		mvOsPrintf("%s Error: new_prio value (%d) is out of range\n", __func__, new_prio);
+		return MV_BAD_PARAM;
+	}
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (!rule) {
+		rule = mvNfpBridgeClassifyRuleCreate(rule2);
+		if (!rule)
+			return MV_FAIL;
+	}
+
+	if (eth_type == MV_ETH_NFP_GLOBAL_MAP) {
+		rule->vpri_map[NFP_VPRI_MAP_GLOBAL].eth_type = eth_type;
+		rule->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio = new_prio;
+		rule->vpri_map[NFP_VPRI_MAP_GLOBAL].valid = MV_TRUE;
+	} else {
+		for (first = -1, i = 0; i < NFP_VPRI_MAP_GLOBAL; i++) {
+			if (rule->vpri_map[i].eth_type == eth_type) {
+				rule->vpri_map[i].new_prio = new_prio;	/* just update */
+				return MV_OK;
+			}
+			if ((first == -1) && (rule->vpri_map[i].valid == MV_FALSE))
+				first = i;
+		}
+		if (first != -1) {
+			rule->vpri_map[first].eth_type = eth_type;
+			rule->vpri_map[first].new_prio = new_prio;
+			rule->vpri_map[first].valid = MV_TRUE;
+		} else {
+			mvOsPrintf("%s Error: No available space for additional VPRIO mapping\n", __func__);
+		}
+	}
+	rule->flags |= NFP_F_BR_SET_VLAN_PRIO;
+
+	return MV_OK;
+}
+
+static INLINE MV_STATUS mvNfpIsVpriSet(NFP_RULE_BRIDGE *rule)
+{
+	int i;
+
+	for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++)
+		if (rule->vpri_map[i].valid)
+			return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+MV_STATUS mvNfpBridgeVlanPrioRuleDel(NFP_RULE_BRIDGE *rule2, int eth_type)
+{
+	NFP_RULE_BRIDGE *rule;
+	int i;
+
+	/* sanity: check eth_type parameter */
+	if ((eth_type < MV_ETH_NFP_GLOBAL_MAP) || (eth_type > 0xFFFF)) {
+		mvOsPrintf("%s Error: eth_type value (%d) is out of range\n", __func__, eth_type);
+		return MV_BAD_PARAM;
+	}
+
+	rule = mvNfpBridgeLookup(rule2->da, rule2->sa, rule2->iif);
+	if (!rule)
+		rule = mvNfpBridgeRuleInvalidLookup(rule2);
+	if (rule) {
+		if (eth_type == MV_ETH_NFP_GLOBAL_MAP) {
+			rule->vpri_map[NFP_VPRI_MAP_GLOBAL].eth_type = 0;
+			rule->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio = 0;
+			rule->vpri_map[NFP_VPRI_MAP_GLOBAL].valid = MV_FALSE;
+		} else {
+			for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++) {
+				if (rule->vpri_map[i].eth_type == eth_type) {
+					rule->vpri_map[i].eth_type = 0;
+					rule->vpri_map[i].new_prio = 0;
+					rule->vpri_map[i].valid = MV_FALSE;
+				}
+			}
+		}
+		if (!mvNfpIsVpriSet(rule))
+			rule->flags &= ~NFP_F_BR_SET_VLAN_PRIO;
+
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+#endif /* NFP_CLASSIFY */
+
+
+static void mvNfpBridgeRulePrint(NFP_RULE_BRIDGE *rule)
+{
+#ifdef NFP_CLASSIFY
+	int i;
+#endif /* NFP_CLASSIFY */
+
+	mvOsPrintf("Bridge: ");
+
+	mvOsPrintf(" DA=" MV_MACQUAD_FMT ", SA=" MV_MACQUAD_FMT ", iif=%u, oif=%u, flags=0x%04x, age=%u\n",
+		MV_MACQUAD(rule->da), MV_MACQUAD(rule->sa), rule->iif, rule->oif, rule->flags, rule->age);
+
+#ifdef NFP_CLASSIFY
+	if (rule->flags & NFP_F_BR_SET_VLAN_PRIO) {
+		mvOsPrintf(" VLAN Prio Map: ");
+		mvOsPrintf("eth_type\t\tVPrio\n");
+		for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++) {
+			if (rule->vpri_map[i].valid) {
+				if (i == NFP_VPRI_MAP_GLOBAL)
+					mvOsPrintf("Global:\t\t%d\n", rule->vpri_map[i].new_prio);
+				else
+					mvOsPrintf("0x%X\t\t%d\n", rule->vpri_map[i].eth_type, rule->vpri_map[i].new_prio);
+			}
+		}
+	}
+	if (rule->flags & NFP_F_BR_NOT_EXIST)
+		mvOsPrintf("This rule is in classification context - use mvNfpBridgeRuleAdd() to make it valid\n");
+#endif /* NFP_CLASSIFY */
+}
+
+void mvNfpBridgeDump(void)
+{
+	int             i;
+	NFP_RULE_BRIDGE *rule;
+#ifdef NFP_CLASSIFY
+	MV_LIST_ELEMENT	*curr;
+#endif /* NFP_CLASSIFY */
+
+	mvOsPrintf("\n(bridge)\n");
+	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
+		rule = nfp_bridge_hash[i];
+
+		while (rule) {
+			mvOsPrintf(" [%5d] ", i);
+			mvNfpBridgeRulePrint(rule);
+			rule = rule->next;
+		}
+	}
+#ifdef NFP_CLASSIFY
+	if (!bridge_inv_list)
+		return;
+	mvOsPrintf("(bridge_inv_list)\n");
+	curr = bridge_inv_list->next;
+	while (curr) {
+		rule = (NFP_RULE_BRIDGE *)curr->data;
+		mvNfpBridgeRulePrint(rule);
+		curr = curr->next;
+	}
+#endif /* NFP_CLASSIFY */
+}
+
+void mvNfpFlushBridge(int ifindex)
+{
+	int i;
+
+	NFP_RULE_BRIDGE *rule;
+
+	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
+		rule = nfp_bridge_hash[i];
+
+		while (rule) {
+			if ((rule->iif == ifindex) || (rule->oif == ifindex) || (ifindex == -1))
+				mvNfpBridgeRuleDel(rule);
+			rule = rule->next;
+		}
+	}
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpCt.c
@@ -0,0 +1,1514 @@
+/*******************************************************************************
+Copyright (C) Marvell Interfdbional Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+Interfdbional Ltd. and/or its affiliates ("Marvell") under the following
+alterfdbive licensing terms.  Once you have made an election to distribute the
+File under one of the following license alterfdbives, please (i) delete this
+introductory statement regarding license alterfdbives, (ii) delete the two
+license alterfdbives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvNfpCt.c - Marvell Fast Network Processing
+*
+* DESCRIPTION:
+*
+*       Supported Features:
+*       - OS independent.
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvOs.h"
+#include "mvDebug.h"
+#include "mvList.h"
+#include "gbe/mvNeta.h"
+#include "mvNfpDefs.h"
+#include "mvNfp.h"
+
+MV_LIST_ELEMENT *ct_inv_list = NULL;
+NFP_RULE_CT **ct_hash = NULL;
+int ct_iterator_row = 0;
+#ifdef NFP_LIMIT
+MV_LIST_ELEMENT *tbfs;
+#endif /* NFP_LIMIT */
+
+MV_STATUS _INIT mvNfpCtInit(MV_VOID)
+{
+	MV_U32 bytes = sizeof(NFP_RULE_CT *) * NFP_CT_HASH_SIZE;
+
+	ct_hash = (NFP_RULE_CT **)mvOsMalloc(bytes);
+	if (ct_hash == NULL) {
+		mvOsPrintf("NFP (ct): not enough memory for CT database\n");
+		return MV_NO_RESOURCE;
+	}
+
+	mvOsMemset(ct_hash, 0, bytes);
+	ct_inv_list = mvListCreate();
+	if (ct_inv_list == NULL) {
+		mvOsPrintf("NFP (ct): not enough memory for CT database\n");
+		mvOsFree(ct_hash);
+		return MV_NO_RESOURCE;
+	}
+
+	mvOsPrintf("NFP (ct) init %d entries, %d bytes\n", NFP_CT_HASH_SIZE, bytes);
+#ifdef NFP_LIMIT
+	tbfs = mvListCreate();
+	if (tbfs == NULL) {
+		mvOsPrintf("NFP (ct): not enough memory for TBF database\n");
+		mvListDestroy(ct_inv_list);
+		mvOsFree(ct_hash);
+		return MV_NO_RESOURCE;
+	}
+#endif /* NFP_LIMIT */
+	return MV_OK;
+}
+
+static INLINE MV_U32 mvNfpCtHash(NFP_RULE_CT *ct)
+{
+	MV_U32 hash = mv_jhash_2addr(ct->family, (const MV_U8 *)&ct->srcL3, (const MV_U8 *)&ct->dstL3,
+					(ct->ports | ct->proto), nfp_jhash_iv);
+	hash &= NFP_CT_HASH_MASK;
+	return hash;
+}
+
+static INLINE NFP_RULE_CT *mvNfpCtLookup(NFP_RULE_CT *ct2)
+{
+	MV_U32 hash;
+	NFP_RULE_CT *ct;
+
+	if (!ct_hash)
+		return NULL;
+
+	hash = mvNfpCtHash(ct2);
+	ct = ct_hash[hash];
+	while (ct) {
+		if ((ct->family == ct2->family) &&
+			l3_addr_eq(ct->family, ct->srcL3, ct2->srcL3) &&
+			l3_addr_eq(ct->family, ct->dstL3, ct2->dstL3) &&
+			(ct->ports == ct2->ports) && (ct->proto == ct2->proto))
+			return ct;
+		ct = ct->next;
+	}
+
+	return NULL;
+}
+
+/* Move CT rule from ct_inv_list to ct_hash */
+static MV_STATUS mvNfpCtRuleValid(NFP_RULE_CT *ct, MV_LIST_ELEMENT *curr)
+{
+	MV_U32	hash;
+
+	if (((ct->flags & NFP_F_CT_DROP) || !(ct->flags & NFP_F_CT_FIB_INV)) && !(ct->flags & NFP_F_CT_NOT_EXIST)) {
+		/* CT rule became ready */
+
+		/* Delete CT rule from incomplete list */
+		mvListDel(curr);
+
+		/* Add ct to hash table */
+		hash = mvNfpCtHash(ct);
+		ct->next = ct_hash[hash];
+		ct_hash[hash] = ct;
+		ct->visited = 0;
+
+		return MV_OK;
+	}
+	return MV_BAD_PARAM;
+}
+
+MV_VOID mvNfpCtRuleFibUpdate(NFP_RULE_FIB *fib)
+{
+	NFP_RULE_CT	*ct;
+	MV_LIST_ELEMENT	*curr, *tmp;
+	int i;
+
+	/* Update FIB rule pointers in CT hash */
+	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
+		ct = ct_hash[i];
+		while (ct) {
+			if ((fib->family == ct->family) &&
+				(l3_addr_eq(fib->family, fib->srcL3, ct->srcL3)) &&
+#ifdef NFP_NAT
+				((!(ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) ||
+				((ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, (MV_U8 *)&(ct->new_dip)))))) {
+#else
+				(l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) {
+#endif /* NFP_NAT */
+				/* Invalidate CT route */
+				if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
+					(ct->fib)->ct_ref_count--;
+				if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
+					(ct->fib)->ct_hwf_ref_count--;
+				ct->flags &= ~NFP_F_CT_FIB_INV;
+				ct->fib = fib;
+				(ct->fib)->ct_ref_count++;
+				if (ct->flags & NFP_F_CT_HWF)
+					(ct->fib)->ct_hwf_ref_count++;
+			}
+			ct = ct->next;
+		}
+	}
+
+	/* Update FIB rule pointers in CT invalid list */
+	if (!ct_inv_list)
+		return;
+
+	curr = ct_inv_list->next;
+	while (curr) {
+		ct = (NFP_RULE_CT *)curr->data;
+		tmp = curr->next;
+		if ((fib->family == ct->family) &&
+			(l3_addr_eq(fib->family, fib->srcL3, ct->srcL3)) &&
+#ifdef NFP_NAT
+			((!(ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) ||
+			((ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, (MV_U8 *)&(ct->new_dip)))))) {
+#else
+			(l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) {
+#endif /* NFP_NAT */
+			/* Found incomplete CT entry with a matching FIB rule */
+			if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
+				(ct->fib)->ct_ref_count--;
+			if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
+				(ct->fib)->ct_hwf_ref_count--;
+			ct->fib = fib;
+			(ct->fib)->ct_ref_count++;
+			if (ct->flags & NFP_F_CT_HWF)
+				(ct->fib)->ct_hwf_ref_count++;
+			ct->flags &= ~NFP_F_CT_FIB_INV;
+			mvNfpCtRuleValid(ct, curr);
+		}
+		curr = tmp;
+	}
+}
+
+MV_VOID mvNfpCtRuleFibInvalidate(NFP_RULE_FIB *fib)
+{
+	int i;
+	NFP_RULE_CT *ct, *ct_prev;
+	MV_LIST_ELEMENT	*curr;
+
+	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
+		ct = ct_hash[i];
+		ct_prev = NULL;
+		while (ct) {
+			if ((fib->family == ct->family) &&
+				(l3_addr_eq(fib->family, fib->srcL3, ct->srcL3)) &&
+#ifdef NFP_NAT
+				((!(ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) ||
+				((ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, (MV_U8 *)&(ct->new_dip)))))) {
+#else
+				(l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) {
+#endif /* NFP_NAT */
+				/* Invalidate CT route */
+				if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
+					(ct->fib)->ct_ref_count--;
+				if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
+					(ct->fib)->ct_hwf_ref_count--;
+				ct->flags |= NFP_F_CT_FIB_INV;
+				ct->fib = NULL;
+
+				if (!(ct->flags & NFP_F_CT_DROP)) {
+					/* Remove CT rule from hash table only if it is not a DROP rule */
+					if (ct_prev)
+						ct_prev->next = ct->next;
+					else
+						ct_hash[i] = ct->next;
+
+					/* Add CT rule to incomplete list */
+					mvListAddHead(ct_inv_list, (MV_ULONG)ct);
+				}
+			}
+			ct_prev = ct;
+			ct = ct->next;
+		}
+	}
+
+	/* Invalidate FIB rule pointers in CT invalid list (possible in classification context rules) */
+	if (!ct_inv_list)
+		return;
+
+	curr = ct_inv_list->next;
+	while (curr) {
+		ct = (NFP_RULE_CT *)curr->data;
+		if ((fib->family == ct->family) &&
+			(l3_addr_eq(fib->family, fib->srcL3, ct->srcL3)) &&
+#ifdef NFP_NAT
+			((!(ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) ||
+			((ct->flags & NFP_F_CT_DNAT) && (l3_addr_eq(fib->family, fib->dstL3, (MV_U8 *)&(ct->new_dip)))))) {
+#else
+			(l3_addr_eq(fib->family, fib->dstL3, ct->dstL3))) {
+#endif /* NFP_NAT */
+			if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
+				(ct->fib)->ct_ref_count--;
+			if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
+				(ct->fib)->ct_hwf_ref_count--;
+			ct->flags |= NFP_F_CT_FIB_INV;
+			ct->fib = NULL;
+		}
+		curr = curr->next;
+	}
+}
+
+
+static MV_VOID mvNfpCtRulePrint(NFP_RULE_CT *ct)
+{
+#ifdef NFP_CLASSIFY
+	int i;
+#endif /* NFP_CLASSIFY */
+
+	if (ct->family == MV_INET)
+		mvOsPrintf("IPv4: "MV_IPQUAD_FMT":%d->"MV_IPQUAD_FMT":%d",
+			MV_IPQUAD(ct->srcL3), MV_16BIT_BE(ct->ports & 0xFFFF),
+			MV_IPQUAD(ct->dstL3), MV_16BIT_BE(ct->ports >> 16));
+	else /* MV_INET6 */
+		mvOsPrintf(" IPv6: "MV_IP6_FMT":%d->"MV_IP6_FMT":%d",
+			MV_IP6_ARG(ct->srcL3), MV_16BIT_BE(ct->ports & 0xFFFF),
+			MV_IP6_ARG(ct->dstL3), MV_16BIT_BE(ct->ports >> 16));
+
+	if (ct->proto == MV_IP_PROTO_TCP)
+		mvOsPrintf(" TCP - ");
+	else if (ct->proto == MV_IP_PROTO_UDP)
+		mvOsPrintf(" UDP - ");
+	else
+		mvOsPrintf(" %-2d - ", ct->proto);
+
+	if (ct->flags & NFP_F_CT_DROP)
+		mvOsPrintf("Drop, ");
+	else
+		mvOsPrintf("Forward, ");
+
+	mvOsPrintf("flags=0x%04x, ", ct->flags);
+
+#ifdef NFP_NAT
+	if (ct->flags & NFP_F_CT_DNAT)
+		mvOsPrintf("DNAT: "MV_IPQUAD_FMT":%d, ", MV_IPQUAD(((MV_U8 *)&ct->new_dip)), MV_16BIT_BE(ct->new_dport));
+
+	if (ct->flags & NFP_F_CT_SNAT)
+		mvOsPrintf("SNAT: "MV_IPQUAD_FMT":%d, ", MV_IPQUAD(((MV_U8 *)&ct->new_sip)), MV_16BIT_BE(ct->new_sport));
+#endif /* NFP_NAT */
+
+
+#ifdef NFP_CLASSIFY
+	if (ct->flags & NFP_F_CT_NOT_EXIST)
+		mvOsPrintf("This rule is in classification context\n");
+
+	if (ct->flags & NFP_F_CT_SET_MH)
+		mvOsPrintf("MH=0x%X ", ct->mh);
+
+	if (ct->flags & NFP_F_CT_SET_TXP)
+		mvOsPrintf("txp=0x%X ", ct->txp);
+#endif /* NFP_CLASSIFY */
+
+	mvOsPrintf("age=%d, hit=%d\n", ct->age, ct->hit_cntr);
+
+#ifdef NFP_CLASSIFY
+	if (ct->flags & NFP_F_CT_SET_TXQ) {
+		mvOsPrintf(" DSCP to TXQ Map: ");
+		mvOsPrintf("DSCP        TXQ\n");
+		for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++) {
+			if (ct->txq_map[i].valid) {
+				if (i == NFP_DSCP_MAP_GLOBAL)
+					mvOsPrintf("           Global     %2d\n", ct->txq_map[i].txq);
+				else
+					mvOsPrintf("           %2d         %2d\n", i, ct->txq_map[i].txq);
+			}
+		}
+	}
+
+	if (ct->flags & NFP_F_CT_SET_DSCP) {
+		mvOsPrintf(" DSCP Map: ");
+		mvOsPrintf("Old        New\n");
+		for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++) {
+			if (ct->dscp_map[i].valid) {
+				if (i == NFP_DSCP_MAP_GLOBAL)
+					mvOsPrintf("           Global     %2d\n", ct->dscp_map[i].new_dscp);
+				else
+					mvOsPrintf("           %2d         %2d\n", i, ct->dscp_map[i].new_dscp);
+			}
+		}
+	}
+
+	if (ct->flags & NFP_F_CT_SET_VLAN_PRIO) {
+		mvOsPrintf(" VPri Map: ");
+		mvOsPrintf("Old        New\n");
+		for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++) {
+			if (ct->vpri_map[i].valid) {
+				if (i == NFP_VPRI_MAP_GLOBAL)
+					mvOsPrintf("           Global     %2d\n", ct->vpri_map[i].new_prio);
+				else
+					mvOsPrintf("           %2d         %2d\n", i, ct->vpri_map[i].new_prio);
+			}
+		}
+	}
+#endif /* NFP_CLASSIFY */
+}
+
+static NFP_RULE_CT *mvNfpCtRuleInvalidLookup(NFP_RULE_CT *ct2)
+{
+	MV_LIST_ELEMENT	*curr;
+	NFP_RULE_CT *ct;
+
+	if (!ct_inv_list)
+		return NULL;
+
+	curr = ct_inv_list->next;
+	while (curr) {
+		ct = (NFP_RULE_CT *)curr->data;
+		if ((ct->family == ct2->family) &&
+			l3_addr_eq(ct->family, ct->srcL3, ct2->srcL3) &&
+			l3_addr_eq(ct->family, ct->dstL3, ct2->dstL3) &&
+			(ct->ports == ct2->ports) &&
+			(ct->proto == ct2->proto))
+			return ct;
+
+		curr = curr->next;
+	}
+	return NULL;
+}
+
+MV_STATUS   mvNfpCtRuleAge(NFP_RULE_CT *ct2)
+{
+	NFP_RULE_CT *ct;
+
+	ct = mvNfpCtRuleInvalidLookup(ct2);
+	if (ct) {
+		ct2->age = (ct->flags & NFP_F_CT_HWF) ? 1 : ct->age;
+		ct->age = (ct->flags & NFP_F_CT_HWF) ? ct->age : 0;
+		return MV_OK;
+	}
+
+	ct = mvNfpCtLookup(ct2);
+	if (ct) {
+		ct2->age = (ct->flags & NFP_F_CT_HWF) ? 1 : ct->age;
+		ct->age = (ct->flags & NFP_F_CT_HWF) ? ct->age : 0;
+		return MV_OK;
+	}
+
+	ct2->age = 0;
+	return MV_NOT_FOUND;
+}
+
+/* create rule from classification context                                           *
+ *     - search and update if relevant FIB rule exist                                *
+ *     - set NFP_F_CT_NOT_EXIST flag                                                 *
+ *     - add rule to invalid rule list (NFP_F_CT_NOT_EXIST is set)                   *
+ *     - if mvNfpCtFilterModeSet is called later, then clear NFP_F_CT_NOT_EXIST flag *
+ * Return: pointer to created rule                                                   */
+NFP_RULE_CT *mvNfpCtClassifyRuleCreate(NFP_RULE_CT *ct2)
+{
+	/* rule not exist - create rule and mark it as "not exist" */
+	NFP_RULE_CT *ct = (NFP_RULE_CT *)mvOsMalloc(sizeof(NFP_RULE_CT));
+	if (!ct) {
+		mvOsPrintf("%s: OOM\n", __func__);
+		return NULL;
+	}
+
+	mvOsMemcpy(ct, ct2, sizeof(NFP_RULE_CT));
+
+	ct->flags |= NFP_F_CT_NOT_EXIST;
+	ct->flags |= NFP_F_CT_FIB_INV;
+	/* this rule is invalid until mvNfpCtFilterModeSet will be called */
+	mvListAddHead(ct_inv_list, (MV_ULONG)ct);
+	return ct;
+}
+
+#ifdef NFP_NAT
+MV_STATUS mvNfpCtNatRuleAdd(NFP_RULE_CT *nat2)
+{
+	NFP_RULE_CT *nat;
+	MV_U32 hash;
+
+	/* Update rule if it exists as a valid rule or as an invalid rule */
+	nat = mvNfpCtLookup(nat2);
+	if (!nat)
+		nat = mvNfpCtRuleInvalidLookup(nat2);
+
+	if (nat) {
+		if (nat->flags & NFP_F_CT_NOT_EXIST)
+			nat->flags &= ~NFP_F_CT_NOT_EXIST;
+		if (nat2->flags & NFP_F_CT_SNAT) {
+			nat->new_sip = nat2->new_sip;
+			nat->new_sport = nat2->new_sport;
+			nat->flags |= NFP_F_CT_SNAT;
+		}
+		if (nat2->flags & NFP_F_CT_DNAT) {
+			nat->new_dip = nat2->new_dip;
+			nat->new_dport = nat2->new_dport;
+			nat->flags |= NFP_F_CT_DNAT;
+		}
+		/* copy other information to nat2 - classification, tbf, etc.. */
+		mvOsMemcpy(nat2, nat, sizeof(NFP_RULE_CT));
+
+		/* delete previous rule, and add it again later (will search for fib again)    */
+		/* delete is important because it updates fib->ct_ref_count, rate limit, etc.. */
+		mvNfpCtRuleDel(nat);
+	}
+
+	nat = (NFP_RULE_CT *)mvOsMalloc(sizeof(NFP_RULE_CT));
+	if (!nat) {
+		mvOsPrintf("%s: OOM\n", __func__);
+		return MV_FAIL;
+	}
+	mvOsMemcpy(nat, nat2, sizeof(NFP_RULE_CT));
+
+	if (nat->flags & NFP_F_CT_DNAT)
+		nat->fib = mvNfpFibLookup(nat2->family, nat2->srcL3, (const MV_U8 *)&(nat2->new_dip));
+	else
+		nat->fib = mvNfpFibLookup(nat2->family, nat2->srcL3, nat2->dstL3);
+
+	if (nat->fib) {
+		(nat->fib)->ct_ref_count++; /* update FIB reference count */
+		hash = mvNfpCtHash(nat2);
+		nat->next = ct_hash[hash];
+		ct_hash[hash] = nat;
+		nat->visited = 0;
+	} else {
+		mvListAddHead(ct_inv_list, (MV_ULONG)nat);
+	}
+
+	NFP_DBG("NFP (nat) add %p\n", nat);
+
+	return MV_OK;
+}
+#endif /* NFP_NAT */
+
+MV_STATUS mvNfpCtFilterModeSet(NFP_RULE_CT *ct2)
+{
+	NFP_RULE_CT *ct, *new_ct;
+	MV_LIST_ELEMENT	*element;
+	MV_U32 hash;
+
+	/* The rule can be in one of several initial states, each requires different handling	*/
+	/* The rule can exists as valid, exist as invalid or not exist at this point		*/
+
+	ct = mvNfpCtLookup(ct2);
+	if (ct) {
+		/* Rule exists as valid */
+		/* Either it has valid FIB information, or it is a DROP rule */
+
+		if (ct2->flags & NFP_F_CT_DROP) {
+			/* Updated rule says DROP, so we don't care if FIB information exists or not */
+			ct->flags |= NFP_F_CT_DROP;
+		} else {
+			/* Updated rule says FORWARD */
+			ct->flags &= ~NFP_F_CT_DROP;
+			if (ct->flags & NFP_F_CT_FIB_INV) {
+				/* need to move this rule to the invalid list */
+				new_ct = (NFP_RULE_CT *)mvOsMalloc(sizeof(NFP_RULE_CT));
+				if (!new_ct) {
+					mvOsPrintf("%s: OOM\n", __func__);
+					return MV_FAIL;
+				}
+				mvOsMemcpy(new_ct, ct, sizeof(NFP_RULE_CT));
+#ifdef NFP_LIMIT
+				if (new_ct->tbfInfo)
+					new_ct->tbfInfo->refCnt++;
+#endif /* NFP_LIMIT */
+				mvNfpCtRuleDel(ct);
+				mvListAddHead(ct_inv_list, (MV_ULONG)new_ct);
+			}
+		}
+		return MV_OK;
+	}
+
+
+	ct = mvNfpCtRuleInvalidLookup(ct2);
+	/* Rule exists as invalid */
+	if (ct) {
+		/* this rule was created by classification API  *
+		 *     mark it as "real" rule                   *
+		 *     search for relevant fib rule             */
+		if (ct->flags & NFP_F_CT_NOT_EXIST) {
+			ct->flags &= ~NFP_F_CT_NOT_EXIST;
+			ct->flags |= NFP_F_CT_FIB_INV;
+			ct->fib = mvNfpFibLookup(ct2->family, ct2->srcL3, ct2->dstL3);
+			if (ct->fib) {
+				(ct->fib)->ct_ref_count++;
+				ct->flags &= ~NFP_F_CT_FIB_INV;
+			}
+		}
+		if (ct2->flags & NFP_F_CT_DROP || !(ct->flags & NFP_F_CT_FIB_INV)) {
+			/* need to move this rule to the valid rules database */
+			if (ct2->flags & NFP_F_CT_DROP)
+				ct->flags |= NFP_F_CT_DROP;
+			element = mvListFind(ct_inv_list, (MV_ULONG)ct);
+			if (!element)
+				return MV_FAIL;
+			return mvNfpCtRuleValid(ct, element);
+		} else {
+			/* no need to do anything special - clearing DROP flag just for clarity, it is already cleared */
+			ct->flags &= ~NFP_F_CT_DROP;
+			return MV_OK;
+		}
+	}
+
+
+	/* Rule doesn't exist, need to create  a new one */
+	ct = (NFP_RULE_CT *)mvOsMalloc(sizeof(NFP_RULE_CT));
+	if (!ct) {
+		mvOsPrintf("%s: OOM\n", __func__);
+		return MV_FAIL;
+	}
+
+	mvOsMemcpy(ct, ct2, sizeof(NFP_RULE_CT));
+
+	ct->flags |= NFP_F_CT_FIB_INV;
+	ct->fib = mvNfpFibLookup(ct2->family, ct2->srcL3, ct2->dstL3);
+	if (ct->fib) {
+		(ct->fib)->ct_ref_count++;
+		ct->flags &= ~NFP_F_CT_FIB_INV;
+	}
+
+	if ((ct->flags & NFP_F_CT_DROP) || !(ct->flags & NFP_F_CT_FIB_INV)) {
+		hash = mvNfpCtHash(ct2);
+		ct->next = ct_hash[hash];
+		ct_hash[hash] = ct;
+		ct->visited = 0;
+	} else {
+		mvListAddHead(ct_inv_list, (MV_ULONG)ct);
+	}
+
+	NFP_DBG("NFP (ct filter mode) set %p\n", ct);
+
+	return MV_OK;
+}
+
+#ifdef NFP_LIMIT
+void mvNfpCtTbfsDump(void)
+{
+	MV_LIST_ELEMENT	*curr;
+	NFP_TBF_INFO *tbf_data;
+	mvOsPrintf("Tbfs list:\n");
+	if (!tbfs)
+		return;
+	curr = tbfs->next;
+	while (curr) {
+		tbf_data = (NFP_TBF_INFO *)curr->data;
+		mvOsPrintf("index: %d,  limit: %d,  burst: %d, refCnt: %d\n", tbf_data->index,
+				tbf_data->creditPerTick * mvOsGetTicksFreq(), tbf_data->creditMax, tbf_data->refCnt);
+		curr = curr->next;
+	}
+	mvOsPrintf("\n");
+}
+
+/* limit units = KBytes/sec, burst_limit units = Kbytes */
+int mvNfpTbfCreate(int limit, int burst_limit)
+{
+	NFP_TBF_INFO *tbf;
+
+	if (limit < 0 || burst_limit < 0 || !tbfs)
+		return -1;
+
+	tbf = mvOsMalloc(sizeof(NFP_TBF_INFO));
+	if (!tbf) {
+		mvOsPrintf("%s: OOM\n", __func__);
+		return -1;
+	}
+
+	tbf->refCnt = 0;
+	tbf->credit = tbf->creditMax = (burst_limit * 1000); /* Bytes */
+	/* convert from KBytes/sec to Bytes/tick */
+	tbf->creditPerTick = (limit * 1000) / mvOsGetTicksFreq(); /* Bytes per tick */
+	if (tbf->creditPerTick == 0)
+		tbf->maxElapsedTicks = 0;
+	else
+		tbf->maxElapsedTicks = tbf->creditMax / tbf->creditPerTick; /* ticks */
+	tbf->lastUpdate = mvOsGetTicks(); /* ticks */
+
+	/* calculate index */
+	if (tbfs->next)
+		tbf->index = ((NFP_TBF_INFO *)(tbfs->next->data))->index + 1;
+	else
+		tbf->index = 0;
+
+	if (!mvListAddHead(tbfs, (MV_U32)tbf)) {
+		mvOsPrintf("%s: OOM\n", __func__);
+		mvOsFree(tbf);
+		return -1;
+	}
+	return tbf->index;
+}
+
+NFP_TBF_INFO *mvNfpTbfGet(int tbf)
+{
+	MV_LIST_ELEMENT	*curr;
+	NFP_TBF_INFO *tbf_data;
+	if (tbf < 0 || !tbfs)
+		return NULL;
+	curr = tbfs->next;
+	while (curr) {
+		tbf_data = (NFP_TBF_INFO *)curr->data;
+		if (tbf_data->index == tbf)
+			return tbf_data;
+		curr = curr->next;
+	}
+	return NULL;
+}
+
+MV_STATUS mvNfpTbfDel(int tbf)
+{
+	MV_LIST_ELEMENT *element;
+	NFP_TBF_INFO *tbf_data = mvNfpTbfGet(tbf);
+	if (!tbf_data) {
+		mvOsPrintf("%s: Invalid Token Bucket Filter index (%d)\n", __func__, tbf);
+		return MV_BAD_PARAM;
+	}
+	/* delete tbf only if there are no rules attached */
+	if (!tbf_data->refCnt) {
+		element = mvListFind(tbfs, (MV_ULONG)tbf_data);
+		mvListDel(element);
+		mvOsFree(tbf_data);
+	}
+	return MV_OK;
+}
+
+MV_STATUS mvNfpCtRateLimitSet(NFP_RULE_CT *ct2, int tbf_index)
+{
+	NFP_RULE_CT *ct;
+	NFP_TBF_INFO *tbf = mvNfpTbfGet(tbf_index);
+
+	if (!ct2)
+		return MV_BAD_PARAM;
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+
+	if (ct) {
+		if (tbf) {
+			if (ct->tbfInfo)
+				(ct->tbfInfo)->refCnt--;
+			tbf->refCnt++;
+			ct->tbfInfo = tbf;
+			ct->flags |= NFP_F_CT_LIMIT;
+		} else {
+			mvOsPrintf("%s: Invalid Token Bucket Filter index (%d)\n", __func__, tbf_index);
+			return MV_BAD_PARAM;
+		}
+	} else {
+		mvOsPrintf("%s Error: Could not find existing 5 tuple rule\n", __func__);
+		return MV_NOT_FOUND;
+	}
+
+	NFP_DBG("NFP (ct rate limit) set %p\n", ct);
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpCtRateLimitDel(NFP_RULE_CT *ct2)
+{
+	NFP_RULE_CT *ct;
+
+	if (!ct2)
+		return MV_BAD_PARAM;
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+
+	if (ct) {
+		if (ct->tbfInfo)
+			(ct->tbfInfo)->refCnt--;
+
+		ct->tbfInfo = NULL;
+		ct->flags &= ~NFP_F_CT_LIMIT;
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpTbfProcess(NFP_TBF_INFO *tbf, MV_U32 packetSize)
+{
+	MV_U32 ticks = mvOsGetTicks();
+	MV_U32 elapsed;
+
+	if (!tbf)
+		return MV_CONTINUE;
+	/* Update credit */
+	elapsed = ticks - tbf->lastUpdate;
+	tbf->lastUpdate = ticks;
+	/* safe check if elapsed time is higher than "time that gives maximum credit" */
+	if (elapsed > tbf->maxElapsedTicks) {
+		tbf->credit = tbf->creditMax;
+	} else {
+		tbf->credit += elapsed * tbf->creditPerTick;
+		if (tbf->credit > tbf->creditMax)
+			tbf->credit = tbf->creditMax;
+	}
+
+	/* Check result */
+	if (packetSize > tbf->credit)
+		return MV_DROPPED;
+	tbf->credit -= packetSize;
+	return MV_CONTINUE;
+}
+#endif /* NFP_LIMIT */
+
+#ifdef NFP_CLASSIFY
+/* Add DSCP mapping for an existing 5 tuple rule */
+MV_STATUS mvNfpCtDscpRuleAdd(NFP_RULE_CT *ct2, int dscp, int new_dscp)
+{
+	NFP_RULE_CT *ct;
+
+	/* sanity: chack new_dscp parameter */
+	if ((new_dscp < NFP_DSCP_MIN) || (new_dscp > NFP_DSCP_MAX)) {
+		mvOsPrintf("%s Error: new_dscp value (%d) is out of range\n", __func__, new_dscp);
+		return MV_BAD_PARAM;
+	}
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+	/* rule is not exist - create rule from classification context */
+	if (!ct) {
+		ct = mvNfpCtClassifyRuleCreate(ct2);
+		if (!ct)
+			return MV_FAIL;
+	}
+
+	/* Update rule DSCP map table */
+	if (ct2->flags & NFP_F_CT_SET_DSCP) {
+		if (dscp == MV_ETH_NFP_GLOBAL_MAP) {
+			ct->dscp_map[NFP_DSCP_MAP_GLOBAL].new_dscp = new_dscp;
+			ct->dscp_map[NFP_DSCP_MAP_GLOBAL].valid = MV_TRUE;
+		} else if ((dscp >= NFP_DSCP_MIN) && (dscp <= NFP_DSCP_MAX)) {
+			ct->dscp_map[dscp].new_dscp = new_dscp;
+			ct->dscp_map[dscp].valid = MV_TRUE;
+		} else {
+			mvOsPrintf("%s Error: dscp value (%d) is out of range\n", __func__, dscp);
+			return MV_BAD_PARAM;
+		}
+		ct->flags |= NFP_F_CT_SET_DSCP;
+	} else {
+		mvOsPrintf("%s Error: NFP_F_CT_SET_DSCP flag is not set\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	NFP_DBG("NFP (ct dscp) set %p\n", ct);
+
+	return MV_OK;
+}
+
+static INLINE MV_STATUS mvNfpIsDscpSet(NFP_RULE_CT *ct)
+{
+	int i;
+
+	for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++)
+		if (ct->dscp_map[i].valid)
+			return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+MV_STATUS mvNfpCtDscpRuleDel(NFP_RULE_CT *ct2, int dscp)
+{
+	NFP_RULE_CT *ct;
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+
+	if (ct) {
+		if (dscp == MV_ETH_NFP_GLOBAL_MAP) {
+			ct->dscp_map[NFP_DSCP_MAP_GLOBAL].new_dscp = 0;
+			ct->dscp_map[NFP_DSCP_MAP_GLOBAL].valid = MV_FALSE;
+		} else if ((dscp >= NFP_DSCP_MIN) && (dscp <= NFP_DSCP_MAX)) {
+			ct->dscp_map[dscp].new_dscp = 0;
+			ct->dscp_map[dscp].valid = MV_FALSE;
+		} else {
+			mvOsPrintf("%s Error: dscp value (%d) is out of range\n", __func__, dscp);
+			return MV_BAD_PARAM;
+		}
+
+		if (!mvNfpIsDscpSet(ct))
+			ct->flags &= ~NFP_F_CT_SET_DSCP;
+
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpCtVlanPrioRuleAdd(NFP_RULE_CT *ct2, int prio, int new_prio)
+{
+	NFP_RULE_CT *ct;
+
+	/* sanity: chack new_prio parameter */
+	if ((new_prio < NFP_VPRI_MIN) || (new_prio > NFP_VPRI_MAX)) {
+		mvOsPrintf("%s Error: new_prio value (%d) is out of range\n", __func__, new_prio);
+		return MV_BAD_PARAM;
+	}
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+	/* rule is not exist - create rule from classification context */
+	if (!ct) {
+		ct = mvNfpCtClassifyRuleCreate(ct2);
+		if (!ct)
+			return MV_FAIL;
+	}
+
+	/* Update rule VLAN Priority map table */
+	if (ct2->flags & NFP_F_CT_SET_VLAN_PRIO) {
+		if (prio == MV_ETH_NFP_GLOBAL_MAP) {
+			ct->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio = new_prio;
+			ct->vpri_map[NFP_VPRI_MAP_GLOBAL].valid = MV_TRUE;
+		} else if ((prio >= NFP_VPRI_MIN) && (prio <= NFP_VPRI_MAX)) {
+			ct->vpri_map[prio].new_prio = new_prio;
+			ct->vpri_map[prio].valid = MV_TRUE;
+		} else {
+			mvOsPrintf("%s Error: prio value (%d) is out of range\n", __func__, prio);
+			return MV_BAD_PARAM;
+		}
+		ct->flags |= NFP_F_CT_SET_VLAN_PRIO;
+	} else {
+		mvOsPrintf("%s: NFP_F_CT_SET_VLAN_PRIO flag is not set\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	NFP_DBG("NFP (ct vpri) set %p\n", ct);
+
+	return MV_OK;
+}
+
+static INLINE MV_STATUS mvNfpIsVpriSet(NFP_RULE_CT *ct)
+{
+	int i;
+
+	for (i = 0; i <= NFP_VPRI_MAP_GLOBAL; i++)
+		if (ct->vpri_map[i].valid)
+			return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+MV_STATUS mvNfpCtVlanPrioRuleDel(NFP_RULE_CT *ct2, int prio)
+{
+	NFP_RULE_CT *ct;
+
+	/* sanity: chack prio parameter */
+	if ((prio < MV_ETH_NFP_GLOBAL_MAP) || (prio > NFP_VPRI_MAP_GLOBAL)) {
+		mvOsPrintf("%s Error: prio value (%d) is out of range\n", __func__, prio);
+		return MV_BAD_PARAM;
+	}
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+
+	if (ct) {
+		if (prio == MV_ETH_NFP_GLOBAL_MAP) {
+			ct->vpri_map[NFP_VPRI_MAP_GLOBAL].new_prio = 0;
+			ct->vpri_map[NFP_VPRI_MAP_GLOBAL].valid = MV_FALSE;
+		} else {
+			ct->vpri_map[prio].new_prio = 0;
+			ct->vpri_map[prio].valid = MV_FALSE;
+		}
+		if (!mvNfpIsVpriSet(ct))
+			ct->flags &= ~NFP_F_CT_SET_VLAN_PRIO;
+
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpCtTxqRuleAdd(NFP_RULE_CT *ct2, int dscp, int txq)
+{
+	NFP_RULE_CT *ct;
+
+	/* sanity: chack txq parameter */
+	if ((txq < 0) || (txq >= CONFIG_MV_ETH_TXQ)) {
+		mvOsPrintf("%s Error: txq (%d) is out of range\n", __func__, txq);
+		return MV_BAD_PARAM;
+	}
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+	/* rule is not exist - create rule from classification context */
+	if (!ct) {
+		ct = mvNfpCtClassifyRuleCreate(ct2);
+		if (!ct)
+			return MV_FAIL;
+	}
+
+	/* Update rule DSCP to TXQ map table */
+	if (ct2->flags & NFP_F_CT_SET_TXQ) {
+		if (dscp == MV_ETH_NFP_GLOBAL_MAP) {
+			ct->txq_map[NFP_DSCP_MAP_GLOBAL].txq = txq;
+			ct->txq_map[NFP_DSCP_MAP_GLOBAL].valid = MV_TRUE;
+		} else if ((dscp >= NFP_DSCP_MIN) && (dscp <= NFP_DSCP_MAX)) {
+			ct->txq_map[dscp].txq = txq;
+			ct->txq_map[dscp].valid = MV_TRUE;
+		} else {
+			mvOsPrintf("%s Error: dscp value (%d) is out of range\n", __func__, dscp);
+			return MV_BAD_PARAM;
+		}
+		ct->flags |= NFP_F_CT_SET_TXQ;
+	} else {
+		mvOsPrintf("%s Error: NFP_F_CT_SET_TXQ flag is not set\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	NFP_DBG("NFP (ct txq) set %p\n", ct);
+
+	return MV_OK;
+}
+
+static INLINE MV_STATUS mvNfpIsTxqSet(NFP_RULE_CT *ct)
+{
+	int i;
+
+	for (i = 0; i <= NFP_DSCP_MAP_GLOBAL; i++)
+		if (ct->txq_map[i].valid)
+			return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+MV_STATUS mvNfpCtTxqRuleDel(NFP_RULE_CT *ct2, int dscp)
+{
+	NFP_RULE_CT *ct;
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+
+	if (ct) {
+		if (dscp == MV_ETH_NFP_GLOBAL_MAP) {
+			ct->txq_map[NFP_DSCP_MAP_GLOBAL].txq = 0;
+			ct->txq_map[NFP_DSCP_MAP_GLOBAL].valid = MV_FALSE;
+		} else if ((dscp >= NFP_DSCP_MIN) && (dscp <= NFP_DSCP_MAX)) {
+			ct->txq_map[dscp].txq = 0;
+			ct->txq_map[dscp].valid = MV_FALSE;
+		} else {
+			mvOsPrintf("%s Error: dscp value (%d) is out of range\n", __func__, dscp);
+			return MV_BAD_PARAM;
+		}
+
+		if (!mvNfpIsTxqSet(ct))
+			ct->flags &= ~NFP_F_CT_SET_TXQ;
+
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpCtTxpRuleAdd(NFP_RULE_CT *ct2)
+{
+	NFP_RULE_CT *ct;
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+	/* rule is not exist - create rule from classification context */
+	if (!ct) {
+		ct = mvNfpCtClassifyRuleCreate(ct2);
+		if (!ct)
+			return MV_FAIL;
+	}
+
+	/* Update rule Txq table */
+	if (ct2->flags & NFP_F_CT_SET_TXP) {
+		ct->txp = ct2->txp;
+		ct->flags |= NFP_F_CT_SET_TXP;
+	} else {
+		mvOsPrintf("%s: NFP_F_CT_SET_TXP flag is not set\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	NFP_DBG("NFP (ct txp) set %p\n", ct);
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpCtTxpRuleDel(NFP_RULE_CT *ct2)
+{
+	NFP_RULE_CT *ct;
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+
+	if (ct) {
+		ct->txp = 0;
+		ct->flags &= ~NFP_F_CT_SET_TXP;
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpCtMhRuleAdd(NFP_RULE_CT *ct2)
+{
+	NFP_RULE_CT *ct;
+
+	/* sanity: chack mh parameter */
+	if (ct2->mh < 0) {
+		mvOsPrintf("%s Error: mh (%d) is out of range\n", __func__, ct2->mh);
+		return MV_BAD_PARAM;
+	}
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+	/* rule is not exist - create rule from classification context */
+	if (!ct) {
+		ct = mvNfpCtClassifyRuleCreate(ct2);
+		if (!ct)
+			return MV_FAIL;
+	}
+
+	/* Update rule MH table */
+	if (ct2->flags & NFP_F_CT_SET_MH) {
+		ct->mh = ct2->mh;
+		ct->flags |= NFP_F_CT_SET_MH;
+	} else {
+		mvOsPrintf("%s: NFP_F_CT_SET_MH flag is not set\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	NFP_DBG("NFP (ct mh) set %p\n", ct);
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpCtMhRuleDel(NFP_RULE_CT *ct2)
+{
+	NFP_RULE_CT *ct;
+
+	/* Rule must exist already, but it can be valid or invalid */
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+
+	if (ct) {
+		ct->mh = 0;
+		ct->flags &= ~NFP_F_CT_SET_MH;
+		return MV_OK;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+#endif /* NFP_CLASSIFY */
+
+MV_STATUS mvNfpCtRuleDel(NFP_RULE_CT *ct2)
+{
+	MV_U32 hash;
+	NFP_RULE_CT *ct, *prev;
+	MV_LIST_ELEMENT	*element;
+
+	/* If this rule currently exists in the Invalid Rules DB, delete it */
+	ct = mvNfpCtRuleInvalidLookup(ct2);
+	if (ct) {
+		if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
+			(ct->fib)->ct_ref_count--;
+		if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
+			(ct->fib)->ct_hwf_ref_count--;
+		element = mvListFind(ct_inv_list, (MV_ULONG)ct);
+#ifdef NFP_LIMIT
+		if (ct->tbfInfo)
+			mvNfpCtRateLimitDel(ct);
+#endif /* NFP_LIMIT */
+		mvListDel(element);
+		mvOsFree(ct);
+		return MV_OK;
+	}
+
+	hash = mvNfpCtHash(ct2);
+	ct = ct_hash[hash];
+
+	prev = NULL;
+	while (ct) {
+		if ((ct->family == ct2->family) &&
+			l3_addr_eq(ct->family, ct->srcL3, ct2->srcL3) &&
+			l3_addr_eq(ct->family, ct->dstL3, ct2->dstL3) &&
+			(ct->ports == ct2->ports) &&
+			(ct->proto == ct2->proto)) {
+			if (ct->fib && !(ct->flags & NFP_F_CT_FIB_INV))
+				(ct->fib)->ct_ref_count--;
+			if ((ct->fib) && (ct->flags & NFP_F_CT_HWF) && !(ct->flags & NFP_F_CT_FIB_INV))
+				(ct->fib)->ct_hwf_ref_count--;
+			if (prev)
+				prev->next = ct->next;
+			else
+				ct_hash[hash] = ct->next;
+
+			NFP_DBG("NFP (ct) del %p\n", ct);
+#ifdef NFP_LIMIT
+			if (ct->tbfInfo)
+				mvNfpCtRateLimitDel(ct);
+#endif /* NFP_LIMIT */
+			mvOsFree(ct);
+			return MV_OK;
+		}
+		prev = ct;
+		ct = ct->next;
+	}
+
+	return MV_NOT_FOUND;
+}
+
+void    mvNfpCtClean(int family)
+{
+	int             i;
+	NFP_RULE_CT    *ct, *next;
+#ifdef NFP_LIMIT
+	NFP_TBF_INFO *tbf_data;
+#endif /* NFP_LIMIT */
+	MV_LIST_ELEMENT	*curr, *tmp;
+
+	/* Clean CT incomplete rules list */
+	if (ct_inv_list) {
+		curr = ct_inv_list->next;
+		while (curr) {
+			tmp = curr->next;
+			ct = (NFP_RULE_CT *)curr->data;
+			if (ct->family == family) {
+#ifdef NFP_LIMIT
+			if (ct->tbfInfo)
+				mvNfpCtRateLimitDel(ct);
+#endif /* NFP_LIMIT */
+			mvOsFree(ct);
+			mvListDel(curr);
+			}
+			curr = tmp;
+		}
+	}
+
+	/* Clean CT hash table */
+	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
+		ct = ct_hash[i];
+
+		while (ct) {
+			next = ct->next;
+			if (ct->family == family) {
+#ifdef NFP_LIMIT
+			if (ct->tbfInfo)
+				mvNfpCtRateLimitDel(ct);
+#endif /* NFP_LIMIT */
+			mvOsFree(ct);
+			}
+			ct = next;
+		}
+		ct_hash[i] = NULL;
+	}
+#ifdef NFP_LIMIT
+	/* clean tbfs */
+	if (tbfs) {
+		curr = tbfs->next;
+		while (curr) {
+			tbf_data = (NFP_TBF_INFO *)mvListDel(curr);
+			mvOsFree(tbf_data);
+			curr = tbfs->next;
+		}
+	}
+
+#endif /* NFP_LIMIT */
+}
+
+void	mvNfpCtDestroy(void)
+{
+	if (ct_hash)
+		mvOsFree(ct_hash);
+#ifdef NFP_LIMIT
+	if (tbfs)
+		mvOsFree(tbfs);
+#endif /* NFP_LIMIT */
+	mvListDestroy(ct_inv_list);
+}
+
+MV_VOID mvNfpCtCleanVisited(MV_U32 row, MV_U32 iterator_id)
+{
+	NFP_RULE_CT *curr  = ct_hash[row];
+
+	while (curr) {
+		curr->visited = curr->visited & ~(1 << iterator_id);
+		curr = curr->next;
+	}
+}
+
+MV_STATUS mvNfpCtFirstRuleGet(NFP_RULE_CT **rule, MV_U32 iterator_id)
+{
+	mvNfpCtCleanVisited(ct_iterator_row, iterator_id);
+	ct_iterator_row  = 0;
+	return mvNfpCtNextRuleGet(rule, iterator_id);
+}
+
+MV_STATUS mvNfpCtNextRuleGet(NFP_RULE_CT **rule, MV_U32 iterator_id)
+{
+	NFP_RULE_CT *curr;
+
+	while (ct_iterator_row < NFP_CT_HASH_SIZE) {
+		curr  = ct_hash[ct_iterator_row];
+		/* skip visited and HWF processed rules */
+		while (curr && ((curr->visited & (1 << iterator_id))
+				|| (curr->flags & NFP_F_CT_HWF)))
+			curr = curr->next;
+		if (!curr) { /* reached end of line */
+			mvNfpCtCleanVisited(ct_iterator_row, iterator_id);
+			ct_iterator_row++;
+			continue;
+		}
+		curr->visited = 1; /* update - this rule is now visited by iterator */
+		*rule = curr;
+		return MV_OK;
+	}
+	/* reached end of DB - no rule is found */
+	ct_iterator_row = 0; /* next call start from the begining of the DB */
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpCtRuleMaxHitCntrGet(NFP_RULE_CT **rule)
+{
+	int i;
+	MV_U32 max = -1;
+	NFP_RULE_CT *curr, *max_rule = NULL;
+
+	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
+		curr = ct_hash[i];
+		while (curr) {
+			if (curr->flags & NFP_F_CT_HWF) {
+				curr = curr->next;
+				continue;
+			}
+			if (curr->hit_cntr > max || !max_rule) {
+				max = curr->hit_cntr;
+				max_rule = curr;
+			}
+			curr = curr->next;
+		}
+	}
+	if (!max_rule)
+		return MV_NOT_FOUND;
+	*rule = max_rule;
+	return MV_OK;
+}
+
+/* 0 - set zero to UDP csum on TX, 1 - recalculate UDP csum on TX */
+MV_STATUS mvNfpCtRuleUdpCsumSet(NFP_RULE_CT *ct2, int mode)
+{
+	NFP_RULE_CT *ct;
+
+	if (!ct2 || (mode < 0) || (mode > 1) || (ct2->proto != MV_IP_PROTO_UDP))
+		return MV_BAD_PARAM;
+
+	ct = mvNfpCtLookup(ct2);
+	if (!ct)
+		ct = mvNfpCtRuleInvalidLookup(ct2);
+
+	if (!ct)
+		return MV_NOT_FOUND;
+
+	if (mode)
+		ct->flags |= NFP_F_CT_UDP_CSUM;
+	else
+		ct->flags &= ~NFP_F_CT_UDP_CSUM;
+
+	return MV_OK;
+}
+
+/* mode = 1:HWF,  0:NFP  */
+MV_STATUS mvNfpCtRuleHwfSet(MV_NFP_CT_KEY *key, int mode)
+{
+	NFP_RULE_CT *rule;
+	MV_U32 nflags = 0, ports;
+
+	if (!key || (mode < 0) || (mode > 1))
+		return MV_BAD_PARAM;
+
+	ports = (MV_16BIT_BE(key->dport) << 16) | MV_16BIT_BE(key->sport);
+	rule = mvNfpCtLookupByTuple(key->family, key->src_l3, key->dst_l3, ports, key->proto);
+	if (!rule)
+		return MV_NOT_FOUND;
+
+	/* sanity check */
+	if (!rule->fib || (rule->flags & NFP_F_CT_FIB_INV))
+		return MV_NOT_FOUND;
+
+	if (mode)
+		nflags = (rule->flags | NFP_F_CT_HWF);
+	else
+		nflags = (rule->flags & ~NFP_F_CT_HWF);
+
+	if (rule->flags != nflags) {
+		/* Mode is changed - update hwf ref count */
+		if (mode) /* go to HWF mode */
+			rule->fib->ct_hwf_ref_count++;
+		else {
+			/* exit from HWF mode */
+			rule->fib->ct_hwf_ref_count--;
+			rule->hit_cntr = 0;
+		}
+	}
+	rule->flags = nflags;
+	return MV_OK;
+}
+
+MV_STATUS mvNfpCtRuleHitCntrGet(MV_NFP_CT_KEY *key, MV_U32 *hit_cntr)
+{
+	NFP_RULE_CT *rule;
+	MV_U32 ports;
+
+	if (!key || !hit_cntr)
+		return MV_BAD_PARAM;
+		ports = (MV_16BIT_BE(key->dport) << 16) | MV_16BIT_BE(key->sport);
+	rule = mvNfpCtLookupByTuple(key->family, key->src_l3, key->dst_l3, ports, key->proto);
+	if (!rule)
+		return MV_NOT_FOUND;
+	*hit_cntr = rule->hit_cntr;
+	return MV_OK;
+}
+
+MV_STATUS mvNfpCtRuleHitCntrSet(MV_NFP_CT_KEY *key, MV_U32 val)
+{
+	NFP_RULE_CT *rule;
+	MV_U32 ports;
+
+	if (!key || val < 0)
+		return MV_BAD_PARAM;
+	ports = (MV_16BIT_BE(key->dport) << 16) | MV_16BIT_BE(key->sport);
+	rule = mvNfpCtLookupByTuple(key->family, key->src_l3, key->dst_l3, ports, key->proto);
+	if (!rule)
+		return MV_NOT_FOUND;
+	rule->hit_cntr = val;
+	return MV_OK;
+}
+
+MV_STATUS mvNfpCtRuleInfoGet(MV_NFP_CT_KEY *key, MV_NFP_CT_INFO *ct_info)
+{
+	NFP_RULE_CT *rule;
+	NFP_IF_MAP *ifMap;
+	MV_U32 ports;
+
+	if (!key || !ct_info)
+		return MV_BAD_PARAM;
+	ports = (MV_16BIT_BE(key->dport) << 16) | MV_16BIT_BE(key->sport);
+	rule = mvNfpCtLookupByTuple(key->family, key->src_l3, key->dst_l3, ports, key->proto);
+	if (!rule)
+		return MV_NOT_FOUND;
+	ct_info->flags = rule->flags;
+	ct_info->new_sip = rule->new_sip;
+	ct_info->new_dip = rule->new_dip;
+	ct_info->new_sport = rule->new_sport;
+	ct_info->new_dport = rule->new_dport;
+	if (rule->fib) {
+		memcpy(ct_info->sa, (rule->fib)->sa, MV_MAC_ADDR_SIZE);
+		memcpy(ct_info->da, (rule->fib)->da, MV_MAC_ADDR_SIZE);
+		ifMap = mvNfpIfMapGet((rule->fib)->oif);
+		ct_info->out_port = ifMap->port;
+	}
+#ifdef NFP_CLASSIFY
+	ct_info->mh = rule->mh;
+	ct_info->txp = rule->txp;
+	/* return only global txq/dscp/vprio mapping */
+	ct_info->txq = (rule->txq_map[NFP_DSCP_MAP_GLOBAL]).txq;
+	if (!(rule->txq_map[NFP_DSCP_MAP_GLOBAL]).valid)
+		ct_info->flags = ct_info->flags & ~NFP_F_CT_SET_TXQ;
+	ct_info->dscp = (rule->dscp_map[NFP_DSCP_MAP_GLOBAL]).new_dscp;
+	if (!(rule->dscp_map[NFP_DSCP_MAP_GLOBAL]).valid)
+		ct_info->flags = ct_info->flags & ~NFP_F_CT_SET_DSCP;
+	ct_info->vprio = (rule->vpri_map[NFP_VPRI_MAP_GLOBAL]).new_prio;
+	if (!(rule->vpri_map[NFP_VPRI_MAP_GLOBAL]).valid)
+		ct_info->flags = ct_info->flags & ~NFP_F_CT_SET_VLAN_PRIO;
+#endif /* NFP_CLASSIFY */
+	return MV_OK;
+}
+
+void    mvNfpCtDump(void)
+{
+	MV_U32 i;
+	NFP_RULE_CT *ct;
+	MV_LIST_ELEMENT	*curr;
+
+	mvOsPrintf("\n(ct hash)\n");
+	for (i = 0; i < NFP_CT_HASH_SIZE; i++) {
+		ct = ct_hash[i];
+
+		while (ct) {
+			mvOsPrintf(" [%2d] ", i);
+			mvNfpCtRulePrint(ct);
+
+			ct = ct->next;
+		}
+	}
+	if (!ct_inv_list) {
+		mvOsPrintf("(ct_inv_list) does not exist\n");
+		return;
+	}
+	mvOsPrintf("(ct_inv_list)\n");
+	curr = ct_inv_list->next;
+	while (curr) {
+		ct = (NFP_RULE_CT *)curr->data;
+		mvNfpCtRulePrint(ct);
+		curr = curr->next;
+	}
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h
@@ -0,0 +1,223 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvNfpDefs.h - Header File for Marvell NFP Configuration definitions
+*
+* DESCRIPTION:
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __mvNfpDefs_h__
+#define __mvNfpDefs_h__
+
+#include "mv802_3.h"
+#include "gbe/mvNetaRegs.h"
+#include "gbe/mvNeta.h"
+
+#ifdef CONFIG_MV_ETH_NFP_MODULE
+# define CONFIG_MV_ETH_NFP
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP
+
+#define ETH_NFP
+
+#ifdef CONFIG_MV_ETH_NFP_EXT
+# define NFP_EXT
+# define NFP_EXT_NUM 	CONFIG_MV_ETH_NFP_EXT_NUM
+#else
+# define NFP_EXT_NUM 	0
+#endif
+
+#define NFP_MAX_PORTS   (MV_ETH_MAX_PORTS + NFP_EXT_NUM)
+
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN) || defined(CONFIG_MV_ETH_NFP_VLAN_LEARN) || defined(CONFIG_MV_ETH_NFP_FDB_LEARN) || \
+		defined(CONFIG_MV_ETH_NFP_PPP_LEARN) || defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+#define NFP_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_FIB
+#define NFP_FIB
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_FIB_LEARN
+#define NFP_FIB_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_VLAN
+#define NFP_VLAN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_VLAN_LEARN
+#define NFP_VLAN_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_PPP
+#define NFP_PPP
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_PPP_LEARN
+#define NFP_PPP_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_CT
+#define NFP_CT
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_CT_LEARN
+#define NFP_CT_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_NAT
+#define NFP_NAT
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_LIMIT
+#define NFP_LIMIT
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_CLASSIFY
+#define NFP_CLASSIFY
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_STATS
+#define NFP_STAT
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_BRIDGE
+#define NFP_BRIDGE
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_FDB_MODE
+#define NFP_FDB_MODE
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_FDB_LEARN
+#define NFP_FDB_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_SWITCH
+# define NFP_MAX_SWITCH_GROUPS  CONFIG_MV_ETH_SWITCH_NETDEV_NUM
+#else
+# define NFP_MAX_SWITCH_GROUPS  1
+#endif /* CONFIG_MV_ETH_SWITCH */
+
+typedef struct {
+	MV_U16 flags;
+
+	MV_U8  txp;
+	MV_U8  txq;
+
+	MV_U8 pkt_ecn;
+	MV_U8 pkt_dscp;
+	int   ct_dscp;
+
+	int pkt_vlan_prio;
+	int bridge_vlan_prio;
+	int ct_vlan_prio;
+
+	MV_U16 mh;
+
+	int iif_prio;
+	int iif_vlan_prio;
+	int iif_dscp_prio;
+
+	int prio_dscp;
+	int prio_vprio;
+	MV_U8 prio_txp;
+	MV_U8 prio_txq;
+	MV_U16 prio_mh;
+
+} NFP_CLASSIFY_INFO;
+
+typedef struct {
+	void   *dev;
+	MV_U32 tx_cmd;
+	MV_U32 diffL4[2];
+	MV_U8  *pWrite;
+	MV_U16 flags;
+	MV_U16 mtu;
+	short  shift;
+	MV_U8  txp;
+	MV_U8  txq;
+	MV_IP_HEADER_INFO ipInfo;
+	void   *privateData;
+} MV_NFP_RESULT;
+
+#define MV_NFP_RES_TXP_VALID       0x0001
+#define MV_NFP_RES_TXQ_VALID       0x0002
+#define MV_NFP_RES_IP_INFO_VALID   0x0004
+#define MV_NFP_RES_NETDEV_EXT      0x0010
+#define MV_NFP_RES_L4_CSUM_NEEDED  0x0020
+
+MV_STATUS mvNfpIfMapPortGet(int ifIdx, int *port);
+MV_STATUS mvNfpRx(MV_U32 inPort, NETA_RX_DESC *pRxDesc, MV_ETH_PKT *pPkt, MV_NFP_RESULT* pRes);
+
+#endif /* CONFIG_MV_ETH_NFP */
+
+#endif /* __mvNfp_h__ */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFdb.c
@@ -0,0 +1,309 @@
+/*******************************************************************************
+Copyright (C) Marvell Interfdbional Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+Interfdbional Ltd. and/or its affiliates ("Marvell") under the following
+alterfdbive licensing terms.  Once you have made an election to distribute the
+File under one of the following license alterfdbives, please (i) delete this
+introductory statement regarding license alterfdbives, (ii) delete the two
+license alterfdbives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvNfpFdb.c - Marvell Fast Network Processing
+*
+* DESCRIPTION:
+*
+*       Supported Features:
+*       - OS independent.
+*
+*******************************************************************************/
+
+#include "mvOs.h"
+#include "mvDebug.h"
+#include "mvList.h"
+#include "gbe/mvNeta.h"
+#include "mvNfpDefs.h"
+#include "mvNfp.h"
+
+NFP_RULE_FDB **nfp_fdb_hash = NULL;
+
+MV_STATUS _INIT mvNfpFdbInit(void)
+{
+	MV_U32 bytes = sizeof(NFP_RULE_FDB *) * NFP_BRIDGE_HASH_SIZE;
+
+	nfp_fdb_hash = (NFP_RULE_FDB **)mvOsMalloc(bytes);
+	if (nfp_fdb_hash == NULL) {
+		mvOsPrintf("NFP (FDB hash): not enough memory\n");
+		return MV_NO_RESOURCE;
+	}
+	mvOsMemset(nfp_fdb_hash, 0, bytes);
+
+	mvOsPrintf("NFP (FDB) init %d entries, %d bytes\n", NFP_BRIDGE_HASH_SIZE, bytes);
+
+	return MV_OK;
+}
+
+/* Clear FDB Rule Database */
+MV_STATUS mvNfpFdbClear(void)
+{
+	int	i;
+	NFP_RULE_FDB	*rule, *tmp;
+
+	if (nfp_fdb_hash == NULL)
+		return MV_NOT_INITIALIZED;
+
+	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
+
+		rule = nfp_fdb_hash[i];
+		while (rule) {
+			tmp = rule;
+			rule = rule->next;
+			mvOsFree(tmp);
+		}
+		nfp_fdb_hash[i] = NULL;
+	}
+	return MV_OK;
+}
+
+void mvNfpFdbDestroy(void)
+{
+	if (nfp_fdb_hash != NULL)
+		mvOsFree(nfp_fdb_hash);
+}
+
+MV_STATUS mvNfpFdbRuleAdd(NFP_RULE_FDB *rule2)
+{
+	MV_U32 hash;
+	NFP_RULE_FDB	*rule;
+	NFP_RULE_FIB	*fib;
+	NFP_IF_MAP      *outIfMap;
+	MV_LIST_ELEMENT	*curr, *tmp;
+
+	hash = mvNfpFdbRuleHash(rule2->bridgeIf, rule2->mac);
+
+	rule = nfp_fdb_hash[hash];
+	while (rule) {
+		if (mvNfpFdbRuleCmp(rule2->bridgeIf, rule2->mac, rule)) {
+			MV_U32 age = rule->age;
+
+			/* Update rule, but save age */
+			mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_FDB));
+			rule->age = age;
+			goto out;
+		}
+		rule = rule->next;
+	}
+
+	rule = (NFP_RULE_FDB *)mvOsMalloc(sizeof(NFP_RULE_FDB));
+	if (rule == NULL) {
+		mvOsPrintf("%s: NFP (FDB rule) - OOM\n", __func__);
+		return MV_FAIL;
+	}
+
+	mvOsMemcpy(rule, rule2, sizeof(NFP_RULE_FDB));
+
+	rule->next = nfp_fdb_hash[hash];
+	nfp_fdb_hash[hash] = rule;
+
+	outIfMap = mvNfpIfMapGet(rule->if_index);
+
+	/* Update incomplete FIB entires */
+	curr = fib_inv_list->next;
+	while (curr) {
+		fib = (NFP_RULE_FIB *)curr->data;
+		tmp = curr->next;
+		if ((rule->bridgeIf == fib->oif) &&
+			(!memcmp(rule->mac, fib->da, MV_MAC_ADDR_SIZE))) {
+
+			/* Found incomplete FIB entry */
+			fib->oif = outIfMap->ifIdx;
+			fib->mh = outIfMap->txMh;
+			fib->flags &= ~NFP_F_FIB_BRIDGE_INV;
+
+			mvNfpFibRuleValid(fib, curr);
+		}
+		curr = tmp;
+	}
+out:
+	NFP_DBG("NFP (FDB) add %p\n", rule);
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpFdbRuleDel(NFP_RULE_FDB *rule2)
+{
+	MV_U32 hash;
+	NFP_RULE_FDB	*rule, *prev;
+	NFP_RULE_FIB	*fib, *fib_prev;
+	int i;
+
+	hash = mvNfpFdbRuleHash(rule2->bridgeIf, rule2->mac);
+
+	rule = nfp_fdb_hash[hash];
+	prev = NULL;
+
+	while (rule) {
+		if (mvNfpFdbRuleCmp(rule2->bridgeIf, rule2->mac, rule)) {
+			/* Found: delete rule */
+			if (prev)
+				prev->next = rule->next;
+			else
+				nfp_fdb_hash[hash] = rule->next;
+
+			NFP_DBG("NFP (FDB) del %p\n", rule);
+			rule2->if_index = rule->if_index;
+			mvOsFree(rule);
+			break;
+		}
+		prev = rule;
+		rule = rule->next;
+	}
+	if (rule == NULL)
+		return MV_NOT_FOUND;
+
+	/* Invalidate relevant FIB rules */
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+		fib_prev = NULL;
+		while (fib) {
+			if ((rule2->if_index == fib->oif) &&
+				(!memcmp(rule2->mac, fib->da, MV_MAC_ADDR_SIZE))) {
+				/* Invalidate FIB route. FIXME - update HWF rule */
+				fib->flags |= NFP_F_FIB_BRIDGE_INV;
+				fib->oif = rule2->bridgeIf;
+
+				/* Remove FIB rule from hash table */
+				if (fib_prev)
+					fib_prev->next = fib->next;
+				else
+					fib_hash[i] = fib->next;
+
+				/* Add FIB rule to incomplete list */
+				mvListAddHead(fib_inv_list, (MV_ULONG)fib);
+#ifdef NFP_CT
+				/* Invalidate relevant CT rules */
+				mvNfpCtRuleFibInvalidate(fib);
+#endif /* NFP_CT */
+			}
+			fib_prev = fib;
+			fib = fib->next;
+		}
+	}
+
+	return MV_OK;
+}
+
+MV_STATUS mvNfpFdbRuleAge(NFP_RULE_FDB *rule2)
+{
+	NFP_RULE_FDB *rule;
+
+	rule = mvNfpFdbLookup(rule2->bridgeIf, rule2->mac);
+	if (rule) {
+		rule2->age = rule->age;
+		rule->age = 0;
+		return MV_OK;
+	}
+	rule2->age = 0;
+	return MV_NOT_FOUND;
+}
+
+static void mvNfpFdbRulePrint(NFP_RULE_FDB *rule)
+{
+	if (rule->status == NFP_BRIDGE_INV)
+		mvOsPrintf("INVALID  : ");
+	else if (rule->status == NFP_BRIDGE_LOCAL)
+		mvOsPrintf("LOCAL    : ");
+	else
+		mvOsPrintf("NON_LOCAL: ");
+
+	mvOsPrintf(" bridgeIf=%d, if_index=%u, MAC=" MV_MACQUAD_FMT " age=%u\n",
+		rule->bridgeIf, rule->if_index, MV_MACQUAD(rule->mac), rule->age);
+}
+
+void mvNfpFdbDump(void)
+{
+	int             i;
+	NFP_RULE_FDB *rule;
+
+	mvOsPrintf("\n(fdb)\n");
+	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
+		rule = nfp_fdb_hash[i];
+
+		while (rule) {
+			mvOsPrintf(" [%5d] ", i);
+			mvNfpFdbRulePrint(rule);
+			rule = rule->next;
+		}
+	}
+}
+
+void mvNfpFdbFlushBridge(int ifindex)
+{
+	int i;
+
+	NFP_RULE_FDB *rule;
+
+	for (i = 0; i < NFP_BRIDGE_HASH_SIZE; i++) {
+		rule = nfp_fdb_hash[i];
+
+		while (rule) {
+			if ((rule->if_index == ifindex) || (ifindex == -1))
+				mvNfpFdbRuleDel(rule);
+			rule = rule->next;
+		}
+	}
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpFib.c
@@ -0,0 +1,718 @@
+/*******************************************************************************
+Copyright (C) Marvell Interfdbional Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+Interfdbional Ltd. and/or its affiliates ("Marvell") under the following
+alterfdbive licensing terms.  Once you have made an election to distribute the
+File under one of the following license alterfdbives, please (i) delete this
+introductory statement regarding license alterfdbives, (ii) delete the two
+license alterfdbives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvNfpFib.c - Marvell Fast Network Processing
+*
+* DESCRIPTION:
+*
+*       Supported Features:
+*       - OS independent.
+*
+*******************************************************************************/
+
+#include "mvOs.h"
+#include "mvDebug.h"
+#include "mvList.h"
+#include "gbe/mvNeta.h"
+#include "mvNfpDefs.h"
+#include "mvNfp.h"
+
+MV_LIST_ELEMENT *fib_inv_list = NULL;
+NFP_RULE_FIB **fib_hash = NULL;
+NFP_RULE_ARP **nfp_arp_hash = NULL;
+
+MV_STATUS _INIT mvNfpFibInit(void)
+{
+	MV_U32 bytes = sizeof(NFP_RULE_FIB *) * NFP_FIB_HASH_SIZE;
+
+	fib_hash = (NFP_RULE_FIB **)mvOsMalloc(bytes);
+	if (fib_hash == NULL) {
+		mvOsPrintf("NFP (fib): not enough memory\n");
+		return MV_NO_RESOURCE;
+	}
+	mvOsMemset(fib_hash, 0, bytes);
+
+	fib_inv_list = mvListCreate();
+	if (fib_inv_list == NULL) {
+		mvOsPrintf("NFP (fib): not enough memory\n");
+		mvOsFree(fib_hash);
+		return MV_NO_RESOURCE;
+	}
+
+	mvOsPrintf("NFP (fib) init %d entries, %d bytes\n", NFP_FIB_HASH_SIZE, bytes);
+
+	return MV_OK;
+}
+
+/* Move FIB rule from fib_inv_list to fib_hash */
+MV_STATUS mvNfpFibRuleValid(NFP_RULE_FIB *fib, MV_LIST_ELEMENT *curr)
+{
+	MV_U32	hash;
+
+	if (!(fib->flags & (NFP_F_FIB_ARP_INV | NFP_F_FIB_BRIDGE_INV))) {
+		/* FIB rule became ready */
+
+		/* Delete FIB rule from incomplete list */
+		mvListDel(curr);
+
+		/* Add fib to hash table */
+		hash = mvNfpFibRuleHash(fib->family, fib->srcL3, fib->dstL3);
+		fib->next = fib_hash[hash];
+		fib_hash[hash] = fib;
+
+#ifdef NFP_CT
+		/* Update incomplete CT entires */
+		mvNfpCtRuleFibUpdate(fib);
+#endif /* NFP_CT */
+
+		return MV_OK;
+	}
+	return MV_BAD_PARAM;
+}
+
+static void mvNfpFibRulePrint(NFP_RULE_FIB *fib)
+{
+	if (fib->family == MV_INET)
+		mvOsPrintf("IPv4: " MV_IPQUAD_FMT "->" MV_IPQUAD_FMT"\n",
+			   MV_IPQUAD(fib->srcL3), MV_IPQUAD(fib->dstL3));
+	else
+		mvOsPrintf("IPv6: " MV_IP6_FMT "->" MV_IP6_FMT"\n",
+					MV_IP6_ARG(fib->srcL3), MV_IP6_ARG(fib->dstL3));
+
+	mvOsPrintf("     mh=%2.2x:%2.2x, da=" MV_MACQUAD_FMT ", sa=" MV_MACQUAD_FMT,
+				((MV_U8 *) &fib->mh)[0], ((MV_U8 *) &fib->mh)[1], MV_MACQUAD(fib->da), MV_MACQUAD(fib->sa));
+#ifdef NFP_CT
+	mvOsPrintf("\n     fib=%p, oif=%d, ref=%d, age=%d, ct_ref_count=%d, ct_hwf_ref_count=%d\n",
+				fib, fib->oif, fib->ref, fib->age, fib->ct_ref_count, fib->ct_hwf_ref_count);
+#else
+	mvOsPrintf("\n     fib=%p, oif=%d, ref=%d, age=%d\n",
+				fib, fib->oif, fib->ref, fib->age);
+#endif /* NFP_CT */
+
+	if (fib->flags & NFP_F_FIB_ALL_FLAGS)
+		mvOsPrintf("     Flags: ");
+	if (fib->flags & NFP_F_FIB_HWF)
+		mvOsPrintf("NFP_F_FIB_HWF ");
+	if (fib->flags & NFP_F_FIB_BRIDGE_INV)
+		mvOsPrintf("NFP_F_FIB_BRIDGE_INV ");
+	if (fib->flags & NFP_F_FIB_ARP_INV)
+		mvOsPrintf("NFP_F_FIB_ARP_INV ");
+
+	mvOsPrintf("\n");
+}
+
+MV_STATUS mvNfpArpRuleAdd(NFP_RULE_ARP *arp2)
+{
+	MV_U32          hash;
+	NFP_RULE_FIB    *fib;
+	NFP_RULE_ARP    *arp;
+	MV_LIST_ELEMENT	*curr, *tmp;
+
+	if (!nfp_arp_hash || !fib_hash || !fib_inv_list)
+		return MV_FAIL;
+
+	/* Check if such rule already exist - update it */
+	arp = mvNfpArpLookup(arp2->family, arp2->nextHopL3);
+	if (arp) {
+		/* Rule exists - update it and the relevant FIB entries */
+		mvOsMemcpy(arp, arp2, sizeof(NFP_RULE_ARP));
+		mvNfpArpRuleUpdateFibEntries(arp);
+	} else { /* Add new rule to ARP hash table */
+		arp = (NFP_RULE_ARP *)mvOsMalloc(sizeof(NFP_RULE_ARP));
+		if (!arp) {
+			mvOsPrintf("%s: NFP (arp) OOM\n", __func__);
+			return MV_FAIL;
+		}
+		mvOsMemcpy(arp, arp2, sizeof(NFP_RULE_ARP));
+		hash = mvNfpArpRuleHash(arp2->family, arp2->nextHopL3);
+		arp->next = nfp_arp_hash[hash];
+		nfp_arp_hash[hash] = arp;
+	}
+
+	/* Update incomplete FIB entires */
+	curr = fib_inv_list->next;
+	while (curr) {
+		fib = (NFP_RULE_FIB *)curr->data;
+		tmp = curr->next;
+		if ((arp2->family == fib->family) &&
+			(l3_addr_eq(arp2->family, arp2->nextHopL3, fib->defGtwL3))) {
+
+			/* Found incomplete FIB entry - copy DA from arp2 */
+			mvOsMemcpy((MV_U8 *)&fib->da, (MV_U8 *)&arp2->da, MV_MAC_ADDR_SIZE);
+			fib->flags &= ~NFP_F_FIB_ARP_INV;
+
+#ifdef NFP_BRIDGE
+			if (fib->flags & NFP_F_FIB_BRIDGE_INV) {
+				NFP_IF_MAP      *outIfMap;
+#ifdef NFP_FDB_MODE
+				NFP_RULE_FDB *fdb;
+
+				/* Check FDB hash */
+				fdb = mvNfpFdbLookup(fib->oif, fib->da);
+				if (fdb) {
+					outIfMap = mvNfpIfMapGet(fdb->if_index);
+#else
+				NFP_RULE_BRIDGE *bridge;
+
+				/* Check BRIDGE hash */
+				bridge = mvNfpBridgeLookup(fib->da, fib->sa, fib->oif);
+				if (bridge) {
+					outIfMap = mvNfpIfMapGet(bridge->oif);
+#endif /* NFP_FDB_MODE */
+					fib->oif = outIfMap->ifIdx;
+					fib->mh = outIfMap->txMh;
+					fib->flags &= ~NFP_F_FIB_BRIDGE_INV;
+				} else {
+					NFP_WARN("%s: bridgeLookup failed, oif=%d, da="MV_MACQUAD_FMT"\n",
+						__func__, fib->oif, MV_MACQUAD(fib->da));
+				}
+			}
+#endif /* NFP_BRIDGE */
+
+			mvNfpFibRuleValid(fib, curr);
+		}
+		curr = tmp;
+	}
+	return MV_OK;
+}
+
+/* Update all routes with rule2->defGtwL3 */
+MV_STATUS mvNfpArpRuleUpdateFibEntries(NFP_RULE_ARP *arp)
+{
+	int		i;
+	NFP_RULE_FIB	*fib;
+
+	if (!fib_hash)
+		return MV_FAIL;
+
+	/* Update relevant FIB rules */
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+		while (fib) {
+			if ((arp->family == fib->family) &&
+				(l3_addr_eq(arp->family, arp->nextHopL3, fib->defGtwL3)))
+				mvOsMemcpy((MV_U8 *)&fib->da, (MV_U8 *)&arp->da, MV_MAC_ADDR_SIZE);
+			fib = fib->next;
+		}
+	}
+	return MV_OK;
+}
+
+/* Delete ARP Rule and invalidate all routes with rule2->defGtwL3 */
+MV_STATUS mvNfpArpRuleDel(NFP_RULE_ARP *arp2)
+{
+	int				i;
+	MV_U32          hash;
+	NFP_RULE_ARP	*arp, *arp_prev;
+	NFP_RULE_FIB	*fib, *fib_prev;
+
+	if (!nfp_arp_hash || !fib_hash)
+		return MV_FAIL;
+
+	/* Find rule in ARP hash table and delete it */
+	hash = mvNfpArpRuleHash(arp2->family, arp2->nextHopL3);
+
+	arp = nfp_arp_hash[hash];
+	arp_prev = NULL;
+
+	while (arp) {
+		if (mvNfpArpRuleCmp(arp2->family, arp2->nextHopL3, arp)) {
+			/* Found: delete ARP rule */
+			if (arp_prev)
+				arp_prev->next = arp->next;
+			else
+				nfp_arp_hash[hash] = arp->next;
+
+			NFP_DBG("NFP (arp) del %p\n", arp);
+			mvOsFree(arp);
+			break;
+		}
+		arp_prev = arp;
+		arp = arp->next;
+	}
+	if (arp == NULL)
+		return MV_NOT_FOUND;
+
+	/* Invalidate relevant FIB rules */
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+		fib_prev = NULL;
+		while (fib) {
+			if ((arp2->family == fib->family) &&
+				(l3_addr_eq(arp2->family, arp2->nextHopL3, fib->defGtwL3))) {
+
+				/* Invalidate FIB route. FIXME - update HWF rule */
+				fib->flags |= NFP_F_FIB_ARP_INV;
+
+				/* Remove FIB rule from hash table */
+				if (fib_prev)
+					fib_prev->next = fib->next;
+				else
+					fib_hash[i] = fib->next;
+
+				/* Add FIB rule to incomplete list */
+				mvListAddHead(fib_inv_list, (MV_ULONG)fib);
+#ifdef NFP_CT
+				/* Invalidate relevant CT rules */
+				mvNfpCtRuleFibInvalidate(fib);
+#endif /* NFP_CT */
+			}
+			fib_prev = fib;
+			fib = fib->next;
+		}
+	}
+	return MV_OK;
+}
+
+/* If exist routing entires with the rule2->defGtwL3 - prevent aging */
+MV_STATUS mvNfpArpRuleAge(NFP_RULE_ARP *arp2)
+{
+	int		i;
+	NFP_RULE_FIB	*fib;
+
+	arp2->age = 0;
+	if (!nfp_arp_hash || !fib_hash)
+		return MV_FAIL;
+
+	/* FIXME: Find rule in ARP hash table */
+
+	/* prevent ARP aging if there are at least one valid FIB rule use it */
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+		while (fib) {
+			if ((arp2->family == fib->family) &&
+				(l3_addr_eq(arp2->family, arp2->nextHopL3, fib->defGtwL3))) {
+
+				/* Prevent neigbour aging */
+				arp2->age = 1;
+				return MV_OK;
+			}
+			fib = fib->next;
+		}
+	}
+	return MV_NOT_FOUND;
+}
+
+static NFP_RULE_FIB *mvNfpFibRuleInvalidLookup(int family, const MV_U8 *srcL3, const MV_U8 *dstL3)
+{
+	MV_LIST_ELEMENT	*curr;
+	NFP_RULE_FIB *currRule;
+
+	if (!fib_inv_list)
+		return NULL;
+
+	curr = fib_inv_list->next;
+	while (curr) {
+		currRule = (NFP_RULE_FIB *)curr->data;
+		if (mvNfpFibRuleCmp(family, srcL3, dstL3, currRule))
+			return currRule;
+
+		curr = curr->next;
+	}
+	return NULL;
+}
+
+/* prevent FIB aging if there are 5 tuple rules based on this FIB rule */
+MV_STATUS mvNfpFibRuleAge(NFP_RULE_FIB *fib2)
+{
+	NFP_RULE_FIB *fib;
+
+	fib = mvNfpFibRuleInvalidLookup(fib2->family, fib2->srcL3, fib2->dstL3);
+	if (fib) {
+#ifdef NFP_CT
+		fib2->age = (fib->ct_hwf_ref_count > 0) ? 1 : fib->age;
+		fib->age = (fib->ct_hwf_ref_count > 0) ? fib->age : 0;
+#else
+		fib2->age = fib->age;
+		fib->age = 0;
+#endif /* NFP_CT */
+		return MV_OK;
+	}
+
+	fib = mvNfpFibLookup(fib2->family, fib2->srcL3, fib2->dstL3);
+	if (fib) {
+#ifdef NFP_CT
+			fib2->age = (fib->ct_hwf_ref_count > 0) ? 1 : fib->age;
+			fib->age = (fib->ct_hwf_ref_count > 0) ? fib->age : 0;
+#else
+			fib2->age = fib->age;
+			fib->age = 0;
+#endif /* NFP_CT */
+		return MV_OK;
+	}
+
+	fib2->age = 0;
+	return MV_NOT_FOUND;
+}
+
+MV_STATUS mvNfpFibRuleAdd(NFP_RULE_FIB *fib2)
+{
+	MV_U32 hash, ref = 0;
+	NFP_RULE_FIB *fib;
+	MV_LIST_ELEMENT	*element;
+	NFP_IF_MAP      *outIfMap;
+
+	/* sanity checks */
+	if (!fib_hash || !fib_inv_list)
+		return MV_FAIL;
+
+	/* If this rule currently exists in the Invalid Rules DB, delete it */
+	fib = mvNfpFibRuleInvalidLookup(fib2->family, fib2->srcL3, fib2->dstL3);
+	if (fib) {
+		element = mvListFind(fib_inv_list, (MV_ULONG)fib);
+		mvListDel(element);
+	}
+	/* If this rule currently exists as a valid rule, we want to update it */
+	/* so we save the reference count, but delete and re-add it */
+	fib = mvNfpFibLookup(fib2->family, fib2->srcL3, fib2->dstL3);
+	if (fib) {
+		ref = fib->ref;
+		mvNfpFibRuleDel(fib);
+	}
+
+	outIfMap = mvNfpIfMapGet(fib2->oif);
+	memcpy(fib2->sa, outIfMap->mac, MV_MAC_ADDR_SIZE);
+	fib2->mh = outIfMap->txMh;
+
+	if (fib2->flags & NFP_F_FIB_ARP_INV) {
+#ifdef NFP_PPP
+		if (outIfMap->flags & NFP_F_MAP_PPPOE) {
+			mvOsMemcpy(fib2->da, outIfMap->remoteMac, MV_MAC_ADDR_SIZE);
+			fib2->flags &= ~NFP_F_FIB_ARP_INV;
+		} else {
+#endif /* NFP_PPP */
+			NFP_RULE_ARP  *arp;
+			if (fib2->family == MV_INET) {
+				NFP_DBG("%s: ArpLookup, defGtwL3="MV_IPQUAD_FMT"\n",
+							__func__, MV_IPQUAD(fib2->defGtwL3));
+			} else {
+				NFP_DBG("%s: ArpLookup, defGtwL3="MV_IP6_FMT"\n",
+							__func__, MV_IP6_ARG(fib2->defGtwL3));
+			}
+
+			/* lookup for ARP entry */
+			arp = mvNfpArpLookup(fib2->family, fib2->defGtwL3);
+			if (arp) {
+				mvOsMemcpy(fib2->da, arp->da, MV_MAC_ADDR_SIZE);
+				fib2->flags &= ~NFP_F_FIB_ARP_INV;
+			} else {
+				if (fib2->family == MV_INET) {
+					NFP_WARN("%s: ArpLookup failed, defGtwL3="MV_IPQUAD_FMT"\n",
+								__func__, MV_IPQUAD(fib2->defGtwL3));
+				} else {
+					NFP_WARN("%s: ArpLookup failed, defGtwL3="MV_IP6_FMT"\n",
+								__func__, MV_IP6_ARG(fib2->defGtwL3));
+				}
+			}
+#ifdef NFP_PPP
+		}
+#endif /* NFP_PPP */
+	}
+#ifdef NFP_BRIDGE
+	/* ARP (da) is known, bridge (oif) is unknown */
+	if ((fib2->flags & (NFP_F_FIB_BRIDGE_INV | NFP_F_FIB_ARP_INV)) == NFP_F_FIB_BRIDGE_INV) {
+
+#ifdef NFP_FDB_MODE
+		NFP_RULE_FDB  *fdb;
+
+		/* lookup for FDB entry */
+		fdb = mvNfpFdbLookup(fib2->oif, fib2->da);
+		if (fdb) {
+			outIfMap = mvNfpIfMapGet(fdb->if_index);
+#else
+		NFP_RULE_BRIDGE  *bridge;
+
+		/* lookup for Bridging entry */
+		bridge = mvNfpBridgeLookup(fib2->da, fib2->sa, fib2->oif);
+		if (bridge) {
+			outIfMap = mvNfpIfMapGet(bridge->oif);
+#endif /* NFP_FDB_MODE */
+			fib2->oif = outIfMap->ifIdx;
+			fib2->mh = outIfMap->txMh;
+			fib2->flags &= ~NFP_F_FIB_BRIDGE_INV;
+		} else {
+			NFP_WARN("%s: mvNfpFdbLookup failed, oif=%d, mac="MV_MACQUAD_FMT"\n",
+					__func__, fib2->oif, MV_MACQUAD(fib2->da));
+		}
+	}
+#endif /* NFP_BRIDGE */
+
+	if (fib2->flags & (NFP_F_FIB_BRIDGE_INV | NFP_F_FIB_ARP_INV)) {
+		/* Put FIB entry to incomplete list */
+		fib = (NFP_RULE_FIB *)mvOsMalloc(sizeof(NFP_RULE_FIB));
+		if (!fib) {
+			mvOsPrintf("%s: NFP (fib) OOM\n", __func__);
+			return MV_FAIL;
+		}
+		mvOsMemcpy(fib, fib2, sizeof(NFP_RULE_FIB));
+		mvListAddHead(fib_inv_list, (MV_ULONG)fib);
+		return MV_OK;
+	}
+
+	/* FIB Entry is valid - add it to hash */
+	hash = mvNfpFibRuleHash(fib2->family, fib2->srcL3, fib2->dstL3);
+
+	fib = (NFP_RULE_FIB *)mvOsMalloc(sizeof(NFP_RULE_FIB));
+	if (!fib) {
+		mvOsPrintf("%s: NFP (fib) OOM\n", __func__);
+		return MV_FAIL;
+	}
+	mvOsMemcpy(fib, fib2, sizeof(NFP_RULE_FIB));
+	fib->ref = ref;
+
+	fib->next = fib_hash[hash];
+	fib_hash[hash] = fib;
+
+#ifdef NFP_CT
+	/* Update incomplete CT entires */
+	mvNfpCtRuleFibUpdate(fib);
+#endif /* NFP_CT */
+
+	NFP_DBG("NFP (fib) add %p\n", fib);
+	return MV_OK;
+}
+
+MV_STATUS mvNfpFibRuleDel(NFP_RULE_FIB *fib2)
+{
+	MV_U32 hash;
+	NFP_RULE_FIB *fib, *prev;
+	MV_LIST_ELEMENT	*element;
+
+	/* If this rule currently exists in the Invalid Rules DB, delete it */
+	fib = mvNfpFibRuleInvalidLookup(fib2->family, fib2->srcL3, fib2->dstL3);
+	if (fib) {
+		element = mvListFind(fib_inv_list, (MV_ULONG)fib);
+		mvListDel(element);
+		mvOsFree(fib);
+		return MV_OK;
+	}
+
+	hash = mvNfpFibRuleHash(fib2->family, fib2->srcL3, fib2->dstL3);
+	fib = fib_hash[hash];
+
+	prev = NULL;
+	while (fib) {
+		if (mvNfpFibRuleCmp(fib2->family, fib2->srcL3, fib2->dstL3, fib)) {
+			if (prev)
+				prev->next = fib->next;
+			else
+				fib_hash[hash] = fib->next;
+
+			NFP_DBG("NFP (fib) del %p\n", fib);
+			mvOsFree(fib);
+#ifdef NFP_CT
+			/* Invalidate relevant CT rules */
+			mvNfpCtRuleFibInvalidate(fib2);
+#endif /* NFP_CT */
+			return MV_OK;
+		}
+		prev = fib;
+		fib = fib->next;
+	}
+	return MV_NOT_FOUND;
+}
+
+void mvNfpFibClean(void)
+{
+	int i;
+	NFP_RULE_FIB *fib, *next;
+	MV_LIST_ELEMENT	*curr, *tmp;
+
+	/* Clean FIB incomplete rules list */
+	if (fib_inv_list) {
+		curr = fib_inv_list->next;
+		while (curr) {
+			tmp = curr->next;
+			mvListDel(curr);
+			curr = tmp;
+		}
+	}
+
+	/* Clean FIB hash table */
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+		while (fib) {
+			next = fib->next;
+			mvOsFree(fib);
+			fib = next;
+		}
+		fib_hash[i] = NULL;
+	}
+}
+
+void mvNfpFibDestroy(void)
+{
+	if (fib_hash != NULL)
+		mvOsFree(fib_hash);
+
+	mvListDestroy(fib_inv_list);
+}
+
+void mvNfpFibDump(void)
+{
+	MV_U32 i;
+	NFP_RULE_FIB *fib;
+	MV_LIST_ELEMENT	*curr;
+
+	mvOsPrintf("\n(fib_hash)\n");
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+
+		while (fib) {
+			mvOsPrintf(" [%5d] ", i);
+			mvNfpFibRulePrint(fib);
+			fib = fib->next;
+		}
+	}
+	if (!fib_inv_list) {
+		mvOsPrintf("(fib_inv_list) does not exist\n");
+		return;
+	}
+	mvOsPrintf("(fib_inv_list)\n");
+	curr = fib_inv_list->next;
+	while (curr) {
+		fib = (NFP_RULE_FIB *)curr->data;
+		mvNfpFibRulePrint(fib);
+		curr = curr->next;
+	}
+}
+
+
+static void mvNfpArpRulePrint(NFP_RULE_ARP *arp)
+{
+	if (arp->family == MV_INET)
+		mvOsPrintf("IPv4: nextHop=" MV_IPQUAD_FMT, MV_IPQUAD(arp->nextHopL3));
+	else
+		mvOsPrintf("IPv6: nextHop=" MV_IP6_FMT, MV_IP6_ARG(arp->nextHopL3));
+
+	mvOsPrintf(" da=" MV_MACQUAD_FMT " age=%u\n",
+				MV_MACQUAD(arp->da), (mvNfpArpRuleAge(arp) == MV_OK) ? 1 : 0);
+}
+
+MV_STATUS _INIT mvNfpArpInit(void)
+{
+	MV_U32 bytes = sizeof(NFP_RULE_ARP *) * NFP_ARP_HASH_SIZE;
+
+	nfp_arp_hash = (NFP_RULE_ARP **)mvOsMalloc(bytes);
+	if (nfp_arp_hash == NULL) {
+		mvOsPrintf("NFP (arp): not enough memory\n");
+		return MV_NO_RESOURCE;
+	}
+
+	mvOsMemset(nfp_arp_hash, 0, bytes);
+
+	mvOsPrintf("NFP (arp) init %d entries, %d bytes\n", NFP_ARP_HASH_SIZE, bytes);
+
+	return MV_OK;
+}
+
+void mvNfpArpDestroy(void)
+{
+	if (nfp_arp_hash != NULL)
+		mvOsFree(nfp_arp_hash);
+}
+
+void mvNfpArpDump(void)
+{
+	MV_U32 i;
+	NFP_RULE_ARP *arp;
+
+	mvOsPrintf("\n(arp)\n");
+	for (i = 0; i < NFP_ARP_HASH_SIZE; i++) {
+		arp = nfp_arp_hash[i];
+
+		while (arp) {
+			mvOsPrintf(" [%5d] ", i);
+			mvNfpArpRulePrint(arp);
+			arp = arp->next;
+		}
+	}
+}
+
+void mvNfpFlushFib(int ifindex)
+{
+	NFP_RULE_FIB *fib;
+	MV_LIST_ELEMENT	*curr;
+	int i;
+	for (i = 0; i < NFP_FIB_HASH_SIZE; i++) {
+		fib = fib_hash[i];
+
+		while (fib) {
+			if (fib->oif == ifindex)
+				mvNfpFibRuleDel(fib);
+
+			fib = fib->next;
+		}
+	}
+	if (fib_inv_list) {
+		curr = fib_inv_list->next;
+		while (curr) {
+			fib = (NFP_RULE_FIB *)curr->data;
+			if (fib->oif == ifindex)
+				mvNfpFibRuleDel(fib);
+			curr = curr->next;
+		}
+	}
+}
--- a/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncRxq.c
+++ /dev/null
@@ -1,412 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell Commercial License Option
-
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*******************************************************************************/
-
-#include "mvOs.h"
-#include "mvCommon.h"
-#include "mv802_3.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
-
-#include "gbe/mvNetaRegs.h"
-#include "gbe/mvEthRegs.h"
-
-#include "mvPnc.h"
-#include "mvTcam.h"
-
-#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
-int first_2tuple_rule = TE_FLOW_L3_END + 1;
-int last_5tuple_rule = TE_FLOW_L3 - 1;
-
-extern int pnc_port_mask_check(unsigned int mask, int eth_port);
-
-static INLINE struct tcam_entry *pnc_create_2t_entry(unsigned int sip, unsigned int dip)
-{
-	struct tcam_entry *te = tcam_sw_alloc(TCAM_LU_FLOW_IP4);
-
-	tcam_sw_set_byte(te, 12, (sip >> 0) & 0xFF);
-	tcam_sw_set_byte(te, 13, (sip >> 8) & 0xFF);
-	tcam_sw_set_byte(te, 14, (sip >> 16) & 0xFF);
-	tcam_sw_set_byte(te, 15, (sip >> 24) & 0xFF);
-
-	tcam_sw_set_byte(te, 16, (dip >> 0) & 0xFF);
-	tcam_sw_set_byte(te, 17, (dip >> 8) & 0xFF);
-	tcam_sw_set_byte(te, 18, (dip >> 16) & 0xFF);
-	tcam_sw_set_byte(te, 19, (dip >> 24) & 0xFF);
-
-	return te;
-}
-
-static INLINE int tcam_sw_cmp_2tuple(struct tcam_entry *te, unsigned int sip, unsigned int dip)
-{
-	return !((tcam_sw_cmp_bytes(te, 12, 4, (unsigned char *)&sip) == 0)
-			&& (tcam_sw_cmp_bytes(te, 16, 4, (unsigned char *)&dip) == 0));
-}
-
-static INLINE int tcam_sw_cmp_5tuple(struct tcam_entry *te, unsigned int sip, unsigned int dip,
-								unsigned int ports, unsigned int proto)
-{
-	if (tcam_sw_cmp_2tuple(te, sip, dip) != 0)
-		return 1;
-
-	return !((tcam_sw_cmp_bytes(te, 9, 1, (unsigned char *)&proto) == 0) &&
-			(tcam_sw_cmp_bytes(te, 20, 2, (unsigned char *)&ports) == 0));
-}
-#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
-
-static INLINE int pnc_mask_to_port(unsigned int mask)
-{
-#ifdef CONFIG_ARCH_FEROCEON_KW2
-	switch (mask) {
-	case 27:
-		return 0;
-	case 15:
-		return 1;
-	case 30:
-		return 2;
-	default:
-		return -1;
-	}
-#else
-	switch (mask) {
-	case 30:
-		return 0;
-	case 15:
-		return 1;
-	case 27:
-		return 2;
-	case 23:
-		return 3;
-	default:
-		return -1;
-	}
-#endif /* MV_ETH_PNC_NEW */
-}
-
-/*
- * pnc_ip4_2tuple - Add 2-tuple priority rules
- */
-int pnc_ip4_2tuple_rxq(unsigned int eth_port, unsigned int sip, unsigned int dip, int rxq)
-{
-#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
-	struct tcam_entry *te;
-	unsigned int pdata, pmask;
-	int tid, empty = -1, min_index_occupied = TE_FLOW_L3_END + 1;
-
-	if (rxq < -2 || rxq >= CONFIG_MV_ETH_RXQ || eth_port >= CONFIG_MV_ETH_PORTS_NUM)
-		return 1;
-
-	for (tid = TE_FLOW_L3_END; tid > last_5tuple_rule; tid--) {
-		te = pnc_tcam_entry_get(tid);
-		/* Remember first Empty entry */
-		if (te == NULL) {
-			if (empty == -1)
-				empty = tid;
-			continue;
-		}
-
-		/* Find existing entry for this rule */
-		if (tcam_sw_cmp_2tuple(te, sip, dip) == 0) {
-			tcam_sw_get_port(te, &pdata, &pmask);
-			if (rxq == -2) { /* delete rule */
-				if (!pnc_port_mask_check(pmask, eth_port)) {
-					printk(KERN_ERR "%s: rule is not associated with this port (%d)\n", __func__, eth_port);
-					tcam_sw_free(te);
-					return 1;
-				}
-				if (first_2tuple_rule == tid)
-					first_2tuple_rule = min_index_occupied;
-				pnc_te_del(tid);
-				tcam_sw_free(te);
-				return 0;
-			}
-
-			if (!pnc_port_mask_check(pmask, eth_port)) { /* rule is already associated with another port */
-				printk(KERN_ERR "%s: rule is already associated with port %d\n",
-									__func__, pnc_mask_to_port(pmask));
-				return 1;
-			}
-			if (rxq == -1) { /* set rule to drop mode */
-				sram_sw_set_rinfo(te, RI_DROP, RI_DROP);
-				sram_sw_set_lookup_done(te, 1);
-				tcam_hw_write(te, tid);
-			} else { /* update rxq */
-				sram_sw_set_rinfo(te, 0, RI_DROP);
-				sram_sw_set_rinfo(te, RI_L3_FLOW, RI_L3_FLOW);
-				sram_sw_set_rxq(te, rxq, 0);
-				tcam_hw_write(te, tid);
-			}
-
-			tcam_sw_free(te);
-			return 0;
-		}
-		min_index_occupied = tid;
-		tcam_sw_free(te);
-	}
-
-	/* Add rule to PNC */
-	if (rxq == -2) {
-		mvOsPrintf("%s: Entry not found - sip=0x%x, dip=0x%x, rxq=%d\n", __func__, sip, dip, rxq);
-		return 1;
-	}
-	/* Not found existing entry and no free TCAM entry - Failed */
-	if ((empty == -1) || (empty <= last_5tuple_rule)) {
-		mvOsPrintf("%s: No free place - sip=0x%x, dip=0x%x, rxq=%d\n", __func__, sip, dip, rxq);
-		return 1;
-	}
-
-	/* update upper border of 2 tuple rules */
-	if (first_2tuple_rule > empty)
-		first_2tuple_rule = empty;
-
-	te = pnc_create_2t_entry(sip, dip);
-	pmask = pnc_port_mask(eth_port);
-	tcam_sw_set_port(te, 0, pmask);
-	sram_sw_set_lookup_done(te, 1);
-	tcam_sw_text(te, "ipv4_2t");
-
-	if (rxq == -1) {
-		sram_sw_set_rinfo(te, RI_DROP, RI_DROP);
-		sram_sw_set_lookup_done(te, 1);
-	} else {
-		sram_sw_set_rinfo(te, 0, RI_DROP);
-		sram_sw_set_rinfo(te, RI_L3_FLOW, RI_L3_FLOW);
-		sram_sw_set_rxq(te, rxq, 0);
-	}
-
-	tcam_hw_write(te, empty);
-	tcam_sw_free(te);
-
-	return 0;
-#else
-	return -1;
-#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
-}
-
-/*
- * pnc_ip4_5tuple - Add 5-tuple priority rules
- */
-int pnc_ip4_5tuple_rxq(unsigned int eth_port, unsigned int sip, unsigned int dip, unsigned int ports,
-						unsigned int proto, int rxq)
-{
-#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
-	struct tcam_entry *te;
-	unsigned int pdata, pmask;
-	int tid, empty = -1, max_index_occupied = TE_FLOW_L3 - 1;
-
-	if (rxq < -2 || rxq >= CONFIG_MV_ETH_RXQ || eth_port >= CONFIG_MV_ETH_PORTS_NUM)
-		return 1;
-
-	for (tid = TE_FLOW_L3; tid < first_2tuple_rule; tid++) {
-		te = pnc_tcam_entry_get(tid);
-		/* Remember first Empty entry */
-		if (te == NULL) {
-			if (empty == -1)
-				empty = tid;
-			continue;
-		}
-		/* Find existing entry for this rule */
-		if (tcam_sw_cmp_5tuple(te, sip, dip, ports, proto) == 0) {
-			tcam_sw_get_port(te, &pdata, &pmask);
-			if (rxq == -2) { /* delete rule */
-				if (!pnc_port_mask_check(pmask, eth_port)) {
-					printk(KERN_ERR "%s: rule is not associated with this port (%d)\n", __func__, eth_port);
-					tcam_sw_free(te);
-					return 1;
-				}
-				if (last_5tuple_rule == tid)
-					last_5tuple_rule = max_index_occupied;
-				pnc_te_del(tid);
-				tcam_sw_free(te);
-				return 0;
-			}
-
-			if (!pnc_port_mask_check(pmask, eth_port)) { /* rule is already associated with another port */
-				printk(KERN_ERR "%s: rule is already associated with port %d\n",
-									__func__, pnc_mask_to_port(pmask));
-				return 1;
-			}
-			if (rxq == -1) { /* set rule to drop mode */
-				sram_sw_set_rinfo(te, RI_DROP, RI_DROP);
-				sram_sw_set_lookup_done(te, 1);
-				tcam_hw_write(te, tid);
-			} else { /* update rxq */
-				sram_sw_set_rinfo(te, 0, RI_DROP);
-				sram_sw_set_rinfo(te, RI_L3_FLOW, RI_L3_FLOW);
-				sram_sw_set_rxq(te, rxq, 0);
-				tcam_hw_write(te, tid);
-			}
-
-			tcam_sw_free(te);
-			return 0;
-		}
-		max_index_occupied = tid;
-		tcam_sw_free(te);
-	}
-
-	/* Add rule to PNC */
-	if (rxq == -2) {
-		mvOsPrintf("%s: Entry not found - sip=0x%x, dip=0x%x, ports=0x%x, proto=%d, rxq=%d\n",
-				__func__, sip, dip, ports, proto, rxq);
-		return 1;
-	}
-	/* Not found existing entry and no free TCAM entry - Failed */
-	if ((empty == -1) || (empty >= first_2tuple_rule)) {
-		mvOsPrintf("%s: No free place - sip=0x%x, dip=0x%x, ports=0x%x, proto=%d, rxq=%d\n",
-				__func__, sip, dip, ports, proto, rxq);
-		return 1;
-	}
-
-	/* update lower border of 5 tuple rules */
-	if (last_5tuple_rule < empty)
-		last_5tuple_rule = empty;
-
-	te = pnc_create_2t_entry(sip, dip);
-
-	tcam_sw_set_byte(te, 9, proto);
-	tcam_sw_set_byte(te, 20, (ports >> 0) & 0xFF);
-	tcam_sw_set_byte(te, 21, (ports >> 8) & 0xFF);
-	tcam_sw_set_byte(te, 22, (ports >> 16) & 0xFF);
-	tcam_sw_set_byte(te, 23, (ports >> 24) & 0xFF);
-	pmask = pnc_port_mask(eth_port);
-	tcam_sw_set_port(te, 0, pmask);
-	sram_sw_set_lookup_done(te, 1);
-	tcam_sw_text(te, "ipv4_5t");
-
-	if (rxq == -1) {
-		sram_sw_set_rinfo(te, RI_DROP, RI_DROP);
-		sram_sw_set_lookup_done(te, 1);
-	} else {
-		sram_sw_set_rinfo(te, 0, RI_DROP);
-		sram_sw_set_rinfo(te, RI_L3_FLOW, RI_L3_FLOW);
-		sram_sw_set_rxq(te, rxq, 0);
-	}
-
-	tcam_hw_write(te, empty);
-	tcam_sw_free(te);
-
-	return 0;
-#else
-	return -1;
-#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
-}
-
-
-/*
- * pnc_rxq_map_dump - Dump all rules
- */
-int pnc_rxq_map_dump()
-{
-#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
-	struct tcam_entry *te;
-	unsigned int tid, sport, dport, word, shift, rinfo, mask, data;
-	unsigned char sip[4], dip[4], sip_buf[16], dip_buf[16], *proto;
-
-	mvOsPrintf(" Tid   Sip               Dip               Sport   Dport   Proto   Rxq    Port   Name\n");
-	for (tid = TE_FLOW_L3; tid <= TE_FLOW_L3_END; tid++) {
-		te = pnc_tcam_entry_get(tid);
-		/* Remember first Empty entry */
-		if (te) {
-			memset(sip_buf, 0, 16);
-			memset(dip_buf, 0, 16);
-
-			sip[0] = *(te->data.u.byte + 12);
-			sip[1] = *(te->data.u.byte + 13);
-			sip[2] = *(te->data.u.byte + 14);
-			sip[3] = *(te->data.u.byte + 15);
-			dip[0] = *(te->data.u.byte + 16);
-			dip[1] = *(te->data.u.byte + 17);
-			dip[2] = *(te->data.u.byte + 18);
-			dip[3] = *(te->data.u.byte + 19);
-			mvOsSPrintf(sip_buf, "%d.%d.%d.%d", sip[0], sip[1], sip[2], sip[3]);
-			mvOsSPrintf(dip_buf, "%d.%d.%d.%d", dip[0], dip[1], dip[2], dip[3]);
-			mvOsPrintf(" %-3d   %-15s   %-15s   ", tid, sip_buf, dip_buf);
-
-			if (te->ctrl.text[5] == '5') {
-				sport = MV_BYTE_SWAP_16BIT(*((u16 *)(te->data.u.byte + 20)));
-				dport = MV_BYTE_SWAP_16BIT(*((u16 *)(te->data.u.byte + 22)));
-				proto = (*(te->data.u.byte + 9) == 6) ? "TCP" : "UDP";
-				mvOsPrintf("%-5d   %-5d   %-5s   ", sport, dport, proto);
-			} else
-				mvOsPrintf("-----   -----   -----   ");
-
-			word = RI_VALUE_OFFS / 32;
-			shift = RI_VALUE_OFFS % 32;
-			rinfo = (te->sram.word[word] >> shift) & ((1 << RI_BITS) - 1);
-			if (rinfo & 1)
-				mvOsPrintf("DROP   ");
-			else
-				mvOsPrintf("%-4d   ", sram_sw_get_rxq(te, NULL));
-
-			tcam_sw_get_port(te, &data, &mask);
-			mvOsPrintf("%-4d   ", pnc_mask_to_port(mask));
-			mvOsPrintf("%s\n", te->ctrl.text);
-
-			tcam_sw_free(te);
-		}
-	}
-
-	return 0;
-#else
-	return -1;
-#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
-}
--- a/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c
+++ b/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c
@@ -349,7 +349,7 @@ MV_NFC_FLASH_INFO flashDeviceInfo[] = {
 	 .flags = NFC_CLOCK_UPSCALE_200M
 	},
 
- 	{			/* Samsung 8Gb */
+	{			/* Samsung 8Gb */
 	.tADL = 100,		/* tADL, Address to write data delay */
 	.tCH = 5,		/* tCH, Enable signal hold time */
 	.tCS = 20,		/* tCS, Enable signal setup time */
@@ -373,7 +373,7 @@ MV_NFC_FLASH_INFO flashDeviceInfo[] = {
 	 .flags = NFC_CLOCK_UPSCALE_200M
 	},
 
- 	{			/* Samsung 4Gb */
+	{			/* Samsung 4Gb */
 	.tADL = 70,		/* tADL, Address to write data delay */
 	.tCH = 5,		/* tCH, Enable signal hold time */
 	.tCS = 20,		/* tCS, Enable signal setup time */
@@ -2328,7 +2328,7 @@ static MV_STATUS mvNfcDeviceFeatureSet(M
 	/* Wait for Command WRITE request */
 	errCode = mvDfcWait4Complete(NFC_SR_WRCMDREQ_MASK, 1);
 	if (errCode != MV_OK)
-		goto Error;
+		goto Error_1;
 
 	reg = MV_REG_READ(NFC_STATUS_REG);
 	MV_REG_WRITE(NFC_STATUS_REG, reg);
@@ -2370,7 +2370,7 @@ static MV_STATUS mvNfcDeviceFeatureSet(M
 	if (timeout == 0)
 		return MV_BAD_STATE;
 
-Error:
+Error_1:
 	return errCode;
 }
 
@@ -2411,7 +2411,7 @@ static MV_STATUS mvNfcDeviceFeatureGet(M
 	/* Wait for Command WRITE request */
 	errCode = mvDfcWait4Complete(NFC_SR_WRCMDREQ_MASK, 1);
 	if (errCode != MV_OK)
-		goto Error;
+		goto Error_2;
 
 	reg = MV_REG_READ(NFC_STATUS_REG);
 	MV_REG_WRITE(NFC_STATUS_REG, reg);
@@ -2433,7 +2433,7 @@ static MV_STATUS mvNfcDeviceFeatureGet(M
 	if (errCode != MV_OK)
 		return errCode;
 
-	udelay(100);
+	udelay(500);
 	/* Send Last-Naked Read Command */
 	reg = 0x0;
 	reg |= NFC_CB0_CMD_XTYPE_LAST_NAKED;
@@ -2463,7 +2463,7 @@ static MV_STATUS mvNfcDeviceFeatureGet(M
 	}
 	if (timeout == 0)
 		return MV_BAD_STATE;
-Error:
+Error_2:
 	return errCode;
 }
 
@@ -2529,7 +2529,7 @@ MV_STATUS mvNfcReset(void)
 	if (errCode != MV_OK)
 	{
 		mvOsPrintf("%s() - Failed wait for NFC_SR_WRCMDREQ_MASK\n", __func__ );
-		goto Error;
+		goto Error_3;
 	}
 
 	/* Send Command */
@@ -2542,7 +2542,7 @@ MV_STATUS mvNfcReset(void)
 	if (errCode != MV_OK)
 	{
 		mvOsPrintf("%s() - Failed wait for NFC_SR_RDY0_MASK\n", __func__ );
-		goto Error;
+		goto Error_3;
 	}
 
 	/* Wait for ND_RUN bit to get cleared. */
@@ -2555,7 +2555,7 @@ MV_STATUS mvNfcReset(void)
 	if (timeout == 0)
 		return MV_BAD_STATE;
 
-Error:
+Error_3:
 	return errCode;
 }
 #endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pci-if/mvCompVer.txt
@@ -0,0 +1,3 @@
+Global HAL Version: FEROCEON_HAL_3_1_7
+Unit HAL Version: 3.1.3
+Description: This component includes an implementation of the unit HAL drivers
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.c
@@ -0,0 +1,344 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*	Redistributions of source code must retain the above copyright notice,
+		this list of conditions and the following disclaimer.
+
+	*	Redistributions in binary form must reproduce the above copyright
+		notice, this list of conditions and the following disclaimer in the
+		documentation and/or other materials provided with the distribution.
+
+	*	Neither the name of Marvell nor the names of its contributors may be
+		used to endorse or promote products derived from this software without
+		specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvPciIf.h"
+#include "mv_hal_if/mvSysPexApi.h"
+
+/* #if defined(MV_INCLUDE_PCI) */
+/* #include "ctrlEnv/sys/mvSysPci.h" */
+/* #endif */
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*******************************************************************************
+* mvPciInit - Initialize PCI interfaces
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	None
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*	MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
+*
+*******************************************************************************/
+MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)
+{
+	MV_PEX_TYPE pexType;
+	if (PCI_IF_MODE_HOST == pciIfmode) {
+		pexType = MV_PEX_ROOT_COMPLEX;
+	} else if (PCI_IF_MODE_DEVICE == pciIfmode) {
+		pexType = MV_PEX_END_POINT;
+	} else {
+		mvOsPrintf("%s: ERROR!!! Bus %d type %d neither root complex nor"
+			   " end point\n", __func__, pciIf, pciIfmode);
+		return MV_FAIL;
+	}
+	return mvSysPexInit(pciIf, pexType);
+}
+
+/* PCI configuration space read write */
+/*******************************************************************************
+* mvPciConfigRead - Read from configuration space
+*
+* DESCRIPTION:
+*	This function performs a 32 bit read from PCI configuration space.
+*	It supports both type 0 and type 1 of Configuration Transactions
+*	(local and over bridge). In order to read from local bus segment, use
+*	bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers
+*	will result configuration transaction of type 1 (over bridge).
+*
+* INPUT:
+*	pciIf		- PCI interface number.
+*	bus		- PCI segment bus number.
+*	dev		- PCI device number.
+*	func		- Function number.
+*	regOffs		- Register offset.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	32bit register data, 0xffffffff on error
+*
+*******************************************************************************/
+MV_U32 mvPciIfConfigRead(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff)
+{
+	return mvPexConfigRead(pciIf, bus, dev, func, regOff);
+}
+
+/*******************************************************************************
+* mvPciConfigWrite - Write to configuration space
+*
+* DESCRIPTION:
+*	This function performs a 32 bit write to PCI configuration space.
+*	It supports both type 0 and type 1 of Configuration Transactions
+*	(local and over bridge). In order to write to local bus segment, use
+*	bus number retrieved from mvPciLocalBusNumGet(). Other bus numbers
+*	will result configuration transaction of type 1 (over bridge).
+*
+* INPUT:
+*	pciIf		- PCI interface number.
+*	bus		- PCI segment bus number.
+*	dev		- PCI device number.
+*	func		- Function number.
+*	regOffs		- Register offset.
+*	data		- 32bit data.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff, MV_U32 data)
+{
+	return mvPexConfigWrite(pciIf, bus, dev, func, regOff, data);
+}
+
+/*******************************************************************************
+* mvPciMasterEnable - Enable/disale PCI interface master transactions.
+*
+* DESCRIPTION:
+*	This function performs read modified write to PCI command status
+*	(offset 0x4) to set/reset bit 2. After this bit is set, the PCI
+*	master is allowed to gain ownership on the bus, otherwise it is
+*	incapable to do so.
+*
+* INPUT:
+*	pciIf		- PCI interface number.
+*	enable		- Enable/disable parameter.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciIfMasterEnable(MV_U32 pciIf, MV_BOOL enable)
+{
+	return mvPexMasterEnable(pciIf, enable);
+}
+
+/*******************************************************************************
+* mvPciSlaveEnable - Enable/disale PCI interface slave transactions.
+*
+* DESCRIPTION:
+*	This function performs read modified write to PCI command status
+*	(offset 0x4) to set/reset bit 0 and 1. After those bits are set,
+*	the PCI slave is allowed to respond to PCI IO space access (bit 0)
+*	and PCI memory space access (bit 1).
+*
+* INPUT:
+*	pciIf		- PCI interface number.
+*	dev		- PCI device number.
+*	enable		- Enable/disable parameter.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciIfSlaveEnable(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_BOOL enable)
+{
+	return mvPexSlaveEnable(pciIf, bus, dev, enable);
+}
+
+/*******************************************************************************
+* mvPciLocalBusNumSet - Set PCI interface local bus number.
+*
+* DESCRIPTION:
+*	This function sets given PCI interface its local bus number.
+*	Note: In case the PCI interface is PCI-X, the information is read-only.
+*
+* INPUT:
+*	pciIf		- PCI interface number.
+*	busNum		- Bus number.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_NOT_ALLOWED in case PCI interface is PCI-X.
+*	MV_BAD_PARAM on bad parameters, otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciIfLocalBusNumSet(MV_U32 pciIf, MV_U32 busNum)
+{
+	return mvPexLocalBusNumSet(pciIf, busNum);
+}
+
+/*******************************************************************************
+* mvPciLocalBusNumGet - Get PCI interface local bus number.
+*
+* DESCRIPTION:
+*	This function gets the local bus number of a given PCI interface.
+*
+* INPUT:
+*	pciIf  - PCI interface number.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	Local bus number.0xffffffff on Error
+*
+*******************************************************************************/
+MV_U32 mvPciIfLocalBusNumGet(MV_U32 pciIf)
+{
+	return mvPexLocalBusNumGet(pciIf);
+}
+
+/*******************************************************************************
+* mvPciLocalDevNumSet - Set PCI interface local device number.
+*
+* DESCRIPTION:
+*	This function sets given PCI interface its local device number.
+*	Note: In case the PCI interface is PCI-X, the information is read-only.
+*
+* INPUT:
+*	pciIf		- PCI interface number.
+*	devNum		- Device number.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_NOT_ALLOWED in case PCI interface is PCI-X.
+*	MV_BAD_PARAM on bad parameters, otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciIfLocalDevNumSet(MV_U32 pciIf, MV_U32 devNum)
+{
+	return mvPexLocalDevNumSet(pciIf, devNum);
+}
+
+/*******************************************************************************
+* mvPciLocalDevNumGet - Get PCI interface local device number.
+*
+* DESCRIPTION:
+*	This function gets the local device number of a given PCI interface.
+*
+* INPUT:
+*	pciIf  - PCI interface number.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	Local device number. 0xffffffff on Error
+*
+*******************************************************************************/
+MV_U32 mvPciIfLocalDevNumGet(MV_U32 pciIf)
+{
+	return mvPexLocalDevNumGet(pciIf);
+}
+
+/*******************************************************************************
+* mvPciIfTypeGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*
+*******************************************************************************/
+PCI_IF_TYPE mvPciIfTypeGet(MV_U32 pciIf)
+{
+	return PCI_IF_TYPE_PEX;
+}
+
+/*******************************************************************************
+* mvPciIfTypeGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvPciRealIfNumGet(MV_U32 pciIf)
+{
+	return pciIf;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pci-if/mvPciIf.h
@@ -0,0 +1,134 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*	Redistributions of source code must retain the above copyright notice,
+		this list of conditions and the following disclaimer.
+
+	*	Redistributions in binary form must reproduce the above copyright
+		notice, this list of conditions and the following disclaimer in the
+		documentation and/or other materials provided with the distribution.
+
+	*	Neither the name of Marvell nor the names of its contributors may be
+		used to endorse or promote products derived from this software without
+		specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCPCIIFH
+#define __INCPCIIFH
+
+#include "mvSysHwConfig.h"
+#include "pci-if/mvPciIfRegs.h"
+#if defined(MV_INCLUDE_PEX)
+#include "pex/mvPex.h"
+#endif
+#if defined(MV_INCLUDE_PCI)
+#include "pci/mvPci.h"
+#endif
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+typedef enum _mvPCIIfType {
+	PCI_IF_TYPE_CONVEN_PCIX,
+	PCI_IF_TYPE_PEX
+} PCI_IF_TYPE;
+
+typedef enum _mvPCIIfMode {
+	PCI_IF_MODE_HOST,
+	PCI_IF_MODE_DEVICE
+} PCI_IF_MODE;
+
+/* Global Functions prototypes */
+
+/* mvPciIfInit - Initialize PCI interfaces*/
+MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode);
+
+/* mvPciIfConfigRead - Read from configuration space */
+MV_U32 mvPciIfConfigRead(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff);
+
+/* mvPciIfConfigWrite - Write to configuration space */
+MV_STATUS mvPciIfConfigWrite(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_U32 regOff, MV_U32 data);
+
+/* mvPciIfMasterEnable - Enable/disale PCI interface master transactions.*/
+MV_STATUS mvPciIfMasterEnable(MV_U32 pciIf, MV_BOOL enable);
+
+/* mvPciIfSlaveEnable - Enable/disale PCI interface slave transactions.*/
+MV_STATUS mvPciIfSlaveEnable(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_BOOL enable);
+
+/* mvPciIfLocalBusNumSet - Set PCI interface local bus number.*/
+MV_STATUS mvPciIfLocalBusNumSet(MV_U32 pciIf, MV_U32 busNum);
+
+/* mvPciIfLocalBusNumGet - Get PCI interface local bus number.*/
+MV_U32 mvPciIfLocalBusNumGet(MV_U32 pciIf);
+
+/* mvPciIfLocalDevNumSet - Set PCI interface local device number.*/
+MV_STATUS mvPciIfLocalDevNumSet(MV_U32 pciIf, MV_U32 devNum);
+
+/* mvPciIfLocalDevNumGet - Get PCI interface local device number.*/
+MV_U32 mvPciIfLocalDevNumGet(MV_U32 pciIf);
+
+/* mvPciIfTypeGet - Get PCI If type*/
+PCI_IF_TYPE mvPciIfTypeGet(MV_U32 pciIf);
+
+MV_U32 mvPciRealIfNumGet(MV_U32 pciIf);
+
+/* mvPciIfAddrDecShow - Display address decode windows attributes */
+MV_VOID mvPciIfAddrDecShow(MV_VOID);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* #ifndef __INCPCIIFH */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pci-if/mvPciIfRegs.h
@@ -0,0 +1,235 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*	Redistributions of source code must retain the above copyright notice,
+		this list of conditions and the following disclaimer.
+
+	*	Redistributions in binary form must reproduce the above copyright
+		notice, this list of conditions and the following disclaimer in the
+		documentation and/or other materials provided with the distribution.
+
+	*	Neither the name of Marvell nor the names of its contributors may be
+		used to endorse or promote products derived from this software without
+		specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCPCIIFREGSH
+#define __INCPCIIFREGSH
+
+/* defines */
+#define MAX_PCI_DEVICES         32
+#define MAX_PCI_FUNCS           8
+#define MAX_PCI_BUSSES          128
+
+/***************************************/
+/* PCI Configuration registers */
+/***************************************/
+
+/*********************************************/
+/* PCI Configuration, Function 0, Registers  */
+/*********************************************/
+
+/* Standard registers */
+#define PCI_DEVICE_AND_VENDOR_ID					0x000
+#define PCI_STATUS_AND_COMMAND						0x004
+#define PCI_CLASS_CODE_AND_REVISION_ID			    0x008
+#define PCI_BIST_HDR_TYPE_LAT_TMR_CACHE_LINE		0x00C
+#define PCI_MEMORY_BAR_BASE_ADDR(barNum)		 	(0x010 + ((barNum) << 2))
+#define PCI_SUBSYS_ID_AND_SUBSYS_VENDOR_ID		 	0x02C
+#define PCI_EXPANSION_ROM_BASE_ADDR_REG			    0x030
+#define PCI_CAPABILTY_LIST_POINTER			        0x034
+#define PCI_INTERRUPT_PIN_AND_LINE					0x03C
+
+/* PCI Device and Vendor ID Register (PDVIR) */
+#define PDVIR_VEN_ID_OFFS			0	/* Vendor ID */
+#define PDVIR_VEN_ID_MASK			(0xffff << PDVIR_VEN_ID_OFFS)
+
+#define PDVIR_DEV_ID_OFFS			16	/* Device ID */
+#define PDVIR_DEV_ID_MASK  			(0xffff << PDVIR_DEV_ID_OFFS)
+
+/* PCI Status and Command Register (PSCR) */
+#define PSCR_IO_EN			BIT0	/* IO Enable                                                      */
+#define PSCR_MEM_EN			BIT1	/* Memory Enable                                                  */
+#define PSCR_MASTER_EN		BIT2	/* Master Enable                                                  */
+#define PSCR_SPECIAL_EN		BIT3	/* Special Cycle Enable                                   */
+#define PSCR_MEM_WRI_INV	BIT4	/* Memory Write and Invalidate Enable     */
+#define PSCR_VGA			BIT5	/* VGA Palette Snoops                                     */
+#define PSCR_PERR_EN		BIT6	/* Parity Errors Respond Enable                   */
+#define PSCR_ADDR_STEP   	BIT7	/* Address Stepping Enable (Wait Cycle En) */
+#define PSCR_SERR_EN		BIT8	/* Ability to assert SERR# line                   */
+#define PSCR_FAST_BTB_EN	BIT9	/* generate fast back-to-back transactions */
+#define PSCR_CAP_LIST		BIT20	/* Capability List Support                                */
+#define PSCR_66MHZ_EN		BIT21	/* 66 MHz Capable                                                 */
+#define PSCR_UDF_EN			BIT22	/* User definable features                                */
+#define PSCR_TAR_FAST_BB 	BIT23	/* fast back-to-back transactions capable */
+#define PSCR_DATA_PERR		BIT24	/* Data Parity reported                                   */
+
+#define PSCR_DEVSEL_TIM_OFFS 	25	/* DEVSEL timing */
+#define PSCR_DEVSEL_TIM_MASK 	(0x3 << PSCR_DEVSEL_TIM_OFFS)
+#define PSCR_DEVSEL_TIM_FAST	(0x0 << PSCR_DEVSEL_TIM_OFFS)
+#define PSCR_DEVSEL_TIM_MED 	(0x1 << PSCR_DEVSEL_TIM_OFFS)
+#define PSCR_DEVSEL_TIM_SLOW 	(0x2 << PSCR_DEVSEL_TIM_OFFS)
+
+#define PSCR_SLAVE_TABORT	BIT27	/* Signalled Target Abort       */
+#define PSCR_MASTER_TABORT	BIT28	/* Recieved Target Abort        */
+#define PSCR_MABORT			BIT29	/* Recieved Master Abort        */
+#define PSCR_SYSERR			BIT30	/* Signalled system error       */
+#define PSCR_DET_PARERR		BIT31	/* Detect Parity Error          */
+
+/*	PCI configuration register offset=0x08 fields
+	(PCI_CLASS_CODE_AND_REVISION_ID)(PCCRI) */
+
+#define PCCRIR_REVID_OFFS		0	/* Revision ID */
+#define PCCRIR_REVID_MASK		(0xff << PCCRIR_REVID_OFFS)
+
+#define PCCRIR_FULL_CLASS_OFFS	8	/* Full Class Code */
+#define PCCRIR_FULL_CLASS_MASK	(0xffffff << PCCRIR_FULL_CLASS_OFFS)
+
+#define PCCRIR_PROGIF_OFFS		8	/* Prog .I/F */
+#define PCCRIR_PROGIF_MASK		(0xff << PCCRIR_PROGIF_OFFS)
+
+#define PCCRIR_SUB_CLASS_OFFS	16	/* Sub Class */
+#define PCCRIR_SUB_CLASS_MASK	(0xff << PCCRIR_SUB_CLASS_OFFS)
+
+#define PCCRIR_BASE_CLASS_OFFS	24	/* Base Class */
+#define PCCRIR_BASE_CLASS_MASK	(0xff << PCCRIR_BASE_CLASS_OFFS)
+
+/* 	PCI configuration register offset=0x0C fields
+	(PCI_BIST_HEADER_TYPE_LATENCY_TIMER_CACHE_LINE)(PBHTLTCL) */
+
+#define PBHTLTCLR_CACHELINE_OFFS		0	/* Specifies the cache line size */
+#define PBHTLTCLR_CACHELINE_MASK		(0xff << PBHTLTCLR_CACHELINE_OFFS)
+
+#define PBHTLTCLR_LATTIMER_OFFS			8	/* latency timer */
+#define PBHTLTCLR_LATTIMER_MASK			(0xff << PBHTLTCLR_LATTIMER_OFFS)
+
+#define PBHTLTCLR_HEADTYPE_FULL_OFFS	16	/* Full Header Type */
+#define PBHTLTCLR_HEADTYPE_FULL_MASK	(0xff << PBHTLTCLR_HEADTYPE_FULL_OFFS)
+
+#define PBHTLTCLR_MULTI_FUNC			BIT23	/* Multi/Single function */
+
+#define PBHTLTCLR_HEADER_OFFS			16	/* Header type */
+#define PBHTLTCLR_HEADER_MASK			(0x7f << PBHTLTCLR_HEADER_OFFS)
+#define PBHTLTCLR_HEADER_STANDARD		(0x0 << PBHTLTCLR_HEADER_OFFS)
+#define PBHTLTCLR_HEADER_PCI2PCI_BRIDGE	(0x1 << PBHTLTCLR_HEADER_OFFS)
+
+#define PBHTLTCLR_BISTCOMP_OFFS		24	/* BIST Completion Code */
+#define PBHTLTCLR_BISTCOMP_MASK		(0xf << PBHTLTCLR_BISTCOMP_OFFS)
+
+#define PBHTLTCLR_BISTACT			BIT30	/* BIST Activate bit */
+#define PBHTLTCLR_BISTCAP			BIT31	/* BIST Capable Bit */
+
+/* PCI Bar Base Low Register (PBBLR) */
+#define PBBLR_IOSPACE			BIT0	/* Memory Space Indicator */
+
+#define PBBLR_TYPE_OFFS			1	/* BAR Type/Init Val. */
+#define PBBLR_TYPE_MASK			(0x3 << PBBLR_TYPE_OFFS)
+#define PBBLR_TYPE_32BIT_ADDR	(0x0 << PBBLR_TYPE_OFFS)
+#define PBBLR_TYPE_64BIT_ADDR	(0x2 << PBBLR_TYPE_OFFS)
+
+#define PBBLR_PREFETCH_EN		BIT3	/* Prefetch Enable */
+
+#define PBBLR_MEM_BASE_OFFS		4	/* Memory Bar Base address. Corresponds to
+address bits [31:4] */
+#define PBBLR_MEM_BASE_MASK		(0xfffffff << PBBLR_MEM_BASE_OFFS)
+
+#define PBBLR_IO_BASE_OFFS		2	/* IO Bar Base address. Corresponds to
+address bits [31:2] */
+#define PBBLR_IO_BASE_MASK		(0x3fffffff << PBBLR_IO_BASE_OFFS)
+
+#define PBBLR_BASE_OFFS			12	/* Base address. Address bits [31:12] */
+#define PBBLR_BASE_MASK			(0xfffff << PBBLR_BASE_OFFS)
+#define PBBLR_BASE_ALIGNMET		(1 << PBBLR_BASE_OFFS)
+
+/* PCI Bar Base High Fegister (PBBHR) */
+#define PBBHR_BASE_OFFS			0	/* Base address. Address bits [31:12] */
+#define PBBHR_BASE_MASK			(0xffffffff << PBBHR_BASE_OFFS)
+
+/*	PCI configuration register offset=0x2C fields
+	(PCI_SUBSYSTEM_ID_AND_SUBSYSTEM_VENDOR_ID)(PSISVI) */
+
+#define PSISVIR_VENID_OFFS	0	/* Subsystem Manufacturer Vendor ID Number */
+#define PSISVIR_VENID_MASK	(0xffff << PSISVIR_VENID_OFFS)
+
+#define PSISVIR_DEVID_OFFS	16	/* Subsystem Device ID Number */
+#define PSISVIR_DEVID_MASK	(0xffff << PSISVIR_DEVID_OFFS)
+
+/*	PCI configuration register offset=0x30 fields
+	(PCI_EXPANSION_ROM_BASE_ADDR_REG)(PERBA) */
+
+#define PERBAR_EXPROMEN		BIT0	/* Expansion ROM Enable */
+
+#define PERBAR_BASE_OFFS		12	/* Expansion ROM Base Address */
+#define PERBAR_BASE_MASK		(0xfffff << PERBAR_BASE_OFFS)
+
+/*	PCI configuration register offset=0x34 fields
+	(PCI_CAPABILTY_LIST_POINTER)(PCLP) */
+
+#define PCLPR_CAPPTR_OFFS	0	/* Capability List Pointer */
+#define PCLPR_CAPPTR_MASK	(0xff << PCLPR_CAPPTR_OFFS)
+
+/*	PCI configuration register offset=0x3C fields
+	(PCI_INTERRUPT_PIN_AND_LINE)(PIPL) */
+
+#define PIPLR_INTLINE_OFFS	0	/* Interrupt line (IRQ) */
+#define PIPLR_INTLINE_MASK	(0xff << PIPLR_INTLINE_OFFS)
+
+#define PIPLR_INTPIN_OFFS	8	/* interrupt pin (A, B, C, D) */
+#define PIPLR_INTPIN_MASK	(0xff << PIPLR_INTPIN_OFFS)
+
+#define PIPLR_MINGRANT_OFFS	16	/* Minimum Grant on 250 nano seconds units */
+#define PIPLR_MINGRANT_MASK	(0xff << PIPLR_MINGRANT_OFFS)
+
+#define PIPLR_MAXLATEN_OFFS	24	/* Maximum latency on 250 nano seconds units */
+#define PIPLR_MAXLATEN_MASK	(0xff << PIPLR_MAXLATEN_OFFS)
+
+#endif /* #ifndef __INCPCIIFREGSH */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.c
@@ -0,0 +1,753 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*	Redistributions of source code must retain the above copyright notice,
+		this list of conditions and the following disclaimer.
+
+	*	Redistributions in binary form must reproduce the above copyright
+		notice, this list of conditions and the following disclaimer in the
+		documentation and/or other materials provided with the distribution.
+
+	*	Neither the name of Marvell nor the names of its contributors may be
+		used to endorse or promote products derived from this software without
+		specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "pci-if/pci_util/mvPciUtils.h"
+#include "pex/mvPex.h"
+#include "mvCtrlEnvLib.h"
+#include "pci-if/mvPciIf.h"
+
+/* #define MV_DEBUG */
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*
+This module only support scanning of Header type 00h of pci devices
+There is no suppotr for Header type 01h of pci devices  ( PCI bridges )
+*/
+
+static MV_STATUS pciDetectDevice(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_PCI_DEVICE *pPciAgent);
+
+static MV_U32 pciDetectDeviceBars(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_PCI_DEVICE *pPciAgent);
+
+/*******************************************************************************
+* mvPciScan - Scan a PCI interface bus
+*
+* DESCRIPTION:
+* Performs a full scan on a PCI interface and returns all possible details
+* on the agents found on the bus.
+*
+* INPUT:
+*	pciIf			- PCI Interface
+*	pPciAgents		- Pointer to an Array of the pci agents to be detected
+*	pPciAgentsNum		- pPciAgents array maximum number of elements
+*
+* OUTPUT:
+*	pPciAgents		- Array of the pci agents detected on the bus
+*	pPciAgentsNum		- Number of pci agents detected on the bus
+*
+* RETURN:
+*	MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+
+MV_STATUS mvPciScan(MV_U32 pciIf, MV_PCI_DEVICE *pPciAgents, MV_U32 * pPciAgentsNum)
+{
+
+	MV_U32 devIndex, funcIndex = 0, busIndex = 0, detectedDevNum = 0;
+	MV_U32 localBus = mvPexLocalBusNumGet(pciIf);
+	MV_PCI_DEVICE *pPciDevice;
+	MV_PCI_DEVICE *pMainDevice;
+
+	DB(mvOsPrintf("mvPciScan: PCI interface num %d\n", pciIf));
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciIfMaxIfGet()) {
+		DB(mvOsPrintf("mvPciScan: ERR. Invalid PCI interface num %d\n", pciIf));
+		return MV_BAD_PARAM;
+	}
+	if (NULL == pPciAgents) {
+		DB(mvOsPrintf("mvPciScan: ERR. pPciAgents=NULL \n"));
+		return MV_BAD_PARAM;
+	}
+	if (NULL == pPciAgentsNum) {
+		DB(mvOsPrintf("mvPciScan: ERR. pPciAgentsNum=NULL \n"));
+		return MV_BAD_PARAM;
+	}
+
+	DB(mvOsPrintf("mvPciScan: PCI interface num %d mvPciMasterEnable\n", pciIf));
+	/* Master enable the MV PCI master */
+	if (MV_OK != mvPciIfMasterEnable(pciIf, MV_TRUE)) {
+		DB(mvOsPrintf("mvPciScan: ERR. mvPciMasterEnable failed  \n"));
+		return MV_ERROR;
+
+	}
+
+	DB(mvOsPrintf("mvPciScan: PCI interface num scan%d\n", pciIf));
+
+	/* go through all busses */
+	for (busIndex = localBus; busIndex < MAX_PCI_BUSSES; busIndex++) {
+		/* go through all possible devices on the local bus */
+		for (devIndex = 0; devIndex < MAX_PCI_DEVICES; devIndex++) {
+			/* always start with function equal to zero */
+			funcIndex = 0;
+
+			pPciDevice = &pPciAgents[detectedDevNum];
+			DB(mvOsPrintf("mvPciScan: PCI interface num scan%d:%d\n", busIndex, devIndex));
+
+			if (MV_ERROR == pciDetectDevice(pciIf, busIndex, devIndex, funcIndex, pPciDevice)) {
+				/* no device detected , try the next address */
+				continue;
+			}
+
+			/* We are here ! means we have detected a device */
+			/* always we start with only one function per device */
+			pMainDevice = pPciDevice;
+			pPciDevice->funtionsNum = 1;
+
+			/* move on */
+			detectedDevNum++;
+
+			/* check if we have no more room for a new device */
+			if (detectedDevNum == *pPciAgentsNum) {
+				DB(mvOsPrintf("mvPciScan: ERR. array passed too small \n"));
+				return MV_ERROR;
+			}
+
+			/* check the detected device if it is a multi functional device then
+			   scan all device functions */
+			if (pPciDevice->isMultiFunction == MV_TRUE) {
+				/* start with function number 1 because we have already detected
+				   function 0 */
+				for (funcIndex = 1; funcIndex < MAX_PCI_FUNCS; funcIndex++) {
+					pPciDevice = &pPciAgents[detectedDevNum];
+
+					if (MV_ERROR == pciDetectDevice(pciIf,
+									busIndex,
+									devIndex, funcIndex, pPciDevice)) {
+						/* no device detected means no more functions ! */
+						continue;
+					}
+					/* We are here ! means we have detected a device */
+
+					/* move on */
+					pMainDevice->funtionsNum++;
+					detectedDevNum++;
+
+					/* check if we have no more room for a new device */
+					if (detectedDevNum == *pPciAgentsNum) {
+						DB(mvOsPrintf("mvPciScan: ERR. Array too small\n"));
+						return MV_ERROR;
+					}
+				}
+			}
+		}
+	}
+
+	/* return the number of devices actually detected on the bus ! */
+	*pPciAgentsNum = detectedDevNum;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciDetectDevice - Detect a pci device parameters
+*
+* DESCRIPTION:
+* This function detect if a pci agent exist on certain address !
+* and if exists then it fills all possible information on the
+* agent
+*
+* INPUT:
+*	pciIf		- PCI Interface
+*	bus		- Bus number
+*	dev		- Device number
+*	func		- Function number
+*
+* OUTPUT:
+*	pPciAgent	- pointer to the pci agent filled with its information
+*
+* RETURN:
+*	MV_ERROR if no device , MV_OK otherwise
+*
+*******************************************************************************/
+
+static MV_STATUS pciDetectDevice(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_PCI_DEVICE *pPciAgent)
+{
+	MV_U32 pciData;
+
+	/* no Parameters checking ! because it is static function and it is assumed
+	   that all parameters were checked in the calling function */
+
+	/* Try read the PCI Vendor ID and Device ID */
+
+	/*  We will scan only ourselves and the PCI slots that exist on the
+	   board, because we may have a case that we have one slot that has
+	   a Cardbus connector, and because CardBus answers all IDsels we want
+	   to scan only this slot and ourseleves.
+
+	 */
+#if defined(MV_INCLUDE_PCI)
+	if ((PCI_IF_TYPE_CONVEN_PCIX == mvPciIfTypeGet(pciIf)) &&
+			(DB_88F5181_DDR1_PRPMC != mvBoardIdGet()) &&
+			(DB_88F5181_DDR1_PEXPCI != mvBoardIdGet()) &&
+			(DB_88F5181_DDR1_MNG != mvBoardIdGet()) && (mvBoardIsOurPciSlot(bus, dev) == MV_FALSE))
+		return MV_ERROR;
+
+#endif /* defined(MV_INCLUDE_PCI) */
+
+	pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_DEVICE_AND_VENDOR_ID);
+
+	if (PCI_ERROR_CODE == pciData) {
+		/* no device exist */
+		return MV_ERROR;
+	}
+
+	/* we are here ! means a device is detected */
+
+	/* fill basic information */
+	pPciAgent->busNumber = bus;
+	pPciAgent->deviceNum = dev;
+	pPciAgent->function = func;
+
+	/* Fill the PCI Vendor ID and Device ID */
+
+	pPciAgent->venID = (pciData & PDVIR_VEN_ID_MASK) >> PDVIR_VEN_ID_OFFS;
+	pPciAgent->deviceID = (pciData & PDVIR_DEV_ID_MASK) >> PDVIR_DEV_ID_OFFS;
+
+	/* Read Status and command */
+	pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_STATUS_AND_COMMAND);
+
+	/* Fill related Status and Command information */
+
+	if (pciData & PSCR_TAR_FAST_BB)
+		pPciAgent->isFastB2BCapable = MV_TRUE;
+	else
+		pPciAgent->isFastB2BCapable = MV_FALSE;
+
+	if (pciData & PSCR_CAP_LIST)
+		pPciAgent->isCapListSupport = MV_TRUE;
+	else
+		pPciAgent->isCapListSupport = MV_FALSE;
+
+	if (pciData & PSCR_66MHZ_EN)
+		pPciAgent->is66MHZCapable = MV_TRUE;
+	else
+		pPciAgent->is66MHZCapable = MV_FALSE;
+
+	/* Read Class Code and Revision */
+	pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_CLASS_CODE_AND_REVISION_ID);
+
+	pPciAgent->baseClassCode = (pciData & PCCRIR_BASE_CLASS_MASK) >> PCCRIR_BASE_CLASS_OFFS;
+
+	pPciAgent->subClassCode = (pciData & PCCRIR_SUB_CLASS_MASK) >> PCCRIR_SUB_CLASS_OFFS;
+
+	pPciAgent->progIf = (pciData & PCCRIR_PROGIF_MASK) >> PCCRIR_PROGIF_OFFS;
+
+	pPciAgent->revisionID = (pciData & PCCRIR_REVID_MASK) >> PCCRIR_REVID_OFFS;
+
+	/* Read  PCI_BIST_HDR_TYPE_LAT_TMR_CACHE_LINE */
+	pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_BIST_HDR_TYPE_LAT_TMR_CACHE_LINE);
+
+	pPciAgent->pciCacheLine = (pciData & PBHTLTCLR_CACHELINE_MASK) >> PBHTLTCLR_CACHELINE_OFFS;
+	pPciAgent->pciLatencyTimer = (pciData & PBHTLTCLR_LATTIMER_MASK) >> PBHTLTCLR_LATTIMER_OFFS;
+
+	switch (pciData & PBHTLTCLR_HEADER_MASK) {
+	case PBHTLTCLR_HEADER_STANDARD:
+
+		pPciAgent->pciHeader = MV_PCI_STANDARD;
+		break;
+	case PBHTLTCLR_HEADER_PCI2PCI_BRIDGE:
+
+		pPciAgent->pciHeader = MV_PCI_PCI2PCI_BRIDGE;
+		break;
+	}
+
+	if (pciData & PBHTLTCLR_MULTI_FUNC)
+		pPciAgent->isMultiFunction = MV_TRUE;
+	else
+		pPciAgent->isMultiFunction = MV_FALSE;
+
+	if (pciData & PBHTLTCLR_BISTCAP)
+		pPciAgent->isBISTCapable = MV_TRUE;
+	else
+		pPciAgent->isBISTCapable = MV_FALSE;
+
+	/* read this device pci bars */
+
+	pciDetectDeviceBars(pciIf, bus, dev, func, pPciAgent);
+
+	/* check if we are bridge */
+	if ((pPciAgent->baseClassCode == PCI_BRIDGE_CLASS) && (pPciAgent->subClassCode == P2P_BRIDGE_SUB_CLASS_CODE)) {
+
+		/* Read  P2P_BUSSES_NUM */
+		pciData = mvPciIfConfigRead(pciIf, bus, dev, func, P2P_BUSSES_NUM);
+
+		pPciAgent->p2pPrimBusNum = (pciData & PBM_PRIME_BUS_NUM_MASK) >> PBM_PRIME_BUS_NUM_OFFS;
+
+		pPciAgent->p2pSecBusNum = (pciData & PBM_SEC_BUS_NUM_MASK) >> PBM_SEC_BUS_NUM_OFFS;
+
+		pPciAgent->p2pSubBusNum = (pciData & PBM_SUB_BUS_NUM_MASK) >> PBM_SUB_BUS_NUM_OFFS;
+
+		pPciAgent->p2pSecLatencyTimer = (pciData & PBM_SEC_LAT_TMR_MASK) >> PBM_SEC_LAT_TMR_OFFS;
+
+		/* Read  P2P_IO_BASE_LIMIT_SEC_STATUS */
+		pciData = mvPciIfConfigRead(pciIf, bus, dev, func, P2P_IO_BASE_LIMIT_SEC_STATUS);
+
+		pPciAgent->p2pSecStatus = (pciData & PIBLSS_SEC_STATUS_MASK) >> PIBLSS_SEC_STATUS_OFFS;
+
+		pPciAgent->p2pIObase = (pciData & PIBLSS_IO_BASE_MASK) << PIBLSS_IO_LIMIT_OFFS;
+
+		/* clear low address (should be zero) */
+		pPciAgent->p2pIObase &= PIBLSS_HIGH_ADDR_MASK;
+
+		pPciAgent->p2pIOLimit = (pciData & PIBLSS_IO_LIMIT_MASK);
+
+		/* fill low address with 0xfff */
+		pPciAgent->p2pIOLimit |= PIBLSS_LOW_ADDR_MASK;
+
+		switch ((pciData & PIBLSS_ADD_CAP_MASK) >> PIBLSS_ADD_CAP_OFFS) {
+		case PIBLSS_ADD_CAP_16BIT:
+
+			pPciAgent->bIO32 = MV_FALSE;
+
+			break;
+		case PIBLSS_ADD_CAP_32BIT:
+
+			pPciAgent->bIO32 = MV_TRUE;
+
+			/* Read  P2P_IO_BASE_LIMIT_UPPER_16 */
+			pciData = mvPciIfConfigRead(pciIf, bus, dev, func, P2P_IO_BASE_LIMIT_UPPER_16);
+
+			pPciAgent->p2pIObase |= (pciData & PRBU_IO_UPP_BASE_MASK) << PRBU_IO_UPP_LIMIT_OFFS;
+
+			pPciAgent->p2pIOLimit |= (pciData & PRBU_IO_UPP_LIMIT_MASK);
+
+			break;
+		}
+
+		/* Read  P2P_MEM_BASE_LIMIT */
+		pciData = mvPciIfConfigRead(pciIf, bus, dev, func, P2P_MEM_BASE_LIMIT);
+
+		pPciAgent->p2pMemBase = (pciData & PMBL_MEM_BASE_MASK) << PMBL_MEM_LIMIT_OFFS;
+
+		/* clear low address */
+		pPciAgent->p2pMemBase &= PMBL_HIGH_ADDR_MASK;
+
+		pPciAgent->p2pMemLimit = (pciData & PMBL_MEM_LIMIT_MASK);
+
+		/* add 0xfffff */
+		pPciAgent->p2pMemLimit |= PMBL_LOW_ADDR_MASK;
+
+		/* Read  P2P_PREF_MEM_BASE_LIMIT */
+		pciData = mvPciIfConfigRead(pciIf, bus, dev, func, P2P_PREF_MEM_BASE_LIMIT);
+
+		pPciAgent->p2pPrefMemBase = (pciData & PRMBL_PREF_MEM_BASE_MASK) << PRMBL_PREF_MEM_LIMIT_OFFS;
+
+		/* get high address only */
+		pPciAgent->p2pPrefMemBase &= PRMBL_HIGH_ADDR_MASK;
+
+		pPciAgent->p2pPrefMemLimit = (pciData & PRMBL_PREF_MEM_LIMIT_MASK);
+
+		/* add 0xfffff */
+		pPciAgent->p2pPrefMemLimit |= PRMBL_LOW_ADDR_MASK;
+
+		switch (pciData & PRMBL_ADD_CAP_MASK) {
+		case PRMBL_ADD_CAP_32BIT:
+
+			pPciAgent->bPrefMem64 = MV_FALSE;
+
+			/* Read  P2P_PREF_BASE_UPPER_32 */
+			pPciAgent->p2pPrefBaseUpper32Bits = 0;
+
+			/* Read  P2P_PREF_LIMIT_UPPER_32 */
+			pPciAgent->p2pPrefLimitUpper32Bits = 0;
+
+			break;
+		case PRMBL_ADD_CAP_64BIT:
+
+			pPciAgent->bPrefMem64 = MV_TRUE;
+
+			/* Read  P2P_PREF_BASE_UPPER_32 */
+			pPciAgent->p2pPrefBaseUpper32Bits = mvPciIfConfigRead(pciIf,
+							    bus, dev, func,
+							    P2P_PREF_BASE_UPPER_32);
+
+			/* Read  P2P_PREF_LIMIT_UPPER_32 */
+			pPciAgent->p2pPrefLimitUpper32Bits = mvPciIfConfigRead(pciIf,
+							     bus, dev, func,
+							     P2P_PREF_LIMIT_UPPER_32);
+
+			break;
+
+		}
+
+	} else {		/* no bridge */
+
+		/* Read  PCI_SUBSYS_ID_AND_SUBSYS_VENDOR_ID */
+		pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_SUBSYS_ID_AND_SUBSYS_VENDOR_ID);
+
+		pPciAgent->subSysVenID = (pciData & PSISVIR_VENID_MASK) >> PSISVIR_VENID_OFFS;
+		pPciAgent->subSysID = (pciData & PSISVIR_DEVID_MASK) >> PSISVIR_DEVID_OFFS;
+
+		/* Read  PCI_EXPANSION_ROM_BASE_ADDR_REG */
+		pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_EXPANSION_ROM_BASE_ADDR_REG);
+
+		if (pciData & PERBAR_EXPROMEN)
+			pPciAgent->isExpRom = MV_TRUE;
+		else
+			pPciAgent->isExpRom = MV_FALSE;
+
+		pPciAgent->expRomAddr = (pciData & PERBAR_BASE_MASK) >> PERBAR_BASE_OFFS;
+	}
+
+	if (MV_TRUE == pPciAgent->isCapListSupport) {
+		/* Read  PCI_CAPABILTY_LIST_POINTER */
+		pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_CAPABILTY_LIST_POINTER);
+
+		pPciAgent->capListPointer = (pciData & PCLPR_CAPPTR_MASK) >> PCLPR_CAPPTR_OFFS;
+	}
+
+	/* Read  PCI_INTERRUPT_PIN_AND_LINE */
+	pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_INTERRUPT_PIN_AND_LINE);
+
+	pPciAgent->irqLine = (pciData & PIPLR_INTLINE_MASK) >> PIPLR_INTLINE_OFFS;
+
+	pPciAgent->intPin = (MV_PCI_INT_PIN) (pciData & PIPLR_INTPIN_MASK) >> PIPLR_INTPIN_OFFS;
+
+	pPciAgent->minGrant = (pciData & PIPLR_MINGRANT_MASK) >> PIPLR_MINGRANT_OFFS;
+	pPciAgent->maxLatency = (pciData & PIPLR_MAXLATEN_MASK) >> PIPLR_MAXLATEN_OFFS;
+
+	mvPciClassNameGet(pPciAgent->baseClassCode, (MV_8 *) pPciAgent->type);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciDetectDeviceBars - Detect a pci device bars
+*
+* DESCRIPTION:
+*	This function detects all pci agent bars
+*
+* INPUT:
+*	pciIf		- PCI Interface
+*	bus		- Bus number
+*	dev		- Device number
+*	func		- Function number
+*
+* OUTPUT:
+*	pPciAgent	- pointer to the pci agent filled with its information
+*
+* RETURN:
+*	Detected bars number
+*
+*******************************************************************************/
+static MV_U32 pciDetectDeviceBars(MV_U32 pciIf, MV_U32 bus, MV_U32 dev, MV_U32 func, MV_PCI_DEVICE *pPciAgent)
+{
+	MV_U32 pciData, barIndex, detectedBar = 0;
+	MV_U32 tmpBaseHigh = 0, tmpBaseLow = 0;
+	MV_U32 pciMaxBars = 0;
+
+	pPciAgent->barsNum = 0;
+
+	/* check if we are bridge */
+	if ((pPciAgent->baseClassCode == PCI_BRIDGE_CLASS) && (pPciAgent->subClassCode == P2P_BRIDGE_SUB_CLASS_CODE))
+		pciMaxBars = 2;
+	else			/* no bridge */
+		pciMaxBars = 6;
+
+	/* read this device pci bars */
+	for (barIndex = 0; barIndex < pciMaxBars; barIndex++) {
+		/* Read  PCI_MEMORY_BAR_BASE_ADDR */
+		tmpBaseLow = pciData = mvPciIfConfigRead(pciIf, bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex));
+
+		pPciAgent->pciBar[detectedBar].barOffset = PCI_MEMORY_BAR_BASE_ADDR(barIndex);
+
+		/* check if the bar is 32bit or 64bit bar */
+		switch (pciData & PBBLR_TYPE_MASK) {
+		case PBBLR_TYPE_32BIT_ADDR:
+			pPciAgent->pciBar[detectedBar].barType = PCI_32BIT_BAR;
+			break;
+		case PBBLR_TYPE_64BIT_ADDR:
+			pPciAgent->pciBar[detectedBar].barType = PCI_64BIT_BAR;
+			break;
+		}
+
+		/* check if it is memory or IO bar */
+		if (pciData & PBBLR_IOSPACE)
+			pPciAgent->pciBar[detectedBar].barMapping = PCI_IO_BAR;
+		else
+			pPciAgent->pciBar[detectedBar].barMapping = PCI_MEMORY_BAR;
+
+		/* if it is memory bar then check if it is prefetchable */
+		if (PCI_MEMORY_BAR == pPciAgent->pciBar[detectedBar].barMapping) {
+			if (pciData & PBBLR_PREFETCH_EN)
+				pPciAgent->pciBar[detectedBar].isPrefetchable = MV_TRUE;
+			else
+				pPciAgent->pciBar[detectedBar].isPrefetchable = MV_FALSE;
+
+			pPciAgent->pciBar[detectedBar].barBaseLow = pciData & PBBLR_MEM_BASE_MASK;
+		} else {	/* IO Bar */
+
+			pPciAgent->pciBar[detectedBar].barBaseLow = pciData & PBBLR_IO_BASE_MASK;
+		}
+
+		pPciAgent->pciBar[detectedBar].barBaseHigh = 0;
+
+		if (PCI_64BIT_BAR == pPciAgent->pciBar[detectedBar].barType) {
+			barIndex++;
+
+			tmpBaseHigh = pPciAgent->pciBar[detectedBar].barBaseHigh =
+					      mvPciIfConfigRead(pciIf, bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex));
+		}
+
+		/* calculating full base address (64bit) */
+		pPciAgent->pciBar[detectedBar].barBaseAddr = (MV_U64) pPciAgent->pciBar[detectedBar].barBaseHigh;
+
+		pPciAgent->pciBar[detectedBar].barBaseAddr <<= 32;
+
+		pPciAgent->pciBar[detectedBar].barBaseAddr |= (MV_U64) pPciAgent->pciBar[detectedBar].barBaseLow;
+
+		/* get the sizes of the the bar */
+
+		pPciAgent->pciBar[detectedBar].barSizeHigh = 0;
+
+		if ((PCI_64BIT_BAR == pPciAgent->pciBar[detectedBar].barType) &&
+				(PCI_MEMORY_BAR == pPciAgent->pciBar[detectedBar].barMapping)) {
+			/* write oxffffffff to the bar to get the size */
+			/* start with sizelow ( original value was saved in tmpBaseLow ) */
+			mvPciIfConfigWrite(pciIf,
+					   bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex - 1), 0xffffffff);
+
+			/* read size */
+			pPciAgent->pciBar[detectedBar].barSizeLow =
+				mvPciIfConfigRead(pciIf, bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex - 1));
+
+			/* restore original value */
+			mvPciIfConfigWrite(pciIf,
+					   bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex - 1), tmpBaseLow);
+
+			/* now do the same for BaseHigh */
+
+			/* write oxffffffff to the bar to get the size */
+			mvPciIfConfigWrite(pciIf, bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex), 0xffffffff);
+
+			/* read size */
+			pPciAgent->pciBar[detectedBar].barSizeHigh =
+				mvPciIfConfigRead(pciIf, bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex));
+
+			/* restore original value */
+			mvPciIfConfigWrite(pciIf,
+					   bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex), tmpBaseHigh);
+
+			if ((0 == pPciAgent->pciBar[detectedBar].barSizeLow) &&
+					(0 == pPciAgent->pciBar[detectedBar].barSizeHigh)) {
+				/* this bar is not applicable for this device,
+				   ignore all previous settings and check the next bar */
+
+				/* we though this was a 64bit bar , and it seems this
+				   was wrong ! so decrement barIndex */
+				barIndex--;
+				continue;
+			}
+
+			/* calculate the full 64 bit size  */
+
+			if (0 != pPciAgent->pciBar[detectedBar].barSizeHigh) {
+				pPciAgent->pciBar[detectedBar].barSizeLow &= PBBLR_MEM_BASE_MASK;
+
+				pPciAgent->pciBar[detectedBar].barSizeLow =
+					~pPciAgent->pciBar[detectedBar].barSizeLow + 1;
+
+				pPciAgent->pciBar[detectedBar].barSizeHigh = 0;
+
+			} else {
+
+				pPciAgent->pciBar[detectedBar].barSizeLow &= PBBLR_MEM_BASE_MASK;
+
+				pPciAgent->pciBar[detectedBar].barSizeLow =
+					~pPciAgent->pciBar[detectedBar].barSizeLow + 1;
+
+				pPciAgent->pciBar[detectedBar].barSizeHigh = 0;
+
+			}
+
+		} else {	/* 32bit bar */
+
+			/* write oxffffffff to the bar to get the size */
+			mvPciIfConfigWrite(pciIf, bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex), 0xffffffff);
+
+			/* read size */
+			pPciAgent->pciBar[detectedBar].barSizeLow =
+				mvPciIfConfigRead(pciIf, bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex));
+
+			if (0 == pPciAgent->pciBar[detectedBar].barSizeLow) {
+				/* this bar is not applicable for this device,
+				   ignore all previous settings and check the next bar */
+				continue;
+			}
+
+			/* restore original value */
+			mvPciIfConfigWrite(pciIf, bus, dev, func, PCI_MEMORY_BAR_BASE_ADDR(barIndex), tmpBaseLow);
+
+			/* calculate size low */
+
+			if (PCI_MEMORY_BAR == pPciAgent->pciBar[detectedBar].barMapping)
+				pPciAgent->pciBar[detectedBar].barSizeLow &= PBBLR_MEM_BASE_MASK;
+			else
+				pPciAgent->pciBar[detectedBar].barSizeLow &= PBBLR_IO_BASE_MASK;
+
+			pPciAgent->pciBar[detectedBar].barSizeLow =
+				~pPciAgent->pciBar[detectedBar].barSizeLow + 1;
+
+			pPciAgent->pciBar[detectedBar].barSizeHigh = 0;
+			pPciAgent->pciBar[detectedBar].barSize =
+				(MV_U64) pPciAgent->pciBar[detectedBar].barSizeLow;
+
+		}
+
+		/* we are here ! this means we have already detected a bar for
+		   this device , now move on */
+
+		detectedBar++;
+		pPciAgent->barsNum++;
+	}
+
+	return detectedBar;
+}
+
+/*******************************************************************************
+* mvPciClassNameGet - get PCI  class name
+*
+* DESCRIPTION:
+*	This function returns the PCI class name
+*
+* INPUT:
+*	baseClassCode	- Base Class Code.
+*
+* OUTPUT:
+*	pType		- the class name
+*
+* RETURN:
+*	MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciClassNameGet(MV_U32 baseClassCode, MV_8 *pType)
+{
+	switch (baseClassCode) {
+	case 0x0:
+		strcpy(pType, "Old generation device");
+		break;
+	case 0x1:
+		strcpy(pType, "Mass storage controller");
+		break;
+	case 0x2:
+		strcpy(pType, "Network controller");
+		break;
+	case 0x3:
+		strcpy(pType, "Display controller");
+		break;
+	case 0x4:
+		strcpy(pType, "Multimedia device");
+		break;
+	case 0x5:
+		strcpy(pType, "Memory controller");
+		break;
+	case 0x6:
+		strcpy(pType, "Bridge Device");
+		break;
+	case 0x7:
+		strcpy(pType, "Simple Communication controllers");
+		break;
+	case 0x8:
+		strcpy(pType, "Base system peripherals");
+		break;
+	case 0x9:
+		strcpy(pType, "Input Devices");
+		break;
+	case 0xa:
+		strcpy(pType, "Docking stations");
+		break;
+	case 0xb:
+		strcpy(pType, "Processors");
+		break;
+	case 0xc:
+		strcpy(pType, "Serial bus controllers");
+		break;
+	case 0xd:
+		strcpy(pType, "Wireless controllers");
+		break;
+	case 0xe:
+		strcpy(pType, "Intelligent I/O controllers");
+		break;
+	case 0xf:
+		strcpy(pType, "Satellite communication controllers");
+		break;
+	case 0x10:
+		strcpy(pType, "Encryption/Decryption controllers");
+		break;
+	case 0x11:
+		strcpy(pType, "Data acquisition and signal processing controllers");
+		break;
+	default:
+		strcpy(pType, "Unknown device");
+		break;
+	}
+
+	return MV_OK;
+
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pci-if/pci_util/mvPciUtils.h
@@ -0,0 +1,303 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*	Redistributions of source code must retain the above copyright notice,
+		this list of conditions and the following disclaimer.
+
+	*	Redistributions in binary form must reproduce the above copyright
+		notice, this list of conditions and the following disclaimer in the
+		Documentation and/or other materials provided with the distribution.
+
+	*	Neither the name of Marvell nor the names of its contributors may be
+		used to endorse or promote products derived from this software without
+		specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvPciUtilsh
+#define __INCmvPciUtilsh
+
+/*
+This module only support scanning of Header type 00h of pci devices
+There is no suppotr for Header type 01h of pci devices  ( PCI bridges )
+*/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvSysHwConfig.h"
+
+#include "pci-if/mvPciIf.h"
+#include "pci-if/mvPciIfRegs.h"
+
+/* PCI base address low bar mask */
+#define PCI_ERROR_CODE                      0xffffffff
+
+#define PCI_BRIDGE_CLASS					0x6
+#define P2P_BRIDGE_SUB_CLASS_CODE			0x4
+
+#define P2P_BUSSES_NUM						0x18
+#define P2P_IO_BASE_LIMIT_SEC_STATUS		0x1C
+#define P2P_MEM_BASE_LIMIT					0x20
+#define P2P_PREF_MEM_BASE_LIMIT				0x24
+#define P2P_PREF_BASE_UPPER_32				0x28
+#define P2P_PREF_LIMIT_UPPER_32				0x2C
+#define P2P_IO_BASE_LIMIT_UPPER_16			0x30
+#define P2P_EXP_ROM							0x38
+
+/* P2P_BUSSES_NUM  (PBM) */
+
+#define PBM_PRIME_BUS_NUM_OFFS				0
+#define PBM_PRIME_BUS_NUM_MASK				(0xff << PBM_PRIME_BUS_NUM_OFFS)
+
+#define PBM_SEC_BUS_NUM_OFFS				8
+#define PBM_SEC_BUS_NUM_MASK				(0xff << PBM_SEC_BUS_NUM_OFFS)
+
+#define PBM_SUB_BUS_NUM_OFFS				16
+#define PBM_SUB_BUS_NUM_MASK				(0xff << PBM_SUB_BUS_NUM_OFFS)
+
+#define PBM_SEC_LAT_TMR_OFFS				24
+#define PBM_SEC_LAT_TMR_MASK				(0xff << PBM_SEC_LAT_TMR_OFFS)
+
+/* P2P_IO_BASE_LIMIT_SEC_STATUS (PIBLSS) */
+
+#define PIBLSS_IO_BASE_OFFS					0
+#define PIBLSS_IO_BASE_MASK					(0xff << PIBLSS_IO_BASE_OFFS)
+
+#define PIBLSS_ADD_CAP_OFFS					0
+#define PIBLSS_ADD_CAP_MASK 				(0x3 << PIBLSS_ADD_CAP_OFFS)
+#define PIBLSS_ADD_CAP_16BIT 				(0x0 << PIBLSS_ADD_CAP_OFFS)
+#define PIBLSS_ADD_CAP_32BIT 				(0x1 << PIBLSS_ADD_CAP_OFFS)
+
+#define PIBLSS_LOW_ADDR_OFFS				0
+#define PIBLSS_LOW_ADDR_MASK				(0xFFF << PIBLSS_LOW_ADDR_OFFS)
+
+#define PIBLSS_HIGH_ADDR_OFFS				12
+#define PIBLSS_HIGH_ADDR_MASK				(0xF << PIBLSS_HIGH_ADDR_OFFS)
+
+#define PIBLSS_IO_LIMIT_OFFS				8
+#define PIBLSS_IO_LIMIT_MASK				(0xff << PIBLSS_IO_LIMIT_OFFS)
+
+#define PIBLSS_SEC_STATUS_OFFS				16
+#define PIBLSS_SEC_STATUS_MASK				(0xffff << PIBLSS_SEC_STATUS_OFFS)
+
+/* P2P_MEM_BASE_LIMIT (PMBL)*/
+
+#define PMBL_MEM_BASE_OFFS					0
+#define PMBL_MEM_BASE_MASK					(0xffff << PMBL_MEM_BASE_OFFS)
+
+#define PMBL_MEM_LIMIT_OFFS					16
+#define PMBL_MEM_LIMIT_MASK					(0xffff << PMBL_MEM_LIMIT_OFFS)
+
+#define PMBL_LOW_ADDR_OFFS					0
+#define PMBL_LOW_ADDR_MASK					(0xFFFFF << PMBL_LOW_ADDR_OFFS)
+
+#define PMBL_HIGH_ADDR_OFFS					20
+#define PMBL_HIGH_ADDR_MASK					(0xFFF << PMBL_HIGH_ADDR_OFFS)
+
+/* P2P_PREF_MEM_BASE_LIMIT (PRMBL) */
+
+#define PRMBL_PREF_MEM_BASE_OFFS			0
+#define PRMBL_PREF_MEM_BASE_MASK			(0xffff << PRMBL_PREF_MEM_BASE_OFFS)
+
+#define PRMBL_PREF_MEM_LIMIT_OFFS			16
+#define PRMBL_PREF_MEM_LIMIT_MASK			(0xffff<<PRMBL_PREF_MEM_LIMIT_OFFS)
+
+#define PRMBL_LOW_ADDR_OFFS					0
+#define PRMBL_LOW_ADDR_MASK					(0xFFFFF << PRMBL_LOW_ADDR_OFFS)
+
+#define PRMBL_HIGH_ADDR_OFFS				20
+#define PRMBL_HIGH_ADDR_MASK				(0xFFF << PRMBL_HIGH_ADDR_OFFS)
+
+#define PRMBL_ADD_CAP_OFFS					0
+#define PRMBL_ADD_CAP_MASK					(0xf << PRMBL_ADD_CAP_OFFS)
+#define PRMBL_ADD_CAP_32BIT					(0x0 << PRMBL_ADD_CAP_OFFS)
+#define PRMBL_ADD_CAP_64BIT					(0x1 << PRMBL_ADD_CAP_OFFS)
+
+/* P2P_IO_BASE_LIMIT_UPPER_16 (PIBLU) */
+
+#define PRBU_IO_UPP_BASE_OFFS				0
+#define PRBU_IO_UPP_BASE_MASK				(0xffff << PRBU_IO_UPP_BASE_OFFS)
+
+#define PRBU_IO_UPP_LIMIT_OFFS				16
+#define PRBU_IO_UPP_LIMIT_MASK				(0xffff << PRBU_IO_UPP_LIMIT_OFFS)
+
+/* typedefs */
+
+typedef enum _mvPciBarMapping {
+	PCI_MEMORY_BAR,
+	PCI_IO_BAR,
+	PCI_NO_MAPPING
+} MV_PCI_BAR_MAPPING;
+
+typedef enum _mvPciBarType {
+	PCI_32BIT_BAR,
+	PCI_64BIT_BAR
+} MV_PCI_BAR_TYPE;
+
+typedef enum _mvPciIntPin {
+	MV_PCI_INTA = 1,
+	MV_PCI_INTB = 2,
+	MV_PCI_INTC = 3,
+	MV_PCI_INTD = 4
+} MV_PCI_INT_PIN;
+
+typedef enum _mvPciHeader {
+	MV_PCI_STANDARD,
+	MV_PCI_PCI2PCI_BRIDGE
+} MV_PCI_HEADER;
+
+/* BAR structure */
+typedef struct _pciBar {
+	MV_U32 barOffset;
+	MV_U32 barBaseLow;
+	MV_U32 barBaseHigh;
+	MV_U32 barSizeLow;
+	MV_U32 barSizeHigh;
+	/* The 'barBaseAddr' is a 64-bit variable
+	   that will contain the TOTAL base address
+	   value achived by combining both the 'barBaseLow'
+	   and the 'barBaseHigh' parameters as follows:
+
+	   BIT: 63          31         0
+	   |           |         |
+	   barBaseHigh barBaseLow */
+	MV_U64 barBaseAddr;
+	/* The 'barSize' is a 64-bit variable
+	   that will contain the TOTAL size achived
+	   by combining both the 'barSizeLow' and
+	   the 'barSizeHigh' parameters as follows:
+
+	   BIT: 63          31         0
+	   |           |         |
+	   barSizeHigh barSizeLow
+
+	   NOTE: The total size described above
+	   is AFTER the size calculation as
+	   described in PCI spec rev2.2 */
+	MV_U64 barSize;
+	MV_BOOL isPrefetchable;
+	MV_PCI_BAR_TYPE barType;
+	MV_PCI_BAR_MAPPING barMapping;
+
+} PCI_BAR;
+
+/* Device information structure */
+typedef struct _mvPciDevice {
+	/* Device specific information */
+	MV_U32 busNumber;	/* Pci agent bus number */
+	MV_U32 deviceNum;	/* Pci agent device number */
+	MV_U32 function;	/* Pci agent function number */
+
+	MV_U32 venID;		/* Pci agent Vendor ID */
+	MV_U32 deviceID;	/* Pci agent Device ID */
+
+	MV_BOOL isFastB2BCapable;	/* Capability of Fast Back to Back
+					   transactions */
+	MV_BOOL isCapListSupport;	/* Support of Capability list */
+	MV_BOOL is66MHZCapable;	/* 66MHZ support */
+
+	MV_U32 baseClassCode;	/* Pci agent base Class Code */
+	MV_U32 subClassCode;	/* Pci agent sub Class Code */
+	MV_U32 progIf;	/* Pci agent Programing interface */
+	MV_U32 revisionID;
+
+	PCI_BAR pciBar[6];	/* Pci agent bar list */
+
+	MV_U32 p2pPrimBusNum;	/* P2P Primary Bus number */
+	MV_U32 p2pSecBusNum;	/* P2P Secondary Bus Number */
+	MV_U32 p2pSubBusNum;	/* P2P Subordinate bus Number */
+	MV_U32 p2pSecLatencyTimer;	/* P2P Econdary Latency Timer */
+	MV_U32 p2pIObase;	/* P2P IO Base */
+	MV_U32 p2pIOLimit;	/* P2P IO Linit */
+	MV_BOOL bIO32;
+	MV_U32 p2pSecStatus;	/* P2P Secondary Status */
+	MV_U32 p2pMemBase;	/* P2P Memory Space */
+	MV_U32 p2pMemLimit;	/* P2P Memory Limit */
+	MV_U32 p2pPrefMemBase;	/* P2P Prefetchable Mem Base */
+	MV_U32 p2pPrefMemLimit;	/* P2P Prefetchable Memory Limit */
+	MV_BOOL bPrefMem64;
+	MV_U32 p2pPrefBaseUpper32Bits;	/* P2P Prefetchable upper 32 bits */
+	MV_U32 p2pPrefLimitUpper32Bits;	/* P2P prefetchable limit upper 32 */
+
+	MV_U32 pciCacheLine;	/* Pci agent cache line */
+	MV_U32 pciLatencyTimer;	/* Pci agent Latency timer  */
+	MV_PCI_HEADER pciHeader;	/* Pci agent header type */
+	MV_BOOL isMultiFunction;	/* Multi function support */
+	MV_BOOL isBISTCapable;	/* Self test capable */
+
+	MV_U32 subSysID;	/* Sub System ID */
+	MV_U32 subSysVenID;	/* Sub System Vendor ID */
+
+	MV_BOOL isExpRom;	/* Expantion Rom support */
+	MV_U32 expRomAddr;	/* Expantion Rom pointer */
+
+	MV_U32 capListPointer;	/* Capability list pointer */
+
+	MV_U32 irqLine;	/* IRQ line  */
+	MV_PCI_INT_PIN intPin;	/* Interrupt pin */
+	MV_U32 minGrant;	/* Minimum grant */
+	MV_U32 maxLatency;	/* Maximum latency */
+
+	MV_U32 funtionsNum;	/* pci agent total functions number */
+
+	MV_U32 barsNum;
+	MV_U8 type[60];	/* class name of the pci agent */
+
+} MV_PCI_DEVICE;
+
+/* PCI gloabl functions */
+MV_STATUS mvPciClassNameGet(MV_U32 classCode, MV_8 *pType);
+
+/* Performs a full scan on both PCIs and returns all possible details on the
+   agents found on the bus. */
+MV_STATUS mvPciScan(MV_U32 pciIf, MV_PCI_DEVICE *pPciAgents, MV_U32 *pPciAgentsNum);
+
+#endif /* #ifndef __INCmvPciUtilsh */
--- a/arch/arm/plat-armada/mv_hal/pex/mvPex.c
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPex.c
@@ -229,18 +229,11 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX
 	}
 	/* now wait 1ms to be sure the link is valid */
 	mvOsDelay(1);
-
 	/* Check if we have link */
 	if (MV_REG_READ(PEX_STATUS_REG(pexIf)) & PXSR_DL_DOWN) {
 		/*mvOsPrintf("PEX%d interface detected no Link.\n", pexIf);*/
 		return MV_NO_SUCH;
 	}
-#if 0
-	if (MV_PEX_WITDH_X1 == pexMode.pexWidth)
-		mvOsPrintf("PEX%d interface detected Link X1\n", pexIf);
-	else
-		mvOsPrintf("PEX%d interface detected Link X4\n", pexIf);
-#endif
 #ifdef PCIE_VIRTUAL_BRIDGE_SUPPORT
 	mvPexVrtBrgInit(pexIf);
 #endif
@@ -268,17 +261,7 @@ MV_U32 mvPexModeGet(MV_U32 pexIf, MV_PEX
 
 	if (pexIf >= MV_PEX_MAX_IF)
 		return MV_BAD_PARAM;
-#if 0 /* maen - disabled because there is a conflict with SysPexInit
-	sysPexInit need pexMode, however pexHalData[pexIf].maxPexIf is needed in mvPexModeGe */
-      */
-	/* Parameter checking   */
-	if (PEX_DEFAULT_IF != pexIf) {
-		if (pexIf >= pexHalData[pexIf].maxPexIf) {
-			mvOsPrintf("mvPexModeGet: ERR. Invalid PEX interface %d\n", pexIf);
-			return MV_ERROR;
-		}
-	}
-#endif
+
 
 	pexData = MV_REG_READ(PEX_CTRL_REG(pexIf));
 
@@ -300,13 +283,7 @@ MV_U32 mvPexModeGet(MV_U32 pexIf, MV_PEX
 		pexMode->pexWidth = MV_PEX_WITDH_INVALID;
 	}
 	else { /* We have Link negotiation started */
-		if ((MV_REG_READ(PEX_DBG_STATUS_REG(pexIf))) == 0x7e)
 			pexMode->pexLinkUp = MV_TRUE;
-		else {
-			mvOsPrintf("Link negotiation failed ");
-			pexMode->pexLinkUp = MV_FALSE;
-		}
-
 		/* We have link. The link width is now valid */
 		pexData = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_LINK_CTRL_STAT_REG));
 		pexMode->pexWidth = ((pexData & PXLCSR_NEG_LNK_WDTH_MASK) >> PXLCSR_NEG_LNK_WDTH_OFFS);
@@ -412,7 +389,6 @@ MV_U32 mvPexHwConfigRead(MV_U32 pexIf, M
 				return MV_ERROR;
 		}
 	}
-
 	/* Creating PEX address to be passed */
 	pexData = (bus << PXCAR_BUS_NUM_OFFS);
 	pexData |= (dev << PXCAR_DEVICE_NUM_OFFS);
@@ -426,7 +402,6 @@ MV_U32 mvPexHwConfigRead(MV_U32 pexIf, M
 
 	/* Write the address to the PEX configuration address register */
 	MV_REG_WRITE(PEX_CFG_ADDR_REG(pexIf), pexData);
-
 	DB(mvOsPrintf("mvPexConfigRead:address pexData=%x ", pexData));
 
 	/* In order to let the PEX controller absorbed the address of the read  */
@@ -436,135 +411,9 @@ MV_U32 mvPexHwConfigRead(MV_U32 pexIf, M
 
 	/* cleaning Master Abort */
 	MV_REG_BIT_SET(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_STATUS_AND_COMMAND), PXSAC_MABORT);
-#if 0
-	/* Guideline (GL# PCI Express-1) Erroneous Read Data on Configuration   */
-	/* This guideline is relevant for all devices except of the following devices:
-	   88F5281-BO and above, 88F5181L-A0 and above, 88F1281 A0 and above
-	   88F6183 A0 and above, 88F6183L  */
-	ctrlModel = pexHalData[pexIf].ctrlModel;
-	if (((dev != localDev) || (bus != localBus)) &&
-			(!(MV_5281_DEV_ID == ctrlModel) &&
-			 !((MV_5181_DEV_ID == ctrlModel) && (mvCtrlRevGet() >= MV_5181L_A0_REV)) &&
-			 !(MV_1281_DEV_ID == ctrlModel) &&
-			 !(MV_6183_DEV_ID == ctrlModel) &&
-			 !(MV_6183L_DEV_ID == ctrlModel) &&
-			 !(MV_6281_DEV_ID == ctrlModel) &&
-			 !(MV_6282_DEV_ID == ctrlModel) &&
-			 !(MV_6192_DEV_ID == ctrlModel) &&
-			 !(MV_6190_DEV_ID == ctrlModel) &&
-			 !(MV_6180_DEV_ID == ctrlModel) && !(MV_6280_DEV_ID == ctrlModel) && !(MV_78XX0_DEV_ID == ctrlModel)
-			)) {
-
-		/* PCI-Express configuration read work-around */
-
-		/* we will use one of the Punit (AHBToMbus) windows to access the xbar
-		   and read the data from there */
-		/*
-		   Need to configure the 2 free Punit (AHB to MBus bridge)
-		   address decoding windows:
-		   Configure the flash Window to handle Configuration space requests
-		   for PEX0/1:
-		   1.    write 0x7931/0x7941 to the flash window and the size,
-		   79-xbar attr (pci cfg), 3/4-xbar target (pex0/1), 1-WinEn
-		   2.    write base to flash window
-
-		   Configuration transactions from the CPU should write/read the data
-		   to/from address of the form:
-		   addr[31:28] = 0x5 (for PEX0) or 0x6 (for PEX1)
-		   addr[27:24] = extended register number
-		   addr[23:16] = bus number
-		   addr[15:11] = device number
-		   addr[10:8]   = function number
-		   addr[7:0]     = register number
-		 */
-
-#include "ctrlEnv/sys/mvAhbToMbus.h"
-		{
-			MV_U32 winNum;
-			MV_AHB_TO_MBUS_DEC_WIN originWin;
-			MV_U32 pciAddr = 0;
-			MV_U32 remapLow = 0, remapHigh = 0;
-
-			/*
-			   We will use DEV_CS2\Flash window for this workarround
-			 */
-
-			winNum = mvAhbToMbusWinTargetGet(PEX_CONFIG_RW_WA_TARGET);
-
-			/* save remap values if exist */
-			if ((1 == winNum) || (0 == winNum)) {
-				remapLow = MV_REG_READ(AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum));
-				remapHigh = MV_REG_READ(AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum));
-
-			}
-
-			/* save the original window values */
-			mvAhbToMbusWinGet(winNum, &originWin);
-
-			if (PEX_CONFIG_RW_WA_USE_ORIGINAL_WIN_VALUES) {
-				/* set the window as xbar window */
-				if (pexIf) {
-					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum),
-						     (0x7931 | (((originWin.addrWin.size >> 16) - 1)) << 16));
-				} else {
-					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum),
-						     (0x7941 | (((originWin.addrWin.size >> 16) - 1)) << 16));
-				}
-
-				MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(winNum), originWin.addrWin.baseLow);
-
-				/*pciAddr = originWin.addrWin.baseLow; */
-				pciAddr = (MV_U32) CPU_MEMIO_UNCACHED_ADDR((MV_U32) originWin.addrWin.baseLow);
-
-			} else {
-				/* set the window as xbar window */
-				if (pexIf) {
-					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum),
-						     (0x7931 | (((PEX_CONFIG_RW_WA_SIZE >> 16) - 1)) << 16));
-				} else {
-					MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum),
-						     (0x7941 | (((PEX_CONFIG_RW_WA_SIZE >> 16) - 1)) << 16));
-				}
-
-				MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(winNum), PEX_CONFIG_RW_WA_BASE);
-
-				pciAddr = (MV_U32) CPU_MEMIO_UNCACHED_ADDR(PEX_CONFIG_RW_WA_BASE);
-			}
-
-			/* remap should be as base */
-			if ((1 == winNum) || (0 == winNum)) {
-				MV_REG_WRITE(AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum), pciAddr);
-				MV_REG_WRITE(AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum), 0);
-
-			}
-
-			/* extended register space */
-			pciAddr |= (bus << 16);
-			pciAddr |= (dev << 11);
-			pciAddr |= (func << 8);
-			pciAddr |= (regOff & PXCAR_REG_NUM_MASK);	/* lgacy register space */
-
-			pexData = *(MV_U32 *) pciAddr;
-			pexData = MV_32BIT_LE(pexData);	/* Data always in LE */
-
-			/* restore the original window values */
-			mvAhbToMbusWinSet(winNum, &originWin);
-
-			/* restore original remap values */
-			if ((1 == winNum) || (0 == winNum)) {
-				MV_REG_WRITE(AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum), remapLow);
-				MV_REG_WRITE(AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum), remapHigh);
-
-			}
-		}
-	} else
-#endif
-	{
 		/* Read the Data returned in the PEX Data register */
 		pexData = MV_REG_READ(PEX_CFG_DATA_REG(pexIf));
 
-	}
-
 	DB(mvOsPrintf("mvPexConfigRead: got : %x \n", pexData));
 
 	return pexData;
@@ -724,8 +573,6 @@ MV_STATUS mvPexHwConfigWrite(MV_U32 pexI
 MV_STATUS mvPexMasterEnable(MV_U32 pexIf, MV_BOOL enable)
 {
 	MV_U32 pexCommandStatus;
-	MV_U32 localBus;
-	MV_U32 localDev;
 
 	/* Parameter checking   */
 	if (pexIf >= pexHalData[pexIf].maxPexIf) {
@@ -733,9 +580,6 @@ MV_STATUS mvPexMasterEnable(MV_U32 pexIf
 		return MV_ERROR;
 	}
 
-	localBus = mvPexLocalBusNumGet(pexIf);
-	localDev = mvPexLocalDevNumGet(pexIf);
-
 	pexCommandStatus = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(pexIf, PEX_STATUS_AND_COMMAND));
 
 	if (MV_TRUE == enable)
@@ -823,8 +667,6 @@ MV_STATUS mvPexSlaveEnable(MV_U32 pexIf,
 MV_STATUS mvPexLocalBusNumSet(MV_U32 pexIf, MV_U32 busNum)
 {
 	MV_U32 pexStatus;
-	MV_U32 localBus;
-	MV_U32 localDev;
 
 	/* Parameter checking   */
 	if (pexIf >= pexHalData[pexIf].maxPexIf) {
@@ -836,9 +678,6 @@ MV_STATUS mvPexLocalBusNumSet(MV_U32 pex
 		return MV_ERROR;
 	}
 
-	localBus = mvPexLocalBusNumGet(pexIf);
-	localDev = mvPexLocalDevNumGet(pexIf);
-
 	pexStatus = MV_REG_READ(PEX_STATUS_REG(pexIf));
 
 	pexStatus &= ~PXSR_PEX_BUS_NUM_MASK;
@@ -911,8 +750,6 @@ MV_U32 mvPexLocalBusNumGet(MV_U32 pexIf)
 MV_STATUS mvPexLocalDevNumSet(MV_U32 pexIf, MV_U32 devNum)
 {
 	MV_U32 pexStatus;
-	MV_U32 localBus;
-	MV_U32 localDev;
 
 	if (pexIf >= MV_PEX_MAX_IF)
 		return MV_BAD_PARAM;
@@ -927,9 +764,6 @@ MV_STATUS mvPexLocalDevNumSet(MV_U32 pex
 		return MV_BAD_PARAM;
 	}
 
-	localBus = mvPexLocalBusNumGet(pexIf);
-	localDev = mvPexLocalDevNumGet(pexIf);
-
 	pexStatus = MV_REG_READ(PEX_STATUS_REG(pexIf));
 
 	pexStatus &= ~PXSR_PEX_DEV_NUM_MASK;
@@ -1000,7 +834,6 @@ MV_VOID mvPexPhyRegWrite(MV_U32 pexIf, M
 	}
 	regAddr = (((regOffset & 0x3fff) << 16) | value);
 	MV_REG_WRITE(PEX_PHY_ACCESS_REG(pexIf), regAddr);
-
 }
 
 /*******************************************************************************
@@ -1125,28 +958,3 @@ MV_VOID mvPexPhyPowerDown(MV_U32 pexIf)
 	MV_REG_WRITE(PEX_PHY_ACCESS_REG(pexIf), 0x20800087);
 	return;
 }
-
-#if 0
-/*  These APIs will be removed, OS glue should call the mvCtrlPwerClkxxx() */
-/*  functions directly. */
-MV_BOOL mvPexIsPowerUp(MV_U32 pexIf)
-{
-	if (pexIf >= pexHalData[pexIf].maxPexIf) {
-		mvOsPrintf("mvPexIsPowerUp: ERR. Invalid PEX interface %d\n", pexIf);
-		return MV_FALSE;
-	}
-	return mvCtrlPwrClckGet(PEX_UNIT_ID, pexIf);
-}
-
-MV_VOID mvPexPowerDown(MV_U32 pexIf)
-{
-	MV_U32 ctrlModel = pexHalData[pexIf].ctrlModel;
-
-	if ((ctrlModel == MV_78XX0_DEV_ID) ||
-			(ctrlModel == MV_76100_DEV_ID) || (ctrlModel == MV_78100_DEV_ID) || (ctrlModel == MV_78200_DEV_ID)) {
-		mvCtrlPwrClckSet(PEX_UNIT_ID, pexIf, MV_FALSE);
-	} else {
-		MV_REG_WRITE((0x41B00 - (pexIf) * 0x10000), 0x20800087);
-	}
-}
-#endif
--- a/arch/arm/plat-armada/mv_hal/pex/mvPexAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPexAddrDec.c
@@ -103,10 +103,6 @@ MV_U32 pexDevBarPrioTable[] = {
 
 static MV_STATUS pexWinOverlapDetect(MV_U32 pexIf, MV_U32 winNum, MV_ADDR_WIN *pAddrWin);
 /* NOTE: PEX Overlap Detection is disabled to support Muli CS DRAM - Need to be fixed */
-#if 0
-static MV_STATUS pexBarIsValid(MV_U32 baseLow, MV_U32 size);
-static MV_BOOL pexBarOverlapDetect(MV_U32 pexIf, MV_U32 barNum, MV_ADDR_WIN *pAddrWin);
-#endif
 static MV_BOOL pexIsWinWithinBar(MV_U32 pexIf, MV_ADDR_WIN *pAddrWin);
 
 /*******************************************************************************
@@ -249,15 +245,7 @@ MV_STATUS mvPexWinInit(MV_U32 pexIf, MV_
 	}
 
 /* NOTE: PEX Overlap Detection is disabled to support Muli CS DRAM - Need to be fixed */
-#if 0
-	/* check if the size and base are valid */
-	if (MV_TRUE == pexBarOverlapDetect(pexIf, bar, &pexBar.addrWin)) {
-		mvOsPrintf("mvPexInit:Warning :Bar %d size is illigal\n", bar);
-		mvOsPrintf("it will be disabled\n");
-		mvOsPrintf("please check Pex and CPU windows configuration\n");
-#endif
-	if (0) {
-	} else {
+	{
 		pexBar.enable = MV_TRUE;
 
 		/* configure the bar */
@@ -537,11 +525,6 @@ MV_STATUS mvPexTargetWinRead(MV_U32 pexI
 	else
 		pAddrDecWin->enable = MV_FALSE;
 
-#if 0
-	if (-1 == pAddrDecWin->addrWin.size)
-		return MV_ERROR;
-#endif
-
 	/* get target bar */
 	if ((sizeReg & PXWCR_WIN_BAR_MAP_MASK) == PXWCR_WIN_BAR_MAP_BAR1)
 		pexWin->targetBar = 1;
@@ -605,14 +588,8 @@ MV_STATUS mvPexTargetWinEnable(MV_U32 pe
 			mvOsPrintf("mvPexTargetWinEnable: mvPexTargetWinRead Failed\n");
 			return MV_ERROR;
 		}
-/* NOTE: PEX Overlap Detection is disabled to support Muli CS DRAM - Need to be fixed */
-#if 0
-		/* Check if the requested window overlaps with current windows  */
-		if (MV_TRUE == pexWinOverlapDetect(pexIf, winNum, &addrDecWin->addrWin)) {
-			mvOsPrintf("mvPexTargetWinEnable: ERR. Target %d overlap\n", winNum);
-			return MV_BAD_PARAM;
-		}
-#endif
+
+		/* NOTE: PEX Overlap Detection is disabled to support Muli CS DRAM - Need to be fixed */
 		if (MV_FALSE == pexIsWinWithinBar(pexIf, &addrDecWin->addrWin)) {
 			mvOsPrintf("mvPexTargetWinEnable: Win %d should be in bar boundries\n", winNum);
 			return MV_BAD_PARAM;
@@ -739,40 +716,12 @@ MV_STATUS mvPexBarSet(MV_U32 pexIf, MV_U
 		return MV_BAD_PARAM;
 	}
 
-/* NOTE: PEX Overlap Detection is disabled to support Muli CS DRAM - Need to be fixed */
-#if 0
-	if (pAddrWin->addrWin.size == 0) {
-		mvOsPrintf("mvPexBarSet: Size zero is illegal\n");
-		return MV_BAD_PARAM;
-	}
-
-	/* Check if the window complies with PEX spec                       */
-	if (MV_TRUE != pexBarIsValid(pAddrWin->addrWin.baseLow, pAddrWin->addrWin.size)) {
-		mvOsPrintf("mvPexBarSet: ERR. Target %d window invalid\n", barNum);
-		return MV_BAD_PARAM;
-	}
-
-	/* 2) Check if the requested bar overlaps with current bars         */
-	if (MV_TRUE == pexBarOverlapDetect(pexIf, barNum, &pAddrWin->addrWin)) {
-		mvOsPrintf("mvPexBarSet: ERR. Target %d overlap\n", barNum);
-		return MV_BAD_PARAM;
-	}
-#endif
 	/* Get size register value according to window size         */
 	sizeToReg = (pAddrWin->addrWin.size / PXBCR_BAR_SIZE_ALIGNMENT) - 1;
 
 	/* Read bar size */
 	if (PEX_INTER_REGS_BAR != barNum) {	/* internal registers have no size */
 		regSize = MV_REG_READ(PEX_BAR_CTRL_REG(pexIf, barNum));
-
-/* NOTE: PEX Bar Valid Size Detection is disabled to support Muli CS DRAM - Need to be fixed */
-#if 0
-		/* Size parameter validity check.                                   */
-		if (-1 == sizeToReg) {
-			mvOsPrintf("mvPexBarSet: ERR. Target BAR %d size invalid.\n", barNum);
-			return MV_BAD_PARAM;
-		}
-#endif
 		regSize &= ~PXBCR_BAR_SIZE_MASK;
 		regSize |= (sizeToReg << PXBCR_BAR_SIZE_OFFS);
 		MV_REG_WRITE(PEX_BAR_CTRL_REG(pexIf, barNum), regSize);
@@ -1014,88 +963,6 @@ static MV_BOOL pexIsWinWithinBar(MV_U32
 }
 
 /*******************************************************************************
-* pexBarOverlapDetect - Detect address windows overlapping
-*
-* DESCRIPTION:
-*       This function detects address window overlapping of a given address
-*       window in PEX BARs.
-*
-* INPUT:
-*       pAddrWin - Address window to be checked.
-*       bar      - BAR to be accessed by slave.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if the given address window overlap current address
-*       decode map, MV_FALSE otherwise.
-*
-*******************************************************************************/
-/* NOTE: PEX Overlap Detection is disabled to support Muli CS DRAM - Need to be fixed */
-#if 0
-static MV_BOOL pexBarOverlapDetect(MV_U32 pexIf, MV_U32 barNum, MV_ADDR_WIN *pAddrWin)
-{
-	MV_U32 bar;
-	MV_PEX_BAR barDecWin;
-
-	for (bar = 0; bar < PEX_MAX_BARS; bar++) {
-		/* don't check our target or illegal targets */
-		if (barNum == bar)
-			continue;
-
-		/* Get window parameters        */
-		if (MV_OK != mvPexBarGet(pexIf, bar, &barDecWin)) {
-			mvOsPrintf("pexBarOverlapDetect: ERR. TargetWinGet failed\n");
-			return MV_ERROR;
-		}
-
-		/* don't check disabled bars */
-		if (barDecWin.enable == MV_FALSE)
-			continue;
-
-		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &barDecWin.addrWin)) {
-			mvOsPrintf("pexBarOverlapDetect: winNum %d overlap current %d\n", barNum, bar);
-			return MV_TRUE;
-		}
-	}
-	return MV_FALSE;
-}
-#endif
-
-/*******************************************************************************
-* pexBarIsValid - Check if the given address window is valid
-*
-* DESCRIPTION:
-*		PEX spec restrict BAR base to be aligned to BAR size.
-*		This function checks if the given address window is valid.
-*
-* INPUT:
-*       baseLow - 32bit low base address.
-*       size    - Window size.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if the address window is valid, MV_FALSE otherwise.
-*
-*******************************************************************************/
-/* NOTE: PEX Overlap Detection is disabled to support Muli CS DRAM - Need to be fixed */
-#if 0
-static MV_STATUS pexBarIsValid(MV_U32 baseLow, MV_U32 size)
-{
-	/* PCI spec restrict BAR base to be aligned to BAR size         */
-	if (MV_IS_NOT_ALIGN(baseLow, size))
-		return MV_ERROR;
-	else
-		return MV_TRUE;
-
-	return MV_TRUE;
-}
-#endif
-
-/*******************************************************************************
 * pexBarRegInfoGet - Get BAR register information
 *
 * DESCRIPTION:
@@ -1174,91 +1041,3 @@ const MV_8 *pexBarNameGet(MV_U32 bar)
 		return "Bar unknown";
 	}
 }
-
-#if 0
-/*******************************************************************************
-* mvPexAddrDecShow - Print the PEX address decode map (BARs and windows).
-*
-* DESCRIPTION:
-*		This function print the PEX address decode map (BARs and windows).
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-MV_VOID mvPexAddrDecShow(MV_VOID)
-{
-	MV_PEX_BAR pexBar;
-	MV_PEX_DEC_WIN win;
-	MV_U32 pexIf;
-	MV_U32 bar, winNum;
-
-	for (pexIf = 0; pexIf < mvCtrlPexMaxIfGet(); pexIf++) {
-		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexIf))
-			continue;
-		mvOsOutput("\n");
-		mvOsOutput("PEX%d:\n", pexIf);
-		mvOsOutput("-----\n");
-
-		mvOsOutput("\nPex Bars \n\n");
-
-		for (bar = 0; bar < PEX_MAX_BARS; bar++) {
-			memset(&pexBar, 0, sizeof(MV_PEX_BAR));
-
-			mvOsOutput("%s ", pexBarNameGet(bar));
-
-			if (mvPexBarGet(pexIf, bar, &pexBar) == MV_OK) {
-				if (pexBar.enable) {
-					mvOsOutput("base %08x, ", pexBar.addrWin.baseLow);
-					mvSizePrint(pexBar.addrWin.size);
-					mvOsOutput("\n");
-				} else
-					mvOsOutput("disable\n");
-			}
-		}
-		mvOsOutput("\nPex Decode Windows\n\n");
-
-		for (winNum = 0; winNum < PEX_MAX_TARGET_WIN - 2; winNum++) {
-			memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
-
-			mvOsOutput("win%d - ", winNum);
-
-			if (mvPexTargetWinGet(pexIf, winNum, &win) == MV_OK) {
-				if (win.enable) {
-					mvOsOutput("%s base %08x, ",
-						   mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
-					mvOsOutput("....");
-					mvSizePrint(win.addrWin.size);
-
-					mvOsOutput("\n");
-				} else
-					mvOsOutput("disable\n");
-			}
-		}
-
-		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
-
-		mvOsOutput("default win - ");
-
-		if (mvPexTargetWinGet(pexIf, MV_PEX_WIN_DEFAULT, &win) == MV_OK) {
-			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
-			mvOsOutput("\n");
-		}
-		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
-
-		mvOsOutput("Expansion ROM - ");
-
-		if (mvPexTargetWinGet(pexIf, MV_PEX_WIN_EXP_ROM, &win) == MV_OK) {
-			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
-			mvOsOutput("\n");
-		}
-	}
-}
-
-#endif
--- a/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h
@@ -185,7 +185,6 @@ extern "C" {
 #define PEX_TL_CTRL_REG(pexIf)				(MV_PEX_IF_REGS_BASE(pexIf) - (pexIf)*0x10000)
 #define PEX_RAM_PARITY_CTRL_REG(pexIf) 			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A50)
 #define PEX_DBG_CTRL_REG(pexIf) 			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A60)
-#define PEX_DBG_STATUS_REG(pexIf) 			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A64)
 
 #define PEX_LINK_CTRL_STATUS_REG(pexIf) 		((MV_PEX_IF_REGS_BASE(pexIf)) + 0x70)
 
--- a/arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS1339.h
+++ b/arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS1339.h
@@ -100,4 +100,3 @@ MV_VOID mvRtcDS1339AlarmSet(MV_RTC_TIME
 
 
 #endif  /* __INCmvDS1511h */
-
--- a/arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS1339Reg.h
+++ b/arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS1339Reg.h
@@ -373,4 +373,3 @@ extern "C" {
 #endif
 
 #endif /* __INCmvDS1339Regh */
-
--- a/arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS133x.h
+++ b/arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS133x.h
@@ -104,4 +104,3 @@ MV_VOID mvRtcDS133xAlarmSet(MV_RTC_TIME
 
 
 #endif  /* __INCmvDS133xh */
-
--- a/arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS133xReg.h
+++ b/arch/arm/plat-armada/mv_hal/rtc/ext_rtc/mvDS133xReg.h
@@ -374,4 +374,3 @@ extern "C" {
 #endif
 
 #endif /* __INCmvDS133xRegh */
-
--- a/arch/arm/plat-armada/mv_hal/rtc/mvCompVer.txt
+++ b/arch/arm/plat-armada/mv_hal/rtc/mvCompVer.txt
@@ -1,4 +1,3 @@
 Global HAL Version: FEROCEON_HAL_3_1_7
 Unit HAL Version: 3.1.3
 Description: This component includes an implementation of the unit HAL drivers
-
--- a/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSata.c
+++ b/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSata.c
@@ -1279,11 +1279,9 @@ static void handleEdmaInterrupt(MV_SATA_
 
 static void handleEdmaError(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
 {
-	MV_SATA_CHANNEL *pSataChannel;
 	MV_U32 eDmaErrorCause = 0;
 	MV_BUS_ADDR_T ioBaseAddr = pAdapter->adapterIoBaseAddress;
 
-	pSataChannel = pAdapter->sataChannel[channelIndex];
 
 	eDmaErrorCause = MV_REG_READ_DWORD(ioBaseAddr,
 					   getEdmaRegOffset(channelIndex) + MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET);
@@ -1897,10 +1895,7 @@ static void handleDeviceInterrupt(MV_SAT
 
 	mvOsSemTake(&pSataChannel->semaphore);
 	if (pSataChannel->ErrorHandlingInfo.state == MV_ERROR_HANDLING_STATE_WAIT_FOR_BUSY) {
-		MV_U8 ATAstatus;
 
-		ATAstatus = MV_REG_READ_BYTE(pAdapter->adapterIoBaseAddress,
-					     pSataChannel->eDmaRegsOffset + MV_ATA_DEVICE_STATUS_REG_OFFSET);
 		/* clear DevInterrupt */
 		MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
 				   MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
@@ -2148,17 +2143,6 @@ static void handlePIOInterrupt(MV_SATA_C
 				pCommandEntry->pCommandInfo->commandParams.packetCommand.transfered_data =
 				    pCommandEntry->pCommandInfo->commandParams.packetCommand.buffer_len;
 
-#if 0
-				/* chech if the BMDMA still active */
-				if (BMDMA_status & MV_BIT0) {
-					mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG,
-						 "Packet Interrupt: BMDMA not finished yet. "
-						 "status 0x%08x, ATA status 0x%02x\n", BMDMA_status, ATAstatus);
-					/* wait for BMDMA done interrrupt */
-					pSataChannel->waitForBMDMA = MV_TRUE;
-					return;
-				}
-#endif
 				/* if BMDMA finished, call _resetBmDma to clear the Done interrupt */
 				_resetBmDma(pSataChannel->mvSataAdapter, pSataChannel->channelNumber);
 				/* chech if the BMDMA completed with errors */
@@ -4935,26 +4919,7 @@ MV_BOOLEAN mvSataInitAdapter(MV_SATA_ADA
 			}
 		}
 	}
-#if 0
-	/* Fix for 88SX60x1 FEr SATA#8 */
-	for (channelIndex = 0; channelIndex < pAdapter->numberOfChannels; channelIndex++) {
-		if (pAdapter->sataAdapterGeneration >= MV_SATA_GEN_II) {
-			regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
-						   getEdmaRegOffset(channelIndex) + MV_SATA_II_SATA_CONFIG_REG_OFFSET);
-			/* Fix for 88SX60x1 FEr SATA#8 */
-			/* according to the spec, bits [31:12] must be set to 0x009B1 */
-			regVal &= 0x00000FFF;
-			/* regVal |= MV_BIT12; */
-			regVal |= 0x009B1000;
 
-			MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
-					   getEdmaRegOffset(channelIndex) + MV_SATA_II_SATA_CONFIG_REG_OFFSET, regVal);
-			/* _channelHardReset(pAdapter, channelIndex); */
-		}
-
-		_fixPhyParams(pAdapter, channelIndex);
-	}
-#endif
 	if (pAdapter->hostInterface == MV_HOST_IF_PCI) {
 
 		MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
@@ -5339,7 +5304,6 @@ static MV_BOOLEAN _checkSStatusAfterHRes
 MV_BOOLEAN mvSataChannelHardReset(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
 {
 	MV_SATA_CHANNEL *pSataChannel;
-	MV_BUS_ADDR_T ioBaseAddr;
 	MV_U32 count = 0;
 
 	if (pAdapter == NULL) {
@@ -5348,7 +5312,6 @@ MV_BOOLEAN mvSataChannelHardReset(MV_SAT
 		return MV_FALSE;
 	}
 	pSataChannel = pAdapter->sataChannel[channelIndex];
-	ioBaseAddr = pAdapter->adapterIoBaseAddress;
 	if (pSataChannel == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: "
 			 "mvSataChannelHardReset Failed, channel data structure not "
@@ -5661,14 +5624,12 @@ MV_BOOLEAN mvSataConfigEdmaMode(MV_SATA_
 MV_BOOLEAN mvSataEnableChannelDma(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
 {
 	MV_SATA_CHANNEL *pSataChannel;
-	MV_BUS_ADDR_T ioBaseAddr;
 
 	if (pAdapter == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataEnableChannelDma"
 			 " Failed, Bad adapter data structure pointer\n");
 		return MV_FALSE;
 	}
-	ioBaseAddr = pAdapter->adapterIoBaseAddress;
 	pSataChannel = pAdapter->sataChannel[channelIndex];
 	if (pSataChannel == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataEnableChannelD"
@@ -5719,14 +5680,12 @@ MV_BOOLEAN mvSataEnableChannelDma(MV_SAT
 *******************************************************************************/
 MV_BOOLEAN mvSataDisableChannelDma(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
 {
-	MV_BUS_ADDR_T ioBaseAddr;
 
 	if (pAdapter == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataDisableChannelDma"
 			 " Failed, Bad adapter data structure pointer\n");
 		return MV_FALSE;
 	}
-	ioBaseAddr = pAdapter->adapterIoBaseAddress;
 	if (pAdapter->sataChannel[channelIndex] == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataDisableChannel"
 			 "Dma Failed, channel data structure is not allocated\n", pAdapter->adapterId, channelIndex);
@@ -6343,7 +6302,6 @@ MV_QUEUE_COMMAND_RESULT mvSataQueueComma
 {
 	MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
 	MV_QUEUED_COMMAND_ENTRY *pCommandEntry;
-	MV_U32 eDmaRegsOffset;
 	MV_U8 hostTag;
 	MV_U8 deviceTag;
 
@@ -6372,7 +6330,6 @@ MV_QUEUE_COMMAND_RESULT mvSataQueueComma
 		return MV_QUEUE_COMMAND_RESULT_BAD_PARAMS;
 	}
 #endif
-	eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
 	if (pSataChannel->queueCommandsEnabled == MV_FALSE) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: queued commands mode"
 			 " is disabled\n", pAdapter->adapterId, channelIndex);
@@ -6942,7 +6899,6 @@ MV_BOOLEAN mvSataDisableStaggeredSpinUp(
 
 MV_BOOLEAN mvSataSetInterfaceSpeed(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex, MV_SATA_IF_SPEED ifSpeed)
 {
-	MV_U32 SStatusOffset;
 	if (pAdapter == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
 			 "mvSataSetInterfaceSpeed Failed, Bad adapter data structure" " pointer\n");
@@ -6969,7 +6925,6 @@ MV_BOOLEAN mvSataSetInterfaceSpeed(MV_SA
 			mvOsSemRelease(&pSataChannel->semaphore);
 		}
 
-		SStatusOffset = getEdmaRegOffset(channelIndex) + MV_SATA_II_S_STATUS_REG_OFFSET;
 
 		if (ifSpeed == MV_SATA_IF_SPEED_1_5_GBPS) {
 			pAdapter->limitInterfaceSpeed[channelIndex] = MV_TRUE;
--- a/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c
@@ -282,58 +282,6 @@ MV_STATUS mvSataWinRead(MV_U32 dev, MV_U
 	return MV_OK;
 }
 
-#if 0
-/*******************************************************************************
-* mvSataAddrDecShow - Print the SATA address decode map.
-*
-* DESCRIPTION:
-*		This function print the SATA address decode map.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       None.
-*
-*******************************************************************************/
-MV_VOID mvSataAddrDecShow(MV_VOID)
-{
-	MV_SATA_DEC_WIN win;
-	int i, j;
-
-	for (j = 0; j < MV_SATA_MAX_CHAN; j++) {
-		if (MV_FALSE == mvCtrlPwrClckGet(SATA_UNIT_ID, j))
-			return;
-
-		mvOsOutput("\n");
-		mvOsOutput("SATA %d:\n", j);
-		mvOsOutput("----\n");
-
-		for (i = 0; i < MV_SATA_MAX_ADDR_DECODE_WIN; i++) {
-			memset(&win, 0, sizeof(MV_SATA_DEC_WIN));
-
-			mvOsOutput("win%d - ", i);
-
-			if (mvSataWinGet(j, i, &win) == MV_OK) {
-				if (win.enable) {
-					mvOsOutput("%s base %08x, ",
-						   mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
-					mvOsOutput("....");
-
-					mvSizePrint(win.addrWin.size);
-
-					mvOsOutput("\n");
-				} else
-					mvOsOutput("disable\n");
-			}
-		}
-	}
-}
-#endif
-
 /*******************************************************************************
 * mvSataWinInit - Initialize the integrated SATA target address window.
 *
--- a/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvStorageDev.c
+++ b/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvStorageDev.c
@@ -518,8 +518,6 @@ MV_BOOLEAN mvStorageDevATASoftResetDevic
 					  MV_U8 PMPort, MV_STORAGE_DEVICE_REGISTERS *registerStruct)
 {
 	MV_SATA_CHANNEL *pSataChannel;
-	MV_BUS_ADDR_T ioBaseAddr;
-	MV_U32 eDmaRegsOffset;
 	MV_BOOLEAN result;
 
 	if (pAdapter == NULL) {
@@ -528,7 +526,6 @@ MV_BOOLEAN mvStorageDevATASoftResetDevic
 		return MV_FALSE;
 	}
 	pSataChannel = pAdapter->sataChannel[channelIndex];
-	ioBaseAddr = pAdapter->adapterIoBaseAddress;
 	if (pSataChannel == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
 			 "re is not allocated\n", pAdapter->adapterId, channelIndex);
@@ -536,7 +533,6 @@ MV_BOOLEAN mvStorageDevATASoftResetDevic
 	}
 
 	mvOsSemTake(&pSataChannel->semaphore);
-	eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
 
 	if (pSataChannel->queueCommandsEnabled == MV_TRUE) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  mvStorageDevATASoft"
@@ -622,7 +618,6 @@ MV_BOOLEAN _isDeviceBsyBitOff(MV_SATA_CH
 MV_BOOLEAN mvStorageDevATAStartSoftResetDevice(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex, MV_U8 PMPort)
 {
 	MV_SATA_CHANNEL *pSataChannel;
-	MV_BUS_ADDR_T ioBaseAddr;
 
 	if (pAdapter == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevATASoftRes"
@@ -630,7 +625,6 @@ MV_BOOLEAN mvStorageDevATAStartSoftReset
 		return MV_FALSE;
 	}
 	pSataChannel = pAdapter->sataChannel[channelIndex];
-	ioBaseAddr = pAdapter->adapterIoBaseAddress;
 	if (pSataChannel == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
 			 "re is not allocated\n", pAdapter->adapterId, channelIndex);
@@ -677,7 +671,6 @@ MV_BOOLEAN mvStorageIsDeviceBsyBitOff(MV
 				      MV_U8 channelIndex, MV_STORAGE_DEVICE_REGISTERS *registerStruct)
 {
 	MV_SATA_CHANNEL *pSataChannel;
-	MV_BUS_ADDR_T ioBaseAddr;
 	MV_BOOLEAN result;
 
 	if (pAdapter == NULL) {
@@ -686,7 +679,6 @@ MV_BOOLEAN mvStorageIsDeviceBsyBitOff(MV
 		return MV_FALSE;
 	}
 	pSataChannel = pAdapter->sataChannel[channelIndex];
-	ioBaseAddr = pAdapter->adapterIoBaseAddress;
 	if (pSataChannel == NULL) {
 		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
 			 "re is not allocated\n", pAdapter->adapterId, channelIndex);
@@ -814,169 +806,6 @@ MV_BOOLEAN mvStorageDevATAExecuteNonUDMA
 	return result;
 }
 
-#if 0
-MV_BOOLEAN executePacketCommand(MV_SATA_ADAPTER *pAdapter,
-				MV_U8 channelIndex,
-				MV_NON_UDMA_PROTOCOL protocolType,
-				MV_U8 PMPort, MV_U16_PTR cdb, MV_U8 cdb_len, MV_U16_PTR dataBufPtr)
-{
-	MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
-	MV_BUS_ADDR_T ioBaseAddr = pAdapter->adapterIoBaseAddress;
-	MV_U32 eDmaRegsOffset;
-	MV_U32 i;
-	MV_U32 count;
-	MV_U8 ATAstatus;
-
-	mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG | MV_DEBUG_NON_UDMA_COMMAND, " %d %d send PACKET "
-		 " command: protocol(%d) cdb %p cdb len %p buffer %p \n", pAdapter->adapterId,
-		 channelIndex, protocolType, cdb, cdb_len, dataBufPtr);
-
-	eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
-	if ((PMPort) && ((pSataChannel->PMSupported == MV_FALSE) ||
-			 (pSataChannel->deviceType != MV_SATA_DEVICE_TYPE_PM))) {
-		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  executePacketCommand"
-			 " failed PM not supported for this channel\n",
-			 pSataChannel->mvSataAdapter->adapterId, pSataChannel->channelNumber);
-		mvOsSemRelease(&pSataChannel->semaphore);
-		return MV_FALSE;
-	}
-	{
-		if (isStorageDevReadyForPIO(pSataChannel) == MV_FALSE) {
-			mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
-				 " %d %d : Error in Issue NON UDMA command:"
-				 " isStorageDevReadyForPIO failed\n", pAdapter->adapterId, channelIndex);
-
-			return MV_FALSE;
-		}
-	}
-	_setActivePMPort(pSataChannel, PMPort);
-	if (pSataChannel->queueCommandsEnabled == MV_TRUE) {
-		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  PIO command failed:"
-			 "EDMA is active\n", pSataChannel->mvSataAdapter->adapterId, pSataChannel->channelNumber);
-		return MV_FALSE;
-	}
-
-	if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
-		disableStorageDevInterrupt(pSataChannel);
-
-	MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_FEATURES_REG_OFFSET, 0);
-
-	MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET, 0);
-
-	MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_LBA_LOW_REG_OFFSET, 0);
-
-	MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_LBA_MID_REG_OFFSET, 0);
-
-	MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET, 0x20);
-
-	MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_HEAD_REG_OFFSET, 0);
-	MV_CPU_WRITE_BUFFER_FLUSH();
-
-	/* 88SX60X1 FEr SATA #16 */
-	if (pAdapter->sataAdapterGeneration >= MV_SATA_GEN_II)
-		enableStorageDevInterrupt(pSataChannel);
-
-	MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_COMMAND_REG_OFFSET, MV_ATA_COMMAND_PACKET);
-
-	/* Wait for PIO Setup or completion */
-	if (waitWhileStorageDevIsBusy(pAdapter, ioBaseAddr, eDmaRegsOffset, 3100, 10000) == MV_FALSE) {
-		enableStorageDevInterrupt(pSataChannel);
-		return MV_FALSE;
-	}
-	if (protocolType == MV_NON_UDMA_PROTOCOL_PACKET_PIO_NON_DATA) {
-		enableStorageDevInterrupt(pSataChannel);
-		pSataChannel->recoveredErrorsCounter = 0;
-		return MV_TRUE;
-	}
-
-	/* Check the status register on DATA request commands */
-	ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_STATUS_REG_OFFSET);
-	if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I) {
-		if (!(ATAstatus & MV_ATA_DATA_REQUEST_STATUS)) {
-			mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: DRQ bit in ATA STATUS"
-				 " register is not set\n", pAdapter->adapterId, channelIndex);
-			enableStorageDevInterrupt(pSataChannel);
-			return MV_FALSE;
-		}
-	}
-	if (pAdapter->sataAdapterGeneration >= MV_SATA_GEN_II) {
-
-		if (waitForDRQ(pAdapter, ioBaseAddr, eDmaRegsOffset, 500, 10000)
-		    == MV_FALSE) {
-			mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: DRQ bit in ATA STATUS"
-				 " register is not set\n", pAdapter->adapterId, channelIndex);
-			enableStorageDevInterrupt(pSataChannel);
-			return MV_FALSE;
-		}
-	}
-	for (i = 0; i < cdb_len; i++) {
-		MV_REG_WRITE_WORD(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_PIO_DATA_REG_OFFSET, cdb[i]);
-		MV_CPU_WRITE_BUFFER_FLUSH();
-	}
-
-	if (waitForDRQ(pAdapter, ioBaseAddr, eDmaRegsOffset, 500, 10000)
-	    == MV_FALSE) {
-		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: DRQ bit in ATA STATUS"
-			 " register is not set\n", pAdapter->adapterId, channelIndex);
-		enableStorageDevInterrupt(pSataChannel);
-		return MV_FALSE;
-	}
-
-	mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " Status: %x\n",
-		 MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_STATUS_REG_OFFSET));
-
-	mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " Sector Count: %x\n",
-		 MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET));
-
-	mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " LBA Mid: %x\n",
-		 MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_LBA_MID_REG_OFFSET));
-
-	mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " LBA High: %x\n",
-		 MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET));
-
-	count = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_LBA_MID_REG_OFFSET) +
-	    (MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET) << 8);
-	count >>= 1;
-	for (i = 0; i < count; i++) {
-		if (protocolType == MV_NON_UDMA_PROTOCOL_PACKET_PIO_DATA_IN) {
-			dataBufPtr[i] = MV_REG_READ_WORD(ioBaseAddr, eDmaRegsOffset +
-							 MV_ATA_DEVICE_PIO_DATA_REG_OFFSET);
-		} else {
-			MV_REG_WRITE_WORD(ioBaseAddr, eDmaRegsOffset +
-					  MV_ATA_DEVICE_PIO_DATA_REG_OFFSET, dataBufPtr[i]);
-
-		}
-	}
-
-	/* Wait for the storage device to be available */
-	mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: on non-UDMA sequence - checking if"
-		 " device is has finished the command\n", pAdapter->adapterId, channelIndex);
-
-	if (waitWhileStorageDevIsBusy(pAdapter, ioBaseAddr, eDmaRegsOffset, 50000, 100) == MV_FALSE) {
-		mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " Status: %x\n",
-			 MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_STATUS_REG_OFFSET));
-
-		enableStorageDevInterrupt(pSataChannel);
-		return MV_FALSE;
-	}
-
-	if (pAdapter->sataAdapterGeneration >= MV_SATA_GEN_II) {
-
-		if (waitForDRQToClear(pAdapter, ioBaseAddr, eDmaRegsOffset, 50000, 100)
-		    == MV_FALSE) {
-			enableStorageDevInterrupt(pSataChannel);
-			return MV_FALSE;
-		}
-	}
-
-	mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: Finish NonUdma Command. Status=0x%02x"
-		 "\n", pAdapter->adapterId, channelIndex,
-		 MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_STATUS_REG_OFFSET));
-	enableStorageDevInterrupt(pSataChannel);
-	pSataChannel->recoveredErrorsCounter = 0;
-	return MV_TRUE;
-}
-#endif /* 0 */
 MV_BOOLEAN executeNonUDMACommand(MV_SATA_ADAPTER *pAdapter,
 				 MV_U8 channelIndex,
 				 MV_U8 PMPort,
--- a/arch/arm/plat-armada/mv_hal/sflash/mvSFlash.c
+++ b/arch/arm/plat-armada/mv_hal/sflash/mvSFlash.c
@@ -672,13 +672,7 @@ MV_STATUS mvSFlashSectorErase(MV_SFLASH_
     MV_STATUS ret;
     MV_U8 cmd[MV_SFLASH_SE_CMND_LENGTH];
     MV_U32 secAddr;
-#if 0
-    MV_U32 i;
-    MV_U32 *pW = (MV_U32 *) (secAddr + pFlinfo->baseAddr);
-    MV_U32 erasedWord = 0xFFFFFFFF;
-    MV_U32 wordsPerSector = (pFlinfo->sectorSize / sizeof(MV_U32));
-    MV_BOOL eraseNeeded = MV_FALSE;
-#endif
+
     /* check for NULL pointer */
     if (pFlinfo == NULL) {
 	mvOsPrintf("%s ERROR: Null pointer parameter!\n", __func__);
@@ -700,19 +694,6 @@ MV_STATUS mvSFlashSectorErase(MV_SFLASH_
 
     /* we don't want to access SPI in direct mode from in-direct API,
 	becasue of timing issue between CS asserts. */
-#if 0
-    /* First compare to FF and check if erase is needed */
-    for (i = 0; i < wordsPerSector; i++)  {
-	if (memcmp(pW, &erasedWord, sizeof(MV_U32)) != 0) {
-		eraseNeeded = MV_TRUE;
-		break;
-	}
-
-	++pW;
-    }
-    if (!eraseNeeded)
-	return MV_OK;
-#endif
 
     cmd[0] = sflash[pFlinfo->index].opcdSE;
 	cmd[1] = ((secAddr >> 16) & 0xFF);
@@ -1628,4 +1609,3 @@ const MV_8 *mvSFlashModelGet(MV_SFLASH_I
 
     return sflash[pFlinfo->index].deviceModel;
 }
-
--- a/arch/arm/plat-armada/mv_hal/spi/mvSpiCmnd.c
+++ b/arch/arm/plat-armada/mv_hal/spi/mvSpiCmnd.c
@@ -253,4 +253,3 @@ MV_STATUS mvSpiWriteThenRead(MV_U8 spiId
 
     return ret;
 }
-
--- a/arch/arm/plat-armada/mv_hal/spi/mvSpiSpec.h
+++ b/arch/arm/plat-armada/mv_hal/spi/mvSpiSpec.h
@@ -136,4 +136,3 @@ extern "C" {
 #endif
 
 #endif /* __INCmvSpiSpecH */
-
--- a/arch/arm/plat-armada/mv_hal/twsi/mvCompVer.txt
+++ b/arch/arm/plat-armada/mv_hal/twsi/mvCompVer.txt
@@ -1,4 +1,3 @@
 Global HAL Version: FEROCEON_HAL_3_1_7
 Unit HAL Version: 3.1.5
 Description: This component includes an implementation of the unit HAL drivers
-
--- a/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c
+++ b/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c
@@ -71,7 +71,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "mvTwsiSpec.h"
 #include "mvSysTwsiConfig.h"
 
-/*#define MV_DEBUG*/
+#undef MV_DEBUG
 #ifdef MV_DEBUG
 #define DB(x) x
 #define DB1(x) x
@@ -223,7 +223,7 @@ MV_STATUS mvTwsiStopBitSet(MV_U8 chanNum
 	/* check the status */
 	temp = twsiStsGet(chanNum);
 	if ((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
-		DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", val));
+		DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", temp));
 		return MV_RETRY;
 	} else if (temp != TWSI_NO_REL_STS_INT_FLAG_IS_KEPT_0) {
 		mvOsPrintf("TWSI: mvTwsiStopBitSet ERROR - status %x after Stop Bit. \n", temp);
--- a/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.h
+++ b/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.h
@@ -113,4 +113,3 @@ MV_STATUS mvTwsiWrite(MV_U8 chanNum, MV_
 #endif /* __cplusplus */
 
 #endif /* __INCmvTwsiH */
-
--- a/arch/arm/plat-armada/mv_hal/uart/mvCompVer.txt
+++ b/arch/arm/plat-armada/mv_hal/uart/mvCompVer.txt
@@ -1,4 +1,3 @@
 Global HAL Version: FEROCEON_HAL_3_1_7
 Unit HAL Version: 3.1.3
 Description: This component includes an implementation of the unit HAL drivers
-
--- a/arch/arm/plat-armada/mv_hal/uart/mvUart.c
+++ b/arch/arm/plat-armada/mv_hal/uart/mvUart.c
@@ -65,7 +65,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "mvUart.h"
 
 /* static variables */
-static volatile MV_UART_PORT * uartBase[MV_UART_MAX_CHAN];
+static volatile MV_UART_PORT * uartBase[MV_UART_MAX_CHAN]=
+{
+	mvUartBase(0),
+	mvUartBase(1),
+	mvUartBase(2),
+	mvUartBase(3)
+};
+
 
 /*******************************************************************************
 * mvUartInit - Init a uart port.
--- a/arch/arm/plat-armada/mv_hal/usb/api/mvUsbCh9.h
+++ b/arch/arm/plat-armada/mv_hal/usb/api/mvUsbCh9.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
--- a/arch/arm/plat-armada/mv_hal/usb/api/mvUsbDebug.h
+++ b/arch/arm/plat-armada/mv_hal/usb/api/mvUsbDebug.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -85,7 +85,7 @@ extern char    DEBUG_TRACE_ARRAY[TRACE_A
             {DEBUG_TRACE_ARRAY_COUNTER = 0;}                                        \
     }                                                                               \
 }
-                                                    
+
 #elif defined(MV_USB_TRACE_PRINT)
 
 #   define ARC_DEBUG_TRACE(flags, format, x...)           \
--- a/arch/arm/plat-armada/mv_hal/usb/api/mvUsbDefs.h
+++ b/arch/arm/plat-armada/mv_hal/usb/api/mvUsbDefs.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
--- a/arch/arm/plat-armada/mv_hal/usb/api/mvUsbDevApi.h
+++ b/arch/arm/plat-armada/mv_hal/usb/api/mvUsbDevApi.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -78,7 +78,7 @@ if they are not you need to modify the t
 #define  ARC_USB_SERVICE_STALL                (0x17)
 
 typedef pointer _usb_device_handle;
-typedef void (*USB_SERVICE_FUNC)(void* handle, uint_8, boolean, uint_8, 
+typedef void (*USB_SERVICE_FUNC)(void* handle, uint_8, boolean, uint_8,
                                                  uint_8_ptr, uint_32, uint_8);
 
 #ifdef __cplusplus
@@ -100,7 +100,7 @@ void    _usb_device_shutdown(void* handl
 void    _usb_device_stop(void* handle);
 void    _usb_device_start(void* handle);
 
-uint_8  _usb_device_init_endpoint(void* handle, uint_8 ep_num, uint_16 max_pkt_size, 
+uint_8  _usb_device_init_endpoint(void* handle, uint_8 ep_num, uint_16 max_pkt_size,
                                   uint_8 direction, uint_8 type, uint_8 flag);
 uint_8  _usb_device_deinit_endpoint(void* handle, uint_8 ep_num, uint_8 direction);
 
@@ -123,24 +123,24 @@ uint_8  _usb_device_unregister_service(v
 
 
 /* These functions that implement USB 2.0 standard Chapter 9 Setup requests */
-void    mvUsbCh9GetStatus(void* handle, boolean setup, 
+void    mvUsbCh9GetStatus(void* handle, boolean setup,
                                   SETUP_STRUCT* ctrl_req);
 
-void    mvUsbCh9ClearFeature(void* handle, boolean setup, 
+void    mvUsbCh9ClearFeature(void* handle, boolean setup,
                                    SETUP_STRUCT* setup_ptr);
 
-void    mvUsbCh9SetFeature(void* handle, boolean setup, 
+void    mvUsbCh9SetFeature(void* handle, boolean setup,
                                  SETUP_STRUCT* setup_ptr);
 
-void    mvUsbCh9SetAddress(void* handle, boolean setup, 
+void    mvUsbCh9SetAddress(void* handle, boolean setup,
                                    SETUP_STRUCT* setup_ptr);
 
 /* DEBUG Functions */
-void    _usb_dci_vusb20_set_test_mode(void* handle, uint_16 testMode);   
+void    _usb_dci_vusb20_set_test_mode(void* handle, uint_16 testMode);
 
-void    _usb_debug_set_flags(uint_32 flags);     
+void    _usb_debug_set_flags(uint_32 flags);
 uint_32 _usb_debug_get_flags(void);
-     
+
 void    _usb_debug_init_trace_log(void);
 void    _usb_debug_print_trace_log(void);
 
@@ -156,4 +156,3 @@ void    _usb_ep_status(void* usbHandle,
 
 #endif /* __mvUsbDevApi_h__ */
 /* EOF */
-
--- a/arch/arm/plat-armada/mv_hal/usb/api/mvUsbTypes.h
+++ b/arch/arm/plat-armada/mv_hal/usb/api/mvUsbTypes.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -49,11 +49,11 @@ typedef void _PTR_     pointer;  /* Mach
 */
 
 #ifndef  FALSE
-#   define FALSE ((boolean)0)   
+#   define FALSE ((boolean)0)
 #endif
 
 #ifndef  TRUE
-#   define TRUE ((boolean)!FALSE) 
+#   define TRUE ((boolean)!FALSE)
 #endif
 
 #ifndef  NULL
@@ -71,7 +71,7 @@ typedef void _PTR_     pointer;  /* Mach
 #endif
 
 #ifndef  MIN
-#   define MIN(a,b)   ((a) < (b) ? (a) : (b))      
+#   define MIN(a,b)   ((a) < (b) ? (a) : (b))
 #endif
 
 #define USB_MEM_ALIGN(n, align)            ((n) + (-(n) & (align-1)))
@@ -90,7 +90,7 @@ typedef void _PTR_     pointer;  /* Mach
 #define USB_uint_16_low(x)                  ((x) & 0xFF)
 #define USB_uint_16_high(x)                 (((x) >> 8) & 0xFF)
 
-#define USB_CACHE_ALIGN(n)                  USB_MEM_ALIGN(n, PSP_CACHE_LINE_SIZE)       
+#define USB_CACHE_ALIGN(n)                  USB_MEM_ALIGN(n, PSP_CACHE_LINE_SIZE)
 
 #ifndef INLINE
 #   if defined(MV_VXWORKS)
@@ -103,42 +103,42 @@ typedef void _PTR_     pointer;  /* Mach
 /* 16bit byte swap. For example 0x1122 -> 0x2211                            */
 static INLINE uint_16 USB_BYTE_SWAP_16BIT(uint_16 value)
 {
-    return ( ((value & 0x00ff) << 8) | 
+    return ( ((value & 0x00ff) << 8) |
              ((value & 0xff00) >> 8) );
 }
 
 /* 32bit byte swap. For example 0x11223344 -> 0x44332211                    */
 static INLINE uint_32 USB_BYTE_SWAP_32BIT(uint_32 value)
 {
-    return ( ((value & 0x000000ff) << 24) |                      
-             ((value & 0x0000ff00) << 8)  |                    
-             ((value & 0x00ff0000) >> 8)  |       
+    return ( ((value & 0x000000ff) << 24) |
+             ((value & 0x0000ff00) << 8)  |
+             ((value & 0x00ff0000) >> 8)  |
              ((value & 0xff000000) >> 24));
 }
 
-    
+
 /* Endianess macros.                                                        */
 #if defined(MV_CPU_LE)
-#   define USB_16BIT_LE(X)  (X) 
+#   define USB_16BIT_LE(X)  (X)
 #   define USB_32BIT_LE(X)  (X)
 #   define USB_16BIT_BE(X)  USB_BYTE_SWAP_16BIT(X)
 #   define USB_32BIT_BE(X)  USB_BYTE_SWAP_32BIT(X)
 #elif defined(MV_CPU_BE)
-#   define USB_16BIT_LE(X)  USB_BYTE_SWAP_16BIT(X) 
+#   define USB_16BIT_LE(X)  USB_BYTE_SWAP_16BIT(X)
 #   define USB_32BIT_LE(X)  USB_BYTE_SWAP_32BIT(X)
 #   define USB_16BIT_BE(X)  (X)
 #   define USB_32BIT_BE(X)  (X)
 #else
     #error "CPU endianess isn't defined!\n"
-#endif 
+#endif
 
 typedef struct
 {
     void    (*bspPrintf)          (const char *  fmt, ...);
     int     (*bspSprintf)         (char* buffer, const char *  fmt, ...);
     void*   (*bspUncachedMalloc)  (void* pDev, uint_32 size, uint_32 align,
-                                   unsigned long* pPhyAddr);     
-    void    (*bspUncachedFree)    (void* pDev, uint_32 size, unsigned long phyAddr, 
+                                   unsigned long* pPhyAddr);
+    void    (*bspUncachedFree)    (void* pDev, uint_32 size, unsigned long phyAddr,
                                     void*  pVirtAddr);
     void*   (*bspMalloc)          (unsigned int size);
     void    (*bspFree)            (void* ptr);
@@ -170,16 +170,16 @@ extern USB_IMPORT_FUNCS*            glob
 
 #define USB_get_cap_reg_addr(dev)   global_import_funcs->bspGetCapRegAddr(dev)
 
-static INLINE void* USB_uncached_memalloc(uint_32 size, uint_32 align, unsigned long* pPhyAddr) 
+static INLINE void* USB_uncached_memalloc(uint_32 size, uint_32 align, unsigned long* pPhyAddr)
 {
     /*USB_printf("**** USB_uncached_memalloc: size=%d\n", (size));       */
-    return global_import_funcs->bspUncachedMalloc(NULL, size, align, pPhyAddr); 
+    return global_import_funcs->bspUncachedMalloc(NULL, size, align, pPhyAddr);
 }
 
-static INLINE void* USB_memalloc(uint_32 size)                                                                              
+static INLINE void* USB_memalloc(uint_32 size)
 {
     /*USB_printf("**** USB_memalloc: size=%d\n", (size)); */
-    return global_import_funcs->bspMalloc(size);        
+    return global_import_funcs->bspMalloc(size);
 }
 
 #define USB_uncached_memfree(pVirt, size, physAddr)                                 \
@@ -194,16 +194,16 @@ static INLINE void* USB_memalloc(uint_32
 #define USB_memcopy(src, dst, n)    global_import_funcs->bspMemcpy(dst, src, n)
 
 #define USB_dcache_inv(ptr, size)   if(global_import_funcs->bspCacheInv != NULL)  \
-                                        global_import_funcs->bspCacheInv(NULL, ptr, size)     
+                                        global_import_funcs->bspCacheInv(NULL, ptr, size)
 
 #define USB_dcache_flush(ptr, size) if(global_import_funcs->bspCacheFlush != NULL)  \
-                                        global_import_funcs->bspCacheFlush(NULL, ptr, size)     
+                                        global_import_funcs->bspCacheFlush(NULL, ptr, size)
 
 #define USB_lock()                  (global_import_funcs->bspLock == NULL) ?        \
                                                     0 : global_import_funcs->bspLock()
 
 #define USB_unlock(key)             if(global_import_funcs->bspUnlock != NULL)  \
-                                        global_import_funcs->bspUnlock(key)     
+                                        global_import_funcs->bspUnlock(key)
 
 #define USB_reset_complete(dev)     if(global_import_funcs->bspResetComplete)       \
                                         global_import_funcs->bspResetComplete(dev)
@@ -211,7 +211,7 @@ static INLINE void* USB_memalloc(uint_32
 
 #if defined(USB_UNDERRUN_WA)
 
-#define USB_SRAM_MAX_PARTS  16  
+#define USB_SRAM_MAX_PARTS  16
 
 typedef struct
 {
@@ -222,7 +222,7 @@ typedef struct
 
 extern USB_WA_FUNCS*    global_wa_funcs;
 extern int              global_wa_sram_parts;
-extern int              global_wa_threshold; 
+extern int              global_wa_threshold;
 
 #define USB_get_sram_addr(pSize)        global_wa_funcs->bspGetSramAddr(pSize)
 
--- a/arch/arm/plat-armada/mv_hal/usb/common/mvUsbCore.h
+++ b/arch/arm/plat-armada/mv_hal/usb/common/mvUsbCore.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -47,7 +47,7 @@ disclaimer.
 #define  EHCI_CMD_FRAME_SIZE_16                    (0x00008008) /* 110 */
 #define  EHCI_CMD_FRAME_SIZE_8                     (0x0000800C) /* 111 */
 
-/* Hardware Rev 4.0 related change */                                             
+/* Hardware Rev 4.0 related change */
 /* Mode Register Bit Masks */
 #define  VUSBHS_MODE_CTRL_MODE_IDLE                (0x00000000)
 #define  VUSBHS_MODE_CTRL_MODE_DEV                 (0x00000002)
@@ -55,7 +55,7 @@ disclaimer.
 #define  VUSBHS_MODE_BIG_ENDIAN                    (0x00000004)
 #define  VUSBHS_MODE_SETUP_LOCK_DISABLE            (0x00000008)
 #define  VUSBHS_MODE_STREAM_DISABLE                (0x00000010)
-    
+
 /* Interrupt Enable Register Bit Masks */
 #define  EHCI_INTR_INT_EN                          (0x00000001)
 #define  EHCI_INTR_ERR_INT_EN                      (0x00000002)
@@ -119,9 +119,9 @@ disclaimer.
 #define  EHCI_EPCTRL_RX_EP_TYPE_SHIFT              (2)
 
 /* set bit 24 (PFSC) in PORTSCX register */
-#define  EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT     (0x01000000) 
+#define  EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT     (0x01000000)
 /* set bit 23 (PHCD) in PORTSCX register */
-#define  EHCI_PORTSCX_PHY_CLOCK_DISABLE            (0x00800000) 
+#define  EHCI_PORTSCX_PHY_CLOCK_DISABLE            (0x00800000)
 
 #define  EHCI_PORTSCX_PORT_POWER                   (0x00001000)
 #define  EHCI_PORTSCX_LINE_STATUS_BITS             (0x00000C00)
@@ -151,8 +151,8 @@ disclaimer.
 #define  VUSBHS_ADDRESS_BIT_SHIFT                  (25)
 
 #define  VUSB20_DCC_MAX_ENDPTS_SUPPORTED           (0x1F)
-#define  VUSB20_DCC_HOST_MODE_MASK                 (1 << 8)               
-#define  VUSB20_DCC_DEVICE_MODE_MASK               (1 << 7)               
+#define  VUSB20_DCC_HOST_MODE_MASK                 (1 << 8)
+#define  VUSB20_DCC_DEVICE_MODE_MASK               (1 << 7)
 
 #define  EHCI_HCC_PARAMS_64_BIT_ADDR_CAP           (0x01)
 #define  EHCI_HCC_PARAMS_PGM_FRM_LIST_FLAG         (0x02)
@@ -242,7 +242,7 @@ Split transatcions specific defines
 #define  EHCI_ITD_BUFFER_POINTER                   (0xFFFFF000)
 #define  EHCI_ITD_MULTI_TRANSACTION_BITS           (0x00000003)
 
-          
+
 
 /* SITD position bits */
 #define  EHCI_SITD_DIRECTION_BIT_POS                (31)
@@ -374,7 +374,7 @@ Split transatcions specific defines
 hardware. Enable the following switch in config.mk to enable the
 changes. */
 
-    /* WEB20040409 below line changed from VUSBHS_OTGSC_B_HOST_EN to VUSBHS_OTGSC_IDPU 
+    /* WEB20040409 below line changed from VUSBHS_OTGSC_B_HOST_EN to VUSBHS_OTGSC_IDPU
        to reflect change in usbhs4.0  B_HOST_EN has not been used quite some time */
     #define  VUSBHS_OTGSC_IDPU                         (0x00000020)   /* ID pull enable */
 #else
@@ -383,12 +383,7 @@ changes. */
 
 #define  VUSBHS_OTGSC_DP                           (0x00000010)   /* Data-pulsing */
 #define  VUSBHS_OTGSC_OT                           (0x00000008)   /* OTG termination */
-#if 0
-    #define  VUSBHS_OTGSC_VO                       (0x00000004)   /* Vbus on */
-#endif
-
 #define  VUSBHS_OTGSC_HAAR                         (0x00000004)   /* Auto reset bit*/
-
 #define  VUSBHS_OTGSC_VC                           (0x00000002)   /* Vbus charge */
 #define  VUSBHS_OTGSC_VD                           (0x00000001)   /* Vbus discharge */
 
@@ -405,7 +400,7 @@ typedef struct {
          volatile USB_REGISTER   DCI_VERSION;      /* DC version number and reserved 16 bits */
          volatile USB_REGISTER   DCC_PARAMS;       /* DC Capability Parameters */
       } CAPABILITY_REGISTERS;
-      
+
       struct  {
          volatile USB_REGISTER   USB_CMD;                   /* Command register */
          volatile USB_REGISTER   USB_STS;                   /* Status register */
@@ -426,7 +421,7 @@ typedef struct {
          volatile USB_REGISTER   ENDPTCOMPLETE;             /* Endpoint Interrupt On Complete */
          volatile USB_REGISTER   ENDPTCTRLX[16];            /* Endpoint Control, where x = 0.. 15 */
       } OPERATIONAL_DEVICE_REGISTERS;
-      
+
       struct  {
          volatile USB_REGISTER   USB_CMD;                   /* Command register */
          volatile USB_REGISTER   USB_STS;                   /* Status register */
@@ -446,13 +441,13 @@ typedef struct {
 } VUSB20_REG_STRUCT, _PTR_ VUSB20_REG_STRUCT_PTR;
 
 typedef struct {
-   volatile uint_32   MAX_PKT_LENGTH;    /* Bits 16..26 Bit 15 is Interrupt 
-                                          ** On Setup 
+   volatile uint_32   MAX_PKT_LENGTH;    /* Bits 16..26 Bit 15 is Interrupt
+                                          ** On Setup
                                           */
    volatile uint_32   CURR_DTD_PTR;        /* Current dTD Pointer */
    volatile uint_32   NEXT_DTD_PTR;        /* Next dTD Pointer */
-   volatile uint_32   SIZE_IOC_INT_STS;    /* Total bytes (16..30), IOC (15), 
-                                          ** INT (8), STS (0-7) 
+   volatile uint_32   SIZE_IOC_INT_STS;    /* Total bytes (16..30), IOC (15),
+                                          ** INT (8), STS (0-7)
                                           */
    volatile uint_32   BUFF_PTR0;           /* Buffer pointer Page 0 (12-31) */
    volatile uint_32   BUFF_PTR1;           /* Buffer pointer Page 1 (12-31) */
@@ -460,8 +455,8 @@ typedef struct {
    volatile uint_32   BUFF_PTR3;           /* Buffer pointer Page 3 (12-31) */
    volatile uint_32   BUFF_PTR4;           /* Buffer pointer Page 4 (12-31) */
    volatile uint_32   RESERVED1;
-   volatile uint_8    SETUP_BUFFER[8];     /* 8 bytes of setup data that follows 
-                                            ** the Setup PID 
+   volatile uint_8    SETUP_BUFFER[8];     /* 8 bytes of setup data that follows
+                                            ** the Setup PID
                                             */
    volatile uint_32   RESERVED2[4];
 } VUSB20_EP_QUEUE_HEAD_STRUCT, _PTR_ VUSB20_EP_QUEUE_HEAD_STRUCT_PTR;
@@ -473,13 +468,13 @@ typedef struct {
 } SCRATCH_STRUCT, _PTR_ SCRATCH_STRUCT_PTR;
 
 typedef struct ep_tr_struct {
-   volatile uint_32      NEXT_TR_ELEM_PTR; /* Memory address of next 
+   volatile uint_32      NEXT_TR_ELEM_PTR; /* Memory address of next
                                           ** dTD to be processed (5-31)
-                                          ** and the T (bit 0) indicating 
+                                          ** and the T (bit 0) indicating
                                           ** pointer validity
                                           */
-   volatile uint_32      SIZE_IOC_STS;     /* total bytes (16-30), 
-                                          ** IOC (15), Status (0-7) 
+   volatile uint_32      SIZE_IOC_STS;     /* total bytes (16-30),
+                                          ** IOC (15), Status (0-7)
                                           */
    volatile uint_32      BUFF_PTR0;        /* Buffer pointer Page 0 */
    volatile uint_32      BUFF_PTR1;        /* Buffer pointer Page 1 */
@@ -490,10 +485,10 @@ typedef struct ep_tr_struct {
 } VUSB20_EP_TR_STRUCT, _PTR_ VUSB20_EP_TR_STRUCT_PTR;
 
 typedef struct {
-   uint_32      NEXT_LINK_PTR;    /* (5-31) Memory address of 
-                                          ** next schedule data structure 
-                                          ** item Type (1..2 ) and the 
-                                          ** T (bit 0) indicating pointer 
+   uint_32      NEXT_LINK_PTR;    /* (5-31) Memory address of
+                                          ** next schedule data structure
+                                          ** item Type (1..2 ) and the
+                                          ** T (bit 0) indicating pointer
                                           ** validity
                                           */
    uint_32      TR_STATUS_CTL_LIST[8];  /* bits 31-28: Status,
@@ -502,8 +497,8 @@ typedef struct {
                                                 ** bits 14-12: Page Select
                                                 ** bits 11-0: Tr X offset
                                                 */
-   uint_32      BUFFER_PAGE_PTR_LIST[7];  /* bits 31-12 4K aligned pointer 
-                                                ** to physical memory 
+   uint_32      BUFFER_PAGE_PTR_LIST[7];  /* bits 31-12 4K aligned pointer
+                                                ** to physical memory
                                                 ** bits 11-8 endpoint no.
                                                 ** bit 7: reserved
                                                 ** bits 6-0 device address*/
@@ -517,10 +512,10 @@ typedef struct {
 } EHCI_ITD_STRUCT, _PTR_ EHCI_ITD_STRUCT_PTR;
 
 typedef struct {
-   uint_32      NEXT_LINK_PTR;    /* (5-31) Memory address of 
-                                          ** next schedule data structure 
-                                          ** item Type (1..2 ) and the 
-                                          ** T (bit 0) indicating pointer 
+   uint_32      NEXT_LINK_PTR;    /* (5-31) Memory address of
+                                          ** next schedule data structure
+                                          ** item Type (1..2 ) and the
+                                          ** T (bit 0) indicating pointer
                                           ** validity
                                           */
    uint_32      EP_CAPAB_CHARAC;  /* bits 31: Direction (I/O),
@@ -532,30 +527,30 @@ typedef struct {
                                           ** bit 7: reserved
                                           ** bits 6-0: device address
                                           */
-   uint_32      UFRAME_SCHED_CTL; /* bits 31-16: reserved 
+   uint_32      UFRAME_SCHED_CTL; /* bits 31-16: reserved
                                           ** bits 15-8: Split completion mask
                                           ** bits 7-0: Split start mask
                                           */
    uint_32      TRANSFER_STATE;   /* bit 31: int on complete
                                           ** bit 30: Page Select
                                           ** bits 29-26: Reserved
-                                          ** bits 25-16: total bytes to 
+                                          ** bits 25-16: total bytes to
                                           ** transfer
-                                          ** bits 15-8: uframe 
+                                          ** bits 15-8: uframe
                                           ** complete-split progress mask
                                           ** bits 7-0: status
                                           */
-   uint_32      BUFFER_PTR_0;     /* bits 31-12: 4K aligned pointer 
-                                          ** to physical memory 
+   uint_32      BUFFER_PTR_0;     /* bits 31-12: 4K aligned pointer
+                                          ** to physical memory
                                           ** bits 11-0: Current offset
                                           */
-   uint_32      BUFFER_PTR_1;     /* bits 31-12: 4K aligned pointer 
-                                          ** to physical memory 
+   uint_32      BUFFER_PTR_1;     /* bits 31-12: 4K aligned pointer
+                                          ** to physical memory
                                           ** bits 11-5 reserved
                                           ** bits 4-3 tr position
                                           ** bits 2-0 tr count
                                           */
-   uint_32      BACK_LINK_PTR;    /* bits 31-5 back pointer points to sITD 
+   uint_32      BACK_LINK_PTR;    /* bits 31-5 back pointer points to sITD
                                           ** bits 4-1: reserved
                                           ** bit 0: terminate
                                           */
@@ -570,20 +565,20 @@ typedef struct {
 } EHCI_SITD_STRUCT, _PTR_ EHCI_SITD_STRUCT_PTR;
 
 typedef struct {
-   uint_32      NEXT_QTD_PTR;     /* (5-31) Memory address of 
+   uint_32      NEXT_QTD_PTR;     /* (5-31) Memory address of
                                           ** next qTD to be processed
-                                          ** (4..1) reserved 
-                                          ** T (bit 0) indicating pointer 
+                                          ** (4..1) reserved
+                                          ** T (bit 0) indicating pointer
                                           ** validity
                                           */
-   uint_32      ALT_NEXT_QTD_PTR; /* bits 31-5: alternate next 
-                                          ** qTD if the above one encounters 
+   uint_32      ALT_NEXT_QTD_PTR; /* bits 31-5: alternate next
+                                          ** qTD if the above one encounters
                                           ** a short packet
-                                          ** (4..1) reserved 
-                                          ** T (bit 0) indicating pointer 
+                                          ** (4..1) reserved
+                                          ** T (bit 0) indicating pointer
                                           ** validity
                                           */
-   uint_32      TOKEN;            /* bits 31: data toggle 
+   uint_32      TOKEN;            /* bits 31: data toggle
                                           ** bits 30-16: Total bytes to transfer
                                           ** bit 15: Interrupt on Complete
                                           ** bits 14-12: Current page
@@ -591,23 +586,23 @@ typedef struct {
                                           ** bits 9-8: PID code
                                           ** bits 7-0: status
                                           */
-   uint_32      BUFFER_PTR_0;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_0;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bit 11-0: Current Offset
                                           */
-   uint_32      BUFFER_PTR_1;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_1;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bit 11-0: reserved
                                           */
-   uint_32      BUFFER_PTR_2;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_2;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bit 11-0: reserved
                                           */
-   uint_32      BUFFER_PTR_3;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_3;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bit 11-0: reserved
                                           */
-   uint_32      BUFFER_PTR_4;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_4;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bit 11-0: reserved
                                           */
@@ -618,17 +613,17 @@ typedef struct {
 } EHCI_QTD_STRUCT, _PTR_ EHCI_QTD_STRUCT_PTR;
 
 typedef struct {
-   uint_32      HORIZ_LINK_PTR;   /* (5-31) Memory address of 
+   uint_32      HORIZ_LINK_PTR;   /* (5-31) Memory address of
                                           ** next data object to be processed
-                                          ** (4..3) reserved 
+                                          ** (4..3) reserved
                                           ** (2..1) type of the item
-                                          ** T (bit 0) indicating pointer 
+                                          ** T (bit 0) indicating pointer
                                           ** validity
                                           */
    uint_32      EP_CAPAB_CHARAC1; /* bits 31-28: NAK count reload,
                                           ** bit 27: Control endpoint flag
                                           ** bit 26-16: Maximum packet length
-                                          ** bit 15: Head of reclamation 
+                                          ** bit 15: Head of reclamation
                                           ** list flag
                                           ** bit 14: data toggle control
                                           ** bits 13-12: endpoint speed
@@ -636,8 +631,8 @@ typedef struct {
                                           ** bits 7: Inactivate on next tr
                                           ** bits 6-0: Device address
                                           */
-   uint_32      EP_CAPAB_CHARAC2; /* bits 31-30: High-BW pipe 
-                                          ** Multiplier, 
+   uint_32      EP_CAPAB_CHARAC2; /* bits 31-30: High-BW pipe
+                                          ** Multiplier,
                                           ** bit 29-23: Port number
                                           ** bit 22-16: Hub address
                                           ** bit 15-8: Split completion mask
@@ -663,26 +658,26 @@ typedef struct {
                                           ** physical memory address
                                           ** bit 11-0: reserved
                                           */
-   uint_32      BUFFER_PTR_0;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_0;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bit 11-0: reserved
                                           */
-   uint_32      BUFFER_PTR_1;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_1;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
-                                          ** bit 7-0: Split-transaction, 
+                                          ** bit 7-0: Split-transaction,
                                           ** complete-split progress
                                           */
-   uint_32      BUFFER_PTR_2;     /* bits 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_2;     /* bits 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bits 11-5: S-bytes
-                                          ** bits 4-0: Split-transaction 
+                                          ** bits 4-0: Split-transaction
                                           ** frame tag
                                           */
-   uint_32      BUFFER_PTR_3;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_3;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bit 11-0: reserved
                                           */
-   uint_32      BUFFER_PTR_4;     /* bit 31-12: 4K-page aligned 
+   uint_32      BUFFER_PTR_4;     /* bit 31-12: 4K-page aligned
                                           ** physical memory address
                                           ** bit 11-0: reserved
                                           */
@@ -692,19 +687,19 @@ typedef struct {
 } EHCI_QH_STRUCT, _PTR_ EHCI_QH_STRUCT_PTR;
 
 typedef struct {
-   uint_32      NORMAL_PATH_LINK_PTR;   /* (5-31) Memory address of 
+   uint_32      NORMAL_PATH_LINK_PTR;   /* (5-31) Memory address of
                                                 ** next data object to be processed
                                                 ** in the periodic list
-                                                ** bits 4-3: reserved 
+                                                ** bits 4-3: reserved
                                                 ** (2..1) type of the item
-                                                ** T (bit 0) indicating pointer 
+                                                ** T (bit 0) indicating pointer
                                                 ** validity
                                                 */
-   uint_32      BACK_PATH_LINK_PTR;     /* bits 31-5: Memory address of 
+   uint_32      BACK_PATH_LINK_PTR;     /* bits 31-5: Memory address of
                                                 ** the queue head,
                                                 ** bit 4-3: reserved
                                                 ** (2..1) type of the item
-                                                ** T (bit 0) indicating pointer 
+                                                ** T (bit 0) indicating pointer
                                                 ** validity
                                                 */
    SCRATCH_STRUCT_PTR   SCRATCH_PTR;
@@ -716,5 +711,3 @@ typedef uint_32   EHCI_FRAME_LIST_ELEMEN
 
 #endif /* __mvUsbCore_h__ */
 /* EOF */
-
-
--- a/arch/arm/plat-armada/mv_hal/usb/common/mvUsbDesc.h
+++ b/arch/arm/plat-armada/mv_hal/usb/common/mvUsbDesc.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -38,8 +38,8 @@ typedef struct usb_device_descriptor
    uint_8   iManufacturer;    /* Index to manufacturer string */
    uint_8   iProduct;         /* Index to product string */
    uint_8   iSerialNumber;    /* Index to serial number string */
-   uint_8   bNumConfigurations; /* Number of possible configurations */ 
-} DEVICE_DESCRIPTOR, _PTR_ DEVICE_DESCRIPTOR_PTR;  
+   uint_8   bNumConfigurations; /* Number of possible configurations */
+} DEVICE_DESCRIPTOR, _PTR_ DEVICE_DESCRIPTOR_PTR;
 
 typedef struct usb_configuration_descriptor
 {
@@ -47,14 +47,14 @@ typedef struct usb_configuration_descrip
    uint_8   bDescriptorType;  /* CONFIGURATION type = 2 or 7 */
    uint_8   wTotalLength[2];  /* Length of concatenated descriptors */
    uint_8   bNumInterfaces;   /* Number of interfaces, this config. */
-   uint_8   bConfigurationValue;  /* Value to set this config. */ 
+   uint_8   bConfigurationValue;  /* Value to set this config. */
    uint_8   iConfig;          /* Index to configuration string */
    uint_8   bmAttributes;     /* Config. characteristics */
    #define  CONFIG_RES7       (0x80)  /* Reserved, always = 1 */
    #define  CONFIG_SELF_PWR   (0x40)  /* Self-powered device */
    #define  CONFIG_WAKEUP     (0x20)  /* Remote wakeup */
    uint_8   bMaxPower;        /* Max.power from bus, 2mA units */
-} CONFIGURATION_DESCRIPTOR, _PTR_ CONFIGURATION_DESCRIPTOR_PTR;  
+} CONFIGURATION_DESCRIPTOR, _PTR_ CONFIGURATION_DESCRIPTOR_PTR;
 
 typedef struct usb_interface_descriptor
 {
@@ -67,7 +67,7 @@ typedef struct usb_interface_descriptor
    uint_8   bInterfaceSubClass;  /* Sub-Class code, 0 if class = 0 */
    uint_8   bInterfaceProtocol;  /* Protocol, 0xFF = vendor */
    uint_8   iInterface;       /* Index to interface string */
-} INTERFACE_DESCRIPTOR, _PTR_ INTERFACE_DESCRIPTOR_PTR;  
+} INTERFACE_DESCRIPTOR, _PTR_ INTERFACE_DESCRIPTOR_PTR;
 
 typedef struct usb_endpoint_descriptor
 {
@@ -101,7 +101,7 @@ typedef struct usb_endpoint_descriptor
    #define  TWO_ADDITIONAL    (0x1000)   /* 3 / microframe */
    #define  ADDITIONAL_MASK   (ONE_ADDITIONAL | TWO_ADDITIONAL)
    uint_8   iInterval;        /* Polling interval in (micro) frames */
-} ENDPOINT_DESCRIPTOR, _PTR_ ENDPOINT_DESCRIPTOR_PTR;  
+} ENDPOINT_DESCRIPTOR, _PTR_ ENDPOINT_DESCRIPTOR_PTR;
 
 typedef struct usb_qualifier_descriptor
 {
@@ -113,8 +113,8 @@ typedef struct usb_qualifier_descriptor
    uint_8   bDeviceProtocol;  /* Protocol, if 0 see interface */
    uint_8   bMaxPacketSize;   /* Endpoint 0 max. size */
    uint_8   bNumConfigurations; /* Number of possible configurations */
-   uint_8   bReserved;        /* Reserved = 0 */ 
-} QUALIFIER_DESCRIPTOR, _PTR_ QUALIFIER_DESCRIPTOR_PTR;  
+   uint_8   bReserved;        /* Reserved = 0 */
+} QUALIFIER_DESCRIPTOR, _PTR_ QUALIFIER_DESCRIPTOR_PTR;
 
 /* Other-Config type 7 fields are identical to type 2 above */
 
@@ -127,7 +127,7 @@ typedef struct usb_otg_descriptor
    uint_8   bmAttributes;     /* OTG characteristics */
    #define  OTG_SRP_SUPPORT   (0x01)  /* Supports SRP */
    #define  OTG_HNP_SUPPORT   (0x02)  /* Supports HNP */
-} OTG_DESCRIPTOR, _PTR_ OTG_DESCRIPTOR_PTR;  
+} OTG_DESCRIPTOR, _PTR_ OTG_DESCRIPTOR_PTR;
 
 typedef union descriptor_union
 {
@@ -141,21 +141,21 @@ typedef union descriptor_union
    QUALIFIER_DESCRIPTOR_PTR      qual;
    OTG_DESCRIPTOR_PTR            otg;
 }  DESCRIPTOR_UNION, _PTR_ DESCRIPTOR_UNION_PTR;
-                           
+
 /* Prototypes */
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-extern uint_32 usb_host_init(uint_8, uint_32, 
+extern uint_32 usb_host_init(uint_8, uint_32,
                   _usb_host_handle _PTR_);
-extern uint_32 _usb_host_open_pipe(_usb_host_handle, 
+extern uint_32 _usb_host_open_pipe(_usb_host_handle,
                   PIPE_INIT_PARAM_STRUCT_PTR, _usb_pipe_handle _PTR_ );
 
 #ifdef __cplusplus
 }
-#endif                         
+#endif
 
 #endif /* __mvUsbDesc_h__ */
 
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevCh9.c
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevCh9.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -25,23 +25,23 @@ disclaimer.
 #include "usb/device/mvUsbDevPrv.h"
 #include "usb/api/mvUsbCh9.h"
 
-static volatile boolean  ENTER_TEST_MODE = FALSE; 
+static volatile boolean  ENTER_TEST_MODE = FALSE;
 static volatile uint_16  test_mode_index = 0;
 
 
-void    mvUsbCh9GetStatus(_usb_device_handle handle, boolean setup, 
+void    mvUsbCh9GetStatus(_usb_device_handle handle, boolean setup,
                          SETUP_STRUCT* ctrl_req)
 { /* Body */
     uint_8                  endpoint, direction;
     uint_16                 usb_status;
-    USB_DEV_STATE_STRUCT*   usb_dev_ptr = (USB_DEV_STATE_STRUCT*)handle; 
+    USB_DEV_STATE_STRUCT*   usb_dev_ptr = (USB_DEV_STATE_STRUCT*)handle;
 
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
 
     if(!setup)
         return;
 
-    switch (ctrl_req->REQUESTTYPE) 
+    switch (ctrl_req->REQUESTTYPE)
     {
        case (REQ_DIR_IN | REQ_RECIP_DEVICE):
           /* Device request */
@@ -52,7 +52,7 @@ void    mvUsbCh9GetStatus(_usb_device_ha
           /* Interface request */
           _usb_device_get_status(handle, ARC_USB_STATUS_INTERFACE, &usb_status);
           break;
-    
+
        case (REQ_DIR_IN | REQ_RECIP_ENDPOINT):
           /* Endpoint request */
           endpoint = ctrl_req->INDEX & ARC_USB_STATUS_ENDPOINT_NUMBER_MASK;
@@ -63,7 +63,7 @@ void    mvUsbCh9GetStatus(_usb_device_ha
 
           usb_status = _usb_device_is_endpoint_stalled(handle, endpoint, direction);
           break;
-       
+
        default:
           /* Unknown request */
            USB_printf("GetStatus: Unknown request type 0x%x\n", ctrl_req->REQUESTTYPE);
@@ -74,23 +74,23 @@ void    mvUsbCh9GetStatus(_usb_device_ha
     /* Send the requested data */
     *usb_dev_ptr->STATUS_PTR = USB_16BIT_LE(usb_status);
     _usb_device_send_data(handle, 0, (uint_8_ptr)usb_dev_ptr->STATUS_PTR, sizeof(uint_16));
-    
+
     /* status phase */
     _usb_device_recv_data(handle, 0, NULL, 0);
-    
+
     return;
 } /* Endbody */
 
-void    mvUsbCh9ClearFeature(_usb_device_handle handle, boolean setup, 
+void    mvUsbCh9ClearFeature(_usb_device_handle handle, boolean setup,
                             SETUP_STRUCT* setup_ptr)
 { /* Body */
     uint_8   endpoint, direction;
     uint_16  usb_status;
-     
+
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
 
     _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_status);
-    if ((usb_status != ARC_USB_STATE_CONFIG) && (usb_status != ARC_USB_STATE_ADDRESS)) 
+    if ((usb_status != ARC_USB_STATE_CONFIG) && (usb_status != ARC_USB_STATE_ADDRESS))
     {
         USB_printf("ClearFeature: Wrong USB state %d\n", usb_status);
         _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
@@ -100,13 +100,13 @@ void    mvUsbCh9ClearFeature(_usb_device
     if(!setup)
         return;
 
-    switch (setup_ptr->REQUESTTYPE) 
+    switch (setup_ptr->REQUESTTYPE)
     {
         case (REQ_DIR_OUT | REQ_RECIP_DEVICE):
             /* DEVICE */
             switch(setup_ptr->VALUE)
             {
-                case DEVICE_REMOTE_WAKEUP: 
+                case DEVICE_REMOTE_WAKEUP:
                     /* clear remote wakeup */
                     _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
                     usb_status &= ~ARC_USB_REMOTE_WAKEUP;
@@ -120,18 +120,18 @@ void    mvUsbCh9ClearFeature(_usb_device
                     break;
 
                 default:
-                    USB_printf("ClearFeature: Unknown Device feature %d\n", 
+                    USB_printf("ClearFeature: Unknown Device feature %d\n",
                                 setup_ptr->VALUE);
                     _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
                     return;
             } /* Endif */
             break;
-         
+
         case (REQ_DIR_OUT | REQ_RECIP_ENDPOINT):
             /* ENDPOINT */
-            if (setup_ptr->VALUE != ENDPOINT_HALT) 
+            if (setup_ptr->VALUE != ENDPOINT_HALT)
             {
-                USB_printf("ClearFeature: Wrong Endpoint feature %d\n", 
+                USB_printf("ClearFeature: Wrong Endpoint feature %d\n",
                             setup_ptr->VALUE);
                 _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
                 return;
@@ -147,33 +147,33 @@ void    mvUsbCh9ClearFeature(_usb_device
             break;
 
         default:
-            USB_printf("ClearFeature: Unknown REQUEST_TYPE %d\n", 
+            USB_printf("ClearFeature: Unknown REQUEST_TYPE %d\n",
                                 setup_ptr->REQUESTTYPE);
 
             _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
             return;
     } /* Endswitch */
-      
+
     /* status phase */
     _usb_device_send_data(handle, 0, 0, 0);
 }
 
-void    mvUsbCh9SetFeature(_usb_device_handle handle, boolean setup, 
+void    mvUsbCh9SetFeature(_usb_device_handle handle, boolean setup,
                           SETUP_STRUCT* setup_ptr)
 {
    uint_16                  usb_status;
    uint_8                   endpoint, direction;
-   USB_DEV_STATE_STRUCT*    usb_dev_ptr = (USB_DEV_STATE_STRUCT*)handle; 
+   USB_DEV_STATE_STRUCT*    usb_dev_ptr = (USB_DEV_STATE_STRUCT*)handle;
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
 
-   if (setup) 
+   if (setup)
    {
-      switch (setup_ptr->REQUESTTYPE) 
+      switch (setup_ptr->REQUESTTYPE)
       {
          case (REQ_DIR_OUT | REQ_RECIP_DEVICE):
             /* DEVICE */
-            switch (setup_ptr->VALUE) 
+            switch (setup_ptr->VALUE)
             {
                case DEVICE_REMOTE_WAKEUP:
                   /* set remote wakeup */
@@ -185,27 +185,27 @@ void    mvUsbCh9SetFeature(_usb_device_h
 
                case DEVICE_TEST_MODE:
                   /* Test Mode */
-                  if( (setup_ptr->INDEX & 0x00FF) || (usb_dev_ptr->SPEED != ARC_USB_SPEED_HIGH) ) 
+                  if( (setup_ptr->INDEX & 0x00FF) || (usb_dev_ptr->SPEED != ARC_USB_SPEED_HIGH) )
                   {
-                     USB_printf("SetFeature: Wrong Test mode parameters: mode=%d, speed=%d\n", 
+                     USB_printf("SetFeature: Wrong Test mode parameters: mode=%d, speed=%d\n",
                                 (setup_ptr->INDEX & 0x00FF), usb_dev_ptr->SPEED);
                      _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
                      return;
                   } /* Endif */
 
                   _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_status);
-                  if( (usb_status == ARC_USB_STATE_CONFIG)  || 
-                      (usb_status == ARC_USB_STATE_ADDRESS) || 
-                      (usb_status == ARC_USB_STATE_DEFAULT)) 
+                  if( (usb_status == ARC_USB_STATE_CONFIG)  ||
+                      (usb_status == ARC_USB_STATE_ADDRESS) ||
+                      (usb_status == ARC_USB_STATE_DEFAULT))
                   {
                       /* wait with Set Test mode */
                       ENTER_TEST_MODE = TRUE;
                       test_mode_index = (setup_ptr->INDEX & 0xFF00);
                       USB_printf("SetFeature: Prepare for Test mode 0x%x\n", test_mode_index);
-                  } 
-                  else 
+                  }
+                  else
                   {
-                     USB_printf("SetFeature: Wrong USB state for Test mode: state=%d\n", 
+                     USB_printf("SetFeature: Wrong USB state for Test mode: state=%d\n",
                                 usb_status);
                      _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
                      return;
@@ -213,18 +213,18 @@ void    mvUsbCh9SetFeature(_usb_device_h
                   break;
 
                default:
-                    USB_printf("SetFeature: Unknown Device feature %d\n", 
+                    USB_printf("SetFeature: Unknown Device feature %d\n",
                                 setup_ptr->VALUE);
                   _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
                   return;
             } /* Endswitch */
             break;
-            
+
          case (REQ_DIR_OUT | REQ_RECIP_ENDPOINT):
             /* ENDPOINT */
-            if (setup_ptr->VALUE != ENDPOINT_HALT) 
+            if (setup_ptr->VALUE != ENDPOINT_HALT)
             {
-                USB_printf("SetFeature: Unknown Endpoint feature %d\n", 
+                USB_printf("SetFeature: Unknown Endpoint feature %d\n",
                             setup_ptr->VALUE);
                 _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
                 return;
@@ -240,19 +240,19 @@ void    mvUsbCh9SetFeature(_usb_device_h
             break;
 
          default:
-            USB_printf("SetFeature: Unknown REQUEST_TYPE %d\n", 
+            USB_printf("SetFeature: Unknown REQUEST_TYPE %d\n",
                        setup_ptr->REQUESTTYPE);
 
             _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
             return;
       } /* Endswitch */
-      
+
       /* status phase */
       _usb_device_send_data(handle, 0, 0, 0);
-   } 
-   else 
+   }
+   else
    {
-      if (ENTER_TEST_MODE) 
+      if (ENTER_TEST_MODE)
       {
          /* Enter Test Mode */
           USB_printf("SetFeature: Activate Test mode 0x%x\n", test_mode_index);
@@ -262,7 +262,7 @@ void    mvUsbCh9SetFeature(_usb_device_h
 }
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SetAddress
 * Returned Value : None
 * Comments       :
@@ -270,17 +270,17 @@ void    mvUsbCh9SetFeature(_usb_device_h
 *     We setup a TX packet of 0 length ready for the IN token
 *     Once we get the TOK_DNE interrupt for the IN token, then
 *     we change the ADDR register and go to the ADDRESS state.
-* 
+*
 *END*--------------------------------------------------------------------*/
 void    mvUsbCh9SetAddress(_usb_device_handle handle,
                         boolean setup, SETUP_STRUCT* setup_ptr)
 { /* Body */
    static uint_8            new_address;
 
-   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ADDR, "usbDisk %s: setup=%d, address=%d\n", 
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ADDR, "usbDisk %s: setup=%d, address=%d\n",
                                     __FUNCTION__, (int)setup, setup_ptr->VALUE);
 
-   if (setup) 
+   if (setup)
    {
       new_address = setup_ptr->VALUE;
       /*******************************************************
@@ -288,17 +288,17 @@ void    mvUsbCh9SetAddress(_usb_device_h
        * hardware rev for details) we need to do the set_address
        * before queuing the status phase.
        *******************************************************/
-#ifdef SET_ADDRESS_HARDWARE_ASSISTANCE      
+#ifdef SET_ADDRESS_HARDWARE_ASSISTANCE
        _usb_device_set_status(handle, ARC_USB_STATUS_ADDRESS, new_address);
 #endif
       /* ack */
       _usb_device_send_data(handle, 0, 0, 0);
-   } 
-   else 
+   }
+   else
    {
 #ifndef SET_ADDRESS_HARDWARE_ASSISTANCE
       _usb_device_set_status(handle, ARC_USB_STATUS_ADDRESS, new_address);
 #endif
-      _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE, ARC_USB_STATE_ADDRESS);        
+      _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE, ARC_USB_STATE_ADDRESS);
    }
 }
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevMain.c
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevMain.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -48,7 +48,7 @@ static void    _usb_device_cleanup(USB_D
     {
         USB_memfree((pointer)usb_dev_ptr->XD_BASE);
     }
-   
+
     /* Free all XD scratch memory */
     if(usb_dev_ptr->XD_SCRATCH_STRUCT_BASE != NULL)
     {
@@ -87,7 +87,7 @@ void _usb_device_free_XD
 { /* Body */
     int                         lockKey;
     USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
-  
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)(((XD_STRUCT_PTR)xd_ptr)->SCRATCH_PTR->PRIVATE);
 
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "free_XD: xd_ptr=0x%x\n", (unsigned)xd_ptr);
@@ -123,7 +123,7 @@ void _usb_device_free_XD
 void _usb_device_set_bsp_funcs(USB_IMPORT_FUNCS* pBspFuncs)
 {
     static  boolean isFirst = TRUE;
-    
+
     if(isFirst)
     {
         global_import_funcs = pBspFuncs;
@@ -137,7 +137,7 @@ void _usb_device_set_bsp_funcs(USB_IMPOR
 *  Function Name  : _usb_device_get_max_endpoint
 *  Returned Value : handle or NULL
 *  Comments       :
-*        Return maximum number of endpoints supportedby USB device 
+*        Return maximum number of endpoints supportedby USB device
 *        (for DEBUG only)
 *
 *END*-----------------------------------------------------------------*/
@@ -174,7 +174,7 @@ uint_8  _usb_device_get_dev_num(_usb_dev
 *  Function Name  : _usb_device_init
 *  Returned Value : USB_OK or error code
 *  Comments       :
-*        Initializes the USB device specific data structures and calls 
+*        Initializes the USB device specific data structures and calls
 *  the low-level device controller chip initialization routine.
 *
 *END*-----------------------------------------------------------------*/
@@ -201,49 +201,49 @@ uint_8 _usb_device_init
         USB_printf("_usb_device_init, error invalid device number");
         return USBERR_INVALID_DEVICE_NUM;
    } /* Endif */
-   
+
    /* Allocate memory for the state structure */
-   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)USB_memalloc(sizeof(USB_DEV_STATE_STRUCT));      
-   if (usb_dev_ptr == NULL) 
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)USB_memalloc(sizeof(USB_DEV_STATE_STRUCT));
+   if (usb_dev_ptr == NULL)
    {
-        USB_printf("_usb_device_init, malloc of %d bytes for USB_DEV_STATE_STRUCT failed\n", 
+        USB_printf("_usb_device_init, malloc of %d bytes for USB_DEV_STATE_STRUCT failed\n",
                     sizeof(USB_DEV_STATE_STRUCT));
         return USBERR_ALLOC_STATE;
    } /* Endif */
-   
+
    /* Zero out the internal USB state structure */
    USB_memzero(usb_dev_ptr, sizeof(USB_DEV_STATE_STRUCT));
-    
+
    usb_dev_ptr->DEV_NUM = devnum;
 
-   /* Multiple devices will have different base addresses and 
+   /* Multiple devices will have different base addresses and
    ** interrupt vectors (For future)
-   */   
+   */
    usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
-   
+
    /* Allocate MAX_XDS_FOR_TR_CALLS */
-   xd_ptr = (XD_STRUCT_PTR)USB_memalloc(sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS);      
-   if (xd_ptr == NULL) 
+   xd_ptr = (XD_STRUCT_PTR)USB_memalloc(sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS);
+   if (xd_ptr == NULL)
    {
         _usb_device_cleanup(usb_dev_ptr);
-        USB_printf("_usb_device_init, malloc of %d bytes for %d XD_STRUCT failed\n", 
+        USB_printf("_usb_device_init, malloc of %d bytes for %d XD_STRUCT failed\n",
                         sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS, MAX_XDS_FOR_TR_CALLS);
         return USBERR_ALLOC_TR;
    } /* Endif */
-   
+
    usb_dev_ptr->XD_BASE = xd_ptr;
 
    _usb_clear_stats(usb_dev_ptr);
 
    USB_memzero(xd_ptr, sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS);
 
-   /* Allocate memory for internal scratch structure */   
+   /* Allocate memory for internal scratch structure */
    usb_dev_ptr->XD_SCRATCH_STRUCT_BASE = (SCRATCH_STRUCT_PTR)
                     USB_memalloc(sizeof(SCRATCH_STRUCT) * MAX_XDS_FOR_TR_CALLS);
-   if (usb_dev_ptr->XD_SCRATCH_STRUCT_BASE == NULL) 
+   if (usb_dev_ptr->XD_SCRATCH_STRUCT_BASE == NULL)
    {
         _usb_device_cleanup(usb_dev_ptr);
-        USB_printf("_usb_device_init, malloc of %d bytes for %d XD_STRUCT failed\n", 
+        USB_printf("_usb_device_init, malloc of %d bytes for %d XD_STRUCT failed\n",
                         sizeof(SCRATCH_STRUCT) * MAX_XDS_FOR_TR_CALLS, MAX_XDS_FOR_TR_CALLS);
         return USBERR_ALLOC;
    } /* Endif */
@@ -253,8 +253,8 @@ uint_8 _usb_device_init
    usb_dev_ptr->XD_TAIL = NULL;
    usb_dev_ptr->XD_ENTRIES = 0;
 
-   /* Enqueue all the XDs */   
-   for (i=0;i<MAX_XDS_FOR_TR_CALLS;i++) 
+   /* Enqueue all the XDs */
+   for (i=0;i<MAX_XDS_FOR_TR_CALLS;i++)
    {
       xd_ptr->SCRATCH_PTR = temp_scratch_ptr;
       xd_ptr->SCRATCH_PTR->FREE = _usb_device_free_XD;
@@ -267,7 +267,7 @@ uint_8 _usb_device_init
    usb_dev_ptr->TEMP_XD_PTR = (XD_STRUCT_PTR)USB_memalloc(sizeof(XD_STRUCT));
    if(usb_dev_ptr->TEMP_XD_PTR == NULL)
    {
-        USB_printf("_usb_device_init, malloc of %d bytes for TEMP_XD_STRUCT failed\n", 
+        USB_printf("_usb_device_init, malloc of %d bytes for TEMP_XD_STRUCT failed\n",
                         sizeof(XD_STRUCT));
         _usb_device_cleanup(usb_dev_ptr);
         return USBERR_ALLOC;
@@ -278,7 +278,7 @@ uint_8 _usb_device_init
    usb_dev_ptr->STATUS_UNAIGNED_PTR = (uint_8*)USB_memalloc(sizeof(uint_16) + PSP_CACHE_LINE_SIZE);
    if(usb_dev_ptr->STATUS_UNAIGNED_PTR == NULL)
    {
-        USB_printf("_usb_device_init, malloc of %d bytes for USB_STATUS failed\n", 
+        USB_printf("_usb_device_init, malloc of %d bytes for USB_STATUS failed\n",
                         sizeof(uint_16) + PSP_CACHE_LINE_SIZE);
         _usb_device_cleanup(usb_dev_ptr);
         return USBERR_ALLOC;
@@ -290,7 +290,7 @@ uint_8 _usb_device_init
    usb_dev_ptr->TEST_PKT_UNAIGNED_PTR = (uint_8*)USB_memalloc(USB_TEST_MODE_TEST_PACKET_LENGTH + PSP_CACHE_LINE_SIZE);
    if(usb_dev_ptr->TEST_PKT_UNAIGNED_PTR == NULL)
    {
-        USB_printf("_usb_device_init, malloc of %d bytes for USB Test packet failed\n", 
+        USB_printf("_usb_device_init, malloc of %d bytes for USB Test packet failed\n",
                         USB_TEST_MODE_TEST_PACKET_LENGTH + PSP_CACHE_LINE_SIZE);
         _usb_device_cleanup(usb_dev_ptr);
         return USBERR_ALLOC;
@@ -300,7 +300,7 @@ uint_8 _usb_device_init
 
    /* Initialize the USB controller chip */
    error = _usb_dci_vusb20_init(devnum, usb_dev_ptr);
-   if (error) 
+   if (error)
    {
         _usb_device_cleanup(usb_dev_ptr);
         USB_printf("_usb_device_init, init failed");
@@ -313,7 +313,7 @@ uint_8 _usb_device_init
                 (unsigned)usb_dev_ptr->TEMP_XD_PTR);
 
    *handle = usb_dev_ptr;
-   return USB_OK;   
+   return USB_OK;
 } /* EndBody */
 
 
@@ -332,30 +332,30 @@ void _usb_device_shutdown(_usb_device_ha
     int                          ep;
 
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_CTRL, "shutdown\n");
-   
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
 
     for(ep=0; ep<(usb_dev_ptr->MAX_ENDPOINTS); ep++)
     {
         /* Cancel all transfers on all endpoints */
-        while(_usb_device_get_transfer_status(handle, ep, ARC_USB_RECV) != 
+        while(_usb_device_get_transfer_status(handle, ep, ARC_USB_RECV) !=
                                                     ARC_USB_STATUS_IDLE)
         {
             _usb_device_cancel_transfer(handle, ep, ARC_USB_RECV);
         }
-        while(_usb_device_get_transfer_status(handle, ep, ARC_USB_SEND) != 
+        while(_usb_device_get_transfer_status(handle, ep, ARC_USB_SEND) !=
                                                     ARC_USB_STATUS_IDLE)
         {
             _usb_device_cancel_transfer(handle, ep, ARC_USB_SEND);
         }
     }
     _usb_dci_vusb20_shutdown(usb_dev_ptr);
-   
+
     /* Free all the Callback function structure memory */
     for( service_ptr = usb_dev_ptr->SERVICE_HEAD_PTR; service_ptr;
-         service_ptr = service_ptr->NEXT) 
+         service_ptr = service_ptr->NEXT)
     {
-        USB_printf("_usb_device_shutdown: free service_ptr = 0x%x\n", 
+        USB_printf("_usb_device_shutdown: free service_ptr = 0x%x\n",
                             service_ptr);
         USB_memfree(service_ptr);
     }
@@ -366,21 +366,21 @@ void _usb_device_shutdown(_usb_device_ha
 
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _usb_device_register_service
 * Returned Value : USB_OK or error code
 * Comments       :
 *     Registers a callback routine for a specified event or endpoint.
-* 
+*
 *END*--------------------------------------------------------------------*/
 uint_8 _usb_device_register_service
    (
       /* [IN] Handle to the USB device */
       _usb_device_handle         handle,
-      
+
       /* [IN] type of event or endpoint number to service */
       uint_8                     type,
-      
+
       /* [IN] Pointer to the service's callback function */
       void(_CODE_PTR_ service)(pointer, uint_8, boolean, uint_8, uint_8_ptr, uint_32, uint_8)
    )
@@ -389,17 +389,17 @@ uint_8 _usb_device_register_service
    SERVICE_STRUCT_PTR         service_ptr;
    SERVICE_STRUCT_PTR _PTR_   search_ptr;
    int                        lockKey;
- 
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    /* Needs mutual exclusion */
    lockKey = USB_lock();
-   
+
    /* Search for an existing entry for type */
    for (search_ptr = &usb_dev_ptr->SERVICE_HEAD_PTR;
       *search_ptr;
-      search_ptr = &(*search_ptr)->NEXT) 
+      search_ptr = &(*search_ptr)->NEXT)
    {
-      if ((*search_ptr)->TYPE == type) 
+      if ((*search_ptr)->TYPE == type)
       {
          /* Found an existing entry */
          USB_unlock(lockKey);
@@ -407,13 +407,13 @@ uint_8 _usb_device_register_service
          return USBERR_OPEN_SERVICE;
       } /* Endif */
    } /* Endfor */
-   
+
    /* No existing entry found - create a new one */
    service_ptr = (SERVICE_STRUCT_PTR)USB_memalloc(sizeof(SERVICE_STRUCT));
-   if (!service_ptr) 
+   if (!service_ptr)
    {
       USB_unlock(lockKey);
-      USB_printf("_usb_device_register_service, malloc for %d bytes failed\n", 
+      USB_printf("_usb_device_register_service, malloc for %d bytes failed\n",
                     sizeof(SERVICE_STRUCT));
       return USBERR_ALLOC;
    } /* Endif */
@@ -422,19 +422,19 @@ uint_8 _usb_device_register_service
    service_ptr->SERVICE = service;
    service_ptr->NEXT = NULL;
    *search_ptr = service_ptr;
-   
+
    USB_unlock(lockKey);
 
    return USB_OK;
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _usb_device_unregister_service
 * Returned Value : USB_OK or error code
 * Comments       :
 *     Unregisters a callback routine for a specified event or endpoint.
-* 
+*
 *END*--------------------------------------------------------------------*/
 uint_8 _usb_device_unregister_service
    (
@@ -449,35 +449,35 @@ uint_8 _usb_device_unregister_service
    SERVICE_STRUCT_PTR         service_ptr;
    SERVICE_STRUCT_PTR _PTR_   search_ptr;
    int                        lockKey;
- 
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    /* Needs mutual exclusion */
    lockKey = USB_lock();
-   
+
    /* Search for an existing entry for type */
    for (search_ptr = &usb_dev_ptr->SERVICE_HEAD_PTR;
       *search_ptr;
-      search_ptr = &(*search_ptr)->NEXT) 
+      search_ptr = &(*search_ptr)->NEXT)
    {
       if ((*search_ptr)->TYPE == type) {
          /* Found an existing entry - delete it */
          break;
       } /* Endif */
    } /* Endfor */
-   
+
    /* No existing entry found */
-   if (!*search_ptr) 
+   if (!*search_ptr)
    {
       USB_unlock(lockKey);
       USB_printf("_usb_device_unregister_service, no service found\n");
       return USBERR_CLOSED_SERVICE;
    } /* Endif */
-   
+
    service_ptr = *search_ptr;
    *search_ptr = service_ptr->NEXT;
 
    USB_memfree((pointer)service_ptr);
-   
+
    USB_unlock(lockKey);
 
    return USB_OK;
@@ -485,13 +485,13 @@ uint_8 _usb_device_unregister_service
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _usb_device_call_service
 * Returned Value : USB_OK or error code
 * Comments       :
 *     Calls the appropriate service for the specified type, if one is
 *     registered. Used internally only.
-* 
+*
 *END*--------------------------------------------------------------------*/
 uint_8 _usb_device_call_service
    (
@@ -500,16 +500,16 @@ uint_8 _usb_device_call_service
 
       /* [OUT] Type of service or endpoint */
       uint_8               type,
-      
+
       /* [OUT] Is it a Setup transfer? */
       boolean              setup,
-      
+
       /* [OUT] Direction of transmission; is it a Transmit? */
       boolean              direction,
 
       /* [OUT] Pointer to the data */
       uint_8_ptr           buffer_ptr,
-      
+
       /* [OUT] Number of bytes in transmission */
       uint_32              length,
 
@@ -524,17 +524,17 @@ uint_8 _usb_device_call_service
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    /* Needs mutual exclusion */
    lockKey = USB_lock();
-   
+
    /* Search for an existing entry for type */
    for (service_ptr = usb_dev_ptr->SERVICE_HEAD_PTR;
         service_ptr;
-        service_ptr = service_ptr->NEXT) 
+        service_ptr = service_ptr->NEXT)
    {
-      if (service_ptr->TYPE == type) 
+      if (service_ptr->TYPE == type)
       {
 #ifdef CONFIG_MV_SP_I_FTCH_DB_INV
         if( (direction == ARC_USB_RECV) && (buffer_ptr != NULL) && (length > 0) )
-            USB_dcache_inv( buffer_ptr, length);   
+            USB_dcache_inv( buffer_ptr, length);
 #endif /* CONFIG_MV_SP_I_FTCH_DB_INV */
 
          service_ptr->SERVICE(handle, type, setup, direction, buffer_ptr, length, errors);
@@ -542,7 +542,7 @@ uint_8 _usb_device_call_service
 
          return USB_OK;
       } /* Endif */
-      
+
    } /* Endfor */
 
    USB_unlock(lockKey);
@@ -557,7 +557,7 @@ uint_8 _usb_device_call_service
 *  Function Name  : _usb_device_init_endpoint
 *  Returned Value : USB_OK or error code
 *  Comments       :
-*     Initializes the endpoint and the data structures associated with the 
+*     Initializes the endpoint and the data structures associated with the
 *  endpoint
 *
 *END*-----------------------------------------------------------------*/
@@ -565,30 +565,30 @@ uint_8 _usb_device_init_endpoint
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] MAX Packet size for this endpoint */
       uint_16                    max_pkt_size,
-            
+
       /* [IN] Direction */
       uint_8                     direction,
-            
+
       /* [IN] Type of Endpoint */
       uint_8                     type,
-            
-      /* [IN] After all data is transfered, should we terminate the transfer 
-      ** with a zero length packet if the last packet size == MAX_PACKET_SIZE? 
+
+      /* [IN] After all data is transfered, should we terminate the transfer
+      ** with a zero length packet if the last packet size == MAX_PACKET_SIZE?
       */
-      uint_8                     flag   
+      uint_8                     flag
    )
 { /* Body */
 
     int                         lockKey;
     uint_8                      error = 0;
     USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
-   
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
 
     /* Initialize the transfer descriptor */
@@ -597,13 +597,13 @@ uint_8 _usb_device_init_endpoint
     usb_dev_ptr->TEMP_XD_PTR->WMAXPACKETSIZE = max_pkt_size;
     usb_dev_ptr->TEMP_XD_PTR->EP_TYPE = type;
     usb_dev_ptr->TEMP_XD_PTR->DONT_ZERO_TERMINATE = flag;
-    usb_dev_ptr->TEMP_XD_PTR->MAX_PKTS_PER_UFRAME = 
+    usb_dev_ptr->TEMP_XD_PTR->MAX_PKTS_PER_UFRAME =
                     ((flag & ARC_USB_MAX_PKTS_PER_UFRAME) >> 1);
 
     lockKey = USB_lock();
     error = _usb_dci_vusb20_init_endpoint(handle, usb_dev_ptr->TEMP_XD_PTR);
     USB_unlock(lockKey);
-   
+
    return error;
 
 } /* EndBody */
@@ -613,7 +613,7 @@ uint_8 _usb_device_init_endpoint
 *  Function Name  : _usb_device_deinit_endpoint
 *  Returned Value : USB_OK or error code
 *  Comments       :
-*  Disables the endpoint and the data structures associated with the 
+*  Disables the endpoint and the data structures associated with the
 *  endpoint
 *
 *END*-----------------------------------------------------------------*/
@@ -621,10 +621,10 @@ uint_8 _usb_device_deinit_endpoint
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                    ep_num,
-            
+
       /* [IN] Direction */
       uint_8                    direction
    )
@@ -634,9 +634,9 @@ uint_8 _usb_device_deinit_endpoint
    lockKey = USB_lock();
 
    error = _usb_dci_vusb20_deinit_endpoint(handle, ep_num, direction);
-   
+
    USB_unlock(lockKey);
-   
+
    return error;
 } /* EndBody */
 
@@ -652,10 +652,10 @@ uint_8 _usb_device_get_transfer_status
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -687,16 +687,16 @@ void _usb_device_read_setup_data
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] buffer for receiving Setup packet */
       uint_8_ptr                  buff_ptr
    )
 { /* Body */
    int                           lockKey;
- 
+
    lockKey = USB_lock();
 
    _usb_dci_vusb20_get_setup_data(handle, ep_num, buff_ptr);
@@ -717,21 +717,21 @@ uint_8 _usb_device_cancel_transfer
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
 { /* Body */
    uint_8                        error = USB_OK;
    int                           lockKey;
-   
+
    lockKey = USB_lock();
 
-   /* Cancel transfer on the specified endpoint for the specified 
-   ** direction 
+   /* Cancel transfer on the specified endpoint for the specified
+   ** direction
    */
    error = _usb_dci_vusb20_cancel_transfer(handle, ep_num, direction);
 
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevPrv.h
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevPrv.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -26,7 +26,7 @@ disclaimer.
 
 #define USB_TEST_MODE_TEST_PACKET_LENGTH   (53)
 
- 
+
 #define USB_XD_QADD(head,tail,XD)      \
    if ((head) == NULL) {         \
       (head) = (XD);            \
@@ -35,7 +35,7 @@ disclaimer.
    } /* Endif */                 \
    (tail) = (XD);               \
    (XD)->SCRATCH_PTR->PRIVATE = NULL
-   
+
 #define USB_XD_QGET(head,tail,XD)      \
    (XD) = (head);               \
    if (head) {                   \
@@ -53,7 +53,7 @@ disclaimer.
    } /* Endif */                 \
    (tail) = (dTD);               \
    (dTD)->SCRATCH_PTR->PRIVATE = NULL
-   
+
 #define EHCI_DTD_QGET(head,tail,dTD)      \
    (dTD) = (head);               \
    if (head) {                   \
@@ -87,7 +87,7 @@ typedef struct
     uint_32     usb_complete_isr_count;
     uint_32     usb_complete_count;
     uint_32     usb_complete_max_count;
-    uint_32     usb_port_change_count; 
+    uint_32     usb_port_change_count;
     uint_32     usb_suspend_count;
     uint_32     usb_complete_ep_count[ARC_USB_MAX_ENDPOINTS*2];
 
@@ -96,7 +96,7 @@ typedef struct
 
 
 /* Callback function storage structure */
-typedef struct service_struct 
+typedef struct service_struct
 {
     uint_8   TYPE;
     void     (_CODE_PTR_ SERVICE)(pointer, uint_8, boolean, uint_8, uint_8_ptr, uint_32, uint_8);
@@ -104,7 +104,7 @@ typedef struct service_struct
 
 } SERVICE_STRUCT, _PTR_ SERVICE_STRUCT_PTR;
 
-typedef struct xd_struct 
+typedef struct xd_struct
 {
     uint_8         EP_NUM;           /* Endpoint number */
     uint_8         BDIRECTION;       /* Direction : Send/Receive */
@@ -120,33 +120,33 @@ typedef struct xd_struct
 } XD_STRUCT, _PTR_ XD_STRUCT_PTR;
 
 /* The USB Device State Structure */
-typedef struct 
+typedef struct
 {
-    boolean                          BUS_RESETTING;       /* Device is 
+    boolean                          BUS_RESETTING;       /* Device is
                                                          ** being reset */
     volatile VUSB20_REG_STRUCT_PTR   CAP_REGS_PTR;        /* Capabilities registers */
 
-    volatile VUSB20_REG_STRUCT_PTR   DEV_PTR;            /* Device Controller 
-                                                         ** Register base 
+    volatile VUSB20_REG_STRUCT_PTR   DEV_PTR;            /* Device Controller
+                                                         ** Register base
                                                          ** address */
 
-    SERVICE_STRUCT_PTR               SERVICE_HEAD_PTR;   /* Head struct 
-                                                         ** address of 
-                                                         ** registered services 
+    SERVICE_STRUCT_PTR               SERVICE_HEAD_PTR;   /* Head struct
+                                                         ** address of
+                                                         ** registered services
                                                          */
     XD_STRUCT_PTR                    TEMP_XD_PTR;         /* Temp xd for ep init */
     XD_STRUCT_PTR                    XD_BASE;
-    XD_STRUCT_PTR                    XD_HEAD;             /* Head Transaction 
-                                                         ** descriptors 
+    XD_STRUCT_PTR                    XD_HEAD;             /* Head Transaction
+                                                         ** descriptors
                                                          */
-    XD_STRUCT_PTR                    XD_TAIL;             /* Tail Transaction 
-                                                         ** descriptors 
+    XD_STRUCT_PTR                    XD_TAIL;             /* Tail Transaction
+                                                         ** descriptors
                                                          */
     uint_32                          XD_ENTRIES;
     uint_8*                          EP_QUEUE_HEAD_BASE;
     uint_32                          EP_QUEUE_HEAD_PHYS;
     uint_32                          EP_QUEUE_HEAD_SIZE;
-    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  EP_QUEUE_HEAD_PTR;   /* Endpoint Queue head */   
+    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  EP_QUEUE_HEAD_PTR;   /* Endpoint Queue head */
 
     uint_8*                          DTD_BASE_PTR;        /* Device transfer descriptor pool address */
     uint_32                          DTD_BASE_PHYS;
@@ -158,10 +158,10 @@ typedef struct
     VUSB20_EP_TR_STRUCT_PTR          EP_DTD_HEADS[ARC_USB_MAX_ENDPOINTS * 2];
     VUSB20_EP_TR_STRUCT_PTR          EP_DTD_TAILS[ARC_USB_MAX_ENDPOINTS * 2];
     SCRATCH_STRUCT_PTR               XD_SCRATCH_STRUCT_BASE;
-   
-   
+
+
     SCRATCH_STRUCT_PTR               SCRATCH_STRUCT_BASE;
-   
+
     uint_16                          USB_STATE;
     uint_16                          USB_DEVICE_STATE;
     uint_16                          USB_SOF_COUNT;
@@ -169,19 +169,19 @@ typedef struct
     uint_16                          ERRORS;
     uint_16                          ERROR_STATE;
     uint_16                          USB_DEV_STATE_B4_SUSPEND;
-    uint_8                           DEV_NUM;             /* USB device number 
-                                                         ** on the board 
+    uint_8                           DEV_NUM;             /* USB device number
+                                                         ** on the board
                                                          */
-    uint_8                           SPEED;               /* Low Speed, 
-                                                         ** High Speed, 
-                                                         ** Full Speed 
+    uint_8                           SPEED;               /* Low Speed,
+                                                         ** High Speed,
+                                                         ** Full Speed
                                                          */
     uint_8                           MAX_ENDPOINTS;       /* Max endpoints
                                                          ** supported by this
                                                          ** device
                                                          */
-                                                         
-    uint_8                           USB_CURR_CONFIG;                                                         
+
+    uint_8                           USB_CURR_CONFIG;
     uint_8                           DEVICE_ADDRESS;
     uint_8                           FORCE_FS;
     USB_STATS                        STATS;
@@ -256,10 +256,10 @@ extern uint_8*  usbSramBase;
 extern int      usbSramSize;
 
 void    _usb_reset_send_queue(void);
-void    usbSendComplete(void* handle, uint_8 type, boolean setup, uint_8 dir, 
+void    usbSendComplete(void* handle, uint_8 type, boolean setup, uint_8 dir,
                         uint_8_ptr buffer, uint_32 length, uint_8 error);
 #endif /* USB_UNDERRUN_WA */
-                         
+
 #ifdef __cplusplus
 }
 #endif
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevRecv.c
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevRecv.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -35,13 +35,13 @@ uint_8 _usb_device_recv_data
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] buffer to receive data */
       uint_8_ptr                 buff_ptr,
-            
+
       /* [IN] length of the transfer */
       uint_32                    size
    )
@@ -50,7 +50,7 @@ uint_8 _usb_device_recv_data
     uint_8                           error = USB_OK;
     XD_STRUCT_PTR                    xd_ptr;
     USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
-   
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
 
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RX, "recv_data: ep=%d, buf_ptr=0x%x, size=%d\n",
@@ -59,38 +59,38 @@ uint_8 _usb_device_recv_data
     ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_recv_count++));
 
     if(buff_ptr != NULL)
-        USB_dcache_inv((pointer)buff_ptr,size);   
-    
+        USB_dcache_inv((pointer)buff_ptr,size);
+
     lockKey = USB_lock();
 
-    if (!usb_dev_ptr->XD_ENTRIES) 
+    if (!usb_dev_ptr->XD_ENTRIES)
     {
         USB_unlock(lockKey);
         USB_printf("_usb_device_recv_data, transfer in progress\n");
         return ARC_USB_STATUS_TRANSFER_IN_PROGRESS;
     } /* Endif */
 
-    /* Get a transfer descriptor for the specified endpoint 
-    ** and direction 
+    /* Get a transfer descriptor for the specified endpoint
+    ** and direction
     */
     USB_XD_QGET(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, xd_ptr);
-   
+
     usb_dev_ptr->XD_ENTRIES--;
 
-    /* Initialize the new transfer descriptor */      
+    /* Initialize the new transfer descriptor */
     xd_ptr->EP_NUM = ep_num;
     xd_ptr->BDIRECTION = ARC_USB_RECV;
     xd_ptr->WTOTALLENGTH = size;
     xd_ptr->WSOFAR = 0;
     xd_ptr->WSTARTADDRESS = buff_ptr;
-   
+
     xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
 
     error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
 
     USB_unlock(lockKey);
-   
-    if (error) 
+
+    if (error)
     {
         USB_printf("_usb_device_recv_data, receive failed\n");
         return USBERR_RX_FAILED;
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevSend.c
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevSend.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -69,7 +69,7 @@ void    _usb_reset_send_queue(void)
         usbSendQueue.size[i] = 0;
         usbSendQueue.buff_ptr[i] = NULL;
         usbSendQueue.ep_num[i] = 0;
-    }        
+    }
 	usbSramPartSize = usbSramSize/global_wa_sram_parts;
 
     for(i=0; i<global_wa_sram_parts; i++)
@@ -99,14 +99,14 @@ uint_8 _usb_prepare_to_send(void*   hand
 	    return 0;
 
 /*
-    USB_printf("_usb_prepare_to_send: num=%d, tail=%d, sentSize=%d, size=%d, buff=%p\n", 
+    USB_printf("_usb_prepare_to_send: num=%d, tail=%d, sentSize=%d, size=%d, buff=%p\n",
                 num_dma, tail_dma, usbSentSize, size, buff_ptr);
 */
     for(i=0; i<global_wa_sram_parts; i++)
     {
 	    if(sram_parts[dma_index] != S_FREE)
 	        break;
-	
+
 	    if(usbDmaSize >= usbSendQueue.size[tail_dma])
 	    {
 	        /* Remove from the usbSendQueues */
@@ -124,7 +124,7 @@ uint_8 _usb_prepare_to_send(void*   hand
         }
 
 	    buff_ptr = usbSendQueue.buff_ptr[tail_dma] + usbDmaSize;
-	    size = MIN(usbSramPartSize, (usbSendQueue.size[tail_dma] - usbDmaSize) ); 
+	    size = MIN(usbSramPartSize, (usbSendQueue.size[tail_dma] - usbDmaSize) );
 
 	    usbDmaSize += size;
 
@@ -139,20 +139,20 @@ uint_8 _usb_prepare_to_send(void*   hand
             if(dma_index == global_wa_sram_parts)
                 dma_index = 0;
 	    }
-        
+
 
 	    /* Get a transfer descriptor */
 	    USB_XD_QGET(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, xd_ptr);
 
 	    usb_dev_ptr->XD_ENTRIES--;
-	    USB_dcache_flush((pointer)buff_ptr, size);   
+	    USB_dcache_flush((pointer)buff_ptr, size);
 
-	    /* Initialize the new transfer descriptor */      
+	    /* Initialize the new transfer descriptor */
 	    xd_ptr->EP_NUM = usbSendQueue.ep_num[tail_dma];
 	    xd_ptr->BDIRECTION = ARC_USB_SEND;
 	    xd_ptr->WTOTALLENGTH = size;
 	    xd_ptr->WSOFAR = 0;
-	    xd_ptr->WSTARTADDRESS = buff_ptr;   
+	    xd_ptr->WSTARTADDRESS = buff_ptr;
 	    xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
 
 	    error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
@@ -161,7 +161,7 @@ uint_8 _usb_prepare_to_send(void*   hand
 	        break;
     }
 
-    return error;    
+    return error;
 }
 
 
@@ -173,7 +173,7 @@ uint_8 _usb_prepare_to_send(void*   hand
 *        Callback for send transfer complete event.
 *
 *END*-----------------------------------------------------------------*/
-void    usbSendComplete(void* handle, uint_8 type, boolean setup, uint_8 dir, 
+void    usbSendComplete(void* handle, uint_8 type, boolean setup, uint_8 dir,
                         uint_8_ptr buffer, uint_32 length, uint_8 error)
 {
     /* Check if this complete is one from the sendQueue */
@@ -192,8 +192,8 @@ void    usbSendComplete(void* handle, ui
         buff_ptr = usbSendQueue.buff_ptr[tail];
         size = usbSendQueue.size[tail];
 /*
-        USB_printf("usbSendComplete: num=%d, tail=%d, usbSentSize=%d, type=%d, length=%d (%d), buff=%p (%p)\n", 
-                num, tail, usbSentSize, type, length, usbSendQueue.size[tail], 
+        USB_printf("usbSendComplete: num=%d, tail=%d, usbSentSize=%d, type=%d, length=%d (%d), buff=%p (%p)\n",
+                num, tail, usbSentSize, type, length, usbSendQueue.size[tail],
                 buffer, usbSendQueue.buff_ptr[tail]);
 */
         usbSentSize += length;
@@ -221,24 +221,24 @@ void    usbSendComplete(void* handle, ui
             usbSentSize = 0;
 
             /* Call complete callback */
-            _usb_device_call_service(handle, type, setup, dir, 
+            _usb_device_call_service(handle, type, setup, dir,
                          buff_ptr, size, error);
 
             if(num == 0)
                 return;
         }
 
-	    error = _usb_prepare_to_send(handle);	
-        if (error) 
+	    error = _usb_prepare_to_send(handle);
+        if (error)
         {
             USB_printf("usbSendComplete, add_dTD failed\n");
-        }	
+        }
 
     }
     else
     {
         /* Call complete callback */
-        _usb_device_call_service(handle, type, setup, dir, 
+        _usb_device_call_service(handle, type, setup, dir,
                         buffer, length, error);
     }
 }
@@ -257,13 +257,13 @@ uint_8 _usb_device_send_data
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] buffer to send */
       uint_8_ptr                 buff_ptr,
-            
+
       /* [IN] length of the transfer */
       uint_32                    size
    )
@@ -277,14 +277,14 @@ uint_8 _usb_device_send_data
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TX,
-       "send_data: handle=%p, ep=%d, pBuf=0x%x, size=%d, EP_QH=%p\n", 
+       "send_data: handle=%p, ep=%d, pBuf=0x%x, size=%d, EP_QH=%p\n",
        handle, ep_num, (unsigned)buff_ptr, (int)size, usb_dev_ptr->EP_QUEUE_HEAD_PTR);
 
    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_send_count++));
-      
+
    lockKey = USB_lock();
 
-   if (!usb_dev_ptr->XD_ENTRIES) 
+   if (!usb_dev_ptr->XD_ENTRIES)
    {
       USB_unlock(lockKey);
       USB_printf("_usb_device_send_data, transfer in progress\n");
@@ -294,15 +294,15 @@ uint_8 _usb_device_send_data
 #if defined(USB_UNDERRUN_WA)
     {
         int 			                head;
-       	VUSB20_EP_QUEUE_HEAD_STRUCT* 	ep_queue_head_ptr;
+	VUSB20_EP_QUEUE_HEAD_STRUCT* 	ep_queue_head_ptr;
 
-		ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + 
-                       						                  2*ep_num + ARC_USB_SEND;
+		ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
+								                  2*ep_num + ARC_USB_SEND;
 
-        if( ((ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF) > global_wa_threshold) 
+        if( ((ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF) > global_wa_threshold)
         {
             /* Only Endpoints with maxPktSize more than 128 bytes need special processing */
-            if( (size > global_wa_threshold) || 
+            if( (size > global_wa_threshold) ||
                 (usbSendQueue.num != 0) )
             {
 /*
@@ -351,21 +351,21 @@ uint_8 _usb_device_send_data
         usb_dev_ptr->XD_ENTRIES--;
 
         if(buff_ptr != NULL)
-            USB_dcache_flush((pointer)buff_ptr, size);   
+            USB_dcache_flush((pointer)buff_ptr, size);
 
-        /* Initialize the new transfer descriptor */      
+        /* Initialize the new transfer descriptor */
         xd_ptr->EP_NUM = ep_num;
         xd_ptr->BDIRECTION = ARC_USB_SEND;
         xd_ptr->WTOTALLENGTH = size;
         xd_ptr->WSOFAR = 0;
-        xd_ptr->WSTARTADDRESS = buff_ptr;   
+        xd_ptr->WSTARTADDRESS = buff_ptr;
         xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
 
         error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
     }
     USB_unlock(lockKey);
-   
-    if (error) 
+
+    if (error)
     {
         USB_printf("_usb_device_send_data, transfer failed\n");
         return USBERR_TX_FAILED;
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevUtl.c
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbDevUtl.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -37,55 +37,55 @@ void _usb_device_unstall_endpoint
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
 { /* Body */
    USB_DEV_STATE_STRUCT_PTR   	usb_dev_ptr;
    int							lockKey;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
- 
+
    lockKey = USB_lock();
-   
+
    _usb_dci_vusb20_unstall_endpoint(handle, ep_num, direction);
 
    USB_unlock(lockKey);
-  
+
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _usb_device_get_status
 * Returned Value : USB_OK or error code
 * Comments       :
 *     Provides API to access the USB internal state.
-* 
+*
 *END*--------------------------------------------------------------------*/
 uint_8 _usb_device_get_status
    (
       /* [IN] Handle to the USB device */
       _usb_device_handle   handle,
-      
+
       /* [IN] What to get the status of */
       uint_8               component,
-      
+
       /* [OUT] The requested status */
       uint_16_ptr          status
    )
 { /* Body */
-   	USB_DEV_STATE_STRUCT_PTR 	usb_dev_ptr;
+	USB_DEV_STATE_STRUCT_PTR 	usb_dev_ptr;
 	int							lockKey;
 
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
-  
+
    lockKey = USB_lock();
 
-   switch (component) 
+   switch (component)
    {
       case ARC_USB_STATUS_DEVICE_STATE:
          *status = usb_dev_ptr->USB_STATE;
@@ -98,11 +98,11 @@ uint_8 _usb_device_get_status
       case ARC_USB_STATUS_INTERFACE:
           *status = 0;
          break;
-         
+
       case ARC_USB_STATUS_ADDRESS:
          *status = usb_dev_ptr->DEVICE_ADDRESS;
          break;
-         
+
       case ARC_USB_STATUS_CURRENT_CONFIG:
          *status = usb_dev_ptr->USB_CURR_CONFIG;
          break;
@@ -110,34 +110,34 @@ uint_8 _usb_device_get_status
       case ARC_USB_STATUS_SOF_COUNT:
          *status = usb_dev_ptr->USB_SOF_COUNT;
          break;
-   
+
       default:
             USB_unlock(lockKey);
             USB_printf("_usb_device_get_status, bad status\n");
             return USBERR_BAD_STATUS;
-  
+
    } /* Endswitch */
    USB_unlock(lockKey);
-  
-   return USB_OK;   
-} /* EndBody */  
- 
+
+   return USB_OK;
+} /* EndBody */
+
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _usb_device_set_status
 * Returned Value : USB_OK or error code
 * Comments       :
 *     Provides API to set internal state
-* 
+*
 *END*--------------------------------------------------------------------*/
 uint_8 _usb_device_set_status
    (
       /* [IN] Handle to the usb device */
       _usb_device_handle   handle,
-      
+
       /* [IN] What to set the status of */
       uint_8               component,
-      
+
       /* [IN] What to set the status to */
       uint_16              setting
    )
@@ -145,13 +145,13 @@ uint_8 _usb_device_set_status
    USB_DEV_STATE_STRUCT_PTR usb_dev_ptr;
    int 					    lockKey;
 
-   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STATUS, 
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STATUS,
             "set_status: component=0x%x, value=0x%x\n", component, setting);
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    lockKey = USB_lock();
 
-   switch (component) 
+   switch (component)
    {
       case ARC_USB_STATUS_DEVICE_STATE:
          usb_dev_ptr->USB_STATE = setting;
@@ -185,21 +185,21 @@ uint_8 _usb_device_set_status
 
          _usb_dci_vusb20_set_address((pointer)usb_dev_ptr, setting);
          break;
-      
+
       case ARC_USB_STATUS_TEST_MODE:
          _usb_dci_vusb20_set_test_mode(handle, setting);
          break;
-         
+
       default:
             USB_unlock(lockKey);
             USB_printf("_usb_device_set_status, bad status\n");
             return USBERR_BAD_STATUS;
-  
+
    } /* Endswitch */
 
    USB_unlock(lockKey);
-   
-   return USB_OK;   
+
+   return USB_OK;
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -214,10 +214,10 @@ void _usb_device_stall_endpoint
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -232,7 +232,7 @@ void _usb_device_stall_endpoint
    _usb_dci_vusb20_stall_endpoint(handle, ep_num, direction);
 
    USB_unlock(lockKey);
-   
+
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -247,10 +247,10 @@ uint_8 _usb_device_is_endpoint_stalled
    (
       /* [IN] the USB_USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -268,7 +268,7 @@ uint_8 _usb_device_is_endpoint_stalled
    USB_unlock(lockKey);
 
    return val;
-   
+
 } /* EndBody */
 
 
@@ -287,7 +287,7 @@ void _usb_device_assert_resume
    )
 { /* Body */
    USB_DEV_STATE_STRUCT_PTR      usb_dev_ptr;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
 
    _usb_dci_vusb20_assert_resume(handle);
@@ -313,21 +313,21 @@ void _usb_status(void* usbHandle)
     USB_printf("DEV_NUM=%d, DEV_ADDR=%d, CAP_REGS=0x%x, DEV_REGS=0x%x, MAX_EP=%d\n",
                 pUsbDev->DEV_NUM,
                 pUsbDev->DEVICE_ADDRESS,
-                (unsigned)pUsbDev->CAP_REGS_PTR, 
-                (unsigned)pUsbDev->DEV_PTR, 
+                (unsigned)pUsbDev->CAP_REGS_PTR,
+                (unsigned)pUsbDev->DEV_PTR,
                 pUsbDev->MAX_ENDPOINTS);
 
     USB_printf("BUS_RESET=%s, STATE=0x%02x, DEV_STATE=0x%02x, SPEED=%d, ERRORS=%d, ERROR_STATE=0x%04x\n",
                 pUsbDev->BUS_RESETTING ? "Yes" : "No",
                 pUsbDev->USB_STATE,
                 pUsbDev->USB_DEVICE_STATE,
-                pUsbDev->SPEED, 
+                pUsbDev->SPEED,
                 pUsbDev->ERRORS,
                 pUsbDev->ERROR_STATE);
 
     USB_printf("EP_QUEUE_HEAD: SIZE=%d, BASE=%p (0x%08x), ALIGNED=%p, SERVICE_HEAD=%p\n",
                 pUsbDev->EP_QUEUE_HEAD_SIZE,
-                pUsbDev->EP_QUEUE_HEAD_BASE, 
+                pUsbDev->EP_QUEUE_HEAD_BASE,
                 pUsbDev->EP_QUEUE_HEAD_PHYS,
                 pUsbDev->EP_QUEUE_HEAD_PTR,
                 pUsbDev->SERVICE_HEAD_PTR);
@@ -359,33 +359,33 @@ void _usb_stats(void* usbHandle)
 
     USB_printf("\n\tUSB Statistics\n\n");
 
-    USB_printf("isr=%u, empty_isr=%u, reset=%u, setup=%u, read_setup=%u\n", 
-                    pUsbStats->usb_isr_count, pUsbStats->usb_empty_isr_count, 
-                    pUsbStats->usb_reset_count, pUsbStats->usb_setup_count, 
+    USB_printf("isr=%u, empty_isr=%u, reset=%u, setup=%u, read_setup=%u\n",
+                    pUsbStats->usb_isr_count, pUsbStats->usb_empty_isr_count,
+                    pUsbStats->usb_reset_count, pUsbStats->usb_setup_count,
                     pUsbStats->usb_read_setup_count);
 
-    USB_printf("recv=%u, send=%u, add=%u (%u), cancel=%u\n", 
-                pUsbStats->usb_recv_count, pUsbStats->usb_send_count, 
-                pUsbStats->usb_add_count, pUsbStats->usb_add_not_empty_count, 
+    USB_printf("recv=%u, send=%u, add=%u (%u), cancel=%u\n",
+                pUsbStats->usb_recv_count, pUsbStats->usb_send_count,
+                pUsbStats->usb_add_count, pUsbStats->usb_add_not_empty_count,
                 pUsbStats->usb_cancel_count);
 
-    USB_printf("free_XD=%u, free_dTD=%u\n", 
+    USB_printf("free_XD=%u, free_dTD=%u\n",
             pUsbStats->free_XD_count, pUsbStats->free_dTD_count);
 
-    USB_printf("complete_isr=%u, complete=%u, empty_complete=%u, max_complete=%u\n", 
-                pUsbStats->usb_complete_isr_count, pUsbStats->usb_complete_count, 
+    USB_printf("complete_isr=%u, complete=%u, empty_complete=%u, max_complete=%u\n",
+                pUsbStats->usb_complete_isr_count, pUsbStats->usb_complete_count,
                 pUsbStats->usb_empty_complete_count, pUsbStats->usb_complete_max_count);
 
-    USB_printf("port_change=%u, suspend=%u\n", 
+    USB_printf("port_change=%u, suspend=%u\n",
                 pUsbStats->usb_port_change_count, pUsbStats->usb_suspend_count);
     for(i=0; i<(pUsbDev->MAX_ENDPOINTS); i++)
     {
-        if( (pUsbStats->usb_complete_ep_count[i*2] == 0) && 
+        if( (pUsbStats->usb_complete_ep_count[i*2] == 0) &&
             (pUsbStats->usb_complete_ep_count[i*2+1] == 0) )
             continue;
 
         USB_printf("EP #%d: RECV (OUT) = %3u, \tSEND (IN) = %u\n", i,
-                    pUsbStats->usb_complete_ep_count[i*2], 
+                    pUsbStats->usb_complete_ep_count[i*2],
                     pUsbStats->usb_complete_ep_count[i*2+1]);
     }
     USB_printf("\n");
@@ -412,15 +412,15 @@ void _usb_regs(void* usbHandle)
     USB_printf("\n\tUSB Capability Registers\n\n");
 
     cap_regs = pUsbDev->CAP_REGS_PTR;
-    USB_printf("CAPLENGTH_HCIVER (0x%08x) = 0x%08x\n", 
+    USB_printf("CAPLENGTH_HCIVER (0x%08x) = 0x%08x\n",
         (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER,
         (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER));
 
-    USB_printf("DCI_VERSION      (0x%08x) = 0x%08x\n", 
+    USB_printf("DCI_VERSION      (0x%08x) = 0x%08x\n",
         (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCI_VERSION,
         (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCI_VERSION));
 
-    USB_printf("DCC_PARAMS       (0x%08x) = 0x%08x\n", 
+    USB_printf("DCC_PARAMS       (0x%08x) = 0x%08x\n",
         (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS,
         (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS));
 
@@ -428,66 +428,66 @@ void _usb_regs(void* usbHandle)
     dev_num = pUsbDev->DEV_NUM;
     USB_printf("\n\tUSB Device Operational Registers\n\n");
 
-    USB_printf("USB_CMD          (0x%08x) = 0x%08x\n", 
+    USB_printf("USB_CMD          (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
 
-    USB_printf("USB_STS          (0x%08x) = 0x%08x\n", 
+    USB_printf("USB_STS          (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS));
 
-    USB_printf("USB_INTR         (0x%08x) = 0x%08x\n", 
+    USB_printf("USB_INTR         (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR));
 
-    USB_printf("USB_FRINDEX      (0x%08x) = 0x%08x\n", 
+    USB_printf("USB_FRINDEX      (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX));
 
     /* Skip CTRLDSSEGMENT register */
-    USB_printf("DEVICE_ADDR      (0x%08x) = 0x%08x\n", 
+    USB_printf("DEVICE_ADDR      (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR));
 
-    USB_printf("EP_LIST_ADDR     (0x%08x) = 0x%08x\n", 
+    USB_printf("EP_LIST_ADDR     (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR));
 
     /* Skip CONFIG_FLAG register */
 
     /* Skip PORTSCX[0..15] registers*/
-    USB_printf("PORTSCX[0]       (0x%08x) = 0x%08x\n", 
+    USB_printf("PORTSCX[0]       (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0],
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]));
 
     /* Skip OTGSC register */
 
-    USB_printf("USB_MODE         (0x%08x) = 0x%08x\n", 
+    USB_printf("USB_MODE         (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_MODE,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_MODE));
 
-    USB_printf("ENDPT_SETUP_STAT (0x%08x) = 0x%08x\n", 
+    USB_printf("ENDPT_SETUP_STAT (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT));
 
-    USB_printf("ENDPTPRIME       (0x%08x) = 0x%08x\n", 
+    USB_printf("ENDPTPRIME       (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME));
 
-    USB_printf("ENDPTFLUSH       (0x%08x) = 0x%08x\n", 
+    USB_printf("ENDPTFLUSH       (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH));
 
-    USB_printf("ENDPTSTATUS      (0x%08x) = 0x%08x\n", 
+    USB_printf("ENDPTSTATUS      (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS));
 
-    USB_printf("ENDPTCOMPLETE    (0x%08x) = 0x%08x\n", 
+    USB_printf("ENDPTCOMPLETE    (0x%08x) = 0x%08x\n",
         (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE,
         (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE));
 }
 
-    
+
 void _usb_ep_status(void* usbHandle, int ep_num, int direction)
 {
     USB_DEV_STATE_STRUCT*               pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
@@ -518,42 +518,42 @@ void _usb_ep_status(void* usbHandle, int
     head_dTD_ptr = pUsbDev->EP_DTD_HEADS[ep_idx];
     tail_dTD_ptr = pUsbDev->EP_DTD_TAILS[ep_idx];
 
-    USB_printf("EP_QH=0x%08x: MAX_PKT=0x%x, SIZE_IOC_INT_STS=0x%x, CURR_DTD=0x%x, NEXT_DTD=0x%x\n", 
-                (unsigned)ep_queue_head_ptr, (unsigned)USB_32BIT_LE(ep_queue_head_ptr->MAX_PKT_LENGTH), 
-                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS), 
-                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR), 
+    USB_printf("EP_QH=0x%08x: MAX_PKT=0x%x, SIZE_IOC_INT_STS=0x%x, CURR_DTD=0x%x, NEXT_DTD=0x%x\n",
+                (unsigned)ep_queue_head_ptr, (unsigned)USB_32BIT_LE(ep_queue_head_ptr->MAX_PKT_LENGTH),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR),
                 (unsigned)USB_32BIT_LE(ep_queue_head_ptr->NEXT_DTD_PTR));
 
     USB_printf("\tBUF_0=0x%08x, BUF_1=0x%08x, BUF_2=0x%08x, BUF_3=0x%08x, BUF_4=0x%08x\n",
-                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR0), 
-                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR1), 
-                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR2), 
-                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR3), 
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR0),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR1),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR2),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR3),
                 (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR4));
-    
+
     USB_printf("\tSETUP_BUFFER (%p): ", ep_queue_head_ptr->SETUP_BUFFER);
     for(i=0; i<sizeof(ep_queue_head_ptr->SETUP_BUFFER); i++)
         USB_printf("%02x", ep_queue_head_ptr->SETUP_BUFFER[i] & 0xFF);
     USB_printf("\n");
 
-    USB_printf("\ndTD_HEAD=0x%08x, dTD_TAIL=0x%08x\n", 
+    USB_printf("\ndTD_HEAD=0x%08x, dTD_TAIL=0x%08x\n",
                 (unsigned)head_dTD_ptr, (unsigned)tail_dTD_ptr);
 
     dTD_ptr = head_dTD_ptr;
     i = 0;
     while(dTD_ptr != NULL)
     {
-        USB_printf("%d. dTD=0x%08x (0x%08x), SIZE_IOC_STS=0x%08x, BUF_0=0x%08x, NEXT=0x%08x\n", 
+        USB_printf("%d. dTD=0x%08x (0x%08x), SIZE_IOC_STS=0x%08x, BUF_0=0x%08x, NEXT=0x%08x\n",
                     i, (unsigned)dTD_ptr, USB_DTD_VIRT_TO_PHYS(pUsbDev, dTD_ptr),
-                    (unsigned)USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS), 
-                    (unsigned)USB_32BIT_LE(dTD_ptr->BUFF_PTR0), 
+                    (unsigned)USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS),
+                    (unsigned)USB_32BIT_LE(dTD_ptr->BUFF_PTR0),
                     (unsigned)USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR));
 
         xd_ptr = dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
 
-        next_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(pUsbDev, 
+        next_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(pUsbDev,
                            (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK));
-        if(next_dTD_ptr != NULL) 
+        if(next_dTD_ptr != NULL)
             next_xd_ptr = next_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
         else
             next_xd_ptr = NULL;
@@ -561,7 +561,7 @@ void _usb_ep_status(void* usbHandle, int
         if(next_xd_ptr != xd_ptr)
         {
             USB_printf("\tXD=0x%08x, ADDR=0x%08x, SIZE=%u, STATUS=0x%02x\n",
-                (unsigned)xd_ptr, (unsigned)xd_ptr->WSTARTADDRESS, 
+                (unsigned)xd_ptr, (unsigned)xd_ptr->WSTARTADDRESS,
                 (unsigned)xd_ptr->WTOTALLENGTH, xd_ptr->BSTATUS);
         }
         i++;
@@ -572,20 +572,20 @@ void _usb_ep_status(void* usbHandle, int
 
 /* DEBUG */
 uint_32 usbDebugFlags = ARC_DEBUG_FLAG_STATS
-                      | ARC_DEBUG_FLAG_INIT 
-                      | ARC_DEBUG_FLAG_ERROR 
+                      | ARC_DEBUG_FLAG_INIT
+                      | ARC_DEBUG_FLAG_ERROR
                       | ARC_DEBUG_FLAG_STALL
                       | ARC_DEBUG_FLAG_RESET;
                       /*| ARC_DEBUG_FLAG_TRANSFER;*/
 
-void    _usb_debug_set_flags(uint_32 flags)     
+void    _usb_debug_set_flags(uint_32 flags)
 {
-    usbDebugFlags = (flags);                        
+    usbDebugFlags = (flags);
 }
 
-uint_32 _usb_debug_get_flags(void)     
+uint_32 _usb_debug_get_flags(void)
 {
-    return usbDebugFlags;  
+    return usbDebugFlags;
 }
 
 #if defined(MV_USB_TRACE_LOG)
@@ -593,37 +593,37 @@ uint_32 _usb_debug_get_flags(void)
 uint_16 DEBUG_TRACE_ARRAY_COUNTER = 0;
 char    DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE][MAX_STRING_SIZE];
 
-void  _usb_debug_init_trace_log(void)                   
-{                                                  
+void  _usb_debug_init_trace_log(void)
+{
     USB_memzero(DEBUG_TRACE_ARRAY, TRACE_ARRAY_SIZE*MAX_STRING_SIZE);
-	DEBUG_TRACE_ARRAY_COUNTER =0;                  
-}                               
+	DEBUG_TRACE_ARRAY_COUNTER =0;
+}
+
+void    _usb_debug_print_trace_log(void)
+{
+    int     i;
+
+    USB_printf("USB Trace log: start=0x%x, end=0x%x, idx=%d, flags=0x%x\n\n",
+               &DEBUG_TRACE_ARRAY[0][0], &DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE-1][0],
+               DEBUG_TRACE_ARRAY_COUNTER, usbDebugFlags);
+
+    for(i=DEBUG_TRACE_ARRAY_COUNTER; i<TRACE_ARRAY_SIZE; i++)
+    {
+        if(DEBUG_TRACE_ARRAY[i][0] == '\0')
+            continue;
 
-void    _usb_debug_print_trace_log(void)                     
-{                                                       
-    int     i;                                          
-                                                        
-    USB_printf("USB Trace log: start=0x%x, end=0x%x, idx=%d, flags=0x%x\n\n", 
-               &DEBUG_TRACE_ARRAY[0][0], &DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE-1][0], 
-               DEBUG_TRACE_ARRAY_COUNTER, usbDebugFlags);      
-
-    for(i=DEBUG_TRACE_ARRAY_COUNTER; i<TRACE_ARRAY_SIZE; i++)                      
-    {                                                 
-        if(DEBUG_TRACE_ARRAY[i][0] == '\0')              
-            continue;                     
-        
         USB_printf("%3d. %s", i, DEBUG_TRACE_ARRAY[i]);
-    }                                                 
-    for(i=0; i<DEBUG_TRACE_ARRAY_COUNTER; i++)       
-    {                                                 
-        if(DEBUG_TRACE_ARRAY[i][0] == '\0')           
-            continue;                                 
+    }
+    for(i=0; i<DEBUG_TRACE_ARRAY_COUNTER; i++)
+    {
+        if(DEBUG_TRACE_ARRAY[i][0] == '\0')
+            continue;
         USB_printf("%3d. %s", i, DEBUG_TRACE_ARRAY[i]);
-    }                          
+    }
     _usb_debug_init_trace_log();
 }
 #else
-void  _usb_debug_init_trace_log(void)                   
+void  _usb_debug_init_trace_log(void)
 {
 }
 
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbHsDevCncl.c
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbHsDevCncl.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -36,10 +36,10 @@ uint_8 _usb_dci_vusb20_cancel_transfer
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-     
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -51,26 +51,26 @@ uint_8 _usb_dci_vusb20_cancel_transfer
    XD_STRUCT_PTR                        xd_ptr;
    uint_32                              temp, bit_pos;
    volatile unsigned long               timeout, status_timeout;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-   
+
    bit_pos = (1 << (16 * direction + ep_num));
    temp = (2*ep_num + direction);
-   
+
    ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
-   
+
    /* Unlink the dTD */
    dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[temp];
-   
-   if (dTD_ptr) 
+
+   if (dTD_ptr)
    {
       ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_cancel_count++));
 
-      check_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, 
+      check_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr,
                             ((uint_32)USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK));
 
-      if (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE) 
+      if (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE)
       {
          /* Flushing will halt the pipe */
          /* Write 1 to the Flush register */
@@ -78,43 +78,43 @@ uint_8 _usb_dci_vusb20_cancel_transfer
 
          /* Wait until flushing completed */
          timeout = 0x1000000;
-         while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH) & bit_pos) 
+         while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH) & bit_pos)
          {
             /* ENDPTFLUSH bit should be cleared to indicate this operation is complete */
             timeout--;
             if(timeout == 0)
             {
-                USB_printf("USB Cancel: - TIMEOUT for ENDPTFLUSH=0x%x, bit_pos=0x%x \n", 
-                      (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH), 
+                USB_printf("USB Cancel: - TIMEOUT for ENDPTFLUSH=0x%x, bit_pos=0x%x \n",
+                      (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH),
                       (unsigned)bit_pos);
                 break;
             }
          } /* EndWhile */
          status_timeout = 0x100000;
-         while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos) 
+         while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)
          {
             status_timeout--;
             if(status_timeout == 0)
             {
-                USB_printf("USB Cancel: - TIMEOUT for ENDPTSTATUS=0x%x, bit_pos=0x%x\n", 
-                      (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS), 
+                USB_printf("USB Cancel: - TIMEOUT for ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
+                      (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
                       (unsigned)bit_pos);
                 break;
             }
 
             /* Write 1 to the Flush register */
             dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH = USB_32BIT_LE(bit_pos);
-         
+
             /* Wait until flushing completed */
             timeout = 0x1000000;
-            while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH) & bit_pos) 
+            while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH) & bit_pos)
             {
                /* ENDPTFLUSH bit should be cleared to indicate this operation is complete */
                timeout--;
                if(timeout == 0)
                 {
-                    USB_printf("USB Cancel: - TIMEOUT for ENDPTFLUSH=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n", 
-                            (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH), 
+                    USB_printf("USB Cancel: - TIMEOUT for ENDPTFLUSH=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
+                            (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH),
                             (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
                             (unsigned)bit_pos);
                     break;
@@ -122,32 +122,32 @@ uint_8 _usb_dci_vusb20_cancel_transfer
             } /* EndWhile */
          } /* EndWhile */
       } /* Endif */
-      
+
       /* Retire the current dTD */
       dTD_ptr->SIZE_IOC_STS = 0;
       dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(VUSBHS_TD_NEXT_TERMINATE);
-      
+
       /* The transfer descriptor for this dTD */
       xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
       dTD_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
 
       ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
                       "cncl_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p, bit=0x%x\n",
-                       usb_dev_ptr->STATS.usb_cancel_count & 0xFFFF, 
-                       USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 
-                       ep_num, direction ? "in" : "out", 
-                       xd_ptr->WSTARTADDRESS, xd_ptr->WTOTALLENGTH, xd_ptr, 
+                       usb_dev_ptr->STATS.usb_cancel_count & 0xFFFF,
+                       USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+                       ep_num, direction ? "in" : "out",
+                       xd_ptr->WSTARTADDRESS, xd_ptr->WTOTALLENGTH, xd_ptr,
                        dTD_ptr, check_dTD_ptr, bit_pos);
-       
+
       /* Free the dTD */
       _usb_dci_vusb20_free_dTD((pointer)dTD_ptr);
-      
+
       /* Update the dTD head and tail for specific endpoint/direction */
-      if (!check_dTD_ptr) 
+      if (!check_dTD_ptr)
       {
          usb_dev_ptr->EP_DTD_HEADS[temp] = NULL;
          usb_dev_ptr->EP_DTD_TAILS[temp] = NULL;
-         if (xd_ptr) 
+         if (xd_ptr)
          {
             xd_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
             /* Free the transfer descriptor */
@@ -156,52 +156,52 @@ uint_8 _usb_dci_vusb20_cancel_transfer
          /* No other transfers on the queue */
          ep_queue_head_ptr->NEXT_DTD_PTR = USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE);
          ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
-      } 
-      else 
+      }
+      else
       {
          usb_dev_ptr->EP_DTD_HEADS[temp] = check_dTD_ptr;
-            
-         if (xd_ptr) 
+
+         if (xd_ptr)
          {
-            if ((uint_32)check_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD != (uint_32)xd_ptr) 
+            if ((uint_32)check_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD != (uint_32)xd_ptr)
             {
                xd_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
                /* Free the transfer descriptor */
                _usb_device_free_XD((pointer)xd_ptr);
             } /* Endif */
          } /* Endif */
-         
-         if (USB_32BIT_LE(check_dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE) 
-         {         
+
+         if (USB_32BIT_LE(check_dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE)
+         {
             /* Start CR 1015 */
             /* Prime the Endpoint */
             dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
 
-            if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)) 
+            if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos))
             {
                timeout = 0x100000;
-               while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos) 
+               while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)
                {
                   /* Wait for the ENDPTPRIME to go to zero */
                   timeout--;
                   if(timeout == 0)
                   {
-                      USB_printf("USB Cancel: - TIMEOUT for ENDPTPRIME=0x%x, bit_pos=0x%x\n", 
-                                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME), 
+                      USB_printf("USB Cancel: - TIMEOUT for ENDPTPRIME=0x%x, bit_pos=0x%x\n",
+                                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
                                 (unsigned)bit_pos);
                       break;
                   }
                } /* EndWhile */
 
-               if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos) 
+               if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)
                {
-                  /* The endpoint was not not primed so no other transfers on 
-                  ** the queue 
+                  /* The endpoint was not not primed so no other transfers on
+                  ** the queue
                   */
                   goto done;
                } /* Endif */
-            } 
-            else 
+            }
+            else
             {
                goto done;
             } /* Endif */
@@ -209,16 +209,16 @@ uint_8 _usb_dci_vusb20_cancel_transfer
             /* No other transfers on the queue */
             ep_queue_head_ptr->NEXT_DTD_PTR = (uint_32)USB_32BIT_LE((uint_32)check_dTD_ptr);
             ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
-   
+
             /* Prime the Endpoint */
             dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
          } /* Endif */
       } /* Endif */
    } /* Endif */
-   
+
 done:
 
-   /* End CR 1015 */  
+   /* End CR 1015 */
    return USB_OK;
 } /* EndBody */
 
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbHsDevMain.c
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbHsDevMain.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -46,68 +46,68 @@ uint_8 _usb_dci_vusb20_init
     uint_32                     temp;
     uint_8*                     pBuf;
     unsigned long               phyAddr;
-      
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
 
-    usb_dev_ptr->CAP_REGS_PTR = 
+    usb_dev_ptr->CAP_REGS_PTR =
        (VUSB20_REG_STRUCT_PTR)USB_get_cap_reg_addr(devnum);
-      
+
     /* Get the base address of the VUSB_HS registers */
-    usb_dev_ptr->DEV_PTR = 
-      (VUSB20_REG_STRUCT_PTR)(((uint_32)usb_dev_ptr->CAP_REGS_PTR) + 
-       (USB_32BIT_LE(usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER) & 
+    usb_dev_ptr->DEV_PTR =
+      (VUSB20_REG_STRUCT_PTR)(((uint_32)usb_dev_ptr->CAP_REGS_PTR) +
+       (USB_32BIT_LE(usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER) &
                                                                 EHCI_CAP_LEN_MASK));
 
     /* Get the maximum number of endpoints supported by this USB controller */
-    usb_dev_ptr->MAX_ENDPOINTS = 
-      (USB_32BIT_LE(usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS) & 
+    usb_dev_ptr->MAX_ENDPOINTS =
+      (USB_32BIT_LE(usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS) &
                                                 VUSB20_DCC_MAX_ENDPTS_SUPPORTED);
 
     USB_printf("USB init: CAP_REGS=0x%x, DEV_REGS=0x%x, MAX_EP=%d\n",
-                (unsigned)usb_dev_ptr->CAP_REGS_PTR, (unsigned)usb_dev_ptr->DEV_PTR, 
+                (unsigned)usb_dev_ptr->CAP_REGS_PTR, (unsigned)usb_dev_ptr->DEV_PTR,
                 usb_dev_ptr->MAX_ENDPOINTS);
 
     temp = (usb_dev_ptr->MAX_ENDPOINTS * 2);
-   
-    pBuf = (uint_8*)USB_uncached_memalloc(temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT), 
-                                          2048, &phyAddr);      
-    if (pBuf == NULL) 
+
+    pBuf = (uint_8*)USB_uncached_memalloc(temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT),
+                                          2048, &phyAddr);
+    if (pBuf == NULL)
     {
         USB_printf("_usb_dci_vusb20_init, malloc of %d bytes in Uncached area failed\n",
                         temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT));
         return USBERR_ALLOC;
     }
 
-    /****************************************************************   
+    /****************************************************************
       Assign QH base
-    ****************************************************************/   
+    ****************************************************************/
     usb_dev_ptr->EP_QUEUE_HEAD_BASE = pBuf;
     usb_dev_ptr->EP_QUEUE_HEAD_PHYS = (uint_32)phyAddr;
 
-    /* Align the endpoint queue head to 2K boundary */   
+    /* Align the endpoint queue head to 2K boundary */
     usb_dev_ptr->EP_QUEUE_HEAD_PTR = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)
                 USB_MEM2048_ALIGN((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
 
     usb_dev_ptr->EP_QUEUE_HEAD_SIZE = temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT) +
-                                      ((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_PTR - 
+                                      ((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_PTR -
                                        (uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
 
-    /****************************************************************   
+    /****************************************************************
       Zero out the memory allocated
-    ****************************************************************/   
-    USB_memzero( (void*)usb_dev_ptr->EP_QUEUE_HEAD_PTR, 
+    ****************************************************************/
+    USB_memzero( (void*)usb_dev_ptr->EP_QUEUE_HEAD_PTR,
                  temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT));
 
     USB_printf("USB EP_QH: Base=%p (0x%x), Aligned(%d)=%p, Size=%d\n",
                 usb_dev_ptr->EP_QUEUE_HEAD_BASE, usb_dev_ptr->EP_QUEUE_HEAD_PHYS,
                 2048, usb_dev_ptr->EP_QUEUE_HEAD_PTR, usb_dev_ptr->EP_QUEUE_HEAD_SIZE);
 
-    /****************************************************************   
+    /****************************************************************
       Assign DTD base
-    ****************************************************************/   
-    pBuf = (uint_8*)USB_uncached_memalloc(MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT), 
-                                          32, &phyAddr);      
-    if (pBuf == NULL) 
+    ****************************************************************/
+    pBuf = (uint_8*)USB_uncached_memalloc(MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT),
+                                          32, &phyAddr);
+    if (pBuf == NULL)
     {
         USB_printf("_usb_dci_vusb20_init, malloc of %d bytes in Uncached area failed\n",
                         MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT));
@@ -116,34 +116,34 @@ uint_8 _usb_dci_vusb20_init
 
     usb_dev_ptr->DTD_BASE_PTR = pBuf;
     usb_dev_ptr->DTD_BASE_PHYS = (uint_32)phyAddr;
-    
-    /* Align the dTD base to 32 byte boundary */   
+
+    /* Align the dTD base to 32 byte boundary */
     usb_dev_ptr->DTD_ALIGNED_BASE_PTR = (VUSB20_EP_TR_STRUCT_PTR)
                         USB_MEM32_ALIGN((uint_32)usb_dev_ptr->DTD_BASE_PTR);
 
     usb_dev_ptr->DTD_SIZE = MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT) +
-                                ((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_PTR - 
+                                ((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_PTR -
                                  (uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
 
-    /****************************************************************   
+    /****************************************************************
       Zero out the memory allocated
-    ****************************************************************/   
-    USB_memzero((void*)usb_dev_ptr->DTD_ALIGNED_BASE_PTR, 
+    ****************************************************************/
+    USB_memzero((void*)usb_dev_ptr->DTD_ALIGNED_BASE_PTR,
                 MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT));
 
-    /****************************************************************   
+    /****************************************************************
       Assign SCRATCH Structure base
-    ****************************************************************/   
-    /* Allocate memory for internal scratch structure */   
+    ****************************************************************/
+    /* Allocate memory for internal scratch structure */
     pBuf = USB_memalloc(MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
-    if (pBuf == NULL) 
+    if (pBuf == NULL)
     {
         USB_printf("_usb_dci_vusb20_init, malloc of %d bytes failed\n",
                         MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
         return USBERR_ALLOC;
     }
     usb_dev_ptr->SCRATCH_STRUCT_BASE = (SCRATCH_STRUCT_PTR)pBuf;
-    USB_memzero(usb_dev_ptr->SCRATCH_STRUCT_BASE, 
+    USB_memzero(usb_dev_ptr->SCRATCH_STRUCT_BASE,
             MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
 
     USB_printf("USB dTD(%d): Base=%p (0x%x), Aligned(%d)=%p, Size=%d, Scratch=%p\n",
@@ -153,22 +153,22 @@ uint_8 _usb_dci_vusb20_init
 
 #ifdef USB_UNDERRUN_WA
     usbSramBase = (uint_8*)USB_get_sram_addr(&usbSramSize);
-    if (usbSramBase == NULL) 
+    if (usbSramBase == NULL)
     {
-        USB_printf("_usb_dci_vusb20_init, SRAM is not available\n");                        
+        USB_printf("_usb_dci_vusb20_init, SRAM is not available\n");
         return USBERR_ALLOC;
     }
     USB_memzero(usbSramBase, usbSramSize);
-    USB_printf("USB WA_Queue: base=%p, size=%d, parts=%d\n", 
+    USB_printf("USB WA_Queue: base=%p, size=%d, parts=%d\n",
                     usbSramBase, usbSramSize, global_wa_sram_parts);
 #endif /* USB_UNDERRUN_WA */
 
     usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
 
-    /* Initialize the VUSB_HS controller */   
+    /* Initialize the VUSB_HS controller */
     _usb_dci_vusb20_chip_initialize((pointer)usb_dev_ptr);
 
-    return USB_OK;   
+    return USB_OK;
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -194,22 +194,22 @@ void _usb_dci_vusb20_chip_initialize
     volatile unsigned long           delay;
 
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "chip_initialize\n");
-   
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
 
     dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-   
+
     /* Stop the controller */
     dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= ~(USB_32BIT_LE(EHCI_CMD_RUN_STOP));
-      
+
     /* Reset the controller to get default values */
     dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_CTRL_RESET);
 
     USB_printf("USB Init: Wait for RESET completed\n");
-   
+
     delay = 0x100000;
-    while (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD & 
-                                    (USB_32BIT_LE(EHCI_CMD_CTRL_RESET))) 
+    while (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &
+                                    (USB_32BIT_LE(EHCI_CMD_CTRL_RESET)))
     {
         /* Wait for the controller reset to complete */
         delay--;
@@ -228,39 +228,39 @@ void _usb_dci_vusb20_chip_initialize
     /* Call BSP callback to complete reset process */
     USB_reset_complete(usb_dev_ptr->DEV_NUM);
 
-    /* Initialize the internal dTD head and tail to NULL */   
+    /* Initialize the internal dTD head and tail to NULL */
     usb_dev_ptr->DTD_HEAD = NULL;
     usb_dev_ptr->DTD_TAIL = NULL;
-    usb_dev_ptr->DTD_ENTRIES = 0; 
+    usb_dev_ptr->DTD_ENTRIES = 0;
     usb_dev_ptr->ERROR_STATE = 0;
 
    /* Make sure the 16 MSBs of this register are 0s */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(0);
-   
+
    ep_queue_head_ptr = usb_dev_ptr->EP_QUEUE_HEAD_PTR;
 
    /* Initialize all device queue heads */
-   for (i=0; i<(usb_dev_ptr->MAX_ENDPOINTS*2); i++) 
+   for (i=0; i<(usb_dev_ptr->MAX_ENDPOINTS*2); i++)
    {
       /* Interrupt on Setup packet */
       (ep_queue_head_ptr + i)->MAX_PKT_LENGTH = (USB_32BIT_LE(
-          ((uint_32)USB_MAX_CTRL_PAYLOAD << VUSB_EP_QUEUE_HEAD_MAX_PKT_LEN_POS) | 
+          ((uint_32)USB_MAX_CTRL_PAYLOAD << VUSB_EP_QUEUE_HEAD_MAX_PKT_LEN_POS) |
             VUSB_EP_QUEUE_HEAD_IOS));
 
       (ep_queue_head_ptr + i)->NEXT_DTD_PTR = (USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE));
    } /* Endfor */
 
    /* Configure the Endpoint List Address */
-   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR = 
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR =
                             USB_32BIT_LE(USB_EP_QH_VIRT_TO_PHYS(usb_dev_ptr, ep_queue_head_ptr));
-      
+
    port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
-   if (usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.HCS_PARAMS & 
-                                        USB_32BIT_LE(VUSB20_HCS_PARAMS_PORT_POWER_CONTROL_FLAG)) 
+   if (usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.HCS_PARAMS &
+                                        USB_32BIT_LE(VUSB20_HCS_PARAMS_PORT_POWER_CONTROL_FLAG))
    {
       port_control &= (~EHCI_PORTSCX_W1C_BITS | ~EHCI_PORTSCX_PORT_POWER);
    } /* Endif */
-   
+
    if(usb_dev_ptr->FORCE_FS == TRUE)
    {
        port_control |= EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT;
@@ -275,8 +275,8 @@ void _usb_dci_vusb20_chip_initialize
 
    temp_scratch_ptr = usb_dev_ptr->SCRATCH_STRUCT_BASE;
 
-   /* Enqueue all the dTDs */   
-   for (i=0; i<MAX_EP_TR_DESCRS; i++) 
+   /* Enqueue all the dTDs */
+   for (i=0; i<MAX_EP_TR_DESCRS; i++)
    {
       dTD_ptr->SCRATCH_PTR = temp_scratch_ptr;
       dTD_ptr->SCRATCH_PTR->FREE = _usb_dci_vusb20_free_dTD;
@@ -346,7 +346,7 @@ uint_8 _usb_dci_vusb20_add_dTD
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-     
+
       /* [IN] The transfer descriptor address */
       XD_STRUCT_PTR              xd_ptr
    )
@@ -355,10 +355,10 @@ uint_8 _usb_dci_vusb20_add_dTD
    VUSB20_REG_STRUCT_PTR            dev_ptr;
    VUSB20_EP_TR_STRUCT_PTR          dTD_ptr, temp_dTD_ptr, first_dTD_ptr = NULL;
    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  ep_queue_head_ptr;
-   uint_32                          curr_pkt_len, remaining_len; 
+   uint_32                          curr_pkt_len, remaining_len;
    uint_32                          curr_offset, temp, bit_pos;
    volatile unsigned long           timeout;
-   
+
    /*********************************************************************
    For a optimal implementation, we need to detect the fact that
    we are adding DTD to an empty list. If list is empty, we can
@@ -367,41 +367,41 @@ uint_8 _usb_dci_vusb20_add_dTD
    in skipping some code here.
    *********************************************************************/
    boolean           list_empty = FALSE;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
    remaining_len = xd_ptr->WTOTALLENGTH;
-   
+
    curr_offset = 0;
    temp = (2*xd_ptr->EP_NUM + xd_ptr->BDIRECTION);
    bit_pos = (1 << (16 * xd_ptr->BDIRECTION + xd_ptr->EP_NUM));
-   
+
    ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
 
    /*********************************************************************
    This loops iterates through the length of the transfer and divides
    the data in to DTDs each handling the a max of 0x4000 bytes of data.
    The first DTD in the list is stored in a pointer called first_dTD_ptr.
-   This pointer is later linked in to QH for processing by the hardware.   
+   This pointer is later linked in to QH for processing by the hardware.
    *********************************************************************/
 
-    do 
+    do
     {
         /* Check if we need to split the transfer into multiple dTDs */
-        if (remaining_len > VUSB_EP_MAX_LENGTH_TRANSFER) 
+        if (remaining_len > VUSB_EP_MAX_LENGTH_TRANSFER)
         {
             curr_pkt_len = VUSB_EP_MAX_LENGTH_TRANSFER;
-        } 
-        else 
+        }
+        else
         {
             curr_pkt_len = remaining_len;
         } /* Endif */
-   
-        /* Get a dTD from the queue */   
+
+        /* Get a dTD from the queue */
         EHCI_DTD_QGET(usb_dev_ptr->DTD_HEAD, usb_dev_ptr->DTD_TAIL, dTD_ptr);
-   
-        if (!dTD_ptr) 
+
+        if (!dTD_ptr)
         {
             USB_printf("Error: Can't get dTD\n");
             return USBERR_TR_FAILED;
@@ -413,7 +413,7 @@ uint_8 _usb_dci_vusb20_add_dTD
 
         usb_dev_ptr->DTD_ENTRIES--;
 
-        if (curr_offset == 0) 
+        if (curr_offset == 0)
         {
             first_dTD_ptr = dTD_ptr;
         } /* Endif */
@@ -423,7 +423,7 @@ uint_8 _usb_dci_vusb20_add_dTD
 
         /* Initialize the dTD */
         dTD_ptr->SCRATCH_PTR->PRIVATE = handle;
-   
+
         /* Set the Terminate bit */
         dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE);
 
@@ -432,22 +432,22 @@ uint_8 _usb_dci_vusb20_add_dTD
         we must initialize the multiplied field so that Host can issues
         multiple IN transactions on the endpoint. See the DTD data
         structure for MultiIO field.
-      
+
         S Garg 11/06/2003
         *************************************************************/
-      
+
         /* Fill in the transfer size */
-        if (!remaining_len) 
+        if (!remaining_len)
         {
-            dTD_ptr->SIZE_IOC_STS = USB_32BIT_LE((curr_pkt_len << 
+            dTD_ptr->SIZE_IOC_STS = USB_32BIT_LE((curr_pkt_len <<
                     VUSBHS_TD_LENGTH_BIT_POS) | (VUSBHS_TD_IOC) | (VUSBHS_TD_STATUS_ACTIVE));
-        } 
-        else 
+        }
+        else
         {
-            dTD_ptr->SIZE_IOC_STS = USB_32BIT_LE((curr_pkt_len << VUSBHS_TD_LENGTH_BIT_POS) 
+            dTD_ptr->SIZE_IOC_STS = USB_32BIT_LE((curr_pkt_len << VUSBHS_TD_LENGTH_BIT_POS)
                                                    | VUSBHS_TD_STATUS_ACTIVE);
         } /* Endif */
-   
+
         /* Set the reserved field to 0 */
         dTD_ptr->SIZE_IOC_STS &= ~USB_32BIT_LE(VUSBHS_TD_RESERVED_FIELDS);
 
@@ -457,7 +457,7 @@ uint_8 _usb_dci_vusb20_add_dTD
             uint_32 physAddr = USB_virt_to_phys((uint_8*)xd_ptr->WSTARTADDRESS + curr_offset);
 
             dTD_ptr->BUFF_PTR0 = USB_32BIT_LE(physAddr);
-            
+
             physAddr += 4096;
             dTD_ptr->BUFF_PTR1 = USB_32BIT_LE(physAddr);
 
@@ -477,10 +477,10 @@ uint_8 _usb_dci_vusb20_add_dTD
         }
         curr_offset += curr_pkt_len;
 
-      /* Maintain the first and last device transfer descriptor per 
-      ** endpoint and direction 
+      /* Maintain the first and last device transfer descriptor per
+      ** endpoint and direction
       */
-      if (!usb_dev_ptr->EP_DTD_HEADS[temp]) 
+      if (!usb_dev_ptr->EP_DTD_HEADS[temp])
       {
          usb_dev_ptr->EP_DTD_HEADS[temp] = dTD_ptr;
          /***********************************************
@@ -488,17 +488,17 @@ uint_8 _usb_dci_vusb20_add_dTD
          is empty. An empty condition is detected.
          ***********************************************/
          list_empty = TRUE;
-      } /* Endif */ 
-   
+      } /* Endif */
+
       /* Check if the transfer is to be queued at the end or beginning */
       temp_dTD_ptr = usb_dev_ptr->EP_DTD_TAILS[temp];
-      
+
       /* Remember which XD to use for this dTD */
       dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD = (pointer)xd_ptr;
-      
+
       /* New tail */
       usb_dev_ptr->EP_DTD_TAILS[temp] = dTD_ptr;
-      if (temp_dTD_ptr) 
+      if (temp_dTD_ptr)
       {
          /* Should not do |=. The Terminate bit should be zero */
          temp_dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, dTD_ptr));
@@ -508,14 +508,14 @@ uint_8 _usb_dci_vusb20_add_dTD
 
    /**************************************************************
    In the loop above DTD has already been added to the list
-   However endpoint has not been primed yet. If list is not empty 
-   we need safter ways to add DTD to the existing list. 
+   However endpoint has not been primed yet. If list is not empty
+   we need safter ways to add DTD to the existing list.
    Else we just skip to adding DTD to QH safely.
    **************************************************************/
-   
+
     if(list_empty == FALSE)
     {
-        volatile boolean    read_safe = FALSE;                      
+        volatile boolean    read_safe = FALSE;
         uint_32             prime, temp_ep_stat=0;
 
         /*********************************************************
@@ -538,7 +538,7 @@ uint_8 _usb_dci_vusb20_add_dTD
         {
             timeout = 0x1000;
             while( dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME
-                    & USB_32BIT_LE(bit_pos) ) 
+                    & USB_32BIT_LE(bit_pos) )
             {
                /* Wait for the ENDPTPRIME to go to zero */
                 timeout--;
@@ -547,11 +547,11 @@ uint_8 _usb_dci_vusb20_add_dTD
                     USB_printf(
                         "timeout: CTRL=%x, PRIME=%x, STAT=%x, INTR=%x, ADDR=%x, PORTSC=%x, dTD=%p, temp_dTD=%p\n",
                         USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]),
-                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME), 
-                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS), 
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
                         USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS),
                         USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR),
-                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]), 
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
                         first_dTD_ptr, temp_dTD_ptr);
 
                     _usb_ep_status(handle, xd_ptr->EP_NUM, xd_ptr->BDIRECTION);
@@ -574,7 +574,7 @@ uint_8 _usb_dci_vusb20_add_dTD
             timeout--;
             if(timeout <= 0)
             {
-                USB_printf("%s: Timeout for ATDTW_TRIPWIRE reg = 0x%x\n", __FUNCTION__, 
+                USB_printf("%s: Timeout for ATDTW_TRIPWIRE reg = 0x%x\n", __FUNCTION__,
                     (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
                 return USBERR_TR_FAILED;
             }
@@ -582,14 +582,14 @@ uint_8 _usb_dci_vusb20_add_dTD
            /*********************************************************
            start with setting the semaphores
            *********************************************************/
-           dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD |= 
+           dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD |=
                                           USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_SET);
-               
+
            /*********************************************************
            Read the endpoint status
            *********************************************************/
-           temp_ep_stat = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) 
-                                        & bit_pos; 
+           temp_ep_stat = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS)
+                                        & bit_pos;
 
            /*********************************************************
            Reread the ATDTW semaphore bit to check if it is cleared.
@@ -597,7 +597,7 @@ uint_8 _usb_dci_vusb20_add_dTD
            else we remain set to 1 and we can proceed with priming
            of endpoint if not already primed.
            *********************************************************/
-           if( dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD & 
+           if( dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &
                                           USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_SET))
            {
                read_safe = TRUE;
@@ -608,11 +608,11 @@ uint_8 _usb_dci_vusb20_add_dTD
         /*********************************************************
         Clear the semaphore
         *********************************************************/
-        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= 
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &=
                                        USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_CLEAR);
 
         /*********************************************************
-         * If endpoint is not active, we activate it now.               
+         * If endpoint is not active, we activate it now.
          *********************************************************/
          if(!temp_ep_stat)
          {
@@ -631,7 +631,7 @@ uint_8 _usb_dci_vusb20_add_dTD
          ep_queue_head_ptr->NEXT_DTD_PTR = USB_32BIT_LE(
                             USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, first_dTD_ptr));
          ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
-   
+
          /* Prime the Endpoint */
          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
          /* delay */
@@ -648,11 +648,11 @@ done:
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
                " add_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p, empty=%d\n",
-               usb_dev_ptr->STATS.usb_add_count & 0xFFFF, 
-               USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 
-               xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "in" : "out", 
-               xd_ptr->WSTARTADDRESS, (int)xd_ptr->WTOTALLENGTH, 
-               xd_ptr, (unsigned)first_dTD_ptr, 
+               usb_dev_ptr->STATS.usb_add_count & 0xFFFF,
+               USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+               xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "in" : "out",
+               xd_ptr->WSTARTADDRESS, (int)xd_ptr->WTOTALLENGTH,
+               xd_ptr, (unsigned)first_dTD_ptr,
                usb_dev_ptr->EP_DTD_HEADS[temp], list_empty);
 
 
@@ -677,7 +677,7 @@ void _usb_dci_vusb20_process_tr_complete
 { /* Body */
    USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
    volatile VUSB20_REG_STRUCT_PTR               dev_ptr;
-   volatile VUSB20_EP_TR_STRUCT_PTR             dTD_ptr; 
+   volatile VUSB20_EP_TR_STRUCT_PTR             dTD_ptr;
    VUSB20_EP_TR_STRUCT_PTR                      temp_dTD_ptr;
    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR              ep_queue_head_ptr;
    uint_32                                      temp, i, ep_num = 0, direction = 0, bit_pos;
@@ -688,49 +688,49 @@ void _usb_dci_vusb20_process_tr_complete
    XD_STRUCT_PTR                                temp_xd_ptr = NULL;
    uint_8_ptr                                   buff_start_address = NULL;
    boolean                                      endpoint_detected = FALSE;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_isr_count++));
 
-   /* We use separate loops for ENDPTSETUPSTAT and ENDPTCOMPLETE because the 
-   ** setup packets are to be read ASAP 
+   /* We use separate loops for ENDPTSETUPSTAT and ENDPTCOMPLETE because the
+   ** setup packets are to be read ASAP
    */
-   
+
    /* Process all Setup packet received interrupts */
    bit_pos = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT);
-   
-   if (bit_pos) 
+
+   if (bit_pos)
    {
       ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "setup_isr: bit_pos=0x%x\n", (unsigned)bit_pos);
-      for(i=0; i<USB_MAX_CONTROL_ENDPOINTS; i++) 
+      for(i=0; i<USB_MAX_CONTROL_ENDPOINTS; i++)
       {
-         if (bit_pos & (1 << i)) 
+         if (bit_pos & (1 << i))
          {
             ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_setup_count++));
             _usb_device_call_service(handle, i, TRUE, 0, 0, 8, 0);
          } /* Endif */
       } /* Endfor */
    } /* Endif */
-   
-   /* Don't clear the endpoint setup status register here. It is cleared as a 
-   ** setup packet is read out of the buffer 
+
+   /* Don't clear the endpoint setup status register here. It is cleared as a
+   ** setup packet is read out of the buffer
    */
 
-   /* Process non-setup transaction complete interrupts */   
+   /* Process non-setup transaction complete interrupts */
    bit_pos = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE);
 
    /* Clear the bits in the register */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE = USB_32BIT_LE(bit_pos);
-   
-   if (bit_pos) 
+
+   if (bit_pos)
    {
         ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_count++));
 
         /* Get the endpoint number and the direction of transfer */
         counter = 0;
-        for (i=0; i<(ARC_USB_MAX_ENDPOINTS*2); i++) 
+        for (i=0; i<(ARC_USB_MAX_ENDPOINTS*2); i++)
         {
             endpoint_detected = FALSE;
             if ((i < ARC_USB_MAX_ENDPOINTS) && (bit_pos & (1 << i)))
@@ -741,28 +741,28 @@ void _usb_dci_vusb20_process_tr_complete
             }
             else
             {
-                if( (i >= ARC_USB_MAX_ENDPOINTS) && 
+                if( (i >= ARC_USB_MAX_ENDPOINTS) &&
                     (bit_pos & (1 << (i+16-ARC_USB_MAX_ENDPOINTS))))
                 {
                     ep_num = (i - ARC_USB_MAX_ENDPOINTS);
                     direction = ARC_USB_SEND;
                     endpoint_detected = TRUE;
-                }            
+                }
             }
 
             if(endpoint_detected)
             {
                 temp = (2*ep_num + direction);
 
-                /* Get the first dTD */      
+                /* Get the first dTD */
                 dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[temp];
-            
+
                 ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
 
                 /* Process all the dTDs for respective transfers */
-                while (dTD_ptr) 
-                {            
-                    if (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE) 
+                while (dTD_ptr)
+                {
+                    if (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE)
                     {
                         /* No more dTDs to process. Next one is owned by VUSB */
                         if(counter == 0)
@@ -774,83 +774,83 @@ void _usb_dci_vusb20_process_tr_complete
                         }
                         break;
                     } /* Endif */
-               
+
                     /* Get the correct internal transfer descriptor */
                     xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
-                    if (xd_ptr) 
+                    if (xd_ptr)
                     {
                         buff_start_address = xd_ptr->WSTARTADDRESS;
                         actual_transfer_length = xd_ptr->WTOTALLENGTH;
                         temp_xd_ptr = xd_ptr;
                     } /* Endif */
-               
+
                     /* Get the address of the next dTD */
-                    temp_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, 
+                    temp_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr,
                                 (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) );
-                  
+
                     /* Read the errors */
-                    errors = (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_ERROR_MASK);                  
-                    if (!errors) 
+                    errors = (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_ERROR_MASK);
+                    if (!errors)
                     {
                         /* No errors */
-                        /* Get the length of transfer from the current dTD */   
+                        /* Get the length of transfer from the current dTD */
                         remaining_length += ((USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
                         actual_transfer_length -= remaining_length;
-                    } 
-                    else 
+                    }
+                    else
                     {
-                        if (errors & VUSBHS_TD_STATUS_HALTED) 
+                        if (errors & VUSBHS_TD_STATUS_HALTED)
                         {
                             /* Clear the errors and Halt condition */
                             ep_queue_head_ptr->SIZE_IOC_INT_STS &= USB_32BIT_LE(~errors);
                         } /* Endif */
 
-                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ERROR, 
-                            "complete_tr ERROR: ep=%d %s: STS=0x%x, dTD=%p, dTD_next=%p, xd=%p, qh->sts=0x%x\n", 
-                                    (unsigned)ep_num, direction ? "SEND" : "RECV", 
-                                    (unsigned)dTD_ptr->SIZE_IOC_STS, dTD_ptr, temp_dTD_ptr, 
+                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ERROR,
+                            "complete_tr ERROR: ep=%d %s: STS=0x%x, dTD=%p, dTD_next=%p, xd=%p, qh->sts=0x%x\n",
+                                    (unsigned)ep_num, direction ? "SEND" : "RECV",
+                                    (unsigned)dTD_ptr->SIZE_IOC_STS, dTD_ptr, temp_dTD_ptr,
                                     xd_ptr, ep_queue_head_ptr->SIZE_IOC_INT_STS);
                     } /* Endif */
-               
+
                     /* Retire the processed dTD */
                     counter++;
                     _usb_dci_vusb20_cancel_transfer(handle, ep_num, direction);
-                    if( (temp_dTD_ptr == NULL) || 
-                        (temp_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD != temp_xd_ptr) ) 
+                    if( (temp_dTD_ptr == NULL) ||
+                        (temp_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD != temp_xd_ptr) )
                     {
                         /* Transfer complete. Call the register service function for the endpoint */
                         ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_ep_count[temp]++));
 
 #if defined(USB_UNDERRUN_WA)
-                        if( (direction == ARC_USB_SEND) && 
+                        if( (direction == ARC_USB_SEND) &&
                             (((ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF) > global_wa_threshold) )
-                            usbSendComplete(handle, ep_num, FALSE, direction, 
+                            usbSendComplete(handle, ep_num, FALSE, direction,
                                    buff_start_address, actual_transfer_length, errors);
                         else
 #endif /* USB_UNDERRUN_WA */
-                            _usb_device_call_service(handle, ep_num, FALSE, direction, 
+                            _usb_device_call_service(handle, ep_num, FALSE, direction,
                                    buff_start_address, actual_transfer_length, errors);
                         remaining_length = 0;
 
                         ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
-                            "comp_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p %p, COMP=0x%x\n", 
-                            usb_dev_ptr->STATS.usb_complete_count & 0xFFFF, 
-                            USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 
-                            (unsigned)ep_num, direction ? "in" : "out", 
+                            "comp_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p %p, COMP=0x%x\n",
+                            usb_dev_ptr->STATS.usb_complete_count & 0xFFFF,
+                            USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+                            (unsigned)ep_num, direction ? "in" : "out",
                             buff_start_address, actual_transfer_length,
                             temp_xd_ptr, dTD_ptr, temp_dTD_ptr, usb_dev_ptr->EP_DTD_HEADS[temp], (unsigned)bit_pos);
 
                     } /* Endif */
                     else
                     {
-                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER, "tr_complete not completed: ep=%d %s\n", 
+                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER, "tr_complete not completed: ep=%d %s\n",
                                 (unsigned)ep_num, direction ? "SEND" : "RECV");
                     }
                     if( (temp_dTD_ptr == NULL) && (usb_dev_ptr->EP_DTD_HEADS[temp] != NULL) )
                     {
 /*
                         USB_printf("tr_complete: ep=%d, temp_dTD=%p, dTD_ptr=%p (%p), DTD_HEADS=%p, remain=%d\n",
-                                    temp, temp_dTD_ptr, dTD_ptr, 
+                                    temp, temp_dTD_ptr, dTD_ptr,
                                     USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) ),
                                     usb_dev_ptr->EP_DTD_HEADS[temp], remaining_length);
 */
@@ -864,8 +864,8 @@ void _usb_dci_vusb20_process_tr_complete
                 } /* Endwhile */
             } /* Endif */
         } /* Endfor */
-        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, 
-               ( {if(usb_dev_ptr->STATS.usb_complete_max_count < counter) 
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS,
+               ( {if(usb_dev_ptr->STATS.usb_complete_max_count < counter)
                             usb_dev_ptr->STATS.usb_complete_max_count = counter;}));
    } /* Endif */
 } /* EndBody */
@@ -894,26 +894,26 @@ void _usb_dci_vusb20_isr
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
    status = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS);
-   
+
    status &= USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR);
 
-   if(status == 0) 
+   if(status == 0)
    {
        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_empty_isr_count++));
        return;
    } /* Endif */
 /*
-    USB_printf("USB_ISR: FRINDEX=0x%x, status=0x%x, PORTSC=0x%x, EP_SETUP=0x%x, EP_COMPLETE=0x%x\n", 
+    USB_printf("USB_ISR: FRINDEX=0x%x, status=0x%x, PORTSC=0x%x, EP_SETUP=0x%x, EP_COMPLETE=0x%x\n",
                     USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
-                    status, 
+                    status,
                     USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
                     USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
                     USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE) );
 */
    /* Clear all the interrupts occured */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS = USB_32BIT_LE(status);
-   
-   if (status & EHCI_STS_ERR) 
+
+   if (status & EHCI_STS_ERR)
    {
         usb_dev_ptr->ERROR_STATE = (status & 0xFFFF);
 
@@ -925,27 +925,27 @@ void _usb_dci_vusb20_isr
         /*USB_printf("USB process error: status=0x%x\n", status);*/
    } /* Endif */
 
-   if (status & EHCI_STS_RESET) 
+   if (status & EHCI_STS_RESET)
    {
        _usb_dci_vusb20_process_reset((pointer)usb_dev_ptr);
    } /* Endif */
-   
-   if (status & EHCI_STS_PORT_CHANGE) 
+
+   if (status & EHCI_STS_PORT_CHANGE)
    {
       _usb_dci_vusb20_process_port_change((pointer)usb_dev_ptr);
    } /* Endif */
-      
-   if (status & EHCI_STS_SOF) 
+
+   if (status & EHCI_STS_SOF)
    {
       _usb_dci_vusb20_process_SOF((pointer)usb_dev_ptr);
    } /* Endif */
-   
-   if (status & EHCI_STS_INT) 
+
+   if (status & EHCI_STS_INT)
    {
       _usb_dci_vusb20_process_tr_complete((pointer)usb_dev_ptr);
    } /* Endif */
-   
-    if (status & EHCI_STS_SUSPEND) 
+
+    if (status & EHCI_STS_SUSPEND)
     {
         _usb_dci_vusb20_process_suspend((pointer)usb_dev_ptr);
     } /* Endif */
@@ -975,7 +975,7 @@ void _usb_dci_vusb20_process_reset
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_reset\n");
    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_reset_count++));
-   
+
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
    /* Inform the application so that it can cancel all previously queued transfers */
@@ -984,42 +984,42 @@ void _usb_dci_vusb20_process_reset
 #if defined(USB_UNDERRUN_WA)
     _usb_reset_send_queue();
 #endif /* USB_UNDERRUN_WA */
-   
+
    /* The address bits are past bit 25-31. Set the address */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR &= ~USB_32BIT_LE(0xFE000000);
-   
+
    /* Clear all the setup token semaphores */
    temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT);
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(temp);
 
-   /* Clear all the endpoint complete status bits */   
+   /* Clear all the endpoint complete status bits */
    temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE);
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE = USB_32BIT_LE(temp);
-   
+
     timeout = 0x10000;
-    while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & 0xFFFFFFFF) 
+    while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & 0xFFFFFFFF)
     {
         timeout--;
         if(timeout <= 0)
         {
-            USB_printf("%s: Timeout for ENDPTPRIME = 0x%x\n", __FUNCTION__, 
+            USB_printf("%s: Timeout for ENDPTPRIME = 0x%x\n", __FUNCTION__,
                 (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME));
             break;
         }
 
       /* Wait until all ENDPTPRIME bits cleared */
     } /* Endif */
-   
+
    /* Write 1s to the Flush register */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH = USB_32BIT_LE(0xFFFFFFFF);
-   
+
     if( (usb_dev_ptr->ERROR_STATE == 0x0) &&
-        (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & 
+        (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) &
                                                 EHCI_PORTSCX_PORT_RESET) )
     {
         ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RESET,
-                    "USB Bus Reset: fri=0x%x, dev_ptr=%p, STATE=%d, PORTSC=0x%x, CMD=0x%x, ENDPT[0]=0x%x\n", 
-                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 
+                    "USB Bus Reset: fri=0x%x, dev_ptr=%p, STATE=%d, PORTSC=0x%x, CMD=0x%x, ENDPT[0]=0x%x\n",
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
                     usb_dev_ptr, usb_dev_ptr->USB_STATE,
                     USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
                     USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD),
@@ -1027,17 +1027,17 @@ void _usb_dci_vusb20_process_reset
 
         usb_dev_ptr->BUS_RESETTING = TRUE;
         usb_dev_ptr->USB_STATE = ARC_USB_STATE_POWERED;
-    } 
-    else 
-    { 
-        USB_printf("USB Chip reinit: PORTSC=0x%x\n", 
+    }
+    else
+    {
+        USB_printf("USB Chip reinit: PORTSC=0x%x\n",
                 USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]));
 
-        /* re-initialize */      
+        /* re-initialize */
         _usb_dci_vusb20_chip_initialize((pointer)usb_dev_ptr);
         ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "process_reset, Chip reinit hw\n");
     } /* Endif */
-   
+
     _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_BUS_RESET, 1, 0, 0, 0, 0);
 
 } /* EndBody */
@@ -1058,21 +1058,21 @@ void _usb_dci_vusb20_process_suspend
 { /* Body */
     USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
     VUSB20_REG_STRUCT_PTR        dev_ptr;
-   
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
 
     dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_suspend\n");
     ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_suspend_count++));
-   
+
     usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND = usb_dev_ptr->USB_STATE;
-   
+
     usb_dev_ptr->USB_STATE = ARC_USB_STATE_SUSPEND;
 
     /* Inform the upper layers */
     _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SLEEP, 0, 0, 0, 0, 0);
-   
+
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -1093,12 +1093,12 @@ void _usb_dci_vusb20_process_SOF
    VUSB20_REG_STRUCT_PTR                        dev_ptr;
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_SOF\n");
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
-   /* Inform the upper layer */   
-   _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SOF, 0, 0, 0, 
+   /* Inform the upper layer */
+   _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SOF, 0, 0, 0,
       USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 0);
 
 } /* EndBody */
@@ -1128,41 +1128,41 @@ void _usb_dci_vusb20_process_port_change
 
     dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 /*
-    USB_printf("port_change: PORTSC=0x%x, DTD_ENTRIES=%d, XD_ENTRIES=%d\n", 
+    USB_printf("port_change: PORTSC=0x%x, DTD_ENTRIES=%d, XD_ENTRIES=%d\n",
                 USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
                 usb_dev_ptr->DTD_ENTRIES, usb_dev_ptr->XD_ENTRIES);
 */
-    if (usb_dev_ptr->BUS_RESETTING) 
+    if (usb_dev_ptr->BUS_RESETTING)
     {
         /* Bus reset operation complete */
         usb_dev_ptr->BUS_RESETTING = FALSE;
     } /* Endif */
-   
-    if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & 
-                                                EHCI_PORTSCX_PORT_RESET)) 
+
+    if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) &
+                                                EHCI_PORTSCX_PORT_RESET))
     {
         /* Get the speed */
-        if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & 
-                                            EHCI_PORTSCX_PORT_HIGH_SPEED) 
+        if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) &
+                                            EHCI_PORTSCX_PORT_HIGH_SPEED)
         {
             usb_dev_ptr->SPEED = ARC_USB_SPEED_HIGH;
-        } 
-        else 
+        }
+        else
         {
             usb_dev_ptr->SPEED = ARC_USB_SPEED_FULL;
         } /* Endif */
 /*
-        USB_printf("USB %s speed device detected\n", 
+        USB_printf("USB %s speed device detected\n",
                 (usb_dev_ptr->SPEED == ARC_USB_SPEED_HIGH) ? "High" : "Full");
 */
-        /* Inform the upper layers of the speed of operation */      
-        _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SPEED_DETECTION, 0, 0, 
+        /* Inform the upper layers of the speed of operation */
+        _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SPEED_DETECTION, 0, 0,
                                 0, usb_dev_ptr->SPEED, 0);
     } /* Endif */
-      
-    if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & 
-                                                EHCI_PORTSCX_PORT_SUSPEND) 
-    {   
+
+    if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) &
+                                                EHCI_PORTSCX_PORT_SUSPEND)
+    {
         usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND = usb_dev_ptr->USB_STATE;
         usb_dev_ptr->USB_STATE = ARC_USB_STATE_SUSPEND;
 
@@ -1170,9 +1170,9 @@ void _usb_dci_vusb20_process_port_change
         USB_printf("USB suspend\n");
         _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SUSPEND, 0, 0, 0, 0, 0);
     } /* Endif */
-   
-    if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & EHCI_PORTSCX_PORT_SUSPEND) 
-                    && (usb_dev_ptr->USB_STATE == ARC_USB_STATE_SUSPEND)) 
+
+    if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & EHCI_PORTSCX_PORT_SUSPEND)
+                    && (usb_dev_ptr->USB_STATE == ARC_USB_STATE_SUSPEND))
     {
         USB_printf("USB resume\n");
         usb_dev_ptr->USB_STATE = usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND;
@@ -1182,9 +1182,9 @@ void _usb_dci_vusb20_process_port_change
         ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SUSPEND, "process_port_change, SUCCESSFUL, resumed\n");
         return;
     } /* Endif */
-   
+
     usb_dev_ptr->USB_STATE = ARC_USB_STATE_DEFAULT;
-      
+
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -1202,15 +1202,15 @@ void _usb_dci_vusb20_process_error
    )
 { /* Body */
    USB_DEV_STATE_STRUCT_PTR          usb_dev_ptr;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
-   
+
    /* Increment the error count */
    usb_dev_ptr->ERRORS++;
-   
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ERROR, 
-                "process_error_%d: state=0x%x\n", 
-                    usb_dev_ptr->ERRORS, usb_dev_ptr->ERROR_STATE); 
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ERROR,
+                "process_error_%d: state=0x%x\n",
+                    usb_dev_ptr->ERRORS, usb_dev_ptr->ERROR_STATE);
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -1225,7 +1225,7 @@ void _usb_dci_vusb20_set_speed_full
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-     
+
       /* The port number on the device */
       uint_8                     port_number
    )
@@ -1233,16 +1233,16 @@ void _usb_dci_vusb20_set_speed_full
    USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
    VUSB20_REG_STRUCT_PTR                        dev_ptr;
    uint_32                                      port_control;
-   
+
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ANY, "FORCE set_speed_full\n");
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
-   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number]);   
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number]);
    port_control |= EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT;
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number] = USB_32BIT_LE(port_control);
-  
+
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -1257,7 +1257,7 @@ void _usb_dci_vusb20_suspend_phy
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-     
+
       /* The port number on the device */
       uint_8                     port_number
    )
@@ -1265,16 +1265,16 @@ void _usb_dci_vusb20_suspend_phy
    USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
    VUSB20_REG_STRUCT_PTR                        dev_ptr;
    uint_32                                      port_control;
-      
+
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SUSPEND, "set_suspend_phy\n");
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
-   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number]);   
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number]);
    port_control |= EHCI_PORTSCX_PHY_CLOCK_DISABLE;
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number] = USB_32BIT_LE(port_control);
-   
+
 } /* EndBody */
 
 
@@ -1290,7 +1290,7 @@ void _usb_dci_vusb20_set_address
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-     
+
       /* Address of the device assigned by the host */
       uint_8                     address
    )
@@ -1299,18 +1299,18 @@ void _usb_dci_vusb20_set_address
    VUSB20_REG_STRUCT_PTR             dev_ptr;
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ADDR, "set_address: address=%d\n",address);
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-   
-#ifdef SET_ADDRESS_HARDWARE_ASSISTANCE   
+
+#ifdef SET_ADDRESS_HARDWARE_ASSISTANCE
    /***********************************************************
    Hardware Rev 4.0 onwards have special assistance built in
    for handling the set_address command. As per the USB specs
    a device should be able to receive the response on a new
    address, within 2 msecs after status phase of set_address is
    completed. Since 2 mili second may be a very small time window
-   (on high interrupt latency systems) before software could 
+   (on high interrupt latency systems) before software could
    come to the code below and write the device register,
    this routine will be called in advance when status phase of
    set_address is still not finished. The following line in the
@@ -1319,22 +1319,22 @@ void _usb_dci_vusb20_set_address
    it will use it to decode the next USB token. Please look
    at hardware rev details for the implementation of this
    assistance.
-   
+
    Also note that writing bit 24 to 0x01 will not break
    any old hardware revs because it was an unused bit.
    ***********************************************************/
-   /* The address bits are past bit 25-31. Set the address 
+   /* The address bits are past bit 25-31. Set the address
    also set the bit 24 to 0x01 to start hardware assitance*/
-   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR = 
-      USB_32BIT_LE((uint_32)address << VUSBHS_ADDRESS_BIT_SHIFT) | 
-      (0x01 << (VUSBHS_ADDRESS_BIT_SHIFT -1)); 
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR =
+      USB_32BIT_LE((uint_32)address << VUSBHS_ADDRESS_BIT_SHIFT) |
+      (0x01 << (VUSBHS_ADDRESS_BIT_SHIFT -1));
 #else
-   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR = 
-      USB_32BIT_LE((uint_32)address << VUSBHS_ADDRESS_BIT_SHIFT); 
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR =
+      USB_32BIT_LE((uint_32)address << VUSBHS_ADDRESS_BIT_SHIFT);
 #endif /* SET_ADDRESS_HARDWARE_ASSISTANCE */
-   
+
    usb_dev_ptr->USB_STATE = ARC_USB_STATE_ADDRESS;
-      
+
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -1349,10 +1349,10 @@ void _usb_dci_vusb20_get_setup_data
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [OUT] address of the buffer to read the setup data into */
       uint_8_ptr                  buffer_ptr
    )
@@ -1360,24 +1360,24 @@ void _usb_dci_vusb20_get_setup_data
     USB_DEV_STATE_STRUCT_PTR                    usb_dev_ptr;
     volatile VUSB20_REG_STRUCT_PTR              dev_ptr;
     volatile VUSB20_EP_QUEUE_HEAD_STRUCT_PTR    ep_queue_head_ptr;
-    volatile boolean                            read_safe = FALSE;                      
+    volatile boolean                            read_safe = FALSE;
     volatile unsigned long                      timeout;
 
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
    /* Get the endpoint queue head */
-   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + 
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
                                                                 2*ep_num + ARC_USB_RECV;
 
    /********************************************************************
-   CR 1219. Hardware versions 2.3+ have a implementation of tripwire 
-   semaphore mechanism that requires that we read the contents of 
+   CR 1219. Hardware versions 2.3+ have a implementation of tripwire
+   semaphore mechanism that requires that we read the contents of
    QH safely by using the semaphore. Read the USBHS document to under
    stand how the code uses the semaphore mechanism. The following are
    the steps in brief
-   
+
    1. USBCMD Write 1 to Setup Tripwire in register.
    2. Duplicate contents of dQH.StatusBuffer into local software byte
       array.
@@ -1386,8 +1386,8 @@ void _usb_dci_vusb20_get_setup_data
    4. Write '0' to clear Setup Tripwire in register.
    5. Process setup packet using local software byte array copy and
       execute status/handshake phases.
-   
-           
+
+
    ********************************************************************/
     timeout = 0x100000;
     while(!read_safe)
@@ -1396,7 +1396,7 @@ void _usb_dci_vusb20_get_setup_data
         start with setting the semaphores
         *********************************************************/
 
-        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD |= 
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD |=
                                                 USB_32BIT_LE(EHCI_CMD_SETUP_TRIPWIRE_SET);
 
         /* Copy the setup packet to private buffer */
@@ -1414,22 +1414,22 @@ void _usb_dci_vusb20_get_setup_data
         }
         if(timeout <= 0)
         {
-            USB_printf("%s: Timeout for SETUP_TRIPWIRE = 0x%x\n", __FUNCTION__, 
+            USB_printf("%s: Timeout for SETUP_TRIPWIRE = 0x%x\n", __FUNCTION__,
                         (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
             break;
         }
     }
     ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_read_setup_count++));
-  
+
    /*********************************************************
    Clear the semaphore bit now
    *********************************************************/
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &=
-                                    USB_32BIT_LE(EHCI_CMD_SETUP_TRIPWIRE_CLEAR);                         
-   
+                                    USB_32BIT_LE(EHCI_CMD_SETUP_TRIPWIRE_CLEAR);
+
    /* Clear the bit in the ENDPTSETUPSTAT */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(1 << ep_num);
-   
+
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -1444,7 +1444,7 @@ uint_8 _usb_dci_vusb20_init_endpoint
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the transaction descriptor address */
       XD_STRUCT_PTR              xd_ptr
    )
@@ -1453,97 +1453,97 @@ uint_8 _usb_dci_vusb20_init_endpoint
    VUSB20_REG_STRUCT_PTR                        dev_ptr;
    VUSB20_EP_QUEUE_HEAD_STRUCT _PTR_            ep_queue_head_ptr;
    uint_32                                      val, bit_pos;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
    /* Get the endpoint queue head address */
-   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + 
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
                                                     2*xd_ptr->EP_NUM + xd_ptr->BDIRECTION;
-      
+
    bit_pos = (1 << (16 * xd_ptr->BDIRECTION + xd_ptr->EP_NUM));
 
    /* Check if the Endpoint is Primed */
-   if ((!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)) && 
-       (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos))) 
-   { 
+   if ((!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)) &&
+       (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)))
+   {
       /* Set the max packet length, interrupt on Setup and Mult fields */
-      if (xd_ptr->EP_TYPE == ARC_USB_ISOCHRONOUS_ENDPOINT) 
+      if (xd_ptr->EP_TYPE == ARC_USB_ISOCHRONOUS_ENDPOINT)
       {
          /* Mult bit should be set for isochronous endpoints */
-         ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) | 
-            ((xd_ptr->MAX_PKTS_PER_UFRAME ?  xd_ptr->MAX_PKTS_PER_UFRAME : 1) << 
+         ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) |
+            ((xd_ptr->MAX_PKTS_PER_UFRAME ?  xd_ptr->MAX_PKTS_PER_UFRAME : 1) <<
             VUSB_EP_QUEUE_HEAD_MULT_POS));
-      } 
-      else 
+      }
+      else
       {
-         if (xd_ptr->EP_TYPE != ARC_USB_CONTROL_ENDPOINT) 
+         if (xd_ptr->EP_TYPE != ARC_USB_CONTROL_ENDPOINT)
          {
              /* BULK or INTERRUPT */
-            ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) | 
+            ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) |
                (xd_ptr->DONT_ZERO_TERMINATE ? VUSB_EP_QUEUE_HEAD_ZERO_LEN_TER_SEL : 0));
-         } 
-         else 
+         }
+         else
          {
              /* CONTROL */
-            ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) | 
+            ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) |
                                                     VUSB_EP_QUEUE_HEAD_IOS);
          } /* Endif */
       } /* Endif */
-      
+
       /* Enable the endpoint for Rx or Tx and set the endpoint type */
       val = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM];
       if(xd_ptr->BDIRECTION  == ARC_USB_SEND)
       {
           val &= ~(USB_32BIT_LE(EHCI_EPCTRL_TX_ALL_MASK));
-          val |= USB_32BIT_LE((EHCI_EPCTRL_TX_ENABLE | EHCI_EPCTRL_TX_DATA_TOGGLE_RST) | 
+          val |= USB_32BIT_LE((EHCI_EPCTRL_TX_ENABLE | EHCI_EPCTRL_TX_DATA_TOGGLE_RST) |
                           (xd_ptr->EP_TYPE << EHCI_EPCTRL_TX_EP_TYPE_SHIFT));
       }
       else
       {
           val &= ~(USB_32BIT_LE(EHCI_EPCTRL_RX_ALL_MASK));
-          val |= USB_32BIT_LE((EHCI_EPCTRL_RX_ENABLE | EHCI_EPCTRL_RX_DATA_TOGGLE_RST) | 
+          val |= USB_32BIT_LE((EHCI_EPCTRL_RX_ENABLE | EHCI_EPCTRL_RX_DATA_TOGGLE_RST) |
                           (xd_ptr->EP_TYPE << EHCI_EPCTRL_RX_EP_TYPE_SHIFT));
       }
       dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] = val;
-      
+
       /* Implement Guideline (GL# USB-7) The unused endpoint type must  */
       /* be programmed to bulk.                                         */
-      if( (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] & 
+      if( (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] &
             USB_32BIT_LE(EHCI_EPCTRL_RX_ENABLE)) == 0)
       {
-          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] |= 
+          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] |=
               USB_32BIT_LE(ARC_USB_BULK_ENDPOINT << EHCI_EPCTRL_RX_EP_TYPE_SHIFT);
       }
 
-      if( (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] & 
+      if( (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] &
             USB_32BIT_LE(EHCI_EPCTRL_TX_ENABLE)) == 0)
       {
-          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] |= 
+          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] |=
               USB_32BIT_LE(ARC_USB_BULK_ENDPOINT << EHCI_EPCTRL_TX_EP_TYPE_SHIFT);
       }
 
       ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT,
-                    "init ep #%d %s: type=0x%x, EPCTRLX=0x%x, SETUP=0x%x, PRIME=0x%x, STATUS=0x%x, COMPL=0x%x\n", 
-                        xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "SEND" : "RECV", xd_ptr->EP_TYPE, 
+                    "init ep #%d %s: type=0x%x, EPCTRLX=0x%x, SETUP=0x%x, PRIME=0x%x, STATUS=0x%x, COMPL=0x%x\n",
+                        xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "SEND" : "RECV", xd_ptr->EP_TYPE,
                         (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM]),
                         (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
                         (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
                         (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
                         (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE) );
-   } 
-   else 
-   { 
+   }
+   else
+   {
       USB_printf("ep=%d %s: Init ERROR: ENDPTPRIME=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
                 (unsigned)xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "SEND" : "RECV",
                 (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
-                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS), 
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
                 (unsigned)bit_pos);
         return USBERR_EP_INIT_FAILED;
    } /* Endif */
-      
+
    return USB_OK;
-   
+
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -1558,10 +1558,10 @@ uint_8 _usb_dci_vusb20_get_transfer_stat
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-     
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -1570,23 +1570,23 @@ uint_8 _usb_dci_vusb20_get_transfer_stat
    VUSB20_EP_TR_STRUCT_PTR                      dTD_ptr;
    XD_STRUCT_PTR                                xd_ptr;
    uint_8                                       status;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
-  
+
    /* Unlink the dTD */
    dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[2*ep_num + direction];
 
-   if (dTD_ptr) 
+   if (dTD_ptr)
    {
       /* Get the transfer descriptor for the dTD */
       xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
       status = xd_ptr->BSTATUS;
-   } 
-   else 
+   }
+   else
    {
       status = ARC_USB_STATUS_IDLE;
    } /* Endif */
-   
+
    return (status);
 
 } /* EndBody */
@@ -1602,10 +1602,10 @@ XD_STRUCT_PTR  _usb_dci_vusb20_get_trans
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-     
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -1617,29 +1617,29 @@ XD_STRUCT_PTR  _usb_dci_vusb20_get_trans
    uint_32                                      temp, remaining_bytes;
    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR              ep_queue_head_ptr;
 
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
    temp = (2*ep_num + direction);
 
-   /* get a pointer to QH for this endpoint */   
+   /* get a pointer to QH for this endpoint */
    ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "get_transfer_details\n");
-   
+
    /* Unlink the dTD */
    dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[2*ep_num + direction];
 
-   if (dTD_ptr) 
-   {      
+   if (dTD_ptr)
+   {
       /* Get the transfer descriptor for the dTD */
       xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
       if(!xd_ptr) return NULL;
-      
+
       /* Initialize the transfer length field */
       xd_ptr->WSOFAR =0;
       remaining_bytes =0;
-      
+
       /*if length of this transfer is greater than 20K
       we have multiple DTDs to count */
       if(xd_ptr->WTOTALLENGTH > VUSB_EP_MAX_LENGTH_TRANSFER)
@@ -1647,34 +1647,34 @@ XD_STRUCT_PTR  _usb_dci_vusb20_get_trans
          /* it is a valid DTD. We should parse all DTDs for this XD
          and find the total bytes used so far */
          temp_dTD_ptr = dTD_ptr;
-      
+
          /*loop through the list of DTDS until an active DTD is found
          or list has finished */
-         while(!(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_NEXT_TERMINATE))         
+         while(!(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_NEXT_TERMINATE))
          {
-            
+
             /**********************************************************
-            If this DTD has been overlayed, we take the actual length 
+            If this DTD has been overlayed, we take the actual length
             from QH.
             **********************************************************/
 
             if ((uint_32)(USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR) & VUSBHS_TD_ADDR_MASK) ==
                                      USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, temp_dTD_ptr) )
             {
-                remaining_bytes += 
+                remaining_bytes +=
                   ((USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
             }
             else
             {
                /* take the length from DTD itself */
-                remaining_bytes += 
+                remaining_bytes +=
                   ((USB_32BIT_LE(temp_dTD_ptr->SIZE_IOC_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
             }
-   
+
             dTD_ptr = temp_dTD_ptr;
-             
+
             /* Get the address of the next dTD */
-            temp_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, 
+            temp_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr,
                                 (uint_32)(USB_32BIT_LE(temp_dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) );
          }
          xd_ptr->WSOFAR = xd_ptr->WTOTALLENGTH - remaining_bytes;
@@ -1682,15 +1682,15 @@ XD_STRUCT_PTR  _usb_dci_vusb20_get_trans
       else
       {
          /*look at actual length from QH*/
-         xd_ptr->WSOFAR = xd_ptr->WTOTALLENGTH - 
-            ((USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);         
-      }      
-   } 
-   else 
+         xd_ptr->WSOFAR = xd_ptr->WTOTALLENGTH -
+            ((USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
+      }
+   }
+   else
    {
       xd_ptr = NULL;
    } /* Endif */
-   
+
    return (xd_ptr);
 
 } /* EndBody */
@@ -1707,10 +1707,10 @@ uint_8 _usb_dci_vusb20_deinit_endpoint
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -1720,45 +1720,45 @@ uint_8 _usb_dci_vusb20_deinit_endpoint
     VUSB20_EP_QUEUE_HEAD_STRUCT*    ep_queue_head_ptr;
     uint_32                         bit_pos;
     uint_8                          status = USB_OK;
-   
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
     dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-   
+
     /* Get the endpoint queue head address */
     ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
                                                                     (2*ep_num + direction);
-      
+
     bit_pos = (1 << (16 * direction + ep_num));
 
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT,
-               "deinit ep #%d-%s: bit_pos=0x%x, EPCTRLX=0x%x, SETUP=0x%x, PRIME=0x%x, STATUS=0x%x, COMPL=0x%x\n", 
+               "deinit ep #%d-%s: bit_pos=0x%x, EPCTRLX=0x%x, SETUP=0x%x, PRIME=0x%x, STATUS=0x%x, COMPL=0x%x\n",
                    ep_num, direction ? "SEND" : "RECV", bit_pos,
                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]),
                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE) );
-      
+
     /* Check if the Endpoint is Primed */
-    if( ((USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)) || 
-        ((USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)) ) 
-    { 
+    if( ((USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)) ||
+        ((USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)) )
+    {
         USB_printf("ep=%d %s: Deinit ERROR: ENDPTPRIME=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
                 (unsigned)ep_num, direction ? "SEND" : "RECV",
                 (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
-                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS), 
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
                 (unsigned)bit_pos);
         status = USBERR_EP_DEINIT_FAILED;
     }
 
     /* Reset the max packet length and the interrupt on Setup */
     ep_queue_head_ptr->MAX_PKT_LENGTH = 0;
-      
+
     /* Disable the endpoint for Rx or Tx and reset the endpoint type */
-    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &= 
-         USB_32BIT_LE( ~((direction ? EHCI_EPCTRL_TX_ENABLE : EHCI_EPCTRL_RX_ENABLE) | 
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &=
+         USB_32BIT_LE( ~((direction ? EHCI_EPCTRL_TX_ENABLE : EHCI_EPCTRL_RX_ENABLE) |
                         (direction ? EHCI_EPCTRL_TX_TYPE : EHCI_EPCTRL_RX_TYPE)));
-      
+
    return status;
 }
 
@@ -1779,21 +1779,21 @@ void _usb_dci_vusb20_shutdown
 { /* Body */
     USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
     VUSB20_REG_STRUCT_PTR                        dev_ptr;
-   
+
     usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
     dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-   
+
     /* Disable interrupts */
-    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR &= 
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR &=
       ~(USB_32BIT_LE(EHCI_INTR_INT_EN | EHCI_INTR_ERR_INT_EN |
       EHCI_INTR_PORT_CHANGE_DETECT_EN | EHCI_INTR_RESET_EN));
-      
-    USB_uncached_memfree(usb_dev_ptr->EP_QUEUE_HEAD_BASE, 
-                        usb_dev_ptr->EP_QUEUE_HEAD_SIZE, 
+
+    USB_uncached_memfree(usb_dev_ptr->EP_QUEUE_HEAD_BASE,
+                        usb_dev_ptr->EP_QUEUE_HEAD_SIZE,
                         usb_dev_ptr->EP_QUEUE_HEAD_PHYS);
 
-    USB_uncached_memfree(usb_dev_ptr->DTD_BASE_PTR, 
-                        usb_dev_ptr->DTD_SIZE, 
+    USB_uncached_memfree(usb_dev_ptr->DTD_BASE_PTR,
+                        usb_dev_ptr->DTD_SIZE,
                         usb_dev_ptr->DTD_BASE_PHYS);
 
     USB_memfree(usb_dev_ptr->SCRATCH_STRUCT_BASE);
@@ -1802,10 +1802,10 @@ void _usb_dci_vusb20_shutdown
 
    /* Reset the Run the bit in the command register to stop VUSB */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= ~USB_32BIT_LE(EHCI_CMD_RUN_STOP);
-   
+
    /* Reset the controller to get default values */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_CTRL_RESET);
-              
+
 } /* EndBody */
 /*FUNCTION*-------------------------------------------------------------
 *
@@ -1819,12 +1819,12 @@ void _usb_dci_vusb20_stop(_usb_device_ha
 {
    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
    VUSB20_REG_STRUCT_PTR        dev_ptr;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
     /* Disable interrupts */
-   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR &= 
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR &=
             ~(USB_32BIT_LE(EHCI_INTR_INT_EN | EHCI_INTR_ERR_INT_EN |
                            EHCI_INTR_PORT_CHANGE_DETECT_EN | EHCI_INTR_RESET_EN));
 
@@ -1845,24 +1845,24 @@ void _usb_dci_vusb20_start(_usb_device_h
 {
    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
    VUSB20_REG_STRUCT_PTR        dev_ptr;
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
       /* Enable interrupts */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR = USB_32BIT_LE(
                            EHCI_INTR_INT_EN
-                         | EHCI_INTR_ERR_INT_EN 
-                         | EHCI_INTR_PORT_CHANGE_DETECT_EN 
-                         | EHCI_INTR_RESET_EN 
+                         | EHCI_INTR_ERR_INT_EN
+                         | EHCI_INTR_PORT_CHANGE_DETECT_EN
+                         | EHCI_INTR_RESET_EN
                          | EHCI_INTR_DEVICE_SUSPEND
-                       /*  
-                         | EHCI_INTR_SOF_UFRAME_EN 
+                       /*
+                         | EHCI_INTR_SOF_UFRAME_EN
                         */
                          );
-   
+
    usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
-   
+
    /* Set the Run bit in the command register */
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_RUN_STOP);
 }
--- a/arch/arm/plat-armada/mv_hal/usb/device/mvUsbHsDevUtl.c
+++ b/arch/arm/plat-armada/mv_hal/usb/device/mvUsbHsDevUtl.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -26,16 +26,16 @@ disclaimer.
 #include "usb/api/mvUsbDefs.h"
 
 /* Test packet for Test Mode : TEST_PACKET. USB 2.0 Specification section 7.1.20 */
-uint_8 test_packet[USB_TEST_MODE_TEST_PACKET_LENGTH] = 
+uint_8 test_packet[USB_TEST_MODE_TEST_PACKET_LENGTH] =
 {
    /* Synch */
    /* DATA 0 PID */
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-   0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
-   0xAA, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 
-   0xEE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
-   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF, 
-   0xEF, 0xF7, 0xFB, 0xFD, 0xFC, 0x7E, 0xBF, 0xDF, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
+   0xAA, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
+   0xEE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF,
+   0xEF, 0xF7, 0xFB, 0xFD, 0xFC, 0x7E, 0xBF, 0xDF,
    0xEF, 0xF7, 0xFB, 0xFD, 0x7E
 };
 
@@ -56,18 +56,18 @@ void _usb_dci_vusb20_assert_resume
    USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
    VUSB20_REG_STRUCT_PTR             dev_ptr;
    uint_32                                      temp;
- 
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
 
-   /* Assert the Resume signal */   
+   /* Assert the Resume signal */
    temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
    temp &= ~EHCI_PORTSCX_W1C_BITS;
    temp |= EHCI_PORTSCX_PORT_FORCE_RESUME;
    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] = USB_32BIT_LE(temp);
-   
-   /* Port change interrupt will be asserted at the end of resume 
-   ** operation 
+
+   /* Port change interrupt will be asserted at the end of resume
+   ** operation
    */
 
 } /* EndBody */
@@ -84,10 +84,10 @@ void _usb_dci_vusb20_stall_endpoint
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -95,41 +95,41 @@ void _usb_dci_vusb20_stall_endpoint
    USB_DEV_STATE_STRUCT_PTR             usb_dev_ptr;
    VUSB20_REG_STRUCT_PTR                dev_ptr;
    VUSB20_EP_QUEUE_HEAD_STRUCT _PTR_    ep_queue_head_ptr;
-      
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-   
+
    /* Get the endpoint queue head address */
-   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + 
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
                                                                     2*ep_num + direction;
    /* Stall the endpoint for Rx or Tx and set the endpoint type */
-   if (ep_queue_head_ptr->MAX_PKT_LENGTH & USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_IOS)) 
+   if (ep_queue_head_ptr->MAX_PKT_LENGTH & USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_IOS))
    {
       /* This is a control endpoint so STALL both directions */
-      dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+      dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
          USB_32BIT_LE((EHCI_EPCTRL_TX_EP_STALL | EHCI_EPCTRL_RX_EP_STALL));
-   } 
-   else 
-   {   
-       if(direction) 
+   }
+   else
+   {
+       if(direction)
        {
-            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
                         USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL);
        }
        else {
-            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
                         USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL);
        }
    } /* Endif */
 
-   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STALL, 
-                    "STALL ep=%d %s: EPCTRLX=0x%x, CURR_dTD=0x%x, NEXT_dTD=0x%x, SIZE=0x%x\n", 
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STALL,
+                    "STALL ep=%d %s: EPCTRLX=0x%x, CURR_dTD=0x%x, NEXT_dTD=0x%x, SIZE=0x%x\n",
                     ep_num, direction ? "SEND" : "RECV",
                     (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]),
-                    (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR), 
+                    (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR),
                     (unsigned)USB_32BIT_LE(ep_queue_head_ptr->NEXT_DTD_PTR),
                     (unsigned)USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS));
-      
+
 } /* EndBody */
 
 /*FUNCTION*-------------------------------------------------------------
@@ -144,10 +144,10 @@ void _usb_dci_vusb20_unstall_endpoint
    (
       /* [IN] the USB_dev_initialize state structure */
       _usb_device_handle         handle,
-            
+
       /* [IN] the Endpoint number */
       uint_8                     ep_num,
-            
+
       /* [IN] direction */
       uint_8                     direction
    )
@@ -157,27 +157,27 @@ void _usb_dci_vusb20_unstall_endpoint
 
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-   
+
    /* Enable the endpoint for Rx or Tx and set the endpoint type */
    if(direction)
    {
-        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
               USB_32BIT_LE(EHCI_EPCTRL_TX_DATA_TOGGLE_RST);
 
-        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &= 
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &=
                 ~(USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL));
    }
    else
    {
-        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
               USB_32BIT_LE(EHCI_EPCTRL_RX_DATA_TOGGLE_RST);
 
-        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &= 
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &=
                 ~(USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL));
-   }     
+   }
 
-   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STALL, 
-                    "UNSTALL ep=%d %s: EPCTRLX=0x%x\n", 
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STALL,
+                    "UNSTALL ep=%d %s: EPCTRLX=0x%x\n",
                     ep_num, direction ? "SEND" : "RECV",
                     (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]));
 
@@ -185,18 +185,18 @@ void _usb_dci_vusb20_unstall_endpoint
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _usb_dci_vusb20_is_endpoint_stalled
 * Returned Value : None
 * Comments       :
 *     Gets the endpoint status
-* 
+*
 *END*--------------------------------------------------------------------*/
 uint_8 _usb_dci_vusb20_is_endpoint_stalled
    (
       /* [IN] Handle to the USB device */
       _usb_device_handle   handle,
-      
+
       /* [IN] Endpoint number */
       uint_8               ep,
 
@@ -209,36 +209,36 @@ uint_8 _usb_dci_vusb20_is_endpoint_stall
    uint_32                      value;
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "is_endpoint_stalled\n");
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-  
+
    if(dir)
    {
-        value = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep] & 
+        value = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep] &
                                     (USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL));
    }
    else
    {
-        value = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep] & 
+        value = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep] &
                                     (USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL));
    }
    return (value) ? 1 : 0;
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _usb_dci_vusb20_set_test_mode
 * Returned Value : None
 * Comments       :
 *     sets/resets the test mode
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _usb_dci_vusb20_set_test_mode
    (
       /* [IN] Handle to the USB device */
       _usb_device_handle handle,
-      
+
       /* [IN] Test mode */
       uint_16 test_mode
    )
@@ -248,27 +248,27 @@ void _usb_dci_vusb20_set_test_mode
    uint_32                                      temp;
 
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ANY, "set_test_mode\n");
-   
+
    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
-   
+
    temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]);
-   
-   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0] = 
+
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0] =
                                 USB_32BIT_LE((temp | EHCI_EPCTRL_TX_DATA_TOGGLE_RST));
 
-   if (test_mode == ARC_USB_TEST_MODE_TEST_PACKET) 
+   if (test_mode == ARC_USB_TEST_MODE_TEST_PACKET)
    {
-       USB_memcopy(test_packet, usb_dev_ptr->TEST_PKT_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH); 
+       USB_memcopy(test_packet, usb_dev_ptr->TEST_PKT_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH);
       _usb_device_send_data(handle, 0, usb_dev_ptr->TEST_PKT_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH);
 
    } /* Endif */
-   
+
    temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
    temp &= ~EHCI_PORTSCX_W1C_BITS;
-   
-   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] = 
+
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] =
                                     USB_32BIT_LE(temp | ((uint_32)test_mode << 8));
-             
+
 } /* EndBody */
 
--- a/arch/arm/plat-armada/mv_hal/usb/examples/disk.c
+++ b/arch/arm/plat-armada/mv_hal/usb/examples/disk.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -42,9 +42,9 @@ Include the USB stack and local header f
 
 /**************************************************************************
 Include the OS and BSP dependent files that define IO functions and
-basic types. You may like to change these files for your board and RTOS 
+basic types. You may like to change these files for your board and RTOS
 **************************************************************************/
-   
+
 
 /**************************************************************************
 Global variables and some defines for device.
@@ -93,7 +93,7 @@ typedef struct
     SETUP_STRUCT        local_setup_packet;
 
     volatile boolean    TEST_ENABLED;
-    volatile boolean    ENTER_TEST_MODE; 
+    volatile boolean    ENTER_TEST_MODE;
     volatile uint_16    test_mode_index;
     volatile uint_8     speed;
     uint_16             logicalBlocks;
@@ -191,7 +191,7 @@ static const uint_8 ConfigDescData[CONFI
    /* "Configuration" type of descriptor */
    2,
    /* Total length of the Configuration descriptor */
-   USB_uint_16_low(CONFIG_DESC_SIZE), 
+   USB_uint_16_low(CONFIG_DESC_SIZE),
    USB_uint_16_high(CONFIG_DESC_SIZE),
    /* NumInterfaces */
    1,
@@ -233,7 +233,7 @@ static const uint_8 ConfigDescData[CONFI
    /* Attributes.  0=Control 1=Isochronous 2=Bulk 3=Interrupt */
    DISK_IN_EP_TYPE,
    /* Max Packet Size for this endpoint */
-   USB_uint_16_low(DISK_FS_MAX_PACKET_SIZE), 
+   USB_uint_16_low(DISK_FS_MAX_PACKET_SIZE),
    USB_uint_16_high(DISK_FS_MAX_PACKET_SIZE),
    /* Polling Interval (ms) */
    0,
@@ -249,7 +249,7 @@ static const uint_8 ConfigDescData[CONFI
    /* Attributes.  0=Control 1=Isochronous 2=Bulk 3=Interrupt */
    DISK_OUT_EP_TYPE,
    /* Max Packet Size for this endpoint */
-   USB_uint_16_low(DISK_FS_MAX_PACKET_SIZE), 
+   USB_uint_16_low(DISK_FS_MAX_PACKET_SIZE),
    USB_uint_16_high(DISK_FS_MAX_PACKET_SIZE),
    /* Polling Interval (ms) */
    0
@@ -260,7 +260,7 @@ static const uint_8  other_speed_config_
 {
    9,                         /* bLength Length of this descriptor */
    7,                         /* bDescType This is a Other speed config descr */
-   USB_uint_16_low(OTHER_SPEED_CONFIG_DESC_SIZE), 
+   USB_uint_16_low(OTHER_SPEED_CONFIG_DESC_SIZE),
    USB_uint_16_high(OTHER_SPEED_CONFIG_DESC_SIZE),
    1,
    1,
@@ -297,7 +297,7 @@ static const uint_8  other_speed_config_
    /* Attributes.  0=Control 1=Isochronous 2=Bulk 3=Interrupt */
    DISK_IN_EP_TYPE,
    /* Max Packet Size for this endpoint */
-   USB_uint_16_low(DISK_HS_MAX_PACKET_SIZE), 
+   USB_uint_16_low(DISK_HS_MAX_PACKET_SIZE),
    USB_uint_16_high(DISK_HS_MAX_PACKET_SIZE),
    /* Polling Interval (ms) */
    0,
@@ -314,7 +314,7 @@ static const uint_8  other_speed_config_
    /* Attributes.  0=Control 1=Isochronous 2=Bulk 3=Interrupt */
    DISK_OUT_EP_TYPE,
    /* Max Packet Size for this endpoint */
-   USB_uint_16_low(DISK_HS_MAX_PACKET_SIZE), 
+   USB_uint_16_low(DISK_HS_MAX_PACKET_SIZE),
    USB_uint_16_high(DISK_HS_MAX_PACKET_SIZE),
    /* Polling Interval (ms) */
    0
@@ -326,13 +326,13 @@ static uint_8 USB_IF_ALT[4] = { 0, 0, 0,
 static const uint_8 USB_STR_NUM = 7;
 
 /*
-** if the number of strings changes, look for USB_STR_0 everywhere and make 
+** if the number of strings changes, look for USB_STR_0 everywhere and make
 ** the obvious changes.  It should be found in 3 places.
 */
 
 static uint_16 USB_STR_0[ 2] = {(0x300 + sizeof(USB_STR_0)),(0x0409)};
 static uint_16 USB_STR_1[26] = {(0x300 + sizeof(USB_STR_1)),
-      'M','a','r','v','e','l','l',' ','S','e','m','i','c','o','n','d','u','c','t','o','r',' ','L','t','d'};       
+      'M','a','r','v','e','l','l',' ','S','e','m','i','c','o','n','d','u','c','t','o','r',' ','L','t','d'};
 static uint_16 USB_STR_2[28] = {(0x300 + sizeof(USB_STR_2)),
       'M','A','R','V','E','L','L',' ','M','a','s','s',' ','S','t','o','r','a','g','e',' ',\
       'D','e','v','i','c','e'};
@@ -344,7 +344,7 @@ static uint_16 USB_STR_5[ 4] = {(0x300 +
       '_','A','1'};
       /* Serial number has to be at least 12 bytes */
 static uint_16 USB_STR_6[ 13] = {(0x300 + sizeof(USB_STR_6)),
-      '0','0','0','0','0','0','0','0','0','0','0','1'};     
+      '0','0','0','0','0','0','0','0','0','0','0','1'};
 static uint_16 USB_STR_7[15] = {(0x300 + sizeof(USB_STR_7)),
       'Y','o','u','r',' ','n','a','m','e',' ','h','e','r','e'};
 static uint_16 USB_STR_n[17] = {(0x300 + sizeof(USB_STR_n)),
@@ -368,129 +368,129 @@ static uint_8_ptr USB_STRING_DESC[USB_ST
 MASS STORAGE SPECIFIC GLOBALS
 *****************************************************************/
 
-static const DISK_DEVICE_INFO device_information_data = 
+static const DISK_DEVICE_INFO device_information_data =
 {
-   0, 0x80, 0, 0x01, 0x1F, 
+   0, 0x80, 0, 0x01, 0x1F,
    /* Reserved */
    {0, 0, 0},
    /* Vendor information: "MARVELL  " */
    {0x4D, 0x41, 0x52, 0x56, 0x45, 0x4C, 0x4C, 0x20,},
    /* Product information: "Disk            " */
    {0x44, 0x69, 0x73, 0x6B, 0x20, 0x20, 0x20, 0x20,
-   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20}, 
+   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
    /* Product Revision level: "Demo" */
    {0x44, 0x65, 0x6D, 0x6F}
-}; 
+};
 
-static const DISK_READ_CAPACITY read_capacity = 
+static const DISK_READ_CAPACITY read_capacity =
 {
    /* Data for the capacity */
    {
-      0x00, 0x00, USB_uint_16_high(TOTAL_LOGICAL_ADDRESS_BLOCKS-14), 
+      0x00, 0x00, USB_uint_16_high(TOTAL_LOGICAL_ADDRESS_BLOCKS-14),
       USB_uint_16_low(TOTAL_LOGICAL_ADDRESS_BLOCKS-14)
-   }, 
+   },
    {
-      0x00, 0x00, USB_uint_16_high(LENGTH_OF_EACH_LAB), 
+      0x00, 0x00, USB_uint_16_high(LENGTH_OF_EACH_LAB),
       USB_uint_16_low(LENGTH_OF_EACH_LAB)
    }
 };
 
-static const uint_8 BOOT_SECTOR_AREA[512] = 
+static const uint_8 BOOT_SECTOR_AREA[512] =
 {
    /* Block 0 is the boot sector. Following is the data in the boot sector */
    /* 80x86 "short: jump instruction, indicating that the disk is formatted */
-    0xEB, 
+    0xEB,
     /* 8-bit displacement */
-    0x3C, 
+    0x3C,
     /* NOP OPCode */
-    0x90, 
+    0x90,
     /* 8-bytes for OEM identification: "ARC 4.3 " */
-    0x41, 0x52, 0x43, 0x20, 0x34, 0x2E, 0x33, 0x20, 
+    0x41, 0x52, 0x43, 0x20, 0x34, 0x2E, 0x33, 0x20,
     /* bytes/sector: 512 bytes (0x0200) */
-    0x00, 0x02, 
+    0x00, 0x02,
     /* Sectors/allocation unit */
     0x01,
     /* Reserved sectors: 0x0001 */
-    0x01, 0x00, 
+    0x01, 0x00,
     /* Number of File Allocation Tables (FATs): 2 */
     0x02,
     /* Number of root directory entries */
-    0x00, 0x02, 
+    0x00, 0x02,
     /* Total Small sectors in logical volume */
-    USB_uint_16_low(TOTAL_LOGICAL_ADDRESS_BLOCKS), 
+    USB_uint_16_low(TOTAL_LOGICAL_ADDRESS_BLOCKS),
     USB_uint_16_high(TOTAL_LOGICAL_ADDRESS_BLOCKS),
     /* Media descriptor byte: 0xF8: Fixed disk */
     0xF8,
     /* Sectors/FAT: 3 (Each FAT starts at a new sector) */
-    0x80, 0x00, 
+    0x80, 0x00,
     /* Sectors/track: 9 */
-    0x09, 0x00, 
+    0x09, 0x00,
     /* Number of heads */
-    0x02, 0x00, 
+    0x02, 0x00,
     /* Number of hidden sectors: 0 */
-    0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00,
     /* Total Large sectors in logical volume */
-    0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00,
     /* Physical drive number */
-    0x00, 
+    0x00,
     /* Reserved */
-    0x00, 
+    0x00,
     /* Extended boot signature record: 0x29 */
     0x29,
     /* 32-bit binary volume ID */
-    0x01, 0x02, 0x03, 0x04, 
+    0x01, 0x02, 0x03, 0x04,
     /* Volume label */
-    0x53, 0x54, 0x55, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x53, 0x54, 0x55, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
     /* Reserved FAT-16*/
     0x46, 0x41, 0x54, 0x31, 0x36, 0x00, 0x00, 0x00,
     /* Bootstrap */
-    0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0xFC, 0xE8, 0x45, 0x00, 
+    0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0xFC, 0xE8, 0x45, 0x00,
     /* String: \r\nNon-System disk\r\nPress any key to reboot\r\n" */
     0x0D, 0x0A, 0x4E, 0x6F, 0x6E, 0x2D, 0x53, 0x79, 0x73, 0x74, 0x65,
-    0x6D, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x0D, 0x0A, 0x50, 0x72, 0x65, 
-    0x73, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20, 
-    0x74, 0x6F, 0x20, 0x72, 0x65, 0x62, 0x6F, 0x6F, 0x74, 0x0D, 0x0A, 
-    0x5E, 0xEB, 0x02, 0xCD, 0x10, 0xB4, 0x0E, 0xBB, 0x07, 0x00, 0x2E, 
-    0xAC, 0x84, 0xC0, 0x75, 0xF3, 0x98, 0xCD, 0x16, 0xCD, 0x19, 0xEB, 
-    0xB1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x6D, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x0D, 0x0A, 0x50, 0x72, 0x65,
+    0x73, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20,
+    0x74, 0x6F, 0x20, 0x72, 0x65, 0x62, 0x6F, 0x6F, 0x74, 0x0D, 0x0A,
+    0x5E, 0xEB, 0x02, 0xCD, 0x10, 0xB4, 0x0E, 0xBB, 0x07, 0x00, 0x2E,
+    0xAC, 0x84, 0xC0, 0x75, 0xF3, 0x98, 0xCD, 0x16, 0xCD, 0x19, 0xEB,
+    0xB1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     /* Partition descriptors */
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
 };
 
 
-static const uint_8 FAT16_SPECIAL_BYTES[3] = 
+static const uint_8 FAT16_SPECIAL_BYTES[3] =
 {
    /* FAT ID: Same as Media descriptor */
    0xF8, 0xFF, 0xFF
@@ -498,7 +498,7 @@ static const uint_8 FAT16_SPECIAL_BYTES[
 
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9GetDescription
 * Returned Value : None
 * Comments       :
@@ -507,16 +507,16 @@ static const uint_8 FAT16_SPECIAL_BYTES[
 *     descriptors (via wValue). We then post an IN response to return the
 *     requested descriptor.
 *     And then wait for the OUT which terminates the control transfer.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9GetDescription
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
@@ -525,13 +525,13 @@ static void ch9GetDescription
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
     uint_32             max_pkt_size;
 
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d, value=0x%x, length=%d\n", 
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d, value=0x%x, length=%d\n",
                 __FUNCTION__, (int)setup, setup_ptr->VALUE, setup_ptr->LENGTH);
 
-    if (setup) 
+    if (setup)
     {
         /* Load the appropriate string depending on the descriptor requested.*/
-        switch (setup_ptr->VALUE & 0xFF00) 
+        switch (setup_ptr->VALUE & 0xFF00)
         {
             case 0x0100:
                 _usb_device_send_data(handle, 0, pDiskCtrl->DevDesc,
@@ -540,27 +540,27 @@ static void ch9GetDescription
 
             case 0x0200:
                 /* Set the Max Packet Size in the config and other speed config */
-                if(pDiskCtrl->speed == ARC_USB_SPEED_HIGH) 
+                if(pDiskCtrl->speed == ARC_USB_SPEED_HIGH)
                 {
                     max_pkt_size = pDiskCtrl->hsMaxPktSize;
-                } 
-                else 
+                }
+                else
                 {
                     max_pkt_size = pDiskCtrl->fsMaxPktSize;
                 } /* Endif */
-        
+
                 *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_IN_TYPE_OFFSET) = (uint_8)pDiskCtrl->inEpType;
 
-                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET) = 
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET) =
                                                 USB_uint_16_low(max_pkt_size);
-                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET+1) = 
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET+1) =
                                                 USB_uint_16_high(max_pkt_size);
 
                 *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_OUT_TYPE_OFFSET) = (uint_8)pDiskCtrl->outEpType;
 
-                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET) = 
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET) =
                                                 USB_uint_16_low(max_pkt_size);
-                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET+1) = 
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET+1) =
                                                 USB_uint_16_high(max_pkt_size);
 
                 _usb_device_send_data(handle, 0, pDiskCtrl->ConfigDesc,
@@ -571,50 +571,50 @@ static void ch9GetDescription
                 if ((setup_ptr->VALUE & 0x00FF) > USB_STR_NUM) {
                     _usb_device_send_data(handle, 0, USB_STRING_DESC[USB_STR_NUM+1],
                             MIN(setup_ptr->LENGTH, USB_STRING_DESC[USB_STR_NUM+1][0]));
-                } 
-                else 
+                }
+                else
                 {
                     _usb_device_send_data(handle, 0, USB_STRING_DESC[setup_ptr->VALUE & 0x00FF],
                             MIN(setup_ptr->LENGTH, USB_STRING_DESC[setup_ptr->VALUE & 0x00FF][0]));
-                } /* Endif */      
+                } /* Endif */
                 break;
-            
+
             case 0x600:
-                _usb_device_send_data(handle, 0, (uint_8_ptr)pDiskCtrl->DevQualifierDesc, 
+                _usb_device_send_data(handle, 0, (uint_8_ptr)pDiskCtrl->DevQualifierDesc,
                         MIN(setup_ptr->LENGTH, DEVICE_QUALIFIER_DESCRIPTOR_SIZE));
                 break;
-            
+
             case 0x700:
-                if(pDiskCtrl->speed == ARC_USB_SPEED_HIGH) 
+                if(pDiskCtrl->speed == ARC_USB_SPEED_HIGH)
                 {
                     max_pkt_size = pDiskCtrl->fsMaxPktSize;
-                } 
-                else 
+                }
+                else
                 {
                     max_pkt_size = pDiskCtrl->hsMaxPktSize;
                 } /* Endif */
-            
+
                 *(pDiskCtrl->other_speed_config + CFG_DESC_EP_IN_TYPE_OFFSET) = (uint_8)pDiskCtrl->inEpType;
 
-                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET) = 
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET) =
                     USB_uint_16_low(max_pkt_size);
-                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET+1) = 
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET+1) =
                     USB_uint_16_high(max_pkt_size);
 
                 *(pDiskCtrl->other_speed_config + CFG_DESC_EP_OUT_TYPE_OFFSET) = (uint_8)pDiskCtrl->outEpType;
 
-                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET) = 
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET) =
                     USB_uint_16_low(max_pkt_size);
-                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET+1) = 
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET+1) =
                     USB_uint_16_high(max_pkt_size);
-            
-                _usb_device_send_data(handle, 0, (uint_8_ptr)pDiskCtrl->other_speed_config, 
+
+                _usb_device_send_data(handle, 0, (uint_8_ptr)pDiskCtrl->other_speed_config,
                             MIN(setup_ptr->LENGTH, OTHER_SPEED_CONFIG_DESC_SIZE));
-               
+
                 break;
 
             default:
-                USB_printf("usbDisk_%d, %s: Unexpected VALUE=0x%04x\n", 
+                USB_printf("usbDisk_%d, %s: Unexpected VALUE=0x%04x\n",
                         _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);
                 _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
                 return;
@@ -626,26 +626,26 @@ static void ch9GetDescription
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SetDescription
 * Returned Value : None
 * Comments       :
 *     Chapter 9 SetDescription command
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9SetDescription
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
-   USB_printf("usbDisk_%d, %s: setup=%d\n", 
+   USB_printf("usbDisk_%d, %s: setup=%d\n",
         _usb_device_get_dev_num(handle), __FUNCTION__, (int)setup);
    _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
 
@@ -653,21 +653,21 @@ static void ch9SetDescription
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9GetConfig
 * Returned Value : None
 * Comments       :
 *     Chapter 9 GetConfig command
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9GetConfig
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
@@ -680,10 +680,10 @@ static void ch9GetConfig
 
     /* Return the currently selected configuration */
     if (setup)
-    { 
+    {
         _usb_device_get_status(handle, ARC_USB_STATUS_CURRENT_CONFIG,
                                 &current_config);
-        *pDiskCtrl->epTemp_buf = (current_config & 0xFF);      
+        *pDiskCtrl->epTemp_buf = (current_config & 0xFF);
         _usb_device_send_data(handle, 0, pDiskCtrl->epTemp_buf, sizeof(uint_8));
         /* status phase */
         _usb_device_recv_data(handle, 0, NULL, 0);
@@ -692,21 +692,21 @@ static void ch9GetConfig
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SetConfig
 * Returned Value : None
 * Comments       :
 *     Chapter 9 SetConfig command
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9SetConfig
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
@@ -715,38 +715,38 @@ static void ch9SetConfig
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
     uint_16             usb_state;
     uint_32             max_pkt_size;
-   
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d, value=0x%x\n", 
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d, value=0x%x\n",
                     __FUNCTION__, (int)setup, setup_ptr->VALUE);
 
-    if (setup) 
+    if (setup)
     {
-        if ((setup_ptr->VALUE & 0x00FF) > 1) 
+        if ((setup_ptr->VALUE & 0x00FF) > 1)
         {
             /* generate stall */
-            USB_printf("usbDisk_%d, %s: Wrong VALUE=0x%04x\n", 
+            USB_printf("usbDisk_%d, %s: Wrong VALUE=0x%04x\n",
                     _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);
             _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
             return;
         } /* Endif */
 
         /* 0 indicates return to unconfigured state */
-        if ((setup_ptr->VALUE & 0x00FF) == 0) 
+        if ((setup_ptr->VALUE & 0x00FF) == 0)
         {
             _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_state);
-            if( (usb_state == ARC_USB_STATE_CONFIG) || 
-                (usb_state == ARC_USB_STATE_ADDRESS) ) 
+            if( (usb_state == ARC_USB_STATE_CONFIG) ||
+                (usb_state == ARC_USB_STATE_ADDRESS) )
             {
                 /* clear the currently selected config value */
                 _usb_device_set_status(handle, ARC_USB_STATUS_CURRENT_CONFIG, 0);
                 _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE,
                                                     ARC_USB_STATE_ADDRESS);
-                /* status phase */      
+                /* status phase */
                 _usb_device_send_data(handle, 0, 0, 0);
-            } 
-            else 
+            }
+            else
             {
-                USB_printf("usbDisk_%d, %s: Wrong usb_state=%d\n", 
+                USB_printf("usbDisk_%d, %s: Wrong usb_state=%d\n",
                     _usb_device_get_dev_num(handle), __FUNCTION__, usb_state);
                 _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
             } /* Endif */
@@ -761,13 +761,13 @@ static void ch9SetConfig
         _usb_device_get_status(handle, ARC_USB_STATUS_CURRENT_CONFIG,
                                                         &usb_state);
 
-        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk: Set configuration: old=%d, new=%d\n", 
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk: Set configuration: old=%d, new=%d\n",
                     usb_state, setup_ptr->VALUE & 0x00FF);
 
-        if (usb_state != (setup_ptr->VALUE & 0x00FF)) 
+        if (usb_state != (setup_ptr->VALUE & 0x00FF))
         {
             /* Reconfigure endpoints here */
-            switch (setup_ptr->VALUE & 0x00FF) 
+            switch (setup_ptr->VALUE & 0x00FF)
             {
                 default:
                 break;
@@ -777,25 +777,25 @@ static void ch9SetConfig
                                     setup_ptr->VALUE & 0x00FF);
         } /* Endif */
 
-        if (pDiskCtrl->speed == ARC_USB_SPEED_HIGH) 
+        if (pDiskCtrl->speed == ARC_USB_SPEED_HIGH)
         {
             max_pkt_size = pDiskCtrl->hsMaxPktSize;
-        } 
-        else 
+        }
+        else
         {
             max_pkt_size = pDiskCtrl->fsMaxPktSize;
         } /* Endif */
-      
+
         _usb_device_init_endpoint(handle, pDiskCtrl->outEpNo, max_pkt_size,
                 ARC_USB_RECV, ARC_USB_BULK_ENDPOINT, ARC_USB_DEVICE_DONT_ZERO_TERMINATE);
         _usb_device_init_endpoint(handle, pDiskCtrl->inEpNo, max_pkt_size,
                 ARC_USB_SEND, ARC_USB_BULK_ENDPOINT, ARC_USB_DEVICE_DONT_ZERO_TERMINATE);
-    
-        if (_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) == USB_OK) 
+
+        if (_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) == USB_OK)
         {
             _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
-        } /* Endif */      
-      
+        } /* Endif */
+
         pDiskCtrl->TEST_ENABLED = TRUE;
 
         _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE,
@@ -803,8 +803,8 @@ static void ch9SetConfig
         /* status phase */
         _usb_device_send_data(handle, 0, 0, 0);
 
-        USB_printf("USB %s speed disk: config = %d\n", 
-            (pDiskCtrl->speed == ARC_USB_SPEED_HIGH) ? "High" : "Full", 
+        USB_printf("USB %s speed disk: config = %d\n",
+            (pDiskCtrl->speed == ARC_USB_SPEED_HIGH) ? "High" : "Full",
             setup_ptr->VALUE & 0x00FF);
 
     } /* Endif */
@@ -812,76 +812,76 @@ static void ch9SetConfig
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9GetInterface
 * Returned Value : None
 * Comments       :
 *     Chapter 9 GetInterface command
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9GetInterface
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
     uint_16 usb_state;
-   
+
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d\n", __FUNCTION__, (int)setup);
 
     _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_state);
-    if (usb_state != ARC_USB_STATE_CONFIG) 
+    if (usb_state != ARC_USB_STATE_CONFIG)
     {
-        USB_printf("usbDisk_%d, %s: Wrong usb_state=%d\n", 
+        USB_printf("usbDisk_%d, %s: Wrong usb_state=%d\n",
                     _usb_device_get_dev_num(handle), __FUNCTION__, usb_state);
         _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
         return;
     } /* Endif */
 
-    if (setup) 
+    if (setup)
     {
         _usb_device_send_data(handle, 0, &USB_IF_ALT[setup_ptr->INDEX & 0x00FF],
                             MIN(setup_ptr->LENGTH, sizeof(uint_8)));
-        /* status phase */      
+        /* status phase */
         _usb_device_recv_data(handle, 0, NULL, 0);
     } /* Endif */
     return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SetInterface
 * Returned Value : None
 * Comments       :
 *     Chapter 9 SetInterface command
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9SetInterface
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d\n", __FUNCTION__, (int)setup);
 
-    if (setup) 
+    if (setup)
     {
-        if (setup_ptr->REQUESTTYPE != 0x01) 
+        if (setup_ptr->REQUESTTYPE != 0x01)
         {
-            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n", 
-                        _usb_device_get_dev_num(handle), __FUNCTION__, 
+            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__,
                         setup_ptr->REQUESTTYPE);
             _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
             return;
@@ -897,7 +897,7 @@ static void ch9SetInterface
         {
             USB_IF_ALT[setup_ptr->INDEX & 0x00FF] = (setup_ptr->VALUE & 0x00FF);
             /* Reconfigure endpoints here. */
-         
+
         } /* Endif */
 
         /* status phase */
@@ -907,21 +907,21 @@ static void ch9SetInterface
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SynchFrame
-* Returned Value : 
+* Returned Value :
 * Comments       :
 *     Chapter 9 SynchFrame command
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9SynchFrame
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
@@ -931,15 +931,15 @@ static void ch9SynchFrame
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
 
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d\n", 
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d\n",
                                         __FUNCTION__, (int)setup);
 
-    if (setup) 
+    if (setup)
     {
         if (setup_ptr->REQUESTTYPE != (REQ_RECIP_ENDPOINT | REQ_TYPE_STANDARD | REQ_DIR_OUT) )
         {
-            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n", 
-                        _usb_device_get_dev_num(handle), __FUNCTION__, 
+            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__,
                         setup_ptr->REQUESTTYPE);
             _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
             return;
@@ -948,7 +948,7 @@ static void ch9SynchFrame
         if ((setup_ptr->INDEX & 0x00FF) >=
             pDiskCtrl->ConfigDesc[CONFIG_DESC_NUM_INTERFACES])
         {
-            USB_printf("usbDisk_%d, %s: Wrong INDEX=0x%02x\n", 
+            USB_printf("usbDisk_%d, %s: Wrong INDEX=0x%02x\n",
                         _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->INDEX);
             _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
             return;
@@ -958,20 +958,20 @@ static void ch9SynchFrame
         pDiskCtrl->epTemp_buf[0] = USB_uint_16_low(usbStatus);
         pDiskCtrl->epTemp_buf[1] = USB_uint_16_high(usbStatus);
         _usb_device_send_data(handle, 0, pDiskCtrl->epTemp_buf, MIN(setup_ptr->LENGTH, sizeof(uint_16)));
-        /* status phase */      
+        /* status phase */
         _usb_device_recv_data(handle, 0, NULL, 0);
     } /* Endif */
     return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9Class
-* Returned Value : 
+* Returned Value :
 * Comments       :
 *     Chapter 9 Class specific request
 *     See section 9.4.11 (page 195) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9Class
    (
@@ -983,41 +983,41 @@ static void ch9Class
 { /* Body */
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
-   
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_CLASS, 
-                "usbDisk %s: setup=%d, request=0x%x, value=%d, index=%d, size=%d\n", 
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_CLASS,
+                "usbDisk %s: setup=%d, request=0x%x, value=%d, index=%d, size=%d\n",
                 __FUNCTION__, (int)setup, setup_ptr->REQUEST,
                 setup_ptr->VALUE, setup_ptr->INDEX, setup_ptr->LENGTH);
 
-    if (setup) 
+    if (setup)
     {
-        switch (setup_ptr->REQUEST) 
+        switch (setup_ptr->REQUEST)
         {
             case 0xFF:
-                /* Bulk-Only Mass Storage Reset: Ready the device for the next 
-                ** CBW from the host 
+                /* Bulk-Only Mass Storage Reset: Ready the device for the next
+                ** CBW from the host
                 */
-                if ((setup_ptr->VALUE != 0) || 
+                if ((setup_ptr->VALUE != 0) ||
                     (setup_ptr->INDEX != MASS_STORAGE_INTERFACE) ||
-                    (setup_ptr->LENGTH != 0)) 
+                    (setup_ptr->LENGTH != 0))
                 {
-                    USB_printf("usbDisk_%d, %s: Wrong Setup: VALUE=%d, INDEX=%d, LENGTH=%d\n", 
-                        _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE, 
+                    USB_printf("usbDisk_%d, %s: Wrong Setup: VALUE=%d, INDEX=%d, LENGTH=%d\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE,
                         setup_ptr->INDEX, setup_ptr->LENGTH);
 
                     _usb_device_stall_endpoint(handle, 0, 0);
-                } 
-                else 
+                }
+                else
                 { /* Body */
                     pDiskCtrl->CBW_PROCESSED = FALSE;
                     pDiskCtrl->ZERO_TERMINATE = FALSE;
                     _usb_device_cancel_transfer(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
                     _usb_device_cancel_transfer(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
-               
+
                     /* unstall bulk endpoint */
                     _usb_device_unstall_endpoint(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
                     _usb_device_unstall_endpoint(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
-               
+
                     _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
                     /* send zero packet to control pipe */
                     _usb_device_send_data(handle, 0, NULL, 0);
@@ -1026,53 +1026,53 @@ static void ch9Class
 
             case 0xFE:
                 /* For Get Max LUN use any of these responses*/
-                if (setup_ptr->LENGTH == 0) 
+                if (setup_ptr->LENGTH == 0)
                 { /* Body */
 
-                    USB_printf("usbDisk_%d, %s: Wrong Length: LENGTH=%d\n", 
+                    USB_printf("usbDisk_%d, %s: Wrong Length: LENGTH=%d\n",
                         _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->LENGTH);
 
                     _usb_device_stall_endpoint(handle, 0, 0);
-                } 
+                }
                 else
                 {
                     if ((setup_ptr->VALUE != 0) ||
                         (setup_ptr->INDEX != MASS_STORAGE_INTERFACE) ||
-                        (setup_ptr->LENGTH != 1)) 
+                        (setup_ptr->LENGTH != 1))
                     { /* Body */
-                        USB_printf("usbDisk_%d, %s: Wrong Setup: VALUE=%d, INDEX=%d, LENGTH=%d\n", 
-                                    _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE, 
+                        USB_printf("usbDisk_%d, %s: Wrong Setup: VALUE=%d, INDEX=%d, LENGTH=%d\n",
+                                    _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE,
                                     setup_ptr->INDEX, setup_ptr->LENGTH);
                         _usb_device_stall_endpoint(handle, 0, 0);
-                    } 
-                    else 
+                    }
+                    else
                     { /* Body */
                         /* Send Max LUN = 0 to the the control pipe */
                         *pDiskCtrl->epTemp_buf = 0;
                         _usb_device_send_data(handle, 0, pDiskCtrl->epTemp_buf, 1);
                         /* status phase */
                         _usb_device_recv_data(handle, 0, 0, 0);
-                    } /* Endbody */     
+                    } /* Endbody */
                 }
                 break;
 
             default :
-                USB_printf("usbDisk_%d, %s: Wrong REQUEST=0x%02x\n", 
+                USB_printf("usbDisk_%d, %s: Wrong REQUEST=0x%02x\n",
                     _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->REQUEST);
                 _usb_device_stall_endpoint(handle, 0, 0);
                 return;
         } /* EndSwitch */
-    } 
+    }
     return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : service_ep0
 * Returned Value : None
 * Comments       :
 *     Called upon a completed endpoint 0 (USB 1.1 Chapter 9) transfer
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void service_ep0
    (
@@ -1084,44 +1084,44 @@ static void service_ep0
 
       /* [IN] Is it a setup packet? */
       boolean              setup,
-      
+
       /* [IN] Direction of the transfer.  Is it transmit? */
       uint_8               direction,
-      
+
       /* [IN] Pointer to the data buffer */
       uint_8_ptr           buffer,
-      
+
       /* [IN] Length of the transfer */
       uint_32              length,
-      
+
       /* [IN] Error, if any */
       uint_8               error
-            
+
    )
 { /* Body */
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
     SETUP_STRUCT*       pSetupPacket = &pDiskCtrl->local_setup_packet;
 
-   if (setup) 
+   if (setup)
    {
       _usb_device_read_setup_data(handle, 0, (uint_8_ptr)pSetupPacket);
         pSetupPacket->VALUE = USB_16BIT_LE(pSetupPacket->VALUE);
         pSetupPacket->INDEX = USB_16BIT_LE(pSetupPacket->INDEX);
         pSetupPacket->LENGTH = USB_16BIT_LE(pSetupPacket->LENGTH);
    }
-   
+
    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_EP0,
               "disk %s: setup=%s, dir=%s, pBuf=0x%x, length=%d, reqType=0x%x, req=0x%x\n",
-                    __FUNCTION__, (setup ? "YES" : "NO"), 
-                    (direction == ARC_USB_RECV) ? "RECV" : "SEND", 
-                    (unsigned)buffer, (int)length, pSetupPacket->REQUESTTYPE, 
+                    __FUNCTION__, (setup ? "YES" : "NO"),
+                    (direction == ARC_USB_RECV) ? "RECV" : "SEND",
+                    (unsigned)buffer, (int)length, pSetupPacket->REQUESTTYPE,
                     pSetupPacket->REQUEST);
 
-   switch (pSetupPacket->REQUESTTYPE & REQ_TYPE_MASK) 
+   switch (pSetupPacket->REQUESTTYPE & REQ_TYPE_MASK)
    {
       case REQ_TYPE_STANDARD:
-         switch (pSetupPacket->REQUEST) 
+         switch (pSetupPacket->REQUEST)
          {
             case REQ_GET_STATUS:
                mvUsbCh9GetStatus(handle, setup, pSetupPacket);
@@ -1168,13 +1168,13 @@ static void service_ep0
                break;
 
             default:
-                USB_printf("usbDisk_%d, %s: Wrong REQUEST = 0x%02x\n", 
+                USB_printf("usbDisk_%d, %s: Wrong REQUEST = 0x%02x\n",
                         _usb_device_get_dev_num(handle), __FUNCTION__, pSetupPacket->REQUEST);
                _usb_device_stall_endpoint(handle, 0, 0);
                break;
 
          } /* Endswitch */
-         
+
          break;
 
       case REQ_TYPE_CLASS:
@@ -1184,41 +1184,41 @@ static void service_ep0
 
       case REQ_TYPE_VENDOR:
          /* vendor specific request can be handled here*/
-         USB_printf("usbDisk_%d, %s: Vendor REQUESTTYPE (%d) not supported\n", 
+         USB_printf("usbDisk_%d, %s: Vendor REQUESTTYPE (%d) not supported\n",
                _usb_device_get_dev_num(handle), __FUNCTION__, REQ_TYPE_VENDOR);
-         
+
          _usb_device_stall_endpoint(handle, 0, 0);
          break;
-      
+
       default:
-         USB_printf("usbDisk_%d, %s: Unexpected REQUESTTYPE = 0x%x\n", 
-                _usb_device_get_dev_num(handle), __FUNCTION__, 
+         USB_printf("usbDisk_%d, %s: Unexpected REQUESTTYPE = 0x%x\n",
+                _usb_device_get_dev_num(handle), __FUNCTION__,
                 pSetupPacket->REQUESTTYPE);
-         
+
          _usb_device_stall_endpoint(handle, 0, 0);
          break;
-         
+
    } /* Endswitch */
-   
+
    return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _process_inquiry_command
 * Returned Value : None
 * Comments       :
 *     Process a Mass storage class Inquiry command
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _process_inquiry_command
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-            
+
       /* [IN] Endpoint number */
       uint_8               ep_num,
-      
+
       /* [IN] Pointer to the data buffer */
       CBW_STRUCT_PTR       cbw_ptr
    )
@@ -1226,82 +1226,82 @@ void _process_inquiry_command
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
 
-    if (cbw_ptr->DCBWDATALENGTH) 
+    if (cbw_ptr->DCBWDATALENGTH)
     {
-        if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT) 
-        {      
+        if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)
+        {
             /* Send the device information */
             _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)&device_information_data, 36);
         } /* Endif */
     } /* Endif */
-   
-    /* The actual length will never exceed the DCBWDATALENGTH */            
+
+    /* The actual length will never exceed the DCBWDATALENGTH */
     pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH - 36);
     pDiskCtrl->pCSW->BCSWSTATUS = 0;
-   
+
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _process_unsupported_command
 * Returned Value : None
 * Comments       :
 *     Responds appropriately to unsupported commands
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _process_unsupported_command
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-            
+
       /* [IN] Endpoint number */
       uint_8               ep_num,
-      
+
       /* [IN] Pointer to the data buffer */
       CBW_STRUCT_PTR       cbw_ptr
    )
 { /* Body */
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
-   
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK, 
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK,
                     "disk unsupported command: BMCBWFLAGS = 0x%02x\n", cbw_ptr->BMCBWFLAGS);
 
     /* The actual length will never exceed the DCBWDATALENGTH */
     pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
     pDiskCtrl->pCSW->BCSWSTATUS = 0;
 
-    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT) 
-    {      
+    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)
+    {
         /* Send a zero-length packet */
         _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)NULL, 0);
-    } 
-    else 
+    }
+    else
     {
         pDiskCtrl->CBW_PROCESSED = FALSE;
         /* Send the command status information */
         _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
         _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
     } /* Endif */
-   
+
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _process_report_capacity
 * Returned Value : None
 * Comments       :
 *     Reports the media capacity as a response to READ CAPACITY Command.
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _process_report_capacity
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-            
+
       /* [IN] Endpoint number */
       uint_8               ep_num,
-      
+
       /* [IN] Pointer to the data buffer */
       CBW_STRUCT_PTR       cbw_ptr
    )
@@ -1309,38 +1309,38 @@ void _process_report_capacity
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
 
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_CAP, 
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_CAP,
                     "disk read_capacity: BMCBWFLAGS = 0x%02x\n", cbw_ptr->BMCBWFLAGS);
 
-    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT) 
-    {      
+    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)
+    {
         /* Send a zero-length packet */
         _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pReadCapacity, 8);
-      
+
     } /* Endif */
-   
-    /* The actual length will never exceed the DCBWDATALENGTH */            
+
+    /* The actual length will never exceed the DCBWDATALENGTH */
     pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
     pDiskCtrl->pCSW->BCSWSTATUS = 0;
-   
+
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _process_read_command
 * Returned Value : None
 * Comments       :
 *     Sends data as a response to READ Command.
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _process_read_command
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-            
+
       /* [IN] Endpoint number */
       uint_8               ep_num,
-      
+
       /* [IN] Pointer to the data buffer */
       CBW_STRUCT_PTR       cbw_ptr
    )
@@ -1350,16 +1350,16 @@ void _process_read_command
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
 
-    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT) 
-    {                
+    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)
+    {
       /* Send a zero-length packet */
       index1  = ((uint_32)cbw_ptr->CBWCB[4] << 8);
       index1  |= cbw_ptr->CBWCB[5];
       index2 = ((uint_32)cbw_ptr->CBWCB[7] << 8);
       index2 |= (uint_32)cbw_ptr->CBWCB[8];
 
-      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_READ, 
-                    "disk read: FLAGS=0x%02x, LENGTH=0x%x, index1=0x%x, index2=0x%x\n", 
+      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_READ,
+                    "disk read: FLAGS=0x%02x, LENGTH=0x%x, index1=0x%x, index2=0x%x\n",
                     cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH, index1, index2);
 
       if(cbw_ptr->CBWCB[0] != 0x3E)
@@ -1383,8 +1383,8 @@ void _process_read_command
           _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)NULL, 0);
           return;
       }
- 
-      if (cbw_ptr->DCBWDATALENGTH == 0) 
+
+      if (cbw_ptr->DCBWDATALENGTH == 0)
       { /* Body */
          pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
          pDiskCtrl->pCSW->BCSWSTATUS = 2;
@@ -1393,49 +1393,49 @@ void _process_read_command
          _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
          _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
          return;
-      } 
-      else 
+      }
+      else
       { /* Body */
          pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
-         pDiskCtrl->pCSW->BCSWSTATUS = 0;         
-         if (byteSize > cbw_ptr->DCBWDATALENGTH) 
+         pDiskCtrl->pCSW->BCSWSTATUS = 0;
+         if (byteSize > cbw_ptr->DCBWDATALENGTH)
          { /* Body */
             byteSize = cbw_ptr->DCBWDATALENGTH;
             pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
             pDiskCtrl->pCSW->BCSWSTATUS = 2;
-         } 
-         else 
+         }
+         else
          {
-            if (byteSize < cbw_ptr->DCBWDATALENGTH) 
+            if (byteSize < cbw_ptr->DCBWDATALENGTH)
             { /* Body */
                 pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH - index2);
-                if (byteSize > 0) 
+                if (byteSize > 0)
                 { /* Body */
-                    if (pDiskCtrl->speed == ARC_USB_SPEED_HIGH) 
+                    if (pDiskCtrl->speed == ARC_USB_SPEED_HIGH)
                     {
                         max_pkt_size = pDiskCtrl->hsMaxPktSize;
-                    } 
-                    else 
+                    }
+                    else
                     {
                         max_pkt_size = pDiskCtrl->fsMaxPktSize;
                     }
 
-                    if( (byteSize % max_pkt_size) == 0) 
+                    if( (byteSize % max_pkt_size) == 0)
                     { /* Body */
                         /* Need send a zero terminate packet to host */
                         pDiskCtrl->ZERO_TERMINATE = TRUE;
                     } /* Endbody */
-                } /* Endbody */  
+                } /* Endbody */
             } /* Endbody */
          }
 
-         _usb_device_send_data(handle, pDiskCtrl->inEpNo, 
+         _usb_device_send_data(handle, pDiskCtrl->inEpNo,
             pDiskCtrl->MASS_STORAGE_DISK + (index1*LENGTH_OF_EACH_LAB), byteSize);
       } /* Endbody */
-   } 
-   else 
+   }
+   else
    { /* Body */
-      USB_printf("disk read incorrect: FLAGS=0x%02x, LENGTH=0x%x\n", 
+      USB_printf("disk read incorrect: FLAGS=0x%02x, LENGTH=0x%x\n",
                     cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH);
 
       /* Incorrect but valid CBW */
@@ -1446,26 +1446,26 @@ void _process_read_command
 
       pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
       pDiskCtrl->pCSW->BCSWSTATUS = 2;
-       _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, index2);   
-   } /* Endbody */     
+       _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, index2);
+   } /* Endbody */
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _process_write_command
 * Returned Value : None
 * Comments       :
 *     Sends data as a response to WRITE Command.
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _process_write_command
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-            
+
       /* [IN] Endpoint number */
       uint_8               ep_num,
-      
+
       /* [IN] Pointer to the data buffer */
       CBW_STRUCT_PTR       cbw_ptr
    )
@@ -1475,17 +1475,17 @@ void _process_write_command
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
 
-    if (!(cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)) 
+    if (!(cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT))
     {
         index1  = ((uint_32)cbw_ptr->CBWCB[4] << 8);
         index1  |= cbw_ptr->CBWCB[5];
         index2 = ((uint_32)cbw_ptr->CBWCB[7] << 8);
         index2 |= (uint_32)cbw_ptr->CBWCB[8];
-        
-        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_WRITE, 
-                      "disk write: FLAGS=0x%02x, LENGTH=0x%x, index1=0x%x, index2=0x%x\n", 
+
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_WRITE,
+                      "disk write: FLAGS=0x%02x, LENGTH=0x%x, index1=0x%x, index2=0x%x\n",
                       cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH, index1, index2);
-        
+
         if(cbw_ptr->CBWCB[0] != 0x3F)
         {
             byteSize = index2 * LENGTH_OF_EACH_LAB;
@@ -1495,7 +1495,7 @@ void _process_write_command
             byteSize = index2;
             index2 = (USB_MEM_ALIGN(byteSize, LENGTH_OF_EACH_LAB) / LENGTH_OF_EACH_LAB);
         }
-        
+
         /* Check index validities */
         if( (index1 + index2) >= pDiskCtrl->logicalBlocks)
         {
@@ -1510,49 +1510,49 @@ void _process_write_command
             return;
         }
 
-        if (cbw_ptr->DCBWDATALENGTH == 0) 
+        if (cbw_ptr->DCBWDATALENGTH == 0)
         { /* Body */
             /* Zero transfer length */
             pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
             pDiskCtrl->pCSW->BCSWSTATUS = 2;
             pDiskCtrl->CBW_PROCESSED = FALSE;
-            
+
             /* Send the command status information */
             _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
-            
+
             _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
             return;
-        } 
-        else 
+        }
+        else
         { /* Body */
             pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
             pDiskCtrl->pCSW->BCSWSTATUS = 0;
-         
-            if (byteSize < cbw_ptr->DCBWDATALENGTH) 
+
+            if (byteSize < cbw_ptr->DCBWDATALENGTH)
             { /* Body */
                 /* The actual length will never exceed the DCBWDATALENGTH */
                 pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH - byteSize);
                 byteSize = cbw_ptr->DCBWDATALENGTH;
-            } 
-            else if (byteSize > cbw_ptr->DCBWDATALENGTH) 
+            }
+            else if (byteSize > cbw_ptr->DCBWDATALENGTH)
             { /* Body */
                 pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
                 pDiskCtrl->pCSW->BCSWSTATUS = 2;
                 byteSize = cbw_ptr->DCBWDATALENGTH;
             } /* Endbody */
-            
-            if (_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) != USB_OK) 
+
+            if (_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) != USB_OK)
             {
                 _usb_device_cancel_transfer(handle, ep_num, ARC_USB_RECV);
             } /* Endif */
 
-            _usb_device_recv_data(handle, pDiskCtrl->outEpNo, 
+            _usb_device_recv_data(handle, pDiskCtrl->outEpNo,
                     pDiskCtrl->MASS_STORAGE_DISK + (index1*LENGTH_OF_EACH_LAB), byteSize);
         }
-    } 
-    else 
+    }
+    else
     { /* Body */
-        USB_printf("disk write incorrect: FLAGS=0x%02x, LENGTH=0x%x\n", 
+        USB_printf("disk write incorrect: FLAGS=0x%02x, LENGTH=0x%x\n",
                     cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH);
 
         /* Incorrect but valid CBW */
@@ -1561,25 +1561,25 @@ void _process_write_command
         _usb_device_send_data(handle, pDiskCtrl->inEpNo, 0, 0);
         return;
     } /* Endbody */
-   
+
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _process_test_unit_ready
 * Returned Value : None
 * Comments       :
 *     Responds appropriately to unit ready query
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _process_test_unit_ready
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-            
+
       /* [IN] Endpoint number */
       uint_8               ep_num,
-      
+
       /* [IN] Pointer to the data buffer */
       CBW_STRUCT_PTR       cbw_ptr
    )
@@ -1587,21 +1587,21 @@ void _process_test_unit_ready
     uint_32             bufSize;
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
-   
+
     if ((cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT) ||
-        (cbw_ptr->DCBWDATALENGTH == 0)) 
+        (cbw_ptr->DCBWDATALENGTH == 0))
     {
         /* The actual length will never exceed the DCBWDATALENGTH */
         pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
         pDiskCtrl->pCSW->BCSWSTATUS = 0;
-   
+
         pDiskCtrl->CBW_PROCESSED = FALSE;
 
         /* Send the command status information */
         _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
         _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
-    } 
-    else 
+    }
+    else
     { /* Body */
       /* Incorrect but valid CBW */
         if (cbw_ptr->DCBWDATALENGTH > BUFFERSIZE)
@@ -1613,25 +1613,25 @@ void _process_test_unit_ready
         pDiskCtrl->pCSW->BCSWSTATUS = 1;
         _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, bufSize);
     } /* Endbody */
-   
+
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _process_prevent_allow_medium_removal
 * Returned Value : None
 * Comments       :
 *     Responds appropriately to unit ready query
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _process_prevent_allow_medium_removal
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-            
+
       /* [IN] Endpoint number */
       uint_8               ep_num,
-      
+
       /* [IN] Pointer to the data buffer */
       CBW_STRUCT_PTR       cbw_ptr
    )
@@ -1642,41 +1642,41 @@ void _process_prevent_allow_medium_remov
     /* The actual length will never exceed the DCBWDATALENGTH */
     pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
     pDiskCtrl->pCSW->BCSWSTATUS = 0;
-   
+
     pDiskCtrl->CBW_PROCESSED = FALSE;
 
     /* Send the command status information */
     _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
     _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
-   
+
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : _process_mass_storage_command
 * Returned Value : None
 * Comments       :
 *     Process a Mass storage class command
-* 
+*
 *END*--------------------------------------------------------------------*/
 void _process_mass_storage_command
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-            
+
       /* [IN] Endpoint number */
       uint_8               ep_num,
-      
+
       /* [IN] Pointer to the data buffer */
       CBW_STRUCT_PTR       cbw_ptr
    )
 { /* Body */
 
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK, 
-                    "disk command: CBWCB[0]=0x%02x, FLAGS=0x%02x, LENGTH=0x%x\n", 
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK,
+                    "disk command: CBWCB[0]=0x%02x, FLAGS=0x%02x, LENGTH=0x%x\n",
                     cbw_ptr->CBWCB[0], cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH);
 
-   switch (cbw_ptr->CBWCB[0]) 
+   switch (cbw_ptr->CBWCB[0])
    {
       case 0x00: /* Request the device to report if it is ready */
          _process_test_unit_ready(handle, ep_num, cbw_ptr);
@@ -1694,8 +1694,8 @@ void _process_mass_storage_command
          _process_prevent_allow_medium_removal(handle, ep_num, cbw_ptr);
          break;
 
-      case 0x23: /* Read Format Capacities. Report current media capacity and 
-                 ** formattable capacities supported by media 
+      case 0x23: /* Read Format Capacities. Report current media capacity and
+                 ** formattable capacities supported by media
                   */
          /* We bahave like already installed medium. No need to send any data */
          _process_unsupported_command(handle, ep_num, cbw_ptr);
@@ -1718,20 +1718,20 @@ void _process_mass_storage_command
       case 0x01: /* Position a head of the drive to zero track */
       case 0x03: /* Transfer status sense data to the host */
       case 0x04: /* Format unformatted media */
-      case 0x1B: /* Request a request a removable-media device to load or 
-                 ** unload its media 
+      case 0x1B: /* Request a request a removable-media device to load or
+                 ** unload its media
                  */
       case 0x1D: /* Perform a hard reset and execute diagnostics */
       case 0x2B: /* Seek the device to a specified address */
-      case 0x2E: /* Transfer binary data from the host to the media and 
-                 ** verify data 
+      case 0x2E: /* Transfer binary data from the host to the media and
+                 ** verify data
                  */
       case 0x2F: /* Verify data on the media */
       case 0x55: /* Allow the host to set parameters in a peripheral */
       case 0x5A: /* Report parameters to the host */
       case 0xA8: /* Read (12) Transfer binary data from the media to the host */
-      case 0xAA: /* Write (12) Transfer binary data from the host to the 
-                 ** media 
+      case 0xAA: /* Write (12) Transfer binary data from the host to the
+                 ** media
                  */
       default:
          _process_unsupported_command(handle, ep_num, cbw_ptr);
@@ -1741,12 +1741,12 @@ void _process_mass_storage_command
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : service_ep1
 * Returned Value : None
 * Comments       :
 *     Called upon a completed endpoint 1 (USB 1.1 Chapter 9) transfer
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void service_ep1
    (
@@ -1755,35 +1755,35 @@ static void service_ep1
 
       /* [IN] Service type as registered */
       uint_8               type,
-      
+
       /* [IN] Is it a setup packet? */
       boolean              setup,
-      
+
       /* [IN] Direction of the transfer.  Is it transmit? */
       uint_8               direction,
-      
+
       /* [IN] Pointer to the data buffer */
       uint_8_ptr           buffer,
-      
+
       /* [IN] Length of the transfer */
       uint_32              length,
 
       /* [IN] Error, if any */
       uint_8               error
-            
+
    )
 { /* Body */
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
-    CBW_STRUCT_PTR cbw_ptr = (CBW_STRUCT_PTR)((pointer)buffer);      
+    CBW_STRUCT_PTR cbw_ptr = (CBW_STRUCT_PTR)((pointer)buffer);
 
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_EP1, 
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_EP1,
                     "disk %s: ep=%d, dir=%s, pBuf=0x%x, length=%d, error=0x%x\n",
-                    __FUNCTION__, type, (direction == ARC_USB_RECV) ? "RECV" : "SEND", 
+                    __FUNCTION__, type, (direction == ARC_USB_RECV) ? "RECV" : "SEND",
                     (unsigned)buffer, (int)length, error);
 
-    if ((!direction) && (!pDiskCtrl->CBW_PROCESSED) && (length == 31) && 
-        (cbw_ptr->DCBWSIGNATURE == USB_32BIT_LE(USB_DCBWSIGNATURE))) 
+    if ((!direction) && (!pDiskCtrl->CBW_PROCESSED) && (length == 31) &&
+        (cbw_ptr->DCBWSIGNATURE == USB_32BIT_LE(USB_DCBWSIGNATURE)))
     {
         /* A valid CBW was received */
         pDiskCtrl->pCSW->DCSWSIGNATURE = USB_32BIT_LE(USB_DCSWSIGNATURE);
@@ -1795,20 +1795,20 @@ static void service_ep1
 
         /* Process the command */
         _process_mass_storage_command(handle, type, cbw_ptr);
-    } 
-    else 
+    }
+    else
     {
-        /* If a CBW was processed then send the status information and 
+        /* If a CBW was processed then send the status information and
         ** queue another cbw receive request, else just queue another CBW receive
-        ** request if we received an invalid CBW 
+        ** request if we received an invalid CBW
         */
-        if (pDiskCtrl->CBW_PROCESSED) 
+        if (pDiskCtrl->CBW_PROCESSED)
         {
             int     i;
 
-            ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DATA, 
+            ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DATA,
                     "disk %s: ep=%d, dir=%s, pBuf=0x%x, length=%d, error=0x%x\n",
-                    __FUNCTION__, type, (direction == ARC_USB_RECV) ? "RECV" : "SEND", 
+                    __FUNCTION__, type, (direction == ARC_USB_RECV) ? "RECV" : "SEND",
                     (unsigned)buffer, (int)length, error);
 
             for(i=0; i<64; i++)
@@ -1819,48 +1819,48 @@ static void service_ep1
                 }
                 ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DUMP, "%02x ", buffer[i]);
                 if( (i % 3) == 0)
-                    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DUMP, " ");                
+                    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DUMP, " ");
             }
 
-            if (pDiskCtrl->ZERO_TERMINATE) 
+            if (pDiskCtrl->ZERO_TERMINATE)
             { /* Body */
                 pDiskCtrl->ZERO_TERMINATE = FALSE;
                 _usb_device_send_data(handle, pDiskCtrl->inEpNo, 0, 0);
-            } 
-            else 
+            }
+            else
             { /* Body */
                 pDiskCtrl->CBW_PROCESSED = FALSE;
 
                 /* Send the command status information */
-                _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);        
+                _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
                 _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
             }
-        } 
+        }
         else
         {
-            if (!direction) 
+            if (!direction)
             {
-                USB_printf("usbDisk_%d, %s: Wrong direction = %d\n", 
+                USB_printf("usbDisk_%d, %s: Wrong direction = %d\n",
                     _usb_device_get_dev_num(handle), __FUNCTION__, direction);
                 _usb_device_stall_endpoint(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
                 _usb_device_stall_endpoint(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
 
                 /* Invalid CBW received. Queue another receive buffer */
-                _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);  
+                _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
             }
         } /* Endif */
     } /* Endif */
-   
+
     return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : service_speed
 * Returned Value : None
 * Comments       :
 *     Called upon a speed detection event.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void service_speed
    (
@@ -1872,24 +1872,24 @@ static void service_speed
 
       /* [IN] Unused */
       boolean              setup,
-   
+
       /* [IN] Unused */
       uint_8               direction,
-   
+
       /* [IN] Unused */
       uint_8_ptr           buffer,
-   
+
       /* [IN] Unused */
       uint_32              length,
 
       /* [IN] Error, if any */
       uint_8               error
-            
+
    )
 { /* EndBody */
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
-    
+
     ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SPEED, "disk %s: speed = %d\n", __FUNCTION__, (unsigned)length);
 
     pDiskCtrl->speed = length;
@@ -1897,42 +1897,42 @@ static void service_speed
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : reset_ep0
 * Returned Value : None
 * Comments       :
 *     Called upon a bus reset event.  Initialises the control endpoint.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void reset_ep0
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-   
+
       /* [IN] request type as registered */
       uint_8               type,
 
       /* [IN] Unused */
       boolean              setup,
-   
+
       /* [IN] Unused */
       uint_8               direction,
-   
+
       /* [IN] Unused */
       uint_8_ptr           buffer,
-   
+
       /* [IN] Unused */
       uint_32              length,
 
       /* [IN] Error, if any */
       uint_8               error
-            
+
    )
 { /* Body */
     int                 devNo = _usb_device_get_dev_num(handle);
     USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
-    
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RESET, "disk-%d %s: pDiskCtrl=%p, handle=%p\n", 
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RESET, "disk-%d %s: pDiskCtrl=%p, handle=%p\n",
                     devNo, __FUNCTION__, pDiskCtrl, handle);
 
     /* on a reset always ensure all transfers are cancelled on control EP*/
@@ -1941,29 +1941,29 @@ static void reset_ep0
 
     _usb_device_start(handle);
     /* Initialize the endpoint 0 in both directions */
-    _usb_device_init_endpoint(handle, 0, pDiskCtrl->DevDesc[DEV_DESC_MAX_PACKET_SIZE], 
+    _usb_device_init_endpoint(handle, 0, pDiskCtrl->DevDesc[DEV_DESC_MAX_PACKET_SIZE],
                                 ARC_USB_RECV, ARC_USB_CONTROL_ENDPOINT, 0);
-    _usb_device_init_endpoint(handle, 0, pDiskCtrl->DevDesc[DEV_DESC_MAX_PACKET_SIZE], 
+    _usb_device_init_endpoint(handle, 0, pDiskCtrl->DevDesc[DEV_DESC_MAX_PACKET_SIZE],
                                 ARC_USB_SEND, ARC_USB_CONTROL_ENDPOINT, 0);
 
 
-    if (pDiskCtrl->TEST_ENABLED) 
+    if (pDiskCtrl->TEST_ENABLED)
     {
         int out_ep_count=0, in_ep_count=0;
 
-        while(_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) != 
+        while(_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) !=
                                                     ARC_USB_STATUS_IDLE)
         {
             out_ep_count++;
             _usb_device_cancel_transfer(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
         }
-        while(_usb_device_get_transfer_status(handle, pDiskCtrl->inEpNo, ARC_USB_SEND) != 
+        while(_usb_device_get_transfer_status(handle, pDiskCtrl->inEpNo, ARC_USB_SEND) !=
                                                     ARC_USB_STATUS_IDLE)
         {
             in_ep_count++;
             _usb_device_cancel_transfer(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
         }
-        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RESET, "disk %s: out_ep_count=%d, in_ep_count=%d\n", 
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RESET, "disk %s: out_ep_count=%d, in_ep_count=%d\n",
                         __FUNCTION__, out_ep_count, in_ep_count);
     } /* Endif */
 
@@ -1973,15 +1973,15 @@ static void reset_ep0
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : usbDiskLoad - main task
 * Inputs:
-*   int diskSize  - size of created disk in KBytes    
+*   int diskSize  - size of created disk in KBytes
 * Returned Value : None
 * Comments       :
 *     First function called.  Initialises the USB and registers Chapter 9
 *     callback functions.
-* 
+*
 *END*--------------------------------------------------------------------*/
 _usb_device_handle  usbDiskLoad(int devNo, int diskSize)
 { /* Body */
@@ -1994,7 +1994,7 @@ _usb_device_handle  usbDiskLoad(int devN
     int                 lockKey, i, j;
     static boolean      isFirst = TRUE;
 
-    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "%s: devNo=%d, diskSize=%d\n", 
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "%s: devNo=%d, diskSize=%d\n",
                         __FUNCTION__, devNo, diskSize);
 
     if(devNo >= MAX_USB_DEVICES)
@@ -2037,7 +2037,7 @@ _usb_device_handle  usbDiskLoad(int devN
     pDiskCtrl = USB_memalloc(sizeof(USB_DISK_STRUCT));
     if(pDiskCtrl == NULL)
     {
-        USB_printf("USB disk #%d: Can't allocate USB_DISK_STRUCT (%d bytes)\n", 
+        USB_printf("USB disk #%d: Can't allocate USB_DISK_STRUCT (%d bytes)\n",
                     devNo, sizeof(USB_DISK_STRUCT));
         USB_unlock(lockKey);
         return NULL;
@@ -2056,7 +2056,7 @@ _usb_device_handle  usbDiskLoad(int devN
         USB_unlock(lockKey);
         return NULL;
     }
-    
+
     pDiskCtrl->devNo = devNo;
     pDiskCtrl->hsMaxPktSize = diskHsMaxPktSize;
     pDiskCtrl->fsMaxPktSize = diskFsMaxPktSize;
@@ -2069,7 +2069,7 @@ _usb_device_handle  usbDiskLoad(int devN
 
     /* Initialize the USB interface */
     error = _usb_device_init(devNo, &handle);
-    if (error != USB_OK) 
+    if (error != USB_OK)
     {
         USB_unlock(lockKey);
         USB_printf("\nUSB Initialization failed. Error: %x", error);
@@ -2077,35 +2077,35 @@ _usb_device_handle  usbDiskLoad(int devN
     } /* Endif */
 
     /* Self Power, Remote wakeup disable */
-    _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, (1 << DEVICE_SELF_POWERED));    
+    _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, (1 << DEVICE_SELF_POWERED));
 
-    error = _usb_device_register_service(handle, ARC_USB_SERVICE_EP0, service_ep0);   
-    if (error != USB_OK) 
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_EP0, service_ep0);
+    if (error != USB_OK)
     {
         USB_unlock(lockKey);
         USB_printf("\nUSB Service Registration failed. Error: %x", error);
         return NULL;
     } /* Endif */
-   
-    error = _usb_device_register_service(handle, ARC_USB_SERVICE_BUS_RESET, reset_ep0);   
-    if (error != USB_OK) 
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_BUS_RESET, reset_ep0);
+    if (error != USB_OK)
     {
         USB_unlock(lockKey);
         USB_printf("\nUSB Service Registration failed. Error: %x", error);
         return NULL;
     } /* Endif */
-   
-    error = _usb_device_register_service(handle, ARC_USB_SERVICE_SPEED_DETECTION, 
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_SPEED_DETECTION,
                                                         service_speed);
-    if (error != USB_OK) 
+    if (error != USB_OK)
     {
         USB_unlock(lockKey);
         USB_printf("\nUSB Service Registration failed. Error: %x", error);
         return NULL;
     } /* Endif */
-         
-    error = _usb_device_register_service(handle, pDiskCtrl->outEpNo, service_ep1);   
-    if (error != USB_OK) 
+
+    error = _usb_device_register_service(handle, pDiskCtrl->outEpNo, service_ep1);
+    if (error != USB_OK)
     {
         USB_unlock(lockKey);
         USB_printf("\nUSB Service Registration failed. Error: %x", error);
@@ -2114,8 +2114,8 @@ _usb_device_handle  usbDiskLoad(int devN
 
     if(pDiskCtrl->outEpNo != pDiskCtrl->inEpNo)
     {
-        error = _usb_device_register_service(handle, pDiskCtrl->inEpNo, service_ep1);   
-        if (error != USB_OK) 
+        error = _usb_device_register_service(handle, pDiskCtrl->inEpNo, service_ep1);
+        if (error != USB_OK)
         {
             USB_unlock(lockKey);
             USB_printf("\nUSB Service Registration failed. Error: %x", error);
@@ -2126,98 +2126,98 @@ _usb_device_handle  usbDiskLoad(int devN
     /**************************************************************************
     Best way to handle the Data cache is to allocate a large buffer that is
     cache aligned and keep all data inside it. Flush the line of the cache
-    that you have changed. In this program, we have static data such as 
+    that you have changed. In this program, we have static data such as
     descriptors which never changes. Such data can be kept in this buffer
     and flushed only once. Note that you can reduce the size of this buffer
-    by aligning the addresses in a different way.   
+    by aligning the addresses in a different way.
     ***************************************************************************/
     send_data_buffer_size =  (DEVICE_DESCRIPTOR_SIZE +  PSP_CACHE_LINE_SIZE) +
                             (CONFIG_DESC_SIZE + PSP_CACHE_LINE_SIZE) +
                             (DEVICE_QUALIFIER_DESCRIPTOR_SIZE + PSP_CACHE_LINE_SIZE) +
                             (OTHER_SPEED_CONFIG_DESC_SIZE + PSP_CACHE_LINE_SIZE) +
                             (BUFFERSIZE + PSP_CACHE_LINE_SIZE) +
-                            (EP_TEMP_BUFFERSIZE + PSP_CACHE_LINE_SIZE) + 
+                            (EP_TEMP_BUFFERSIZE + PSP_CACHE_LINE_SIZE) +
                             (sizeof(DISK_READ_CAPACITY) + PSP_CACHE_LINE_SIZE) +
                             (sizeof(CSW_STRUCT) + PSP_CACHE_LINE_SIZE) +
                             (pDiskCtrl->logicalBlocks*LENGTH_OF_EACH_LAB + PSP_CACHE_LINE_SIZE);
 
     pDiskCtrl->Send_Buffer_Unaligned   = (uint_8_ptr) USB_memalloc(send_data_buffer_size);
-    if (pDiskCtrl->Send_Buffer_Unaligned == NULL) 
+    if (pDiskCtrl->Send_Buffer_Unaligned == NULL)
     {
         USB_unlock(lockKey);
-        USB_printf("diskLoad: Buffer allocation of %d bytes is failed\n", 
+        USB_printf("diskLoad: Buffer allocation of %d bytes is failed\n",
                     (unsigned)send_data_buffer_size);
         return NULL;
     }
-   
+
     Send_Buffer_aligned = (uint_8_ptr) USB_CACHE_ALIGN((uint_32)pDiskCtrl->Send_Buffer_Unaligned);
     /* keep a temporary copy of the aligned address */
     temp = Send_Buffer_aligned;
-   
+
     /**************************************************************************
     Assign pointers to different buffers from it and copy data inside.
     ***************************************************************************/
     pDiskCtrl->DevDesc =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(DevDescData, pDiskCtrl->DevDesc, DEVICE_DESCRIPTOR_SIZE);
-    Send_Buffer_aligned += ((DEVICE_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE; 
-   
+    Send_Buffer_aligned += ((DEVICE_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
     pDiskCtrl->ConfigDesc =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(ConfigDescData, pDiskCtrl->ConfigDesc, CONFIG_DESC_SIZE);
-    Send_Buffer_aligned += ((CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE; 
-   
+    Send_Buffer_aligned += ((CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
     pDiskCtrl->DevQualifierDesc =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(DevQualifierDescData, pDiskCtrl->DevQualifierDesc, DEVICE_QUALIFIER_DESCRIPTOR_SIZE);
     Send_Buffer_aligned += ((DEVICE_QUALIFIER_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + 1) * PSP_CACHE_LINE_SIZE;
 
     pDiskCtrl->other_speed_config =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(other_speed_config_data, pDiskCtrl->other_speed_config, OTHER_SPEED_CONFIG_DESC_SIZE);
-    Send_Buffer_aligned += ((OTHER_SPEED_CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE; 
+    Send_Buffer_aligned += ((OTHER_SPEED_CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
 
     /*buffer to receive data from Bulk OUT */
     pDiskCtrl->ep1_buf =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memzero(pDiskCtrl->ep1_buf, BUFFERSIZE);
     Send_Buffer_aligned += ((BUFFERSIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
-   
+
     /*buffer for control endpoint to send data */
     pDiskCtrl->epTemp_buf =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memzero(pDiskCtrl->epTemp_buf, EP_TEMP_BUFFERSIZE);
-    
-    Send_Buffer_aligned += ((EP_TEMP_BUFFERSIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE; 
+
+    Send_Buffer_aligned += ((EP_TEMP_BUFFERSIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
 
     /* Buffer for read Capacity message */
     pDiskCtrl->pReadCapacity = (DISK_READ_CAPACITY*)Send_Buffer_aligned;
     USB_memcopy((void*)&read_capacity, pDiskCtrl->pReadCapacity, sizeof(DISK_READ_CAPACITY));
 
     /* Update read_capacity */
-    pDiskCtrl->pReadCapacity->LAST_LOGICAL_BLOCK_ADDRESS[2] = 
+    pDiskCtrl->pReadCapacity->LAST_LOGICAL_BLOCK_ADDRESS[2] =
                             USB_uint_16_high(pDiskCtrl->logicalBlocks-14);
-    pDiskCtrl->pReadCapacity->LAST_LOGICAL_BLOCK_ADDRESS[3] = 
+    pDiskCtrl->pReadCapacity->LAST_LOGICAL_BLOCK_ADDRESS[3] =
                             USB_uint_16_low(pDiskCtrl->logicalBlocks-14);
 
-    Send_Buffer_aligned += ((sizeof(DISK_READ_CAPACITY)/PSP_CACHE_LINE_SIZE) + 1) * PSP_CACHE_LINE_SIZE; 
+    Send_Buffer_aligned += ((sizeof(DISK_READ_CAPACITY)/PSP_CACHE_LINE_SIZE) + 1) * PSP_CACHE_LINE_SIZE;
 
     /* Buffer for CSW message */
     pDiskCtrl->pCSW = (CSW_STRUCT*)Send_Buffer_aligned;
     USB_memzero(pDiskCtrl->pCSW , sizeof(CSW_STRUCT));
-    
-    Send_Buffer_aligned += ((sizeof(CSW_STRUCT)/PSP_CACHE_LINE_SIZE) + 1) * PSP_CACHE_LINE_SIZE; 
+
+    Send_Buffer_aligned += ((sizeof(CSW_STRUCT)/PSP_CACHE_LINE_SIZE) + 1) * PSP_CACHE_LINE_SIZE;
 
     /*buffer for storage disk */
     pDiskCtrl->MASS_STORAGE_DISK = (uint_8_ptr)Send_Buffer_aligned;
-    
-    USB_printf("usbDisk-%d: pDiskCtrl=%p, %d bytes allocated addr=0x%x\n", 
-                 devNo, pDiskCtrl, (unsigned)send_data_buffer_size, 
+
+    USB_printf("usbDisk-%d: pDiskCtrl=%p, %d bytes allocated addr=0x%x\n",
+                 devNo, pDiskCtrl, (unsigned)send_data_buffer_size,
                  (unsigned)pDiskCtrl->Send_Buffer_Unaligned);
     USB_printf("usbDisk-%d: DevDesc=0x%x, ConfigDesc=0x%x, QualifierDesc=0x%x, otherSpeedDesc=0x%x\n",
-                 devNo, (unsigned)pDiskCtrl->DevDesc, (unsigned)pDiskCtrl->ConfigDesc, 
+                 devNo, (unsigned)pDiskCtrl->DevDesc, (unsigned)pDiskCtrl->ConfigDesc,
                  (unsigned)pDiskCtrl->DevQualifierDesc, (unsigned)pDiskCtrl->other_speed_config);
     USB_printf("usbDisk-%d: ep1_buf=0x%x, epTemp_buf=0x%x, MASS_STORAGE_DISK=0x%x\n",
-                 devNo, (unsigned)pDiskCtrl->ep1_buf, (unsigned)pDiskCtrl->epTemp_buf, 
+                 devNo, (unsigned)pDiskCtrl->ep1_buf, (unsigned)pDiskCtrl->epTemp_buf,
                  (unsigned)pDiskCtrl->MASS_STORAGE_DISK);
-    
+
     USB_memzero(pDiskCtrl->MASS_STORAGE_DISK, (pDiskCtrl->logicalBlocks*LENGTH_OF_EACH_LAB));
 
-    /* Format the "disk" */      
+    /* Format the "disk" */
     USB_memcopy(BOOT_SECTOR_AREA, pDiskCtrl->MASS_STORAGE_DISK, 512);
 
     /* Update BOOT Sector "Total Small sectors" field */
@@ -2226,7 +2226,7 @@ _usb_device_handle  usbDiskLoad(int devN
 
     USB_memcopy((void *)FAT16_SPECIAL_BYTES, pDiskCtrl->MASS_STORAGE_DISK + 512, 3);
     USB_memcopy((void *)FAT16_SPECIAL_BYTES, pDiskCtrl->MASS_STORAGE_DISK + 512*4, 3);
-                         
+
     /**************************************************************************
     Flush the cache to ensure main memory is updated.
     ***************************************************************************/
@@ -2256,7 +2256,7 @@ void    usbDiskUnload(_usb_device_handle
     }
     /*lock interrupts */
     lockKey = USB_lock();
-    
+
     /* ensure all transfers are cancelled */
     _usb_device_cancel_transfer(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
     _usb_device_cancel_transfer(handle, pDiskCtrl->inEpNo,  ARC_USB_SEND);
@@ -2271,13 +2271,13 @@ void    usbDiskUnload(_usb_device_handle
     _usb_device_stop(handle);
 
     /* Deregister all services */
-    _usb_device_unregister_service(handle, ARC_USB_SERVICE_EP0);   
-    _usb_device_unregister_service(handle, ARC_USB_SERVICE_BUS_RESET);   
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_EP0);
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_BUS_RESET);
     _usb_device_unregister_service(handle, ARC_USB_SERVICE_SPEED_DETECTION);
-    _usb_device_unregister_service(handle, pDiskCtrl->outEpNo);   
+    _usb_device_unregister_service(handle, pDiskCtrl->outEpNo);
     if(pDiskCtrl->outEpNo != pDiskCtrl->inEpNo)
     {
-        _usb_device_unregister_service(handle, pDiskCtrl->inEpNo);   
+        _usb_device_unregister_service(handle, pDiskCtrl->inEpNo);
     }
 
     _usb_device_shutdown(handle);
--- a/arch/arm/plat-armada/mv_hal/usb/examples/disk.h
+++ b/arch/arm/plat-armada/mv_hal/usb/examples/disk.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -66,8 +66,8 @@ typedef struct mass_storage_read_capacit
 typedef struct mass_storage_device_info {
    uint_8   PERIPHERAL_DEVICE_TYPE;    /* Bits 0-4. All other bits reserved */
    uint_8   RMB;                       /* Bit 7. All other bits reserved */
-   uint_8   ANSI_ECMA_ISO_VERSION;     /* ANSI: bits 0-2, ECMA: bits 3-5, 
-                                       ** ISO: bits 6-7 
+   uint_8   ANSI_ECMA_ISO_VERSION;     /* ANSI: bits 0-2, ECMA: bits 3-5,
+                                       ** ISO: bits 6-7
                                        */
    uint_8   RESPONSE_DATA_FORMAT;      /* bits 0-3. All other bits reserved */
    uint_8   ADDITIONAL_LENGTH;         /* For UFI device: always set to 0x1F */
--- a/arch/arm/plat-armada/mv_hal/usb/examples/mouse.c
+++ b/arch/arm/plat-armada/mv_hal/usb/examples/mouse.c
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
@@ -43,7 +43,7 @@ global variables and some defines for de
 
 /**************************************************************************
 Include the OS and BSP dependent files that define IO functions and
-basic types. You may like to change these files for your board and RTOS 
+basic types. You may like to change these files for your board and RTOS
 **************************************************************************/
 
 int frame_interval = FRAME_INTERVAL;
@@ -70,55 +70,55 @@ static SETUP_STRUCT   local_setup_packet
 
 
 /*************************************************************************
-Device descriptors are always 18 bytes 
+Device descriptors are always 18 bytes
 
-Offset|       Field        | Value |  Description  
+Offset|       Field        | Value |  Description
 ------|--------------------|-------|--------------------
-  0   |      bLength       |  0x12 |The size of this 
+  0   |      bLength       |  0x12 |The size of this
       |                    |       |descriptor is 18 bytes
 ------|--------------------|-------|--------------------
   1   |  bDescriptorType   |  0x01 |DEVICE Descriptor Type
 ------|--------------------|-------|--------------------
-  2   |       bcdUSB       | 0x0100|Device compliant to 
-      |                    |       |the USB 
-      |                    |       |specification 
-      |                    |       |version 1.00   
+  2   |       bcdUSB       | 0x0100|Device compliant to
+      |                    |       |the USB
+      |                    |       |specification
+      |                    |       |version 1.00
 ------|--------------------|-------|--------------------
-  4   |    bDeviceClass    |  0x00 |Each interface 
-      |                    |       |specifies its own 
+  4   |    bDeviceClass    |  0x00 |Each interface
+      |                    |       |specifies its own
       |                    |       |class information
 ------|--------------------|-------|--------------------
-  5   |  bDeviceSubClass   |  0x00 |Each interface 
-      |                    |       |specifies its own 
+  5   |  bDeviceSubClass   |  0x00 |Each interface
+      |                    |       |specifies its own
       |                    |       |subclass information
 ------|--------------------|-------|--------------------
-  6   |  bDeviceProtocol   |  0x00 |No protocols on the 
+  6   |  bDeviceProtocol   |  0x00 |No protocols on the
       |                    |       |device basis
 ------|--------------------|-------|--------------------
-  7   |  bMaxPacketSize0   |  0x08 |Maximum packet size 
+  7   |  bMaxPacketSize0   |  0x08 |Maximum packet size
       |                    |       |for endpoint zero is 8
 ------|--------------------|-------|--------------------
-  8   |      idVendor      | 0x0261|Vendor ID is 609: 
-      |                    |       
+  8   |      idVendor      | 0x0261|Vendor ID is 609:
+      |                    |
 ------|--------------------|-------|--------------------
   10  |     idProduct      | 0x4D03|The Product ID is 0x4D03
 ------|--------------------|-------|--------------------
-  12  |     bcdDevice      | 0x0441|The device release 
+  12  |     bcdDevice      | 0x0441|The device release
       |                    |       |number is 4.41
 ------|--------------------|-------|--------------------
-  14  |   iManufacturer    |  0x00 |The device doesn't 
-      |                    |       |have the string 
-      |                    |       |descriptor 
+  14  |   iManufacturer    |  0x00 |The device doesn't
+      |                    |       |have the string
+      |                    |       |descriptor
       |                    |       |describing the manufacturer
 ------|--------------------|-------|--------------------
-  15  |      iProduct      |  0x00 |The device doesn't 
-      |                    |       |have the string 
-      |                    |       |descriptor 
+  15  |      iProduct      |  0x00 |The device doesn't
+      |                    |       |have the string
+      |                    |       |descriptor
       |                    |       |describing the product
 ------|--------------------|-------|--------------------
-  16  |   iSerialNumber    |  0x00 | 
+  16  |   iSerialNumber    |  0x00 |
 ------|--------------------|-------|--------------------
-  17  | bNumConfigurations |  0x01 | 
+  17  | bNumConfigurations |  0x01 |
 ------|--------------------|-------|--------------------
 *************************************************************************/
 #define DEVICE_DESCRIPTOR_SIZE 18
@@ -128,7 +128,7 @@ static uint_8  DevDescData[DEVICE_DESCRI
    DEVICE_DESCRIPTOR_SIZE,
    0x01,
    0x0,2,
-   
+
    0x00,
    0x00,
    0x00,
@@ -144,7 +144,7 @@ static uint_8  DevDescData[DEVICE_DESCRI
    0x02,                      /* iProduct */
    0x00,                      /* iSerialNumber */
    0x01                       /* bNumConfigurations */
-   
+
 };
 
 /* USB 2.0 specific descriptor */
@@ -172,133 +172,133 @@ Data stage (34 bytes) :
 
        CONFIGURATION Descriptor
        ------------------------
-Offset|        Field        | Value |  Description  
+Offset|        Field        | Value |  Description
 ------|---------------------|-------|--------------------
-  0   |       bLength       |  0x09 |The size of this 
+  0   |       bLength       |  0x09 |The size of this
       |                     |       |descriptor is 9 bytes
 ------|---------------------|-------|--------------------
-  1   |   bDescriptorType   |  0x02 |CONFIGURATION 
+  1   |   bDescriptorType   |  0x02 |CONFIGURATION
       |                     |       |Descriptor Type
 ------|---------------------|-------|--------------------
-  2   |    wTotalLength     | 0x0022|The total length of 
-      |                     |       |data for this 
-      |                     |       |configuration is 34. 
-      |                     |       |This includes the 
-      |                     |       |combined length of 
+  2   |    wTotalLength     | 0x0022|The total length of
+      |                     |       |data for this
+      |                     |       |configuration is 34.
+      |                     |       |This includes the
+      |                     |       |combined length of
       |                     |       |all the descriptors returned
 ------|---------------------|-------|--------------------
-  4   |   bNumInterfaces    |  0x01 |This configuration 
+  4   |   bNumInterfaces    |  0x01 |This configuration
       |                     |       |supports 1 interfaces
 ------|---------------------|-------|--------------------
-  5   | bConfigurationValue |  0x01 |The value 1 should 
-      |                     |       |be used to select 
+  5   | bConfigurationValue |  0x01 |The value 1 should
+      |                     |       |be used to select
       |                     |       |this configuration
 ------|---------------------|-------|--------------------
-  6   |   iConfiguration    |  0x00 |The device doesn't 
-      |                     |       |have the string 
-      |                     |       |descriptor 
+  6   |   iConfiguration    |  0x00 |The device doesn't
+      |                     |       |have the string
+      |                     |       |descriptor
       |                     |       |describing this configuration
 ------|---------------------|-------|--------------------
   7   |    bmAttributes     |  0x80 |Configuration characteristics :
-      |                     |       |Bit 7: Reserved (set to one) 1 
-      |                     |       |Bit 6: Self-powered          0 
-      |                     |       |Bit 5: Remote Wakeup         1 
+      |                     |       |Bit 7: Reserved (set to one) 1
+      |                     |       |Bit 6: Self-powered          0
+      |                     |       |Bit 5: Remote Wakeup         1
 ------|---------------------|-------|--------------------
-  8   |      MaxPower       |  0x32 |Maximum power 
-      |                     |       |consumption of the 
-      |                     |       |device in this 
+  8   |      MaxPower       |  0x32 |Maximum power
+      |                     |       |consumption of the
+      |                     |       |device in this
       |                     |       |configuration is 100 mA
 ------|---------------------|-------|--------------------
 
        INTERFACE Descriptor
        --------------------
-Offset|       Field        | Value |  Description  
+Offset|       Field        | Value |  Description
 ------|--------------------|-------|--------------------
-  0   |      bLength       |  0x09 |The size of this 
+  0   |      bLength       |  0x09 |The size of this
       |                    |       |descriptor is 9 bytes
 ------|--------------------|-------|--------------------
   1   |  bDescriptorType   |  0x04 |INTERFACE Descriptor Type
 ------|--------------------|-------|--------------------
-  2   |  bInterfaceNumber  |  0x00 |The number of this 
+  2   |  bInterfaceNumber  |  0x00 |The number of this
       |                    |       |interface is 0
 ------|--------------------|-------|--------------------
-  3   | bAlternateSetting  |  0x00 |The value used to 
-      |                    |       |select alternate 
-      |                    |       |setting for this 
+  3   | bAlternateSetting  |  0x00 |The value used to
+      |                    |       |select alternate
+      |                    |       |setting for this
       |                    |       |interface is 0
 ------|--------------------|-------|--------------------
-  4   |   bNumEndpoints    |  0x01 |The number of 
-      |                    |       |endpoints used by 
-      |                    |       |this interface is 1 
+  4   |   bNumEndpoints    |  0x01 |The number of
+      |                    |       |endpoints used by
+      |                    |       |this interface is 1
       |                    |       |(excluding endpoint zero)
 ------|--------------------|-------|--------------------
-  5   |  bInterfaceClass   |  0x03 |The interface 
+  5   |  bInterfaceClass   |  0x03 |The interface
       |                    |       |implements HID class
 ------|--------------------|-------|--------------------
   6   | bInterfaceSubClass |  0x01 |The subclass code is 0x01
 ------|--------------------|-------|--------------------
   7   | bInterfaceProtocol |  0x02 |The protocol code is 0x02
 ------|--------------------|-------|--------------------
-  8   |     iInterface     |  0x00 |The device doesn't 
-      |                    |       |have the string 
-      |                    |       |descriptor 
+  8   |     iInterface     |  0x00 |The device doesn't
+      |                    |       |have the string
+      |                    |       |descriptor
       |                    |       |describing this interface
 ------|--------------------|-------|--------------------
 
        HID Descriptor
        --------------
-Offset|       Field       | Value |  Description  
+Offset|       Field       | Value |  Description
 ------|-------------------|-------|--------------------
-  0   |      bLength      |  0x09 |The size of this 
+  0   |      bLength      |  0x09 |The size of this
       |                   |       |descriptor is 9 bytes
 ------|-------------------|-------|--------------------
   1   |  bDescriptorType  |  0x21 |HID Descriptor Type
 ------|-------------------|-------|--------------------
-  2   |      bcdHID       | 0x0100|Device compliant to 
-      |                   |       |the HID 
-      |                   |       |specification 
-      |                   |       |version 1.00   
+  2   |      bcdHID       | 0x0100|Device compliant to
+      |                   |       |the HID
+      |                   |       |specification
+      |                   |       |version 1.00
 ------|-------------------|-------|--------------------
   4   |   bCountryCode    |  0x00 |The country code is 0x00
 ------|-------------------|-------|--------------------
-  5   |  bNumDescriptors  |  0x01 |The number of class 
+  5   |  bNumDescriptors  |  0x01 |The number of class
       |                   |       |descriptors is 1
 ------|-------------------|-------|--------------------
-  6   |  bDescriptorType  |  0x22 |The class descriptor 
+  6   |  bDescriptorType  |  0x22 |The class descriptor
       |                   |       |is Report descriptor
 ------|-------------------|-------|--------------------
-  7   | wDescriptorlength | 0x0034|The total size of 
-      |                   |       |the class descriptor 
+  7   | wDescriptorlength | 0x0034|The total size of
+      |                   |       |the class descriptor
       |                   |       |is 52
 ------|-------------------|-------|--------------------
 
        ENDPOINT Descriptor
        -------------------
-Offset|      Field       | Value |  Description  
+Offset|      Field       | Value |  Description
 ------|------------------|-------|--------------------
-  0   |     bLength      |  0x07 |The size of this 
+  0   |     bLength      |  0x07 |The size of this
       |                  |       |descriptor is 7 bytes
 ------|------------------|-------|--------------------
   1   | bDescriptorType  |  0x05 |ENDPOINT Descriptor Type
 ------|------------------|-------|--------------------
-  2   | bEndpointAddress |  0x81 |This is an IN 
-      |                  |       |endpoint with 
-      |                  |       |address (endpoint 
+  2   | bEndpointAddress |  0x81 |This is an IN
+      |                  |       |endpoint with
+      |                  |       |address (endpoint
       |                  |       |number) 1
 ------|------------------|-------|--------------------
-  3   |   bmAttributes   |  0x03 |Types - 
-      |                  |       |Transfer:INTERRUPT 
-      |                  |       |Sync:No Sync 
+  3   |   bmAttributes   |  0x03 |Types -
+      |                  |       |Transfer:INTERRUPT
+      |                  |       |Sync:No Sync
       |                  |       |Usage:Data EP
 ------|------------------|-------|--------------------
-  4   |  wMaxPacketSize  | 0x0004|Maximum packet size 
-      |                  |       |value for this 
-      |                  |       |endpoint is 0x4 
+  4   |  wMaxPacketSize  | 0x0004|Maximum packet size
+      |                  |       |value for this
+      |                  |       |endpoint is 0x4
       |                  |       |(Bits 12-11: Addtl. Transactions/frame)
 ------|------------------|-------|--------------------
-  6   |    bInterval     |  0x0A |bInterval:10. The 
-      |                  |       |polling interval 
-      |                  |       |value is bInterval 
+  6   |    bInterval     |  0x0A |bInterval:10. The
+      |                  |       |polling interval
+      |                  |       |value is bInterval
       |                  |       |or 2**(bInterval-1)
 ------|------------------|-------|--------------------
 
@@ -325,7 +325,7 @@ static uint_8 ConfigDescData[CONFIG_DESC
    0x00,
    0xE0, /* 0x80, */
    0x0,
-   /* Interface Descriptor */	
+   /* Interface Descriptor */
    0x09,
    0x04,
    0x00,
@@ -346,13 +346,13 @@ static uint_8 ConfigDescData[CONFIG_DESC
    0x22,
    USB_uint_16_low(0x0034),
    USB_uint_16_high(0x0034),
- 
+
    /*Endpoint descriptor */
    0x07,
    0x05,
    (0x80+INTERRUPT_EP),
    0x03,
-   USB_uint_16_low(INTERRUPT_MAX_PACKET_SIZE), 
+   USB_uint_16_low(INTERRUPT_MAX_PACKET_SIZE),
    USB_uint_16_high(INTERRUPT_MAX_PACKET_SIZE),
    FRAME_INTERVAL
 };
@@ -371,7 +371,7 @@ static uint_8  other_speed_config_data[C
    0x00,
    0xE0, /* 0x80, */
    0x0,
-   /* Interface Descriptor */	
+   /* Interface Descriptor */
    0x09,
    0x04,
    0x00,
@@ -392,13 +392,13 @@ static uint_8  other_speed_config_data[C
    0x22,
    USB_uint_16_low(0x0034),
    USB_uint_16_high(0x0034),
- 
+
    /*Endpoint descriptor */
    0x07,
    0x05,
    (0x80+INTERRUPT_EP),
    0x03,
-   USB_uint_16_low(INTERRUPT_MAX_PACKET_SIZE), 
+   USB_uint_16_low(INTERRUPT_MAX_PACKET_SIZE),
    USB_uint_16_high(INTERRUPT_MAX_PACKET_SIZE),
    FRAME_INTERVAL
 
@@ -409,33 +409,33 @@ HID Class Report Descriptor :
 
 Item						Value(Hex)
 ------------------------------------------------------------------------------------------------------------
-Usage Page (Generic Desktop Control)			05 01 
-Usage (Mouse)					09 02 
-Collection (Application)				A1 01 
-  Usage (Pointer)					09 01 
-  Collection (Physical)				A1 00 
-    Usage Page (Button)				05 09 
-    Usage Minimum (1)				19 01 
-    Usage Maximum (3)				29 03 
-    Logical Minimum (0)				15 00 
-    Logical Maximum (1)				25 01 
-    Report Count (3)					95 03 
-    Report Size (1)					75 01 
-    Input (Data, Variable, Absolute)			81 02 
-    Report Count (1)					95 01 
-    Report Size (5)					75 05 
-    Input (Constant)					81 01 
-    Usage Page (Generic Desktop Control)		05 01 
-    Usage (X)					09 30 
-    Usage (Y)					09 31 
-    Usage (Wheel)					09 38 
-    Logical Minimum (-127)				15 81 
-    Logical Maximum (127)				25 7F 
-    Report Size (8)					75 08 
-    Report Count (3)					95 03 
-    Input (Data, Variable, Relative)			81 06 
-  End Collection					C0 
-End Collection					C0 
+Usage Page (Generic Desktop Control)			05 01
+Usage (Mouse)					09 02
+Collection (Application)				A1 01
+  Usage (Pointer)					09 01
+  Collection (Physical)				A1 00
+    Usage Page (Button)				05 09
+    Usage Minimum (1)				19 01
+    Usage Maximum (3)				29 03
+    Logical Minimum (0)				15 00
+    Logical Maximum (1)				25 01
+    Report Count (3)					95 03
+    Report Size (1)					75 01
+    Input (Data, Variable, Absolute)			81 02
+    Report Count (1)					95 01
+    Report Size (5)					75 05
+    Input (Constant)					81 01
+    Usage Page (Generic Desktop Control)		05 01
+    Usage (X)					09 30
+    Usage (Y)					09 31
+    Usage (Wheel)					09 38
+    Logical Minimum (-127)				15 81
+    Logical Maximum (127)				25 7F
+    Report Size (8)					75 08
+    Report Count (3)					95 03
+    Input (Data, Variable, Relative)			81 06
+  End Collection					C0
+End Collection					C0
 
 
 ************************************************************************/
@@ -453,7 +453,7 @@ static uint_8 ReportDescData[REPORT_DESC
    0x01,
    0x09,
    0x01,
-   
+
    0xA1,
    0x00,
    0x05,
@@ -462,7 +462,7 @@ static uint_8 ReportDescData[REPORT_DESC
    0x01,
    0x29,
    0x03,
-   
+
    0x15,
    0x00,
    0x25,
@@ -471,7 +471,7 @@ static uint_8 ReportDescData[REPORT_DESC
    0x03,
    0x75,
    0x01,
-   
+
    0x81,
    0x02,
    0x95,
@@ -480,7 +480,7 @@ static uint_8 ReportDescData[REPORT_DESC
    0x05,
    0x81,
    0x01,
-   
+
    0x05,
    0x01,
    0x09,
@@ -489,7 +489,7 @@ static uint_8 ReportDescData[REPORT_DESC
    0x31,
    0x09,
    0x38,
-   
+
    0x15,
    0x81,
    0x25,
@@ -498,11 +498,11 @@ static uint_8 ReportDescData[REPORT_DESC
    0x08,
    0x95,
    0x03,
-   
+
    0x81,
    0x06,
    0xC0,
-   0xC0   
+   0xC0
 };
 
 /**************************************************************
@@ -513,7 +513,7 @@ The following lines should be changed,
 
 USB_uint_16_low(0x0038),  //   Changed from USB_uint_16_low(0x0034),
 USB_uint_16_high(0x0038), //   Changed from USB_uint_16_high(0x0034),
-  
+
 
 
 
@@ -523,34 +523,34 @@ uint_8  ReportDesc[56] = {
     0xa1, 0x01,                    		// COLLECTION (Application)
 
     0x09, 0x02,                    		//   USAGE (Vendor Usage 2)
-    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)																			
-    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127) 																			
-    0x95, 0x01,                    		//   REPORT_COUNT (1)      																			
-    0x75, 0x08,                    		//   REPORT_SIZE (8)       																			
-    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)																			
-
-    0x09, 0x03,                    		//   USAGE (Vendor Usage 3)																			
-    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)																			
-    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127) 																			
-    0x95, 0x01,                    		//   REPORT_COUNT (1)      																			
+    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)
+    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127)
+    0x95, 0x01,                    		//   REPORT_COUNT (1)
+    0x75, 0x08,                    		//   REPORT_SIZE (8)
+    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)
+
+    0x09, 0x03,                    		//   USAGE (Vendor Usage 3)
+    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)
+    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127)
+    0x95, 0x01,                    		//   REPORT_COUNT (1)
     0x75, 0x08,                    		//   REPORT_SIZE (8)
-    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)																			
+    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)
 
-    0x09, 0x04,                    		//   USAGE (Vendor Usage 4)																			
-    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)																			
-    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127) 																			
-    0x95, 0x01,                    		//   REPORT_COUNT (1)      																			
+    0x09, 0x04,                    		//   USAGE (Vendor Usage 4)
+    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)
+    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127)
+    0x95, 0x01,                    		//   REPORT_COUNT (1)
     0x75, 0x08,                    		//   REPORT_SIZE (8)
-    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)																			
+    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)
 
-    0x09, 0x05,                    		//   USAGE (Vendor Usage 5)																			
-    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)																			
-    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127) 																			
-    0x95, 0x01,                    		//   REPORT_COUNT (1)      																			
+    0x09, 0x05,                    		//   USAGE (Vendor Usage 5)
+    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)
+    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127)
+    0x95, 0x01,                    		//   REPORT_COUNT (1)
     0x75, 0x08,                    		//   REPORT_SIZE (8)
-    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)																			
-        
-    0xc0                           		// END_COLLECTION          																			
+    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)
+
+    0xc0                           		// END_COLLECTION
 };
 ***************************************************************/
 
@@ -573,13 +573,13 @@ static uint_8 USB_IF_ALT[4] = { 0, 0, 0,
 static const uint_8 USB_STR_NUM  = 6;
 
 /*
-** if the number of strings changes, look for USB_STR_0 everywhere and make 
+** if the number of strings changes, look for USB_STR_0 everywhere and make
 ** the obvious changes.  It should be found in 3 places.
 */
 
 static const uint_16 USB_STR_0[ 2] = {0x0300 + sizeof(USB_STR_0),0x0409};
 static const uint_16 USB_STR_1[26] = {0x0300 + sizeof(USB_STR_1),
-      'M','a','r','v','e','l','l',' ','S','e','m','i','c','o','n','d','u','c','t','o','r',' ','L','t','d'};       
+      'M','a','r','v','e','l','l',' ','S','e','m','i','c','o','n','d','u','c','t','o','r',' ','L','t','d'};
 static const uint_16 USB_STR_2[28] = {0x0300 + sizeof(USB_STR_2),
       'M','A','R','V','E','L','L',' ','U','S','B',' ','h','i','d','m','o','u','s','e',' ',\
       'D','e','v','i','c','e'};
@@ -609,7 +609,7 @@ static const uint_8_ptr USB_STRING_DESC[
 
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9GetDescription
 * Returned Value : None
 * Comments       :
@@ -619,16 +619,16 @@ static const uint_8_ptr USB_STRING_DESC[
 *     requested descriptor.
 *     And then wait for the OUT which terminates the control transfer.
 *     See section 9.4.3 (page 189) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9GetDescription
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
@@ -647,7 +647,7 @@ static void ch9GetDescription
              *(ConfigDesc + 33) = frame_interval;
             _usb_device_send_data(handle, 0, ConfigDesc,
                MIN(setup_ptr->LENGTH, CONFIG_DESC_SIZE));
-                           
+
             break;
 
          case 0x2200:
@@ -657,9 +657,9 @@ static void ch9GetDescription
          /*send some data for the mouse in the interrupt pipe queue */
          _usb_device_send_data(handle, INTERRUPT_EP, (uint_8_ptr)((pointer)&mouse_data),
                                 sizeof(MOUSE_DATA_STRUCT));
-               
-            break;      
-   
+
+            break;
+
          case 0x0300:
             if ((setup_ptr->VALUE & 0x00FF) > USB_STR_NUM) {
                _usb_device_send_data(handle, 0, USB_STRING_DESC[USB_STR_NUM+1],
@@ -668,24 +668,24 @@ static void ch9GetDescription
                _usb_device_send_data(handle, 0,
                   USB_STRING_DESC[setup_ptr->VALUE & 0x00FF],
                   MIN(setup_ptr->LENGTH, USB_STRING_DESC[setup_ptr->VALUE & 0x00FF][0]));
-            } /* Endif */      
+            } /* Endif */
             break;
 
          case 0x600:
-            _usb_device_send_data(handle, 0, (uint_8_ptr)DevQualifierDesc, 
+            _usb_device_send_data(handle, 0, (uint_8_ptr)DevQualifierDesc,
                MIN(setup_ptr->LENGTH, DEVICE_QUALIFIER_DESCRIPTOR_SIZE));
             break;
-            
-         case 0x700:      
+
+         case 0x700:
             *(other_speed_config + 33) = frame_interval;
 
-            _usb_device_send_data(handle, 0, (uint_8_ptr)other_speed_config, 
+            _usb_device_send_data(handle, 0, (uint_8_ptr)other_speed_config,
                MIN(setup_ptr->LENGTH, OTHER_SPEED_CONFIG_DESC_SIZE));
             break;
-        
+
          default:
-            USB_printf("usbMouse_%d, %s: Unexpected VALUE=0x%04x\n", 
-                _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);                
+            USB_printf("usbMouse_%d, %s: Unexpected VALUE=0x%04x\n",
+                _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);
             _usb_device_stall_endpoint(handle, 0, 0);
             return;
       } /* Endswitch */
@@ -696,59 +696,59 @@ static void ch9GetDescription
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SetDescription
 * Returned Value : None
 * Comments       :
 *     Chapter 9 SetDescription command
 *     See section 9.4.8 (page 193) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9SetDescription
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
-    USB_printf("usbMouse_%d, %s: setup=%d\n", 
+    USB_printf("usbMouse_%d, %s: setup=%d\n",
             _usb_device_get_dev_num(handle), __FUNCTION__, (int)setup);
    _usb_device_stall_endpoint(handle, 0, 0);
    return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9GetConfig
 * Returned Value : None
 * Comments       :
 *     Chapter 9 GetConfig command
 *     See section 9.4.2 (page 189) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9GetConfig
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
    uint_16 current_config;
    /* Return the currently selected configuration */
-   if (setup){ 
+   if (setup){
       _usb_device_get_status(handle, ARC_USB_STATUS_CURRENT_CONFIG,
          &current_config);
-      data_to_send = (uint_8)current_config;      
+      data_to_send = (uint_8)current_config;
       _usb_device_send_data(handle, 0, (pointer) &data_to_send, sizeof(data_to_send));
       /* status phase */
       _usb_device_recv_data(handle, 0, 0, 0);
@@ -757,55 +757,55 @@ static void ch9GetConfig
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SetConfig
 * Returned Value : None
 * Comments       :
 *     Chapter 9 SetConfig command
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9SetConfig
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
     uint_16 usb_state;
-   
-    if (setup) 
+
+    if (setup)
     {
-        if ((setup_ptr->VALUE & 0x00FF) > 1) 
+        if ((setup_ptr->VALUE & 0x00FF) > 1)
         {
             /* generate stall */
-            USB_printf("usbMouse_%d, %s: Wrong VALUE=0x%04x\n", 
+            USB_printf("usbMouse_%d, %s: Wrong VALUE=0x%04x\n",
                     _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);
             _usb_device_stall_endpoint(handle, 0, 0);
             return;
         } /* Endif */
 
         /* 0 indicates return to unconfigured state */
-        if ((setup_ptr->VALUE & 0x00FF) == 0) 
+        if ((setup_ptr->VALUE & 0x00FF) == 0)
         {
             _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_state);
-            if ((usb_state == ARC_USB_STATE_CONFIG) || 
-                (usb_state == ARC_USB_STATE_ADDRESS)) 
+            if ((usb_state == ARC_USB_STATE_CONFIG) ||
+                (usb_state == ARC_USB_STATE_ADDRESS))
             {
                 /* clear the currently selected config value */
                 _usb_device_set_status(handle, ARC_USB_STATUS_CURRENT_CONFIG, 0);
                 _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE,
                                                         ARC_USB_STATE_ADDRESS);
-                /* status phase */      
+                /* status phase */
                 _usb_device_send_data(handle, 0, 0, 0);
-            } 
-            else 
+            }
+            else
             {
-                USB_printf("usbMouse_%d, %s: Wrong usb_state=%d\n", 
+                USB_printf("usbMouse_%d, %s: Wrong usb_state=%d\n",
                         _usb_device_get_dev_num(handle), __FUNCTION__, usb_state);
 
                 _usb_device_stall_endpoint(handle, 0, 0);
@@ -819,14 +819,14 @@ static void ch9SetConfig
         ** reconfigured to match the new device configuration
         */
         _usb_device_get_status(handle, ARC_USB_STATUS_CURRENT_CONFIG, &usb_state);
-        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, 
-                        "usbMouse: Set configuration: old=%d, new=%d\n", 
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP,
+                        "usbMouse: Set configuration: old=%d, new=%d\n",
                         usb_state, setup_ptr->VALUE & 0x00FF);
 
-        if (usb_state != (setup_ptr->VALUE & 0x00FF)) 
+        if (usb_state != (setup_ptr->VALUE & 0x00FF))
         {
             /* Reconfigure endpoints here */
-            switch (setup_ptr->VALUE & 0x00FF) 
+            switch (setup_ptr->VALUE & 0x00FF)
             {
                 default:
                 break;
@@ -835,8 +835,8 @@ static void ch9SetConfig
                                 setup_ptr->VALUE & 0x00FF);
         } /* Endif */
         /* Init Interrupt endpoint */
-        _usb_device_init_endpoint(handle,INTERRUPT_EP, INTERRUPT_MAX_PACKET_SIZE, 
-                                   ARC_USB_SEND, ARC_USB_INTERRUPT_ENDPOINT, 
+        _usb_device_init_endpoint(handle,INTERRUPT_EP, INTERRUPT_MAX_PACKET_SIZE,
+                                   ARC_USB_SEND, ARC_USB_INTERRUPT_ENDPOINT,
                                    ARC_USB_DEVICE_DONT_ZERO_TERMINATE);
 
         TEST_ENABLED = TRUE;
@@ -850,74 +850,74 @@ static void ch9SetConfig
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9GetInterface
 * Returned Value : None
 * Comments       :
 *     Chapter 9 GetInterface command
 *     See section 9.4.4 (page 190) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9GetInterface
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
     uint_16 usb_state;
-   
+
     _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_state);
-    if (usb_state != ARC_USB_STATE_CONFIG) 
+    if (usb_state != ARC_USB_STATE_CONFIG)
     {
-        USB_printf("usbMouse_%d, %s: Wrong usb_state=%d\n", 
+        USB_printf("usbMouse_%d, %s: Wrong usb_state=%d\n",
                     _usb_device_get_dev_num(handle), __FUNCTION__, usb_state);
         _usb_device_stall_endpoint(handle, 0, 0);
         return;
     } /* Endif */
 
-    if (setup) 
+    if (setup)
     {
         _usb_device_send_data(handle, 0, &USB_IF_ALT[setup_ptr->INDEX & 0x00FF],
                                 MIN(setup_ptr->LENGTH, sizeof(uint_8)));
-        /* status phase */      
+        /* status phase */
         _usb_device_recv_data(handle, 0, 0, 0);
     } /* Endif */
     return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SetInterface
 * Returned Value : None
 * Comments       :
 *     Chapter 9 SetInterface command
 *     See section 9.4.10 (page 195) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9SetInterface
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
-    if (setup) 
+    if (setup)
     {
-        if (setup_ptr->REQUESTTYPE != 0x01) 
+        if (setup_ptr->REQUESTTYPE != 0x01)
         {
-            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n", 
-                        _usb_device_get_dev_num(handle), __FUNCTION__, 
+            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__,
                         setup_ptr->REQUESTTYPE);
 
             _usb_device_stall_endpoint(handle, 0, 0);
@@ -934,7 +934,7 @@ static void ch9SetInterface
         {
             USB_IF_ALT[setup_ptr->INDEX & 0x00FF] = (setup_ptr->VALUE & 0x00FF);
             /* Reconfigure endpoints here. */
-         
+
         } /* Endif */
 
         /* status phase */
@@ -944,33 +944,33 @@ static void ch9SetInterface
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9SynchFrame
-* Returned Value : 
+* Returned Value :
 * Comments       :
 *     Chapter 9 SynchFrame command
 *     See section 9.4.11 (page 195) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9SynchFrame
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-            
+
       /* The setup packet pointer */
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
-   
-    if (setup) 
+
+    if (setup)
     {
-        if (setup_ptr->REQUESTTYPE != 0x02) 
+        if (setup_ptr->REQUESTTYPE != 0x02)
         {
-            USB_printf("usbMouse_%d, %s: Wrong REQUESTTYPE=0x%02x\n", 
-                        _usb_device_get_dev_num(handle), __FUNCTION__, 
+            USB_printf("usbMouse_%d, %s: Wrong REQUESTTYPE=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__,
                         setup_ptr->REQUESTTYPE);
             _usb_device_stall_endpoint(handle, 0, 0);
             return;
@@ -979,7 +979,7 @@ static void ch9SynchFrame
         if ((setup_ptr->INDEX & 0x00FF) >=
                 ConfigDesc[CONFIG_DESC_NUM_INTERFACES])
         {
-            USB_printf("usbMouse_%d, %s: Wrong INDEX=0x%04x\n", 
+            USB_printf("usbMouse_%d, %s: Wrong INDEX=0x%04x\n",
                         _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->INDEX);
             _usb_device_stall_endpoint(handle, 0, 0);
             return;
@@ -990,41 +990,41 @@ static void ch9SynchFrame
         sof_count = USB_16BIT_LE(sof_count);
         _usb_device_send_data(handle, 0, (uint_8_ptr)&sof_count,
                         MIN(setup_ptr->LENGTH, sizeof(sof_count)));
-        /* status phase */      
+        /* status phase */
         _usb_device_recv_data(handle, 0, 0, 0);
     } /* Endif */
     return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : get_report
-* Returned Value : 
+* Returned Value :
 * Comments       :
 *     Chapter 9 Class specific request
 *     See section 9.4.11 (page 195) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 
 void get_report
 	(
 	/* USB handle */
 	_usb_device_handle handle,
-	
+
 	/* Is it a Setup phase? */
 	boolean     setup,
-   
+
    /* [IN] Direction of the transfer. (1 for USB IN token)*/
    uint_8      direction,
-	
+
 	/* The setup packet pointer */
 	SETUP_STRUCT_PTR setup_ptr
 
 	)
-{ 
+{
     int i;
-      
-   for(i=0;i<10;i++)	
+
+   for(i=0;i<10;i++)
 	{
 		hid_test_rep_data[i] = (uint_8) i;
 	}
@@ -1033,43 +1033,43 @@ void get_report
 	{
 		_usb_device_send_data(handle, 0, (uint_8_ptr)hid_test_rep_data, MIN(setup_ptr->LENGTH,4));
 	}
-         
+
    _usb_device_recv_data(handle, 0, 0, 0);
-         
+
 
 	return;
-} 
+}
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : set_report
-* Returned Value : 
+* Returned Value :
 * Comments       :
 *     Chapter 9 Class specific request
 *     See section 9.4.11 (page 195) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 
 void set_report
 	(
 	/* USB handle */
 	_usb_device_handle handle,
-	
+
 	/* Is it a Setup phase? */
 	boolean setup,
-   
+
    /* [IN] Direction of the transfer. (1 for USB IN token)*/
    uint_8               direction,
 
-	
+
 	/* The setup packet pointer */
 	SETUP_STRUCT_PTR setup_ptr
 	)
-{ 
+{
 	if (setup)      /*on a SetUP packet*/
    {
 	  _usb_device_recv_data(handle, 0, (uint_8_ptr)hid_test_rep_data, MIN(setup_ptr->LENGTH,4));
- 
+
 	}
    else if(direction == ARC_USB_RECV)   /*on a OUT packet*/
    {
@@ -1078,60 +1078,60 @@ void set_report
    }
 
 	return;
-} 
+}
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : set_idle
-* Returned Value : 
+* Returned Value :
 * Comments       :
 *     Chapter 9 Class specific request
 *     See section 9.4.11 (page 195) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 
 void set_idle
 	(
 	/* USB handle */
 	_usb_device_handle handle,
-	
+
 	/* Is it a Setup phase? */
 	boolean setup,
-   
+
    /* [IN] Direction of the transfer. (1 for USB IN token)*/
    uint_8               direction,
 
-	
+
 	/* The setup packet pointer */
 	SETUP_STRUCT_PTR setup_ptr
 	)
-{ 
+{
    /* SET_IDLE is a No data phase transaction from HID class. All it needs
    is a terminating IN token */
 	if (setup)      /*on a SetUP packet*/
    {
-	  _usb_device_send_data(handle, 0, 0, 0);  
+	  _usb_device_send_data(handle, 0, 0, 0);
 	}
 	return;
-} 
+}
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : ch9Class
-* Returned Value : 
+* Returned Value :
 * Comments       :
 *     Chapter 9 Class specific request
 *     See section 9.4.11 (page 195) of the USB 1.1 Specification.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void ch9Class
    (
       /* USB handle */
       _usb_device_handle handle,
-      
+
       /* Is it a Setup phase? */
       boolean setup,
-      
+
       /* [IN] Direction of the transfer. (1 for USB IN token)*/
       uint_8               direction,
 
@@ -1139,14 +1139,14 @@ static void ch9Class
       SETUP_STRUCT_PTR setup_ptr
    )
 { /* Body */
-   
-   switch (setup_ptr->REQUEST) 
+
+   switch (setup_ptr->REQUEST)
    {
-   
+
       case 0x01:
          get_report(handle, setup, direction, setup_ptr);
          break;
-      
+
       case 0x09:
          set_report(handle, setup, direction, setup_ptr);
          break;
@@ -1154,9 +1154,9 @@ static void ch9Class
       case 0x0A:
          set_idle(handle, setup, direction, setup_ptr);
          break;
-     
+
       default:
-        USB_printf("usbMouse_%d, %s: Wrong REQUEST=0x%02x\n", 
+        USB_printf("usbMouse_%d, %s: Wrong REQUEST=0x%02x\n",
               _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->REQUEST);
 
          _usb_device_stall_endpoint(handle, 0, 0);
@@ -1167,55 +1167,55 @@ static void ch9Class
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : service_ep0
 * Returned Value : None
 * Comments       :
 *     Called upon a completed endpoint 0 (USB 1.1 Chapter 9) transfer
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void service_ep0
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-      
+
       /* [IN] request type as registered */
       uint_8               type,
 
       /* [IN] Is it a setup packet? */
       boolean              setup,
-      
+
       /* [IN] Direction of the transfer.  Is it transmit? */
       uint_8               direction,
-      
+
       /* [IN] Pointer to the data buffer */
       uint_8_ptr           buffer,
-      
+
       /* [IN] Length of the transfer */
       uint_32              length,
-      
+
       /* [IN] Error, if any */
       uint_8               error
-            
-            
+
+
    )
 { /* Body */
    boolean  class_request = FALSE;
-   
-   if (setup) 
+
+   if (setup)
    {
       _usb_device_read_setup_data(handle, 0, (uint_8_ptr)&local_setup_packet);
       local_setup_packet.VALUE = USB_16BIT_LE(local_setup_packet.VALUE);
       local_setup_packet.INDEX = USB_16BIT_LE(local_setup_packet.INDEX);
       local_setup_packet.LENGTH = USB_16BIT_LE(local_setup_packet.LENGTH);
-   } 
+   }
    else if (class_request) {
       class_request = FALSE;
       /* Finish your class or vendor request here */
-      
+
       return;
    } /* Endif */
-   
+
    switch (local_setup_packet.REQUESTTYPE & 0x60) {
 
       case 0x00:
@@ -1266,13 +1266,13 @@ static void service_ep0
                break;
 
             default:
-                USB_printf("usbMouse_%d, %s: Wrong REQUEST = 0x%02x\n", 
+                USB_printf("usbMouse_%d, %s: Wrong REQUEST = 0x%02x\n",
                         _usb_device_get_dev_num(handle), __FUNCTION__, local_setup_packet.REQUEST);
                _usb_device_stall_endpoint(handle, 0, 0);
                break;
 
          } /* Endswitch */
-         
+
          break;
 
       case 0x20:
@@ -1283,27 +1283,27 @@ static void service_ep0
       case 0x40:
          /* vendor specific request */
          break;
-      
+
       default:
-         USB_printf("usbMouse_%d, %s: Unexpected REQUESTTYPE = 0x%x\n", 
-                _usb_device_get_dev_num(handle), __FUNCTION__, 
+         USB_printf("usbMouse_%d, %s: Unexpected REQUESTTYPE = 0x%x\n",
+                _usb_device_get_dev_num(handle), __FUNCTION__,
                 local_setup_packet.REQUESTTYPE);
 
          _usb_device_stall_endpoint(handle, 0, 0);
          break;
-         
+
    } /* Endswitch */
-   
+
    return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : service_ep1
 * Returned Value : None
 * Comments       :
 *     Called upon a completed endpoint 1 (USB 1.1 Chapter 9) transfer
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void service_ep1
    (
@@ -1312,23 +1312,23 @@ static void service_ep1
 
       /* [IN] request type as registered */
       uint_8               type,
-      
+
       /* [IN] Is it a setup packet? */
       boolean              setup,
-      
+
       /* [IN] Direction of the transfer.  Is it transmit? */
       uint_8               direction,
-      
+
       /* [IN] Pointer to the data buffer */
       uint_8_ptr           buffer,
-      
+
       /* [IN] Length of the transfer */
       uint_32              length,
 
       /* [IN] Error, if any */
       uint_8               error
-            
-            
+
+
    )
 { /* Body */
 
@@ -1337,47 +1337,47 @@ static void service_ep1
    Comment this out if this behaviour is not desired.
 ********************************************************************/
 
-    static int       x = 0;  
+    static int       x = 0;
     static boolean   right = FALSE;
     static int       wait = 0;
 
     mouseCntr++;
     if(wait == 0)
     {
-        if (right == FALSE)  
+        if (right == FALSE)
         {
-            mouse_data.b = 1; 
+            mouse_data.b = 1;
             x++;
-            right = (x > 200) ? TRUE : FALSE;     
+            right = (x > 200) ? TRUE : FALSE;
         }
-   
-        if (right == TRUE)  
+
+        if (right == TRUE)
         {
-            mouse_data.b = -1; 
+            mouse_data.b = -1;
             x--;
-            right = (x < 0) ? FALSE : TRUE;     
+            right = (x < 0) ? FALSE : TRUE;
         }
         wait = mouseDelay;
     }
     else
     {
         wait--;
-        mouse_data.b = 0; 
+        mouse_data.b = 0;
     }
-   
+
    _usb_device_send_data(handle, INTERRUPT_EP, (uint_8_ptr)((pointer)&mouse_data),
                             sizeof(MOUSE_DATA_STRUCT));
- 
+
    return;
 } /* Endbody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : reset_ep0
 * Returned Value : None
 * Comments       :
 *     Called upon a bus reset event.  Initialises the control endpoint.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void reset_ep0
    (
@@ -1386,23 +1386,23 @@ static void reset_ep0
 
       /* [IN] request type as registered */
       uint_8               type,
-      
+
       /* [IN] Unused */
       boolean              setup,
-   
+
       /* [IN] Unused */
       uint_8               direction,
-   
+
       /* [IN] Unused */
       uint_8_ptr           buffer,
-   
+
       /* [IN] Unused */
       uint_32              length,
 
       /* [IN] Error, if any */
       uint_8               error
-            
-            
+
+
    )
 { /* Body */
 
@@ -1418,74 +1418,74 @@ static void reset_ep0
    _usb_device_init_endpoint(handle, 0, DevDesc[DEV_DESC_MAX_PACKET_SIZE], 1,
       ARC_USB_CONTROL_ENDPOINT, 0);
 
-   if (TEST_ENABLED) 
+   if (TEST_ENABLED)
    {
       _usb_device_cancel_transfer(handle, INTERRUPT_EP, ARC_USB_SEND);
    } /* Endif */
-   
+
    TEST_ENABLED = FALSE;
    mouseCntr = 0;
-         
+
    return;
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : service_suspend
 * Returned Value : None
 * Comments       :
 *     Called when host suspend the USB port. Do remote wake up if desired.
-* 
+*
 *END*--------------------------------------------------------------------*/
 static void service_suspend
    (
       /* [IN] Handle of the USB device */
       _usb_device_handle   handle,
-   
+
       /* [IN] request type as registered */
       uint_8               type,
 
       /* [IN] Unused */
       boolean              setup,
-   
+
       /* [IN] Unused */
       uint_8               direction,
-   
+
       /* [IN] Unused */
       uint_8_ptr           buffer,
-   
+
       /* [IN] Unused */
       uint_32              length,
 
       /* [IN] Error, if any */
-      uint_8               error                        
+      uint_8               error
    )
 { /* Body */
    uint_16      usb_status;
-   int          lockKey;            
-   
+   int          lockKey;
+
    _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
-   if (usb_status & ARC_USB_REMOTE_WAKEUP) 
-   { 
+   if (usb_status & ARC_USB_REMOTE_WAKEUP)
+   {
        lockKey = USB_lock();
 
        USB_printf("Mouse Suspended: type=%d, usbStatus=0x%x\n", type, usb_status);
        USB_SUSPENDED = TRUE;
 
        USB_unlock(lockKey);
-   } 
-          
+   }
+
    return;
 } /* EndBody */
 
 /*FUNCTION*----------------------------------------------------------------
-* 
+*
 * Function Name  : usbMouseLoad
 * Returned Value : None
 * Comments       :
 *     First function called.  Initialises the USB and registers Chapter 9
 *     callback functions.
-* 
+*
 *END*--------------------------------------------------------------------*/
 _usb_device_handle  usbMouseLoad(int devNo)
 { /* Body */
@@ -1513,48 +1513,48 @@ _usb_device_handle  usbMouseLoad(int dev
     }
 
    lockKey = USB_lock();
-   
+
     /* Initialize the USB interface */
-    error = _usb_device_init(devNo, &handle);   
-    if (error != USB_OK) 
+    error = _usb_device_init(devNo, &handle);
+    if (error != USB_OK)
     {
         USB_printf("\nUSB Initialization failed. Error: %x\n", error);
         return NULL;
     } /* Endif */
-   
+
     /* Self Power, Remote wakeup disable */
-    _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, (1 << DEVICE_SELF_POWERED));    
+    _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, (1 << DEVICE_SELF_POWERED));
 
     error = _usb_device_register_service(handle, ARC_USB_SERVICE_EP0, service_ep0);
-    if (error != USB_OK) 
+    if (error != USB_OK)
     {
         USB_printf("\nUSB EP0 Service Registration failed. Error: %x\n", error);
         return NULL;
     } /* Endif */
-   
+
     error = _usb_device_register_service(handle, ARC_USB_SERVICE_BUS_RESET, reset_ep0);
-    if (error != USB_OK) 
+    if (error != USB_OK)
     {
         USB_printf("\nUSB BUS_RESET Service Registration failed. Error: %x\n", error);
         return NULL;
     } /* Endif */
-   
-    error = _usb_device_register_service(handle, INTERRUPT_EP, service_ep1);   
-    if (error != USB_OK) 
+
+    error = _usb_device_register_service(handle, INTERRUPT_EP, service_ep1);
+    if (error != USB_OK)
     {
         USB_printf("\nUSB EP1 Service Registration failed. Error: %x\n", error);
         return NULL;
     } /* Endif */
 
     error = _usb_device_register_service(handle, ARC_USB_SERVICE_SUSPEND, service_suspend);
-    if (error != USB_OK) 
+    if (error != USB_OK)
     {
         USB_printf("\nUSB SUSPEND Service Registration failed. Error: %x\n", error);
         return NULL;
     } /* Endif */
 
     error = _usb_device_register_service(handle, ARC_USB_SERVICE_SLEEP, service_suspend);
-    if (error != USB_OK) 
+    if (error != USB_OK)
     {
         USB_printf("\nUSB SUSPEND Service Registration failed. Error: %x\n", error);
         return NULL;
@@ -1567,17 +1567,17 @@ _usb_device_handle  usbMouseLoad(int dev
     hid_test_rep_data_unaligned   = (uint_8_ptr) USB_memalloc((EP1_RECV_BUFFER_SIZE + PSP_CACHE_LINE_SIZE));
     if(hid_test_rep_data_unaligned == NULL)
     {
-        USB_printf("mouseLoad: Buffer allocation of %d bytes is failed\n", 
+        USB_printf("mouseLoad: Buffer allocation of %d bytes is failed\n",
                     (unsigned)EP1_RECV_BUFFER_SIZE + PSP_CACHE_LINE_SIZE);
         return NULL;
     }
 
     hid_test_rep_data = (uint_8_ptr) USB_CACHE_ALIGN((uint_32) hid_test_rep_data_unaligned);
-    
+
     /**************************************************************************
     Best way to handle the Data cache is to allocate a large buffer that is
     cache aligned and keep all data inside it. Flush the line of the cache
-    that you have changed. In this program, we have static data such as 
+    that you have changed. In this program, we have static data such as
     descriptors which never changes. Such data can be kept in this buffer
     and flushed only once. Note that you can reduce the size of this buffer
     by aligning the addresses in a different way.
@@ -1587,36 +1587,36 @@ _usb_device_handle  usbMouseLoad(int dev
                              (REPORT_DESC_SIZE + PSP_CACHE_LINE_SIZE) +
                              (DEVICE_QUALIFIER_DESCRIPTOR_SIZE + PSP_CACHE_LINE_SIZE) +
                              (OTHER_SPEED_CONFIG_DESC_SIZE + PSP_CACHE_LINE_SIZE);
-                               
+
     Send_Buffer_Unaligned   = (uint_8_ptr) USB_memalloc(send_data_buffer_size);
-    if (Send_Buffer_Unaligned == NULL) 
+    if (Send_Buffer_Unaligned == NULL)
     {
         USB_printf("\nMouse: %d bytes Buffer allocation failed\n", send_data_buffer_size);
         return NULL;
     }
-   
+
     Send_Buffer_aligned = (uint_8_ptr) USB_CACHE_ALIGN((uint_32) Send_Buffer_Unaligned);
     /* keep a temporary copy of the aligned address */
     temp = Send_Buffer_aligned;
-   
+
 
     /**************************************************************************
     Assign pointers to different descriptors from it and copy descriptors inside.
     ***************************************************************************/
     DevDesc =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(DevDescData, DevDesc, DEVICE_DESCRIPTOR_SIZE);
-    Send_Buffer_aligned += ((DEVICE_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE; 
-   
+    Send_Buffer_aligned += ((DEVICE_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
     ConfigDesc =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(ConfigDescData, ConfigDesc, CONFIG_DESC_SIZE);
 
-    Send_Buffer_aligned += ((CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE; 
+    Send_Buffer_aligned += ((CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
 
     ReportDesc =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(ReportDescData, ReportDesc, REPORT_DESC_SIZE);
-    Send_Buffer_aligned += ((REPORT_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE; 
+    Send_Buffer_aligned += ((REPORT_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
 
-   
     DevQualifierDesc =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(DevQualifierDescData, DevQualifierDesc, DEVICE_QUALIFIER_DESCRIPTOR_SIZE);
     Send_Buffer_aligned += ((DEVICE_QUALIFIER_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + \
@@ -1624,8 +1624,8 @@ _usb_device_handle  usbMouseLoad(int dev
 
     other_speed_config =  (uint_8_ptr) Send_Buffer_aligned;
     USB_memcopy(other_speed_config_data, other_speed_config, OTHER_SPEED_CONFIG_DESC_SIZE);
-    Send_Buffer_aligned += ((OTHER_SPEED_CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE; 
-                           
+    Send_Buffer_aligned += ((OTHER_SPEED_CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
     /**************************************************************************
     Flush the cache to ensure main memory is updated.
     ***************************************************************************/
@@ -1640,8 +1640,8 @@ _usb_device_handle  usbMouseLoad(int dev
     USB_unlock(lockKey);
 
     USB_printf("USB Mouse example is READY\n");
-   
-    return handle; 
+
+    return handle;
 } /* Endbody */
 
 void    usbMouseUnload(_usb_device_handle handle)
@@ -1653,7 +1653,7 @@ void    usbMouseUnload(_usb_device_handl
 
     /*lock interrupts */
     lockKey = USB_lock();
-    
+
     /* ensure all transfers are cancelled */
     _usb_device_cancel_transfer(handle, INTERRUPT_EP,  ARC_USB_SEND);
 
@@ -1666,11 +1666,11 @@ void    usbMouseUnload(_usb_device_handl
     _usb_device_stop(handle);
 
     /* Deregister all services */
-    _usb_device_unregister_service(handle, ARC_USB_SERVICE_EP0);   
-    _usb_device_unregister_service(handle, ARC_USB_SERVICE_BUS_RESET);   
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_EP0);
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_BUS_RESET);
     _usb_device_unregister_service(handle, ARC_USB_SERVICE_SUSPEND);
     _usb_device_unregister_service(handle, ARC_USB_SERVICE_SLEEP);
-    _usb_device_unregister_service(handle, INTERRUPT_EP);   
+    _usb_device_unregister_service(handle, INTERRUPT_EP);
 
     _usb_device_shutdown(handle);
 
@@ -1689,14 +1689,14 @@ void    usbMouseUnload(_usb_device_handl
 
     /* Clear gloabal variables */
     TEST_ENABLED = FALSE;
-    USB_SUSPENDED = FALSE;    
-    
+    USB_SUSPENDED = FALSE;
+
     USB_unlock(lockKey);
 }
 
 void    usbMousePeriodicResume(_usb_device_handle handle)
 {
-    if (USB_SUSPENDED) 
+    if (USB_SUSPENDED)
     {
        /*
         * Send RESUME signal whenever host suspends the USB port. In real case, we should
@@ -1705,7 +1705,7 @@ void    usbMousePeriodicResume(_usb_devi
         USB_printf("Mouse Resumed\n");
 
         _usb_device_assert_resume(handle);
-        USB_SUSPENDED = FALSE;     
+        USB_SUSPENDED = FALSE;
     } /* Endbody */
 }
 /* EOF */
--- a/arch/arm/plat-armada/mv_hal/usb/examples/mouse.h
+++ b/arch/arm/plat-armada/mv_hal/usb/examples/mouse.h
@@ -1,16 +1,16 @@
 /*******************************************************************************
 
-This software file (the "File") is distributed by Marvell International Ltd. 
-or its affiliate(s) under the terms of the GNU General Public License Version 2, 
-June 1991 (the "License").  You may use, redistribute and/or modify this File 
-in accordance with the terms and conditions of the License, a copy of which 
-is available along with the File in the license.txt file or by writing to the 
-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
 (C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
--- a/arch/arm/plat-armada/mv_hal/usb/mvCompVer.txt
+++ b/arch/arm/plat-armada/mv_hal/usb/mvCompVer.txt
@@ -1,4 +1,3 @@
 Global HAL Version: FEROCEON_HAL_3_1_7
 Unit HAL Version: 3.1.4
 Description: This component includes an implementation of the unit HAL drivers
-
--- a/arch/arm/plat-armada/mv_hal/usb/mvUsb.c
+++ b/arch/arm/plat-armada/mv_hal/usb/mvUsb.c
@@ -193,12 +193,6 @@ static int mvUsbPhy40nmInit(int dev)
 	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 3), regVal);
 	/*-------------------------------------------------*/
 
-#if 0
-	/******* reset VCOCAL_START *******/
-	regVal = MV_REG_READ(MV_USB_PHY_PLL_REG(1));
-	regVal &= ~BIT21;
-	MV_REG_WRITE(MV_USB_PHY_PLL_REG(1), regVal);
-#endif
 	/******* Assert REG_RCAL_START in Channel REG 1 *******/
 	regVal = MV_REG_READ(MV_USB_PHY_CHANNEL_REG(dev, 1));
 	regVal |= BIT12;
@@ -211,16 +205,7 @@ static int mvUsbPhy40nmInit(int dev)
 	regVal &= ~BIT12;
 	MV_REG_WRITE(MV_USB_PHY_CHANNEL_REG(dev, 1), regVal);
 	/*-------------------------------------------------*/
-#if 0
-	/* Wait 400 usec */
-	mvOsUDelay(400);
-
-	/******* Check that PLL is ready *******/
-/*	regVal = MV_REG_READ(MV_USB_PHY_PLL_REG(1));
-	if (regVal & BIT23)
-		return 0;
-*/
-#endif
+
 	return 0;
 } /* End of mvUsbPhy40nmInit() */
 
@@ -335,101 +320,6 @@ static void mvUsbPhy65nmNewInit(int dev)
 	/* Nothing to change */
 }
 
-/* USB Phy init (change from defaults) specific for 55nm (6500-Z1 device) */
-#if 0
-static void mvUsbPhyKW6500Init(int dev)
-{
-	MV_U32 regVal;
-	/******* USB PHY PLL Control Register 0x410 *******/
-	regVal = MV_REG_READ(MV_USB_PHY_PLL_CTRL_REG(dev));
-
-	/* VCO recalibrate */
-	regVal |= (0x1 << 21);
-	MV_REG_WRITE(MV_USB_PHY_PLL_CTRL_REG(dev), regVal);
-	/* wait 500 usec */
-	mvOsUDelay(500);
-	regVal &= ~(0x1 << 21);
-	MV_REG_WRITE(MV_USB_PHY_PLL_CTRL_REG(dev), regVal);
-	/*-------------------------------------------------*/
-
-	/******* USB PHY Tx Control Register Register 0x420 *******/
-	regVal = MV_REG_READ(MV_USB_PHY_TX_CTRL_REG(dev));
-
-	/* bit[11]      (LOWVDD_EN)     = 1 */
-	regVal |= (0x1 << 11);
-
-	/* bit[12]      (REG_RCAL_START) = 1 */
-	regVal |= (0x1 << 12);
-
-	/* bits[16:14]  (IMPCAL_VTH[2:0] = 101) */
-	regVal &= ~(0x7 << 14);
-	regVal |= (0x5 << 14);
-
-	/* bit[21]      (TX_BLOCK_EN)   = 0 */
-	regVal &= ~(0x1 << 21);
-
-	/* bit[31]  (HS_STRESS_CTRL) = 0 */
-	regVal &= ~(0x1 << 31);
-
-	MV_REG_WRITE(MV_USB_PHY_TX_CTRL_REG(dev), regVal);
-
-	/* wait 500 usec */
-	mvOsUDelay(500);
-
-	/* Force impedance auto calibrate */
-	/* bit[12]      (REG_RCAL_START) = 0 */
-	regVal &= ~(0x1 << 12);
-	MV_REG_WRITE(MV_USB_PHY_TX_CTRL_REG(dev), regVal);
-
-	/*-------------------------------------------------*/
-
-	/******* USB PHY Rx Control Register 0x430 *******/
-	regVal = MV_REG_READ(MV_USB_PHY_RX_CTRL_REG(dev));
-
-	/* bits[3:2]    LPL_COEF        = 0x1 (1/8) */
-	regVal &= ~(0x3 << 2);
-	regVal |= (0x1 << 2);
-
-	/* bits[7:4]    SQ_THRESH       = 0xC */
-	regVal &= ~(0xf << 4);
-	regVal |= (0xC << 4);
-
-	/* bits[16:15]  REG_SQ_LENGTH   = 0x1 */
-	regVal &= ~(0x3 << 15);
-	regVal |= (0x1 << 15);
-
-	/* bit[21]      CDR_FASTLOCK_EN = 0x0 */
-	regVal &= ~(0x1 << 21);
-
-	/* bits[27:26]  EDGE_DET        = 0x0 (1 Tran) */
-	regVal &= ~(0x3 << 26);
-
-	MV_REG_WRITE(MV_USB_PHY_RX_CTRL_REG(dev), regVal);
-	/*-------------------------------------------------*/
-
-	/******* USB PHY IVREF Control Register 0x440 *******/
-	regVal = MV_REG_READ(MV_USB_PHY_IVREF_CTRL_REG(dev));
-
-	/* bits[9:8]    TXVDD12 = 0x3 */
-	regVal &= ~(0x3 << 8);
-	regVal |= (0x3 << 8);
-
-	MV_REG_WRITE(MV_USB_PHY_IVREF_CTRL_REG(dev), regVal);
-	/*-------------------------------------------------*/
-
-	/***** USB PHY TEST GROUP CONTROL Register: 0x450 *****/
-	regVal = MV_REG_READ(MV_USB_PHY_TEST_GROUP_CTRL_REG_0(dev));
-
-	/* bit[15]      REG_FIFO_SQ_RST = 0x0 */
-	regVal &= ~(0x1 << 15);
-
-	MV_REG_WRITE(MV_USB_PHY_TEST_GROUP_CTRL_REG_0(dev), regVal);
-	/*-------------------------------------------------*/
-
-	return;
-}
-#endif
-
 /* USB Phy init (change from defaults) specific for 65nm (78XX0 and 6281) */
 static void mvUsbPhy65nmInit(int dev)
 {
@@ -873,10 +763,7 @@ MV_STATUS mvUsbHalInit(int dev, MV_BOOL
 		(usbHalData.ctrlModel == MV_6560_DEV_ID)) {
 		/* Change value of new register 0x360 */
 		regVal = MV_REG_READ(MV_USB_BRIDGE_IPG_REG(dev));
-#if 0
-		/*  Change bits31 & bit30 from 1 to 0 */
-		regVal &= ~(0x3 << 30);
-#endif
+
 		/*  Change bits[14:8] - IPG for non Start of Frame Packets
 		 *  from 0x9(default) to 0xD
 		 */
--- a/arch/arm/plat-armada/mv_hal/xor/mvXor.c
+++ b/arch/arm/plat-armada/mv_hal/xor/mvXor.c
@@ -278,13 +278,6 @@ MV_STATUS mvXorMemInit(MV_U32 chan, MV_U
 			   __func__, XEXBSR_BLOCK_SIZE_MIN_VALUE, XEXBSR_BLOCK_SIZE_MAX_VALUE);
 		return MV_BAD_PARAM;
 	}
-#if 0
-/* tzachi - this is done purposely by u-boot */
-	if (0x0 == startPtr) {
-		mvOsPrintf("%s: ERR. startPtr is NULL pointer\n", __func__);
-		return MV_BAD_PARAM;
-	}
-#endif
 
 	/* set the operation mode to Memory Init */
 	temp = MV_REG_READ(XOR_CONFIG_REG(XOR_UNIT(chan), XOR_CHAN(chan)));
@@ -508,7 +501,7 @@ MV_STATUS mvXorCommandSet(MV_U32 chan, M
 		return MV_OK;
 	}
 	/* command is paused and current state is active */
-	else if ((command == MV_PAUSED) && (state == MV_ACTIVE)) {
+	else if ((MV_PAUSED == command) && (MV_ACTIVE == state)) {
 		MV_REG_BIT_SET(XOR_ACTIVATION_REG(XOR_UNIT(chan), XOR_CHAN(chan)), XEXACTR_XEPAUSE_MASK);
 		return MV_OK;
 	}
