From 946ff8970c0143268fc01ebd34cfa3fe6264b6e5 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Thu, 14 Mar 2013 15:24:02 +0200
Subject: [PATCH 571/609] Net: Add support for QD switch HAL ver 3.3

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: Ie74eb918dcdde003b068a2f3da795d70caec1cf4
Reviewed-on: http://vgitil04.il.marvell.com:8080/1340
Reviewed-by: Jonatan Farhadian <yonif@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Seif Mazareeb <seif@marvell.com>
---
 .../mv_hal/qd-dsdt-3.3/Include/Copyright.h         |   60 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/Include/gtMad.h |  202 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/Include/gtPTP.h |  499 +
 .../qd-dsdt-3.3/Include/h/driver/gtDrvConfig.h     |  249 +
 .../qd-dsdt-3.3/Include/h/driver/gtDrvEvents.h     |   87 +
 .../qd-dsdt-3.3/Include/h/driver/gtDrvSwRegs.h     |  300 +
 .../mv_hal/qd-dsdt-3.3/Include/h/driver/gtHwCntl.h | 1083 +
 .../mv_hal/qd-dsdt-3.3/Include/h/msApi/gtVct.h     |  183 +
 .../qd-dsdt-3.3/Include/h/msApi/msApiInternal.h    | 1813 ++
 .../qd-dsdt-3.3/Include/h/platform/gtMiiSmiIf.h    |  238 +
 .../mv_hal/qd-dsdt-3.3/Include/h/platform/gtSem.h  |  153 +
 .../qd-dsdt-3.3/Include/h/platform/platformDeps.h  |   30 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/Include/msApi.h |   22 +
 .../mv_hal/qd-dsdt-3.3/Include/msApiDefs.h         | 4472 ++++
 .../mv_hal/qd-dsdt-3.3/Include/msApiPrototype.h    |22912 ++++++++++++++++++++
 .../mv_hal/qd-dsdt-3.3/Include/msApiSelect.h       |   55 +
 .../mv_hal/qd-dsdt-3.3/Include/msApiTypes.h        |  109 +
 .../mv_hal/qd-dsdt-3.3/Include/msApiWince.h        |  556 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/README_SW.txt   |  382 +
 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/makedefs   |   14 +
 .../mv_hal/qd-dsdt-3.3/sample/802.1Q/802_1q.c      |  332 +
 .../mv_hal/qd-dsdt-3.3/sample/802.1Q/readme.txt    |   46 +
 .../qd-dsdt-3.3/sample/CableTest/advCableTest.c    |  205 +
 .../qd-dsdt-3.3/sample/CableTest/cableTest.c       |  109 +
 .../mv_hal/qd-dsdt-3.3/sample/CableTest/readme.txt |   13 +
 .../sample/CrossChipTrunk/crossChipTrunk.c         |  347 +
 .../qd-dsdt-3.3/sample/CrossChipTrunk/readme.txt   |   12 +
 .../qd-dsdt-3.3/sample/FlowControl/flowCtrl.c      |   55 +
 .../qd-dsdt-3.3/sample/FlowControl/readme.txt      |   10 +
 .../mv_hal/qd-dsdt-3.3/sample/Header/header.c      |   44 +
 .../mv_hal/qd-dsdt-3.3/sample/Header/readme.txt    |   19 +
 .../mv_hal/qd-dsdt-3.3/sample/Include/msSample.h   |  146 +
 .../mv_hal/qd-dsdt-3.3/sample/Include/qdSimRegs.h  |  132 +
 .../qd-dsdt-3.3/sample/Initialization/ev96122mii.c |  213 +
 .../qd-dsdt-3.3/sample/Initialization/msApiInit.c  |  117 +
 .../qd-dsdt-3.3/sample/Initialization/msSample.h   |  157 +
 .../qd-dsdt-3.3/sample/Initialization/osSem.c      |  233 +
 .../qd-dsdt-3.3/sample/Initialization/qdSim.c      | 2004 ++
 .../qd-dsdt-3.3/sample/Initialization/readme.txt   |   85 +
 .../mv_hal/qd-dsdt-3.3/sample/Interrupt/qdInt.c    |  386 +
 .../mv_hal/qd-dsdt-3.3/sample/Interrupt/readme.txt |   13 +
 .../qd-dsdt-3.3/sample/LoadBalance/loadBalance.c   |   57 +
 .../qd-dsdt-3.3/sample/LoadBalance/readme.txt      |    9 +
 .../mv_hal/qd-dsdt-3.3/sample/MACAddress/macAddr.c |  223 +
 .../qd-dsdt-3.3/sample/MACAddress/readme.txt       |   16 +
 .../sample/MinimizeCPUTraffic/minimizeCPUTraffic.c |  184 +
 .../sample/MinimizeCPUTraffic/readme.txt           |   22 +
 .../qd-dsdt-3.3/sample/MultiDevice/msApiInit.c     |  271 +
 .../mv_hal/qd-dsdt-3.3/sample/PIRL/pirl.c          |   92 +
 .../mv_hal/qd-dsdt-3.3/sample/PIRL/pirl2.c         |  199 +
 .../mv_hal/qd-dsdt-3.3/sample/PIRL/readme.txt      |   16 +
 .../mv_hal/qd-dsdt-3.3/sample/PTP/ptp.c            |  281 +
 .../mv_hal/qd-dsdt-3.3/sample/PTP/readme.txt       |    7 +
 .../qd-dsdt-3.3/sample/PktGen/phyPktGenSample.c    |   86 +
 .../mv_hal/qd-dsdt-3.3/sample/PktGen/readme.txt    |   12 +
 .../qd-dsdt-3.3/sample/PortMonitor/portMonitor.c   |  107 +
 .../qd-dsdt-3.3/sample/PortMonitor/readme.txt      |   21 +
 .../mv_hal/qd-dsdt-3.3/sample/QoSSetup/qos.c       |  195 +
 .../mv_hal/qd-dsdt-3.3/sample/QoSSetup/readme.txt  |   32 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/sample/README   |    2 +
 .../mv_hal/qd-dsdt-3.3/sample/RMON/readme.txt      |   28 +
 .../mv_hal/qd-dsdt-3.3/sample/RMON/rmon.c          |  237 +
 .../mv_hal/qd-dsdt-3.3/sample/Trailer/readme.txt   |   12 +
 .../mv_hal/qd-dsdt-3.3/sample/Trailer/trailer.c    |   50 +
 .../mv_hal/qd-dsdt-3.3/sample/VlanSetup/hgVlan.c   |  135 +
 .../mv_hal/qd-dsdt-3.3/sample/VlanSetup/readme.txt |   31 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/sample/makefile |   53 +
 .../mv_hal/qd-dsdt-3.3/sample/tcam/readme.txt      |    7 +
 .../mv_hal/qd-dsdt-3.3/sample/tcam/tcam.c          |  408 +
 .../mv_hal/qd-dsdt-3.3/src/driver/gtDrvConfig.c    |  963 +
 .../mv_hal/qd-dsdt-3.3/src/driver/gtDrvEvents.c    |   94 +
 .../mv_hal/qd-dsdt-3.3/src/driver/gtHwCntl.c       | 2931 +++
 .../mv_hal/qd-dsdt-3.3/src/driver/makefile         |   33 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/src/makefile    |  106 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtAVB.c           | 4018 ++++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtAdvVct.c        | 1876 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtAdvVct_mad.c    |  227 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtBrgFdb.c        | 3289 +++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtBrgStp.c        |  333 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtBrgStu.c        |  848 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtBrgVlan.c       | 1312 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtBrgVtu.c        | 1592 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtCCPVT.c         |  438 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtEvents.c        | 1519 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtMisc.c          | 2188 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPCSCtrl.c       | 1937 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPIRL.c          | 1827 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPIRL2.c         | 1739 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPTP.c           | 5361 +++++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPTP.c.orig      | 5296 +++++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPTPHidden.c     |  269 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPage2Access.c   | 1175 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl.c       | 3005 +++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl_mad.c   | 2045 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPhyInt.c        |  301 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPhyInt_mad.c    |  272 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPolicy.c        |  279 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPortCtrl.c      | 7195 ++++++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPortLed.c       |  840 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPortPav.c       |  269 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPortRateCtrl.c  | 2818 +++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPortRmon.c      | 1244 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPortStat.c      |  391 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPortStatus.c    | 2235 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtPriTable.c      | 1110 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtQosMap.c        | 2423 +++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtSerdesCtrl.c    |  287 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtSysConfig.c     | 1301 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtSysCtrl.c       | 9236 ++++++++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtSysStatus.c     |  262 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtTCAM.c          | 1226 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtUtils.c         |  209 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtVct.c           | 1248 ++
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtVct_mad.c       |  224 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtVersion.c       |   59 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtWeight.c        |  479 +
 .../mv_hal/qd-dsdt-3.3/src/msapi/makefile          |   49 +
 .../mv_hal/qd-dsdt-3.3/src/platform/gtDebug.c      |   78 +
 .../mv_hal/qd-dsdt-3.3/src/platform/gtMiiSmiIf.c   |  833 +
 .../mv_hal/qd-dsdt-3.3/src/platform/gtSem.c        |  148 +
 .../mv_hal/qd-dsdt-3.3/src/platform/makefile       |   33 +
 .../mv_hal/qd-dsdt-3.3/src/platform/platformDeps.c |   90 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/tools/make.defs |  105 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/tools/make.exe  |  Bin 0 -> 180224 bytes
 .../mv_hal/qd-dsdt-3.3/tools/make.rules            |   54 +
 .../mv_hal/qd-dsdt-3.3/tools/makelnx.defs          |   62 +
 .../mv_hal/qd-dsdt-3.3/tools/makelnx.rules         |   57 +
 .../mv_hal/qd-dsdt-3.3/tools/makewce.defs          |   94 +
 .../mv_hal/qd-dsdt-3.3/tools/makewce.rules         |   49 +
 .../plat-armada/mv_hal/qd-dsdt-3.3/tools/setenv    |   14 +
 .../mv_hal/qd-dsdt-3.3/tools/setenv.bat            |   55 +
 131 files changed, 120940 insertions(+)
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/Copyright.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/gtMad.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/gtPTP.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvConfig.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvEvents.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvSwRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtHwCntl.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/msApi/gtVct.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/msApi/msApiInternal.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/platform/gtMiiSmiIf.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/platform/gtSem.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/platform/platformDeps.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApi.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiDefs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiPrototype.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiSelect.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiTypes.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiWince.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/README_SW.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/makedefs
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/802.1Q/802_1q.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/802.1Q/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CableTest/advCableTest.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CableTest/cableTest.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CableTest/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CrossChipTrunk/crossChipTrunk.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CrossChipTrunk/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/FlowControl/flowCtrl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/FlowControl/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Header/header.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Header/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Include/msSample.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Include/qdSimRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/ev96122mii.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/msApiInit.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/msSample.h
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/osSem.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/qdSim.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Interrupt/qdInt.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Interrupt/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/LoadBalance/loadBalance.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/LoadBalance/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MACAddress/macAddr.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MACAddress/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MinimizeCPUTraffic/minimizeCPUTraffic.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MinimizeCPUTraffic/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MultiDevice/msApiInit.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PIRL/pirl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PIRL/pirl2.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PIRL/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PTP/ptp.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PTP/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PktGen/phyPktGenSample.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PktGen/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PortMonitor/portMonitor.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PortMonitor/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/QoSSetup/qos.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/QoSSetup/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/README
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/RMON/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/RMON/rmon.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Trailer/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Trailer/trailer.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/VlanSetup/hgVlan.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/VlanSetup/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/makefile
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/tcam/readme.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/tcam/tcam.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/driver/gtDrvConfig.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/driver/gtDrvEvents.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/driver/gtHwCntl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/driver/makefile
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/makefile
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtAVB.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtAdvVct.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtAdvVct_mad.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgFdb.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgStp.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgStu.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgVlan.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgVtu.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtCCPVT.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtEvents.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtMisc.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPCSCtrl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPIRL.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPIRL2.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPTP.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPTP.c.orig
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPTPHidden.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPage2Access.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl_mad.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyInt.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyInt_mad.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPolicy.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortCtrl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortLed.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortPav.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortRateCtrl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortRmon.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortStat.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortStatus.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPriTable.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtQosMap.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSerdesCtrl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysConfig.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysCtrl.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysStatus.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtTCAM.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtUtils.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtVct.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtVct_mad.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtVersion.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtWeight.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/makefile
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtDebug.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtMiiSmiIf.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtSem.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/makefile
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/platformDeps.c
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/make.defs
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/make.exe
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/make.rules
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/makelnx.defs
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/makelnx.rules
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/makewce.defs
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/makewce.rules
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/setenv
 create mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/setenv.bat

--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/Copyright.h
@@ -0,0 +1,60 @@
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms. Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+********************************************************************************
+Marvell Commercial License Option
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+********************************************************************************
+Marvell GPL License Option
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED. The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+* Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+* Neither the name of Marvell nor the names of its contributors may be
+used to endorse or promote products derived from this software without
+specific prior written permission.
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+#ifndef _msCopyright_h
+#define _msCopyright_h
+
+#define MSAPI_COPYRIGHT "Copyright 2000~2013, Marvell International Ltd."
+#define MSAPI_VERSION "3.3"
+
+#endif /* _msCopyright_h */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/gtMad.h
@@ -0,0 +1,202 @@
+#include <Copyright.h>
+/*******************************************************************************
+* gtMad.h
+*
+* DESCRIPTION:
+*       MAD API header file.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+GT_STATUS gvctGetAdvCableDiag_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+);
+GT_STATUS gvctGetAdvExtendedStatus_mad
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT   port,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+);
+#include <Copyright.h>
+
+
+GT_STATUS gprtPhyReset_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port
+);
+GT_STATUS gprtSetPortLoopback_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   enable
+);
+
+GT_STATUS gprtSetPortSpeed_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_SPEED speed
+);
+GT_STATUS gprtPortAutoNegEnable_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+);
+GT_STATUS gprtPortPowerDown_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   state
+);
+GT_STATUS gprtPortRestartAutoNeg_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port
+);
+GT_STATUS gprtSetPortDuplexMode_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   dMode
+);
+GT_STATUS gprtSetPortAutoMode_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_PHY_AUTO_MODE mode
+);
+GT_STATUS gprtSetPause_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_PAUSE_MODE state
+);
+GT_STATUS gprtSetDTEDetect_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+);
+GT_STATUS gprtGetDTEDetectStatus_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+);
+GT_STATUS gprtSetDTEDetectDropWait_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_U16    waitTime
+);
+GT_STATUS gprtGetDTEDetectDropWait_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_U16    *waitTime
+);
+GT_STATUS gprtSetEnergyDetect_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
+);
+GT_STATUS gprtGetEnergyDetect_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
+);
+GT_STATUS gprtSet1000TMasterMode_mad
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_1000T_MASTER_SLAVE   *mode
+);
+GT_STATUS gprtGet1000TMasterMode_mad
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_1000T_MASTER_SLAVE   *mode
+);
+GT_STATUS gprtGetPhyLinkStatus_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
+);
+GT_STATUS gprtSetPktGenEnable_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   en,
+    IN GT_PG     *pktInfo
+);
+GT_STATUS gprtGetPhyReg_mad
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+);
+GT_STATUS gprtSetPhyReg_mad
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            inData
+);
+GT_STATUS gprtGetPagedPhyReg_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
+    OUT GT_U16* data
+);
+GT_STATUS gprtSetPagedPhyReg_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
+    IN  GT_U16 inData
+);
+GT_STATUS gprtPhyIntEnable_mad
+(
+IN GT_QD_DEV    *dev,
+IN GT_LPORT    port,
+IN GT_U16    intType
+);
+GT_STATUS gprtGetPhyIntStatus_mad
+(
+IN   GT_QD_DEV  *dev,
+IN   GT_LPORT   port,
+OUT  GT_U16*    intType
+);
+GT_STATUS gprtGetPhyIntPortSummary_mad
+(
+IN  GT_QD_DEV  *dev,
+OUT GT_U16     *intPortMask
+);
+GT_STATUS gvctGetCableDiag_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+);
+GT_STATUS gvctGet1000BTExtendedStatus_mad
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+);
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/gtPTP.h
@@ -0,0 +1,499 @@
+#ifdef CONFIG_AVB_FPGA
+
+/*******************************************************************************
+* gptpGetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine gets interrupt status of PTP logic.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt    - PTP Int Status
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
+);
+
+/*******************************************************************************
+* gptpSetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine sets interrupt status of PTP logic.
+*
+* INPUTS:
+*    ptpInt    - PTP Int Status
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32    ptpInt
+);
+
+/*******************************************************************************
+* gptpSetFPGAIntEn
+*
+* DESCRIPTION:
+*       This routine enables PTP interrupt.
+*
+* INPUTS:
+*        ptpInt    - PTP Int Status (1 to enable, 0 to disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        ptpInt
+);
+
+/*******************************************************************************
+* gptpGetClockSource
+*
+* DESCRIPTION:
+*       This routine gets PTP Clock source setup.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
+);
+
+/*******************************************************************************
+* gptpSetClockSource
+*
+* DESCRIPTION:
+*       This routine sets PTP Clock source setup.
+*
+* INPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
+);
+
+/*******************************************************************************
+* gptpGetP9Mode
+*
+* DESCRIPTION:
+*       This routine gets Port 9 Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
+);
+
+/*******************************************************************************
+* gptpSetP9Mode
+*
+* DESCRIPTION:
+*       This routine sets Port 9 Mode.
+*
+* INPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
+);
+
+/*******************************************************************************
+* gptpReset
+*
+* DESCRIPTION:
+*       This routine performs software reset for PTP logic.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpReset
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gptpGetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PTP Duty Cycle Adjustment.
+*
+* INPUTS:
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
+);
+
+/*******************************************************************************
+* gptpGetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine gets clock duty cycle adjustment value.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT    *adj
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine sets clock duty cycle adjustment value.
+*
+* INPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT    *adj
+);
+
+/*******************************************************************************
+* gptpGetPLLEn
+*
+* DESCRIPTION:
+*       This routine checks if PLL is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpGetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
+);
+
+/*******************************************************************************
+* gptpSetPLLEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpSetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
+);
+
+/*******************************************************************************
+* gptpGetDDSReg
+*
+* DESCRIPTION:
+*       This routine gets DDS register data.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*
+* OUTPUTS:
+*    ddsData    - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    OUT GT_U32    *ddsData
+);
+
+/*******************************************************************************
+* gptpSetDDSReg
+*
+* DESCRIPTION:
+*       This routine sets DDS register data.
+*    DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*    ddsData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    IN  GT_U32    ddsData
+);
+
+/*******************************************************************************
+* gptpUpdateDDSReg
+*
+* DESCRIPTION:
+*       This routine updates DDS register data.
+*    DDS register data written by gptpSetDDSReg are not affected until this API is called.
+*
+* INPUTS:
+*    none
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpUpdateDDSReg
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gptpSetADFReg
+*
+* DESCRIPTION:
+*       This routine sets ADF4156 register data.
+*
+* INPUTS:
+*    adfData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetADFReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    adfData
+);
+
+#endif  /*  CONFIG_AVB_FPGA */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvConfig.h
@@ -0,0 +1,249 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtDrvConfig.h
+*
+* DESCRIPTION:
+*       Includes driver level configuration and initialization function.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 4 $
+*
+*******************************************************************************/
+
+#ifndef __gtDrvConfigh
+#define __gtDrvConfigh
+
+#include <msApi.h>
+#include <gtVct.h>
+#include <gtDrvSwRegs.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+* driverConfig
+*
+* DESCRIPTION:
+*       This function initializes the driver level of the quarterDeck software.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success, or
+*       GT_OUT_OF_CPU_MEM   - if failed to allocate CPU memory,
+*       GT_FAIL             - otherwise.
+*
+* COMMENTS:
+*       1.  This function should perform the following:
+*           -   Initialize the global switch configuration structure.
+*           -   Initialize Mii Interface
+*           -   Set the CPU port into trailer mode (Ingress and Egress).
+*
+*******************************************************************************/
+GT_STATUS driverConfig(IN GT_QD_DEV *dev);
+
+/*******************************************************************************
+* driverEnable
+*
+* DESCRIPTION:
+*       This function enables the switch for full operation, after the driver
+*       Config function was called.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverEnable(IN GT_QD_DEV *dev);
+
+/*******************************************************************************
+* driverIsPhyAttached
+*
+* DESCRIPTION:
+*       This function reads and returns Phy ID (register 3) of Marvell Phy.
+*
+* INPUTS:
+*       hwPort    - port number where the Phy is connected
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       phyId - if Marvell Phy exists
+*        0      - otherwise
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U32 driverIsPhyAttached
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort
+);
+
+/*******************************************************************************
+* driverGetPhyID
+*
+* DESCRIPTION:
+*       This function reads and returns Phy ID (register 3) of Marvell Phy.
+*
+* INPUTS:
+*       hwPort    - port number where the Phy is connected
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       phyId - if Marvell Phy exists
+*        GT_INVALID_PORT      - otherwise
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U32 driverGetPhyID
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort
+);
+
+/*******************************************************************************
+* driverGetSerdesPort
+*
+* DESCRIPTION:
+*       This function converts port to Serdes port
+*
+* INPUTS:
+*       hwPort     - port number where the Phy is connected
+*
+* OUTPUTS:
+*       hwPort     - port number where the Phy is connected
+*
+* RETURNS:
+*       GT_OK     - if success
+*       GT_FAIL - othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverGetSerdesPort(GT_QD_DEV *dev, GT_U8* hwPort);
+
+
+/*******************************************************************************
+* driverPagedAccessStart
+*
+* DESCRIPTION:
+*       This function stores page register and Auto Reg Selection mode if needed.
+*
+* INPUTS:
+*       hwPort     - port number where the Phy is connected
+*        pageType - type of the page registers
+*
+* OUTPUTS:
+*       autoOn    - GT_TRUE if Auto Reg Selection enabled, GT_FALSE otherwise.
+*        pageReg - Page Register Data
+*
+* RETURNS:
+*       GT_OK     - if success
+*       GT_FAIL - othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverPagedAccessStart
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    IN    GT_U8         pageType,
+    OUT    GT_BOOL         *autoOn,
+    OUT    GT_U16         *pageReg
+);
+
+
+/*******************************************************************************
+* driverPagedAccessStop
+*
+* DESCRIPTION:
+*       This function restores page register and Auto Reg Selection mode if needed.
+*
+* INPUTS:
+*       hwPort     - port number where the Phy is connected
+*        pageType - type of the page registers
+*       autoOn     - GT_TRUE if Auto Reg Selection enabled, GT_FALSE otherwise.
+*        pageReg  - Page Register Data
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK     - if success
+*       GT_FAIL - othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverPagedAccessStop
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    IN    GT_U8         pageType,
+    IN    GT_BOOL         autoOn,
+    IN    GT_U16         pageReg
+);
+
+
+/*******************************************************************************
+* driverFindPhyInformation
+*
+* DESCRIPTION:
+*       This function gets information of Phy connected to the given port.
+*
+* INPUTS:
+*       hwPort    - port number where the Phy is connected
+*
+* OUTPUTS:
+*       phyId    - Phy ID
+*
+* RETURNS:
+*       GT_OK     - if found Marvell Phy,
+*       GT_FAIL - othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverFindPhyInformation
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    OUT    GT_PHY_INFO     *phyInfo
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtDrvConfigh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvEvents.h
@@ -0,0 +1,87 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtDrvEvents.h
+*
+* DESCRIPTION:
+*       This file includes function declarations for QuarterDeck interrupts
+*       configuration and handling.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*
+*******************************************************************************/
+
+#ifndef __gtDrvEventsh
+#define __gtDrvEventsh
+
+#include <msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+* drvEventInit
+*
+* DESCRIPTION:
+*       This function initializes the driver's interrupt handling mechanism.
+*
+* INPUTS:
+*       intVecNum   - The interrupt vector the switch is connected to.
+*       isrFunc     - A pointer to the Interrupt Service Routine to be
+*                     connected to the given interrupt vector.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success,
+*       GT_FAIL - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS drvEventsInit
+(
+    IN  GT_QD_DEV     *dev,
+    IN GT_U32         intVecNum,
+    IN GT_VOIDFUNCPTR isrFunc
+);
+
+
+
+/*******************************************************************************
+* eventQdSr
+*
+* DESCRIPTION:
+*       QuarterDeck interrupt service routine.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL eventQdSr
+(
+    IN  GT_QD_DEV  *dev,
+    OUT GT_U16*    intCause
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtDrvEventsh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtDrvSwRegs.h
@@ -0,0 +1,300 @@
+#include <Copyright.h>
+
+/********************************************************************************
+ * * gtDrvSwRegs.h
+ * *
+ * * DESCRIPTION:
+ * *       definitions of the register map of QuarterDeck Device
+ * *
+ * * DEPENDENCIES:
+ * *
+ * * FILE REVISION NUMBER:
+ * *
+ * *******************************************************************************/
+#ifndef __gtDrvSwRegsh
+#define __gtDrvSwRegsh
+
+/* QuarterDeck Per Port Registers */
+#define QD_REG_PORT_STATUS        0x0
+#define QD_REG_PCS_CONTROL        0x1        /* for Sapphire family */
+#define QD_REG_LIMIT_PAUSE_CONTROL        0x2        /* Jamming control register */
+#define QD_REG_SWITCH_ID        0x3
+#define QD_REG_PORT_CONTROL        0x4
+#define QD_REG_PORT_CONTROL1        0x5
+#define QD_REG_PORT_VLAN_MAP        0x6
+#define QD_REG_PVID            0x7
+#define QD_REG_PORT_CONTROL2        0x8    /* for Sapphire family */
+#define QD_REG_INGRESS_RATE_CTRL    0x9    /* for Sapphire family */
+#define QD_REG_EGRESS_RATE_CTRL        0xA    /* for Sapphire family */
+#define QD_REG_RATE_CTRL0        0x9
+#define QD_REG_RATE_CTRL        0xA
+#define QD_REG_PAV            0xB
+#define QD_REG_PORT_ATU_CONTROL        0xC
+#define QD_REG_PRI_OVERRIDE        0xD
+#define QD_REG_POLICY_CONTROL    0xE
+#define QD_REG_PORT_ETH_TYPE    0xF
+#define QD_REG_RX_COUNTER        0x10
+#define QD_REG_TX_COUNTER        0x11
+#define QD_REG_DROPPED_COUNTER    0x12
+
+#define QD_REG_INDISCARD_LO_COUNTER        0x10
+#define QD_REG_INDISCARD_HI_COUNTER        0x11
+#define QD_REG_INFILTERED_COUNTER        0x12
+#define QD_REG_OUTFILTERED_COUNTER        0x13
+
+#define QD_REG_LED_CONTROL        0x16
+
+#define QD_REG_Q_COUNTER        0x1B
+#define QD_REG_RATE_CONTROL        0x0A
+#define QD_REG_PORT_ASSOCIATION        0x0B
+#define QD_REG_IEEE_PRI_REMAP_3_0    0x18    /* for Sapphire family */
+#define QD_REG_IEEE_PRI_REMAP_7_4    0x19    /* for Sapphire family */
+
+#define QD_REG_PROVIDER_TAG        0x1A        /* for Schooner family */
+
+/* QuarterDeck Global Registers */
+#define QD_REG_GLOBAL_STATUS        0x0
+#define QD_REG_MACADDR_01        0x1
+#define QD_REG_MACADDR_23        0x2
+#define QD_REG_MACADDR_45        0x3
+#define QD_REG_GLOBAL_CONTROL        0x4
+#define QD_REG_GLOBAL_CONTROL2        0x1C    /* for Sapphire, Schooner family */
+#define QD_REG_CORETAG_TYPE        0x19        /* for Ruby family */
+#define QD_REG_IP_MAPPING_TABLE    0x19        /* for Amber family */
+#define QD_REG_MONITOR_CONTROL    0x1A        /* for Ruby family */
+#define QD_REG_MANGEMENT_CONTROL    0x1A    /* for Schooner family */
+#define QD_REG_TOTAL_FREE_COUNTER    0x1B    /* for Schooner family */
+
+/* QuarterDeck Global 2 Registers */
+#define QD_REG_PHYINT_SOURCE    0x0
+#define QD_REG_DEVINT_SOURCE    0x0
+#define QD_REG_DEVINT_MASK        0x1
+#define QD_REG_MGMT_ENABLE_2X    0x2
+#define QD_REG_MGMT_ENABLE        0x3
+#define QD_REG_FLOWCTRL_DELAY    0x4
+#define QD_REG_MANAGEMENT        0x5
+#define QD_REG_ROUTING_TBL        0x6
+#define QD_REG_TRUNK_MASK_TBL    0x7
+#define QD_REG_TRUNK_ROUTING    0x8
+#define QD_REG_INGRESS_RATE_COMMAND    0x9
+#define QD_REG_INGRESS_RATE_DATA    0xA
+#define QD_REG_PVT_ADDR            0xB
+#define QD_REG_PVT_DATA            0xC
+#define QD_REG_SWITCH_MAC        0xD
+#define QD_REG_ATU_STATS        0xE
+#define QD_REG_PRIORITY_OVERRIDE    0xF
+#define QD_REG_EEPROM_COMMAND    0x14
+#define QD_REG_EEPROM_DATA        0x15
+#define QD_REG_PTP_COMMAND        0x16
+#define QD_REG_PTP_DATA            0x17
+#define QD_REG_SMI_PHY_CMD        0x18
+#define QD_REG_SMI_PHY_DATA        0x19
+#define QD_REG_SCRATCH_MISC        0x1A
+#define QD_REG_WD_CONTROL        0x1B
+#define QD_REG_QOS_WEIGHT        0x1C
+#define QD_REG_SDET_POLARITY    0x1D
+
+/* QuarterDeck Global 3 Registers */
+#define QD_REG_TCAM_OPERATION         0x0
+#define QD_REG_TCAM_P0_KEYS_1         0x2
+#define QD_REG_TCAM_P0_KEYS_2         0x3
+#define QD_REG_TCAM_P0_KEYS_3         0x4
+#define QD_REG_TCAM_P0_KEYS_4         0x5
+#define QD_REG_TCAM_P0_MATCH_DATA_1   0x6
+#define QD_REG_TCAM_P0_MATCH_DATA_2   0x7
+#define QD_REG_TCAM_P0_MATCH_DATA_3   0x8
+#define QD_REG_TCAM_P0_MATCH_DATA_4   0x9
+#define QD_REG_TCAM_P0_MATCH_DATA_5   0xa
+#define QD_REG_TCAM_P0_MATCH_DATA_6   0xb
+#define QD_REG_TCAM_P0_MATCH_DATA_7   0xc
+#define QD_REG_TCAM_P0_MATCH_DATA_8   0xd
+#define QD_REG_TCAM_P0_MATCH_DATA_9   0xe
+#define QD_REG_TCAM_P0_MATCH_DATA_10  0xf
+#define QD_REG_TCAM_P0_MATCH_DATA_11  0x10
+#define QD_REG_TCAM_P0_MATCH_DATA_12  0x11
+#define QD_REG_TCAM_P0_MATCH_DATA_13  0x12
+#define QD_REG_TCAM_P0_MATCH_DATA_14  0x13
+#define QD_REG_TCAM_P0_MATCH_DATA_15  0x14
+#define QD_REG_TCAM_P0_MATCH_DATA_16  0x15
+#define QD_REG_TCAM_P0_MATCH_DATA_17  0x16
+#define QD_REG_TCAM_P0_MATCH_DATA_18  0x17
+#define QD_REG_TCAM_P0_MATCH_DATA_19  0x18
+#define QD_REG_TCAM_P0_MATCH_DATA_20  0x19
+#define QD_REG_TCAM_P0_MATCH_DATA_21  0x1a
+#define QD_REG_TCAM_P0_MATCH_DATA_22  0x1b
+
+#define QD_REG_TCAM_P1_MATCH_DATA_23   0x2
+#define QD_REG_TCAM_P1_MATCH_DATA_24   0x3
+#define QD_REG_TCAM_P1_MATCH_DATA_25   0x4
+#define QD_REG_TCAM_P1_MATCH_DATA_26   0x5
+#define QD_REG_TCAM_P1_MATCH_DATA_27   0x6
+#define QD_REG_TCAM_P1_MATCH_DATA_28   0x7
+#define QD_REG_TCAM_P1_MATCH_DATA_29   0x8
+#define QD_REG_TCAM_P1_MATCH_DATA_30   0x9
+#define QD_REG_TCAM_P1_MATCH_DATA_31   0xa
+#define QD_REG_TCAM_P1_MATCH_DATA_32   0xb
+#define QD_REG_TCAM_P1_MATCH_DATA_33   0xc
+#define QD_REG_TCAM_P1_MATCH_DATA_34   0xd
+#define QD_REG_TCAM_P1_MATCH_DATA_35   0xe
+#define QD_REG_TCAM_P1_MATCH_DATA_36   0xf
+#define QD_REG_TCAM_P1_MATCH_DATA_37   0x10
+#define QD_REG_TCAM_P1_MATCH_DATA_38   0x11
+#define QD_REG_TCAM_P1_MATCH_DATA_39   0x12
+#define QD_REG_TCAM_P1_MATCH_DATA_40   0x13
+#define QD_REG_TCAM_P1_MATCH_DATA_41   0x14
+#define QD_REG_TCAM_P1_MATCH_DATA_42   0x15
+#define QD_REG_TCAM_P1_MATCH_DATA_43   0x16
+#define QD_REG_TCAM_P1_MATCH_DATA_44   0x17
+#define QD_REG_TCAM_P1_MATCH_DATA_45   0x18
+#define QD_REG_TCAM_P1_MATCH_DATA_46   0x19
+#define QD_REG_TCAM_P1_MATCH_DATA_47   0x1a
+#define QD_REG_TCAM_P1_MATCH_DATA_48   0x1b
+
+#define QD_REG_TCAM_P2_ACTION_1        0x2
+#define QD_REG_TCAM_P2_ACTION_2        0x3
+#define QD_REG_TCAM_P2_ACTION_3        0x4
+#define QD_REG_TCAM_P2_ACTION_4        0x5
+#define QD_REG_TCAM_P2_DEBUG_PORT      0x1c
+#define QD_REG_TCAM_P2_ALL_HIT         0x1f
+
+
+
+/* Global 1 Registers Definition for STU,VTU,RMON,and ATU Registers */
+#define QD_REG_ATU_FID_REG        0x1
+#define QD_REG_VTU_FID_REG        0x2
+#define QD_REG_STU_SID_REG        0x3
+#define QD_REG_VTU_OPERATION        0x5
+#define QD_REG_VTU_VID_REG        0x6
+#define QD_REG_VTU_DATA1_REG        0x7
+#define QD_REG_VTU_DATA2_REG        0x8
+#define QD_REG_VTU_DATA3_REG        0x9
+#define QD_REG_STATS_OPERATION        0x1D
+#define QD_REG_STATS_COUNTER3_2        0x1E
+#define QD_REG_STATS_COUNTER1_0        0x1F
+
+#define QD_REG_ATU_CONTROL        0xA
+#define QD_REG_ATU_OPERATION        0xB
+#define QD_REG_ATU_DATA_REG        0xC
+#define QD_REG_ATU_MAC_BASE        0xD
+#define QD_REG_IP_PRI_BASE        0x10
+#define QD_REG_IEEE_PRI            0x18
+
+
+/* Definitions for MIB Counter */
+#define GT_STATS_NO_OP            0x0
+#define GT_STATS_FLUSH_ALL        0x1
+#define GT_STATS_FLUSH_PORT        0x2
+#define GT_STATS_READ_COUNTER        0x4
+#define GT_STATS_CAPTURE_PORT        0x5
+#define GT_STATS_CAPTURE_PORT_CLEAR  0x6
+
+#define QD_PHY_CONTROL_REG            0
+#define QD_PHY_AUTONEGO_AD_REG            4
+#define QD_PHY_NEXTPAGE_TX_REG            7
+#define QD_PHY_AUTONEGO_1000AD_REG        9
+#define QD_PHY_SPEC_CONTROL_REG            16
+#define QD_PHY_INT_ENABLE_REG            18
+#define QD_PHY_INT_STATUS_REG            19
+#define QD_PHY_INT_PORT_SUMMARY_REG        20
+
+/* Definitions for VCT registers */
+#define QD_REG_MDI0_VCT_STATUS     16
+#define QD_REG_MDI1_VCT_STATUS     17
+#define QD_REG_MDI2_VCT_STATUS     18
+#define QD_REG_MDI3_VCT_STATUS     19
+#define QD_REG_ADV_VCT_CONTROL_5    23
+#define QD_REG_ADV_VCT_CONTROL_8    20
+#define QD_REG_PAIR_SKEW_STATUS    20
+#define QD_REG_PAIR_SWAP_STATUS    21
+
+/* Bit Definition for QD_PHY_CONTROL_REG */
+#define QD_PHY_RESET            0x8000
+#define QD_PHY_LOOPBACK            0x4000
+#define QD_PHY_SPEED            0x2000
+#define QD_PHY_AUTONEGO            0x1000
+#define QD_PHY_POWER            0x800
+#define QD_PHY_ISOLATE            0x400
+#define QD_PHY_RESTART_AUTONEGO        0x200
+#define QD_PHY_DUPLEX            0x100
+#define QD_PHY_SPEED_MSB        0x40
+
+#define QD_PHY_POWER_BIT            11
+#define QD_PHY_RESTART_AUTONEGO_BIT        9
+
+/* Bit Definition for QD_PHY_AUTONEGO_AD_REG */
+#define QD_PHY_NEXTPAGE            0x8000
+#define QD_PHY_REMOTEFAULT        0x4000
+#define QD_PHY_PAUSE            0x400
+#define QD_PHY_100_FULL            0x100
+#define QD_PHY_100_HALF            0x80
+#define QD_PHY_10_FULL            0x40
+#define QD_PHY_10_HALF            0x20
+
+#define QD_PHY_MODE_AUTO_AUTO    (QD_PHY_100_FULL | QD_PHY_100_HALF | QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_100_AUTO    (QD_PHY_100_FULL | QD_PHY_100_HALF)
+#define QD_PHY_MODE_10_AUTO        (QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_AUTO_FULL    (QD_PHY_100_FULL | QD_PHY_10_FULL)
+#define QD_PHY_MODE_AUTO_HALF    (QD_PHY_100_HALF | QD_PHY_10_HALF)
+
+#define QD_PHY_MODE_100_FULL    QD_PHY_100_FULL
+#define QD_PHY_MODE_100_HALF    QD_PHY_100_HALF
+#define QD_PHY_MODE_10_FULL        QD_PHY_10_FULL
+#define QD_PHY_MODE_10_HALF        QD_PHY_10_HALF
+
+/* Gigabit Phy related definition */
+#define QD_GIGPHY_1000X_FULL_CAP    0x8
+#define QD_GIGPHY_1000X_HALF_CAP    0x4
+#define QD_GIGPHY_1000T_FULL_CAP    0x2
+#define QD_GIGPHY_1000T_HALF_CAP    0x1
+
+#define QD_GIGPHY_1000X_CAP        (QD_GIGPHY_1000X_FULL_CAP|QD_GIGPHY_1000X_HALF_CAP)
+#define QD_GIGPHY_1000T_CAP        (QD_GIGPHY_1000T_FULL_CAP|QD_GIGPHY_1000T_HALF_CAP)
+
+#define QD_GIGPHY_1000X_FULL        0x20
+#define QD_GIGPHY_1000X_HALF        0x40
+
+#define QD_GIGPHY_1000T_FULL        0x200
+#define QD_GIGPHY_1000T_HALF        0x100
+
+/* Bit definition for QD_PHY_INT_ENABLE_REG */
+#define QD_PHY_INT_SPEED_CHANGED        0x4000
+#define QD_PHY_INT_DUPLEX_CHANGED        0x2000
+#define QD_PHY_INT_PAGE_RECEIVED        0x1000
+#define QD_PHY_INT_AUTO_NEG_COMPLETED        0x800
+#define QD_PHY_INT_LINK_STATUS_CHANGED        0x400
+#define QD_PHY_INT_SYMBOL_ERROR            0x200
+#define QD_PHY_INT_FALSE_CARRIER        0x100
+#define QD_PHY_INT_FIFO_FLOW            0x80
+#define QD_PHY_INT_CROSSOVER_CHANGED        0x40
+#define QD_PHY_INT_POLARITY_CHANGED        0x2
+#define QD_PHY_INT_JABBER            0x1
+
+
+/* Bit definition for DEVICE Interrupt */
+#define QD_DEV_INT_WATCHDOG            0x8000
+#define QD_DEV_INT_JAMLIMIT            0x4000
+#define QD_DEV_INT_DUPLEX_MISMATCH    0x2000
+#define QD_DEV_INT_WAKE_EVENT         0x1000
+
+/* Definition for Multi Address Mode */
+#define QD_REG_SMI_COMMAND        0x0
+#define QD_REG_SMI_DATA            0x1
+
+/* Bit definition for QD_REG_SMI_COMMAND */
+#define QD_SMI_BUSY                0x8000
+#define QD_SMI_MODE                0x1000
+#define QD_SMI_MODE_BIT            12
+#define QD_SMI_OP_BIT            10
+#define QD_SMI_OP_SIZE            2
+#define QD_SMI_DEV_ADDR_BIT        5
+#define QD_SMI_DEV_ADDR_SIZE    5
+#define QD_SMI_REG_ADDR_BIT        0
+#define QD_SMI_REG_ADDR_SIZE    5
+
+#define QD_SMI_CLAUSE45            0
+#define QD_SMI_CLAUSE22            1
+
+#define QD_SMI_WRITE            0x01
+#define QD_SMI_READ                0x02
+
+#endif /* __gtDrvSwRegsh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/driver/gtHwCntl.h
@@ -0,0 +1,1083 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtHwCntl.h
+*
+* DESCRIPTION:
+*       Functions declarations for Hw accessing quarterDeck phy, internal and
+*       global registers.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*
+*******************************************************************************/
+
+#ifndef __gtHwCntlh
+#define __gtHwCntlh
+
+#include <msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This macro is used to calculate the register's SMI   */
+/* device address, according to the baseAddr            */
+/* field in the Switch configuration struct.            */
+extern GT_U8 portToSmiMapping(GT_QD_DEV *dev, GT_U8 portNum, GT_U32 accessType);
+#define CALC_SMI_DEV_ADDR(_dev, _portNum, _accessType)        \
+            portToSmiMapping(_dev, _portNum, _accessType)
+
+/* This macro calculates the mask for partial read /    */
+/* write of register's data.                            */
+#define CALC_MASK(fieldOffset,fieldLen,mask)        \
+            if((fieldLen + fieldOffset) >= 16)      \
+                mask = (0 - (1 << fieldOffset));    \
+            else                                    \
+                mask = (((1 << (fieldLen + fieldOffset))) - (1 << fieldOffset))
+
+#define GT_GET_PAGE_ADDR(_regAddr) ((_regAddr<29)?22:29)
+
+/* Start address of phy related register.               */
+#define PHY_REGS_START_ADDR     0x0
+#define PHY_REGS_START_ADDR_8PORT    0x0
+
+/* Start address of ports related register.             */
+#define PORT_REGS_START_ADDR        0x8
+#define PORT_REGS_START_ADDR_8PORT    0x10
+
+/* Start address of global register.                    */
+#define GLOBAL_REGS_START_ADDR  0xF
+#define GLOBAL_REGS_START_ADDR_8PORT  0x1B
+
+#define PHY_ACCESS            1
+#define PORT_ACCESS           2
+#define GLOBAL_REG_ACCESS     3
+#define GLOBAL2_REG_ACCESS    4
+#define GLOBAL3_REG_ACCESS    5
+
+#define QD_SMI_ACCESS_LOOP        1000
+#define QD_SMI_TIMEOUT            2
+
+
+/****************************************************************************/
+/* Phy registers related functions.                                         */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadPhyReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port phy register.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWritePhyReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port phy register.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetPhyRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port phy register.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPhyRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetPhyRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port phy register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPhyRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+/*******************************************************************************
+* hwPhyReset
+*
+* DESCRIPTION:
+*       This function performs softreset and waits until reset completion.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       u16Data     - data should be written into Phy control register.
+*                      if this value is 0xFF, normal operation occcurs (read,
+*                      update, and write back.)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS hwPhyReset
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U8     portNum,
+    IN    GT_U16        u16Data
+);
+
+
+/*******************************************************************************
+* hwReadPagedPhyReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port phy register in page mode.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       pageNum - Page number of the register to be read.
+*       regAddr - The register's address.
+*        anyPage - register list(vector) that are common to all pages
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
+);
+
+
+/*******************************************************************************
+* hwWritePagedPhyReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port phy register in page mode.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       pageNum - Page number of the register to be written.
+*       regAddr - The register's address.
+*        anyPage - Register list(vector) that are common to all pages
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
+);
+
+/*******************************************************************************
+* hwGetPagedPhyRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port phy register
+*        in page mode.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       pageNum     - Page number of the register to be read.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*        anyPage - Register list(vector) that are common to all pages
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPagedPhyRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
+);
+
+/*******************************************************************************
+* hwSetPagedPhyRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port phy register
+*        in page mode
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       pageNum     - Page number of the register to be read.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*        anyPage     - Register list(vector) that are common to all pages
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPagedPhyRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
+);
+
+
+/****************************************************************************/
+/* Per port registers related functions.                                    */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadPortReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port register.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPortReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWritePortReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port register.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePortReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetPortRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPortRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetPortRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPortRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+/*******************************************************************************
+* hwSetPortRegBits
+*
+* DESCRIPTION:
+*       This function writes to specified bits in a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       mask         - The bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
+*            and 0010b is written to bit[3:0]
+*
+*******************************************************************************/
+GT_STATUS hwSetPortRegBits
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   mask,
+    IN  GT_U16   data
+);
+
+/****************************************************************************/
+/* Global registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadGlobalReg
+*
+* DESCRIPTION:
+*       This function reads a switch's global register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobalReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWriteGlobalReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobalReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetGlobalRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobalRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetGlobalRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobalRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+
+/****************************************************************************/
+/* Global 2 registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadGlobal2Reg
+*
+* DESCRIPTION:
+*       This function reads a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobal2Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWriteGlobal2Reg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobal2Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetGlobal2RegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobal2RegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetGlobal2RegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal2RegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+/*******************************************************************************
+* hwSetGlobal2RegBits
+*
+* DESCRIPTION:
+*       This function writes to specified bits in a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       mask         - The bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
+*            and 0010b is written to bit[3:0]
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal2RegBits
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   mask,
+    IN  GT_U16   data
+);
+
+/****************************************************************************/
+/* Global 3 registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadGlobal3Reg
+*
+* DESCRIPTION:
+*       This function reads a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobal3Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWriteGlobal3Reg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobal3Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetGlobal3RegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobal3RegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetGlobal3RegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal3RegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+/*******************************************************************************
+* hwSetGlobal3RegBits
+*
+* DESCRIPTION:
+*       This function writes to specified bits in a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       mask         - The bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
+*            and 0010b is written to bit[3:0]
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal3RegBits
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   mask,
+    IN  GT_U16   data
+);
+
+/*******************************************************************************
+* hwReadMiiReg
+*
+* DESCRIPTION:
+*       This function reads a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadMiiReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWriteMiiReg
+*
+* DESCRIPTION:
+*       This function writes a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteMiiReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+#ifdef GT_RMGMT_ACCESS
+
+/*******************************************************************************
+* hwAccessMultiRegs
+*
+* DESCRIPTION:
+*       This function accesses switch's registers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1
+*     addr - SMI Address
+*     reg  - Register offset
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwAccessMultiRegs
+(
+    IN GT_QD_DEV *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __gtHwCntlh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/msApi/gtVct.h
@@ -0,0 +1,183 @@
+/*******************************************************************************
+*              Copyright 2002, GALILEO TECHNOLOGY, LTD.
+*
+* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL. NO RIGHTS ARE GRANTED
+* HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT OF MARVELL OR ANY THIRD
+* PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE DISCRETION TO REQUEST THAT THIS
+* CODE BE IMMEDIATELY RETURNED TO MARVELL. THIS CODE IS PROVIDED "AS IS".
+* MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED OR OTHERWISE, REGARDING ITS
+* ACCURACY, COMPLETENESS OR PERFORMANCE. MARVELL COMPRISES MARVELL TECHNOLOGY
+* GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, MARVELL INTERNATIONAL LTD. (MIL),
+* MARVELL TECHNOLOGY, INC. (MTI), MARVELL SEMICONDUCTOR, INC. (MSI), MARVELL
+* ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K. (MJKK), GALILEO TECHNOLOGY LTD. (GTL)
+* AND GALILEO TECHNOLOGY, INC. (GTI).
+********************************************************************************
+* gtPhy.h
+*
+* DESCRIPTION:
+*       API definitions for Marvell Phy functionality.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+
+#ifndef __gtPhyh
+#define __gtPhyh
+
+#include "msApi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MARVELL_OUI_MSb        0x0141
+#define MARVELL_OUI_LSb        0x0C00
+#define OUI_LSb_MASK        0xFC00
+#define PHY_MODEL_MASK        0x03F0
+#define PHY_REV_MASK        0x000F
+
+#define DEV_E3082        0x8 << 4
+#define DEV_E104X        0x2 << 4
+#define DEV_E1111        0xC << 4
+#define DEV_E1112        0x9 << 4
+#define DEV_E114X        0xD << 4
+#define DEV_E1149        0xA << 4
+#define DEV_E1181        0xE << 4
+#define DEV_EC010        0x3 << 4
+#define DEV_G15LV        0xB << 4    /* 88E6165 internal copper phy, 88E1240 */
+#define DEV_S15LV        0x0 << 4    /* 88E6165 internal SERDES */
+#define DEV_MELODY       0x26 << 4   /* 88EC000 internal copper phy, 88E3020-88E6250 */
+#define DEV_G65G         0x27 << 4    /* 88E6375 (Amber) internal copper phy, 88E1340 */
+#define DEV_E1540        0x2B << 4    /* 88E6352 (Agate) internal copper phy, 88E1540 */
+
+typedef struct _GT_PHY_INFO
+{
+    GT_U32    phyId;        /* Marvell PHY ID (register 3) */
+    GT_U32    anyPage;    /* each bit represents if the corresponding register is any page */
+    GT_U32    flag;        /* see below for definition */
+    GT_U8    vctType;    /* VCT Register Type */
+    GT_U8    exStatusType;    /* EX Status Register Type */
+    GT_U8    dteType;    /* DTE Register Type */
+    GT_U8    pktGenType;    /* Pkt Generator Reg. Type */
+    GT_U8    macIfLoopType;        /* MAC IF Loopback Reg. Type */
+    GT_U8    lineLoopType;        /* Line Loopback Reg. Type */
+    GT_U8    exLoopType;        /* External Loopback Reg. Type */
+    GT_U8    pageType;        /* Page Restriction Type */
+} GT_PHY_INFO;
+
+/* GT_PHY_INFO flag definition */
+#define GT_PHY_VCT_CAPABLE        0x0001
+#define GT_PHY_DTE_CAPABLE        0x0002
+#define GT_PHY_EX_CABLE_STATUS    0x0004
+#define GT_PHY_ADV_VCT_CAPABLE    0x0008
+#define GT_PHY_PKT_GENERATOR    0x0010
+#define GT_PHY_MAC_IF_LOOP        0x0100
+#define GT_PHY_LINE_LOOP        0x0200
+#define GT_PHY_EXTERNAL_LOOP    0x0400
+#define GT_PHY_RESTRICTED_PAGE    0x0800
+#define GT_PHY_GIGABIT            0x8000
+#define GT_PHY_COPPER             0x4000
+#define GT_PHY_FIBER              0x2000
+#define GT_PHY_SERDES_CORE        0x1000
+
+/* VCT Register Type */
+#define GT_PHY_VCT_TYPE1    1    /* 10/100 Fast Ethernet */
+#define GT_PHY_VCT_TYPE2    2    /* 1000M without page support */
+#define GT_PHY_VCT_TYPE3    3    /* 1000M without page but with work around */
+#define GT_PHY_VCT_TYPE4    4    /* 1000M with page support */
+
+/* ADV VCT Register Type */
+#define GT_PHY_ADV_VCT_TYPE1    5    /* 88E1181 type device, not supported */
+#define GT_PHY_ADV_VCT_TYPE2    6    /* 88E6165 family devies */
+
+/* Extended Status Type */
+#define GT_PHY_EX_STATUS_TYPE1    1    /* 88E1111, 88E1141, 88E1145 */
+#define GT_PHY_EX_STATUS_TYPE2    2    /* 88E1112 */
+#define GT_PHY_EX_STATUS_TYPE3    3    /* 88E1149 */
+#define GT_PHY_EX_STATUS_TYPE4    4    /* 88E1181 */
+#define GT_PHY_EX_STATUS_TYPE5    5    /* 88E1116 */
+#define GT_PHY_EX_STATUS_TYPE6    6    /* 88E6165 family devices */
+
+/* DTE Register Type */
+#define GT_PHY_DTE_TYPE1    1    /* 10/100 Fast Ethernet with workaround */
+#define GT_PHY_DTE_TYPE2    2    /* 1000M without page support */
+#define GT_PHY_DTE_TYPE3    3    /* 1000M without page but with work around */
+#define GT_PHY_DTE_TYPE4    4    /* 1000M with page support */
+#define GT_PHY_DTE_TYPE5    5    /* 10/100 Fast Ethernet */
+
+/* Pkt Generator Register Type */
+#define GT_PHY_PKTGEN_TYPE1    1    /* Uses Register 30 */
+#define GT_PHY_PKTGEN_TYPE2    2    /* Uses Register 16 */
+#define GT_PHY_PKTGEN_TYPE3    3    /* Uses Register 25 */
+
+/* MAC Interface Loopback Register Type */
+#define GT_PHY_LOOPBACK_TYPE0    0    /* Don't do anything */
+#define GT_PHY_LOOPBACK_TYPE1    1    /* 0.14 only */
+#define GT_PHY_LOOPBACK_TYPE2    2    /* For DEV_G15LV like device */
+#define GT_PHY_LOOPBACK_TYPE3    3    /* For DEV_S15LV like device */
+#define GT_PHY_LOOPBACK_TYPE4    4    /* For DEV_E1111 like device */
+
+/* Line Loopback Register Type */
+#define GT_PHY_LINE_LB_TYPE1    1    /* 0_2.14 */
+#define GT_PHY_LINE_LB_TYPE2    2    /* 21_2.14 */
+#define GT_PHY_LINE_LB_TYPE3    3    /* 20.14 */
+#define GT_PHY_LINE_LB_TYPE4    4    /* 16.12 */
+
+/* External Loopback Register Type */
+#define GT_PHY_EX_LB_TYPE0    0    /* Don't do anything */
+#define GT_PHY_EX_LB_TYPE1    1    /* For DEV_E1111 like dev */
+#define GT_PHY_EX_LB_TYPE2    2    /* For DEV_E1149 like dev */
+
+/* Restricted Page Access Type */
+#define GT_PHY_PAGE_WRITE_BACK    0    /* For every device */
+#define GT_PHY_PAGE_DIS_AUTO1    1    /* For 88E1111 type */
+#define GT_PHY_PAGE_DIS_AUTO2    2    /* For 88E1121 type */
+#define GT_PHY_NO_PAGE            3    /* No Pages */
+
+
+/* definition for formula to calculate actual distance */
+#ifdef FP_SUPPORT
+#define FORMULA_PHY100M(_data)    ((_data)*0.7861 - 18.862)
+#define FORMULA_PHY1000M(_data)    ((_data)*0.8018 - 28.751)
+#else
+#define FORMULA_PHY100M(_data)    (((long)(_data)*7861 - 188620)/10000 + (((((long)(_data)*7861 - 188620)%10000) >= 5000)?1:0))
+#define FORMULA_PHY1000M(_data)    (((long)(_data)*8018 - 287510)/10000 + (((((long)(_data)*8018 - 287510)%10000) >= 5000)?1:0))
+#endif
+
+#define GT_ADV_VCT_CALC(_data)        \
+        (((long)(_data)*8333 - 191667)/10000 + (((((long)(_data)*8333 - 191667)%10000) >= 5000)?1:0))
+
+#define GT_ADV_VCT_CALC_SHORT(_data)        \
+        (((long)(_data)*7143 - 71429)/10000 + (((((long)(_data)*7143 - 71429)%10000) >= 5000)?1:0))
+
+/* macro to check VCT Failure */
+#define IS_VCT_FAILED(_reg)        \
+        (((_reg) & 0xFF) == 0xFF)
+
+/* macro to find out if Amplitude is zero */
+#define IS_ZERO_AMPLITUDE(_reg)    \
+        (((_reg) & 0x7F00) == 0)
+
+/* macro to retrieve Amplitude */
+#define GET_AMPLITUDE(_reg)    \
+        (((_reg) & 0x7F00) >> 8)
+
+/* macro to find out if Amplitude is positive */
+#define IS_POSITIVE_AMPLITUDE(_reg)    \
+        (((_reg) & 0x8000) == 0x8000)
+
+typedef struct _VCT_REGISTER
+{
+    GT_U8    page;
+    GT_U8    regOffset;
+} VCT_REGISTER;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtPhyh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/msApi/msApiInternal.h
@@ -0,0 +1,1813 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* msApiPrototype.h
+*
+* DESCRIPTION:
+*       API Prototypes for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiInternal_h
+#define __msApiInternal_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef GT_USE_SIMPLE_PORT_MAPPING
+#define GT_LPORT_2_PORT(_lport)      (GT_U8)((_lport) & 0xff)
+#define GT_PORT_2_LPORT(_port)       (GT_LPORT)((_port) & 0xff)
+#define GT_LPORTVEC_2_PORTVEC(_lvec)      (GT_U32)((_lvec) & 0xffff)
+#define GT_PORTVEC_2_LPORTVEC(_pvec)       (GT_U32)((_pvec) & 0xffff)
+#define GT_LPORT_2_PHY(_lport)      (GT_U8)((_lport) & 0xff)
+#else
+ #define GT_LPORT_2_PHY(_lport)       lport2phy(dev,_lport)
+ #ifdef GT_PORT_MAP_IN_DEV
+  #define GT_LPORT_2_PORT(_lport)      dev->lport2port(dev->validPortVec, _lport)
+  #define GT_PORT_2_LPORT(_port)       dev->port2lport(dev->validPortVec, _port)
+  #define GT_LPORTVEC_2_PORTVEC(_lvec) dev->lportvec2portvec(dev->validPortVec, _lvec)
+  #define GT_PORTVEC_2_LPORTVEC(_pvec) dev->portvec2lportvec(dev->validPortVec, _pvec)
+ #else
+  #define GT_LPORT_2_PORT(_lport)      lport2port(dev->validPortVec, _lport)
+  #define GT_PORT_2_LPORT(_port)       port2lport(dev->validPortVec, _port)
+  #define GT_LPORTVEC_2_PORTVEC(_lvec) lportvec2portvec(dev->validPortVec, _lvec)
+  #define GT_PORTVEC_2_LPORTVEC(_pvec) portvec2lportvec(dev->validPortVec, _pvec)
+#endif
+
+#endif
+
+#define GT_IS_PORT_SET(_portVec, _port)    \
+            ((_portVec) & (0x1 << (_port)))
+
+#define GT_IS_IRLUNIT_VALID(_dev,_unit)        \
+        (((_dev)->deviceId == GT_88E6065)?(_unit < 12):    \
+        (((_dev)->deviceId == GT_88E6055)?(_unit < 12):    \
+        (((_dev)->deviceId == GT_88E6061)?(_unit < 6):    \
+        (((_dev)->deviceId == GT_88E6035)?(_unit < 6):    \
+                                         (_unit < 3)))))
+
+
+/* The following macro converts a binary    */
+/* value (of 1 bit) to a boolean one.       */
+/* 0 --> GT_FALSE                           */
+/* 1 --> GT_TRUE                            */
+#define BIT_2_BOOL(binVal,boolVal)                                  \
+            (boolVal) = (((binVal) == 0) ? GT_FALSE : GT_TRUE)
+
+/* The following macro converts a boolean   */
+/* value to a binary one (of 1 bit).        */
+/* GT_FALSE --> 0                           */
+/* GT_TRUE --> 1                            */
+#define BOOL_2_BIT(boolVal,binVal)                                  \
+            (binVal) = (((boolVal) == GT_TRUE) ? 1 : 0)
+
+/* The following macro converts a binary    */
+/* value (of 1 bit) to a boolean one.       */
+/* 0 --> GT_TRUE                            */
+/* 1 --> GT_FALSE                           */
+#define BIT_2_BOOL_R(binVal,boolVal)                                  \
+            (boolVal) = (((binVal) == 0) ? GT_TRUE : GT_FALSE)
+
+/* The following macro converts a boolean   */
+/* value to a binary one (of 1 bit).        */
+/* GT_FALSE --> 1                           */
+/* GT_TRUE --> 0                            */
+#define BOOL_2_BIT_R(boolVal,binVal)                                  \
+            (binVal) = (((boolVal) == GT_TRUE) ? 0 : 1)
+
+/* Bit definition for devStorage */
+/* Ingress/Egress Rate type (grcSetPri0Rate,    grcSetEgressRate) */
+#define GT_RATE_ENUM_NOT_USED        0x10000
+#define GT_RATE_ENUM_USED        0x00000
+
+/* device name - devName */
+#define DEV_88E6051              0x0001    /* quarterdeck 6051      */
+#define DEV_88E6052              0x0002    /* quarterdeck 6052      */
+#define DEV_88E6021              0x0004    /* fullsail              */
+#define DEV_88E6060              0x0008    /* Gondola               */
+#define DEV_88E6063              0x0010    /* clippership 6063      */
+#define DEV_FF_EG                0x0020    /* FireFox-EG            */
+#define DEV_FF_HG                0x0040    /* FireFox-HG            */
+#define DEV_FH_VPN               0x0080    /* FireHawk-VPN          */
+#define DEV_88E6083              0x0100    /* Octane 6083           */
+#define DEV_88E6181              0x0200    /* Sapphire 88E6181      */
+#define DEV_88E6183              0x0400    /* Sapphire 88E6153,88E6183 */
+#define DEV_88E6093                 0x0800   /* 88E6093                  */
+#define DEV_88E6092                 0x1000   /* 88E6092                  */
+#define DEV_88E6095              0x2000   /* 88E6095                  */
+#define DEV_88E6182              0x4000   /* Jade 88E6152, 88E6182 */
+#define DEV_88E6185              0x8000   /* Jade 88E6155, 88E6185 */
+#define DEV_88E6108              0x10000   /* 88E6108 */
+#define DEV_88E6061              0x20000   /* 88E6031, 88E6061 */
+#define DEV_88E6065              0x40000   /* 88E6035, 88E6055, 88E6065 */
+#define DEV_88E6096              0x80000   /* 88E6096, 88E6046 */
+#define DEV_88E6097              0x100000   /* 88E6097, 88E6047 */
+#define DEV_88E6161              0x200000   /* 88E6161 */
+#define DEV_88E6165              0x400000   /* 88E6165 */
+#define DEV_88E6351              0x800000   /* 88E6351 */
+#define DEV_88E6175              0x1000000  /* 88E6175 */
+#define DEV_88E6171              0x2000000  /* 88E6125 and 88E6171 */
+#define DEV_88E6371              0x4000000  /* 88E6321, 88E6350 */
+#define DEV_88E6172              0x8000000  /* 88E6172 */
+#define DEV_88E6176              0x10000000 /* 88E6176 */
+#define DEV_88E6240              0x20000000 /* 88E6240 */
+#define DEV_88E6352              0x40000000 /* 88E6352 */
+
+/* device name 1 - devName1. These name for extended device family */
+#define DEV_88EC000                      0x000000001  /* Melody 88EC0XX  */
+#define DEV_88E3020                      0x000000010  /* Spannaker 88E3020  */
+#define DEV_88E6020                      0x000000020  /* Spannaker 88E6020  */
+#define DEV_88E6070                      0x000000040  /* Spannaker 88E6070  */
+#define DEV_88E6071                      0x000000080  /* Spannaker 88E6071  */
+#define DEV_88E6220                      0x000000100  /* Spannaker 88E6220  */
+#define DEV_88E6250                      0x000000200  /* Spannaker 88E6250  */
+
+#define DEV_88E6125                      0x000000400  /* Pearl 88E6125  */
+#define DEV_88E6320                      0x000000800  /* Pearl 88E6320  */
+#define DEV_88E6115                      0x000001000  /* Pearl 88E6115  */
+#define DEV_88E6310                      0x000002000  /* Pearl 88E6310  */
+
+#define DEV_88E6097_FAMILY    ( DEV_88E6096 | DEV_88E6097 )
+#define G1_DEV_88E6097_FAMILY     0
+#define DEV_88E6165_FAMILY    ( DEV_88E6161 | DEV_88E6165 )
+#define G1_DEV_88E6165_FAMILY     0
+
+/* Amber */
+#define DEV_88E6351_AVB_FAMILY    ( DEV_88E6351 | DEV_88E6371 )
+#define G1_DEV_88E6351_AVB_FAMILY      0
+#define DEV_88E6351_NO_AVB_FAMILY    (DEV_88E6171 | DEV_88E6175)
+#define G1_DEV_88E6351_NO_AVB_FAMILY   0
+#define DEV_88E6351_FAMILY    ( DEV_88E6351_AVB_FAMILY | DEV_88E6351_NO_AVB_FAMILY)
+#define G1_DEV_88E6351_FAMILY      0
+
+/* Agate */
+#define DEV_88E6352_AVB_FAMILY    ( DEV_88E6352 | DEV_88E6240 )
+#define G1_DEV_88E6352_AVB_FAMILY      0
+#define DEV_88E6352_NO_AVB_FAMILY    (DEV_88E6172 | DEV_88E6176)
+#define G1_DEV_88E6352_NO_AVB_FAMILY   0
+#define DEV_88E6352_FAMILY    ( DEV_88E6352_AVB_FAMILY | DEV_88E6352_NO_AVB_FAMILY)
+#define G1_DEV_88E6352_FAMILY      0
+
+/* Pearl */
+#define DEV_88E6320_AVB_FAMILY      0
+#define G1_DEV_88E6320_AVB_FAMILY    (DEV_88E6320 | DEV_88E6310)
+#define DEV_88E6320_NO_AVB_FAMILY   0
+#define G1_DEV_88E6320_NO_AVB_FAMILY    (DEV_88E6125 | DEV_88E6115)
+#define DEV_88E6320_FAMILY      0
+#define G1_DEV_88E6320_FAMILY    (G1_DEV_88E6320_AVB_FAMILY | G1_DEV_88E6320_NO_AVB_FAMILY)
+
+/* AVB family includes all avb chips except Melody and SpannakAv */
+#define DEV_AVB_FAMILY    ( DEV_88E6351_AVB_FAMILY | DEV_88E6352_AVB_FAMILY)
+#define G1_DEV_AVB_FAMILY      (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_TCAM_FAMILY    (DEV_88E6352_AVB_FAMILY)
+#define G1_DEV_TCAM_FAMILY      (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_88EC000_FAMILY            0
+#define G1_DEV_88EC000_FAMILY     (DEV_88EC000)
+#define DEV_88ESPANNAK_FAMILY            0
+#define G1_DEV_88ESPANNAK_FAMILY  (DEV_88E3020 | DEV_88E6020 | DEV_88E6070 | DEV_88E6071 | DEV_88E6220  | DEV_88E6250 )
+#define DEV_FE_AVB_FAMILY            0
+#define G1_DEV_FE_AVB_FAMILY     ( G1_DEV_88EC000_FAMILY | G1_DEV_88ESPANNAK_FAMILY )
+
+#define G1_DEV_88E6171_FAMILY   0
+#define DEV_88E6095_FAMILY    ( DEV_88E6092 | DEV_88E6095 )
+#define G1_DEV_88E6095_FAMILY     0
+#define DEV_88E6185_FAMILY    ( DEV_88E6182 | DEV_88E6185 | DEV_88E6108)
+#define G1_DEV_88E6185_FAMILY     0
+
+#define DEV_88E6065_FAMILY    ( DEV_88E6061 | DEV_88E6065 )
+#define G1_DEV_88E6065_FAMILY     0
+
+#define DEV_NEW_FEATURE_IN_REV (DEV_88E6095_FAMILY | DEV_88E6182 | DEV_88E6185)
+#define G1_DEV_NEW_FEATURE_IN_REV  0
+
+#define DEV_BURST_RATE        ( DEV_88E6108 )
+#define G1_DEV_BURST_RATE     0
+#define DEV_DROP_BCAST        ( DEV_88E6108 )
+#define G1_DEV_DROP_BCAST     0
+#define DEV_ARP_PRI            ( DEV_88E6108 )
+#define G1_DEV_ARP_PRI             0
+#define DEV_SNOOP_PRI            ( DEV_88E6108 )
+#define G1_DEV_SNOOP_PRI      0
+#define DEV_SERDES_CORE    ( DEV_88E6108 | DEV_88E6165_FAMILY  | DEV_88E6352_FAMILY )
+#define G1_DEV_SERDES_CORE     (DEV_88E6320_FAMILY)
+
+#define DEV_AGE_INTERRUPT  ( DEV_88E6108 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_AGE_INTERRUPT       ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+#define DEV_AGE_INT_GLOBAL2    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_AGE_INT_GLOBAL2     (G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+#define DEV_AGE_OUT_INT        ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_AGE_OUT_INT     ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_AGE_HOLD        ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_AGE_HOLD         ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_DEVICE_INTERRUPT    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_DEVICE_INTERRUPT    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_DEVICE_INT_TYPE1    ( DEV_88E6097_FAMILY )    /* Serdes Int bit[10:8] */
+#define G1_DEV_DEVICE_INT_TYPE1    0    /* Serdes Int bit[10:8] */
+#define DEV_DEVICE_INT_TYPE2    ( DEV_88E6165_FAMILY)
+#define G1_DEV_DEVICE_INT_TYPE2    0
+#define DEV_DEVICE_INT_TYPE3    (  DEV_88E6352_FAMILY )
+#define G1_DEV_DEVICE_INT_TYPE3    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_WATCHDOG_EVENT    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_WATCHDOG_EVENT    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_PORT_BASED_AGE_INT    ( DEV_88E6065_FAMILY )
+#define G1_DEV_PORT_BASED_AGE_INT    0
+#define DEV_DEV_PHY_INTERRUPT    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)    /* device interrupt includes phy int */
+#define G1_DEV_DEV_PHY_INTERRUPT    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )    /* device interrupt includes phy int */
+
+#define DEV_AVB_INTERRUPT      ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_AVB_INTERRUPT      ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_AUTO_REFRESH_LOCKED    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_AUTO_REFRESH_LOCKED    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_PPU_PHY_ACCESS    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_PPU_PHY_ACCESS    0
+#define DEV_PPU_PHY_ACCESS_RES    ( DEV_88E6097_FAMILY | G1_DEV_88E6320_FAMILY )
+#define G1_DEV_PPU_PHY_ACCESS_RES    0
+
+#define DEV_PPU_READ_ONLY    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_PPU_READ_ONLY     (G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+
+#define DEV_PPU_SERDES_ACCESS_RES    ( DEV_88E6165_FAMILY | DEV_88E6352_FAMILY )
+#define G1_DEV_PPU_SERDES_ACCESS_RES      0
+
+#define DEV_SERDES_ACCESS_CONFIG    ( DEV_88E6165_FAMILY | DEV_88E6352_FAMILY )
+#define G1_DEV_SERDES_ACCESS_CONFIG      0
+
+#define DEV_NO_EGRESS_POLICY    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_NO_EGRESS_POLICY    (G1_DEV_88E6320_FAMILY)
+
+/* DEV_8PORT_SWITCH is used to access the given device's Register Map */
+#define DEV_8PORT_SWITCH    ( DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | \
+        DEV_88E6097_FAMILY | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | \
+        DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_8PORT_SWITCH (G1_DEV_88E6320_FAMILY)
+
+/* DEV_MELODY_SWITCH is used to access the given device's Register Map */
+#define DEV_MELODY_SWITCH    0
+#define G1_DEV_MELODY_SWITCH    ( DEV_88EC000 | G1_DEV_88ESPANNAK_FAMILY )
+
+#define DEV_PORT_SECURITY    ( DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_PORT_SECURITY    0
+
+#define DEV_BROADCAST_INVALID    ( DEV_88E6051 | DEV_88E6052 | DEV_FF_EG | DEV_FF_HG)
+#define G1_DEV_BROADCAST_INVALID 0
+
+/* Configurable ATU Size */
+#define DEV_ATU_256_2048     ( DEV_88E6021 | DEV_88E6060 | DEV_88E6065_FAMILY )
+#define G1_DEV_ATU_256_2048     0
+#define DEV_ATU_562_2048     ( DEV_88E6052 | DEV_88E6063 | DEV_FF_HG | DEV_FH_VPN | DEV_88E6083 )
+#define G1_DEV_ATU_562_2048     0
+
+#define DEV_ATU_SIZE_FIXED    DEV_GIGABIT_SWITCH
+#define G1_DEV_ATU_SIZE_FIXED    G1_DEV_GIGABIT_SWITCH
+
+#define DEV_ATU_1024    (DEV_88E6108)    /* Not used */
+#define G1_DEV_ATU_1024    0    /* Not used */
+#define DEV_ATU_8192    (DEV_88E6095_FAMILY | DEV_88E6182 | DEV_88E6185)    /* Not used */
+#define G1_DEV_ATU_8192    0    /* Not used */
+
+#define DEV_ATU_LIMIT        ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_ATU_LIMIT    (G1_DEV_88E6320_FAMILY)
+
+#define DEV_ATU_LIMIT_READ    ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_ATU_LIMIT_READ    (G1_DEV_88E6320_FAMILY)
+
+#define DEV_DBNUM_FULL     ( DEV_88E6021 | DEV_88E6060 | DEV_88E6063 |     \
+      DEV_FH_VPN |  DEV_88E6083 |  DEV_88E6183 | DEV_88E6093 | DEV_88E6061 )
+#define G1_DEV_DBNUM_FULL     0
+
+#define DEV_DBNUM_64     ( DEV_88E6065 )
+#define G1_DEV_DBNUM_64     ( G1_DEV_88EC000_FAMILY  | G1_DEV_88ESPANNAK_FAMILY)
+#define DEV_DBNUM_256     ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_DBNUM_256     0
+#define DEV_DBNUM_4096     ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_DBNUM_4096    (G1_DEV_88E6320_FAMILY)
+
+#define DEV_STATIC_ADDR    ( DEV_88E6060 | DEV_88E6021 | DEV_FF_EG | DEV_FF_HG | DEV_88E6052 | DEV_88E6063 | \
+            DEV_FH_VPN | DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |     \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_STATIC_ADDR    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_TRAILER     ( DEV_88E6021 | DEV_FF_HG | DEV_88E6052 |          \
+      DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+#define G1_DEV_TRAILER     0
+
+#define DEV_TRAILER_P5        ( DEV_FF_EG )
+#define G1_DEV_TRAILER_P5    0
+#define DEV_TRAILER_P4P5    (DEV_88E6060)
+#define G1_DEV_TRAILER_P4P5    0
+
+#define DEV_HEADER    ( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 |    DEV_88E6183 | \
+        DEV_88E6093 |  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |    \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_HEADER    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_HEADER_P5        ( DEV_FF_EG )
+#define G1_DEV_HEADER_P5    0
+#define DEV_HEADER_P4P5      (DEV_88E6060)
+#define G1_DEV_HEADER_P4P5      0
+
+/* DEV_QoS : Devices with multiple Queues for QoS Priority Support */
+#define DEV_QoS        ( DEV_88E6021 | DEV_FF_HG | DEV_88E6051 | DEV_88E6052 | DEV_88E6063 | \
+        DEV_FH_VPN | DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | \
+        DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | DEV_88E6065_FAMILY |     \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_QoS    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_QoS_FPRI_QPRI    ( DEV_88E6065_FAMILY )
+#define G1_DEV_QoS_FPRI_QPRI    0
+
+#define DEV_QoS_WEIGHT        ( DEV_88E6097 | DEV_88E6165 | DEV_AVB_FAMILY | DEV_88E6175 | DEV_88E6352_FAMILY)
+#define G1_DEV_QoS_WEIGHT    (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_TAGGING            (DEV_QoS)
+#define G1_DEV_TAGGING         (G1_DEV_QoS)
+
+#define DEV_EGRESS_DOUBLE_TAGGING ( DEV_QoS & ~(DEV_88E6051 | DEV_88E6092 | DEV_88E6182 | DEV_88E6061))
+#define G1_DEV_EGRESS_DOUBLE_TAGGING 0
+
+#define DEV_INGRESS_DOUBLE_TAGGING    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+      DEV_88E6095 | DEV_88E6185 | DEV_88E6108 )
+#define G1_DEV_INGRESS_DOUBLE_TAGGING    0
+
+#define DEV_PRIORITY_REMAPPING        ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | DEV_88E6095 | \
+    DEV_88E6185 | DEV_88E6108 | DEV_88E6065 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_PRIORITY_REMAPPING  ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+
+#define DEV_802_1Q    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |     \
+              DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |     \
+              DEV_88E6095 | DEV_88E6092 | DEV_88E6185_FAMILY |\
+              DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |    \
+              DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_802_1Q    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_802_1S    ( DEV_88E6095 | DEV_88E6185 | DEV_88E6108 | DEV_88E6065 )
+#define G1_DEV_802_1S    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_802_1S_STU    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_802_1S_STU    0
+
+#define DEV_802_1W    ( DEV_88E6183 | DEV_88E6093 | DEV_88E6095 |     \
+              DEV_88E6185 | DEV_88E6108 | DEV_88E6065 |    \
+              DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_802_1W    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_ATU_15SEC_AGING    ( DEV_GIGABIT_SWITCH | DEV_88E6065_FAMILY )
+#define G1_DEV_ATU_15SEC_AGING    0
+#define DEV_ATU_RM_PORTS    ( DEV_88E6093_FAMILY | DEV_88E6065 )
+#define G1_DEV_ATU_RM_PORTS    0
+#define DEV_ATU_EXT_PRI        ( DEV_88E6065_FAMILY )
+#define G1_DEV_ATU_EXT_PRI     ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_VTU_EXT_INFO    ( DEV_88E6065_FAMILY )
+#define G1_DEV_VTU_EXT_INFO    0
+#define DEV_RMON    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |     \
+              DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |     \
+              DEV_88E6092 | DEV_88E6095 | DEV_88E6185_FAMILY |\
+              DEV_88E6065 | DEV_88E6097_FAMILY |        \
+              DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_RMON    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_RMON_TYPE_1    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+#define G1_DEV_RMON_TYPE_1    0
+#define DEV_RMON_TYPE_2 ( DEV_88E6183 )
+#define G1_DEV_RMON_TYPE_2 0
+#define DEV_RMON_TYPE_3     \
+        ( DEV_88E6093 | DEV_88E6095 | DEV_88E6092 |     \
+          DEV_88E6185_FAMILY | DEV_88E6065 |             \
+          DEV_88E6097_FAMILY |        \
+          DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_RMON_TYPE_3 ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_RMON_REALTIME_SUPPORT    \
+        ( DEV_88E6065 | DEV_88E6065_FAMILY |    \
+          DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |    \
+          DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_RMON_REALTIME_SUPPORT    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+#define DEV_RMON_PORT_BITS    \
+        ( DEV_88E6065 | DEV_88E6065 | DEV_88E6352_FAMILY )
+#define G1_DEV_RMON_PORT_BITS    \
+   ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+
+#define DEV_IGMP_SNOOPING    \
+    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |         \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |            \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |            \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_IGMP_SNOOPING    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_PORT_MONITORING    \
+    ( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |         \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |            \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |            \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PORT_MONITORING    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_ENABLE_MONITORING    \
+    ( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |            \
+      DEV_88E6065_FAMILY )
+#define G1_DEV_ENABLE_MONITORING    0
+#define DEV_MC_RATE_PERCENT    ( DEV_88E6021 | DEV_88E6051 | DEV_88E6052 )
+#define G1_DEV_MC_RATE_PERCENT    0
+
+#define DEV_MC_RATE_KBPS    ( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+#define G1_DEV_MC_RATE_KBPS    0
+
+#define DEV_INGRESS_RATE_KBPS    \
+    ( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6181 | DEV_88E6183 |         \
+      DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY)
+#define G1_DEV_INGRESS_RATE_KBPS 0
+
+#define DEV_EGRESS_RATE_KBPS    \
+    ( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6181 | DEV_88E6183 |         \
+      DEV_88E6093 | DEV_88E6095 | DEV_88E6185 |         \
+      DEV_88E6108 | DEV_88E6065_FAMILY |                 \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |         \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_EGRESS_RATE_KBPS    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+
+#define DEV_ELIMIT_FRAME_BASED    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ELIMIT_FRAME_BASED    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_PIRL_RESOURCE    \
+    ( DEV_88E6065_FAMILY )
+#define G1_DEV_PIRL_RESOURCE    0
+
+#define DEV_PIRL2_RESOURCE    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PIRL2_RESOURCE     \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_RESTRICTED_PIRL_RESOURCE    \
+    ( DEV_88E6061 )
+#define G1_DEV_RESTRICTED_PIRL_RESOURCE    0
+
+#define DEV_RESTRICTED_PIRL2_RESOURCE    \
+                        ( DEV_88E6096 | DEV_88E6161 | DEV_88E6171 )
+#define G1_DEV_RESTRICTED_PIRL2_RESOURCE    0
+
+#define DEV_NONE_RATE_LIMIT        \
+    ( DEV_88E6065 )
+#define G1_DEV_NONE_RATE_LIMIT        0
+
+#define DEV_MII_DUPLEX_CONFIG    \
+    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 )
+#define G1_DEV_MII_DUPLEX_CONFIG    0
+
+#define DEV_QD_PLUS     \
+    ( DEV_88E6021 | DEV_FF_EG | DEV_FF_HG |            \
+      DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |        \
+      DEV_88E6083 | DEV_88E6181 | DEV_88E6183 |             \
+      DEV_88E6093 |                        \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY  |            \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_QD_PLUS     \
+    ( G1_DEV_88E6320_FAMILY )
+
+#define DEV_FASTETH_SWITCH    \
+    ( DEV_88E6051 | DEV_88E6052 | DEV_88E6021 |         \
+      DEV_FF_EG | DEV_FF_HG | DEV_88E6060 |             \
+      DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 |            \
+      DEV_88E6065_FAMILY )
+#define G1_DEV_FASTETH_SWITCH    0
+#define DEV_ENHANCED_FE_SWITCH        ( DEV_88E6065_FAMILY )
+#define G1_DEV_ENHANCED_FE_SWITCH    0
+
+#define DEV_EXTERNAL_PHY    \
+    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |            \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |            \
+      DEV_88E6097_FAMILY )
+#define G1_DEV_EXTERNAL_PHY    0
+
+#define DEV_EXTERNAL_PHY_ONLY    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6182 | DEV_88E6185 )
+#define G1_DEV_EXTERNAL_PHY_ONLY    0
+
+#define DEV_INTERNAL_GPHY   ( DEV_88E6108 )
+#define G1_DEV_INTERNAL_GPHY   0
+
+#define DEV_FC_WITH_VALUE            \
+    ( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |    \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |            \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FC_WITH_VALUE            \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_FC_STATUS                \
+    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |     \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |        \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FC_STATUS                \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_FC_DIS_STATUS    ( DEV_88E6065_FAMILY )
+#define G1_DEV_FC_DIS_STATUS    0
+
+#define DEV_CORE_TAG    ( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_CORE_TAG    0
+#define DEV_PCS_LINK    ( DEV_88E6093 | DEV_88E6095_FAMILY |     \
+              DEV_88E6185_FAMILY | DEV_88E6097_FAMILY |    \
+              DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PCS_LINK    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_MGMII_STATUS    ( DEV_88E6093 | DEV_88E6095_FAMILY |     \
+                  DEV_88E6185_FAMILY | DEV_88E6097_FAMILY | \
+                  DEV_88E6165_FAMILY )
+#define G1_DEV_MGMII_STATUS    0
+
+#define DEV_MGMII_REVERSE_STATUS    ( DEV_88E6165_FAMILY )
+#define G1_DEV_MGMII_REVERSE_STATUS    0
+
+#define DEV_88E6183_FAMILY        ( DEV_88E6183 | DEV_88E6185_FAMILY )
+#define G1_DEV_88E6183_FAMILY        0
+
+/* New released switch chips After 6093 chip */
+#define DEV_88E6093_FAMILY    ( DEV_88E6093 | DEV_88E6095_FAMILY |\
+                  DEV_88E6185_FAMILY | DEV_88E6097_FAMILY |\
+                  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_88E6093_FAMILY    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_UNMANAGED_SWITCH    ( DEV_88E6181 )
+#define G1_DEV_UNMANAGED_SWITCH    0
+
+#define DEV_PCS                    \
+        ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+          DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |     \
+          DEV_88E6097_FAMILY )
+#define G1_DEV_PCS                    0
+
+#define DEV_GIGABIT_SWITCH        \
+        ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+          DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |     \
+          DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+          DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_GIGABIT_SWITCH        (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_GIGABIT_MANAGED_SWITCH    \
+        ( DEV_88E6183 | DEV_88E6093 | \
+          DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |     \
+          DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+          DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_GIGABIT_MANAGED_SWITCH    (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_CASCADE_PORT    \
+        ( DEV_88E6183 | DEV_88E6093 | \
+          DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_CASCADE_PORT 0
+
+
+#define DEV_CROSS_CHIP_VLAN        \
+        ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_CROSS_CHIP_VLAN        0
+
+#define DEV_CROSS_CHIP_PORT_VLAN    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |    \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_CROSS_CHIP_PORT_VLAN    (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_TRUNK    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |    \
+              DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |    \
+              DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_TRUNK    (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_8_TRUNKING    ( DEV_88E6092 | DEV_88E6182 )
+#define G1_DEV_8_TRUNKING    0
+
+#define DEV_TRUNK_NEW_ID_LOCATION    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_TRUNK_NEW_ID_LOCATION     (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_REDUCED_TRUNK    ( DEV_88E6065_FAMILY )
+#define G1_DEV_REDUCED_TRUNK   \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_STACKING    \
+    ( DEV_88E6095 | DEV_88E6185 | DEV_88E6108 |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_STACKING    (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_FRAME_SIZE_1632        \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )        /* Not used */
+#define G1_DEV_FRAME_SIZE_1632        0        /* Not used */
+
+#define DEV_FLOW_CTRL_DELAY        \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FLOW_CTRL_DELAY        (G1_DEV_88E6320_AVB_FAMILY)
+
+/* port based CPU Port */
+#define DEV_ENHANCED_CPU_PORT    \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ENHANCED_CPU_PORT    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+
+#define DEV_CPU_DEST_PER_PORT    \
+    ( DEV_88E6183 | DEV_88E6093 | \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_CPU_DEST_PER_PORT   0
+
+#define DEV_CPU_PORT    ( DEV_88E6065_FAMILY )
+#define G1_DEV_CPU_PORT    0
+#define DEV_MULTICAST    ( DEV_88E6065_FAMILY )
+#define G1_DEV_MULTICAST    0
+
+#define DEV_CPU_DEST        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_CPU_DEST        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_AVB_FAMILY)
+#define DEV_MIRROR_DEST    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_MIRROR_DEST    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_QVLAN_ONLY        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY )
+#define G1_DEV_QVLAN_ONLY        0
+#define DEV_5BIT_PORT        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_5BIT_PORT        \
+    ( G1_DEV_FE_AVB_FAMILY|G1_DEV_88E6320_AVB_FAMILY)
+#define DEV_SDET_POLARITY    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY )
+#define G1_DEV_SDET_POLARITY    0
+#define DEV_LIMITED_SDET    \
+        ( DEV_88E6165_FAMILY )     /* only port 4 & 5 support SDET Polarity */
+
+#define G1_DEV_LIMITED_SDET    0    /* only port 4 & 5 support SDET Polarity */
+
+/* supports Reserved Multicast, etc */
+#define DEV_ENHANCED_MULTICAST    \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ENHANCED_MULTICAST    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_ENHANCED_MULTICAST_2X    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ENHANCED_MULTICAST_2X    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+
+#define DEV_ARP_DEST_SUPPORT    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_ARP_DEST_SUPPORT    ( G1_DEV_88E6095_FAMILY | G1_DEV_88E6185_FAMILY )
+#define DEV_MARVELL_TAG_FLOW_CTRL    \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_MARVELL_TAG_FLOW_CTRL    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_USE_DOUBLE_TAG_DATA        \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )        /* Not Used */
+#define G1_DEV_USE_DOUBLE_TAG_DATA        0        /* Not Used */
+
+#define DEV_MARVELL_TAG_LOOP_BLOCK    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_MARVELL_TAG_LOOP_BLOCK    0
+
+#define DEV_LOOPBACK_FILTER        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_LOOPBACK_FILTER        \
+    (G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_FLOOD_BROADCAST        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FLOOD_BROADCAST        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_TAG_FLOW_CONTROL        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_TAG_FLOW_CONTROL        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_ALWAYS_USE_VTU        ( DEV_88E6097_FAMILY )
+#define G1_DEV_ALWAYS_USE_VTU        0
+
+#define DEV_RM_ONE_PTAG            \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_RM_ONE_PTAG            \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+
+#define DEV_PRIORITY_OVERRIDE    \
+    ( DEV_88E6183 | DEV_88E6093 | DEV_88E6095 |     \
+      DEV_88E6185 | DEV_88E6108 | DEV_88E6097_FAMILY |    \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PRIORITY_OVERRIDE    \
+      ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+
+#define DEV_EXT_PRIORITY_OVERRIDE        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_EXT_PRIORITY_OVERRIDE        \
+      ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY)
+
+#define DEV_PRIORITY_OVERRIDE_TABLE    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PRIORITY_OVERRIDE_TABLE    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_FQPRI_IN_TABLE        ( DEV_88E6065 )
+#define G1_DEV_FQPRI_IN_TABLE     0
+
+#define DEV_MACPRI_IN_TABLE        0
+#define G1_DEV_MACPRI_IN_TABLE     ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_FQPRI_OVERRIDE        ( DEV_88E6065 )
+#define G1_DEV_FQPRI_OVERRIDE        0
+
+#define DEV_Px_MODE     ( DEV_88E6065_FAMILY )
+#define G1_DEV_Px_MODE     0
+
+#define DEV_SA_FILTERING    \
+    ( DEV_88E6065 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_SA_FILTERING    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_ARP_TO_CPU        \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ARP_TO_CPU        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_EGRESS_FLOOD    \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_EGRESS_FLOOD    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_FORCE_MAP        ( DEV_88E6065_FAMILY )
+#define G1_DEV_FORCE_MAP    0
+
+#define DEV_PORT_SCHEDULE    ( DEV_88E6065 )
+#define G1_DEV_PORT_SCHEDULE    0
+
+#define DEV_PORT_MIXED_SCHEDULE        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PORT_MIXED_SCHEDULE        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_OUT_Q_SIZE        \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_OUT_Q_SIZE        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_OUT_Q_512        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_OUT_Q_512        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_FULL_Q_COUNTER        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FULL_Q_COUNTER        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_PROVIDER_TAG    ( DEV_88E6065_FAMILY )
+#define G1_DEV_PROVIDER_TAG    0
+
+#define DEV_OLD_HEADER        ( DEV_88E6065_FAMILY )
+#define G1_DEV_OLD_HEADER        0
+#define DEV_RECURSIVE_TAG_STRIP        ( DEV_88E6065_FAMILY )
+#define G1_DEV_RECURSIVE_TAG_STRIP        0
+
+#define DEV_FORCE_WITH_VALUE            \
+    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |        \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FORCE_WITH_VALUE            \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+/* Grouping ATU Entry State for Unicast */
+
+#define DEV_UC_7_DYNAMIC        \
+    ( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY |    DEV_88E6185_FAMILY |\
+      DEV_88E6183 | DEV_88E6093 | DEV_88E6097_FAMILY |        \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_7_DYNAMIC        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_UC_NO_PRI_TO_CPU_STATIC_NRL        \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_NO_PRI_TO_CPU_STATIC_NRL        \
+    (  G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_UC_TO_CPU_STATIC_NRL            \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_TO_CPU_STATIC_NRL            \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_UC_NO_PRI_STATIC_NRL            \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_NO_PRI_STATIC_NRL            \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_UC_STATIC_NRL                    \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_STATIC_NRL                    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_UC_NO_PRI_TO_CPU_STATIC            \
+    ( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |\
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_NO_PRI_TO_CPU_STATIC            \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_UC_TO_CPU_STATIC            \
+    ( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |\
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_TO_CPU_STATIC            \
+    ( G1_DEV_FE_AVB_FAMILY  | G1_DEV_88E6320_FAMILY)
+
+#define DEV_UC_NO_PRI_STATIC            \
+    ( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY |    DEV_88E6185_FAMILY |\
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |\
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_NO_PRI_STATIC            \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_UC_STATIC    ( DEV_STATIC_ADDR )
+#define G1_DEV_UC_STATIC    ( G1_DEV_STATIC_ADDR )
+
+
+/* Grouping ATU Entry State for Multicast */
+
+#define DEV_MC_MGM_STATIC_UNLIMITED_RATE        \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_MC_MGM_STATIC_UNLIMITED_RATE        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_MC_PRIO_MGM_STATIC_UNLIMITED_RATE    \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_MC_PRIO_MGM_STATIC_UNLIMITED_RATE    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_MC_STATIC_UNLIMITED_RATE    ( DEV_STATIC_ADDR & ~DEV_88E6052 )
+#define G1_DEV_MC_STATIC_UNLIMITED_RATE    ( G1_DEV_STATIC_ADDR )
+
+#define DEV_MC_MGM_STATIC    ( DEV_STATIC_ADDR )
+#define G1_DEV_MC_MGM_STATIC    ( G1_DEV_STATIC_ADDR )
+
+#define DEV_MC_STATIC            ( DEV_STATIC_ADDR )
+#define G1_DEV_MC_STATIC        ( G1_DEV_STATIC_ADDR )
+#define DEV_MC_PRIO_MGM_STATIC        ( DEV_STATIC_ADDR )
+#define G1_DEV_MC_PRIO_MGM_STATIC    ( G1_DEV_STATIC_ADDR )
+
+#define DEV_MC_PRIO_STATIC_UNLIMITED_RATE ( DEV_STATIC_ADDR & ~ (DEV_88E6083|DEV_88E6052) )
+#define G1_DEV_MC_PRIO_STATIC_UNLIMITED_RATE ( G1_DEV_STATIC_ADDR )
+
+#define DEV_MC_PRIO_STATIC        ( DEV_STATIC_ADDR & ~DEV_88E6083 )
+#define G1_DEV_MC_PRIO_STATIC        ( G1_DEV_STATIC_ADDR )
+
+
+/* Grouping Devices that support Pause Limit */
+#define DEV_PAUSE_LIMIT        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PAUSE_LIMIT        \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+/* Grouping Devices that support Frame Mode */
+#define DEV_FRAME_MODE            \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FRAME_MODE            \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_POLICY            \
+    ( DEV_88E6097 | DEV_88E6165 | DEV_AVB_FAMILY | DEV_88E6175)
+#define G1_DEV_POLICY    ( G1_DEV_88E6351_FAMILY | G1_DEV_FE_AVB_FAMILY )
+#define DEV_PORT_ETYPE        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PORT_ETYPE    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_FID_REG        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FID_REG    (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_FRAME_TO_REGISTER    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FRAME_TO_REGISTER   (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_RMU_MODE    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_RMU_MODE  (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_DA_CHECK    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY )
+#define G1_DEV_DA_CHECK  (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_DA_CHECK_1    ( DEV_88E6352_FAMILY )
+#define G1_DEV_DA_CHECK_1  (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_HEADER_TYPE    (DEV_88E6352_FAMILY)
+#define G1_DEV_HEADER_TYPE  (G1_DEV_88E6320_AVB_FAMILY)
+
+#define DEV_COUNTER_MODE    (DEV_88E6352_FAMILY)
+#define G1_DEV_COUNTER_MODE    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_SWITCH_MAC_REG        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_SWITCH_MAC_REG    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_SWITCH_WOL_WOF_REG       (DEV_88E6352_FAMILY)
+#define G1_DEV_SWITCH_WOL_WOF_REG    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_ATU_STATS            \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ATU_STATS    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_JUMBO_MODE        \
+    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_JUMBO_MODE  \
+    (G1_DEV_88E6320_FAMILY)
+#define DEV_PTP        ( DEV_88E6165_FAMILY | DEV_AVB_FAMILY )
+#define G1_DEV_PTP    \
+    ( G1_DEV_FE_AVB_FAMILY)
+#define DEV_PTP_2        ( DEV_AVB_FAMILY )
+#define G1_DEV_PTP_2        ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_TAI        ( DEV_AVB_FAMILY )
+#define G1_DEV_TAI    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_TAI_MULTI_PTP_SYNC    ( DEV_AVB_FAMILY)
+#define G1_DEV_TAI_MULTI_PTP_SYNC    0
+#define DEV_TAI_EXT_CLK    ( DEV_88E6352_AVB_FAMILY)
+#define G1_DEV_TAI_EXT_CLK    (G1_DEV_88E6320_AVB_FAMILY)
+#define DEV_ARRV_TS_MODE    ( DEV_88E6352_AVB_FAMILY)
+#define G1_DEV_ARRV_TS_MODE    (G1_DEV_88E6320_AVB_FAMILY)
+#define DEV_TAI_TRIG_GEN   0
+#define G1_DEV_TAI_TRIG_GEN    (G1_DEV_88E6320_AVB_FAMILY)
+#define DEV_RMU_PAGE2   0
+#define G1_DEV_RMU_PAGE2    (G1_DEV_88E6320_AVB_FAMILY)
+#define DEV_QUEUE_CONTROL   0
+#define G1_DEV_QUEUE_CONTROL    (G1_DEV_88E6320_AVB_FAMILY)
+#define DEV_DEBUG_COUNTER   0
+#define G1_DEV_DEBUG_COUNTER    (G1_DEV_88E6320_AVB_FAMILY)
+#define DEV_CUT_THROUGH   0
+#define G1_DEV_CUT_THROUGH    (G1_DEV_88E6320_AVB_FAMILY)
+
+
+#define DEV_AVB_POLICY    ( DEV_AVB_FAMILY )
+#define G1_DEV_AVB_POLICY\
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_AVB_POLICY_RECOVER_CLK    ( DEV_88E6351_AVB_FAMILY )
+#define G1_DEV_AVB_POLICY_RECOVER_CLK 0
+
+#define DEV_QAV        ( DEV_AVB_FAMILY )
+#define G1_DEV_QAV    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_QAV_QPRI_QTS_TOKEN        ( DEV_88E6351_AVB_FAMILY | DEV_88E6352_AVB_FAMILY )
+#define G1_DEV_QAV_QPRI_QTS_TOKEN    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_QAV_QPRI_RATE        0
+#define G1_DEV_QAV_QPRI_RATE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_QAV_ISO_DELAY_LIMIT        ( DEV_88E6351_AVB_FAMILY )
+#define G1_DEV_QAV_ISO_DELAY_LIMIT    0
+
+#define DEV_TSM_RESOURCE    ( DEV_AVB_FAMILY )
+#define G1_DEV_TSM_RESOURCE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_200BASE_CFG    ( DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_200BASE_CFG        ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_RGMII_TIMING    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_RGMII_TIMING        ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_Q_COUNTER_TABLE    ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_Q_COUNTER_TABLE        ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_LED_CFG        ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_LED_CFG            ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_MAC_AVB        ( DEV_AVB_FAMILY)
+#define G1_DEV_MAC_AVB            ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_CLK_125        ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_CLK_125            ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_QAVB_PRIORITY_OVERRIDE_TABLE    \
+    ( DEV_AVB_FAMILY )
+#define G1_DEV_QAVB_PRIORITY_OVERRIDE_TABLE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_FRAME_PRIORITY_OVERRIDE_TABLE    \
+    ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_FRAME_PRIORITY_OVERRIDE_TABLE    \
+    ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_SCRATCH_MISC_CTRL        ( DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_SCRATCH_MISC_CTRL        ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_IP_MAPPING_TABLE        ( DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_IP_MAPPING_TABLE            ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+#define DEV_EEPROM            ( DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_EEPROM            ( G1_DEV_88E6351_FAMILY | G1_DEV_88E6320_FAMILY)
+
+#define DEV_RMGMT        (DEV_88E6351_FAMILY | DEV_88E6352_FAMILY| DEV_88E6097_FAMILY |DEV_88E6165_FAMILY)
+#define G1_DEV_RMGMT        ( G1_DEV_FE_AVB_FAMILY | G1_DEV_88E6320_FAMILY )
+
+#define DEV_PHY_ACCESS_NO_DIRECTLY    0
+#define G1_DEV_PHY_ACCESS_NO_DIRECTLY    ( G1_DEV_88ESPANNAK_FAMILY )
+
+#define DEV_TCAM        ( DEV_88E6352_FAMILY )
+#define G1_DEV_TCAM        (G1_DEV_88E6320_AVB_FAMILY)
+
+/***************************************************************************/
+/* Added definitions, to improve DSDT */
+#define DEV_SWITCH_MODE     (DEV_QD_PLUS | DEV_ENHANCED_FE_SWITCH )
+#define G1_DEV_SWITCH_MODE  (G1_DEV_QD_PLUS | G1_DEV_ENHANCED_FE_SWITCH )
+
+#define DEV_INIT_READY    (DEV_QD_PLUS | DEV_ENHANCED_FE_SWITCH | DEV_FE_AVB_FAMILY )
+#define G1_DEV_INIT_READY (G1_DEV_QD_PLUS | G1_DEV_ENHANCED_FE_SWITCH | G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_IGNORE_FCS    (DEV_GIGABIT_MANAGED_SWITCH | DEV_ENHANCED_FE_SWITCH | DEV_FE_AVB_FAMILY )
+#define G1_DEV_IGNORE_FCS (G1_DEV_GIGABIT_MANAGED_SWITCH | G1_DEV_ENHANCED_FE_SWITCH | G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_LOCKED_PORT    (DEV_GIGABIT_MANAGED_SWITCH | DEV_ENHANCED_FE_SWITCH | DEV_FE_AVB_FAMILY )
+#define G1_DEV_LOCKED_PORT (G1_DEV_GIGABIT_MANAGED_SWITCH | G1_DEV_ENHANCED_FE_SWITCH | G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_IGNORE_WRONG_DAT    (DEV_GIGABIT_MANAGED_SWITCH | DEV_ENHANCED_FE_SWITCH | DEV_FE_AVB_FAMILY )
+#define G1_DEV_IGNORE_WRONG_DAT (G1_DEV_GIGABIT_MANAGED_SWITCH | G1_DEV_ENHANCED_FE_SWITCH | G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_DISCARD_TAGGED    (DEV_88E6093_FAMILY | DEV_ENHANCED_FE_SWITCH | DEV_FE_AVB_FAMILY )
+#define G1_DEV_DISCARD_TAGGED (G1_DEV_88E6093_FAMILY | G1_DEV_ENHANCED_FE_SWITCH | G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_MAP_DA    (DEV_88E6093_FAMILY | DEV_ENHANCED_FE_SWITCH | DEV_FE_AVB_FAMILY )
+#define G1_DEV_MAP_DA (G1_DEV_88E6093_FAMILY | G1_DEV_ENHANCED_FE_SWITCH | G1_DEV_FE_AVB_FAMILY )
+
+/* Pearl features */
+
+/***************************************************************************/
+
+
+/* Macros to utilize Device Group */
+
+#define IS_IN_DEV_GROUP(dev,_group) ((dev->devName & (_group))||(dev->devName1 & (G1_##_group)))
+
+/* need to check port number(_hwPort) later */
+#define IS_VALID_API_CALL(dev,_hwPort, _devName)            \
+    ((_hwPort == GT_INVALID_PORT) ? GT_BAD_PARAM :            \
+    (!((dev->devName & (_devName))||(dev->devName1 & (G1_##_devName))) ? GT_NOT_SUPPORTED : GT_OK))
+
+#define DOES_DEVPORT_SUPPORT_PCS(dev, _hwPort)            \
+    (!((dev->devName & DEV_GIGABIT_SWITCH)||(dev->devName1 & G1_DEV_GIGABIT_SWITCH)) || \
+     ((dev->devName & DEV_INTERNAL_GPHY)||(dev->devName1 & G1_DEV_INTERNAL_GPHY)) ||   \
+    (!((dev->devName & DEV_EXTERNAL_PHY_ONLY)||(dev->devName1 & G1_DEV_EXTERNAL_PHY_ONLY)) && (((_hwPort) < 8) || ((_hwPort) > 10)))    \
+    ? 0 : 1)
+
+#define IS_CONFIGURABLE_PHY(dev,_hwPort)    driverIsPhyAttached(dev,_hwPort)
+#define GT_GET_PHY_ID(dev,_hwPort)            driverGetPhyID(dev,_hwPort)
+
+#define GT_GET_SERDES_PORT(dev,_hwPort)        driverGetSerdesPort(dev,_hwPort)
+
+#define GT_GIG_PHY_INT_MASK(dev,_portVct)    ((_portVct) = (_portVct) & 0xF7)
+
+
+#define RECOMMENDED_ESB_LIMIT(dev, _bps)                    \
+        ((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?16777200:0xFFFFFF)
+
+#define RECOMMENDED_CBS_LIMIT(dev, _bps)                    \
+        ((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?393216:0x200000)
+
+#define RECOMMENDED_BUCKET_INCREMENT(dev, _bps)                \
+        ((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?174:        \
+        ((_bps) < 1000)?0x3d:                            \
+        ((_bps) < 10000)?0x1f:0x4)
+
+#define FACTOR_FROM_BUCKET_INCREMENT(dev, _bInc, _f)        \
+    {                                                        \
+        if(IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))            \
+        {                                                    \
+            if((_bInc) == 174) {(_f) = 64;}                    \
+            else {(_f) = 0;}                                \
+        }                                                    \
+        else                                                \
+        {                                                    \
+            if((_bInc) == 0x3d) {(_f) = 64;}                \
+            else if((_bInc) == 0x1f) {(_f) = 128;}            \
+            else if((_bInc) == 0x4) {(_f) = 1000;}            \
+            else {(_f) = 0;}                                \
+        }                                                    \
+    }
+
+
+#define TSM_GET_CBS(_rate,_cts)    ((_rate)/((_cts)*8))
+#define TSM_GET_RATE(_cbs,_cts)    ((_cbs)*8*(_cts))
+
+
+#define GT_PTP_BUILD_TIME(_time1, _time2)       (((_time1) << 16) | (_time2))
+#define GT_PTP_L16_TIME(_time1) ((_time1) & 0xFFFF)
+#define GT_PTP_H16_TIME(_time1) (((_time1) >> 16) & 0xFFFF)
+
+/*
+ * typedef: enum GT_ATU_STATS_OP
+ *
+ * Description: Enumeration of the ATU Statistics operation
+ *
+ * Enumerations:
+ *   GT_ATU_STATS_ALL        - count all valid entry
+ *   GT_ATU_STATS_NON_STATIC - count all vaild non-static entry
+ *   GT_ATU_STATS_ALL_FID    - count all valid entry in the given DBNum(or FID)
+ *   GT_ATU_STATS_NON_STATIC_FID - count all valid non-static entry in the given DBNum(or FID)
+ */
+typedef enum
+{
+    GT_ATU_STATS_ALL = 0,
+    GT_ATU_STATS_NON_STATIC,
+    GT_ATU_STATS_ALL_FID,
+    GT_ATU_STATS_NON_STATIC_FID
+}GT_ATU_STATS_OP;
+
+
+/*
+ *  typedef: struct GT_ATU_STAT
+ *
+ *  Description:
+ *        This structure is used to count ATU entries.
+ *
+ *  Fields:
+ *      op       - counter type
+ *        DBNum - required only if op is either GT_ATU_STATS_FID or
+ *                GT_ATU_STATS_NON_STATIC_FID
+ */
+typedef struct
+{
+    GT_ATU_STATS_OP    op;
+    GT_U32             DBNum;
+} GT_ATU_STAT;
+
+
+typedef struct _EXTRA_OP_DATA
+{
+    GT_U32 moveFrom;
+    GT_U32 moveTo;
+    GT_U32 intCause;
+    GT_U32 reserved;
+} GT_EXTRA_OP_DATA;
+
+/*******************************************************************************
+* gvtuGetViolation
+*
+* DESCRIPTION:
+*       Get VTU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*        This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation
+(
+    IN GT_QD_DEV*       dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+);
+
+/*******************************************************************************
+* gvtuGetViolation2
+*
+* DESCRIPTION:
+*       Get VTU Violation data (for Gigabit Device)
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*        This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation2
+(
+    IN GT_QD_DEV*       dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+);
+
+/*******************************************************************************
+* gvtuGetViolation3
+*
+* DESCRIPTION:
+*       Get VTU Violation data (for Spinnaker family Device)
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*        This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation3
+(
+    IN GT_QD_DEV*       dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+);
+
+/*******************************************************************************
+* gatuGetViolation
+*
+* DESCRIPTION:
+*       Get ATU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*        This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gatuGetViolation
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_ATU_INT_STATUS *atuIntStatus
+);
+
+/*******************************************************************************
+* gsysSetRetransmitMode
+*
+* DESCRIPTION:
+*       This routine set the Retransmit Mode.
+*
+* INPUTS:
+*       en - GT_TRUE Retransimt Mode is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRetransmitMode
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL en
+);
+
+/*******************************************************************************
+* gsysGetRetransmitMode
+*
+* DESCRIPTION:
+*       This routine get the Retransmit Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Retransmit Mode is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRetransmitMode
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *en
+);
+
+/*******************************************************************************
+* gsysSetLimitBackoff
+*
+* DESCRIPTION:
+*       This routine set the Limit Backoff bit.
+*
+* INPUTS:
+*       en - GT_TRUE:  uses QoS half duplex backoff operation
+*            GT_FALSE: uses normal half duplex backoff operation
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetLimitBackoff
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL en
+);
+
+/*******************************************************************************
+* gsysGetLimitBackoff
+*
+* DESCRIPTION:
+*       This routine set the Limit Backoff bit.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE:  uses QoS half duplex backoff operation
+*            GT_FALSE: uses normal half duplex backoff operation
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetLimitBackoff
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *en
+);
+
+/*******************************************************************************
+* gsysSetRsvRegPri
+*
+* DESCRIPTION:
+*       This routine set the Reserved Queue's Requesting Priority
+*
+* INPUTS:
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvReqPri
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL en
+);
+
+/*******************************************************************************
+* gsysGetRsvReqPri
+*
+* DESCRIPTION:
+*       This routine get the Reserved Queue's Requesting Priority
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvReqPri
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *en
+);
+
+/*******************************************************************************
+* gsysGetPtrCollision
+*
+* DESCRIPTION:
+*       This routine get the QC Pointer Collision.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*         This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPtrCollision
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *mode
+);
+
+/*******************************************************************************
+* gsysGetDpvCorrupt
+*
+* DESCRIPTION:
+*       This routine get the DpvCorrupt bit. This bit is set to a one when the
+*       QC detects a destination vector error
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: destination vector corrupt, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*     This feature is on clippership, but not on fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDpvCorrupt
+(
+    IN GT_BOOL *mode
+);
+
+/*******************************************************************************
+* gsysGetMissingPointers
+*
+* DESCRIPTION:
+*       This routine get the Missing Pointer bit. This bit is set to a one when
+*       the Register File detects less than 64 pointers in the Link List.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: Missing Pointers error, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*     This feature is on clippership, but not on fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMissingPointers
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *mode
+);
+
+/*******************************************************************************
+* gtDbgPrint
+*
+* DESCRIPTION:
+*       .
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void gtDbgPrint(char* format, ...);
+
+
+/*******************************************************************************
+* gtSemRegister
+*
+* DESCRIPTION:
+*       Assign QuarterDeck Semaphore functions to the given semaphore set.
+*        QuarterDeck maintains its own memory for the structure.
+*
+* INPUTS:
+*        semFunctions - point to the GT_SEM_ROUTINES
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemRegister
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_SEM_ROUTINES* semRoutines
+);
+
+
+/*******************************************************************************
+* gpirlInitialize
+*
+* DESCRIPTION:
+*       This routine initializes PIRL Resources.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlInitialize
+(
+    IN  GT_QD_DEV              *dev
+);
+
+/*******************************************************************************
+* gpirl2Initialize
+*
+* DESCRIPTION:
+*       This routine initializes PIRL2 Resources.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirl2Initialize
+(
+    IN  GT_QD_DEV              *dev
+);
+
+#ifdef DEBUG_FEATURE /* this is a debug feature*/
+/*******************************************************************************
+* gprtGetPortQueueCtr
+*
+* DESCRIPTION:
+*       This routine gets the port queue counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortQueueCtr
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_Q_STAT  *ctr
+);
+
+#endif
+
+
+/*******************************************************************************
+* lport2port
+*
+* DESCRIPTION:
+*       This function converts logical port number to physical port number
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        port    - logical port number
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       physical port number
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_U8 lport2port
+(
+    IN GT_U16    portVec,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* port2lport
+*
+* DESCRIPTION:
+*       This function converts physical port number to logical port number
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        port    - logical port number
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       physical port number
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_LPORT port2lport
+(
+    IN GT_U16    portVec,
+    IN GT_U8     hwPort
+);
+
+/*******************************************************************************
+* lportvec2portvec
+*
+* DESCRIPTION:
+*       This function converts logical port vector to physical port vector
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        lVec     - logical port vector
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       physical port vector
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_U32 lportvec2portvec
+(
+    IN GT_U16    portVec,
+    IN GT_U32     lVec
+);
+
+/*******************************************************************************
+* portvec2lportvec
+*
+* DESCRIPTION:
+*       This function converts physical port vector to logical port vector
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        pVec     - physical port vector
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       logical port vector
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_U32 portvec2lportvec
+(
+    IN GT_U16    portVec,
+    IN GT_U32     pVec
+);
+
+/*******************************************************************************
+* lport2phy
+*
+* DESCRIPTION:
+*       This function converts logical port number to physical phy number.
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        port    - logical port number
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       physical port number
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_U8 lport2phy
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApiInternal_h */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/platform/gtMiiSmiIf.h
@@ -0,0 +1,238 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtMiiSmiIf.h
+*
+* DESCRIPTION:
+*       Includes functions prototypes for initializing and accessing the
+*       MII / SMI interface.
+*       This is the only file to be included from upper layers.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 2 $
+*
+*******************************************************************************/
+
+#ifndef __gtMiiSmiIfh
+#define __gtMiiSmiIfh
+
+
+#include <msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+* miiSmiIfInit
+*
+* DESCRIPTION:
+*       This function initializes the MII / SMI interface.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       highSmiDevAddr - Indicates whether to use the high device register
+*                     addresses when accessing switch's registers (of all kinds)
+*                     i.e, the devices registers range is 0x10 to 0x1F, or to
+*                     use the low device register addresses (range 0x0 to 0xF).
+*                       GT_TRUE     - use high addresses (0x10 to 0x1F).
+*                       GT_FALSE    - use low addresses (0x0 to 0xF).
+*
+* RETURNS:
+*       DEVICE_ID       - on success
+*       0     - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U16 miiSmiIfInit
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   * highSmiDevAddr
+);
+
+/*******************************************************************************
+* miiSmiManualIfInit
+*
+* DESCRIPTION:
+*       This function returns Device ID from the given base address
+*
+* INPUTS:
+*       baseAddr - either 0x0 or 0x10. Indicates whether to use the low device
+*                    register address or high device register address.
+*                    The device register range is from 0x0 to 0xF or from 0x10
+*                    to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port
+*                    switchs.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       DEVICE_ID       - on success
+*       0    - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U16 miiSmiManualIfInit
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_U32        baseAddr
+);
+
+/*******************************************************************************
+* miiSmiIfReadRegister
+*
+* DESCRIPTION:
+*       This function reads a register throw the SMI / MII interface, to be used
+*       by upper layers.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*
+* OUTPUTS:
+*       data        - The register's data.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS miiSmiIfReadRegister
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* miiSmiIfWriteRegister
+*
+* DESCRIPTION:
+*       This function writes to a register throw the SMI / MII interface, to be
+*       used by upper layers.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       data        - The data to be written to the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS miiSmiIfWriteRegister
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+/*****************************************************************************
+* qdMultiAddrRead
+*
+* DESCRIPTION:
+*       This function reads data from a device in the secondary MII bus.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The storage where register date to be saved.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int* value);
+
+/*****************************************************************************
+* qdMultiAddrWrite
+*
+* DESCRIPTION:
+*       This function writes data to the device in the secondary MII bus.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The data to be written into the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int value);
+
+#ifdef GT_RMGMT_ACCESS
+/*******************************************************************************
+* qdAccessRegs
+*
+* DESCRIPTION:
+*       This function access registers through device interface by user, to be
+*       used by upper layers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1
+*     addr - SMI Address
+*     reg  - Register offset
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS qdAccessRegs
+(
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtMiiSmiIfh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/platform/gtSem.h
@@ -0,0 +1,153 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtOs.h
+*
+* DESCRIPTION:
+*       Operating System wrapper
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+
+#ifndef __gtSemh
+#define __gtSemh
+
+#include <msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***** Defines  ********************************************************/
+
+#define OS_WAIT_FOREVER             0
+
+#define OS_MAX_TASKS                30
+#define OS_MAX_TASK_NAME_LENGTH     10
+
+#define OS_MAX_QUEUES               30
+#define OS_MAX_QUEUE_NAME_LENGTH    10
+
+#define OS_MAX_EVENTS               10
+
+#define OS_MAX_SEMAPHORES           50
+
+#define OS_EOF                      (-1)
+
+
+/*******************************************************************************
+* gtSemCreate
+*
+* DESCRIPTION:
+*       Create semaphore.
+*
+* INPUTS:
+*        state - beginning state of the semaphore, either SEM_EMPTY or SEM_FULL
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_SEM if success. Otherwise, NULL
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_SEM gtSemCreate
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM_BEGIN_STATE state
+);
+
+/*******************************************************************************
+* gtSemDelete
+*
+* DESCRIPTION:
+*       Delete semaphore.
+*
+* INPUTS:
+*       smid - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemDelete
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM       smid
+);
+
+/*******************************************************************************
+* gtSemTake
+*
+* DESCRIPTION:
+*       Wait for semaphore.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*       timeOut - time out in miliseconds or 0 to wait forever
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       OS_TIMEOUT - on time out
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemTake
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM       smid,
+    IN GT_U32       timeOut
+);
+
+/*******************************************************************************
+* gtSemGive
+*
+* DESCRIPTION:
+*       release the semaphore which was taken previously.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemGive
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM       smid
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* __gtSemh */
+/* Do Not Add Anything Below This Line */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/h/platform/platformDeps.h
@@ -0,0 +1,30 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* platformDeps.h
+*
+* DESCRIPTION:
+*       platform dependent definitions
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __platformDepsh
+#define __platformDepsh
+
+#include <msApi.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+GT_BOOL defaultMiiRead (unsigned int portNumber , unsigned int miiReg, unsigned int* value);
+GT_BOOL defaultMiiWrite (unsigned int portNumber , unsigned int miiReg, unsigned int value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* platformDepsh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApi.h
@@ -0,0 +1,22 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* msApi.h
+*
+* DESCRIPTION:
+*       API definitions for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApi_h
+#define __msApi_h
+
+#include <msApiDefs.h>
+#include <msApiInternal.h>
+#include <msApiPrototype.h>
+
+#endif /* __msApi_h */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiDefs.h
@@ -0,0 +1,4472 @@
+ #include <Copyright.h>
+
+/********************************************************************************
+* msApiDefs.h
+*
+* DESCRIPTION:
+*       API definitions for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiDefs_h
+#define __msApiDefs_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/* Micro definitions */
+#undef GT_USE_MAD
+#undef GT_RMGMT_ACCESS
+#undef CONFIG_AVB_FPGA
+#undef CONFIG_AVB_FPGA_2
+#undef GT_PORT_MAP_IN_DEV
+#ifdef CHECK_API_SELECT
+#include "msApiSelect.h"
+#endif
+#include "msApiSelect.h"
+
+#include <msApiTypes.h>
+#ifdef GT_USE_MAD
+#include "madApiDefs.h"
+#endif
+
+#ifdef DEBUG_QD
+#define DBG_INFO(x) gtDbgPrint x
+#else
+#define DBG_INFO(x);
+#endif /* DEBUG_QD */
+
+typedef GT_U32 GT_SEM;
+
+#define ETHERNET_HEADER_SIZE    GT_ETHERNET_HEADER_SIZE
+#define IS_MULTICAST_MAC        GT_IS_MULTICAST_MAC
+#define IS_BROADCAST_MAC        GT_IS_BROADCAST_MAC
+
+#define GT_INVALID_PHY            0xFF
+#define GT_INVALID_PORT            0xFF
+#define GT_INVALID_PORT_VEC        0xFFFFFFFF
+
+#define GT_UNUSED_PARAM(_a)        (_a)=(_a)
+
+/*
+ *   Logical Port value based on a Port
+ *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |0|  reserved                                   |    port       |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ *
+ *   The following macros should be used to extract specific info
+ *   from a Logical Port index
+ */
+typedef GT_U32 GT_LPORT;
+typedef GT_U32 GT_ETYPE;
+
+
+/* Define the different device type that may exist in system        */
+typedef enum
+{
+    GT_88E6021  = 0x021,
+    GT_88E6031  = 0x031,
+    GT_88E6035  = 0x035,
+    GT_88E6046  = 0x048,
+    GT_88E6047  = 0x049,
+    GT_88E6085  = 0x04A,
+    GT_88E6051  = 0x051,
+    GT_88E6052  = 0x052,
+    GT_88E6055  = 0x055,
+    GT_88E6060  = 0x060,
+    GT_88E6061  = 0x061,
+    GT_88E6065  = 0x065,
+    GT_88E6083  = 0x083,
+    GT_88E6093  = 0x093,
+    GT_88E6045  = 0x094,
+    GT_88E6095  = 0x095,
+    GT_88E6092  = 0x097,
+    GT_88E6096  = 0x098,
+    GT_88E6097  = 0x099,
+    GT_88E6063    = 0x153,
+    GT_88E6121    = 0x104,
+    GT_88E6122    = 0x105,
+    GT_88E6131    = 0x106,
+    GT_88E6108    = 0x107,
+    GT_88E6123    = 0x121,
+    GT_88E6124    = 0x124,    /* was 88E6124 */
+    GT_88E6140    = 0x141, /* Emerald */
+    GT_88E6161    = 0x161, /* Emerald */
+    GT_88E6165    = 0x165, /* Emerald */
+    GT_88E6171    = 0x171, /* Amber */
+    GT_88E6175    = 0x175, /* Amber */
+    GT_88E6181    = 0x1A0,
+    GT_88E6153    = 0x1A1,
+    GT_88E6183    = 0x1A3,
+    GT_88E6152    = 0x1A4,
+    GT_88E6155    = 0x1A5,
+    GT_88E6182    = 0x1A6,
+    GT_88E6185    = 0x1A7,
+    GT_88E6321    = 0x324,    /* was 88E6325 */ /* Amber */
+    GT_88E6350    = 0x371,    /* was 88E6371 */ /* Amber */
+    GT_88E6351    = 0x375,    /* Amber */
+    GT_88EC000    = 0xC00,    /* Melody 0xc00-0xc07 */
+    GT_88E3020    = 0x000,    /* Spinnaker 0x000 */
+    GT_88E6020    = 0x020,    /* Spinnaker 0x020 */
+    GT_88E6070    = 0x070,    /* Spinnaker 0x070 */
+    GT_88E6071    = 0x071,    /* Spinnaker 0x071 */
+    GT_88E6220    = 0x220,    /* Spinnaker 0x220 */
+    GT_88E6250    = 0x250,    /* Spinnaker 0x250 */
+    GT_FH_VPN   = 0xF53,
+    GT_FF_EG    = 0xF91,
+    GT_FF_HG    = 0xF93,
+    GT_88E6172    = 0x172, /* Agate */
+    GT_88E6176    = 0x176, /* Agate */
+    GT_88E6240    = 0x240, /* Agate */
+    GT_88E6352    = 0x352, /* Agate */
+    GT_88E6115    = 0x115, /* Pearl */
+    GT_88E6125    = 0x125, /* Pearl */
+    GT_88E6310    = 0x310, /* Pearl */
+    GT_88E6320    = 0x320, /* Pearl */
+
+}GT_DEVICE;
+
+
+/* Definition for the revision number of the device        */
+typedef enum
+{
+    GT_REV_0 = 0,
+    GT_REV_1,
+    GT_REV_2,
+    GT_REV_3
+}GT_DEVICE_REV;
+
+
+/* ToDo: No Used */
+typedef enum
+{
+    INTR_MODE_DISABLE =0,
+    INTR_MODE_ENABLE
+}INTERRUPT_MODE;
+
+/* Definition for the Port Speed */
+typedef enum
+{
+    PORT_SPEED_10_MBPS = 0,
+    PORT_SPEED_100_MBPS = 1,
+    PORT_SPEED_200_MBPS = 2,    /* valid only if device support */
+    PORT_SPEED_1000_MBPS = 2 ,    /* valid only if device support */
+    PORT_SPEED_UNKNOWN = 3
+} GT_PORT_SPEED_MODE;
+
+/* Definition for the forced Port Speed */
+typedef enum
+{
+    PORT_FORCE_SPEED_10_MBPS = 0,
+    PORT_FORCE_SPEED_100_MBPS = 1,
+    PORT_FORCE_SPEED_200_MBPS = 2,    /* valid only if device support */
+    PORT_FORCE_SPEED_1000_MBPS = 2,    /* valid only if device support */
+    PORT_DO_NOT_FORCE_SPEED =3
+} GT_PORT_FORCED_SPEED_MODE;
+
+/* Definition for the forced Port Duplex mode */
+typedef enum
+{
+    PORT_DO_NOT_FORCE_DUPLEX,
+    PORT_FORCE_FULL_DUPLEX,
+    PORT_FORCE_HALF_DUPLEX
+} GT_PORT_FORCED_DUPLEX_MODE;
+
+/* Definition for the forced Port Link */
+typedef enum
+{
+    PORT_DO_NOT_FORCE_LINK,
+    PORT_FORCE_LINK_UP,
+    PORT_FORCE_LINK_DOWN
+} GT_PORT_FORCED_LINK_MODE;
+
+/* Definition for the forced flow control mode */
+typedef enum
+{
+    PORT_DO_NOT_FORCE_FC,
+    PORT_FORCE_FC_ENABLED,
+    PORT_FORCE_FC_DISABLED
+} GT_PORT_FORCED_FC_MODE;
+
+/* Definition for the PPU state */
+typedef enum
+{
+    PPU_STATE_DISABLED_AT_RESET,
+    PPU_STATE_ACTIVE,
+    PPU_STATE_DISABLED_AFTER_RESET,
+    PPU_STATE_POLLING
+} GT_PPU_STATE;
+
+
+/*
+ * Typedef: enum GT_PORT_CONFIG_MODE
+ *
+ * Description: Defines port's interface type configuration mode determined at
+ *                reset. This definition may not represent the device under use.
+ *                Please refer to the device datasheet for detailed information.
+ *
+ */
+typedef enum
+{
+    PORTCFG_GMII_125MHZ = 0,        /* Px_GTXCLK = 125MHz, 1000BASE */
+    PORTCFG_FD_MII_0MHZ = 1,        /* Px_GTXCLK = 0 MHz, Power Save */
+    PORTCFG_FDHD_MII_25MHZ = 2,        /* Px_GTXCLK = 25MHz, 100BASE */
+    PORTCFG_FDHD_MII_2_5MHZ = 3,    /* Px_GTXCLK = 2.5MHz, 10BASE */
+    PORTCFG_FD_SERDES = 4,            /* Default value */
+    PORTCFG_FD_1000BASE_X = 5,
+    PORTCFG_MGMII = 6,                /* duplex, speed determined by the PPU */
+    PORTCFG_DISABLED = 7
+} GT_PORT_CONFIG_MODE;
+
+
+typedef enum
+{
+    GT_SA_FILTERING_DISABLE = 0,
+    GT_SA_DROP_ON_LOCK,
+    GT_SA_DROP_ON_UNLOCK,
+    GT_SA_DROP_TO_CPU
+} GT_SA_FILTERING;
+
+
+/* Definition for the Ingree/Egress Frame Mode */
+typedef enum
+{
+    GT_FRAME_MODE_NORMAL = 0,    /* Normal Network */
+    GT_FRAME_MODE_DSA,            /* Distributed Switch Architecture */
+    GT_FRAME_MODE_PROVIDER,        /* Provider */
+    GT_FRAME_MODE_ETHER_TYPE_DSA    /* Ether Type DSA */
+} GT_FRAME_MODE;
+
+/*
+ * Typedef: enum GT_JUMBO_MODE
+ *
+ * Description: Defines Jumbo Frame Size allowed to be tx and rx
+ *
+ * Fields:
+ *      GT_JUMBO_MODE_1522 - Rx and Tx frames with max byte of 1522.
+ *      GT_JUMBO_MODE_2048 - Rx and Tx frames with max byte of 2048.
+ *      GT_JUMBO_MODE_10240 - Rx and Tx frames with max byte of 10240.
+ *
+ */
+typedef enum
+{
+    GT_JUMBO_MODE_1522 = 0,
+    GT_JUMBO_MODE_2048,
+    GT_JUMBO_MODE_10240
+} GT_JUMBO_MODE;
+
+
+/*
+ * Typedef: enum GT_PRI_OVERRIDE
+ *
+ * Description: Defines the priority override
+ *
+ * Fields:
+ *      PRI_OVERRIDE_NONE - Normal frame priority processing occurs.
+ *        PRI_OVERRIDE_FRAME_QUEUE -
+ *            Both frame and queue overrides take place on the frame.
+ *      PRI_OVERRIDE_FRAME -
+ *            Overwite the frame's FPri (frame priority).
+ *            If the frame egresses tagged, the priority in the frame will be
+ *            the overwritten priority value.
+ *        PRI_OVERRIDE_QUEUE -
+ *            Overwite the frame's QPri (queue priority).
+ *            QPri is used internally to map the frame to one of the egress
+ *            queues inside the switch.
+ *
+ */
+typedef enum
+{
+    PRI_OVERRIDE_NONE = 0,
+    PRI_OVERRIDE_FRAME_QUEUE,
+    PRI_OVERRIDE_FRAME,
+    PRI_OVERRIDE_QUEUE
+} GT_PRI_OVERRIDE;
+
+
+/*
+ * Typedef: enum GT_FRAME_POLICY
+ *
+ * Description: Defines the policy of the frame
+ *
+ * Fields:
+ *      FRAME_POLICY_NONE - Normal frame switching
+ *      FRAME_POLICY_MIRROR - Mirror(copy) frame to the MirrorDest port
+ *      FRAME_POLICY_TRAP - Trap(re-direct) frame to the CPUDest port
+ *      FRAME_POLICY_DISCARD - Discard(filter) the frame
+ *
+ */
+typedef enum
+{
+    FRAME_POLICY_NONE = 0,
+    FRAME_POLICY_MIRROR,
+    FRAME_POLICY_TRAP,
+    FRAME_POLICY_DISCARD
+} GT_FRAME_POLICY;
+
+
+/*
+ * Typedef: enum GT_POLICY_TYPE
+ *
+ * Description: Defines the policy type
+ *
+ * Fields:
+ *      POLICY_TYPE_DA     - Policy based on Destination Address
+ *      POLICY_TYPE_SA     - Policy based on Source Address
+ *      POLICY_TYPE_VTU     - Policy based on VID
+ *        POLICY_TYPE_ETYPE    - based on Ether Type of a frame
+ *        POLICY_TYPE_PPPoE    - Policy for the frame with Ether Type of 0x8863
+ *        POLICY_TYPE_VBAS    - Policy for the frame with Ether Type of 0x8200
+ *        POLICY_TYPE_OPT82    - Policy for the frame with DHCP Option 82
+ *        POLICY_TYPE_UDP    - Policy for the frame with Broadcast IPv4 UDP or
+ *                        Multicast IPv6 UDP
+ */
+typedef enum
+{
+    POLICY_TYPE_DA,
+    POLICY_TYPE_SA,
+    POLICY_TYPE_VTU,
+    POLICY_TYPE_ETYPE,
+    POLICY_TYPE_PPPoE,
+    POLICY_TYPE_VBAS,
+    POLICY_TYPE_OPT82,
+    POLICY_TYPE_UDP
+} GT_POLICY_TYPE;
+
+
+/*
+ * Typedef: enum GT_PRI_OVERRIDE_FTYPE
+ *
+ * Description: Definition of the frame type for priority override
+ *
+ * Fields:
+ *        FTYPE_DSA_TO_CPU_BPDU -
+ *            Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_F2R -
+ *            Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+ *            Reply). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_IGMP -
+ *            Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+ *            and on non-DSA Control frames that are IGMP or MLD trapped
+ *        FTYPE_DSA_TO_CPU_TRAP -
+ *            Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+ *            on non-DSA Control frames that are Policy Trapped
+ *        FTYPE_DSA_TO_CPU_ARP -
+ *            Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+ *            on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+ *        FTYPE_DSA_TO_CPU_MIRROR -
+ *            Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+ *            on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+ *        FTYPE_DSA_TO_CPU_RESERVED -
+ *            Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+ *            used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_UCAST_MGMT -
+ *            Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+ *            MGMT). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_FROM_CPU -
+ *            Used on DSA From_CPU frames. Not used on non-DSA Control frame
+ *        FTYPE_DSA_CROSS_CHIP_FC -
+ *            Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+ *            Control). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+ *            Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+ *            Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_PORT_ETYPE_MATCH -
+ *            Used on normal network ports (see gprtSetFrameMode API)
+ *            on frames whose Ethertype matches the port's PortEType register.
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_BCAST_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain a Broadcast
+ *            destination address. Not used on DSA Control frames.
+ *        FTYPE_PPPoE_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain an Ether Type 0x8863
+ *            (i.e., PPPoE frames). Not used on DSA Control frames.
+ *        FTYPE_IP_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+ *            Type. Not used on DSA Control frames.
+ */
+typedef enum
+{
+    FTYPE_DSA_TO_CPU_BPDU = 0,
+    FTYPE_DSA_TO_CPU_F2R,
+    FTYPE_DSA_TO_CPU_IGMP,
+    FTYPE_DSA_TO_CPU_TRAP,
+    FTYPE_DSA_TO_CPU_ARP,
+    FTYPE_DSA_TO_CPU_MIRROR,
+    FTYPE_DSA_TO_CPU_RESERVED,
+    FTYPE_DSA_TO_CPU_UCAST_MGMT,
+    FTYPE_DSA_FROM_CPU,
+    FTYPE_DSA_CROSS_CHIP_FC,
+    FTYPE_DSA_CROSS_CHIP_EGRESS_MON,
+    FTYPE_DSA_CROSS_CHIP_INGRESS_MON,
+    FTYPE_PORT_ETYPE_MATCH,
+    FTYPE_BCAST_NON_DSA_CONTROL,
+    FTYPE_PPPoE_NON_DSA_CONTROL,
+    FTYPE_IP_NON_DSA_CONTROL
+} GT_PRI_OVERRIDE_FTYPE;
+
+
+/*
+ * Typedef: struct GT_QPRI_TBL_ENTRY
+ *
+ * Description: This structure is used for the entry of Queue Priority Override
+ *                Table.
+ *
+ * Fields:
+ *        qPriEn    - GT_TRUE to enable Queue Priority, GT_FALSE otherwise
+ *        qPriority - priority to be overridden ( 0 ~ 3 ) only if qPriEn is GT_TRUE
+ *                    When qPriEn is GT_FALSE, qPriority should be ignored.
+ *
+ * Notes: If device does not support qPriAvbEn, qPriAvbEn and qAvbPriority fields
+ *        will be ignored.
+ */
+typedef struct
+{
+    GT_BOOL        qPriEn;
+    GT_U32        qPriority;
+}GT_QPRI_TBL_ENTRY;
+
+
+/*
+ * Typedef: struct GT_FPRI_TBL_ENTRY
+ *
+ * Description: This structure is used for the entry of Frame Priority Override
+ *                Table.
+ *
+ * Fields:
+ *        fPriEn    - GT_TRUE to enable Frame Priority, GT_FALSE otherwise
+ *        fPriority - priority to be overridden ( 0 ~ 7 ) only if fPriEn is GT_TRUE
+ *                    When fPriEn is GT_FALSE, fPriority should be ignored.
+ */
+typedef struct
+{
+    GT_BOOL        fPriEn;
+    GT_U32        fPriority;
+}GT_FPRI_TBL_ENTRY;
+
+
+/* Maximam number of ports a switch may have. */
+#define MAX_SWITCH_PORTS    11
+#define VERSION_MAX_LEN     30
+#define MAX_QOS_WEIGHTS        128
+
+/*
+ * Typedef: struct GT_QoS_WEIGHT
+ *
+ * Description: This structure is used for Programmable Round Robin Weights.
+ *
+ * Fields:
+ *      len    - length of the valid queue data
+ *        queue  - upto 128 queue data
+ */
+typedef struct
+{
+    GT_U32        len;
+    GT_U8        queue[MAX_QOS_WEIGHTS];
+}GT_QoS_WEIGHT;
+
+
+
+/*
+ * Typedef: struct GT_VERSION
+ *
+ * Description: This struct holds the package version.
+ *
+ * Fields:
+ *      version - string array holding the version.
+ *
+ */
+typedef struct
+{
+    GT_U8   version[VERSION_MAX_LEN];
+}GT_VERSION;
+
+
+/*
+ * typedef: struct GT_RMU
+ *
+ * Description: This struct holds the Remote Management Unit mode.
+ *
+ * Fields:
+ *        rmuEn    - enable or disable RMU
+ *        port    - logical port where RMU is enabled
+ */
+typedef struct
+{
+    GT_BOOL        rmuEn;
+    GT_LPORT    port;
+} GT_RMU;
+
+
+
+/*
+ * Typedef:
+ *
+ * Description: Defines the different sizes of the Mac address table.
+ *
+ * Fields:
+ *      ATU_SIZE_256    -   256 entries Mac address table.
+ *      ATU_SIZE_512    -   512 entries Mac address table.
+ *      ATU_SIZE_1024   -   1024 entries Mac address table.
+ *      ATU_SIZE_2048   -   2048 entries Mac address table.
+ *      ATU_SIZE_4096   -   4096 entries Mac address table.
+ *      ATU_SIZE_8192   -   8192 entries Mac address table.
+ *
+ */
+typedef enum
+{
+    ATU_SIZE_256,
+    ATU_SIZE_512,
+    ATU_SIZE_1024,
+    ATU_SIZE_2048,
+    ATU_SIZE_4096,
+    ATU_SIZE_8192
+}ATU_SIZE;
+
+
+/*
+ * typedef: enum GT_PORT_STP_STATE
+ *
+ * Description: Enumeration of the port spanning tree state.
+ *
+ * Enumerations:
+ *   GT_PORT_DISABLE    - port is disabled.
+ *   GT_PORT_BLOCKING   - port is in blocking/listening state.
+ *   GT_PORT_LEARNING   - port is in learning state.
+ *   GT_PORT_FORWARDING - port is in forwarding state.
+ */
+typedef enum
+{
+    GT_PORT_DISABLE = 0,
+    GT_PORT_BLOCKING,
+    GT_PORT_LEARNING,
+    GT_PORT_FORWARDING
+} GT_PORT_STP_STATE;
+
+
+/*
+ * typedef: enum GT_EGRESS_MODE
+ *
+ * Description: Enumeration of the port egress mode.
+ *
+ * Enumerations:
+ *   GT_UNMODIFY_EGRESS - frames are transmited unmodified.
+ *   GT_TAGGED_EGRESS   - all frames are transmited tagged.
+ *   GT_UNTAGGED_EGRESS - all frames are transmited untagged.
+ *   GT_ADD_TAG         - always add a tag. (or double tag)
+ */
+typedef enum
+{
+    GT_UNMODIFY_EGRESS = 0,
+    GT_UNTAGGED_EGRESS,
+    GT_TAGGED_EGRESS,
+    GT_ADD_TAG
+} GT_EGRESS_MODE;
+
+/*  typedef: enum GT_DOT1Q_MODE */
+
+typedef enum
+{
+    GT_DISABLE = 0,
+    GT_FALLBACK,
+    GT_CHECK,
+    GT_SECURE
+} GT_DOT1Q_MODE;
+
+
+/* typedef: enum GT_SW_MODE */
+
+typedef enum
+{
+    GT_CPU_ATTATCHED = 0, /* ports come up disabled */
+    GT_BACKOFF,           /* EEPROM attac mode with old half duplex backoff mode */
+    GT_STAND_ALONE,       /* ports come up enabled, ignore EEPROM */
+    GT_EEPROM_ATTATCHED   /* EEPROM defined prot states */
+} GT_SW_MODE;
+
+
+/*
+ * Typedef: enum GT_ATU_OPERARION
+ *
+ * Description: Defines the different ATU and VTU operations
+ *
+ * Fields:
+ *      FLUSH_ALL           - Flush all entries.
+ *      FLUSH_UNLOCKED      - Flush all unlocked entries in ATU.
+ *      LOAD_PURGE_ENTRY    - Load / Purge entry.
+ *      GET_NEXT_ENTRY      - Get next ATU or VTU  entry.
+ *      FLUSH_ALL_IN_DB     - Flush all entries in a particular DBNum.
+ *      FLUSH_UNLOCKED_IN_DB - Flush all unlocked entries in a particular DBNum.
+ *      SERVICE_VIOLATONS   - sevice violations of VTU
+ *
+ */
+typedef enum
+{
+    FLUSH_ALL = 1,        /* for both atu and vtu */
+    FLUSH_UNLOCKED,        /* for atu only */
+    LOAD_PURGE_ENTRY,    /* for both atu and vtu */
+    GET_NEXT_ENTRY,        /* for both atu and vtu */
+    FLUSH_ALL_IN_DB,    /* for atu only */
+    FLUSH_UNLOCKED_IN_DB,    /* for atu only */
+    SERVICE_VIOLATIONS     /* for vtu only */
+} GT_ATU_OPERATION, GT_VTU_OPERATION;
+
+
+/*
+ * typedef: enum GT_FLUSH_CMD
+ *
+ * Description: Enumeration of the address translation unit flush operation.
+ *
+ * Enumerations:
+ *   GT_FLUSH_ALL       - flush all entries.
+ *   GT_FLUSH_ALL_UNBLK - flush all unblocked (or unlocked).
+ *   GT_FLUSH_ALL_UNLOCKED - flush all unblocked (or unlocked).
+ */
+typedef enum
+{
+    GT_FLUSH_ALL       = 1,
+    GT_FLUSH_ALL_UNBLK = 2,
+    GT_FLUSH_ALL_UNLOCKED = 2
+}GT_FLUSH_CMD;
+
+/*
+ * typedef: enum GT_MOVE_CMD
+ *
+ * Description: Enumeration of the address translation unit move or remove operation.
+ *     When destination port is set to 0xF, Remove operation occurs.
+ *
+ * Enumerations:
+ *   GT_MOVE_ALL       - move all entries.
+ *   GT_MOVE_ALL_UNBLK - move all unblocked (or unlocked).
+ *   GT_MOVE_ALL_UNLOCKED - move all unblocked (or unlocked).
+ */
+typedef enum
+{
+    GT_MOVE_ALL       = 1,
+    GT_MOVE_ALL_UNBLK = 2,
+    GT_MOVE_ALL_UNLOCKED = 2
+}GT_MOVE_CMD;
+
+
+/*
+ * typedef: enum GT_ATU_UC_STATE
+ *
+ * Description:
+ *      Enumeration of the address translation unit entry state of unicast
+ *      entris.
+ *
+ * Enumerations:
+ *        GT_UC_INVALID   - invalid entry.
+ *        GT_UC_DYNAMIC   - unicast dynamic entry.
+ *        GT_UC_NO_PRI_TO_CPU_STATIC_NRL
+ *                - static unicast entry that will be forwarded to CPU without
+ *                    forcing priority and without rate limiting.
+ *        GT_UC_TO_CPU_STATIC_NRL
+ *                - static unicast entry that will be forwarded to CPU without
+ *                    rate limiting.
+ *        GT_UC_NO_PRI_STATIC_NRL
+ *                - static unicast entry without forcing priority and without.
+ *                    rate limiting.
+ *        GT_UC_NO_PRI_STATIC_AVB_ENTRY
+ *                - static unicast AVB entry without forcing priority if MacAvb is enabled.
+ *        GT_UC_STATIC_NRL    - static unicast entry without rate limiting.
+ *        GT_UC_STATIC_AVB_ENTRY - static unicast AVB entry if MacAvb is enabled .
+ *        GT_UC_NO_PRI_TO_CPU_STATIC
+ *                - static unicast entry that will be forwarded to CPU without
+ *                    forcing priority.
+ *        GT_UC_TO_CPU_STATIC - static unicast entry that will be forwarded to CPU.
+ *        GT_UC_NO_PRI_STATIC - static unicast entry without forcing priority.
+ *        GT_UC_STATIC    - static unicast entry.
+ *
+ * Note: Please refer to the device datasheet for detailed unicast entry states
+ *        that are supported by the device.
+ */
+typedef enum
+{
+    GT_UC_INVALID      = 0,
+    GT_UC_DYNAMIC      = 0x1,
+
+    GT_UC_NO_PRI_TO_CPU_STATIC_NRL    = 0x8,
+    GT_UC_TO_CPU_STATIC_NRL            = 0x9,
+    GT_UC_NO_PRI_STATIC_NRL            = 0xA,
+    GT_UC_NO_PRI_STATIC_AVB_ENTRY    = 0xA,
+    GT_UC_STATIC_NRL                 = 0xB,
+    GT_UC_STATIC_AVB_ENTRY            = 0xB,
+
+    GT_UC_NO_PRI_TO_CPU_STATIC    = 0xC,
+    GT_UC_TO_CPU_STATIC         = 0xD,
+    GT_UC_NO_PRI_STATIC         = 0xE,
+    GT_UC_STATIC                  = 0xF
+} GT_ATU_UC_STATE;
+
+
+/*
+ * typedef: enum GT_ATU_MC_STATE
+ *
+ * Description:
+ *      Enumeration of the address translation unit entry state of multicast
+ *      entris.
+ *
+ * Enumerations:
+ *      GT_MC_INVALID         - invalid entry.
+ *      GT_MC_MGM_STATIC      - static multicast management entries.
+ *      GT_MC_STATIC          - static multicast regular entris.
+ *      GT_MC_STATIC_AVB_ENTRY- static AVB entry if MacAvb is enalbed.
+ *      GT_MC_PRIO_MGM_STATIC - static multicast management entries with
+ *                              priority.
+ *      GT_MC_PRIO_STATIC     - static multicast regular entris with priority.
+ *      GT_MC_PRIO_STATIC_AVB_ENTRY      - static multicast AVB Entry with priority if MacAvb is enabled
+ *      GT_MC_PRIO_STATIC_UNLIMITED_RATE - static multicast regular entris with priority
+ *                                            and without rate limiting.
+ *      GT_MC_MGM_STATIC_UNLIMITED_RATE     - static multicast management entries without
+ *                                            rate limiting.
+ *      GT_MC_STATIC_UNLIMITED_RATE      - static multicast regular entris without
+ *                                            rate limiting.
+ *      GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE - static multicast management entries with
+ *                              priority and without rate limiting.
+ *
+ * Note: Please refer to the device datasheet for detailed multicast entry states
+ *        that are supported by the device.
+ */
+typedef enum
+{
+    GT_MC_INVALID         = 0,
+    GT_MC_MGM_STATIC_UNLIMITED_RATE = 0x4,
+    GT_MC_STATIC_UNLIMITED_RATE    = 0x5,
+    GT_MC_STATIC_AVB_ENTRY    = 0x5,
+    GT_MC_MGM_STATIC      = 0x6,
+    GT_MC_STATIC          = 0x7,
+    GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE = 0xC,
+    GT_MC_PRIO_STATIC_UNLIMITED_RATE    = 0xD,
+    GT_MC_PRIO_STATIC_AVB_ENTRY    = 0xD,
+    GT_MC_PRIO_MGM_STATIC = 0xE,
+    GT_MC_PRIO_STATIC     = 0xF
+} GT_ATU_MC_STATE;
+
+
+/*
+ *  typedef: struct GT_ATU_EXT_PRI
+ *
+ *  Description:
+ *        Extanded priority information for the address tarnslaton unit entry.
+ *
+ *        macFPri data is used to override the frame priority on any frame associated
+ *        with this MAC, if the useMacFPri is GT_TRUE and the port's SA and/or
+ *        DA FPriOverride are enabled. SA Frame Priority Overrides can only occur on
+ *        MAC addresses that are Static or where the Port is Locked, and where the port
+ *        is mapped source port for the MAC address.
+ *
+ *        macQPri data is used to override the queue priority on any frame associated
+ *        with this MAC, if the EntryState indicates Queue Priority Override and the
+ *        port's SA and/or DA QPriOverride are enabled.
+ *
+ *  Fields:
+ *      useMacFPri - Use MAC frame priority override. When this is GT_TRUE,
+ *                     MacFPri data can be used to override the frame priority on
+ *                     any frame associated with this MAC.
+ *      macFPri    - MAC frame priority data (0 ~ 7).
+ *      macQPri    - MAC queue priority data (0 ~ 3).
+ *
+ *  Comment:
+ *      Please refer to the device datasheet to find out if this feature is supported.
+ *        When this structure is implemented, the followings are the devices supporting
+ *        this feature:
+ *            88E6065, 88E6035, and 88E6055 support all extanded priority data.
+ *            88E6061 and 88E6031 support only macQPri data
+ *            88EC000 and 88E3020 family use only macFPri data
+ */
+typedef struct
+{
+    GT_BOOL            useMacFPri;
+    GT_U8             macFPri;
+    GT_U8             macQPri;
+} GT_ATU_EXT_PRI;
+
+
+/*
+ *  typedef: struct GT_ATU_ENTRY
+ *
+ *  Description: address tarnslaton unit Entry
+ *
+ *  Fields:
+ *      macAddr    - mac address
+ *      trunkMember- GT_TRUE if entry belongs to a Trunk. This field will be
+ *                     ignored if device does not support Trunk.
+ *      portVec    - port Vector.
+ *                     If trunkMember field is GT_TRUE, this value represents trunk ID.
+ *      prio       - entry priority.
+ *      entryState - the entry state.
+ *        DBNum       - ATU MAC Address Database number. If multiple address
+ *                     databases are not being used, DBNum should be zero.
+ *                     If multiple address databases are being used, this value
+ *                     should be set to the desired address database number.
+ *        exPrio     - extanded priority information. If device support extanded
+ *                     priority, prio field should be ignored.
+ *
+ *  Comment:
+ *      The entryState union Type is determine according to the Mac Type.
+ */
+typedef struct
+{
+    GT_ETHERADDR     macAddr;
+    GT_BOOL            trunkMember;
+    GT_U32            portVec;
+    GT_U8            prio;
+    GT_U8            reserved;
+    GT_U16            DBNum;
+    union
+    {
+        GT_ATU_UC_STATE ucEntryState;
+        GT_ATU_MC_STATE mcEntryState;
+    } entryState;
+    GT_ATU_EXT_PRI    exPrio;
+} GT_ATU_ENTRY;
+
+
+/*
+ *  typedef: struct GT_VTU_DATA
+ *
+ *  Description: VLAN  tarnslaton unit Data Register
+ *
+ *  Fields:
+ *      memberTagP - Membership and Egress Tagging
+ *                   memberTagP[0] is for Port 0, MemberTagP[1] is for port 1, and so on
+ *
+ *  Comment:
+ *     MAX_SWITCH_PORTS is 10 for Octane.
+ *     In the case of FullSail, there are 3 ports. So, the rest 7 is ignored in memeberTagP
+ */
+typedef struct
+{
+    GT_U8     memberTagP[MAX_SWITCH_PORTS];
+    GT_U8     portStateP[MAX_SWITCH_PORTS];
+} GT_VTU_DATA;
+
+/*
+ *  definition for MEMBER_TAG
+ */
+#define MEMBER_EGRESS_UNMODIFIED    0
+#define NOT_A_MEMBER                1
+#define MEMBER_EGRESS_UNTAGGED        2
+#define MEMBER_EGRESS_TAGGED        3
+
+/*
+ *  typedef: struct GT_VTU_EXT_INFO
+ *
+ *  Description:
+ *        Extanded VTU Entry information for Priority Override and Non Rate Limit.
+ *        Frame Priority is used to as the tag's PRI bits if the frame egresses
+ *        the switch tagged. The egresss queue the frame is switch into is not
+ *        modified by the Frame Priority Override.
+ *        Queue Priority is used to determine the egress queue the frame is
+ *        switched into. If the frame egresses tagged, the priority in the frame
+ *        will not be modified by a Queue Priority Override.
+ *        NonRateLimit for VID is used to indicate any frames associated with this
+ *        VID are to bypass ingress and egress rate limiting, if the ingress
+ *        port's VID NRateLimit is also enabled.
+ *
+ *  Fields:
+ *      useVIDFPri - Use VID frame priority override. When this is GT_TRUE and
+ *                     VIDFPriOverride of the ingress port of the frame is enabled,
+ *                     vidFPri data is used to override the frame priority on
+ *                     any frame associated with this VID.
+ *      vidFPri    - VID frame priority data (0 ~ 7).
+ *      useVIDQPri - Use VID queue priority override. When this is GT_TRUE and
+ *                     VIDQPriOverride of the ingress port of the frame is enabled,
+ *                     vidQPri data can be used to override the queue priority on
+ *                     any frame associated with this VID.
+ *      vidQPri    - VID queue priority data (0 ~ 3).
+ *      vidNRateLimit - bypass rate ingress and egress limiting
+ *
+ *  Comment:
+ *      Please refer to the device datasheet to find out if this feature is supported.
+ *        When this structure is implemented, the followings are the devices supporting
+ *        this feature:
+ *            88E6065, 88E6035, and 88E6055 support all data.
+ *            88E6061 and 88E6031 support only vidNRateLimit.
+ */
+typedef struct
+{
+    GT_BOOL            useVIDFPri;
+    GT_U8             vidFPri;
+    GT_BOOL            useVIDQPri;
+    GT_U8             vidQPri;
+    GT_BOOL            vidNRateLimit;
+} GT_VTU_EXT_INFO;
+
+
+/*
+ *  typedef: struct GT_VTU_ENTRY
+ *
+ *  Description: VLAN tarnslaton unit Entry
+ *        Each field in the structure is device specific, i.e., some fields may not
+ *        be supported by the used switch device. In such case, those fields are
+ *        ignored by the DSDT driver. Please refer to the datasheet for the list of
+ *        supported fields.
+ *
+ *  Fields:
+ *      DBNum      - database number or FID (forwarding information database)
+ *      vid        - VLAN ID
+ *      vtuData    - VTU data
+ *        vidPriOverride - override the priority on any frame associated with this VID
+ *        vidPriority - VID Priority bits (0 ~ 7)
+ *        sid           - 802.1s Port State Database ID
+ *        vidPolicy  - indicate that the frame with this VID uses VID Policy
+ *                     (see gprtSetPolicy API).
+ *        vidExInfo  - extanded information for VTU entry. If the device supports extanded
+ *                     information, vidPriorityOverride and vidPriority values are
+ *                     ignored.
+ */
+typedef struct
+{
+    GT_U16        DBNum;
+    GT_U16        vid;
+    GT_VTU_DATA   vtuData;
+    GT_BOOL          vidPriOverride;
+    GT_U8          vidPriority;
+    GT_U8          sid;
+    GT_BOOL          vidPolicy;
+    GT_VTU_EXT_INFO    vidExInfo;
+} GT_VTU_ENTRY;
+
+
+/*
+ * Typedef: enum GT_STU_OPERARION
+ *
+ * Description: Defines the STU operations
+ *
+ * Fields:
+ *      LOAD_PURGE_STU_ENTRY    - Load / Purge entry.
+ *      GET_NEXT_STU_ENTRY      - Get next STU  entry.
+ *
+ */
+typedef enum
+{
+    LOAD_PURGE_STU_ENTRY = 5,
+    GET_NEXT_STU_ENTRY =6
+} GT_STU_OPERATION;
+
+
+/*
+ *  typedef: struct GT_STU_ENTRY
+ *
+ *  Description: 802.1s Port State Information Database (STU) Entry
+ *
+ *  Fields:
+ *      sid       - STU ID
+ *        portState - Per VLAN Port States for each port.
+ */
+typedef struct
+{
+    GT_U16                sid;
+    GT_PORT_STP_STATE    portState[MAX_SWITCH_PORTS];
+} GT_STU_ENTRY;
+
+
+/*
+ *  typedef: struct GT_VTU_INT_STATUS
+ *
+ *  Description: VLAN tarnslaton unit interrupt status
+ *
+ *  Fields:
+ *      intCause  - VTU Interrupt Cause
+ *                    GT_VTU_FULL_VIOLATION,GT_MEMEBER_VIOLATION,or
+ *                    GT_MISS_VIOLATION
+ *      SPID      - source port number
+ *                     if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ *      vid       - VLAN ID
+ *                     if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ */
+typedef struct
+{
+    GT_U16   vtuIntCause;
+    GT_U8    spid;
+    GT_U16   vid;
+} GT_VTU_INT_STATUS;
+
+/*
+ *  typedef: struct GT_ATU_INT_STATUS
+ *
+ *  Description: VLAN tarnslaton unit interrupt status
+ *
+ *  Fields:
+ *      intCause  - ATU Interrupt Cause
+ *                    GT_FULL_VIOLATION,GT_MEMEBER_VIOLATION,
+ *                    GT_MISS_VIOLATION, GT_AGE_VIOLATION, or
+ *                    GT_AGE_OUT_VIOLATION
+ *      SPID      - source port number
+ *                     if intCause is GT_FULL_VIOLATION, it means nothing
+ *      DBNum     - DB Num (or FID)
+ *                     if intCause is GT_FULL_VIOLATION, it means nothing
+ *        macAddr      - MAC Address
+ */
+typedef struct
+{
+    GT_U16   atuIntCause;
+    GT_U8    spid;
+    GT_U8    dbNum;
+    GT_ETHERADDR  macAddr;
+} GT_ATU_INT_STATUS;
+
+/*
+* Definition for VTU interrupt
+*/
+#define GT_MEMBER_VIOLATION        0x4
+#define GT_MISS_VIOLATION        0x2
+#define GT_VTU_FULL_VIOLATION    0x1
+/*
+* Definitions for ATU interrupt in Gigabit switch are the same as
+* the ones for VTU interrupt. Here we just redefine the FULL_VIOLATION for
+* both VTU and ATU.
+*/
+#define GT_FULL_VIOLATION        0x1
+
+#define GT_AGE_VIOLATION        0x8
+#define GT_AGE_OUT_VIOLATION    0x10
+
+
+/*
+
+  * Typedef: enum GT_PVT_OPERATION
+ *
+ * Description: Defines the PVT (Cross Chip Port VLAN Table) Operation type
+ *
+ * Fields:
+ *      PVT_INITIALIZE - Initialize all resources to the inital state
+ *      PVT_WRITE      - Write to the selected PVT entry
+ *      PVT_READ       - Read from the selected PVT entry
+ */
+typedef enum
+{
+    PVT_INITIALIZE     = 0x1,
+    PVT_WRITE        = 0x3,
+    PVT_READ        = 0x4
+} GT_PVT_OPERATION;
+
+
+/*
+ *  typedef: struct GT_PVT_OP_DATA
+ *
+ *  Description: data required by PVT (Cross Chip Port VLAN Table) Operation
+ *
+ *  Fields:
+ *      pvtAddr - pointer to the desired entry of PVT
+ *      pvtData - Cross Chip Port VLAN data for the entry pointed by pvtAddr
+ */
+typedef struct
+{
+    GT_U32    pvtAddr;
+    GT_U32    pvtData;
+} GT_PVT_OP_DATA;
+
+
+/*
+ *  typedef: enum GT_PIRL_FC_DEASSERT
+ *
+ *  Description: Enumeration of the port flow control de-assertion mode on PIRL.
+ *
+ *  Enumerations:
+ *      GT_PIRL_FC_DEASSERT_EMPTY -
+ *                De-assert when the ingress rate resource has become empty
+ *        GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                De-assert when the ingress rate resource has enough room as
+ *                specified by the CBSLimit.
+ */
+typedef enum
+{
+    GT_PIRL_FC_DEASSERT_EMPTY = 0,
+    GT_PIRL_FC_DEASSERT_CBS_LIMIT
+} GT_PIRL_FC_DEASSERT;
+
+
+/*
+ *  typedef: enum GT_PIRL_ELIMIT_MODE
+ *
+ *  Description: Enumeration of the port egress rate limit counting mode.
+ *
+ *  Enumerations:
+ *      GT_PIRL_ELIMIT_FRAME -
+ *                Count the number of frames
+ *      GT_PIRL_ELIMIT_LAYER1 -
+ *                Count all Layer 1 bytes:
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *      GT_PIRL_ELIMIT_LAYER2 -
+ *                Count all Layer 2 bytes: Frame's DA to CRC
+ *      GT_PIRL_ELIMIT_LAYER3 -
+ *                Count all Layer 3 bytes:
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ */
+typedef enum
+{
+    GT_PIRL_ELIMIT_FRAME = 0,
+    GT_PIRL_ELIMIT_LAYER1,
+    GT_PIRL_ELIMIT_LAYER2,
+    GT_PIRL_ELIMIT_LAYER3
+} GT_PIRL_ELIMIT_MODE;
+
+
+/* typedef: enum GT_RATE_LIMIT_MODE
+ * The ingress limit mode in the rate control register (0xA)
+ */
+
+typedef enum
+{
+    GT_LIMT_ALL = 0,         /* limit and count all frames */
+    GT_LIMIT_FLOOD,          /* limit and count Broadcast, Multicast and flooded unicast frames */
+    GT_LIMIT_BRDCST_MLTCST,    /* limit and count Broadcast and Multicast frames */
+    GT_LIMIT_BRDCST           /* limit and count Broadcast frames */
+} GT_RATE_LIMIT_MODE;
+
+/* typedef: enum GT_PRI0_RATE
+ * The ingress data rate limit for priority 0 frames
+ */
+
+typedef enum
+{
+    GT_NO_LIMIT = 0,     /* Not limited   */
+    GT_128K,              /* 128K bits/sec */
+    GT_256K,              /* 256K bits/sec */
+    GT_512K,              /* 512 bits/sec */
+    GT_1M,              /* 1M  bits/sec */
+    GT_2M,              /* 2M  bits/sec */
+    GT_4M,              /* 4M  bits/sec */
+    GT_8M,              /* 8M  bits/sec */
+    GT_16M,              /* 16M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_32M,              /* 32M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_64M,              /* 64M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_128M,              /* 128M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_256M              /* 256M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+} GT_PRI0_RATE,GT_EGRESS_RATE;
+
+
+/*
+ * Typedef: union GT_ERATE_TYPE
+ *
+ * Description: Egress Rate
+ *
+ * Fields:
+ *      definedRate - GT_EGRESS_RATE enum type should be used on the following devices:
+ *                        88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183, 88E6093
+ *                        88E6095, 88E6185, 88E6108, 88E6065, 88E6061, and their variations.
+ *      kbRate      - rate in kbps that should be used on the following devices:
+ *                        88E6097, 88E6096 with count mode of non frame, such as
+ *                                    ALL_LAYER1, ALL_LAYER2, and ALL_LAYER3
+ *                        64kbps ~ 1Mbps    : increments of 64kbps,
+ *                        1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                        100Mbps ~ 1000Mbps: increments of 10Mbps
+ *                        Therefore, the valid values are:
+ *                            64, 128, 192, 256, 320, 384,..., 960,
+ *                            1000, 2000, 3000, 4000, ..., 100000,
+ *                            110000, 120000, 130000, ..., 1000000.
+ *      fRate         - frame per second that should be used on the following devices:
+ *                        88E6097, 88E6096 with count mode of frame (GT_PIRL_COUNT_FRAME)
+ */
+typedef union
+{
+    GT_EGRESS_RATE    definedRate;
+    GT_U32            kbRate;
+    GT_U32            fRate;
+} GT_ERATE_TYPE;
+
+/*
+ * Formula for Rate Limit of Gigabit Switch family and Enhanced FastEthernet Switch
+ */
+#define GT_GET_RATE_LIMIT(_kbps)    \
+        ((_kbps)?(8000000 / (28 * (_kbps))):0)
+#define GT_GET_RATE_LIMIT2(_kbps)    \
+        ((_kbps)?(8000000 / (32 * (_kbps)) + (8000000 % (32 * (_kbps))?1:0)):0)
+#define GT_GET_RATE_LIMIT3(_kbps)    \
+        ((_kbps)?(8000000 / (40 * (_kbps)) + (8000000 % (40 * (_kbps))?1:0)):0)
+
+#define MAX_RATE_LIMIT        256000    /* unit of Kbps */
+#define MIN_RATE_LIMIT        65        /* unit of Kbps */
+
+
+#define GT_GET_RATE_LIMIT_PER_FRAME(_frames, _dec)    \
+        ((_frames)?(1000000000 / (32 * (_frames)) + (1000000000 % (32 * (_frames))?1:0)):0)
+
+#define GT_GET_RATE_LIMIT_PER_BYTE(_kbps, _dec)    \
+        ((_kbps)?((8000000*(_dec)) / (32 * (_kbps)) + ((8000000*(_dec)) % (32 * (_kbps))?1:0)):0)
+
+/*
+ * typedef: enum GT_BURST_SIZE
+ * The ingress data rate limit burst size windows selection
+ */
+
+typedef enum
+{
+    GT_BURST_SIZE_12K = 0,     /* 12K byte burst size */
+    GT_BURST_SIZE_24K,        /* 24K byte burst size */
+    GT_BURST_SIZE_48K,        /* 48K byte burst size */
+    GT_BURST_SIZE_96K          /* 96K byte burst size */
+} GT_BURST_SIZE;
+
+/*
+ * typedef: enum GT_BURST_RATE
+ * The ingress data rate limit based on burst size
+ */
+
+typedef enum
+{
+    GT_BURST_NO_LIMIT = 0,     /* Not limited   */
+    GT_BURST_64K,          /* 64K bits/sec */
+    GT_BURST_128K,      /* 128K bits/sec */
+    GT_BURST_256K,      /* 256K bits/sec */
+    GT_BURST_384K,      /* 384K bits/sec */
+    GT_BURST_512K,      /* 512 bits/sec */
+    GT_BURST_640K,      /* 640K bits/sec */
+    GT_BURST_768K,      /* 768K bits/sec */
+    GT_BURST_896K,      /* 896K bits/sec */
+    GT_BURST_1M,        /* 1M  bits/sec */
+    GT_BURST_1500K,      /* 1.5M bits/sec */
+    GT_BURST_2M,        /* 2M  bits/sec */
+    GT_BURST_4M,        /* 4M  bits/sec */
+    GT_BURST_8M,           /* 8M  bits/sec */
+    GT_BURST_16M,          /* 16M  bits/sec */
+    GT_BURST_32M,          /* 32M  bits/sec */
+    GT_BURST_64M,          /* 64M  bits/sec */
+    GT_BURST_128M,         /* 128M  bits/sec */
+    GT_BURST_256M          /* 256M  bits/sec */
+} GT_BURST_RATE;
+
+/*
+ * Formula for burst based Rate Limit
+ */
+#define GT_GET_BURST_RATE_LIMIT(_bsize,_kbps)    \
+        ((_kbps)?(((_bsize)+1)*8000000 / (32 * (_kbps)) +         \
+                (((_bsize)+1)*8000000 % (32 * (_kbps))?1:0))    \
+                :0)
+
+/*
+ * Typedef: enum GT_PIRL_OPERATION
+ *
+ * Description: Defines the PIRL (Port Ingress Rate Limit) Operation type
+ *
+ * Fields:
+ *      PIRL_INIT_ALL_RESOURCE - Initialize all resources to the inital state
+ *      PIRL_INIT_RESOURCE     - Initialize selected resources to the inital state
+ *      PIRL_WRITE_RESOURCE    - Write to the selected resource/register
+ *      PIRL_READ_RESOURCE     - Read from the selected resource/register
+ */
+typedef enum
+{
+    PIRL_INIT_ALL_RESOURCE     = 0x1,
+    PIRL_INIT_RESOURCE        = 0x2,
+    PIRL_WRITE_RESOURCE        = 0x3,
+    PIRL_READ_RESOURCE        = 0x4
+} GT_PIRL_OPERATION, GT_PIRL2_OPERATION;
+
+
+/*
+ *  typedef: struct GT_PIRL_OP_DATA
+ *
+ *  Description: data required by PIRL Operation
+ *
+ *  Fields:
+ *      irlUnit   - Ingress Rate Limit Unit that defines one of IRL resources.
+ *      irlReg    - Ingress Rate Limit Register.
+ *      irlData   - Ingress Rate Limit Data.
+ */
+typedef struct
+{
+    GT_U32    irlUnit;
+    GT_U32    irlReg;
+    GT_U32    irlData;
+} GT_PIRL_OP_DATA;
+
+/*
+ *  typedef: struct GT_PIRL2_OP_DATA
+ *
+ *  Description: data required by PIRL Operation
+ *
+ *  Fields:
+ *      irlPort   - Ingress Rate Limiting port (physical port number).
+ *      irlRes    - Ingress Rate Limit Resource.
+ *      irlReg    - Ingress Rate Limit Register.
+ *      irlData   - Ingress Rate Limit Data.
+ */
+typedef struct
+{
+    GT_U32    irlPort;
+    GT_U32    irlRes;
+    GT_U32    irlReg;
+    GT_U32    irlData;
+} GT_PIRL2_OP_DATA;
+
+/*
+ * Typedef: enum GT_PIRL_ACTION
+ *
+ * Description: Defines the Action that should be taken when
+ *        there there are not enough tokens to accept the entire incoming frame
+ *
+ * Fields:
+ *        PIRL_ACTION_ACCEPT - accept the frame
+ *        PIRL_ACTION_USE_LIMIT_ACTION - use ESB Limit Action
+ */
+typedef enum
+{
+    PIRL_ACTION_USE_LIMIT_ACTION = 0x0,
+    PIRL_ACTION_ACCEPT     = 0x1
+} GT_PIRL_ACTION;
+
+/*
+ * Typedef: enum GT_ESB_LIMIT_ACTION
+ *
+ * Description: Defines the ESB Limit Action that should be taken when
+ *        the incoming port information rate exceeds the EBS_Limit.
+ *
+ * Fields:
+ *        ESB_LIMIT_ACTION_DROP - drop packets
+ *        ESB_LIMIT_ACTION_FC   - send flow control packet
+ */
+typedef enum
+{
+    ESB_LIMIT_ACTION_DROP     = 0x0,
+    ESB_LIMIT_ACTION_FC        = 0x1
+} GT_ESB_LIMIT_ACTION;
+
+
+/*
+ * Typedef: enum GT_BUCKET_RATE_TYPE
+ *
+ * Description: Defines the Bucket Rate Type
+ *
+ * Fields:
+ *        BUCKET_TYPE_TRAFFIC_BASED    - bucket is traffic type based
+ *        BUCKET_TYPE_RATE_BASED        - bucket is rate based
+ */
+typedef enum
+{
+    BUCKET_TYPE_TRAFFIC_BASED    = 0x0,
+    BUCKET_TYPE_RATE_BASED        = 0x1
+} GT_BUCKET_RATE_TYPE;
+
+/*
+ * Definition for GT_BUCKET_TYPE_TRAFFIC_BASED
+ *
+ * Description: Defines the Traffic Type that is used when Bucket Rate Type
+ *        is traffic type based (BUCKET_TYPE_TRAFFIC_BASED).
+ *        Please refer to the device datasheet in order to check which traffic
+ *        types are supported.
+ *
+ * Definition:
+ *        BUCKET_TRAFFIC_UNKNOWN_UNICAST    - unknown unicast frame
+ *        BUCKET_TRAFFIC_UNKNOWN_MULTICAST- unknown multicast frame
+ *        BUCKET_TRAFFIC_BROADCAST        - broadcast frame
+ *        BUCKET_TRAFFIC_MULTICAST        - multicast frame
+ *        BUCKET_TRAFFIC_UNICAST            - unicast frame
+ *        BUCKET_TRAFFIC_MGMT_FRAME        - management frame
+ *        BUCKET_TRAFFIC_ARP                - arp frame
+ *        BUCKET_TRAFFIC_TCP_DATA            - TCP Data
+ *        BUCKET_TRAFFIC_TCP_CTRL            - TCP Ctrl (if any of the TCP Flags[5:0] are set)
+ *        BUCKET_TRAFFIC_UDP                - UDP
+ *        BUCKET_TRAFFIC_NON_TCPUDP        - covers IGMP,ICMP,GRE,IGRP,L2TP
+ *        BUCKET_TRAFFIC_IMS                - Ingress Monitor Source
+ *        BUCKET_TRAFFIC_POLICY_MIRROR    - Policy Mirror
+ *        BUCKET_TRAFFIC_PLICY_TRAP        - Policy Trap
+ */
+#define BUCKET_TRAFFIC_UNKNOWN_UNICAST      0x01
+#define BUCKET_TRAFFIC_UNKNOWN_MULTICAST    0x02
+#define BUCKET_TRAFFIC_BROADCAST            0x04
+#define BUCKET_TRAFFIC_MULTICAST            0x08
+#define BUCKET_TRAFFIC_UNICAST                0x10
+#define BUCKET_TRAFFIC_MGMT_FRAME            0x20
+#define BUCKET_TRAFFIC_ARP                    0x40
+#define BUCKET_TRAFFIC_TCP_DATA                0x100
+#define BUCKET_TRAFFIC_TCP_CTRL                0x200
+#define BUCKET_TRAFFIC_UDP                    0x400
+#define BUCKET_TRAFFIC_NON_TCPUDP            0x800
+#define BUCKET_TRAFFIC_IMS                    0x1000
+#define BUCKET_TRAFFIC_POLICY_MIRROR        0x2000
+#define BUCKET_TRAFFIC_PLICY_TRAP            0x4000
+
+/*
+ *  typedef: enum GT_PIRL_COUNT_MODE
+ *
+ *  Description: Enumeration of the port egress rate limit counting mode.
+ *
+ *  Enumerations:
+ *      GT_PIRL_COUNT_ALL_LAYER1 -
+ *                Count all Layer 1 bytes:
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *      GT_PIRL_COUNT_ALL_LAYER2 -
+ *                Count all Layer 2 bytes: Frame's DA to CRC
+ *      GT_PIRL_COUNT_ALL_LAYER3 -
+ *                Count all Layer 3 bytes:
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ */
+typedef enum
+{
+    GT_PIRL_COUNT_ALL_LAYER1 = 0,
+    GT_PIRL_COUNT_ALL_LAYER2,
+    GT_PIRL_COUNT_ALL_LAYER3
+} GT_PIRL_COUNT_MODE;
+
+/*
+ *  typedef: enum GT_PIRL2_COUNT_MODE
+ *
+ *  Description: Enumeration of the port egress rate limit counting mode.
+ *
+ *  Enumerations:
+ *      GT_PIRL2_COUNT_FRAME -
+ *                Count the number of frames
+ *      GT_PIRL2_COUNT_ALL_LAYER1 -
+ *                Count all Layer 1 bytes:
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *      GT_PIRL2_COUNT_ALL_LAYER2 -
+ *                Count all Layer 2 bytes: Frame's DA to CRC
+ *      GT_PIRL2_COUNT_ALL_LAYER3 -
+ *                Count all Layer 3 bytes:
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ */
+typedef enum
+{
+    GT_PIRL2_COUNT_FRAME = 0,
+    GT_PIRL2_COUNT_ALL_LAYER1,
+    GT_PIRL2_COUNT_ALL_LAYER2,
+    GT_PIRL2_COUNT_ALL_LAYER3
+} GT_PIRL2_COUNT_MODE;
+
+
+
+/*
+ *  typedef: struct GT_PIRL_RESOURCE
+ *
+ *  Description: data structure that represents a PIRL Resource
+ *
+ *  Fields:
+ *      accountQConf    - account discarded frames due to queue congestion
+ *      accountFiltered - account filtered frames
+ *        ebsLimitAction  - action should be taken when the incoming rate exceeds
+ *                          the ebsLimit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed BUrst Size limit (expected to be 2kBytes)
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the
+ *                          bucket needs to be updated with tokens, or 1/CIR,
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that
+ *                          need to be removed per each bucket decrement.
+ *        bktIncrement    - the amount of tokens that need to be added for each
+ *                          byte of packet information.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED.
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME, and
+ *                                BUCKET_TRAFFIC_ARP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL_COUNT_ALL_LAYER1,
+ *                                GT_PIRL_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL_COUNT_ALL_LAYER3
+ *
+ */
+typedef struct
+{
+    GT_BOOL        accountQConf;
+    GT_BOOL        accountFiltered;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        bktRateFactor;
+    GT_U32        bktIncrement;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    GT_U32        bktTypeMask;
+    GT_PIRL_COUNT_MODE    byteTobeCounted;
+} GT_PIRL_RESOURCE;
+
+/*
+ *  typedef: struct GT_PIRL_CUSTOM_RATE_LIMIT
+ *
+ *  Description: The parameters that decides Ingress Rate Limit vary depending on
+ *                the application. Since DSDT driver cannot cover all the cases,
+ *                this structure is provided for the custom parameter setting.
+ *                However, in most cases, user may ingore this structure by setting
+ *                isValid to GT_FALSE. If Ingress Rate Limit is too much off from
+ *                the expected rate, please contact FAE and gets the correct ebsLimit,
+ *                cbsLimit,bktIncrement, and bktRateFactor value and use this structure
+ *                to do custom parameter setting.
+ *
+ *        isValid         - If GT_TRUE, the paramers in this structure are used
+ *                          to program PIRL Resource's Rate Limit. And ingressRate
+ *                          in GT_PIRL_BUCKET_DATA structure are ignored.
+ *                          If GT_FALSE, ingressRate in GT_PIRL_BUCKET_DATA structure
+ *                          is used for Resource's Rate Limit.
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed Burst Size limit (expected to be 2kBytes)
+ *        bktIncrement    - the amount of tokens that need to be added for each
+ *                          byte of packet information.
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the
+ *                          bucket needs to be updated with tokens, or 1/CIR,
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that
+ *                          need to be removed per each bucket decrement.
+*/
+typedef struct
+{
+    GT_BOOL        isValid;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        bktIncrement;
+    GT_U32        bktRateFactor;
+} GT_PIRL_CUSTOM_RATE_LIMIT;
+
+/*
+ *  typedef: struct GT_PIRL_BUCKET_DATA
+ *
+ *  Description: data structure for PIRL Bucket programing that is resource based
+ *
+ *  Fields:
+ *        ingressRate       - commited ingress rate in kbps.
+ *                          64kbps ~ 1Mbps    : increments of 64kbps,
+ *                          1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                          100Mbps ~ 200Mbps : increments of 10Mbps
+ *                          Therefore, the valid values are:
+ *                                64, 128, 192, 256, 320, 384,..., 960,
+ *                                1000, 2000, 3000, 4000, ..., 100000,
+ *                                110000, 120000, 130000, ..., 200000.
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_RATE_LIMIT structure.
+ *      accountQConf    - account discarded frames due to queue congestion
+ *      accountFiltered - account filtered frames
+ *        esbLimitAction     - action should be taken when the incoming rate exceeds
+ *                          the limit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        fcDeassertMode    - port flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                          fcDeassertMode[0] for port 0, fcDeassertMode[1] for
+ *                          port 1, etc. If port x does not share the bucket,
+ *                          fcDeassertMode[x] data will be ignored.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED.
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME, and
+ *                                BUCKET_TRAFFIC_ARP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL_COUNT_ALL_LAYER1,
+ *                                GT_PIRL_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL_COUNT_ALL_LAYER3
+ *
+ */
+typedef struct
+{
+    GT_U32        ingressRate;
+    GT_PIRL_CUSTOM_RATE_LIMIT customSetup;
+    GT_BOOL        accountQConf;
+    GT_BOOL        accountFiltered;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_PIRL_FC_DEASSERT fcDeassertMode[MAX_SWITCH_PORTS];
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    GT_U32        bktTypeMask;
+    GT_PIRL_COUNT_MODE    byteTobeCounted;
+} GT_PIRL_DATA;
+
+
+/*
+ *  typedef: struct GT_PIRL2_RESOURCE
+ *
+ *  Description: data structure that represents a PIRL Resource
+ *
+ *  Fields:
+ *      accountQConf    - account discarded frames due to queue congestion
+ *      accountFiltered - account filtered frames
+ *      mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *      saNrlEn         - exclude from ingress rate limiting calculation if the SA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *      daNrlEn         - exclude from ingress rate limiting calculation if the DA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *        samplingMode    - sample one out of so many frames/bytes for a stream of frames
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *        ebsLimitAction  - action should be taken when the incoming rate exceeds
+ *                          the ebsLimit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed BUrst Size limit (expected to be 2kBytes)
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the
+ *                          bucket needs to be updated with tokens, or 1/CIR,
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that
+ *                          need to be removed per each bucket decrement.
+ *        bktIncrement    - the amount of tokens that need to be added for each
+ *                          byte of packet information.
+ *        fcDeassertMode    - flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *      priORpt         - determine the incoming frames that get rate limited using
+ *                          this ingress rate resource.
+ *                                  GT_TRUE - typeMask OR priMask
+ *                                  GT_FALSE - typeMask AND priMask
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED.
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME,
+ *                                BUCKET_TRAFFIC_ARP,
+ *                                BUCKET_TRAFFIC_TCP_DATA,
+ *                                BUCKET_TRAFFIC_TCP_CTRL,
+ *                                BUCKET_TRAFFIC_UDP,
+ *                                BUCKET_TRAFFIC_NON_TCPUDP,
+ *                                BUCKET_TRAFFIC_IMS,
+ *                                BUCKET_TRAFFIC_POLICY_MIRROR, and
+ *                                BUCKET_TRAFFIC_PLICY_TRAP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL2_COUNT_FRAME,
+ *                                GT_PIRL2_COUNT_ALL_LAYER1,
+ *                                GT_PIRL2_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL2_COUNT_ALL_LAYER3
+ *
+ */
+typedef struct
+{
+    GT_BOOL        accountQConf;
+    GT_BOOL        accountFiltered;
+    GT_BOOL        mgmtNrlEn;
+    GT_BOOL        saNrlEn;
+    GT_BOOL        daNrlEn;
+    GT_BOOL        samplingMode;
+    GT_PIRL_ACTION    actionMode;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        bktRateFactor;
+    GT_U32        bktIncrement;
+    GT_PIRL_FC_DEASSERT fcDeassertMode;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    GT_BOOL        priORpt;
+    GT_U32        priMask;
+    GT_U32        bktTypeMask;
+    GT_PIRL2_COUNT_MODE    byteTobeCounted;
+} GT_PIRL2_RESOURCE;
+
+
+/*
+ *  typedef: struct GT_PIRL2_BUCKET_DATA
+ *
+ *  Description: data structure for PIRL2 Bucket programing that is port based.
+ *
+ *  Fields:
+ *        ingressRate       - commited ingress rate in kbps.
+ *                          64kbps ~ 1Mbps    : increments of 64kbps,
+ *                          1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                          100Mbps ~ 200Mbps : increments of 10Mbps
+ *                          Therefore, the valid values are:
+ *                                64, 128, 192, 256, 320, 384,..., 960,
+ *                                1000, 2000, 3000, 4000, ..., 100000,
+ *                                110000, 120000, 130000, ..., 200000.
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_RATE_LIMIT structure.
+ *      accountQConf    - account discarded frames due to queue congestion
+ *      accountFiltered - account filtered frames
+ *      mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *      saNrlEn         - exclude from ingress rate limiting calculation if the SA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *      daNrlEn         - exclude from ingress rate limiting calculation if the DA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *        samplingMode    - sample one out of so many frames/bytes for a stream of frames
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *        ebsLimitAction     - action should be taken when the incoming rate exceeds
+ *                          the limit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        fcDeassertMode    - flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *      priORpt         - determine the incoming frames that get rate limited using
+ *                          this ingress rate resource.
+ *                                  GT_TRUE - typeMask OR priMask
+ *                                  GT_FALSE - typeMask AND priMask
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED.
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME,
+ *                                BUCKET_TRAFFIC_ARP,
+ *                                BUCKET_TRAFFIC_TCP_DATA,
+ *                                BUCKET_TRAFFIC_TCP_CTRL,
+ *                                BUCKET_TRAFFIC_UDP,
+ *                                BUCKET_TRAFFIC_NON_TCPUDP,
+ *                                BUCKET_TRAFFIC_IMS,
+ *                                BUCKET_TRAFFIC_POLICY_MIRROR, and
+ *                                BUCKET_TRAFFIC_PLICY_TRAP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL2_COUNT_FRAME,
+ *                                GT_PIRL2_COUNT_ALL_LAYER1,
+ *                                GT_PIRL2_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL2_COUNT_ALL_LAYER3
+ *
+ */
+typedef struct
+{
+    GT_U32        ingressRate;
+    GT_PIRL_CUSTOM_RATE_LIMIT customSetup;
+    GT_BOOL        accountQConf;
+    GT_BOOL        accountFiltered;
+    GT_BOOL        mgmtNrlEn;
+    GT_BOOL        saNrlEn;
+    GT_BOOL        daNrlEn;
+    GT_BOOL        samplingMode;
+    GT_PIRL_ACTION    actionMode;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_PIRL_FC_DEASSERT fcDeassertMode;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    GT_BOOL        priORpt;
+    GT_U32        priMask;
+    GT_U32        bktTypeMask;
+    GT_PIRL2_COUNT_MODE    byteTobeCounted;
+} GT_PIRL2_DATA;
+
+
+
+/*
+ *  typedef: struct GT_PIRL_CUSTOM_TSM_CFG
+ *
+ *  Description: The parameters that decides Ingress Rate Limit for AVB frames vary
+ *                 depending on the application. Since DSDT driver cannot cover all the cases,
+ *                this structure is provided for the custom parameter setting.
+ *                However, in most cases, user may ingore this structure by setting
+ *                isValid to GT_FALSE. If Ingress Rate Limit is too much off from
+ *                the expected rate, please contact FAE and gets the correct ebsLimit,
+ *                cbsLimit, CTS interval, and action mode value and use this structure
+ *                to do custom parameter setting.
+ *
+ *        isValid         - If GT_TRUE, the paramers in this structure are used
+ *                          to program PIRL Resource's Rate Limit. And ingressRate
+ *                          in GT_PIRL_TSM_DATA structure are ignored.
+ *                          If GT_FALSE, ingressRate in GT_PIRL_TSM_DATA structure
+ *                          is used for Resource's Rate Limit.
+ *        ebsLimit        - Excess Burst Size limit (0 ~ 0xFFFF)
+ *        cbsLimit        - Committed Burst Size limit (0 ~ 0xFFFF)
+ *        ctsIntv         - Class Time Slot Interval
+ *                          0 - interval is 62.5us
+ *                          1 - interval is 125us
+ *                          2 - interval is 250us
+ *                          3 - interval is 1000us
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+*/
+typedef struct
+{
+    GT_BOOL        isValid;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        ctsIntv;
+    GT_PIRL_ACTION        actionMode;
+} GT_PIRL_CUSTOM_TSM_CFG;
+
+
+/*
+ *  typedef: struct GT_PIRL2_TSM_DATA
+ *
+ *  Description: data structure for PIRL2 TSM Ingress Rate Limit.
+ *
+ *  Fields:
+ *        ebsLimit        - Excess Burst Size limit (0 ~ 0xFFFF)
+ *        cbsLimit        - Committed Burst Size limit (0 ~ 0xFFFF)
+ *        ctsIntv         - Class Time Slot Interval
+ *                          0 - interval is 62.5us
+ *                          1 - interval is 125us
+ *                          2 - interval is 250us
+ *                          3 - interval is 1000us
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *         mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *
+ */
+typedef struct
+{
+    GT_BOOL        tsmMode;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        ctsIntv;
+    GT_PIRL_ACTION        actionMode;
+    GT_BOOL        mgmtNrlEn;
+    GT_U32        priMask;
+} GT_PIRL2_TSM_RESOURCE;
+
+
+
+/*
+ *  typedef: struct GT_PIRL2_TSM_DATA
+ *
+ *  Description: data structure for PIRL2 TSM Ingress Rate Limit.
+ *
+ *  Fields:
+ *        tsmMode            - enable/disable TSM mode.
+ *                          The following fields are ignored if diable
+ *        ingressRate       - commited ingress rate in kbps.(min 64 for 64kbps)
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_TSM_CFG structure.
+ *        mgmtNrlEn        - exclude management frame from ingress rate limiting calculation
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *
+ */
+typedef struct
+{
+    GT_BOOL        tsmMode;
+    GT_U32        ingressRate;
+    GT_PIRL_CUSTOM_TSM_CFG customSetup;
+    GT_BOOL        mgmtNrlEn;
+    GT_U32        priMask;
+} GT_PIRL2_TSM_DATA;
+
+
+
+#define MAX_PTP_CONSECUTIVE_READ    4
+
+
+/*
+ * Typedef: enum GT_PTP_OPERATION
+ *
+ * Description: Defines the PTP (Precise Time Protocol) Operation type
+ *
+ * Fields:
+ *      PTP_WRITE_DATA             - Write data to the PTP register
+ *      PTP_READ_DATA            - Read data from PTP register
+ *      PTP_READ_MULTIPLE_DATA    - Read multiple data from PTP register
+ *      PTP_READ_TIMESTAMP_DATA    - Read timestamp data from PTP register
+ *                    valid bit will be reset after read
+ */
+typedef enum
+{
+    PTP_WRITE_DATA             = 0x3,
+    PTP_READ_DATA              = 0x4,
+    PTP_READ_MULTIPLE_DATA    = 0x6,
+    PTP_READ_TIMESTAMP_DATA    = 0x8,
+} GT_PTP_OPERATION;
+
+
+/*
+ * Typedef: enum GT_PTP_SPEC
+ *
+ * Description: Defines the PTP (Precise Time Protocol) SPEC type
+ *
+ * Fields:
+ *      PTP_IEEE_1588         - IEEE 1588
+ *      PTP_IEEE_802_1AS    - IEEE 802.1as
+ */
+typedef enum
+{
+    PTP_IEEE_1588        = 0x0,
+    PTP_IEEE_802_1AS    = 0x1
+} GT_PTP_SPEC;
+
+
+/*
+ *  typedef: struct GT_PTP_OP_DATA
+ *
+ *  Description: data required by PTP Operation
+ *
+ *  Fields:
+ *      ptpPort        - physical port of the device
+ *      ptpAddr     - register address
+ *      ptpData     - data for ptp register.
+ *      ptpMultiData- used for multiple read operation.
+ *      nData         - number of data to be read on multiple read operation.
+ */
+typedef struct
+{
+    GT_U32    ptpPort;
+    GT_U32    ptpBlock;
+    GT_U32    ptpAddr;
+    GT_U32    ptpData;
+    GT_U32    ptpMultiData[MAX_PTP_CONSECUTIVE_READ];
+    GT_U32    nData;
+} GT_PTP_OP_DATA;
+
+
+
+/*
+ *  typedef: struct GT_PTP_GLOBAL_CONFIG
+ *
+ *  Description: PTP global configuration parameters
+ *
+ *  Fields:
+ *      ptpEType    - PTP Ether Type
+ *      msgIdTSEn     - Message IDs that needs time stamp
+ *      tsArrPtr     - Time stamp arrival time counter pointer (either Arr0Time or Arr1Time)
+ */
+typedef struct
+{
+    GT_U32    ptpEType;
+    GT_U32    msgIdTSEn;
+    GT_U32    tsArrPtr;
+} GT_PTP_GLOBAL_CONFIG;
+
+
+/*
+ * Typedef: enum GT_PTP_TS_MODE
+ *
+ * Description: Defines the PTP (Precise Time Protocol) Arr0 TS Mode
+ *
+ * Fields:
+ *      GT_PTP_TS_MODE_IN_REG         - Time stamp in TS regigister (original)
+ *      GT_PTP_TS_MODE_IN_RESERVED_2  - Time stamp in Frame resedved 2
+ *      GT_PTP_TS_MODE_IN_FRAME_END   - Time stamp in Frame End
+ */
+typedef enum
+{
+       GT_PTP_TS_MODE_IN_REG,
+       GT_PTP_TS_MODE_IN_RESERVED_2,
+       GT_PTP_TS_MODE_IN_FRAME_END
+} GT_PTP_TS_MODE;
+
+#define PTP_TS_LOC_RESERVED_2  0x10
+#define PTP_FRAME_SIZE 0xc0
+
+/*
+ *  typedef: struct GT_PTP_PORT_CONFIG
+ *
+ *  Description: PTP configuration parameters for each port
+ *
+ *  Fields:
+ *      transSpec    - This is to differentiate between various timing protocols.
+ *      disTSpec     - Disable Transport specific check
+ *      etJump         - offset to Ether type start address in bytes
+ *      ipJump         - offset to IP header start address counting from Ether type offset
+ *      ptpArrIntEn    - PTP port arrival interrupt enable
+ *      ptpDepIntEn    - PTP port departure interrupt enable
+ *      disTSOverwrite - disable time stamp counter overwriting until the corresponding
+ *                          timer valid bit is cleared.
+ *      arrTSMode      - PTP arrival TS mode.
+ */
+typedef struct
+{
+    GT_PTP_SPEC    transSpec;
+    GT_BOOL        disTSpec;
+    GT_U32         etJump;
+    GT_U32         ipJump;
+    GT_BOOL        ptpArrIntEn;
+    GT_BOOL        ptpDepIntEn;
+    GT_BOOL        disTSOverwrite;
+    GT_PTP_TS_MODE         arrTSMode;
+} GT_PTP_PORT_CONFIG;
+
+/*
+ *  typedef: struct GT_PTP_CONFIG
+ *
+ *  Description: PTP configuration parameters
+ *
+ *  Fields:
+ *      ptpEType    - PTP Ether Type
+ *      msgIdTSEn     - Message IDs that needs time stamp
+ *      tsArrPtr     - Time stamp arrival time counter pointer (either Arr0Time or Arr1Time)
+ *      ptpArrIntEn    - PTP port arrival interrupt enable
+ *      ptpDepIntEn    - PTP port departure interrupt enable
+ *      transSpec    - This is to differentiate between various timing protocols.
+ *      msgIdStartBit     - Message ID starting bit in the PTP common header
+ *      disTSOverwrite     - disable time stamp counter overwriting until the corresponding
+ *                          timer valid bit is cleared.
+ *      ptpPortConfig      - PTP port configuration array.
+ */
+typedef struct
+{
+    GT_U32    ptpEType;
+    GT_U32    msgIdTSEn;
+    GT_U32    tsArrPtr;
+
+    GT_U32    ptpArrIntEn;
+    GT_U32    ptpDepIntEn;
+    GT_PTP_SPEC    transSpec;
+    GT_U32    msgIdStartBit;
+    GT_BOOL    disTSOverwrite;
+    GT_PTP_PORT_CONFIG      ptpPortConfig[MAX_SWITCH_PORTS];
+} GT_PTP_CONFIG;
+
+
+/*
+ * Typedef: enum GT_PTP_TIME
+ *
+ * Description: Defines the PTP Time to be read
+ *
+ * Fields:
+ *      PTP_WRITE_DATA             - Write data to the PTP register
+ *      PTP_READ_DATA            - Read data from PTP register
+ *      PTP_READ_MULTIPLE_DATA    - Read multiple data from PTP register
+ */
+typedef enum
+{
+    PTP_ARR0_TIME = 0x0,
+    PTP_ARR1_TIME = 0x1,
+    PTP_DEP_TIME = 0x2
+} GT_PTP_TIME;
+
+
+/*
+ * Typedef: enum GT_PTP_INT_STATUS
+ *
+ * Description: Defines the PTP Port interrupt status for time stamp
+ *
+ * Fields:
+ *      PTP_INT_NORMAL        - No error condition occurred
+ *      PTP_INT_OVERWRITE     - PTP logic has to process more than one PTP frame
+ *                                  that needs time stamping before the current read.
+ *                                Only the latest one is saved.
+ *      PTP_INT_DROP          - PTP logic has to process more than one PTP frame
+ *                                  that needs time stamping before the current read.
+ *                                Only the oldest one is saved.
+ *
+ */
+typedef enum
+{
+    PTP_INT_NORMAL         = 0x0,
+    PTP_INT_OVERWRITE     = 0x1,
+    PTP_INT_DROP         = 0x2
+} GT_PTP_INT_STATUS;
+
+
+/*
+ *  typedef: struct GT_PTP_TS_STATUS
+ *
+ *  Description: PTP port status of time stamp
+ *
+ *  Fields:
+ *      isValid        - time stamp is valid
+ *      status        - time stamp error status
+ *      timeStamped    - time stamp value of a PTP frame that needs to be time stamped
+ *      ptpSeqId    - sequence ID of the frame whose time stamp information has been captured
+ */
+typedef struct
+{
+    GT_BOOL    isValid;
+    GT_U32    timeStamped;
+    GT_U32    ptpSeqId;
+    GT_PTP_INT_STATUS    status;
+} GT_PTP_TS_STATUS;
+
+
+/*
+ *  typedef: struct GT_PTP_PORT_DISCARD_STATS
+ *
+ *  Description: PTP port discard statistics. The counter (4 bit wide) wraps around after 15.
+ *
+ *  Fields:
+ *      tsDepDisCtr    - PTP departure frame discard counter for PTP frames that need time stamping.
+ *      ntsDepDisCtr    - PTP departure frame discard counter for PTP frames that do not need time stamping.
+ *      tsArrDisCtr    - PTP arrival frame discard counter for PTP frames that need time stamping.
+ *      ntsArrDisCtr    - PTP arrival frame discard counter for PTP frames that do not need time stamping.
+ */
+typedef struct
+{
+    GT_U32    tsDepDisCtr;
+    GT_U32    ntsDepDisCtr;
+    GT_U32    tsArrDisCtr;
+    GT_U32    ntsArrDisCtr;
+} GT_PTP_PORT_DISCARD_STATS;
+
+/* From Agate, to add arrival TS mode, to insert TS into frame */
+typedef enum
+{
+    PTP_ARR_TS_MODE_DIABLE  = 0,   /* PTP Arrival mode: disable TS mode modification */
+    PTP_ARR_TS_MODE_FRM_END = 1,   /* PTP Arrival mode: TS at end of frame */
+    PTP_ARR_TS_MODE_LOC_5   = 4,   /* PTP Arrival mode: TS at offset 5 in common header */
+    PTP_ARR_TS_MODE_LOC_17  = 16,  /* PTP Arrival mode: TS at offset 17 in common header */
+    PTP_ARR_TS_MODE_LOC_35  = 34,  /* PTP Arrival mode: TS at offset 35 in common header */
+    PTP_ARR_TS_MODE_LOC_ff         /* PTP Arrival mode: TS at the end of the frame */
+} GT_PTP_ARR_TS_MODE;
+
+
+
+#ifdef CONFIG_AVB_FPGA
+
+typedef enum
+{
+    PTP_CLOCK_SRC_AD_DEVICE = 0,    /* PTP Clock source is from A/D device */
+    PTP_CLOCK_SRC_FPGA                /* PTP Clock source is from Cesium FPGA */
+} GT_PTP_CLOCK_SRC;
+
+typedef enum
+{
+    PTP_P9_MODE_GMII = 0,     /* Port 9 uses GMII connect to 88E1111 */
+    PTP_P9_MODE_MII,        /* Port 9 uses MII connect to 88E1111 */
+    PTP_P9_MODE_MII_CONNECTOR,        /* Port 9 connect to MII connector */
+    PTP_P9_MODE_JUMPER        /* Use Jumper setup */
+} GT_PTP_P9_MODE;
+
+typedef enum
+{
+    GT_PTP_SIGN_NEGATIVE = 0,    /* apply Minus sign to the Duty Cycle */
+    GT_PTP_SIGN_PLUS            /* apply Plus sign to the Duty Cycle */
+} GT_PTP_SIGN;
+
+typedef struct
+{
+    GT_PTP_SIGN    adjSign;    /* determine the plus/minus sign of the duty cycle adj */
+    GT_U32    cycleStep;        /* number of steps which will be applied in adjusting the duty cycle high time
+                                of the 8KHz clock cycle.
+                                valid values are 0 ~ 7 */
+    GT_U32    cycleInterval;    /* define the interval of clock cycles for which a duty cycle adj will occur */
+    GT_U32    cycleAdjust;    /* define the number of 8KHz clock cycles for which duty cycle adj will occur
+                                within each PTP clock clycle interval.
+                                Note that (cycleAdjust <= cycleInterval) for proper operation */
+} GT_PTP_CLOCK_ADJUSTMENT;
+
+#endif
+
+/*
+ *  typedef: struct GT_TAI_EVENT_CONFIG
+ *
+ *  Description: TAI event capture configuration parameters
+ *
+ *  Fields:
+ *      eventOverwrite    - event capture overwrite
+ *      eventCtrStart     - event counter start
+ *      eventPhase        - event phase, When 0x1 the active phase of the PTP_EVREQ input
+ *        is inverted to be active low. When 0x0 the active phase of the PTP_EVREQ input
+ *        is normal activehigh
+ *      intEn             - event capture interrupt enable
+ *      captTrigEvent     - Catpture Trig. 1: from waveform generated by PTP_TRIG.
+ *                                         0: from PTP_EVREQ pin.
+ */
+typedef struct
+{
+    GT_BOOL    eventOverwrite;
+    GT_BOOL    eventCtrStart;
+    GT_BOOL    eventPhase;
+    GT_BOOL    intEn;
+    GT_BOOL    captTrigEvent;
+
+} GT_TAI_EVENT_CONFIG;
+
+
+/*
+ *  typedef: struct GT_TAI_EVENT_STATUS
+ *
+ *  Description: TAI event capture status
+ *
+ *  Fields:
+ *      isValid        - eventTime is valid
+ *      eventTime     - PTP global time when event is registered.
+ *      eventCtr    - event capture counter. increamented only if eventCtrStart is set.
+ *      eventErr    - isValid is already set when a new event is observed.
+ */
+typedef struct
+{
+    GT_BOOL    isValid;
+    GT_U32    eventTime;
+    GT_U32    eventCtr;
+    GT_BOOL    eventErr;
+} GT_TAI_EVENT_STATUS;
+
+
+typedef enum
+{
+    GT_TAI_TRIG_PERIODIC_PURSE = 0,    /* generate periodic purse */
+    GT_TAI_TRIG_ON_GIVEN_TIME        /* generate purse when
+                                    PTP global time matches with given time */
+} GT_TAI_TRIG_MODE;
+
+typedef enum
+{
+    GT_TAI_MULTI_PTP_SYNC_DISABLE = 0,  /* the EventRequest and TriggerGen interfaces operate normally. */
+    GT_TAI_MULTI_PTP_SYNC_ENABLE        /* the logic detects a low to high transition on
+                                        the EventRequest (GPIO) and transfers the value
+                                        in TrigGenAmt[31:0] (TAI Global Config 0x2, 0x3) into
+                                        the PTP Global Time register[31:0]. The EventCapTime[31:0]
+                                        (TAI global Status 0xA, 0xB) is also updated at that
+                                        instant. */
+} GT_TAI_MULTI_PTP_SYNC_MODE;
+
+
+/*
+ *  typedef: struct GT_TAI_CLOCK_SELECT
+ *
+ *  Description: TAI Clock select
+ *
+ *  Fields:
+ *      priRecClkSel      - Synchronous Ethernet Primary Recovered Clock Select.
+ *        This field indicates the internal PHY number whose recovered clock will be
+ *        presented on the SE_RCLK0 pin. The reset value of 0x7 selects no clock and
+ *        the pin is tri-stated.
+ *      syncRecClkSel     - Synchronous Ethernet Secondary Recovered Clock Select.
+ *      ptpExtClk         - PTP external Clock select
+ */
+typedef struct
+{
+    GT_U8    priRecClkSel;
+    GT_U8    syncRecClkSel;
+    GT_BOOL  ptpExtClk;
+} GT_TAI_CLOCK_SELECT;
+
+/*
+ *  typedef: struct GT_TAI_TRIGGER_CONFIG
+ *
+ *  Description: TAI trigger generator configuration parameters
+ *
+ *  Fields:
+ *      intEn         - trigger generator interrupt enable
+ *      trigPhase     - trigger phase, When 0x1 the active phase of the PTP_TRIG output
+ *        is inverted to be active low. When 0x0 the active phase of the PTP_TRIG output
+ *        is normal active high.
+ *      trigLock     - trigger Lock, When 0x1 the leading edge of PTP_TRIG will be adjudterd in following range.
+ *      trigLockRange - trigger Locking range.
+ *      lockCorrect   - Trig Lock Correction amount
+ *      lock2Correct  - Trig Lock 2 Correction amount
+ *      mode        - trigger mode, either GT_TAI_TRIG_PERIODIC_PURSE or
+ *                      GT_TAI_TRIG_ON_GIVEN_TIME
+ *      trigGenAmt     - if mode is GT_TAI_TRIG_PERIODIC_PURSE,
+ *                      this value is used as a clock period in TSClkPer increments
+ *                      If mode is GT_TAI_TRIG_ON_GIVEN_TIME,
+ *                      this value is used to compare with PTP global time.
+ *      pulseWidth        - pulse width in units of TSClkPer.
+ *                      this value should be 1 ~ 0xF. If it's 0, no changes made.
+ *                      this value is valid only in GT_TAI_TRIG_ON_GIVEN_TIME mode.
+ *      trigClkComp    - trigger mode clock compensation amount in pico sec.
+ *                      this value is valid only in GT_TAI_TRIG_PERIODIC_PURSE mode.
+ *      trigGenTime    - Trigger Generation Time.
+ *      trigGenDelay   - Trigger Generation Delay.
+ *      trigGen2Time   - Trigger Generation Time 2.
+ *      trigGen2Delay  - Trigger Generation Delay 2.
+ */
+typedef struct
+{
+    GT_BOOL   intEn;
+    GT_BOOL   trigPhase;
+    GT_BOOL   trigLock;
+    GT_U8     trigLockRange;
+    GT_U8     lockCorrect;
+    GT_U8     lockCorrect2;
+    GT_TAI_TRIG_MODE     mode;
+    GT_U32    trigGenAmt;
+    GT_U32    pulseWidth;
+    GT_U32    trigClkComp;
+    GT_U32    trigGenTime;
+    GT_U32    trigGenDelay;
+    GT_U32    trigGen2Time;
+    GT_U32    trigGen2Delay;
+} GT_TAI_TRIGGER_CONFIG;
+
+
+
+/* AVB functions */
+typedef enum
+{
+    GT_AVB_HI_FPRI,        /* AVB Hi Frame Priority */
+    GT_AVB_HI_QPRI,        /* AVB Hi Queue Priority */
+    GT_AVB_LO_FPRI,        /* AVB Lo Frame Priority */
+    GT_AVB_LO_QPRI,        /* AVB Lo Queue Priority */
+    GT_LEGACY_HI_FPRI,    /* Legacy Hi Frame Priority */
+    GT_LEGACY_HI_QPRI,    /* Legacy Hi Queue Priority */
+    GT_LEGACY_LO_FPRI,    /* Legacy Lo Frame Priority */
+    GT_LEGACY_LO_QPRI    /* Legacy Lo Queue Priority */
+} GT_AVB_PRI_TYPE;
+
+
+typedef enum
+{
+    GT_AVB_LEGACY_MODE, /* all frames entering the port are considered legacy */
+    GT_AVB_STANDARD_AVB_MODE, /*any tagged frame that ends up with an AVB frame priority is considered AVB */
+    GT_AVB_ENHANCED_AVB_MODE, /*any frame that ends up with an AVB frame priority whose DA is contained in the ATU with an AVB Entry state is considered AVB */
+    GT_AVB_SECURE_AVB_MODE   /*any frame that ends up with an AVB frame priority whose DA is contained in the ATU with an AVB entry state and whose DPV has this source port's bit set to a one is considered AVB. */
+} GT_AVB_MODE;
+
+
+/*
+ * Typedef: enum GT_AVB_FRAME_POLICY
+ *
+ * Description: Defines the policy of the frame
+ *
+ * Fields:
+ *      AVB_FRAME_POLICY_NONE - Normal frame switching
+ *      AVB_FRAME_POLICY_MIRROR - Mirror(copy) frame to the MirrorDest port
+ *      AVB_FRAME_POLICY_TRAP - Trap(re-direct) frame to the CPUDest port
+ *      AVB_FRAME_POLICY_RES - Reserved, but implemented as Discard the frame
+ *
+ */
+typedef enum
+{
+    AVB_FRAME_POLICY_NONE = 0,
+    AVB_FRAME_POLICY_MIRROR,
+    AVB_FRAME_POLICY_TRAP,
+    AVB_FRAME_POLICY_RES
+} GT_AVB_FRAME_POLICY;
+
+
+/*
+ * Typedef: enum GT_AVB_FRAME_TYPE
+ *
+ * Description:
+ *        Defines the AVB frame type.
+ *        AVB Hi Frame is one that DA of the frame is contained in the ATU with an
+ *        Entry State that indicates AVB with priority override where the overridden
+ *        priority equals the Hi AVB frame priority(refer to gavbGetPriority API) and
+ *        when the port's DA AvbOverride is enabled.
+ *        AVB Lo Frame is one that DA of the frame is contained in the ATU with an
+ *        Entry State that indicates AVB with priority override where the overridden
+ *        priority equals the Lo AVB frame priority(refer to gavbGetPriority API) and
+ *        when the port's DA AvbOverride is enabled.
+ *
+ * Fields:
+ *      AVB_HI_FRAME    - AVB Hi Frame
+ *      AVB_LO_FRAME    - AVB Lo Frame
+ */
+typedef enum
+{
+    AVB_HI_FRAME,
+    AVB_LO_FRAME
+} GT_AVB_FRAME_TYPE;
+
+
+/*
+ * Typedef: enum GT_TCAM_OPERATION
+ *
+ * Description: Defines the TCAM (Ternary Content Addressable Memory) Operation type
+ *
+ * Fields:
+ *   TCAM_FLUSH_ALL       - Flush all entries
+ *   TCAM_FLUSH_ENTRY     - Flush or invalidate a single TCAM entry
+ *   TCAM_LOAD_ENTRY      - Load qn entry's page - or Purge an entry
+ *   TCAM_GET_NEXT_ENTRY  - Get Next (read next valid entry - all pages)
+ *   TCAM_READ_ENTRY      - Read an entry's page (perform a direct read of an entry)
+ */
+typedef enum
+{
+    TCAM_FLUSH_ALL       = 0x1,
+    TCAM_FLUSH_ENTRY     = 0x2,
+    TCAM_LOAD_ENTRY      = 0x3,
+    TCAM_PURGE_ENTRY     = 0x6,
+    TCAM_GET_NEXT_ENTRY  = 0x4,
+    TCAM_READ_ENTRY      = 0x5
+} GT_TCAM_OPERATION;
+
+typedef enum
+{
+    FRAME_TYPE_NORMAL  = 0,
+    FRAME_TYPE_DSA     = 1,
+    FRAME_TYPE_PROVIDE = 2,
+    FRAME_TYPE_RES = 3,
+} GT_FRAME_TYPE;
+
+/* The P3 register 31 work as follows in the following example sequence:
+o 0x00FF = Reset state, no hits yet
+o 0x0000 = 48-byte TCAM hit on Entry 0x00
+o 0x0201 = 96-byte TCAM hit on Entries 0x01 (low) and 0x02 (high)
+o 0x0003 = 48-byte TCAM hit on Entry 0x03
+o 0x0809 = 96-byte TCAM hit on Entries 0x09 (low) and 0x08 (high)
+o 0x0009 = 48-byte TCAM hit on Entry 0x09 with a TCAM miss on the high 48-bytes
+o 0x00FF = Miss on 1st 48 byte lookup
+*/
+typedef enum
+{
+    TCAM_HIT_RESET  = 0xFF,
+    TCAM_HIT_48_E0  = 0x00,
+    TCAM_HIT_96_E1  = 0x201,
+    TCAM_HIT_48_E3  = 0x03,
+    TCAM_HIT_96_E9  = 0x809,
+    TCAM_HIT_48_MISS  = 0x0FF,
+} GT_TCAM_HIT_STATUS;
+
+
+
+/*
+ *  typedef: struct GT_TCAM_DATA
+ *
+ *  Description: TCAM Key Data and Frame Match Data.
+ *  The bytes are in the lower 8 bits of each 16-bit register. The upper 8 bits of
+ *  each register are the Mask bits for the lower 8 bits where bit 15 is the mask
+ *  for bit 7, bit 14 is the mask for bit 6, etc. The individual pairs of data bits
+ *  and mask bits work together as follows:
+ *    Mask Data Meaning
+ *      0 0 Dont Care. The data bit can be a one or a zero for a TCAM hit to occur.
+ *      1 0 Hit on 0. The data bit must be a zero for a TCAM hit to occur.
+ *      1 1 Hit on 1. The data bit must be a one for a TCAM hit to occur.
+ *      0 1 Never Hit. Used to prevent a TCAM hit from occurring from this entry.
+ *    The Never Hit value is used to Flush the TCAM or Purge a TCAM entry.
+ *    On a TCAM Flush or Purge, this value it written to the 1st TCAM byte only
+ *    (offset 0x02 on TCAM page 1). On a TCAM Flush All or on a TCAM Flush
+ *    an entry, all other TCAM data and mask bytes are written to a value of 0x0000
+ *    and so are the Action bytes.
+ *
+ *  Fields:
+ *      frameType      - Frame Type. These bits are used to define the Frame type or mode
+ *      frameTypeMask  - Frame Type Mask.
+ *      spv      - Source Port Vector. These bits are used to define which switch ports
+ *                 can use this TCAM entry.
+ *      spvMask  - Source Port Vector Mask.
+ *      ppri      - When the TCAM entrys FrameMode bits are Provider Tagged, these bits are
+ *                  Provider Priority bits.
+ *      ppriMask  - Provider Priority Mask.
+ *      pvid      - When the TCAM entrys FrameMode bits are Provider Tagged, these bits are
+ *                  Provider VID bits..
+ *      pvidMask  - Provider VID Mask.
+ *      frameOctet      - Frame Octet 1-48 and 49-96. These are the match data for octet
+ *                        1-48 of the frame if the TCAM entry is for the first 48 bytes
+ *                        of a frame. If this TCAM entry is for the second 48 bytes of
+ *                        a frame this is the match data for octet 49 (or 97).
+ *      frameOctetMask  - Frame Octet Mask.
+ *      continu  - Continue this TCAM entry. This bit should only be a 1 on TCAM entries
+ *                that cover the first 48 bytes of a frame that needs to be extended to
+ *                also match bytes 49 to 96 of the frame or on any subsequent continuation
+ *                beyond byte 96 of the frame.
+ *      interrupt  - Interrupt on a TCAM hit. When this bit is set to a one on a TCAM entry
+ *                   (where the Continue bit is a zero), a TCAM hit interrupt will be
+ *                   generated whenever a match occurs to this entry.
+ *      IncTcamCtr   - Increment the ports TCAM Counter on a TCAM hit.
+ *      vidOverride  - VID Override Enable.
+ *      vidData    - VID Override Data.
+ *      nextId     - Next Index or Flow ID.
+ *      qpriOverride  - QPRI Override Enable.
+ *      qpriData      - QPRI Override Data.
+ *      fpriOverride  - FPRI Override Enable.
+ *      fpriData      - FPRI Override Data.
+ *      qpriAvbOverride  - QPRI_AVB Override Enable.
+ *      qpriAvbData      - QPRI_AVB Override Data.
+ *      dpvOverride  - DPV Override Enable.
+ *      dpvData      - DPV Override Data.
+ *      factionOverride  - Frame Action Override Enable.
+ *      factionData      - Frame Action Override Data.
+ *      ldBalanceOverride  - Load Balance Override Enable.
+ *      ldBalanceData      - Load Balance Override Data.
+ *      debugPort    - Debug Port Number.
+ *      highHit      - TCAM Entry for High 48-byte Hit..
+ *      lowHit       - TCAM Entry for High 48-byte Hit..
+*/
+typedef union
+{
+  GT_U16  frame[18];
+  struct {
+    GT_U8   destAddr[6];
+    GT_U8   srcAddr[6];
+    GT_U16  tag;
+    GT_U16  priVid;
+    GT_U16  ethType;
+  } paraFrmHd;
+} GT_TCAM_FRM_HD;
+
+typedef union
+{
+  GT_U16  data;
+  struct {
+    GT_U16   oct:8;
+    GT_U16   mask:8;
+  } struc;
+} GT_TCAM_FRAME;
+
+typedef union
+{
+  GT_U16  frame[28];  /* first part is 0-48 bytes of frame */
+                       /* second part is 47-96 bytes of frame */
+  struct {
+  /* Pg0 registers */
+    GT_U16       pg0Op;
+
+    GT_U16       pg0res0;
+
+    GT_U16       spvRes:3;
+    GT_U16       type0Res:3;
+    GT_U16       frame0Type:2;
+    GT_U16       maskType:8;
+
+    GT_U16       spv:8;
+    GT_U16       spvMask:8;
+
+    GT_U16       pvid0Hi:4;
+    GT_U16       ppri0:4;
+    GT_U16       pvid0MaskHi:4;
+    GT_U16       ppri0Mask:4;
+
+    GT_U16       pvid0Low:8;
+    GT_U16       pvidMask0Low:8;
+
+    GT_TCAM_FRAME frame0[22];
+  }  paraFrm;
+} GT_TCAM_FRM0_DATA;
+typedef union
+{
+  GT_U16  frame[28];  /* first part is 0-48 bytes of frame */
+                       /* second part is 47-96 bytes of frame */
+  struct {
+  /* Pg1 registers */
+    GT_U16       pg1Op;
+    GT_U16       pg1res0;
+    GT_TCAM_FRAME frame1[26];
+
+  }  paraFrm;
+} GT_TCAM_FRM1_DATA;
+typedef union
+{
+  GT_U16  frame[28];  /* first part is 0-48 bytes of frame */
+                       /* second part is 47-96 bytes of frame */
+  struct {
+  /* Pg2 registers */
+    GT_U16       pg2Op;
+
+    GT_U16       pg2res0;
+
+    GT_U16       vidData:12;
+    GT_U16       pg2res1:1;
+    GT_U16       IncTcamCtr:1;
+    GT_U16       interrupt:1;
+    GT_U16       continu:1;
+
+    GT_U16        fpriData:3;
+    GT_U16        pg2res3:1;
+    GT_U16        qpriData:2;
+    GT_U16        pg2res2:2;
+    GT_U16        nextId:8;
+
+    GT_U16        dpvData:11;
+    GT_U16        pg2res5:1;
+    GT_U16        qpriAvbData:2;
+    GT_U16        pg2res4:2;
+
+    GT_U16        ldBalanceData:3;
+    GT_U16        pg2res7:1;
+    GT_U16       factionData:11;
+    GT_U16        pg2res6:1;
+  }  paraFrm;
+} GT_TCAM_FRM2_DATA;
+
+typedef struct
+{
+  /* Pg0 registers */
+  GT_TCAM_FRM0_DATA frame0;
+  /* Pg1 registers */
+  GT_TCAM_FRM1_DATA frame1;
+  /* Pg2 registers */
+  GT_TCAM_FRM2_DATA frame2;
+} GT_TCAM_FRM_DATA;
+
+typedef struct
+{
+  GT_TCAM_FRM_DATA  rawFrmData[2];  /* first part is 0-48 bytes of frame */
+                                    /* second part is 47-96 bytes of frame */
+    GT_U8        frameType;
+    GT_U8        frameTypeMask;
+    GT_U8        spv;
+    GT_U8        spvMask;
+    GT_U8        ppri;
+    GT_U8        ppriMask;
+    GT_U16       pvid;
+    GT_U16       pvidMask;
+    GT_U8        frameOctet[96];
+    GT_U8        frameOctetMask[96];
+    GT_U8        continu;
+    GT_U8        interrupt;
+    GT_U8        IncTcamCtr;
+    GT_U8        vidOverride;
+    GT_U16       vidData;
+    GT_U8        nextId;
+    GT_U8        qpriData;
+    GT_U8        fpriData;
+    GT_U8        qpriAvbData;
+    GT_U8        dpvData;
+    GT_U8        factionOverride;
+    GT_U16       factionData;
+    GT_U8        ldBalanceOverride;
+    GT_U8        ldBalanceData;
+    GT_U8        debugPort;
+    GT_U8        highHit;
+    GT_U8        lowHit;
+    GT_U8        is96Frame;
+} GT_TCAM_DATA;
+
+/*
+ *  typedef: struct GT_TCAM_OP_DATA
+ *
+ *  Description: data required by TCAM (Ternary Content Addressable Memory) Operation
+ *
+ *  Fields:
+ *      tcamPage - page  of TCAM
+ *      tcamEntry - pointer to the desired entry of TCAM
+ *      tcamData - TCAM data for the entry pointed by tcamEntry
+ */
+
+typedef struct
+{
+    GT_U32    tcamPage;
+    GT_U32    tcamEntry;
+    GT_TCAM_DATA    *tcamDataP;
+} GT_TCAM_OP_DATA;
+
+
+/*
+ * typedef: enum GT_EVENT_TYPE
+ *
+ * Description: Enumeration of the available hardware driven events.
+ *
+ * Enumerations:
+ *   GT_AVB_INT    - AVB Interrupt Enable
+ *   GT_DEVICE_INT - Device Interrupt (GT_DEVICE_INT_TYPE) Enable
+ *   GT_STATS_DONE - Statistics Operation Done interrrupt Enable
+ *   GT_VTU_PROB - VLAN Problem/Violation Interrupt Enable
+ *   GT_VTU_DONE - VALN Table Operation Done Interrupt Enable
+ *   GT_ATU_PROB - ATU Problem/Violation Interrupt Enable, for Gigabit Switch
+ *   GT_ATU_FULL - ATU full interrupt enable, for Fast Ethernet Switch
+ *   GT_ATU_DONE - ATU Done interrupt enable.
+ *   GT_PHY_INT  - PHY interrupt enable, for Fast Ethernet Switch
+ *   GT_EE_INT   - EEPROM Done interrupt enable.
+ */
+#define GT_AVB_INT               0x100
+#define GT_DEVICE_INT           0x80
+#define GT_STATS_DONE           0x40
+#define GT_VTU_PROB             0x20
+#define GT_VTU_DONE             0x10
+#define GT_ATU_PROB         0x8
+#define GT_ATU_FULL         0x8
+#define GT_ATU_DONE            0x4
+#define GT_PHY_INTERRUPT    0x2        /* Device may not support PHY Int. Please refer to datasheet. */
+#define GT_EE_INTERRUPT        0x1
+
+#define GT_INT_MASK            \
+        (GT_AVB_INT | GT_DEVICE_INT | GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_FULL |     \
+        GT_ATU_DONE | GT_PHY_INTERRUPT | GT_EE_INTERRUPT)
+#define GT_NO_INTERNAL_PHY_INT_MASK        \
+        (GT_AVB_INT | GT_DEVICE_INT | GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_PROB |     \
+        GT_ATU_DONE | GT_EE_INTERRUPT)
+
+
+/*
+ *  typedef: struct GT_DEV_EVENT
+ *
+ *  Description: Device interrupt status
+ *
+ *  Fields:
+ *      event     - Device Interrupts to be enabled
+ *                    GT_DEV_INT_WATCHDOG, GT_DEV_INT_JAMLIMIT,
+ *                    GT_DEV_INT_DUPLEX_MISMATCH, and/or GT_DEV_INT_SERDES_LINK
+ *      portList  - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt needs
+ *                    to be asserted. It's in vector format, Bit 10 is for port 10,
+ *                    Bit 9 is for port 9, etc.
+ *                    valid only if GT_DEV_INT_SERDES_LINK bit is set.
+ *      phyList   - Phy list where GT_DEV_INT_PHY interrupt needs to be asserted.
+ *                    It's in vector format, Bit 0 is for port 0,
+ *                    Bit 1 is for port 1, etc.
+ *                    valid only if GT_DEV_INT_PHY bit is set.
+ */
+typedef struct
+{
+    GT_U32        event;
+    GT_U32        portList;
+    GT_U32        phyList;
+} GT_DEV_EVENT;
+
+
+/*
+ *  typedef: struct GT_DEV_INT_STATUS
+ *
+ *  Description: Device interrupt status
+ *
+ *  Fields:
+ *      intCause  - Device Interrupt Cause
+ *                    GT_DEV_INT_WATCHDOG, GT_DEV_INT_JAMLIMIT,
+ *                    GT_DEV_INT_DUPLEX_MISMATCH, and/or GT_DEV_INT_SERDES_LINK
+ *        port      - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
+ *                    valid only if GT_DEV_INT_DUPLEX_MISMATCH is set.
+ *      linkInt   - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
+ *                    asserted. It's in vector format, Bit 10 is for port 10,
+ *                    Bit 9 is for port 9, etc.
+ *                    valid only if GT_DEV_INT_SERDES_LINK bit is set.
+ *                    These bits are only valid of the port that is in 1000Base-X mode.
+ */
+typedef struct
+{
+    GT_U32        devIntCause;
+    GT_LPORT    port;
+    GT_U32        linkInt;
+    GT_U32        phyInt;
+} GT_DEV_INT_STATUS;
+
+
+/*
+* GT_DEVICE_INT
+*
+* Description: Enumeration of Device interrupt
+*    GT_DEV_INT_WATCHDOG        - WatchDog event interrupt (WatchDog event can be
+*                              configured with gwdSetEvent API)
+*    GT_DEV_INT_JAMLIMIT        - any of the ports detect an Ingress Jam Limit violation
+*                              (gprtSetPauseLimitIn API)
+*    GT_DEV_INT_DUPLEX_MISMATCH    - any of the ports detect a duplex mismatch
+*                              (i.e., the local port is in half duplex mode while
+*                              the link partner is in full duplex mode)
+*    GT_DEV_INT_SERDES_LINK    - SERDES link chage interrupt.
+*                              An interrupt occurs when a SERDES port changes link
+*                              status (link up or link down)
+*/
+
+#define GT_DEV_INT_WATCHDOG            0x8
+#define GT_DEV_INT_JAMLIMIT            0x4
+#define GT_DEV_INT_DUPLEX_MISMATCH    0x2
+#define GT_DEV_INT_SERDES_LINK        0x1
+#define GT_DEV_INT_WAKE_EVENT         0x1
+#define GT_DEV_INT_PHY                0x10
+
+/*
+* GT_WATCHDOG_EVENT
+*
+* Description: Enumeration of WatchDog event
+*        GT_WD_QC  - Queue Controller Watch Dog enable.
+*                    When enabled, the QC's watch dog circuit checks for link
+*                    list errors and any errors found in the QC.
+*        GT_WD_EGRESS - Egress Watch Dog enable.
+*                    When enabled, each port's egress circuit checks for problems
+*                    between the port and the Queue Controller.
+*        GT_WD_FORCE - Force a Watch Dog event.
+*/
+
+#define GT_WD_QC        0x1
+#define GT_WD_EGRESS    0x2
+#define GT_WD_FORCE        0x4
+
+
+/*
+* typedef: struct GT_WD_EVENT_HISTORY
+*
+* Description: WatchDog Event History (cleared only by a hardware reset)
+*        wdEvent   - When it's set to GT_TRUE, some enabled Watch Dog event occurred.
+*                    The following events are possible:
+*                        QC WatchDog Event (GT_WD_QC)
+*                        Egress WatchDog Event (GT_WD_EGRESS)
+*                        Forced WatchDog Event (GT_WD_FORCE)
+*        egressEvent-If any port's egress logic detects an egress watch dog issue,
+*                    this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
+*                    event.
+*/
+typedef struct
+{
+    GT_BOOL    wdEvent;
+    GT_BOOL egressEvent;
+} GT_WD_EVENT_HISTORY;
+
+
+/*
+* typedef: enum GT_PHY_INT
+*
+* Description: Enumeration of PHY interrupt
+*/
+
+#define GT_SPEED_CHANGED         0x4000
+#define GT_DUPLEX_CHANGED        0x2000
+#define GT_PAGE_RECEIVED        0x1000
+#define GT_AUTO_NEG_COMPLETED    0x800
+#define GT_LINK_STATUS_CHANGED    0x400
+#define GT_SYMBOL_ERROR            0x200
+#define GT_FALSE_CARRIER        0x100
+#define GT_FIFO_FLOW            0x80
+#define GT_CROSSOVER_CHANGED    0x40
+#define GT_POLARITY_CHANGED        0x2
+#define GT_JABBER                0x1
+
+#define GT_AUTO_NEG_ERROR        0x8000
+#define GT_DOWNSHIFT_DETECT        0x20
+#define GT_ENERGY_DETECT        0x10
+
+/*
+* typedef: enum GT_PHY_AUTO_MODE
+*
+* Description: Enumeration of Autonegotiation mode.
+*    Auto for both speed and duplex.
+*    Auto for speed only and Full duplex.
+*    Auto for speed only and Half duplex. (1000Mbps is not supported)
+*    Auto for duplex only and speed 1000Mbps.
+*    Auto for duplex only and speed 100Mbps.
+*    Auto for duplex only and speed 10Mbps.
+*    1000Mbps Full duplex.
+*    100Mbps Full duplex.
+*    100Mbps Half duplex.
+*    10Mbps Full duplex.
+*    10Mbps Half duplex.
+*/
+
+typedef enum
+{
+    SPEED_AUTO_DUPLEX_AUTO,
+    SPEED_1000_DUPLEX_AUTO,
+    SPEED_100_DUPLEX_AUTO,
+    SPEED_10_DUPLEX_AUTO,
+    SPEED_AUTO_DUPLEX_FULL,
+    SPEED_AUTO_DUPLEX_HALF,
+    SPEED_1000_DUPLEX_FULL,
+    SPEED_1000_DUPLEX_HALF,
+    SPEED_100_DUPLEX_FULL,
+    SPEED_100_DUPLEX_HALF,
+    SPEED_10_DUPLEX_FULL,
+    SPEED_10_DUPLEX_HALF
+}GT_PHY_AUTO_MODE;
+
+
+/*
+* typedef: enum GT_PHY_PAUSE_MODE
+*
+* Description: Enumeration of Pause Mode in the Phy.
+*
+* Enumerations:
+*    GT_PHY_NO_PAUSE        - disable pause
+*    GT_PHY_PAUSE        - support pause
+*    GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*    GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
+*/
+typedef enum
+{
+    GT_PHY_NO_PAUSE = 0,
+    GT_PHY_PAUSE,
+    GT_PHY_ASYMMETRIC_PAUSE,
+    GT_PHY_BOTH_PAUSE
+} GT_PHY_PAUSE_MODE;
+
+
+/*
+* typedef: enum GT_PHY_SPEED
+*
+* Description: Enumeration of Phy Speed
+*
+* Enumerations:
+*    PHY_SPEED_10_MBPS   - 10Mbps
+*    PHY_SPEED_100_MBPS    - 100Mbps
+*    PHY_SPEED_1000_MBPS - 1000Mbps
+*/
+typedef enum
+{
+    PHY_SPEED_10_MBPS,
+    PHY_SPEED_100_MBPS,
+    PHY_SPEED_1000_MBPS
+} GT_PHY_SPEED;
+
+
+/*
+* typedef: enum GT_SERDES_MODE
+*
+* Description: Enumeration of Serdes mode
+*
+* Enumerations:
+*    PHY_SERDES_100FX     - 100 FX
+*    PHY_SERDES_1000X     - 1000 X
+*    PHY_SERDES_SGMII_PHY - SGMII PHY
+*    PHY_SERDES_SGMII_MAC - SGMII MAC
+*/
+typedef enum
+{
+    PHY_SERDES_100FX = 0,
+    PHY_SERDES_1000X,
+    PHY_SERDES_SGMII_PHY,
+    PHY_SERDES_SGMII_MAC
+} GT_SERDES_MODE;
+
+
+/*
+* typedef: enum GT_EDETECT_MODE
+*
+* Description: Enumeration of Energy Detect mode
+*
+* Enumerations:
+*    GT_EDETECT_OFF        - Energy Detect disabled
+*    GT_EDETECT_SENSE_PULSE    - Energy Detect enabled with sense and pulse
+*    GT_EDETECT_SENSE    - Energy Detect enabled only with sense
+*/
+typedef enum
+{
+    GT_EDETECT_OFF = 0,
+    GT_EDETECT_SENSE_PULSE,
+    GT_EDETECT_SENSE
+} GT_EDETECT_MODE;
+
+/*
+ * typedef: enum GT_INGRESS_MODE
+ *
+ * Description: Enumeration of the port ingress mode.
+ *
+ * Enumerations:
+ *   GT_UNMODIFY_INGRESS - frames are receive unmodified.
+ *   GT_TRAILER_INGRESS  - all frames are received with trailer.
+ *   GT_UNTAGGED_INGRESS  - remove tag on receive (for double tagging).
+ *   GT_CPUPORT_INGRESS - no trailer. used to identify the CPU port for IGMP/MLD Snooping
+ */
+typedef enum
+{
+    GT_UNMODIFY_INGRESS = 0,  /* 0x00 */
+    GT_TRAILER_INGRESS,       /* 0x01 */
+    GT_UNTAGGED_INGRESS,      /* 0x10 */
+    GT_CPUPORT_INGRESS        /* 0x11 */
+} GT_INGRESS_MODE;
+
+
+/*
+ * typedef: enum GT_EGRESS_FLOOD
+ *
+ * Description: Enumeration of the port ingress mode.
+ *
+ * Enumerations:
+ *   GT_BLOCK_EGRESS_UNKNOWN - do not egress frame with unknown DA
+ *   GT_BLOCK_EGRESS_UNKNOWN_MULTICAST - do not egress frame with unknown multicast DA
+ *   GT_BLOCK_EGRESS_UNKNOWN_UNIICAST - do not egress frame with unknown unicast DA
+ *   GT_BLOCK_EGRESS_NONE - egress all frames with unknown DA
+ */
+typedef enum
+{
+    GT_BLOCK_EGRESS_UNKNOWN = 0,
+    GT_BLOCK_EGRESS_UNKNOWN_MULTICAST,
+    GT_BLOCK_EGRESS_UNKNOWN_UNICAST,
+    GT_BLOCK_EGRESS_NONE
+} GT_EGRESS_FLOOD;
+
+
+/*
+ *  typedef: enum GT_MC_RATE
+ *
+ *  Description: Enumeration of the port ingress mode.
+ *
+ *  Enumerations:
+ *      GT_MC_3_PERCENT_RL   - multicast rate is limited to 3 percent.
+ *      GT_MC_6_PERCENT_RL   - multicast rate is limited to 6 percent.
+ *      GT_MC_12_PERCENT_RL  - multicast rate is limited to 12 percent.
+ *      GT_MC_100_PERCENT_RL - unlimited multicast rate.
+ */
+typedef enum
+{
+    GT_MC_3_PERCENT_RL = 0,
+    GT_MC_6_PERCENT_RL,
+    GT_MC_12_PERCENT_RL,
+    GT_MC_100_PERCENT_RL,
+} GT_MC_RATE;
+
+
+/*
+ *  typedef: enum GT_INGRESS_RATE_MODE
+ *
+ *  Description: Enumeration of the port ingress rate limit mode.
+ *
+ *  Enumerations:
+ *      GT_RATE_PRI_BASE   - Priority based rate limiting
+ *        GT_RATE_BURST_BASE - Burst Size based rate limiting
+ */
+typedef enum
+{
+    GT_RATE_PRI_BASE = 0,
+    GT_RATE_BURST_BASE
+} GT_INGRESS_RATE_MODE;
+
+
+/*
+ *  typedef: enum GT_PORT_SCHED_MODE
+ *
+ *  Description: Enumeration of port scheduling mode
+ *
+ *  Fields:
+ *         GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+ *         GT_PORT_SCHED_STRICT_PRI3 - use a strict for priority 3 and weighted
+ *                                    round robin for the priority 2,1,and 0
+ *         GT_PORT_SCHED_STRICT_PRI2_3 - use a strict for priority 2,3 and weighted
+ *                                    round robin for the priority 1,and 0
+ *         GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+ *
+ *  Comment:
+ */
+typedef enum
+{
+    GT_PORT_SCHED_WEIGHTED_RRB = 0,
+    GT_PORT_SCHED_STRICT_PRI3,
+    GT_PORT_SCHED_STRICT_PRI2_3,
+    GT_PORT_SCHED_STRICT_PRI
+} GT_PORT_SCHED_MODE;
+
+
+/*
+ *  typedef: struct GT_PORT_STAT
+ *
+ *  Description: port statistic struct.
+ *
+ *  Fields:
+ *      rxCtr   - port receive counter.
+ *      txCtr   - port transmit counter.
+ *      dropped - dropped frame counter.
+ *
+ *  Comment:
+ *        dropped frame counter is supported by only limited devices.
+ *        At this moment, 88E6061/88E6065 are the devices supporting
+ *        dropped frame counter.
+ */
+typedef struct
+{
+    GT_U16  rxCtr;
+    GT_U16  txCtr;
+    GT_U16  dropped;
+} GT_PORT_STAT;
+
+/*
+ *  typedef: struct GT_PORT_STAT2
+ *
+ *  Description: port statistic struct.
+ *
+ *  Fields:
+ *      inDiscardLo - InDiscards Low Frame Counter
+ *      inDiscardHi - InDiscards High Frame Counter
+ *      inFiltered  - InFiltered Frame Counter
+ *      outFiltered - OutFiltered Frame Counter
+ *
+ *  Comment:
+ */
+typedef struct
+{
+    GT_U16  inDiscardLo;
+    GT_U16  inDiscardHi;
+    GT_U16  inFiltered;
+    GT_U16  outFiltered;
+} GT_PORT_STAT2;
+
+
+/*
+ **  typedef: struct GT_PORT_Q_COUNTERS
+ **
+ **  Description: port queue statistic struct.
+ **
+ **  Fields:
+ **      OutQ_Size - port egress queue size coi
+ **      Rsv_Size  - ingress reserved e counter
+ **
+ **/
+typedef struct
+{
+    GT_U16  OutQ_Size;
+    GT_U16  Rsv_Size;
+} GT_PORT_Q_STAT;
+
+/*
+ * typedef: enum GT_CTR_MODE
+ *
+ * Description: Enumeration of the port counters mode.
+ *
+ * Enumerations:
+ *   GT_CTR_ALL    - In this mode the counters counts Rx receive and transmit
+ *                   frames.
+ *   GT_CTR_ERRORS - In this mode the counters counts Rx Errors and collisions.
+ */
+typedef enum
+{
+    GT_CTR_ALL = 0,
+    GT_CTR_ERRORS,
+} GT_CTR_MODE;
+
+typedef struct _GT_QD_DEV GT_QD_DEV;
+
+/*
+ * semaphore related definitions.
+ * User Applications may register Semaphore functions using following definitions
+ */
+typedef enum
+{
+    GT_SEM_EMPTY,
+    GT_SEM_FULL
+} GT_SEM_BEGIN_STATE;
+
+typedef GT_SEM (*FGT_SEM_CREATE)(
+                        GT_SEM_BEGIN_STATE state);
+typedef GT_STATUS (*FGT_SEM_DELETE)(
+                        GT_SEM semId);
+typedef GT_STATUS (*FGT_SEM_TAKE)(
+                        GT_SEM semId, GT_U32 timOut);
+typedef GT_STATUS (*FGT_SEM_GIVE)(
+                        GT_SEM semId);
+
+typedef struct
+{
+    FGT_SEM_CREATE    semCreate;     /* create semapore */
+    FGT_SEM_DELETE    semDelete;     /* delete the semapore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semapore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
+}GT_SEM_ROUTINES;
+
+/*
+ * definitions for registering Hardware access function.
+ *
+*/
+/*#ifdef GT_RMGMT_ACCESS */
+#if 1
+/*
+ *  * Definition for the direction in HW_DEV_RW_REG structure.
+ *  */
+#define HW_REG_READ                     0
+#define HW_REG_WRITE            1
+#define HW_REG_WAIT_TILL_0      2
+#define HW_REG_WAIT_TILL_1      3
+
+/* HW_ACCESS_READ_REG and HW_ACCESS_WRITE_REG */
+typedef struct _HW_DEV_RW_REG
+{
+  unsigned long cmd;  /*INPUT:HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 */
+  unsigned long addr; /*INPUT:SMI Address */
+  unsigned long reg;  /*INPUT:Register offset */
+  unsigned long data; /*INPUT,OUTPUT:Value in the Register or Bit number */
+} HW_DEV_RW_REG;
+
+#define  MAX_ACCESS_REG_NUM  12
+
+typedef struct _HW_DEV_REG_ACCESS
+{
+        unsigned long   entries;
+        HW_DEV_RW_REG   rw_reg_list[MAX_ACCESS_REG_NUM]; /* INPUT,OUTPUT: Reg Access information */
+} HW_DEV_REG_ACCESS;
+
+
+typedef GT_BOOL (*FGT_HW_ACCESS)(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList);
+#endif
+
+/*
+ * definitions for registering MII access functions.
+ *
+*/
+typedef GT_BOOL (*FGT_READ_MII)(
+                        GT_QD_DEV*   dev,
+                        unsigned int phyAddr,
+                        unsigned int miiReg,
+                        unsigned int* value);
+typedef GT_BOOL (*FGT_WRITE_MII)(
+                        GT_QD_DEV*   dev,
+                        unsigned int phyAddr,
+                        unsigned int miiReg,
+                        unsigned int value);
+typedef GT_BOOL (*FGT_INT_HANDLER)(
+                        GT_QD_DEV*   dev,
+                        GT_U16*);
+
+typedef struct _BSP_FUNCTIONS
+{
+    GT_U32        hwAccessMod;    /* Hardware access mode */
+    FGT_READ_MII     readMii;    /* read MII Registers */
+    FGT_WRITE_MII     writeMii;    /* write MII Registers */
+#ifdef GT_RMGMT_ACCESS
+    FGT_HW_ACCESS   hwAccess;    /* Hardware access function */
+#endif
+    FGT_SEM_CREATE    semCreate;     /* create semapore */
+    FGT_SEM_DELETE    semDelete;     /* delete the semapore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semapore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
+}BSP_FUNCTIONS;
+
+
+/*
+ *    Type definition for MIB counter operation
+*/
+typedef enum
+{
+    STATS_FLUSH_ALL,            /* Flush all counters for all ports */
+    STATS_FLUSH_PORT,           /* Flush all counters for a port */
+    STATS_READ_COUNTER,         /* Read a specific counter from a port */
+    STATS_READ_REALTIME_COUNTER,    /* Read a realtime counter from a port */
+    STATS_READ_ALL,              /* Read all counters from a port */
+    STATS_READ_COUNTER_CLEAR,   /* For RMU page2,Read a specific counter from a port and clear*/
+    STATS_READ_ALL_CLEAR        /* For RMU page2,Read all counters from a port and clear*/
+
+} GT_STATS_OPERATION;
+
+typedef struct _GT_STATS_COUNTER_SET
+{
+    GT_U32    InUnicasts;
+    GT_U32    InBroadcasts;
+    GT_U32    InPause;
+    GT_U32    InMulticasts;
+    GT_U32    InFCSErr;
+    GT_U32    AlignErr;
+    GT_U32    InGoodOctets;
+    GT_U32    InBadOctets;
+    GT_U32    Undersize;
+    GT_U32    Fragments;
+    GT_U32    In64Octets;        /* 64 Octets */
+    GT_U32    In127Octets;    /* 65 to 127 Octets */
+    GT_U32    In255Octets;    /* 128 to 255 Octets */
+    GT_U32    In511Octets;    /* 256 to 511 Octets */
+    GT_U32    In1023Octets;    /* 512 to 1023 Octets */
+    GT_U32    InMaxOctets;    /* 1024 to Max Octets */
+    GT_U32    Jabber;
+    GT_U32    Oversize;
+    GT_U32    InDiscards;
+    GT_U32    Filtered;
+    GT_U32    OutUnicasts;
+    GT_U32    OutBroadcasts;
+    GT_U32    OutPause;
+    GT_U32    OutMulticasts;
+    GT_U32    OutFCSErr;
+    GT_U32    OutGoodOctets;
+    GT_U32    Out64Octets;    /* 64 Octets */
+    GT_U32    Out127Octets;    /* 65 to 127 Octets */
+    GT_U32    Out255Octets;    /* 128 to 255 Octets */
+    GT_U32    Out511Octets;    /* 256 to 511 Octets */
+    GT_U32    Out1023Octets;    /* 512 to 1023 Octets */
+    GT_U32    OutMaxOctets;    /* 1024 to Max Octets */
+    GT_U32    Collisions;
+    GT_U32    Late;
+    GT_U32    Excessive;
+    GT_U32    Multiple;
+    GT_U32    Single;
+    GT_U32    Deferred;
+    GT_U32    OutDiscards;
+
+} GT_STATS_COUNTER_SET;
+
+
+typedef enum
+{
+    STATS_InUnicasts = 0,
+    STATS_InBroadcasts,
+    STATS_InPause,
+    STATS_InMulticasts,
+    STATS_InFCSErr,
+    STATS_AlignErr,
+    STATS_InGoodOctets,
+    STATS_InBadOctets,
+    STATS_Undersize,
+    STATS_Fragments,
+    STATS_In64Octets,
+    STATS_In127Octets,
+    STATS_In255Octets,
+    STATS_In511Octets,
+    STATS_In1023Octets,
+    STATS_InMaxOctets,
+    STATS_Jabber,
+    STATS_Oversize,
+    STATS_InDiscards,
+    STATS_Filtered,
+    STATS_OutUnicasts,
+    STATS_OutBroadcasts,
+    STATS_OutPause,
+    STATS_OutMulticasts,
+    STATS_OutFCSErr,
+    STATS_OutGoodOctets,
+    STATS_Out64Octets,
+    STATS_Out127Octets,
+    STATS_Out255Octets,
+    STATS_Out511Octets,
+    STATS_Out1023Octets,
+    STATS_OutMaxOctets,
+    STATS_Collisions,
+    STATS_Late,
+    STATS_Excessive,
+    STATS_Multiple,
+    STATS_Single,
+    STATS_Deferred,
+    STATS_OutDiscards
+
+} GT_STATS_COUNTERS;
+/*
+ * typedef: enum GT_HISTOGRAM_MODE
+ *
+ * Description: Enumeration of the histogram counters mode.
+ *
+ * Enumerations:
+ *   GT_COUNT_RX_ONLY - In this mode, Rx Histogram Counters are counted.
+ *   GT_COUNT_TX_ONLY - In this mode, Tx Histogram Counters are counted.
+ *   GT_COUNT_RX_TX   - In this mode, Rx and Tx Histogram Counters are counted.
+ */
+typedef enum
+{
+    GT_COUNT_RX_ONLY = 0,
+    GT_COUNT_TX_ONLY,
+    GT_COUNT_RX_TX
+} GT_HISTOGRAM_MODE;
+
+/*
+    Counter set 2 is used by 88E6183
+*/
+typedef struct _GT_STATS_COUNTER_SET2
+{
+    GT_U32    InGoodOctetsHi;
+    GT_U32    InGoodOctetsLo;
+    GT_U32    InBadOctets;
+    GT_U32    OutDiscards;
+    GT_U32    InGoodFrames;
+    GT_U32    InBadFrames;
+    GT_U32    InBroadcasts;
+    GT_U32    InMulticasts;
+    /*
+        Histogram Counters : Rx Only, Tx Only, or both Rx and Tx
+        (refer to Histogram Mode)
+    */
+    GT_U32    Octets64;        /* 64 Octets */
+    GT_U32    Octets127;        /* 65 to 127 Octets */
+    GT_U32    Octets255;        /* 128 to 255 Octets */
+    GT_U32    Octets511;        /* 256 to 511 Octets */
+    GT_U32    Octets1023;        /* 512 to 1023 Octets */
+    GT_U32    OctetsMax;        /* 1024 to Max Octets */
+    GT_U32    OutOctetsHi;
+    GT_U32    OutOctetsLo;
+    GT_U32    OutFrames;
+    GT_U32    Excessive;
+    GT_U32    OutMulticasts;
+    GT_U32    OutBroadcasts;
+    GT_U32    InBadMACCtrl;
+
+    GT_U32    OutPause;
+    GT_U32    InPause;
+    GT_U32    InDiscards;
+    GT_U32    Undersize;
+    GT_U32    Fragments;
+    GT_U32    Oversize;
+    GT_U32    Jabber;
+    GT_U32    MACRcvErr;
+    GT_U32    InFCSErr;
+    GT_U32    Collisions;
+    GT_U32    Late;
+
+} GT_STATS_COUNTER_SET2;
+
+
+typedef enum
+{
+    STATS2_InGoodOctetsHi = 0,
+    STATS2_InGoodOctetsLo,
+    STATS2_InBadOctets,
+
+    STATS2_OutDiscards,
+    STATS2_InGoodFrames,
+    STATS2_InBadFrames,
+    STATS2_InBroadcasts,
+    STATS2_InMulticasts,
+    STATS2_64Octets,
+    STATS2_127Octets,
+    STATS2_255Octets,
+    STATS2_511Octets,
+    STATS2_1023Octets,
+    STATS2_MaxOctets,
+    STATS2_OutOctetsHi,
+    STATS2_OutOctetsLo,
+    STATS2_OutFrames,
+    STATS2_Excessive,
+    STATS2_OutMulticasts,
+    STATS2_OutBroadcasts,
+    STATS2_InBadMACCtrl,
+    STATS2_OutPause,
+    STATS2_InPause,
+    STATS2_InDiscards,
+    STATS2_Undersize,
+    STATS2_Fragments,
+    STATS2_Oversize,
+    STATS2_Jabber,
+    STATS2_MACRcvErr,
+    STATS2_InFCSErr,
+    STATS2_Collisions,
+    STATS2_Late
+
+} GT_STATS_COUNTERS2;
+
+/*
+    Counter set 3 is used by 88E6093 and 88E6065 and later
+*/
+typedef struct _GT_STATS_COUNTER_SET3
+{
+    GT_U32    InGoodOctetsLo;    /* offset 0 */
+    GT_U32    InGoodOctetsHi;    /* offset 1, not supported by 88E6065 */
+    GT_U32    InBadOctets;        /* offset 2 */
+    GT_U32    OutFCSErr;            /* offset 3 */
+    GT_U32    InUnicasts;            /* offset 4 */
+    GT_U32    Deferred;            /* offset 5 */
+    GT_U32    InBroadcasts;        /* offset 6 */
+    GT_U32    InMulticasts;        /* offset 7 */
+    /*
+        Histogram Counters : Rx Only, Tx Only, or both Rx and Tx
+        (refer to Histogram Mode)
+    */
+    GT_U32    Octets64;        /* 64 Octets, offset 8 */
+    GT_U32    Octets127;        /* 65 to 127 Octets, offset 9 */
+    GT_U32    Octets255;        /* 128 to 255 Octets, offset 10 */
+    GT_U32    Octets511;        /* 256 to 511 Octets, offset 11 */
+    GT_U32    Octets1023;        /* 512 to 1023 Octets, offset 12 */
+    GT_U32    OctetsMax;        /* 1024 to Max Octets, offset 13 */
+    GT_U32    OutOctetsLo;    /* offset 14 */
+    GT_U32    OutOctetsHi;    /* offset 15, not supported by 88E6065 */
+    GT_U32    OutUnicasts;    /* offset 16 */
+    GT_U32    Excessive;        /* offset 17 */
+    GT_U32    OutMulticasts;    /* offset 18 */
+    GT_U32    OutBroadcasts;    /* offset 19 */
+    GT_U32    Single;            /* offset 20 */
+
+    GT_U32    OutPause;        /* offset 21 */
+    GT_U32    InPause;            /* offset 22 */
+    GT_U32    Multiple;        /* offset 23 */
+    GT_U32    Undersize;        /* offset 24 */
+    GT_U32    Fragments;        /* offset 25 */
+    GT_U32    Oversize;        /* offset 26 */
+    GT_U32    Jabber;            /* offset 27 */
+    GT_U32    InMACRcvErr;    /* offset 28 */
+    GT_U32    InFCSErr;        /* offset 29 */
+    GT_U32    Collisions;        /* offset 30 */
+    GT_U32    Late;                /* offset 31 */
+
+} GT_STATS_COUNTER_SET3;
+
+
+typedef enum
+{
+    STATS3_InGoodOctetsLo = 0,
+    STATS3_InGoodOctetsHi,
+    STATS3_InBadOctets,
+
+    STATS3_OutFCSErr,
+    STATS3_InUnicasts,
+    STATS3_Deferred,            /* offset 5 */
+    STATS3_InBroadcasts,
+    STATS3_InMulticasts,
+    STATS3_64Octets,
+    STATS3_127Octets,
+    STATS3_255Octets,            /* offset 10 */
+    STATS3_511Octets,
+    STATS3_1023Octets,
+    STATS3_MaxOctets,
+    STATS3_OutOctetsLo,
+    STATS3_OutOctetsHi,
+    STATS3_OutUnicasts,        /* offset 16 */
+    STATS3_Excessive,
+    STATS3_OutMulticasts,
+    STATS3_OutBroadcasts,
+    STATS3_Single,
+    STATS3_OutPause,
+    STATS3_InPause,
+    STATS3_Multiple,
+    STATS3_Undersize,            /* offset 24 */
+    STATS3_Fragments,
+    STATS3_Oversize,
+    STATS3_Jabber,
+    STATS3_InMACRcvErr,
+    STATS3_InFCSErr,
+    STATS3_Collisions,
+    STATS3_Late                    /* offset 31 */
+
+} GT_STATS_COUNTERS3;
+
+/*
+    Counter set RMU page2 is used by 88E6320 and later
+*/
+typedef struct _GT_STATS_COUNTER_SET_PAGE2
+{
+	/* Bank 0 */
+    GT_U32    InGoodOctetsLo;     /* offset 0 */
+    GT_U32    InGoodOctetsHi;     /* offset 1 */
+    GT_U32    InBadOctets;        /* offset 2 */
+    GT_U32    OutFCSErr;          /* offset 3 */
+    GT_U32    InUnicasts;         /* offset 4 */
+    GT_U32    Deferred;           /* offset 5 */
+    GT_U32    InBroadcasts;       /* offset 6 */
+    GT_U32    InMulticasts;       /* offset 7 */
+    /*
+        Histogram Counters : Rx Only, Tx Only, or both Rx and Tx
+        (refer to Histogram Mode)
+    */
+    GT_U32    Octets64;         /* 64 Octets, offset 8 */
+    GT_U32    Octets127;        /* 65 to 127 Octets, offset 9 */
+    GT_U32    Octets255;        /* 128 to 255 Octets, offset 10 */
+    GT_U32    Octets511;        /* 256 to 511 Octets, offset 11 */
+    GT_U32    Octets1023;       /* 512 to 1023 Octets, offset 12 */
+    GT_U32    OctetsMax;        /* 1024 to Max Octets, offset 13 */
+    GT_U32    OutOctetsLo;      /* offset 14 */
+    GT_U32    OutOctetsHi;      /* offset 15 */
+    GT_U32    OutUnicasts;      /* offset 16 */
+    GT_U32    Excessive;        /* offset 17 */
+    GT_U32    OutMulticasts;    /* offset 18 */
+    GT_U32    OutBroadcasts;    /* offset 19 */
+    GT_U32    Single;           /* offset 20 */
+
+    GT_U32    OutPause;         /* offset 21 */
+    GT_U32    InPause;          /* offset 22 */
+    GT_U32    Multiple;         /* offset 23 */
+    GT_U32    Undersize;        /* offset 24 */
+    GT_U32    Fragments;        /* offset 25 */
+    GT_U32    Oversize;         /* offset 26 */
+    GT_U32    Jabber;           /* offset 27 */
+    GT_U32    InMACRcvErr;      /* offset 28 */
+    GT_U32    InFCSErr;         /* offset 29 */
+    GT_U32    Collisions;       /* offset 30 */
+    GT_U32    Late;             /* offset 31 */
+	/* Bank 1 */
+    GT_U32    InDiscards;       /* offset 0x00 */
+    GT_U32    InFiltered;       /* offset 0x01 */
+    GT_U32    InAccepted;       /* offset 0x02 */
+    GT_U32    InBadAccepted;    /* offset 0x03 */
+    GT_U32    InGoodAvbClassA;  /* offset 0x04 */
+    GT_U32    InGoodAvbClassB;  /* offset 0x05 */
+    GT_U32    InBadAvbClassA ;  /* offset 0x06 */
+    GT_U32    InBadAvbClassB ;  /* offset 0x07 */
+    GT_U32    TCAMCounter0;     /* offset 0x08 */
+    GT_U32    TCAMCounter1;     /* offset 0x09 */
+    GT_U32    TCAMCounter2;     /* offset 0x0a */
+    GT_U32    TCAMCounter3;     /* offset 0x0b */
+    GT_U32    reserved_c;     /* offset 0x0c */
+    GT_U32    reserved_d;     /* offset 0x0d */
+    GT_U32    InDaUnknown ;     /* offset 0x0e */
+    GT_U32    InMGMT;           /* offset 0x0f */
+    GT_U32    OutQueue0;        /* offset 0x10 */
+    GT_U32    OutQueue1;        /* offset 0x11 */
+    GT_U32    OutQueue2;        /* offset 0x12 */
+    GT_U32    OutQueue3;        /* offset 0x13 */
+    GT_U32    OutQueue4;        /* offset 0x14 */
+    GT_U32    OutQueue5;        /* offset 0x15 */
+    GT_U32    OutQueue6;        /* offset 0x16 */
+    GT_U32    OutQueue7;        /* offset 0x17 */
+    GT_U32    OutCutThrough;    /* offset 0x18 */
+    GT_U32    reserved_19 ;     /* offset 0x19 */
+    GT_U32    OutOctetsA;       /* offset 0x1a */
+    GT_U32    OutOctetsB;       /* offset 0x1b */
+    GT_U32    reserved_1c;      /* offset 0x1c */
+    GT_U32    reserved_1d;      /* offset 0x1d */
+    GT_U32    reserved_1e;      /* offset 0x1e */
+    GT_U32    OutMGMT;          /* offset 0x1f */
+
+} GT_STATS_COUNTER_SET_PAGE2;
+
+#define GT_PAGE2_BANK1 0x80
+typedef enum
+{
+	/* Bank 0 */
+    STATS_PG2_InGoodOctetsLo = 0,
+    STATS_PG2_InGoodOctetsHi,
+    STATS_PG2_InBadOctets,
+
+    STATS_PG2_OutFCSErr,
+    STATS_PG2_InUnicasts,
+    STATS_PG2_Deferred,            /* offset 5 */
+    STATS_PG2_InBroadcasts,
+    STATS_PG2_InMulticasts,
+    STATS_PG2_64Octets,
+    STATS_PG2_127Octets,
+    STATS_PG2_255Octets,            /* offset 10 */
+    STATS_PG2_511Octets,
+    STATS_PG2_1023Octets,
+    STATS_PG2_MaxOctets,
+    STATS_PG2_OutOctetsLo,
+    STATS_PG2_OutOctetsHi,
+    STATS_PG2_OutUnicasts,        /* offset 16 */
+    STATS_PG2_Excessive,
+    STATS_PG2_OutMulticasts,
+    STATS_PG2_OutBroadcasts,
+    STATS_PG2_Single,
+    STATS_PG2_OutPause,
+    STATS_PG2_InPause,
+    STATS_PG2_Multiple,
+    STATS_PG2_Undersize,            /* offset 24 */
+    STATS_PG2_Fragments,
+    STATS_PG2_Oversize,
+    STATS_PG2_Jabber,
+    STATS_PG2_InMACRcvErr,
+    STATS_PG2_InFCSErr,
+    STATS_PG2_Collisions,
+    STATS_PG2_Late,                    /* offset 31 */
+	/* Bank 1 */
+    STATS_PG2_InDiscards      = GT_PAGE2_BANK1+0x00,
+    STATS_PG2_InFiltered      = GT_PAGE2_BANK1+0x01,
+    STATS_PG2_InAccepted      = GT_PAGE2_BANK1+0x02,
+    STATS_PG2_InBadAccepted   = GT_PAGE2_BANK1+0x03,
+    STATS_PG2_InGoodAvbClassA = GT_PAGE2_BANK1+0x04,
+    STATS_PG2_InGoodAvbClassB = GT_PAGE2_BANK1+0x05,
+    STATS_PG2_InBadAvbClassA  = GT_PAGE2_BANK1+0x06,
+    STATS_PG2_InBadAvbClassB  = GT_PAGE2_BANK1+0x07,
+    STATS_PG2_TCAMCounter0    = GT_PAGE2_BANK1+0x08,
+    STATS_PG2_TCAMCounter1    = GT_PAGE2_BANK1+0x09,
+    STATS_PG2_TCAMCounter2    = GT_PAGE2_BANK1+0x0a,
+    STATS_PG2_TCAMCounter3    = GT_PAGE2_BANK1+0x0b,
+    STATS_PG2_InDaUnknown     = GT_PAGE2_BANK1+0x0e,
+    STATS_PG2_InMGMT          = GT_PAGE2_BANK1+0x0f,
+    STATS_PG2_OutQueue0       = GT_PAGE2_BANK1+0x10,
+    STATS_PG2_OutQueue1       = GT_PAGE2_BANK1+0x11,
+    STATS_PG2_OutQueue2       = GT_PAGE2_BANK1+0x12,
+    STATS_PG2_OutQueue3       = GT_PAGE2_BANK1+0x13,
+    STATS_PG2_OutQueue4       = GT_PAGE2_BANK1+0x14,
+    STATS_PG2_OutQueue5       = GT_PAGE2_BANK1+0x15,
+    STATS_PG2_OutQueue6       = GT_PAGE2_BANK1+0x16,
+    STATS_PG2_OutQueue7       = GT_PAGE2_BANK1+0x17,
+    STATS_PG2_OutCutThrough   = GT_PAGE2_BANK1+0x18,
+    STATS_PG2_OutOctetsA      = GT_PAGE2_BANK1+0x1a,
+    STATS_PG2_OutOctetsB      = GT_PAGE2_BANK1+0x1b,
+    STATS_PG2_OutMGMT         = GT_PAGE2_BANK1+0x1f
+
+} GT_STATS_COUNTERS_PAGE2;
+
+/* Switch Mac/Wol/Wof definitions */
+
+/*
+ * typedef: struct GT_1000T_MASTER_SLAVE
+ *
+ * Description: 1000Base-T Master/Slave Configuration
+ *
+ * Fields:
+ *      autoConfig   - GT_TRUE for auto-config, GT_FALSE for manual setup.
+ *      masterPrefer - GT_TRUE if Master configuration is preferred.
+ *
+ */
+typedef struct _GT_1000T_MASTER_SLAVE
+{
+    GT_BOOL    autoConfig;
+    GT_BOOL masterPrefer;
+} GT_1000T_MASTER_SLAVE;
+
+
+#define GT_MDI_PAIR_NUM         4    /* (1,2),(3,6),(4,5),(7,8) */
+#define GT_CHANNEL_PAIR_NUM     2    /* (channel A,B),(channel C,D) */
+
+
+/*
+ * typedef: enum GT_PHY_LINK_STATUS
+ *
+ * Description: Enumeration of Link Status
+ *
+ * Enumerations:
+ *        GT_PHY_LINK_OFF        - No Link
+ *        GT_PHY_LINK_COPPER    - Link on Copper
+ *        GT_PHY_LINK_FIBER    - Link on Fiber
+ */
+typedef enum
+{
+    GT_PHY_LINK_OFF = 0,
+    GT_PHY_LINK_COPPER = 1,
+    GT_PHY_LINK_FIBER = 2
+} GT_PHY_LINK_STATUS;
+
+
+/* Definition for packet generator */
+
+/* Payload */
+typedef enum
+{
+    GT_PG_PAYLOAD_RANDOM = 0,    /* Pseudo-random */
+    GT_PG_PAYLOAD_5AA5        /* 5A,A5,5A,A5,... */
+} GT_PG_PAYLOAD;
+
+/* Length */
+typedef enum
+{
+    GT_PG_LENGTH_64 = 0,        /* 64 bytes */
+    GT_PG_LENGTH_1514
+} GT_PG_LENGTH;
+
+/* Error */
+typedef enum
+{
+    GT_PG_TX_NORMAL = 0,        /* No Error */
+    GT_PG_TX_ERROR            /* Tx packets with CRC error and Symbol error */
+} GT_PG_TX;
+
+/* Structure for packet generator */
+typedef struct
+{
+    GT_PG_PAYLOAD  payload;
+    GT_PG_LENGTH   length;
+    GT_PG_TX       tx;
+} GT_PG;
+
+
+/*
+ * typedef: enum GT_TEST_STATUS
+ *
+ * Description: Enumeration of VCT test status
+ *
+ * Enumerations:
+ *      GT_TEST_FAIL    - virtual cable test failed.
+ *      GT_NORMAL_CABLE - normal cable.
+ *      GT_IMPEDANCE_MISMATCH - impedance mismatch.
+ *      GT_OPEN_CABLE   - open in cable.
+ *      GT_SHORT_CABLE  - short in cable.
+ *
+ */
+typedef enum
+{
+    GT_TEST_FAIL,
+    GT_NORMAL_CABLE,
+    GT_IMPEDANCE_MISMATCH,
+    GT_OPEN_CABLE,
+    GT_SHORT_CABLE,
+} GT_TEST_STATUS;
+
+
+/*
+ * typedef: enum GT_NORMAL_CABLE_LEN
+ *
+ * Description: Enumeration for normal cable length
+ *
+ * Enumerations:
+ *      GT_LESS_THAN_50M - cable length less than 50 meter.
+ *      GT_50M_80M       - cable length between 50 - 80 meter.
+ *      GT_80M_110M      - cable length between 80 - 110 meter.
+ *      GT_110M_140M     - cable length between 110 - 140 meter.
+ *      GT_MORE_THAN_140 - cable length more than 140 meter.
+ *      GT_UNKNOWN_LEN   - unknown length.
+ *
+ */
+typedef enum
+{
+    GT_LESS_THAN_50M,
+    GT_50M_80M,
+    GT_80M_110M,
+    GT_110M_140M,
+    GT_MORE_THAN_140,
+    GT_UNKNOWN_LEN,
+
+} GT_NORMAL_CABLE_LEN;
+
+
+/*
+ * typedef: enum GT_CABLE_LEN
+ *
+ * Description: Enumeration cable length
+ *
+ * Enumerations:
+ *      normCableLen - cable lenght for normal cable.
+ *      errCableLen  - for cable failure the estimate fault distance in meters.
+ *
+ */
+typedef union
+{
+    GT_NORMAL_CABLE_LEN normCableLen;
+    GT_U8               errCableLen;
+
+} GT_CABLE_LEN;
+
+/*
+ * typedef: struct GT_CABLE_STATUS
+ *
+ * Description: virtual cable diagnostic status per MDI pair.
+ *
+ * Fields:
+ *      cableStatus - VCT cable status.
+ *      cableLen    - VCT cable length.
+ *    phyType        - type of phy (100M phy or Gigabit phy)
+ */
+typedef struct
+{
+    GT_TEST_STATUS  cableStatus[GT_MDI_PAIR_NUM];
+    GT_CABLE_LEN    cableLen[GT_MDI_PAIR_NUM];
+    GT_U16        phyType;
+
+} GT_CABLE_STATUS;
+
+
+/*
+ * typedef: enum GT_CABLE_TYPE
+ *
+ * Description: Enumeration of Cable Type
+ *
+ * Enumerations:
+ *        GT_STRAIGHT_CABLE    _ straight cable
+ *      GT_CROSSOVER_CABLE     - crossover cable
+ */
+typedef enum
+{
+    GT_STRAIGHT_CABLE,
+    GT_CROSSOVER_CABLE
+
+} GT_CABLE_TYPE;
+
+
+/*
+ * typedef: enum GT_RX_CHANNEL
+ *
+ * Description: Enumeration of Receiver Channel Assignment
+ *
+ * Enumerations:
+ *        GT_CHANNEL_A   - Channel A
+ *        GT_CHANNEL_B   - Channel B
+ *        GT_CHANNEL_C   - Channel C
+ *        GT_CHANNEL_D   - Channel D
+ */
+typedef enum
+{
+    GT_CHANNEL_A,
+    GT_CHANNEL_B,
+    GT_CHANNEL_C,
+    GT_CHANNEL_D
+} GT_RX_CHANNEL;
+
+/*
+ * typedef: enum GT_POLARITY_STATUS
+ *
+ * Description: Enumeration of polarity status
+ *
+ * Enumerations:
+ *        GT_POSITIVE    - positive polarity
+ *      GT_NEGATIVE    - negative polarity
+ */
+typedef enum
+{
+    GT_POSITIVE,
+    GT_NEGATIVE
+
+} GT_POLARITY_STATUS;
+
+
+/*
+ * typedef: struct GT_1000BT_EXTENDED_STATUS
+ *
+ * Description: Currently the 1000Base-T PCS can determine the cable polarity
+ *         on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among
+ *        the pares. These status enhance the capability of the virtual cable tester
+ *
+ * Fields:
+ *      isValid        - GT_TRUE if this structure have valid information,
+ *                       GT_FALSE otherwise.
+ *                      It is valid only if 1000BASE-T Link is up.
+ *      pairSwap    - GT_CROSSOVER_CABLE, if the cable is crossover,
+ *                      GT_STRAIGHT_CABLE, otherwise
+ *        pairPolarity- GT_POSITIVE, if polarity is positive,
+ *                      GT_NEGATIVE, otherwise
+ *        pairSkew    - pair skew in units of ns
+ */
+typedef struct
+{
+    GT_BOOL                isValid;
+    GT_CABLE_TYPE        pairSwap[GT_CHANNEL_PAIR_NUM];
+    GT_POLARITY_STATUS    pairPolarity[GT_MDI_PAIR_NUM];
+    GT_U32                pairSkew[GT_MDI_PAIR_NUM];
+
+} GT_1000BT_EXTENDED_STATUS;
+
+/*
+ * typedef: struct GT_ADV_EXTENDED_STATUS
+ *
+ * Description: Currently the 1000Base-T PCS can determine the cable polarity
+ *         on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among
+ *        the pares. These status enhance the capability of the virtual cable tester
+ *
+ * Fields:
+ *      isValid        - GT_TRUE if this structure have valid information,
+ *                       GT_FALSE otherwise.
+ *                      It is valid only if 1000BASE-T Link is up.
+ *      pairSwap    - Receive channel assignement
+ *        pairPolarity- GT_POSITIVE, if polarity is positive,
+ *                      GT_NEGATIVE, otherwise
+ *        pairSkew    - pair skew in units of ns
+ *        cableLen    - cable length based on DSP
+ */
+typedef struct
+{
+    GT_BOOL            isValid;
+    GT_RX_CHANNEL      pairSwap[GT_MDI_PAIR_NUM];
+    GT_POLARITY_STATUS pairPolarity[GT_MDI_PAIR_NUM];
+    GT_U32             pairSkew[GT_MDI_PAIR_NUM];
+    GT_U32                cableLen[GT_MDI_PAIR_NUM];
+} GT_ADV_EXTENDED_STATUS;
+
+
+/*
+ * if isGigPhy in GT_CABLE_STATUS is not GT_TRUE, cableStatus and cableLen
+ * will have only 2 pairs available.
+ * One is RX Pair and the other is TX Pair.
+ */
+#define MDI_RX_PAIR        0    /* cableStatus[0] or cableLen[0] */
+#define MDI_TX_PAIR        1    /* cableStatus[1] or cableLen[1] */
+
+/* definition for Phy Type */
+#define PHY_100M        0 /* 10/100M phy, E3082 or E3083 */
+#define PHY_1000M        1 /* Gigabit phy, the rest phys */
+#define PHY_10000M        2 /* 10 Gigabit phy, unused */
+#define PHY_1000M_B        3 /* Gigabit phy which needs work-around */
+#define PHY_1000M_MP    4 /* Gigabit phy with multiple page mode */
+
+
+/* Definition for Advance Virtual Cable Test */
+
+/*
+ * typedef: enum GT_ADV_VCT_TRANS_CHAN_SEL
+ *
+ * Description: Enumeration of Advanced VCT Transmitter channel select
+ *
+ * Enumerations:
+ *        GT_ADV_VCT_NO_CROSSPAIR - Transmitter channel select is 000
+ *        GT_ADV_VCT_CROSSPAIR    - Transmitter channelselect is 100/101/110/111
+ */
+typedef enum
+{
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_TCS_NO_CROSSPAIR        = 0,
+    GT_ADV_VCT_TCS_CROSSPAIR_0            = 0x4,
+    GT_ADV_VCT_TCS_CROSSPAIR_1            = 0x5,
+    GT_ADV_VCT_TCS_CROSSPAIR_2            = 0x6,
+    GT_ADV_VCT_TCS_CROSSPAIR_3            = 0x7
+} GT_ADV_VCT_TRANS_CHAN_SEL;
+
+
+typedef enum
+{
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_SAVG_2        = 0,
+    GT_ADV_VCT_SAVG_4        = 1,
+    GT_ADV_VCT_SAVG_8        = 2,
+    GT_ADV_VCT_SAVG_16        = 3,
+    GT_ADV_VCT_SAVG_32        = 4,
+    GT_ADV_VCT_SAVG_64        = 5,
+    GT_ADV_VCT_SAVG_128    = 6,
+    GT_ADV_VCT_SAVG_256    = 7
+} GT_ADV_VCT_SAMPLE_AVG;
+
+typedef enum
+{
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_MAX_PEAK        =0x00,
+    GT_ADV_VCT_FIRST_PEAK        =0x01,
+} GT_ADV_VCT_MOD;
+
+
+typedef unsigned int GT_ADV_VCT_PEAKDET_HYST;
+
+/*
+ * typedef: enum GT_ADV_VCT_MODE
+ *
+ * Description: Enumeration of Advanced VCT Mode and Transmitter channel select
+ *
+ * Enumerations:
+ *      GT_ADV_VCT_FIRST_PEAK   - first peak above a certain threshold is reported.
+ *      GT_ADV_VCT_MAX_PEAK     - maximum peak above a certain threshold is reported.
+ *        GT_ADV_VCT_OFFSE         - offset
+ *        GT_ADV_VCT_SAMPLE_POINT - sample point
+ *
+ *        GT_ADV_VCT_NO_CROSSPAIR - Transmitter channel select is 000
+ *        GT_ADV_VCT_CROSSPAIR    - Transmitter channelselect is 100/101/110/111
+ *   Example: mode = GT_ADV_VCT_FIRST_PEAK | GT_ADV_VCT_CROSSPAIR.
+ */
+typedef struct
+{
+    GT_ADV_VCT_MOD                    mode;
+    GT_ADV_VCT_TRANS_CHAN_SEL      transChanSel;
+    GT_ADV_VCT_SAMPLE_AVG            sampleAvg;
+    GT_ADV_VCT_PEAKDET_HYST        peakDetHyst;
+} GT_ADV_VCT_MODE;
+
+
+/*
+ * typedef: enum GT_ADV_VCT_STATUS
+ *
+ * Description: Enumeration of Advanced VCT status
+ *
+ * Enumerations:
+ *      GT_ADV_VCT_FAIL     - advanced virtual cable test failed.
+ *                             cable lengh cannot be determined.
+ *      GT_ADV_VCT_NORMAL   - normal cable.
+ *                             cable lengh may not be determined.
+ *      GT_ADV_VCT_IMP_GREATER_THAN_115 - impedance mismatch > 115 ohms
+ *                             cable lengh is valid.
+ *      GT_ADV_VCT_IMP_LESS_THAN_85 - impedance mismatch < 85 ohms
+ *                             cable lengh is valid.
+ *      GT_ADV_VCT_OPEN      - cable open
+ *                             cable lengh is valid.
+ *      GT_ADV_VCT_SHORT      - cable shorted
+ *                             cable lengh is valid.
+ *      GT_ADV_VCT_CROSS_PAIR_SHORT - cross pair short.
+ *                             cable lengh for each channel is valid.
+ */
+typedef enum
+{
+    GT_ADV_VCT_FAIL,
+    GT_ADV_VCT_NORMAL,
+    GT_ADV_VCT_IMP_GREATER_THAN_115,
+    GT_ADV_VCT_IMP_LESS_THAN_85,
+    GT_ADV_VCT_OPEN,
+    GT_ADV_VCT_SHORT,
+    GT_ADV_VCT_CROSS_PAIR_SHORT
+} GT_ADV_VCT_STATUS;
+
+
+/*
+ * typedef: struct GT_CROSS_PAIR_LIST
+ *
+ * Description: strucuture for cross pair short channels.
+ *
+ * Fields:
+ *      channel - cross pair short channel list
+ *                channel[i] is GT_TRUE if the channel[i] is cross pair short
+ *                with the current channel under test.
+ *      dist2fault - estimated distance to the shorted location.
+ *                   valid only if related channel (above) is GT_TRUE.
+ */
+typedef struct _GT_CROSS_SHORT_LIST
+{
+    GT_BOOL    channel[GT_MDI_PAIR_NUM];
+    GT_16     dist2fault[GT_MDI_PAIR_NUM];
+} GT_CROSS_SHORT_LIST;
+
+
+/*
+ * typedef: struct GT_ADV_CABLE_STATUS
+ *
+ * Description: strucuture for advanced cable status.
+ *
+ * Fields:
+ *      cableStatus - VCT cable status for each channel.
+ *      crossShort  - cross pair short list for each channel.
+ *                    Valid only if relative cableStatus is GT_ADV_VCT_CROSS_PAIR_SHORT.
+ *      dist2fault  - estimated distance to fault for each channel.
+ *                    Valid if relative cableStatus is one of the followings:
+ *                      GT_ADV_VCT_NORMAL
+ *                      GT_ADV_VCT_IMP_GREATER_THAN_115
+ *                      GT_ADV_VCT_IMP_LESS_THAN_85,
+ *                      GT_ADV_VCT_OPEN, or
+ *                        GT_ADV_VCT_SHORT
+  */
+typedef struct
+{
+    GT_ADV_VCT_STATUS   cableStatus[GT_MDI_PAIR_NUM];
+    union {
+        GT_CROSS_SHORT_LIST crossShort;
+        GT_16     dist2fault;
+    }u[GT_MDI_PAIR_NUM];
+} GT_ADV_CABLE_STATUS;
+
+
+/*
+ * Definition:
+ *        GT_LED_LINK_ACT_SPEED     - off = no link, on = link, blink = activity, blink speed = link speed
+ *        GT_LED_LINK_ACT             - off = no link, on = link, blink = activity
+ *        GT_LED_LINK                 - off = no link, on = link
+ *        GT_LED_10_LINK_ACT        - off = no link, on = 10, blink = activity
+ *        GT_LED_10_LINK            - off = no link, on = 10
+ *        GT_LED_100_LINK_ACT        - off = no link, on = 100 link, blink = activity
+ *        GT_LED_100_LINK            - off = no link, on = 100 link
+ *        GT_LED_1000_LINK_ACT    - off = no link, on = 1000 link, blink = activity
+ *        GT_LED_1000_LINK        - off = no link, on = 1000 link
+ *        GT_LED_10_100_LINK_ACT    - off = no link, on = 10 or 100 link, blink = activity
+ *        GT_LED_10_100_LINK        - off = no link, on = 10 or 100 link
+ *        GT_LED_10_1000_LINK_ACT    - off = no link, on = 10 or 1000 link, blink = activity
+ *        GT_LED_10_1000_LINK        - off = no link, on = 10 or 1000 link
+ *        GT_LED_100_1000_LINK_ACT- off = no link, on = 100 or 1000 link, blink = activity
+ *        GT_LED_100_1000_LINK    - off = no link, on = 100 or 1000 link
+ *        GT_LED_SPECIAL            - special leds
+ *        GT_LED_DUPLEX_COL        - off = half duplx, on = full duplex, blink = collision
+ *        GT_LED_ACTIVITY            - off = no link, blink on = activity
+ *        GT_LED_PTP_ACT            - blink on = PTP activity
+ *        GT_LED_FORCE_BLINK        - force blink
+ *        GT_LED_FORCE_OFF        - force off
+ *        GT_LED_FORCE_ON            - force on
+*/
+#define GT_LED_LINK_ACT_SPEED        1
+#define GT_LED_LINK_ACT            2
+#define GT_LED_LINK                3
+#define GT_LED_10_LINK_ACT            4
+#define GT_LED_10_LINK                5
+#define GT_LED_100_LINK_ACT        6
+#define GT_LED_100_LINK            7
+#define GT_LED_1000_LINK_ACT        8
+#define GT_LED_1000_LINK            9
+#define GT_LED_10_100_LINK_ACT        10
+#define GT_LED_10_100_LINK            11
+#define GT_LED_10_1000_LINK_ACT    12
+#define GT_LED_10_1000_LINK        13
+#define GT_LED_100_1000_LINK_ACT    14
+#define GT_LED_100_1000_LINK        15
+#define GT_LED_SPECIAL                16
+#define GT_LED_DUPLEX_COL            17
+#define GT_LED_ACTIVITY            18
+#define GT_LED_PTP_ACT                19
+#define GT_LED_FORCE_BLINK            20
+#define GT_LED_FORCE_OFF            21
+#define GT_LED_FORCE_ON            22
+#define GT_LED_RESERVE                23
+
+
+/*
+ * typedef: enum GT_LED_CFG
+ *
+ * Description: Enumeration for LED configuration type
+ *
+ * Enumerations:
+ *        GT_LED_CFG_LED0        - read/write led0 value (GT_LED_xxx definition)
+ *        GT_LED_CFG_LED1        - read/write led1 value
+ *        GT_LED_CFG_LED2        - read/write led2 value
+ *        GT_LED_CFG_LED3        - read/write led3 value
+ *        GT_LED_CFG_PULSE_STRETCH    - read/write pulse stretch (0 ~ 4)
+ *        GT_LED_CFG_BLINK_RATE        - read/write blink rate    (0 ~ 5)
+ *        GT_LED_CFG_SPECIAL_CONTROL    - read/write special control (port vector)
+ */
+typedef enum
+{
+    GT_LED_CFG_LED0,
+    GT_LED_CFG_LED1,
+    GT_LED_CFG_LED2,
+    GT_LED_CFG_LED3,
+    GT_LED_CFG_PULSE_STRETCH,
+    GT_LED_CFG_BLINK_RATE,
+    GT_LED_CFG_SPECIAL_CONTROL
+} GT_LED_CFG;
+
+
+/*
+ * typedef: enum GT_AVB_RECOVERED_CLOCK
+ *
+ * Description: Enumeration for recovered clock type
+ *
+ * Enumerations:
+ *        GT_PRIMARY_RECOVERED_CLOCK         - primary recovered clock
+ *        GT_SECONDARY_RECOVERED_CLOCK     - secondary recovered clock
+ */
+typedef enum
+{
+    GT_PRIMARY_RECOVERED_CLOCK,
+    GT_SECONDARY_RECOVERED_CLOCK
+} GT_AVB_RECOVERED_CLOCK;
+
+
+/* Define QAV interrupt bits */
+
+#define GT_QAV_INT_STATUS_ENQ_LMT_BIT            0x8000    /* EnQ Limit Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_DEL_BIT            0x0400    /* Iso Delay Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_DIS_BIT            0x0200  /* Iso Discard Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT        0x0100  /* Iso Packet Memory Exceeded Interrupt Enable */
+
+#define GT_QAV_INT_ENABLE_ENQ_LMT_BIT            0x80  /* EnQ Limit Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_DEL_BIT            0x04  /* Iso Delay Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_DIS_BIT            0x02  /* Iso Discard Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT        0x01  /* Iso Packet Memory Exceeded Interrupt Enable */
+
+
+/*
+ * Typedef: enum GT_EEPROM_OPERATION
+ *
+ * Description: Defines the EEPROM Operation type
+ *
+ * Fields:
+ *      PTP_WRITE_DATA             - Write data to the EEPROM register
+ *      PTP_READ_DATA            - Read data from EEPROM register
+ *      PTP_RESTART                - Restart EEPROM oprition
+ */
+typedef enum
+{
+    GT_EEPROM_NO_OP                     = 0x0,
+    GT_EEPROM_WRITE_DATA             = 0x3,
+    GT_EEPROM_READ_DATA              = 0x4,
+    GT_EEPROM_RESTART                = 0x6,
+    GT_EEPROM_HALT                    = 0x7,
+} GT_EEPROM_OPERATION;
+
+
+/*
+ *  typedef: struct GT_EEPROM_OP_DATA
+ *
+ *  Description: data required by EEPROM Operation
+ *
+ *  Fields:
+ *      eepromPort        - physical port of the device
+ *      eepromAddr     - register address
+ *      eepromData     - data for ptp register.
+ */
+typedef struct
+{
+    GT_U32    eepromPort;
+    GT_U32    eepromBlock;
+    GT_U32    eepromAddr;
+    GT_U32    eepromData;
+} GT_EEPROM_OP_DATA;
+
+#define GT_EEPROM_OP_ST_RUNNING_MASK        0x800
+#define GT_EEPROM_OP_ST_WRITE_EN_MASK        0x400
+
+#define GT_SCRAT_MISC_REG_SCRAT_0    0x00 /* Scratch Byte 0 */
+#define GT_SCRAT_MISC_REG_SCRAT_1    0x01 /* Scratch Byte 1 */
+#define GT_SCRAT_MISC_REG_GPIO_CFG    0x60 /* GPIO Configuration */
+                                         /* 0x61 = Reserved for future use */
+#define GT_SCRAT_MISC_REG_GPIO_DIR    0x62 /* GPIO Direction */
+#define GT_SCRAT_MISC_REG_GPIO_DAT    0x63 /* GPIO Data */
+#define GT_SCRAT_MISC_REG_CFG_DAT0    0x70 /* CONFIG Data 0 */
+#define GT_SCRAT_MISC_REG_CFG_DAT1    0x71 /* CONFIG Data 1 */
+#define GT_SCRAT_MISC_REG_CFG_DAT2    0x72 /* CONFIG Data 2 */
+#define GT_SCRAT_MISC_REG_CFG_DAT3    0x73 /* CONFIG Data 3 */
+#define GT_SCRAT_MISC_REG_SYNCE        0x7C /* SyncE & TAICLK125s Drive */
+#define GT_SCRAT_MISC_REG_P5_CLK    0x7D /* P5s & CLK125s Clock Drive */
+#define GT_SCRAT_MISC_REG_P6_CLK    0x7E /* P6s Clock Drive */
+#define GT_SCRAT_MISC_REG_EEPROM    0x7F /* EEPROM Pad drive */
+#define GT_SCRAT_MISC_REG_MAX        0x80 /* Maximun register pointer */
+
+#define GT_GPIO_BIT_0    0x1
+#define GT_GPIO_BIT_1    0x2
+#define GT_GPIO_BIT_2    0x4
+#define GT_GPIO_BIT_3    0x8
+#define GT_GPIO_BIT_4    0x10
+#define GT_GPIO_BIT_5    0x20
+#define GT_GPIO_BIT_6    0x40
+
+typedef struct
+{
+    GT_U8         user : 3;
+    GT_U8         addr : 5;
+}GT_CONFIG_DATA_0;
+
+typedef struct
+{
+    GT_U8         led  : 2;
+    GT_U8         fourcol : 1;
+    GT_U8         normCx : 1;
+    GT_U8         jumbo : 1;
+    GT_U8         ee_we : 1;
+    GT_U8         fd_flow : 1;
+    GT_U8         hd_flow : 1;
+}GT_CONFIG_DATA_1;
+
+typedef struct
+{
+    GT_U8         p5_mod : 3;
+    GT_U8         bit4     : 1;
+    GT_U8         p6_mod : 3;
+}GT_CONFIG_DATA_2;
+
+typedef struct
+{
+    GT_U8         rmu_mod : 2;
+}GT_CONFIG_DATA_3;
+
+typedef struct
+{
+    union {
+        GT_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData0;
+    union {
+        GT_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData1;
+    union {
+        GT_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData2;
+    union {
+        GT_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData3;
+}GT_CONFIG_DATA;
+
+
+/* definition for Trunking */
+#define IS_TRUNK_ID_VALID(_dev, _id)    (((_id) < 16) ? 1 : 0)
+
+
+/* definition for device scan mode */
+#define SMI_AUTO_SCAN_MODE        0    /* Scan 0 or 0x10 base address to find the QD */
+#define SMI_MANUAL_MODE            1    /* Use QD located at manually defined base addr */
+#define SMI_MULTI_ADDR_MODE        2    /* Use QD at base addr and use indirect access */
+typedef struct
+{
+    GT_U32    scanMode;    /* check definition for device scan mode */
+    GT_U32    baseAddr;    /* meaningful if scanMode is not SMI_AUTO_SCAN_MODE */
+} GT_SCAN_MODE;
+
+/* definition for Cut Through */
+typedef struct
+{
+    GT_U8    enableSelect;    /* Port Enable Select. */
+    GT_U8    enable;          /* Cut Through enable. */
+    GT_U8    cutThruQueue;    /* Cut Through Queues.. */
+} GT_CUT_THROUGH;
+
+#define GT_SKIP_INIT_SETUP    0x736b6970
+
+/*
+ * Typedef: struct GT_SYS_CONFIG
+ *
+ * Description: System configuration Parameters struct.
+ *
+ * Fields:
+ *    devNum        - Switch Device Number
+ *  cpuPortNum  - The physical port used to connect the device to CPU.
+ *                This is the port to which packets destined to CPU are
+ *                forwarded.
+ *  initPorts   - Whether to initialize the ports state.
+ *                GT_FALSE    - leave in default state.
+ *                GT_TRUE     - Initialize to Forwarding state.
+ *  skipInitSetup - skip init setup, if value is GT_SKIP_INIT_SETUP
+ *                  perform init setup, otherwise
+ *                    Initializing port state is not affected by this variable.
+ *    BSPFunctions    - Group of BSP specific functions.
+ *                SMI Read/Write and Semaphore Related functions.
+ */
+typedef struct
+{
+    GT_U8         devNum;
+    GT_U8         cpuPortNum;
+    GT_BOOL       initPorts;
+    BSP_FUNCTIONS BSPFunctions;
+    GT_SCAN_MODE  mode;
+    GT_U32        skipInitSetup;
+}GT_SYS_CONFIG;
+
+#ifdef GT_RMGMT_ACCESS
+typedef enum
+{
+ HW_ACCESS_MODE_SMI = 0,    /* Use SMI */
+ HW_ACCESS_MODE_F2R = 1,    /* Use Marvell RMGMT(F2R) function */
+} FGT_HW_ACCESS_MOD;    /* Hardware access mode */
+#endif
+
+/*
+ * Typedef: struct GT_QD_DEV
+ *
+ * Description: Includes Tapi layer switch configuration data.
+ *
+ * Fields:
+ *   deviceId       - The device type identifier.
+ *   revision       - The device revision number.
+ *   baseRegAddr    - Switch Base Register address.
+ *   numOfPorts     - Number of active ports.
+ *   maxPorts       - max ports. This field is only for driver's use.
+ *   cpuPortNum     - Logical port number whose physical port is connected to the CPU.
+ *   maxPhyNum      - max configurable Phy address.
+ *   stpMode        - current switch STP mode (0 none, 1 en, 2 dis)
+ *   accessMode        - shows how to find and access the device.
+ *   phyAddr        - SMI address used to access Switch registers(only for SMI_MULTI_ADDR_MODE).
+ *   validPortVec   - valid port list in vector format
+ *   validPhyVec    - valid phy list in vector format
+ *   validSerdesVec    - valid serdes list in vector format
+ *   devGroup        - the device group
+ *   devName        - name of the device in group 0
+ *   devName1        - name of the device in group 1
+ *   devStorage        - driver internal use (hold various temp information)
+ *   multiAddrSem   - Semaphore for Accessing SMI Device
+ *   atuRegsSem     - Semaphore for ATU access
+ *   vtuRegsSem     - Semaphore for VTU access
+ *   statsRegsSem   - Semaphore for RMON counter access
+ *   pirlRegsSem    - Semaphore for PIRL Resource access
+ *   ptpRegsSem     - Semaphore for PTP Resource access
+ *   tblRegsSem     - Semaphore for various Table Resource access,
+ *                    such as Trunk Tables and Device Table
+ *   eepromRegsSem  - Semaphore for eeprom control access
+ *   phyRegsSem     - Semaphore for PHY Device access
+ *   hwAccessRegsSem - Semaphore for Remote management access
+ *   fgtHwAccessMod - Select register access mode: Read/Write or Hardware access function
+ *   fgtReadMii     - platform specific SMI register Read function
+ *   fgtWriteMii    - platform specific SMI register Write function
+ *   fgtHwAccess    - platform specific register access function
+ *   semCreate      - function to create semapore
+ *   semDelete      - function to delete the semapore
+ *   semTake        - function to get a semapore
+ *   semGive        - function to return semaphore
+ *   appData        - application data that user may use
+ */
+struct _GT_QD_DEV
+{
+    GT_DEVICE   deviceId;
+    GT_LPORT    cpuPortNum;
+    GT_U8       revision;
+    GT_U8        devNum;
+    GT_U8        devEnabled;
+    GT_U8       baseRegAddr;
+    GT_U8       numOfPorts;
+    GT_U8        maxPorts;
+    GT_U8       maxPhyNum;
+    GT_U8        stpMode;
+    GT_U8        accessMode;
+    GT_U8        phyAddr;
+    GT_U16        reserved;
+    GT_U16        validPortVec;
+    GT_U16        validPhyVec;
+    GT_U16        validSerdesVec;
+    GT_U16        devGroup;
+    GT_U32        devName;
+    GT_U32        devName1;
+    GT_U32        devStorage;
+    GT_SEM        multiAddrSem;
+    GT_SEM        atuRegsSem;
+    GT_SEM        vtuRegsSem;
+    GT_SEM        statsRegsSem;
+    GT_SEM        pirlRegsSem;
+    GT_SEM        ptpRegsSem;
+    GT_SEM        tblRegsSem;
+    GT_SEM        eepromRegsSem;
+    GT_SEM        phyRegsSem;
+    GT_SEM        hwAccessRegsSem;
+
+    FGT_READ_MII  fgtReadMii;
+    FGT_WRITE_MII fgtWriteMii;
+#ifdef GT_RMGMT_ACCESS
+    FGT_HW_ACCESS_MOD fgtHwAccessMod;    /* Hardware access mode */
+    FGT_HW_ACCESS fgtHwAccess;    /* Hardware access  */
+#endif
+
+    FGT_SEM_CREATE  semCreate;     /* create semaphore */
+    FGT_SEM_DELETE  semDelete;     /* delete the semaphore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semaphore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
+    void*           appData;
+
+    /* Modified to add port mapping functions into device ssystem configuration. */
+#ifdef GT_PORT_MAP_IN_DEV
+    GT_U8           (*lport2port)   (GT_U16 portVec, GT_LPORT port);
+    GT_LPORT        (*port2lport)   (GT_U16 portVec, GT_U8 hwPort);
+    GT_U32          (*lportvec2portvec) (GT_U16 portVec, GT_U32 lVec);
+    GT_U32          (*portvec2lportvec) (GT_U16 portVec, GT_U32 pVec);
+#endif
+
+    GT_BOOL       use_mad;     /* use MAD driver to process Phy */
+#ifdef GT_USE_MAD
+    MAD_DEV    mad_dev;
+#endif
+};
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApi_h */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiPrototype.h
@@ -0,0 +1,22912 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* msApiPrototype.h
+*
+* DESCRIPTION:
+*       API Prototypes for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiPrototype_h
+#define __msApiPrototype_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbSetAtuSize
+*
+* DESCRIPTION:
+*       Sets the Mac address table size.
+*
+* INPUTS:
+*       size    - Mac address table size.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetAtuSize
+(
+    IN GT_QD_DEV *dev,
+    IN ATU_SIZE size
+);
+
+
+/*******************************************************************************
+* gfdbGetAgingTimeRange
+*
+* DESCRIPTION:
+*       Gets the maximal and minimum age times that the hardware can support.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       maxTimeout - max aging time in secounds.
+*       minTimeout - min aging time in secounds.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAgingTimeRange
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_U32 *maxTimeout,
+    OUT GT_U32 *minTimeout
+);
+
+/*******************************************************************************
+* gfdbGetAgingTimeout
+*
+* DESCRIPTION:
+*       Gets the timeout period in seconds for aging out dynamically learned
+*       forwarding information. The returned value may not be the same as the value
+*        programmed with <gfdbSetAgingTimeout>. Please refer to the description of
+*        <gfdbSetAgingTimeout>.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       timeout - aging time in seconds.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAgingTimeout
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32       *timeout
+);
+
+/*******************************************************************************
+* gfdbSetAgingTimeout
+*
+* DESCRIPTION:
+*       Sets the timeout period in seconds for aging out dynamically learned
+*       forwarding information. The standard recommends 300 sec.
+*        Supported aging timeout values are multiple of time-base, where time-base
+*        is either 15 or 16 seconds, depending on the Switch device. For example,
+*        88E6063 uses time-base 16, and so supported aging timeouts are 0,16,32,
+*        48,..., and 4080. If unsupported timeout value (bigger than 16) is used,
+*        the value will be rounded to the nearest supported value smaller than the
+*        given timeout. If the given timeout is less than 16, minimum timeout value
+*        16 will be used instead. E.g.) 35 becomes 32 and 5 becomes 16.
+*        <gfdbGetAgingTimeRange> function can be used to find the time-base.
+*
+* INPUTS:
+*       timeout - aging time in seconds.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetAgingTimeout
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U32 timeout
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuDynamicCount
+*
+* DESCRIPTION:
+*       Gets the current number of dynamic unicast entries in this
+*       Filtering Database.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numDynEntries - number of dynamic entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuDynamicCount
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_U32 *numDynEntries
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic MAC address entry from the ATU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from Mac[00:00:00:00:00:00]
+*
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuEntryFirst
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_ATU_ENTRY    *atuEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic MAC address from the specified Mac Addr.
+*
+* INPUTS:
+*       atuEntry - the Mac Address to start the search.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
+*       user.
+*
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuEntryNext
+(
+    IN GT_QD_DEV *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbFindAtuMacEntry
+*
+* DESCRIPTION:
+*       Find FDB entry for specific MAC address from the ATU.
+*
+* INPUTS:
+*       atuEntry - the Mac address to search.
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       atuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbFindAtuMacEntry
+(
+    IN GT_QD_DEV *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry,
+    OUT GT_BOOL         *found
+);
+
+
+
+/*******************************************************************************
+* gfdbFlush
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the MAC Address
+*       Table.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbFlush
+(
+    IN GT_QD_DEV *dev,
+    IN GT_FLUSH_CMD flushCmd
+);
+
+/*******************************************************************************
+* gfdbFlushInDB
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the particular
+*       ATU Database (DBNum). If multiple address databases are being used, this
+*        API can be used to flush entries in a particular DBNum database.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*        DBNum     - ATU MAC Address Database Number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbFlushInDB
+(
+    IN GT_QD_DEV *dev,
+    IN GT_FLUSH_CMD flushCmd,
+    IN GT_U32 DBNum
+);
+
+/*******************************************************************************
+* gfdbAddMacEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in MAC address table.
+*
+* INPUTS:
+*       macEntry    - mac address entry to insert to the ATU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_NO_RESOURCE    - failed to allocate a t2c struct
+*       GT_OUT_OF_CPU_MEM - oaMalloc failed
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbAddMacEntry
+(
+    IN GT_QD_DEV *dev,
+    IN GT_ATU_ENTRY *macEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbDelMacEntry
+*
+* DESCRIPTION:
+*       Deletes MAC address entry.
+*
+* INPUTS:
+*       macAddress - mac address.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*       For SVL mode vlan Id is ignored.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbDelMacEntry
+(
+    IN GT_QD_DEV *dev,
+    IN GT_ETHERADDR  *macAddress
+);
+
+/*******************************************************************************
+* gfdbDelAtuEntry
+*
+* DESCRIPTION:
+*       Deletes ATU entry.
+*
+* INPUTS:
+*       atuEntry - the ATU entry to be deleted.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbDelAtuEntry
+(
+    IN GT_QD_DEV *dev,
+    IN GT_ATU_ENTRY  *atuEntry
+);
+
+/*******************************************************************************
+* gfdbLearnEnable
+*
+* DESCRIPTION:
+*       Enable/disable automatic learning of new source MAC addresses on port
+*       ingress.
+*
+* INPUTS:
+*       en - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbLearnEnable
+(
+    IN GT_QD_DEV *dev,
+    IN GT_BOOL  en
+);
+
+
+/*******************************************************************************
+* gfdbGetLearnEnable
+*
+* DESCRIPTION:
+*       Get automatic learning status of new source MAC addresses on port ingress.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       en - GT_TRUE if enabled  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetLearnEnable
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_BOOL  *en
+);
+
+/*******************************************************************************
+* gstpSetMode
+*
+* DESCRIPTION:
+*       This routine Enable the Spanning tree.
+*
+* INPUTS:
+*       en - GT_TRUE for enable, GT_FALSE for disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       when enabled, this function sets all port to blocking state, and inserts
+*       the BPDU MAC into the ATU to be captured to CPU, on disable all port are
+*       being modified to be in forwarding state.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpSetMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gstpSetPortState
+*
+* DESCRIPTION:
+*       This routine set the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       state - the port state to set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpSetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT           port,
+    IN GT_PORT_STP_STATE  state
+);
+
+
+
+/*******************************************************************************
+* gstpGetPortState
+*
+* DESCRIPTION:
+*       This routine returns the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       state - the current port state.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpGetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT           port,
+    OUT GT_PORT_STP_STATE  *state
+);
+
+/*******************************************************************************
+* gprtSetEgressMode
+*
+* DESCRIPTION:
+*       This routine set the egress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the egress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT        port,
+    IN GT_EGRESS_MODE  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetEgressMode
+*
+* DESCRIPTION:
+*       This routine get the egress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the egress mode.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_EGRESS_MODE  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine sets the vlan tunnel mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the vlan tunnel mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine get the vlan tunnel mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the vlan tunnel mode..
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+/*******************************************************************************
+* gprtSetIGMPSnoop
+*
+* DESCRIPTION:
+*         This routine set the IGMP Snoop. When set to one and this port receives
+*        IGMP frame, the frame is switched to the CPU port, overriding all other
+*        switching decisions, with exception for CPU's Trailer.
+*        CPU port is determined by the Ingress Mode bits. A port is considered
+*        the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or
+*        GT_CPUPORT_INGRESS.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIGMPSnoop
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* gprtGetIGMPSnoop
+*
+* DESCRIPTION:
+*        This routine get the IGMP Snoop mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: IGMP Snoop enabled
+*              GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIGMPSnoop
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/* the following two APIs are added to support clippership */
+
+/*******************************************************************************
+* gprtSetHeaderMode
+*
+* DESCRIPTION:
+*        This routine set ingress and egress header mode of a switch port.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for header mode  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetHeaderMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* gprtGetHeaderMode
+*
+* DESCRIPTION:
+*        This routine gets ingress and egress header mode of a switch port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: header mode enabled
+*              GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHeaderMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+/*******************************************************************************
+* gprtSetProtectedMode
+*
+* DESCRIPTION:
+*        This routine set protected mode of a switch port.
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetProtectedMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+);
+
+/*******************************************************************************
+* gprtGetProtectedMode
+*
+* DESCRIPTION:
+*        This routine gets protected mode of a switch port.
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: header mode enabled
+*              GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetProtectedMode
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetForwardUnknown
+*
+* DESCRIPTION:
+*        This routine set Forward Unknown mode of a switch port.
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetForwardUnknown
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT    port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetForwardUnknown
+*
+* DESCRIPTION:
+*        This routine gets Forward Unknown mode of a switch port.
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: header mode enabled
+*                GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetForwardUnknown
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtGetSwitchReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSwitchReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetSwitchReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetSwitchReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    IN  GT_U16         data
+);
+
+
+/*******************************************************************************
+* gprtGetGlobalReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobalReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetGlobalReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobalReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         regAddr,
+    IN  GT_U16         data
+);
+
+
+
+/*******************************************************************************
+* gvlnSetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*       memPorts    - array of logical ports.
+*       memPortsLen - number of members in memPorts array
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_LPORT memPorts[],
+    IN GT_U8    memPortsLen
+);
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine gets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*
+* OUTPUTS:
+*       memPorts    - array of logical ports.
+*       memPortsLen - number of members in memPorts array
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_LPORT memPorts[],
+    OUT GT_U8    *memPortsLen
+);
+
+
+
+
+/*******************************************************************************
+* gvlnSetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine Set the user priority (VPT) LSB bit, to be added to the
+*       user priority on the egress.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortUserPriLsb
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  userPriLsb
+);
+
+
+
+/*******************************************************************************
+* gvlnGetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine gets the user priority (VPT) LSB bit.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*
+* OUTPUTS:
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortUserPriLsb
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *userPriLsb
+);
+
+
+/*******************************************************************************
+* gvlnSetPortVid
+*
+* DESCRIPTION:
+*       This routine Set the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*       vid  - the port vlan id.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVid
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_U16   vid
+);
+
+
+/*******************************************************************************
+* gvlnGetPortVid
+*
+* DESCRIPTION:
+*       This routine Get the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*
+* OUTPUTS:
+*       vid  - the port vlan id.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVid
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U16   *vid
+);
+
+/*******************************************************************************
+* gvlnSetPortVlanDBNum
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN database number (DBNum).
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       DBNum     - database number for this port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_U32   DBNum
+);
+
+
+/*******************************************************************************
+* gvlnGetPortVlanDBNum
+*
+* DESCRIPTION:IN GT_INGRESS_MODE mode
+*       This routine gets the port VLAN database number (DBNum).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       DBNum     - database number for this port
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U32    *DBNum
+);
+
+/********************************************************************
+* gvlnSetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine sets the port 802.1q mode (11:10)
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode     - 802.1q mode for this port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanDot1qMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT     port,
+    IN GT_DOT1Q_MODE    mode
+);
+
+/*******************************************************************************
+* gvlnGetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine gets the port 802.1q mode (bit 11:10).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       mode     - 802.1q mode for this port
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanDot1qMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_DOT1Q_MODE    *mode
+);
+
+
+/********************************************************************
+* gvlnSetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine sets the port 802.1q mode (11:10)
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode    - GT_TRUE, force to use default VID
+*                 GT_FAULSE, otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+);
+
+/*******************************************************************************
+* gvlnGetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine gets the port mode for ForceDefaultVID (bit 12).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       mode     - ForceDefaultVID mode for this port
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT      port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* eventSetActive
+*
+* DESCRIPTION:
+*       This routine enables/disables the receive of an hardware driven event.
+*
+* INPUTS:
+*       eventType - the event type. any combination of the folowing:
+*           GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,
+*           GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, and GT_DEVICE_INT
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Each switch device has its own set of event Types. Please refer to the
+*        device datasheet for the list of event types that the device supports.
+*
+*******************************************************************************/
+GT_STATUS eventSetActive
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_U32         eventType
+);
+
+/*******************************************************************************
+* eventGetIntStatus
+*
+* DESCRIPTION:
+*       This routine reads an hardware driven event status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       intCause -  It provides the source of interrupt of the following:
+*                GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,
+*                GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT.
+*                For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_FULL and
+*                GT_PHY_INTERRUPT is not supported.
+*                GT_DEVICE_INT may not be available on the devices, so please refer
+*                to the datasheet for details.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS eventGetIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *intCause
+);
+
+/*******************************************************************************
+* gvtuGetIntStatus
+*
+* DESCRIPTION:
+*         Check to see if a specific type of VTU interrupt occured
+*
+* INPUTS:
+*       intType - the type of interrupt which causes an interrupt.
+*            any combination of
+*            GT_MEMEBER_VIOLATION,
+*            GT_MISS_VIOLATION,
+*            GT_FULL_VIOLATION
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK   - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*         FULL_VIOLATION is only for Fast Ethernet Switch (not for Gigabit Switch).
+*
+*******************************************************************************/
+
+GT_STATUS gvtuGetIntStatus
+(
+    IN  GT_QD_DEV             *dev,
+    OUT GT_VTU_INT_STATUS     *vtuIntStatus
+);
+
+/*******************************************************************************
+* gvtuGetEntryCount
+*
+* DESCRIPTION:
+*       Gets the current number of entries in the VTU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numEntries - number of VTU entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryCount
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32         *numEntries
+);
+
+/*******************************************************************************
+* gvtuGetEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic entry from the VTU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from vid of all one's
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryFirst
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_VTU_ENTRY    *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuGetEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic VTU entry from the specified VID.
+*
+* INPUTS:
+*       vtuEntry - the VID to start the search.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU  entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from the VID specified by the user.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryNext
+(
+    IN  GT_QD_DEV         *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuFindVidEntry
+*
+* DESCRIPTION:
+*       Find VTU entry for a specific VID, it will return the entry, if found,
+*       along with its associated data
+*
+* INPUTS:
+*       vtuEntry - contains the VID to search for.
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       vtuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuFindVidEntry
+(
+    IN GT_QD_DEV         *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry,
+    OUT GT_BOOL         *found
+);
+
+/*******************************************************************************
+* gvtuFlush
+*
+* DESCRIPTION:
+*       This routine removes all entries from VTU Table.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuFlush
+(
+    IN GT_QD_DEV *dev
+);
+
+/*******************************************************************************
+* gvtuAddEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in VTU table based on user input.
+*
+* INPUTS:
+*       vtuEntry    - vtu entry to insert to the VTU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_FULL              - vtu table is full
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuAddEntry
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_VTU_ENTRY *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuDelEntry
+*
+* DESCRIPTION:
+*       Deletes VTU entry specified by user.
+*
+* INPUTS:
+*       vtuEntry - the VTU entry to be deleted
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuDelEntry
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_VTU_ENTRY *vtuEntry
+);
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtPhyReset
+*
+* DESCRIPTION:
+*        This routine preforms PHY reset.
+*        After reset, phy will be in Autonegotiation mode.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+* COMMENTS:
+*         data sheet register 0.15 - Reset
+*         data sheet register 0.13 - Speed
+*         data sheet register 0.12 - Autonegotiation
+*         data sheet register 0.8  - Duplex Mode
+*
+*******************************************************************************/
+
+GT_STATUS gprtPhyReset
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port
+);
+
+
+/*******************************************************************************
+* gprtSetPortLoopback
+*
+* DESCRIPTION:
+* Enable/Disable Internal Port Loopback.
+* For 10/100 Fast Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled, this routine disables Auto-Negotiation and
+*   forces speed to be 10Mbps.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   Disabling Loopback simply clears bit 14 of control register(0.14). Therefore,
+*   it is recommended to call gprtSetPortAutoMode for PHY configuration after
+*   Loopback test.
+* For 10/100/1000 Gigagbit Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled and Link is active, the current speed is used.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   All other cases, default MAC Interface speed is used. Please refer to the data
+*   sheet for the information of the default MAC Interface speed.
+*
+* INPUTS:
+*         port - logical port number
+*         enable - If GT_TRUE, enable loopback mode
+*                     If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortLoopback
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL         enable
+);
+
+
+/*******************************************************************************
+* gprtSetPortSpeed
+*
+* DESCRIPTION:
+*         Sets speed for a specific logical port. This function will keep the duplex
+*        mode and loopback mode to the previous value, but disable others, such as
+*        Autonegotiation.
+*
+* INPUTS:
+*         port  - logical port number
+*         speed - port speed.
+*                PHY_SPEED_10_MBPS for 10Mbps
+*                PHY_SPEED_100_MBPS for 100Mbps
+*                PHY_SPEED_1000_MBPS for 1000Mbps
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.13 - Speed Selection (LSB)
+* data sheet register 0.6  - Speed Selection (MSB)
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortSpeed
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_SPEED    speed
+);
+
+
+/*******************************************************************************
+* gprtPortAutoNegEnable
+*
+* DESCRIPTION:
+*         Enable/disable an Auto-Negotiation for duplex mode on specific
+*         logical port. When Autonegotiation is disabled, phy will be in 10Mbps Half
+*        Duplex mode. Enabling Autonegotiation will set 100BASE-TX Full Duplex,
+*        100BASE-TX Full Duplex, 100BASE-TX Full Duplex, and 100BASE-TX Full Duplex
+*        in AutoNegotiation Advertisement register.
+*
+* INPUTS:
+*         port - logical port number
+*         state - GT_TRUE for enable Auto-Negotiation for duplex mode,
+*                     GT_FALSE otherwise
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortAutoNegEnable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL         state
+);
+
+
+/*******************************************************************************
+* gprtPortPowerDown
+*
+* DESCRIPTION:
+*         Enable/disable (power down) on specific logical port. When this function
+*        is called with normal operation request, phy will set to Autonegotiation
+*        mode.
+*
+* INPUTS:
+*         port    - logical port number
+*         state    -  GT_TRUE: power down
+*                     GT_FALSE: normal operation
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortPowerDown
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        state
+);
+
+
+/*******************************************************************************
+* gprtPortRestartAutoNeg
+*
+* DESCRIPTION:
+*         Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable
+*        it. Loopback and Power Down will be disabled by this routine.
+*
+* INPUTS:
+*         port - logical port number
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.9 - Restart Auto-Negotiation
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortRestartAutoNeg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+
+/*******************************************************************************
+* gprtSetPortDuplexMode
+*
+* DESCRIPTION:
+*         Sets duplex mode for a specific logical port. This function will keep
+*        the speed and loopback mode to the previous value, but disable others,
+*        such as Autonegotiation.
+*
+* INPUTS:
+*         port     - logical port number
+*         dMode    - dulpex mode
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.8 - Duplex Mode
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortDuplexMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        dMode
+);
+
+
+/*******************************************************************************
+* gprtSetPortAutoMode
+*
+* DESCRIPTION:
+*         This routine sets up the port with given Auto Mode.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*
+*
+* INPUTS:
+*         port - The logical port number
+*         mode - Auto Mode to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+* COMMENTS:
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+
+GT_STATUS gprtSetPortAutoMode
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_AUTO_MODE mode
+);
+
+/*******************************************************************************
+* gprtSetPause
+*
+* DESCRIPTION:
+*       This routine will set the pause bit in Autonegotiation Advertisement
+*        Register. And restart the autonegotiation.
+*
+* INPUTS:
+* port - The logical port number
+* state - GT_PHY_PAUSE_MODE enum value.
+*            GT_PHY_NO_PAUSE        - disable pause
+*             GT_PHY_PAUSE        - support pause
+*            GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*            GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+
+GT_STATUS gprtSetPause
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_PAUSE_MODE state
+);
+
+/*******************************************************************************
+* gprtSetDTEDetect
+*
+* DESCRIPTION:
+*       This routine enables/disables DTE.
+*
+* INPUTS:
+*         port - The logical port number
+*         mode - either GT_TRUE(for enable) or GT_FALSE(for disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetect
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+);
+
+/*******************************************************************************
+* gprtGetDTEDetectStatus
+*
+* DESCRIPTION:
+*       This routine gets DTE status.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       status - GT_TRUE, if link partner needs DTE power.
+*                 GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectStatus
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+);
+
+/*******************************************************************************
+* gprtSetDTEDetectDropWait
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*        will wait a period of time before clearing the power over Ethernet
+*        detection status bit. The wait time is 5 seconds multiplied by the
+*        given value.
+*
+* INPUTS:
+*         port - The logical port number
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetectDropWait
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_U16    waitTime
+);
+
+/*******************************************************************************
+* gprtGetDTEDetectDropWait
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*        will wait a period of time before clearing the power over Ethernet
+*        detection status bit. The wait time is 5 seconds multiplied by the
+*        returned value.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectDropWait
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_U16    *waitTime
+);
+
+/*******************************************************************************
+* gprtSetEnergyDetect
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*       mode - GT_EDETECT_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetEnergyDetect
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
+);
+
+/*******************************************************************************
+* gprtGetEnergyDetect
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       mode - GT_EDETECT_MODE type
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetEnergyDetect
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
+);
+
+/*******************************************************************************
+* gprtSet1000TMasterMode
+*
+* DESCRIPTION:
+*       This routine sets the ports 1000Base-T Master mode and restart the Auto
+*        negotiation.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_1000T_MASTER_SLAVE   *mode
+);
+
+/*******************************************************************************
+* gprtGet1000TMasterMode
+*
+* DESCRIPTION:
+*       This routine retrieves 1000Base-T Master Mode
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_1000T_MASTER_SLAVE   *mode
+);
+
+/*******************************************************************************
+* gprtGetPhyLinkStatus
+*
+* DESCRIPTION:
+*       This routine retrieves the Link status.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       linkStatus - GT_FALSE if link is not established,
+*                     GT_TRUE if link is established.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyLinkStatus
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
+);
+
+/*******************************************************************************
+* gprtSetPktGenEnable
+*
+* DESCRIPTION:
+*       This routine enables or disables Packet Generator.
+*       Link should be established first prior to enabling the packet generator,
+*       and generator will generate packets at the speed of the established link.
+*        When enables packet generator, the following information should be
+*       provided:
+*           Payload Type:  either Random or 5AA55AA5
+*           Packet Length: either 64 or 1514 bytes
+*           Error Packet:  either Error packet or normal packet
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*       en      - GT_TRUE to enable, GT_FALSE to disable
+*       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
+*                 ignored, if en is GT_FALSE
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPktGenEnable
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   en,
+    IN GT_PG     *pktInfo
+);
+
+
+/*******************************************************************************
+* gprtGetPhyReg
+*
+* DESCRIPTION:
+*       This routine reads Phy Registers.
+*
+* INPUTS:
+*       port -    The logical port number,
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetPhyReg
+*
+* DESCRIPTION:
+*       This routine writes Phy Registers.
+*
+* INPUTS:
+*       port -    The logical port number,
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPhyReg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    IN  GT_U32           regAddr,
+    IN  GT_U16           data
+);
+
+/*******************************************************************************
+* gprtGetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*
+* OUTPUTS:
+*        data    - value of the read register
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtGetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
+    OUT GT_U16* data
+);
+
+/*******************************************************************************
+* gprtSetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*        data    - value of the read register
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtSetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
+    IN  GT_U16 data
+);
+
+/*******************************************************************************
+* gprtPhyIntEnable
+*
+* DESCRIPTION:
+* Enable/Disable one PHY Interrupt
+* This register determines whether the INT# pin is asserted when an interrupt
+* event occurs. When an interrupt occurs, the corresponding bit is set and
+* remains set until register 19 is read via the SMI. When interrupt enable
+* bits are not set in register 18, interrupt status bits in register 19 are
+* still set when the corresponding interrupt events occur. However, the INT#
+* is not asserted.
+*
+* INPUTS:
+* port    - logical port number
+* intType - the type of interrupt to enable/disable. any combination of
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,
+*            GT_POLARITY_CHANGED, and
+*            GT_JABBER
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 18
+*
+*******************************************************************************/
+
+GT_STATUS gprtPhyIntEnable
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT   port,
+IN GT_U16    intType
+);
+
+
+/*******************************************************************************
+* gprtGetPhyIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of  interrupt occured
+*
+* INPUTS:
+* port - logical port number
+* intType - the type of interrupt which causes an interrupt.
+*            any combination of
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,
+*            GT_POLARITY_CHANGED, and
+*            GT_JABBER
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 19
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntStatus
+(
+IN GT_QD_DEV *dev,
+IN  GT_LPORT port,
+OUT  GT_U16* intType
+);
+
+/*******************************************************************************
+* gprtGetPhyIntPortSummary
+*
+* DESCRIPTION:
+* Lists the ports that have active interrupts. It provides a quick way to
+* isolate the interrupt so that the MAC or switch does not have to poll the
+* interrupt status register (19) for all ports. Reading this register does not
+* de-assert the INT# pin
+*
+* INPUTS:
+* none
+*
+* OUTPUTS:
+* GT_U8 *intPortMask - bit Mask with the bits set for the corresponding
+* phys with active interrupt. E.g., the bit number 0 and 2 are set when
+* port number 0 and 2 have active interrupt
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 20
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntPortSummary
+(
+IN GT_QD_DEV *dev,
+OUT GT_U16 *intPortMask
+);
+
+
+
+/*******************************************************************************
+* gprtSetForceFc
+*
+* DESCRIPTION:
+*       This routine set the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetForceFc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  force
+);
+
+
+
+/*******************************************************************************
+* gprtGetForceFc
+*
+* DESCRIPTION:
+*       This routine get the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetForceFc
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *force
+);
+
+
+
+/*******************************************************************************
+* gprtSetTrailerMode
+*
+* DESCRIPTION:
+*       This routine set the egress trailer mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetTrailerMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetTrailerMode
+*
+* DESCRIPTION:
+*       This routine get the egress trailer mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTrailerMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetIngressMode
+*
+* DESCRIPTION:
+*       This routine set the ingress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIngressMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT        port,
+    IN GT_INGRESS_MODE mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetIngressMode
+*
+* DESCRIPTION:
+*       This routine get the ingress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the ingress mode.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIngressMode
+(
+    IN GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_INGRESS_MODE *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine set the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMcRateLimit
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT     port,
+    IN GT_MC_RATE   rate
+);
+
+
+
+/*******************************************************************************
+* gprtGetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine Get the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMcRateLimit
+(
+    IN GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_MC_RATE  *rate
+);
+
+
+
+/*******************************************************************************
+* gprtSetCtrMode
+*
+* DESCRIPTION:
+*       This routine sets the port counters mode of operation.
+*
+* INPUTS:
+*       mode  - the counter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetCtrMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_CTR_MODE  mode
+);
+
+
+
+/*******************************************************************************
+* gprtClearAllCtr
+*
+* DESCRIPTION:
+*       This routine clears all port counters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtClearAllCtr
+(
+    IN GT_QD_DEV *dev
+);
+
+
+/*******************************************************************************
+* gprtGetPortCtr
+*
+* DESCRIPTION:
+*       This routine gets the port counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortCtr
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT    *ctr
+);
+
+
+
+
+/*******************************************************************************
+* gprtGetPartnerLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link partner pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPartnerLinkPause
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetSelfLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSelfLinkPause
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetResolve
+*
+* DESCRIPTION:
+*       This routine retrives the resolve state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Done  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetResolve
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetLinkState
+*
+* DESCRIPTION:
+*       This routine retrives the link state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Up  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLinkState
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetPortMode
+*
+* DESCRIPTION:
+*       This routine retrives the port mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetPhyMode
+*
+* DESCRIPTION:
+*       This routine retrives the PHY mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII PHY  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetDuplex
+*
+* DESCRIPTION:
+*       This routine retrives the port duplex mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for Full  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDuplex
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetSpeed
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       speed - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for 100Mb/s  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSpeed
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *speed
+);
+
+/*******************************************************************************
+* gprtSetDuplex
+*
+* DESCRIPTION:
+*       This routine sets the duplex mode of MII/SNI/RMII ports.
+*
+* INPUTS:
+*       port -     the logical port number.
+*                (for FullSail, it will be port 2, and for ClipperShip,
+*                it could be either port 5 or port 6.)
+*       mode -  GT_TRUE for Full Duplex,
+*                GT_FALSE for Half Duplex.
+*
+* OUTPUTS: None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDuplex
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    IN  GT_BOOL  mode
+);
+
+
+/*******************************************************************************
+* gqosSetPortDefaultTc
+*
+* DESCRIPTION:
+*       Sets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*       trafClass - default traffic class of a port.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosSetPortDefaultTc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_U8    trafClass
+);
+
+
+/*******************************************************************************
+* gcosGetPortDefaultTc
+*
+* DESCRIPTION:
+*       Gets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*
+* OUTPUTS:
+*       trafClass - default traffic class of a port.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosGetPortDefaultTc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    OUT GT_U8     *trafClass
+);
+
+
+/*******************************************************************************
+* gqosSetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine sets priority mapping rule.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetPrioMapRule
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gqosGetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine get the priority mapping rule.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetPrioMapRule
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gqosIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the IP priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosIpPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gqosGetIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the IP priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetIpPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *en
+);
+
+
+
+/*******************************************************************************
+* gqosUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the user priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosUserPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gqosGetUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the user priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetUserPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *en
+);
+
+
+
+/*******************************************************************************
+* gcosGetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Gets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+GT_STATUS gcosGetUserPrio2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    userPrior,
+    OUT GT_U8   *trClass
+);
+
+
+/*******************************************************************************
+* gcosSetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Sets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority of a port.
+*       trClass   - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+GT_STATUS gcosSetUserPrio2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8    userPrior,
+    IN GT_U8    trClass
+);
+
+
+/*******************************************************************************
+* gcosGetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine retrieves the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to query.
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+GT_STATUS gcosGetDscp2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8   dscp,
+    OUT GT_U8   *trClass
+);
+
+
+/*******************************************************************************
+* gcosSetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine sets the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to map.
+*       trClass - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+GT_STATUS gcosSetDscp2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8    dscp,
+    IN GT_U8    trClass
+);
+
+
+/*******************************************************************************
+* qdLoadDriver
+*
+* DESCRIPTION:
+*       QuarterDeck Driver Initialization Routine.
+*       This is the first routine that needs be called by system software.
+*       It takes sysCfg from system software, and retures a pointer (*dev)
+*       to a data structure which includes infomation related to this QuarterDeck
+*       device. This pointer (*dev) is then used for all the API functions.
+*
+* INPUTS:
+*       sysCfg      - Holds system configuration parameters.
+*
+* OUTPUTS:
+*       dev         - Holds general system information.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_ALREADY_EXIST    - if device already started
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*     qdUnloadDriver is provided when the driver is not to be used anymore.
+*
+*******************************************************************************/
+GT_STATUS qdLoadDriver
+(
+    IN  GT_SYS_CONFIG   *sysCfg,
+    OUT GT_QD_DEV    *dev
+);
+
+
+/*******************************************************************************
+* qdUnloadDriver
+*
+* DESCRIPTION:
+*       This function unloads the QuaterDeck Driver.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       1.  This function should be called only after successful execution of
+*           qdLoadDriver().
+*
+*******************************************************************************/
+GT_STATUS qdUnloadDriver
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* sysEnable
+*
+* DESCRIPTION:
+*       This function enables the system for full operation.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS sysEnable
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSwReset
+*
+* DESCRIPTION:
+*       This routine preforms switch software reset.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSwReset
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine set the Discard Excessive state.
+*
+* INPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDiscardExcessive
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine get the Discard Excessive state.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDiscardExcessive
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL *en
+);
+
+
+
+/*******************************************************************************
+* gsysSetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine set the Scheduling Mode.
+*
+* INPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetSchedulingMode
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL mode
+);
+
+
+
+/*******************************************************************************
+* gsysGetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine get the Scheduling Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSchedulingMode
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_BOOL *mode
+);
+
+
+
+/*******************************************************************************
+* gsysSetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed.
+*
+* INPUTS:
+*       mode - GT_TRUE max size 1522, GT_FALSE max size 1535.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetMaxFrameSize
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL mode
+);
+
+
+
+/*******************************************************************************
+* gsysGetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Get the max frame size allowed.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE max size 1522, GT_FALSE max size 1535.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMaxFrameSize
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_BOOL *mode
+);
+
+
+
+/*******************************************************************************
+* gsysReLoad
+*
+* DESCRIPTION:
+*       This routine cause to the switch to reload the EEPROM.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysReLoad
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSetWatchDog
+*
+* DESCRIPTION:
+*       This routine Set the the watch dog mode.
+*
+* INPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetWatchDog
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetWatchDog
+*
+* DESCRIPTION:
+*       This routine Get the the watch dog mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetWatchDog
+(
+    IN GT_QD_DEV* dev,
+    OUT GT_BOOL *en
+);
+
+
+/*******************************************************************************
+* gsysSetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets the full duplex pause src Mac Address.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN GT_ETHERADDR *mac
+);
+
+
+/*******************************************************************************
+* gsysGetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets the full duplex pause src Mac Address.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    OUT GT_ETHERADDR *mac
+);
+
+
+
+/*******************************************************************************
+* gsysSetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPerPortDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPerPortDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL *en
+);
+
+/*******************************************************************************
+* gsysSetPortWakeonFrameEn
+*
+* DESCRIPTION:
+*       This routine sets port interrupt for wake on frame.
+*
+* INPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPortWakeonFrameEn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        portVec
+);
+
+/*******************************************************************************
+* gsysGetPortWakeonFrameEnSt
+*
+* DESCRIPTION:
+*       This routine gets port interrupt status for wake on frame.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPortWakeonFrameEnSt
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_U8       *portVec
+);
+
+/*******************************************************************************
+* gsysGetPortWakeonFrameEn
+*
+* DESCRIPTION:
+*       This routine gets port interrupt status for wake on frame.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPortWakeonFrameEn
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_U8       *portVec
+);
+
+/*******************************************************************************
+* gsysSetWoLMac
+*
+* DESCRIPTION:
+*       This routine sets the Wake on Lan Mac Address.
+*        MAC address should be an Unicast address.
+*        For different MAC Addresses per port operation,
+*        use gsysSetPerPortDuplexPauseMac API.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetWoLMac
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+);
+
+/*******************************************************************************
+* gsysGetWoLMac
+*
+* DESCRIPTION:
+*       This routine Gets the Wake on Lan Mac Address.
+*        For different MAC Addresses per port operation,
+*        use gsysGetPerPortDuplexPauseMac API.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetWoLMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+);
+
+/*******************************************************************************
+* gsysSetPerPortWoLMac
+*
+* DESCRIPTION:
+*       This routine sets whether the Wake on Lan Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPerPortWoLMac
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL      en
+);
+
+/*******************************************************************************
+* gsysGetPerPortWoLMac
+*
+* DESCRIPTION:
+*       This routine Gets whether the Wake on Lanc Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPerPortWoLMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetWoLPass
+*
+* DESCRIPTION:
+*       This routine sets the Wake on Lan Password Mac Address.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetWoLPass
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+);
+
+/*******************************************************************************
+* gsysGetWoLPass
+*
+* DESCRIPTION:
+*       This routine Gets the Wake on Lan password Mac Address.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetWoLPass
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+);
+
+/*******************************************************************************
+* gsysReadMiiRegister
+*
+* DESCRIPTION:
+*       This routine reads QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know exactly which phy address(0 ~ 0x1F) will be read.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysReadMiiReg
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_U32    phyAddr,
+    IN  GT_U32    regAddr,
+    OUT GT_U32    *data
+);
+
+/*******************************************************************************
+* gsysWriteMiiRegister
+*
+* DESCRIPTION:
+*       This routine writes QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know exactly which phy address(0 ~ 0x1F) will be read.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*       data    - data to be written.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysWriteMiiReg
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_U32    phyAddr,
+    IN  GT_U32    regAddr,
+    IN  GT_U16    data
+);
+
+#ifdef GT_RMGMT_ACCESS
+/*******************************************************************************
+* gsysAccessMultiRegs
+*
+* DESCRIPTION:
+*       This function accesses switch's registers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1
+*     addr - SMI Address
+*     reg  - Register offset
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysAccessMultiRegs
+(
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+);
+#endif
+
+/*******************************************************************************
+* gsysGetSW_Mode
+*
+* DESCRIPTION:
+*       This routine get the Switch mode. These two bits returen
+*       the current value of the SW_MODE[1:0] pins.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*         This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSW_Mode
+(
+    IN GT_QD_DEV* dev,
+    IN GT_SW_MODE *mode
+);
+
+/*******************************************************************************
+* gsysGetInitReady
+*
+* DESCRIPTION:
+*       This routine get the InitReady bit. This bit is set to a one when the ATU,
+*       the Queue Controller and the Statistics Controller are done with their
+*       initialization and are ready to accept frames.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*         This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetInitReady
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL *mode
+);
+
+
+/*******************************************************************************
+* gstatsFlushAll
+*
+* DESCRIPTION:
+*       Flush All RMON counters for all ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushAll
+(
+    IN GT_QD_DEV* dev
+);
+
+/*******************************************************************************
+* gstatsFlushPort
+*
+* DESCRIPTION:
+*       Flush All RMON counters for a given port.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushPort
+(
+    IN GT_QD_DEV* dev,
+    IN GT_LPORT    port
+);
+
+/*******************************************************************************
+* gstatsGetPortCounter
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS    counter,
+    OUT GT_U32            *statsData
+);
+
+/*******************************************************************************
+* gstatsGetPortAllCounters
+*
+* DESCRIPTION:
+*       This routine gets all RMON counters of the given port
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters
+(
+    IN  GT_QD_DEV* dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET    *statsCounterSet
+);
+
+
+/*******************************************************************************
+* grcSetLimitMode
+*
+* DESCRIPTION:
+*       This routine sets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port    - logical port number.
+*       mode     - rate control ingress limit mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*******************************************************************************/
+GT_STATUS grcSetLimitMode
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT          port,
+    IN GT_RATE_LIMIT_MODE    mode
+);
+
+/*******************************************************************************
+* grcGetLimitMode
+*
+* DESCRIPTION:
+*       This routine gets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       mode     - rate control ingress limit mode.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetLimitMode
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_LPORT port,
+    OUT GT_RATE_LIMIT_MODE    *mode
+);
+
+/*******************************************************************************
+* grcSetPri3Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+GT_STATUS grcSetPri3Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri3Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri3Rate
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri2Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+GT_STATUS grcSetPri2Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri2Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri2Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri1Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+GT_STATUS grcSetPri1Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri1Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri1Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri0Rate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port    - logical port number.
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*             will be discarded after the ingress rate selected is reached
+*             or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcSetPri0Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT        port,
+    IN GT_PRI0_RATE    rate
+);
+
+/*******************************************************************************
+* grcGetPri0Rate
+*
+* DESCRIPTION:
+*       This routine gets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*             will be discarded after the ingress rate selected is reached
+*             or exceeded.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri0Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_PRI0_RATE    *rate
+);
+
+/*******************************************************************************
+* grcSetBytesCount
+*
+* DESCRIPTION:
+*       This routine sets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port      - logical port number to set.
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcSetBytesCount
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT            port,
+    IN GT_BOOL         limitMGMT,
+    IN GT_BOOL         countIFG,
+    IN GT_BOOL         countPre
+);
+
+/*******************************************************************************
+* grcGetBytesCount
+*
+* DESCRIPTION:
+*       This routine gets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port    - logical port number
+*
+* OUTPUTS:
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetBytesCount
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT            port,
+    IN GT_BOOL         *limitMGMT,
+    IN GT_BOOL         *countIFG,
+    IN GT_BOOL         *countPre
+);
+
+/*******************************************************************************
+* grcSetEgressRate
+*
+* DESCRIPTION:
+*       This routine sets the port's egress data limit.
+*
+*
+* INPUTS:
+*       port      - logical port number.
+*       rateType  - egress data rate limit (GT_ERATE_TYPE union type).
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061,
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+GT_STATUS grcSetEgressRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_ERATE_TYPE   *rateType
+);
+
+/*******************************************************************************
+* grcGetEgressRate
+*
+* DESCRIPTION:
+*       This routine gets the port's egress data limit.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       rateType  - egress data rate limit (GT_ERATE_TYPE union type).
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061,
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+GT_STATUS grcGetEgressRate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_ERATE_TYPE  *rateType
+);
+
+
+/*******************************************************************************
+* gpavSetPAV
+*
+* DESCRIPTION:
+*       This routine sets the Port Association Vector
+*
+* INPUTS:
+*       port    - logical port number.
+*       pav     - Port Association Vector
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavSetPAV
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT    port,
+    IN GT_U16    pav
+);
+
+/*******************************************************************************
+* gpavGetPAV
+*
+* DESCRIPTION:
+*       This routine gets the Port Association Vector
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       pav     - Port Association Vector
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavGetPAV
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT GT_U16    *pav
+);
+
+/*******************************************************************************
+* gpavSetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine sets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled
+*              GT_TRUE:  Ingress Monitor disabled
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*******************************************************************************/
+GT_STATUS gpavSetIngressMonitor
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* gpavGetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine gets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled
+*              GT_TRUE:  Ingress Monitor disabled
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavGetIngressMonitor
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* gvctGetCableStatus
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the requested port,
+*       and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvCableDiag
+*        API can be used, instead.
+*
+
+*******************************************************************************/
+GT_STATUS gvctGetCableDiag
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+);
+
+
+/*******************************************************************************
+* gvctGet1000BTExtendedStatus
+*
+* DESCRIPTION:
+*       This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvExtendedStatus
+*        API can be used, instead.
+*
+*
+*******************************************************************************/
+GT_STATUS gvctGet1000BTExtendedStatus
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+);
+
+
+/*******************************************************************************
+* gtMemSet
+*
+* DESCRIPTION:
+*       Set a block of memory
+*
+* INPUTS:
+*       start  - start address of memory block for setting
+*       simbol - character to store, converted to an unsigned char
+*       size   - size of block to be set
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to set memory block
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemSet
+(
+    IN void * start,
+    IN int    symbol,
+    IN GT_U32 size
+);
+
+/*******************************************************************************
+* gtMemCpy
+*
+* DESCRIPTION:
+*       Copies 'size' characters from the object pointed to by 'source' into
+*       the object pointed to by 'destination'. If copying takes place between
+*       objects that overlap, the behavior is undefined.
+*
+* INPUTS:
+*       destination - destination of copy
+*       source      - source of copy
+*       size        - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to destination
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemCpy
+(
+    IN void *       destination,
+    IN const void * source,
+    IN GT_U32       size
+);
+
+
+/*******************************************************************************
+* gtMemCmp
+*
+* DESCRIPTION:
+*       Compares given memories.
+*
+* INPUTS:
+*       src1 - source 1
+*       src2 - source 2
+*       size - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0, if equal.
+*        negative number, if src1 < src2.
+*        positive number, if src1 > src2.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int gtMemCmp
+(
+    IN char src1[],
+    IN char src2[],
+    IN GT_U32 size
+);
+
+/*******************************************************************************
+* gtStrlen
+*
+* DESCRIPTION:
+*       Determine the length of a string
+* INPUTS:
+*       source  - string
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       size    - number of characters in string, not including EOS.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_U32 gtStrlen
+(
+    IN const void * source
+);
+
+/*******************************************************************************
+* gtDelay
+*
+* DESCRIPTION:
+*       Wait for the given uSec and return.
+*        Current Switch devices with Gigabit Ethernet Support require 250 uSec
+*        of delay time for PPU to be disabled.
+*        Since this function is System and/or OS dependent, it should be provided
+*        by each DSDT user.
+*
+* INPUTS:
+*       delayTime - delay in uSec.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void gtDelay
+(
+    IN const unsigned int delayTime
+);
+
+
+/*******************************************************************************
+* gtVersion
+*
+* DESCRIPTION:
+*       This function returns the version of the QuarterDeck SW suite.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       version     - QuarterDeck software version.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_BAD_PARAM on bad parameters,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gtVersion
+(
+    OUT GT_VERSION   *version
+);
+
+
+/* Prototypes added for Gigabit Ethernet Switch Support */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbMove
+*
+* DESCRIPTION:
+*        This routine moves all or unblocked addresses from a port to another.
+*
+* INPUTS:
+*        moveCmd  - the move operation type.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMove
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_MOVE_CMD    moveCmd,
+    IN GT_U32        moveFrom,
+    IN GT_U32        moveTo
+);
+
+/*******************************************************************************
+* gfdbMoveInDB
+*
+* DESCRIPTION:
+*         This routine move all or unblocked addresses which are in the particular
+*         ATU Database (DBNum) from a port to another.
+*
+* INPUTS:
+*         moveCmd  - the move operation type.
+*        DBNum         - ATU MAC Address Database Number.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
+*
+* OUTPUTS:
+*     None
+*
+* RETURNS:
+*         GT_OK           - on success
+*         GT_FAIL         - on error
+*         GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMoveInDB
+(
+    IN GT_QD_DEV   *dev,
+    IN GT_MOVE_CMD moveCmd,
+    IN GT_U32         DBNum,
+    IN GT_U32        moveFrom,
+    IN GT_U32        moveTo
+);
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/*******************************************************************************
+* gatuGetIntStatus
+*
+* DESCRIPTION:
+*        Check to see if a specific type of ATU interrupt occured
+*
+* INPUTS:
+*     intType - the type of interrupt which causes an interrupt.
+*                    GT_MEMEBER_VIOLATION, GT_MISS_VIOLATION, or GT_FULL_VIOLATION
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gatuGetIntStatus
+(
+    IN  GT_QD_DEV                *dev,
+    OUT GT_ATU_INT_STATUS    *atuIntStatus
+);
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtSet1000TMasterMode
+*
+* DESCRIPTION:
+*        This routine set the port multicast rate limit.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_1000T_MASTER_SLAVE    *mode
+);
+
+/*******************************************************************************
+* gprtGet1000TMasterMode
+*
+* DESCRIPTION:
+*        This routine set the port multicast rate limit.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_1000T_MASTER_SLAVE    *mode
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetDropOnLock
+*
+* DESCRIPTION:
+*        This routine set the Drop on Lock. When set to one, Ingress frames will
+*        be discarded if their SA field is not in the ATU's address database.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDropOnLock
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDropOnLock
+*
+* DESCRIPTION:
+*        This routine gets DropOnLock mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: DropOnLock enabled,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDropOnLock
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetDoubleTag
+*
+* DESCRIPTION:
+*        This routine set the Ingress Double Tag Mode. When set to one,
+*        ingressing frames are examined to see if they contain an 802.3ac tag.
+*        If they do, the tag is removed and then the frame is processed from
+*        there (i.e., removed tag is ignored). Essentially, untagged frames
+*        remain untagged, single tagged frames become untagged and double tagged
+*        frames become single tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDoubleTag
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDoubleTag
+*
+* DESCRIPTION:
+*        This routine gets DoubleTag mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: DoubleTag enabled,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDoubleTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetInterswitchPort
+*
+* DESCRIPTION:
+*        This routine set Interswitch Port. When set to one,
+*        it indicates this port is a interswitch port used to communicated with
+*        CPU or to cascade with another switch device.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetInterswitchPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetInterswithPort
+*
+* DESCRIPTION:
+*        This routine gets InterswitchPort.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: This port is interswitch port,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetInterswitchPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetLearnDisable
+*
+* DESCRIPTION:
+*        This routine enables/disables automatic learning of new source MAC
+*        addresses on the given port ingress
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for disable or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLearnDisable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+
+/*******************************************************************************
+* gprtGetLearnDisable
+*
+* DESCRIPTION:
+*        This routine gets LearnDisable setup
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: Learning disabled on the given port ingress frames,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLearnDisable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetIgnoreFCS
+*
+* DESCRIPTION:
+*        This routine sets FCS Ignore mode. When this bit is set to a one,
+*        the last four bytes of frames received on this port are overwritten with
+*        a good CRC and the frames will be accepted by the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreFCS
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL         mode
+);
+
+/*******************************************************************************
+* gprtGetIgnoreFCS
+*
+* DESCRIPTION:
+*        This routine gets Ignore FCS setup
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreFCS
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetVTUPriOverride
+*
+* DESCRIPTION:
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtSetVTUPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_PRI_OVERRIDE        mode
+);
+
+/*******************************************************************************
+* gprtGetVTUPriOverride
+*
+* DESCRIPTION:
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtGetVTUPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PRI_OVERRIDE        *mode
+);
+
+/*******************************************************************************
+* gprtSetSAPriOverride
+*
+* DESCRIPTION:
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtSetSAPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetSAPriOverride
+*
+* DESCRIPTION:
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtGetSAPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
+);
+
+/*******************************************************************************
+* gprtSetDAPriOverride
+*
+* DESCRIPTION:
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtSetDAPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PRI_OVERRIDE        mode
+);
+
+/*******************************************************************************
+* gprtGetDAPriOverride
+*
+* DESCRIPTION:
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtGetDAPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
+);
+
+/*******************************************************************************
+* gprtSetCPUPort
+*
+* DESCRIPTION:
+*        This routine sets CPU Port number. When Snooping is enabled on this port
+*        or when this port is configured as an Interswitch Port and it receives a
+*        To_CPU frame, the switch needs to know what port on this device the frame
+*        should egress.
+*
+* INPUTS:
+*        port - the logical port number.
+*        cpuPort - CPU Port number or interswitch port where CPU Port is connected
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetCPUPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_LPORT     cpuPort
+);
+
+/*******************************************************************************
+* gprtGetCPUPort
+*
+* DESCRIPTION:
+*        This routine gets CPU Logical Port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        cpuPort - CPU Port's logical number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetCPUPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_LPORT     *cpuLPort
+);
+
+/*******************************************************************************
+* gprtSetLockedPort
+*
+* DESCRIPTION:
+*        This routine sets LockedPort. When it's set to one, CPU directed
+*        learning for 802.1x MAC authentication is enabled on this port. In this
+*        mode, an ATU Miss Violation interrupt will occur when a new SA address
+*        is received in a frame on this port. Automatically SA learning and
+*        refreshing is disabled in this mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLockedPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetLockedPort
+*
+* DESCRIPTION:
+*        This routine gets Locked Port mode for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLockedPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
+);
+
+/*******************************************************************************
+* gprtSetIgnoreWrongData
+*
+* DESCRIPTION:
+*        This routine sets Ignore Wrong Data. If the frame's SA address is found
+*        in the database and if the entry is 'static' or if the port is 'locked'
+*        the source port's bit is checked to insure the SA has been assigned to
+*        this port. If the SA is NOT assigned to this port, it is considered an
+*        ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+*        Member Violation interrupt will be generated. If it's set to GT_TRUE,
+*        the ATU Member Violation error will be masked and ignored.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreWrongData
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+
+/*******************************************************************************
+* gprtGetIgnoreWrongData
+*
+* DESCRIPTION:
+*        This routine gets Ignore Wrong Data mode for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreWrongData
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+);
+
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+* gstatsGetPortCounter2
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter2
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS2    counter,
+    OUT GT_U32            *statsData
+);
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters2
+*
+* DESCRIPTION:
+*        This routine gets all counters of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters2
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET2    *statsCounterSet
+);
+
+/*******************************************************************************
+* gstatsGetHistogramMode
+*
+* DESCRIPTION:
+*        This routine gets the Histogram Counters Mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY,
+*                    and GT_COUNT_RX_TX)
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetHistogramMode
+(
+    IN  GT_QD_DEV                *dev,
+    OUT GT_HISTOGRAM_MODE    *mode
+);
+
+/*******************************************************************************
+* gstatsSetHistogramMode
+*
+* DESCRIPTION:
+*        This routine sets the Histogram Counters Mode.
+*
+* INPUTS:
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY,
+*                    and GT_COUNT_RX_TX)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsSetHistogramMode
+(
+    IN GT_QD_DEV                 *dev,
+    IN GT_HISTOGRAM_MODE        mode
+);
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetPauseEn
+*
+* DESCRIPTION:
+*        This routine retrives the link pause state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        If set MAC Pause (for Full Duplex flow control) is implemented in the
+*        link partner and in MyPause
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPauseEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *state
+);
+
+/*******************************************************************************
+* gprtGetHdFlow
+*
+* DESCRIPTION:
+*        This routine retrives the half duplex flow control value.
+*        If set, Half Duplex back pressure will be used on this port if this port
+*        is in a half duplex mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHdFlow
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL     *state
+);
+
+/*******************************************************************************
+* gprtGetPHYDetect
+*
+* DESCRIPTION:
+*        This routine retrives the information regarding PHY detection.
+*        If set, An 802.3 PHY is attached to this port.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if connected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPHYDetect
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL     *state
+);
+
+/*******************************************************************************
+* gprtSetPHYDetect
+*
+* DESCRIPTION:
+*        This routine sets PHYDetect bit which make PPU change its polling.
+*        PPU's pool routine uses these bits to determine which port's to poll
+*        PHYs on for Link, Duplex, Speed, and Flow Control.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        This function should not be called if gsysGetPPUState returns
+*        PPU_STATE_ACTIVE.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPHYDetect
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      state
+);
+
+/*******************************************************************************
+* gprtGetSpeedMode
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_PORT_SPEED_MODE type.
+*                    (PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, or PORT_SPEED_10_MBPS)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSpeedMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_PORT_SPEED_MODE   *speed
+);
+
+/*******************************************************************************
+* gprtGetHighErrorRate
+*
+* DESCRIPTION:
+*        This routine retrives the PCS High Error Rate.
+*        This routine returns GT_TRUE if the rate of invalid code groups seen by
+*        PCS has exceeded 10 to the power of -11.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHighErrorRate
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetTxPaused
+*
+* DESCRIPTION:
+*        This routine retrives Transmit Pause state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTxPaused
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+
+/*******************************************************************************
+* gprtGetFlowCtrl
+*
+* DESCRIPTION:
+*        This routine retrives Flow control state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Rx MAC determines that no more data should be
+*                    entering this port.
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFlowCtrl
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetC_Duplex
+*
+* DESCRIPTION:
+*        This routine retrives Port 9's duplex configuration mode determined
+*        at reset.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if configured as Full duplex operation
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetC_Duplex
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetC_Mode
+*
+* DESCRIPTION:
+*        This routine retrives port's interface type configuration mode
+*        determined at reset.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - one of value in GT_PORT_CONFIG_MODE enum type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetC_Mode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PORT_CONFIG_MODE   *state
+);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetPPUEn
+*
+* DESCRIPTION:
+*        This routine enables/disables Phy Polling Unit.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPPUEn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
+);
+
+/*******************************************************************************
+* gsysGetPPUEn
+*
+* DESCRIPTION:
+*        This routine get the PPU state.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPPUEn
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetCascadePort
+*
+* DESCRIPTION:
+*        This routine sets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
+*
+* INPUTS:
+*        port - Cascade Port
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetCascadePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* gsysGetCascadePort
+*
+* DESCRIPTION:
+*        This routine gets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - Cascade Port
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetCascadePort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
+);
+
+/*******************************************************************************
+* gsysSetDeviceNumber
+*
+* DESCRIPTION:
+*        This routine sets Device Number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip. From CPU frames whose Dev_Num
+*        fieldmatches these bits have reachedtheir destination chip and are sent
+*        out this chip using the port number indicated in the frame's Trg_Port
+*        field.
+*
+* INPUTS:
+*        devNum - Device Number (0 ~ 31)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDeviceNumber
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          devNum
+);
+
+/*******************************************************************************
+* gsysGetDeviceNumber
+*
+* DESCRIPTION:
+*        This routine gets Device Number.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        devNum - Device Number (0 ~ 31)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDeviceNumber
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32      *devNum
+);
+
+
+/* gtPCSCtrl.c */
+
+
+/*******************************************************************************
+* gpcsGetCommaDet
+*
+* DESCRIPTION:
+*        This routine retrieves Comma Detection status in PCS
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetCommaDet
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsGetSyncOK
+*
+* DESCRIPTION:
+*        This routine retrieves SynOK bit. It is set to a one when the PCS has
+*        detected a few comma patterns and is synchronized with its peer PCS
+*        layer.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if synchronized or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetSyncOK
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsGetSyncFail
+*
+* DESCRIPTION:
+*        This routine retrieves SynFail bit.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetSyncFail
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsGetAnBypassed
+*
+* DESCRIPTION:
+*        This routine retrieves Inband Auto-Negotiation bypass status.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetAnBypassed
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsGetAnBypassMode
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetAnBypassMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
+);
+
+/*******************************************************************************
+* gpcsSetAnBypassMode
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetAnBypassMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+);
+
+/*******************************************************************************
+* gpcsGetPCSAnEn
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSAnEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
+);
+
+/*******************************************************************************
+* gpcsSetPCSAnEn
+*
+* DESCRIPTION:
+*        This routine sets Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetPCSAnEn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+);
+
+/*******************************************************************************
+* gpcsSetRestartPCSAn
+*
+* DESCRIPTION:
+*        This routine restarts PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetRestartPCSAn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* gpcsGetPCSAnDone
+*
+* DESCRIPTION:
+*        This routine retrieves completion information of PCS Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if PCS AN is done or never done
+*                GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSAnDone
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
+);
+
+/*******************************************************************************
+* gpcsSetLinkValue
+*
+* DESCRIPTION:
+*        This routine sets Link's force value
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force link up, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetLinkValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetLinkValue
+*
+* DESCRIPTION:
+*        This routine retrieves Link Value which will be used for Forcing Link
+*        up or down.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Link Force value is one (link up)
+*                 GT_FALSE otherwise (link down)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetLinkValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetForcedLink
+*
+* DESCRIPTION:
+*        This routine forces Link. If LinkValue is set to one, calling this
+*        routine with GT_TRUE will force Link to be up.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force link (up or down), GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedLink
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetForcedLink
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Link bit
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedLink bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedLink
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetDpxValue
+*
+* DESCRIPTION:
+*        This routine sets Duplex's Forced value. This function needs to be
+*        called prior to gpcsSetForcedDpx.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force full duplex, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetDpxValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetDpxValue
+*
+* DESCRIPTION:
+*        This routine retrieves Duplex's Forced value
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Duplex's Forced value is set to Full duplex,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetDpxValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetForcedDpx
+*
+* DESCRIPTION:
+*        This routine forces duplex mode. If DpxValue is set to one, calling this
+*        routine with GT_TRUE will force duplex mode to be full duplex.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force duplex mode, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedDpx
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetForcedDpx
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Duplex.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedDpx bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedDpx
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetForceSpeed
+*
+* DESCRIPTION:
+*        This routine forces speed.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or No Speed Force)
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForceSpeed
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_PORT_FORCED_SPEED_MODE  mode
+);
+
+/*******************************************************************************
+* gpcsGetForceSpeed
+*
+* DESCRIPTION:
+*        This routine retrieves Force Speed value
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForceSpeed
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PORT_FORCED_SPEED_MODE   *mode
+);
+
+
+
+/* gtQosMap.c */
+
+/*******************************************************************************
+* gqosGetTagRemap
+*
+* DESCRIPTION:
+*        Gets the remapped priority value for a specific 802.1p priority on a
+*        given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*        pri   - 802.1p priority
+*
+* OUTPUTS:
+*        remappedPri - remapped Priority
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetTagRemap
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U8        pri,
+    OUT GT_U8       *remappedPri
+);
+
+/*******************************************************************************
+* gqosSetTagRemap
+*
+* DESCRIPTION:
+*        Sets the remapped priority value for a specific 802.1p priority on a
+*        given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*        pri   - 802.1p priority
+*        remappedPri - remapped Priority
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetTagRemap
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_U8        pri,
+    IN GT_U8        remappedPri
+);
+
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+/*******************************************************************************
+* gsysGetPPUState
+*
+* DESCRIPTION:
+*        This routine get the PPU State. These two bits return
+*        the current value of the PPU.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - GT_PPU_STATE
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPPUState
+(
+    IN  GT_QD_DEV       *dev,
+    OUT GT_PPU_STATE    *mode
+);
+
+
+/* Prototypes added for 88E6093 */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbGetLearn2All
+*
+* DESCRIPTION:
+*        When more than one Marvell device is used to form a single 'switch', it
+*        may be desirable for all devices in the 'switch' to learn any address this
+*        device learns. When this bit is set to a one all other devices in the
+*        'switch' learn the same addresses this device learns. When this bit is
+*        cleared to a zero, only the devices that actually receive frames will learn
+*        from those frames. This mode typically supports more active MAC addresses
+*        at one time as each device in the switch does not need to learn addresses
+*        it may nerver use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetLearn2All
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *mode
+);
+
+/*******************************************************************************
+* gfdbSetLearn2All
+*
+* DESCRIPTION:
+*        Enable or disable Learn2All mode.
+*
+* INPUTS:
+*        mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetLearn2All
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gfdbRemovePort
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port.
+*
+* INPUTS:
+*       moveCmd - the move operation type.
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbRemovePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gfdbRemovePortInDB
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port in the
+*       particular ATU Database (DBNum).
+*
+* INPUTS:
+*       moveCmd  - the move operation type.
+*       port - the logical port number.
+*        DBNum     - ATU MAC Address Database Number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbRemovePortInDB
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port,
+    IN GT_U32         DBNum
+);
+
+
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/* gtPCSCtrl.c */
+
+/*******************************************************************************
+* gpcsGetPCSLink
+*
+* DESCRIPTION:
+*        This routine retrieves Link up status in PCS
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSLink
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetFCValue
+*
+* DESCRIPTION:
+*        This routine sets Flow Control's force value
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetFCValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetFCValue
+*
+* DESCRIPTION:
+*        This routine retrieves Flow Control Value which will be used for Forcing
+*        Flow Control enabled or disabled.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if FC Force value is one (flow control enabled)
+*                 GT_FALSE otherwise (flow control disabled)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetFCValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gpcsSetForcedFC
+*
+* DESCRIPTION:
+*        This routine forces Flow Control. If FCValue is set to one, calling this
+*        routine with GT_TRUE will force Flow Control to be enabled.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedFC
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+);
+
+/*******************************************************************************
+* gpcsGetForcedFC
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Flow Control bit
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedFC bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedFC
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtGetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*        port     - port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*
+* OUTPUTS:
+*        data    - value of the read register
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtGetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
+    OUT GT_U16* data
+);
+
+/*******************************************************************************
+* gprtSetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*        port     - port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*        data    - value of the read register
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtSetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
+    IN  GT_U16 data
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetUseCoreTag
+*
+* DESCRIPTION:
+*       This routine set the UseCoreTag bit in Port Control Register.
+*            When this bit is cleared to a zero, ingressing frames are considered
+*            Tagged if the 16-bits following the frame's Source Address is 0x8100.
+*            When this bit is set to a one, ingressing frames are considered Tagged
+*            if the 16-bits following the frame's Source Address is equal to the
+*            CoreTag register value.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetUseCoreTag
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    force
+);
+
+/*******************************************************************************
+* gprtGetUseCoreTag
+*
+* DESCRIPTION:
+*       This routine get the Use Core Tag state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetUseCoreTag
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *force
+);
+
+/*******************************************************************************
+* gprtSetDiscardTagged
+*
+* DESCRIPTION:
+*        When this bit is set to a one, all non-MGMT frames that are processed as
+*        Tagged will be discarded as they enter this switch port. Priority only
+*        tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardTagged
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDiscardTagged
+*
+* DESCRIPTION:
+*        This routine gets DiscardTagged bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardTagged
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetDiscardUntagged
+*
+* DESCRIPTION:
+*        When this bit is set to a one, all non-MGMT frames that are processed as
+*        Untagged will be discarded as they enter this switch port. Priority only
+*        tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardUntagged
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDiscardUntagged
+*
+* DESCRIPTION:
+*        This routine gets DiscardUntagged bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardUntagged
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetMapDA
+*
+* DESCRIPTION:
+*        When this bit is set to a one, normal switch operation will occur where a
+*        frame's DA address is used to direct the frame out the correct port.
+*        When this be is cleared to a zero, the frame will be sent out the port(s)
+*        defined by ForwardUnknown bits or the DefaultForward bits even if the DA
+*        is ound in the address database.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMapDA
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetMapDA
+*
+* DESCRIPTION:
+*        This routine gets MapDA bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMapDA
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetDefaultForward
+*
+* DESCRIPTION:
+*        When this bit is set to a one, normal switch operation will occurs and
+*        multicast frames with unknown DA addresses are allowed to egress out this
+*        port (assuming the VLAN settings allow the frame to egress this port too).
+*        When this be is cleared to a zero, multicast frames with unknown DA
+*        addresses will not egress out this port.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDefaultForward
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDefaultForward
+*
+* DESCRIPTION:
+*        This routine gets DefaultForward bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDefaultForward
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetEgressMonitorSource
+*
+* DESCRIPTION:
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressMonitorSource
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetEgressMonitorSource
+*
+* DESCRIPTION:
+*        This routine gets EgressMonitorSource bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressMonitorSource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+);
+
+/*******************************************************************************
+* gprtSetIngressMonitorSource
+*
+* DESCRIPTION:
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIngressMonitorSource
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetIngressMonitorSource
+*
+* DESCRIPTION:
+*        This routine gets IngressMonitorSource bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIngressMonitorSource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+);
+
+
+/* gtPortPAV.c */
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+* gstatsGetPortCounter3
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter3
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT GT_U32            *statsData
+);
+
+/*******************************************************************************
+* gstatsGetPortAllCounters3
+*
+* DESCRIPTION:
+*        This routine gets all counters of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters3
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET3    *statsCounterSet
+);
+
+
+/* gtPortStat.c */
+
+/*******************************************************************************
+* gprtGetPortCtr2
+*
+* DESCRIPTION:
+*       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortCtr2
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT2   *ctr
+);
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetMGMII
+*
+* DESCRIPTION:
+*        SERDES Interface mode. When this bit is cleared to a zero and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be MGMII. When no PHY is detected on this port and the
+*        SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMGMII
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtSetMGMII
+*
+* DESCRIPTION:
+*        SERDES Interface mode. When this bit is cleared to a zero and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be MGMII. When no PHY is detected on this port and the
+*        SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMGMII
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      state
+);
+
+
+/* gtQosMap.c */
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetCoreTagType
+*
+* DESCRIPTION:
+*        This routine sets Ether Core Tag Type.
+*        This Ether Type is added to frames that egress the switch as Double Tagged
+*        frames. It is also the Ether Type expected during Ingress to determine if
+*        a frame is Tagged or not on ports configured as UseCoreTag mode.
+*
+* INPUTS:
+*        etherType - Core Tag Type (2 bytes)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetCoreTagType
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16          etherType
+);
+
+/*******************************************************************************
+* gsysGetCoreTagType
+*
+* DESCRIPTION:
+*        This routine gets CoreTagType
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        etherType - Core Tag Type (2 bytes)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetCoreTagType
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *etherType
+);
+
+/*******************************************************************************
+* gsysSetIngressMonitorDest
+*
+* DESCRIPTION:
+*        This routine sets Ingress Monitor Destination Port. Frames that are
+*        targeted toward an Ingress Monitor Destination go out the port number
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Ingress Monitor type, and frames received on a Network port that
+*        is enabled to be the Ingress Monitor Source Port.
+*        If the Ingress Monitor Destination Port resides in this device these bits
+*        should point to the Network port where these frames are to egress. If the
+*        Ingress Monitor Destination Port resides in another device these bits
+*        should point to the Marvell Tag port in this device that is used to get
+*        to the device that contains the Ingress Monitor Destination Port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetIngressMonitorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetIngressMonitorDest
+*
+* DESCRIPTION:
+*        This routine gets Ingress Monitor Destination Port.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetIngressMonitorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+/*******************************************************************************
+* gsysSetEgressMonitorDest
+*
+* DESCRIPTION:
+*        This routine sets Egress Monitor Destination Port. Frames that are
+*        targeted toward an Egress Monitor Destination go out the port number
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Egress Monitor type, and frames transmitted on a Network port that
+*        is enabled to be the Egress Monitor Source Port.
+*        If the Egress Monitor Destination Port resides in this device these bits
+*        should point to the Network port where these frames are to egress. If the
+*        Egress Monitor Destination Port resides in another device these bits
+*        should point to the Marvell Tag port in this device that is used to get
+*        to the device that contains the Egress Monitor Destination Port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetEgressMonitorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetEgressMonitorDest
+*
+* DESCRIPTION:
+*        This routine gets Egress Monitor Destination Port.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetEgressMonitorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+
+/* functions added on rev 2.2 */
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetMessagePort
+*
+* DESCRIPTION:
+*        When the Learn2All bit is set to one, learning message frames are
+*        generated. These frames will be sent out all ports whose Message Port is
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports,
+*        except for the CPU's port, have their MessagePort bit set to one.
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMessagePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetMessagePort
+*
+* DESCRIPTION:
+*        When the Learn2All bit is set to one, learning message frames are
+*        generated. These frames will be sent out all ports whose Message Port is
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports,
+*        except for the CPU's port, have their MessagePort bit set to one.
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMessagePort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+);
+
+
+/*******************************************************************************
+* gprtSetTrunkPort
+*
+* DESCRIPTION:
+*        This function enables/disables and sets the trunk ID.
+*
+* INPUTS:
+*        port - the logical port number.
+*        en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+*             GT_FALSE, otherwise.
+*        trunkId - valid ID is 0 ~ 15.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetTrunkPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL         en,
+    IN GT_U32        trunkId
+);
+
+
+/*******************************************************************************
+* gprtGetTrunkPort
+*
+* DESCRIPTION:
+*        This function returns trunk state of the port.
+*        When trunk is disabled, trunkId field won't have valid value.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        en - GT_TRUE, if the port is a member of a trunk,
+*             GT_FALSE, otherwise.
+*        trunkId - 0 ~ 15, valid only if en is GT_TRUE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTrunkPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    OUT GT_BOOL     *en,
+    OUT GT_U32        *trunkId
+);
+
+/*******************************************************************************
+* gprtGetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global 2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobal2Reg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobal2Reg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
+);
+
+/*******************************************************************************
+* gprtGetGlobal3Reg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global 3 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobal3Reg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetGlobal3Reg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global3 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobal3Reg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
+);
+
+/* gtSysCtrl.c */
+/*******************************************************************************
+* gsysSetARPDest
+*
+* DESCRIPTION:
+*        This routine sets ARP Monitor Destination Port. Tagged or untagged
+*        frames that ingress Network ports with the Broadcast Destination Address
+*        and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest
+*        should point to the port that directs these frames to the switch's CPU
+*        that will process ARPs. This target port should be a Marvell Tag port so
+*        that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+*        To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell
+*        Tag port will be sent to the port number definded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP
+*        frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetARPDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetARPDest
+*
+* DESCRIPTION:
+*        This routine gets ARP Monitor Destination Port. Tagged or untagged
+*        frames that ingress Network ports with the Broadcast Destination Address
+*        and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest
+*        should point to the port that directs these frames to the switch's CPU
+*        that will process ARPs. This target port should be a Marvell Tag port so
+*        that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+*        To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell
+*        Tag port will be sent to the port number definded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP
+*        frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetARPDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+/*******************************************************************************
+* gsysSetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*        Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with
+*        en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this
+*        enBits(or register) are also set to a one, are treated as MGMT frames.
+*        All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0,
+*        bit 0 of this register is tested. When x = 0x2, bit 2 of this field is
+*        tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2CpuEnables
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        enBits
+);
+
+/*******************************************************************************
+* gsysGetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*        Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with
+*        en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this
+*        enBits(or register) are also set to a one, are treated as MGMT frames.
+*        All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0,
+*        bit 0 of this register is tested. When x = 0x2, bit 2 of this field is
+*        tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2CpuEnables
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *enBits
+);
+
+/*******************************************************************************
+* gsysSetRsvd2Cpu
+*
+* DESCRIPTION:
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN
+*        membership, will be considered MGMT frames and sent to the port's CPU
+*        Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable
+*        function) for the frames's DA is also set to a one.
+*
+* INPUTS:
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2Cpu
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetRsvd2Cpu
+*
+* DESCRIPTION:
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN
+*        membership, will be considered MGMT frames and sent to the port's CPU
+*        Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable
+*        function) for the frames's DA is also set to a one.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2Cpu
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetMGMTPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetMGMTPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
+);
+
+/*******************************************************************************
+* gsysGetMGMTPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMGMTPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
+);
+
+/*******************************************************************************
+* gsysSetUseDoubleTagData
+*
+* DESCRIPTION:
+*        This bit is used to determine if Double Tag data that is removed from a
+*        Double Tag frame is used or ignored when making switching decisions on
+*        the frame.
+*
+* INPUTS:
+*        en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetUseDoubleTagData
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetUseDoubleTagData
+*
+* DESCRIPTION:
+*        This bit is used to determine if Double Tag data that is removed from a
+*        Double Tag frame is used or ignored when making switching decisions on
+*        the frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetUseDoubleTagData
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetPreventLoops
+*
+* DESCRIPTION:
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev
+*        field equals this device's Device Number, the following action will be
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original
+*                        source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetPreventLoops
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetPreventLoops
+*
+* DESCRIPTION:
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev
+*        field equals this device's Device Number, the following action will be
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original
+*                        source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPreventLoops
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetFlowControlMessage
+*
+* DESCRIPTION:
+*        When this bit is set to one, Marvell Tag Flow Control messages will be
+*        generated when an output queue becomes congested and received Marvell Tag
+*        Flow Control messages will pause MACs inside this device. When this bit
+*        is cleared to a zero, Marvell Tag Flow Control messages will not be
+*        generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFlowControlMessage
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetFlowControlMessage
+*
+* DESCRIPTION:
+*        When this bit is set to one, Marvell Tag Flow Control messages will be
+*        generated when an output queue becomes congested and received Marvell Tag
+*        Flow Control messages will pause MACs inside this device. When this bit
+*        is cleared to a zero, Marvell Tag Flow Control messages will not be
+*        generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowControlMessage
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetForceFlowControlPri
+*
+* DESCRIPTION:
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag
+*        Flow Control frames will be set to the value of the FC Pri bits (set by
+*        gsysSetFCPri function call). When this bit is cleared to a zero, generated
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the
+*        frames that caused the congestion. This bit will have no effect if the
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is
+*        cleared to a zero.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetForceFlowControlPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetForceFlowControlPri
+*
+* DESCRIPTION:
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag
+*        Flow Control frames will be set to the value of the FC Pri bits (set by
+*        gsysSetFCPri function call). When this bit is cleared to a zero, generated
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the
+*        frames that caused the congestion. This bit will have no effect if the
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is
+*        cleared to a zero.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetForceFlowControlPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetFCPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFCPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
+);
+
+/*******************************************************************************
+* gsysGetFCPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFCPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
+);
+
+/*******************************************************************************
+* gsysSetFlowCtrlDelay
+*
+* DESCRIPTION:
+*        This function sets Flow control delay time for 10Mbps, 100Mbps, and
+*        1000Mbps.
+*
+* INPUTS:
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*        delayTime - actual delay time will be (this value x 2.048uS).
+*                    the value cannot exceed 0x1FFF (or 8191 in decimal).
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetFlowCtrlDelay
+(
+    IN GT_QD_DEV            *dev,
+    IN GT_PORT_SPEED_MODE    sp,
+    IN GT_U32                delayTime
+);
+
+/*******************************************************************************
+* gsysGetFlowCtrlDelay
+*
+* DESCRIPTION:
+*        This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+*        1000Mbps.
+*
+* INPUTS:
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*
+* OUTPUTS:
+*        delayTime - actual delay time will be (this value x 2.048uS).
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowCtrlDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_PORT_SPEED_MODE    sp,
+    OUT GT_U32        *delayTime
+);
+
+/*******************************************************************************
+* gsysSetDevRoutingTable
+*
+* DESCRIPTION:
+*        This function sets Device to Port mapping (which device is connected to
+*        which port of this device).
+*
+* INPUTS:
+*        devNum - target device number.
+*        portNum - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if devNum >= 32 or port >= total number of ports.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDevRoutingTable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          devNum,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* gsysGetDevRoutingTable
+*
+* DESCRIPTION:
+*        This function gets Device to Port mapping (which device is connected to
+*        which port of this device).
+*
+* INPUTS:
+*        devNum - target device number.
+*
+* OUTPUTS:
+*        portNum - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if devNum >= 32
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDevRoutingTable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         devNum,
+    OUT GT_LPORT     *port
+);
+
+/*******************************************************************************
+* gsysSetTrunkMaskTable
+*
+* DESCRIPTION:
+*        This function sets Trunk mask vector table for load balancing.
+*        This vector will be AND'ed with where the frame was originally egressed to.
+*        To insure all trunks are load balanced correctly, the data in this table
+*        needs to be correctly configured.
+*
+* INPUTS:
+*        trunkNum - one of the eight Trunk mask vectors.
+*        trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7 or trunMask > 0x7FF (or port vector).
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkMaskTable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          trunkNum,
+    IN GT_U32        trunkMask
+);
+
+/*******************************************************************************
+* gsysGetTrunkMaskTable
+*
+* DESCRIPTION:
+*        This function sets Trunk mask vector table for load balancing.
+*        This vector will be AND'ed with where the frame was originally egressed to.
+*        To insure all trunks are load balanced correctly, the data in this table
+*        needs to be correctly configured.
+*
+* INPUTS:
+*        trunkNum - one of the eight Trunk mask vectors.
+*
+* OUTPUTS:
+*        trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkMaskTable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         trunkNum,
+    OUT GT_U32        *trunkMask
+);
+
+/*******************************************************************************
+* gsysSetHashTrunk
+*
+* DESCRIPTION:
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks.
+*        When this bit is set to a one, the hashed computed for address table
+*        lookups is used for the TrunkMask selection. When this bit is cleared to
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to
+*        select the TrunkMask to use.
+*
+* INPUTS:
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetHashTrunk
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetHashTrunk
+*
+* DESCRIPTION:
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks.
+*        When this bit is set to a one, the hashed computed for address table
+*        lookups is used for the TrunkMask selection. When this bit is cleared to
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to
+*        select the TrunkMask to use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetHashTrunk
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetTrunkRouting
+*
+* DESCRIPTION:
+*        This function sets routing information for the given Trunk ID.
+*
+* INPUTS:
+*        trunkId - Trunk ID.
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF or trunkRoute > 0x7FF(or port vector).
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkRouting
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          trunkId,
+    IN GT_U32        trunkRoute
+);
+
+/*******************************************************************************
+* gsysGetTrunkRouting
+*
+* DESCRIPTION:
+*        This function retrieves routing information for the given Trunk ID.
+*
+* INPUTS:
+*        trunkId - Trunk ID.
+*
+* OUTPUTS:
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkRouting
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         trunkId,
+    OUT GT_U32        *trunkRoute
+);
+
+
+
+/* Prototype added for 88E6095 Rev 1 or Rev 2 */
+
+/* gtPortCtrl.c */
+/*******************************************************************************
+* gprtGetDiscardBCastMode
+*
+* DESCRIPTION:
+*       This routine gets the Discard Broadcast Mode. If the mode is enabled,
+*        all the broadcast frames to the given port will be discarded.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardBCastMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gprtSetDiscardBCastMode
+*
+* DESCRIPTION:
+*       This routine sets the Discard Broadcast mode.
+*        If the mode is enabled, all the broadcast frames to the given port will
+*        be discarded.
+*
+* INPUTS:
+*       port - logical port number
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardBCastMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      en
+);
+
+/*******************************************************************************
+* gprtGetFCOnRateLimitMode
+*
+* DESCRIPTION:
+*       This routine returns mode that tells if ingress rate limiting uses Flow
+*        Control. When this mode is enabled and the port receives frames over the
+*        limit, Ingress Rate Limiting will be performed by stalling the
+*        link partner using flow control, instead of discarding frames.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        en - GT_TRUE, if the mode is enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFCOnRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gprtSetFCOnRateLimitMode
+*
+* DESCRIPTION:
+*       This routine sets the mode that tells if ingress rate limiting uses Flow
+*        Control. When this mode is enabled and the port receives frames over the
+*        limit, Ingress Rate Limiting will be performed by stalling the
+*        link partner using flow control, instead of discarding frames.
+*
+* INPUTS:
+*       port - logical port number
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetFCOnRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      en
+);
+
+
+/* gtPortRateCtrl.c */
+
+/*******************************************************************************
+* grcSetBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*       bsize    - burst size.
+*       rate    - ingress data rate limit. These frames will be discarded after
+*                the ingress rate selected is reached or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*                                Minimum rate for Burst Size 24K byte is 128Kbps
+*                                Minimum rate for Burst Size 48K byte is 256Kbps
+*                                Minimum rate for Burst Size 96K byte is 512Kbps
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetBurstRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_BURST_SIZE   bsize,
+    IN GT_BURST_RATE   rate
+);
+
+/*******************************************************************************
+* grcGetBurstRate
+*
+* DESCRIPTION:
+*       This routine retrieves the port's ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       bsize    - burst size.
+*       rate    - ingress data rate limit. These frames will be discarded after
+*                the ingress rate selected is reached or exceeded.
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetBurstRate
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BURST_SIZE   *bsize,
+    OUT GT_BURST_RATE   *rate
+);
+
+
+/*******************************************************************************
+* grcSetTCPBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's TCP/IP ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*       rate    - ingress data rate limit for TCP/IP packets. These frames will
+*                be discarded after the ingress rate selected is reached or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*                                Valid rate is GT_BURST_NO_LIMIT, or between
+*                                64Kbps and 1500Kbps.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetTCPBurstRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_BURST_RATE   rate
+);
+
+
+/*******************************************************************************
+* grcGetTCPBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's TCP/IP ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for TCP/IP packets. These frames will
+*                be discarded after the ingress rate selected is reached or exceeded.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_VALUE        - register value is not known
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetTCPBurstRate
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BURST_RATE   *rate
+);
+
+
+/* gtSysCtrl.c */
+/*******************************************************************************
+* gsysSetRateLimitMode
+*
+* DESCRIPTION:
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine sets which mode to use.
+*
+* INPUTS:
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid mode is used.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRateLimitMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_INGRESS_RATE_MODE mode
+);
+
+/*******************************************************************************
+* gsysGetRateLimitMode
+*
+* DESCRIPTION:
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine gets which mode is being used.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_INGRESS_RATE_MODE *mode
+);
+
+/*******************************************************************************
+* gsysSetAgeInt
+*
+* DESCRIPTION:
+*        Enable/Disable Age Refresh Interrupt. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*
+*
+* INPUTS:
+*        en - GT_TRUE, to enable,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetAgeInt
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetAgeInt
+*
+* DESCRIPTION:
+*        Get state of Age Refresh Interrupt mode. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetAgeInt
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
+);
+
+
+/* For Zephyr */
+
+/* gtPhyCtrl.c */
+/*******************************************************************************
+* gprtGetPhyLinkStatus
+*
+* DESCRIPTION:
+*       This routine retrieves the Link status.
+*
+* INPUTS:
+*         port     - The logical port number
+*
+* OUTPUTS:
+*       linkStatus - GT_FALSE if link is not established,
+*                     GT_TRUE if link is established.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyLinkStatus
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
+);
+
+
+/*******************************************************************************
+* gprtSetPktGenEnable
+*
+* DESCRIPTION:
+*       This routine enables or disables Packet Generator.
+*       Link should be established first prior to enabling the packet generator,
+*       and generator will generate packets at the speed of the established link.
+*        When enables packet generator, the following information should be
+*       provided:
+*           Payload Type:  either Random or 5AA55AA5
+*           Packet Length: either 64 or 1514 bytes
+*           Error Packet:  either Error packet or normal packet
+*
+* INPUTS:
+*         port     - The logical port number
+*       en      - GT_TRUE to enable, GT_FALSE to disable
+*       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
+*                 ignored, if en is GT_FALSE
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPktGenEnable
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   en,
+    IN GT_PG     *pktInfo
+);
+
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetForceSnoopPri
+*
+* DESCRIPTION:
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*       Priority is enabled. When it's disabled, the priority on these frames
+*        is not modified.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetForceSnoopPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetForceSnoopPri
+*
+* DESCRIPTION:
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*       Priority is enabled. When it's disabled, the priority on these frames
+*        is not modified.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetForceSnoopPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+
+/*******************************************************************************
+* gsysSetSnoopPri
+*
+* DESCRIPTION:
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetSnoopPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
+);
+
+
+/*******************************************************************************
+* gsysGetSnoopPri
+*
+* DESCRIPTION:
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSnoopPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
+);
+
+
+/*******************************************************************************
+* gsysSetForceARPPri
+*
+* DESCRIPTION:
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri
+*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's
+*       disabled, the priority on these frames is not modified.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetForceARPPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetForceARPPri
+*
+* DESCRIPTION:
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri
+*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's
+*       disabled, the priority on these frames is not modified.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetForceARPPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+
+/*******************************************************************************
+* gsysSetARPPri
+*
+* DESCRIPTION:
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on ARP frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetARPPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
+);
+
+
+/*******************************************************************************
+* gsysGetARPPri
+*
+* DESCRIPTION:
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on ARP frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetARPPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
+);
+
+
+/* added for 88E6065 */
+
+/* gtBrgVlan.c */
+
+/********************************************************************
+* gvlnSetForceMap
+*
+* DESCRIPTION:
+*       This routine enables/disables Force Map feature.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode    - GT_TRUE, to enable force map feature
+*                 GT_FAULSE, otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetForceMap
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      mode
+);
+
+
+/********************************************************************
+* gvlnGetForceMap
+*
+* DESCRIPTION:
+*       This routine checks if Force Map feature is enabled.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*
+* OUTPUTS:
+*       mode    - GT_TRUE, to enable force map feature
+*                 GT_FAULSE, otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetForceMap
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
+);
+
+/* gtEvents.c */
+
+/*******************************************************************************
+* geventSetAgeIntEn
+*
+* DESCRIPTION:
+*        This routine enables/disables Age Interrupt for a port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort)
+*        and the ingressing frame's SA is contained in the ATU as a non-Static
+*        entry with a EntryState less than 0x4.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventSetAgeIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* geventGetAgeIntEn
+*
+* DESCRIPTION:
+*        This routine gets Age Interrupt Enable for the port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort)
+*        and the ingressing frame's SA is contained in the ATU as a non-Static
+*        entry with a EntryState less than 0x4.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventGetAgeIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+
+/* gtPIRL.c */
+
+/*******************************************************************************
+* gpirlActivate
+*
+* DESCRIPTION:
+*       This routine activates Ingress Rate Limiting for the given ports by
+*        initializing a resource bucket, assigning ports, and configuring
+*        Bucket Parameters.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*       portVec  - the list of ports that share the bucket.
+*        pirlData - PIRL resource parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlActivate
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec,
+    IN  GT_PIRL_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirlDeactivate
+*
+* DESCRIPTION:
+*       This routine deactivates Ingress Rate Limiting for the given bucket.
+*        It simply removes every ports from the Ingress Rate Resource.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be deactivated
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlDeactivate
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit
+);
+
+/*******************************************************************************
+* gpirlUpdateParam
+*
+* DESCRIPTION:
+*       This routine updates IRL Parameter.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11)
+*        pirlData - PIRL resource parameters
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlUpdateParam
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_PIRL_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirlReadParam
+*
+* DESCRIPTION:
+*       This routine retrieves IRL Parameter.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlReadParam
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_PIRL_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirlUpdatePortVec
+*
+* DESCRIPTION:
+*       This routine updates port list that share the bucket.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*       portVec  - the list of ports that share the bucket.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlUpdatePortVec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec
+);
+
+/*******************************************************************************
+* gpirlReadPortVec
+*
+* DESCRIPTION:
+*       This routine retrieves port list that share the bucket.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*
+* OUTPUTS:
+*       portVec  - the list of ports that share the bucket.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlReadPortVec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_U32        *portVec
+);
+
+/*******************************************************************************
+* grcGetPirlFcMode
+*
+* DESCRIPTION:
+*       This routine gets Port Ingress Rate Limit Flow Control mode.
+*        When EBSLimitAction is programmed to generate a flow control message,
+*        the deassertion of flow control is controlled by this mode.
+*            GT_PIRL_FC_DEASSERT_EMPTY:
+*                De-assert when the ingress rate resource has become empty
+*            GT_PIRL_FC_DEASSERT_CBS_LIMIT
+*                De-assert when the ingress rate resource has enough room as
+*                specified by the CBSLimit.
+*        Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
+*        CBSLimit.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        mode - GT_PIRL_FC_DEASSERT enum type
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetPirlFcMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_FC_DEASSERT        *mode
+);
+
+/*******************************************************************************
+* gpirlGetIngressRateResource
+*
+* DESCRIPTION:
+*       This routine gets Ingress Rate Limiting Resources assigned to the port.
+*        This vector is used to attach specific counter resources to the physical
+*        port. And the same counter resource can be attached to more than one port.
+*
+* INPUTS:
+*       port   - logical port number
+*
+* OUTPUTS:
+*        resVec - resource vector (bit 0 for irl unit 0, bit 1 for irl unit 1, etc.)
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpirlGetIngressRateResource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U32        *resVec
+);
+
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetPxMode
+*
+* DESCRIPTION:
+*        This routine retrives 4 bits of Px_MODE Configuration value.
+*        If speed and duplex modes are forced, the returned mode value would be
+*        different from the configuration pin values.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - Px_MODE configuration value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPxMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_U32      *mode
+);
+
+/*******************************************************************************
+* gprtGetMiiInterface
+*
+* DESCRIPTION:
+*        This routine retrives Mii Interface Mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Mii Interface is enabled,
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMiiInterface
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetFdFlowDis
+*
+* DESCRIPTION:
+*        This routine retrives the read time value of the Full Duplex Flow Disable.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Full Duplex Flow Disable.
+*                   GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFdFlowDis
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetHdFlowDis
+*
+* DESCRIPTION:
+*        This routine retrives the read time value of the Half Duplex Flow Disable.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Half Duplex Flow Disable.
+*                   GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHdFlowDis
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+);
+
+/*******************************************************************************
+* gprtGetOutQSize
+*
+* DESCRIPTION:
+*        This routine gets egress queue size counter value.
+*        This counter reflects the current number of Egress buffers switched to
+*        this port. This is the total number of buffers across all four priority
+*        queues.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        count - egress queue size counter value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetOutQSize
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *count
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetSAFiltering
+*
+* DESCRIPTION:
+*        This routine set the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOC :
+*                discard if SA field is in the ATU's address database as Static
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU :
+*                Ingressing frames will be mapped to the CPU Port if their SA
+*                field is in the ATU's address database as Static entry with a
+*                PortVec of all zeros. Otherwise, the frames will be discarded
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_SA_FILTERING structure
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS gprtSetSAFiltering
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_SA_FILTERING    mode
+);
+
+/*******************************************************************************
+* gprtGetSAFiltering
+*
+* DESCRIPTION:
+*        This routine gets the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOC :
+*                discard if SA field is in the ATU's address database as Static
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU :
+*                Ingressing frames will be mapped to the CPU Port if their SA
+*                field is in the ATU's address database as Static entry with a
+*                PortVec of all zeros. Otherwise, the frames will be discarded
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_SA_FILTERING structure
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS gprtGetSAFiltering
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_SA_FILTERING    *mode
+);
+
+
+/*******************************************************************************
+* gprtSetARPtoCPU
+*
+* DESCRIPTION:
+*        When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE, to map ARP frames to CPU Port,
+*               GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS gprtSetARPtoCPU
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    mode
+);
+
+
+/*******************************************************************************
+* gprtGetARPtoCPU
+*
+* DESCRIPTION:
+*        When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE, to map ARP frames to CPU Port,
+*               GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS gprtGetARPtoCPU
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *mode
+);
+
+/*******************************************************************************
+* gprtSetEgressFlood
+*
+* DESCRIPTION:
+*       This routine set Egress Flooding Mode.
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_EGRESS_FLOOD structure
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressFlood
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_EGRESS_FLOOD      mode
+);
+
+/*******************************************************************************
+* gprtGetEgressFlood
+*
+* DESCRIPTION:
+*       This routine gets Egress Flooding Mode.
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_EGRESS_FLOOD structure
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressFlood
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_EGRESS_FLOOD      *mode
+);
+
+/*******************************************************************************
+* gprtSetPortSched
+*
+* DESCRIPTION:
+*        This routine sets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_PORT_SCHED_MODE enum type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortSched
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PORT_SCHED_MODE        mode
+);
+
+/*******************************************************************************
+* gprtGetPortSched
+*
+* DESCRIPTION:
+*        This routine gets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_PORT_SCHED_MODE enum type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortSched
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PORT_SCHED_MODE        *mode
+);
+
+
+/*******************************************************************************
+* gprtSetProviderTag
+*
+* DESCRIPTION:
+*        This routine sets Provider Tag which indicates the provider tag (Ether
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
+*
+* INPUTS:
+*        port - the logical port number
+*        tag  - Provider Tag (Ether Type)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetProviderTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        tag
+);
+
+/*******************************************************************************
+* gprtGetProviderTag
+*
+* DESCRIPTION:
+*        This routine gets Provider Tag which indicates the provider tag (Ether
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        tag  - Provider Tag (Ether Type)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetProviderTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *tag
+);
+
+
+
+/* gtPortRateCtrl.c */
+
+/*******************************************************************************
+* grcSetVidNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables VID None Rate Limit (NRL).
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetVidNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* grcGetVidNrlEn
+*
+* DESCRIPTION:
+*       This routine gets VID None Rate Limit (NRL) mode.
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetVidNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* grcSetSaNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables SA None Rate Limit (NRL).
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetSaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* grcGetSaNrlEn
+*
+* DESCRIPTION:
+*       This routine gets SA None Rate Limit (NRL) mode.
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetSaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* grcSetDaNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables DA None Rate Limit (NRL).
+*        When DA NRL is enabled and the destination address of a frame results in
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates
+*        Non Rate Limited, then the frame will not be ingress nor egress rate
+*        limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetDaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* grcGetDaNrlEn
+*
+* DESCRIPTION:
+*       This routine gets SA None Rate Limit (NRL) mode.
+*        When DA NRL is enabled and the destination address of a frame results in
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates
+*        Non Rate Limited, then the frame will not be ingress nor egress rate
+*        limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetDaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* grcSetELimitMode
+*
+* DESCRIPTION:
+*       This routine sets Egress Rate Limit counting mode.
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*
+* INPUTS:
+*       port - logical port number
+*        mode - GT_PIRL_ELIMIT_MODE enum type
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        GT_PIRL_ELIMIT_FRAME mode is supported by only a few devices.
+*        Please refer to the device datasheet for details.
+*
+*******************************************************************************/
+GT_STATUS grcSetELimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_ELIMIT_MODE        mode
+);
+
+/*******************************************************************************
+* grcGetELimitMode
+*
+* DESCRIPTION:
+*       This routine gets Egress Rate Limit counting mode.
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        mode - GT_PIRL_ELIMIT_MODE enum type
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        GT_PIRL_ELIMIT_FRAME mode is supported by only a few devices.
+*        Please refer to the device datasheet for details.
+*
+*******************************************************************************/
+GT_STATUS grcGetELimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_ELIMIT_MODE        *mode
+);
+
+/*******************************************************************************
+* grcSetRsvdNrlEn
+*
+* DESCRIPTION:
+*       This routine sets Reserved Non Rate Limit.
+*        When this feature is enabled, frames that match the requirements of the
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non
+*        rate limited.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Reserved Non Rate Limit,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS grcSetRsvdNrlEn
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+);
+
+/*******************************************************************************
+* grcGetRsvdNrlEn
+*
+* DESCRIPTION:
+*       This routine gets Reserved Non Rate Limit.
+*        When this feature is enabled, frames that match the requirements of the
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non
+*        rate limited.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Reserved Non Rate Limit,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS grcGetRsvdNrlEn
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+);
+
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+* gstatsGetRealtimePortCounter
+*
+* DESCRIPTION:
+*        This routine gets a specific realtime counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetRealtimePortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT GT_U32            *statsData
+);
+
+
+/* gtQosMap.c */
+
+/*******************************************************************************
+* gqosSetVIDFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetVIDFPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetVIDFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetVIDFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetSAFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Source Address(SA) Frame Priority Override.
+*        When this feature is enabled, SA Frame priority overrides can occur on
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetSAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetSAFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Source Address(SA) Frame Priority Override.
+*        When this feature is enabled, SA Frame priority overrides can occur on
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetSAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetDAFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Frame Priority Override.
+*        When this feature is enabled, DA Frame priority overrides can occur on
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetDAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetDAFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Destination Address(DA) Frame Priority Override.
+*        When this feature is enabled, DA Frame priority overrides can occur on
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetDAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetVIDQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetVIDQPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetVIDQPriOverride
+*
+* DESCRIPTION:
+*        This routine gets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetVIDQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetSAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Source Address(SA) Queue Priority Override.
+*        When this feature is enabled, SA Queue priority overrides can occur on
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetSAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetSAQPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Source Address(SA) Queue Priority Override.
+*        When this feature is enabled, SA Queue priority overrides can occur on
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetSAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetDAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Queue Priority Override.
+*        When this feature is enabled, DA Queue priority overrides can occur on
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetDAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetDAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Queue Priority Override.
+*        When this feature is enabled, DA Queue priority overrides can occur on
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetDAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gqosSetARPQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets ARP Queue Priority Override.
+*        When this feature is enabled, ARP Queue priority overrides can occur on
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetARPQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gqosGetARPQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets ARP Queue Priority Override.
+*        When this feature is enabled, ARP Queue priority overrides can occur on
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetARPQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+
+/*******************************************************************************
+* gqosSetQPriValue
+*
+* DESCRIPTION:
+*       This routine sets Queue priority value to used when forced.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
+*
+* INPUTS:
+*       port - the logical port number.
+*       pri  - Queue priority value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 3
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosSetQPriValue
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_U8      pri
+);
+
+/*******************************************************************************
+* gqosGetQPriValue
+*
+* DESCRIPTION:
+*       This routine gets Queue priority value to used when forced.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       pri  - Queue priority value
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosGetQPriValue
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_U8      *pri
+);
+
+/*******************************************************************************
+* gqosSetForceQPri
+*
+* DESCRIPTION:
+*       This routine enables/disables forcing Queue priority.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE, to force Queue Priority,
+*               GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosSetForceQPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_BOOL    en
+);
+
+/*******************************************************************************
+* gqosGetForceQPri
+*
+* DESCRIPTION:
+*       This routine checks if forcing Queue priority is enabled.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       en   - GT_TRUE, to force Queue Priority,
+*               GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosGetForceQPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *en
+);
+
+/*******************************************************************************
+* gqosSetDefFPri
+*
+* DESCRIPTION:
+*       This routine sets the default frame priority (0 ~ 7).
+*        This priority is used as the default frame priority (FPri) to use when
+*        no other priority information is available.
+*
+* INPUTS:
+*       port - the logical port number
+*       pri  - default frame priority
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 7
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosSetDefFPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_U8      pri
+);
+
+/*******************************************************************************
+* gqosGetDefFPri
+*
+* DESCRIPTION:
+*       This routine gets the default frame priority (0 ~ 7).
+*        This priority is used as the default frame priority (FPri) to use when
+*        no other priority information is available.
+*
+* INPUTS:
+*       port - the logical port number
+*
+* OUTPUTS:
+*       pri  - default frame priority
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosGetDefFPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_U8      *pri
+);
+
+
+/*******************************************************************************
+* gqosSetArpQPri
+*
+* DESCRIPTION:
+*       This routine sets ARP queue Priority to use for ARP QPri Overridden
+*        frames. When a ARP frame is received on a por tthat has its ARP
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
+*
+* INPUTS:
+*       pri - ARP Queue Priority (0 ~ 3)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 3
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gqosSetArpQPri
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     pri
+);
+
+
+/*******************************************************************************
+* gqosGetArpQPri
+*
+* DESCRIPTION:
+*       This routine gets ARP queue Priority to use for ARP QPri Overridden
+*        frames. When a ARP frame is received on a por tthat has its ARP
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       pri - ARP Queue Priority (0 ~ 3)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gqosGetArpQPri
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_U8     *pri
+);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetUsePortSchedule
+*
+* DESCRIPTION:
+*       This routine sets per port scheduling mode
+*
+* INPUTS:
+*       en - GT_TRUE enables per port scheduling,
+*             GT_FALSE disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetUsePortSchedule
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+);
+
+/*******************************************************************************
+* gsysGetUsePortSchedule
+*
+* DESCRIPTION:
+*       This routine gets per port scheduling mode
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE enables per port scheduling,
+*             GT_FALSE disable.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetUsePortSchedule
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+);
+
+/*******************************************************************************
+* gsysSetOldHader
+*
+* DESCRIPTION:
+*       This routine sets Egress Old Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header,
+*        the format of the Header is slightly modified to be backwards compatible
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Old Header Mode,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetOldHader
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+);
+
+/*******************************************************************************
+* gsysGetOldHader
+*
+* DESCRIPTION:
+*       This routine gets Egress Old Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header,
+*        the format of the Header is slightly modified to be backwards compatible
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE to enable Old Header Mode,
+*             GT_FALSE to disable
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetOldHader
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+);
+
+/*******************************************************************************
+* gsysSetRecursiveStrippingDisable
+*
+* DESCRIPTION:
+*       This routine determines if recursive tag stripping feature needs to be
+*        disabled.
+*
+* INPUTS:
+*       en - GT_TRUE to disable Recursive Tag Stripping,
+*             GT_FALSE to enable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRecursiveStrippingDisable
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+);
+
+/*******************************************************************************
+* gsysGetRecursiveStrippingDisable
+*
+* DESCRIPTION:
+*       This routine checks if recursive tag stripping feature is disabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE, if Recursive Tag Stripping is disabled,
+*             GT_FALSE, otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRecursiveStrippingDisable
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+);
+
+/*******************************************************************************
+* gsysSetCPUPort
+*
+* DESCRIPTION:
+*       This routine sets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped
+*        frames are destined.
+*
+* INPUTS:
+*       cpuPort - CPU Port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetCPUPort
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  cpuPort
+);
+
+/*******************************************************************************
+* gsysGetCPUPort
+*
+* DESCRIPTION:
+*       This routine gets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped
+*        frames are destined.
+*
+* INPUTS:
+*       cpuPort - CPU Port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetCPUPort
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_LPORT  *cpuPort
+);
+
+
+
+/* gtSysStatus.c */
+
+/*******************************************************************************
+* gsysGetFreeQSize
+*
+* DESCRIPTION:
+*       This routine gets Free Queue Counter. This counter reflects the
+*        current number of unalllocated buffers available for all the ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       count - Free Queue Counter
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFreeQSize
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16         *count
+);
+
+/*******************************************************************************
+                New APIs in DSDT 2.6
+*******************************************************************************/
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbSetPortAtuLearnLimit
+*
+* DESCRIPTION:
+*       Port's auto learning limit. When the limit is non-zero value, the number
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame
+*        that ingresses this port with a source MAC address not already in the
+*        address database that is associated with this port will be discarded.
+*        Normal auto-learning will resume on the port as soon as the number of
+*        active unicast MAC addresses associated to this port is less than the
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) disable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
+*
+* INPUTS:
+*       port  - logical port number
+*       limit - auto learning limit ( 0 ~ 255 )
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetPortAtuLearnLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_U32       limit
+);
+
+
+/*******************************************************************************
+* gfdbGetPortAtuLearnCnt
+*
+* DESCRIPTION:
+*       Read the current number of active unicast MAC addresses associated with
+*        the given port. This counter (LearnCnt) is held at zero if learn limit
+*        (gfdbSetPortAtuLearnLimit API) is set to zero.
+*
+* INPUTS:
+*       port  - logical port number
+*
+* OUTPUTS:
+*       count - current auto learning count
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetPortAtuLearnCnt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_U32       *count
+);
+
+/*******************************************************************************
+* gfdbGetAtuAllCount
+*
+* DESCRIPTION:
+*       Counts all entries in the Address Translation Unit.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       count - number of valid entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuAllCount
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32         *count
+);
+
+/*******************************************************************************
+* gfdbGetAtuAllCountInDBNum
+*
+* DESCRIPTION:
+*       Counts all entries in the defined FID (or DBNum).
+*
+* INPUTS:
+*       dbNum - DBNum of FID
+*
+* OUTPUTS:
+*       count - number of valid entries in FID (or DBNum).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuAllCountInDBNum
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32         dbNum,
+    OUT GT_U32         *count
+);
+
+/*******************************************************************************
+* gfdbGetAtuDynamicCountInDBNum
+*
+* DESCRIPTION:
+*       Counts all non-static entries in the defined FID (or DBNum).
+*
+* INPUTS:
+*       dbNum - DBNum or FID
+*
+* OUTPUTS:
+*       count - number of valid non-static entries in FID (or DBNum).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuDynamicCountInDBNum
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32         dbNum,
+    OUT GT_U32         *count
+);
+
+
+/* gtBrgStu.c */
+
+/*******************************************************************************
+* gstuGetEntryCount
+*
+* DESCRIPTION:
+*       Gets the current number of valid entries in the STU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numEntries - number of STU entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gstuGetEntryCount
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_U32    *numEntries
+);
+
+/*******************************************************************************
+* gstuGetEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic entry from the STU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       stuEntry - find the first valid STU entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstuGetEntryFirst
+(
+    IN  GT_QD_DEV       *dev,
+    OUT GT_STU_ENTRY    *stuEntry
+);
+
+/*******************************************************************************
+* gstuGetEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic STU entry from the specified SID.
+*
+* INPUTS:
+*       stuEntry - the SID to start the search.
+*
+* OUTPUTS:
+*       stuEntry - next STU entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstuGetEntryNext
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_STU_ENTRY  *stuEntry
+);
+
+/*******************************************************************************
+* gstuFindSidEntry
+*
+* DESCRIPTION:
+*       Find STU entry for a specific SID, it will return the entry, if found,
+*       along with its associated data
+*
+* INPUTS:
+*       stuEntry - contains the SID to searche for
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       stuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no such entry.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstuFindSidEntry
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_STU_ENTRY  *stuEntry,
+    OUT GT_BOOL         *found
+);
+
+/*******************************************************************************
+* gstuAddEntry
+*
+* DESCRIPTION:
+*       Creates or update the entry in STU table based on user input.
+*
+* INPUTS:
+*       stuEntry    - stu entry to insert to the STU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gstuAddEntry
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_STU_ENTRY    *stuEntry
+);
+
+/*******************************************************************************
+* gstuDelEntry
+*
+* DESCRIPTION:
+*       Deletes STU entry specified by user.
+*
+* INPUTS:
+*       stuEntry - the STU entry to be deleted
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstuDelEntry
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_STU_ENTRY     *stuEntry
+);
+
+
+/* gtCCPVT.c */
+
+/*******************************************************************************
+* gpvtInitialize
+*
+* DESCRIPTION:
+*       This routine initializes the PVT Table to all one's (initial state)
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpvtInitialize
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gpvtWritePVTData
+*
+* DESCRIPTION:
+*       This routine write Cross Chip Port Vlan Data.
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0,
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
+*
+*
+* INPUTS:
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*        pvtData    - Cross Chip Port Vlan Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpvtWritePVTData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        pvtPointer,
+    IN  GT_U32        pvtData
+);
+
+/*******************************************************************************
+* gpvtReadPVTData
+*
+* DESCRIPTION:
+*       This routine reads Cross Chip Port Vlan Data.
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0,
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
+*
+*
+* INPUTS:
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*
+* OUTPUTS:
+*        pvtData    - Cross Chip Port Vlan Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpvtReadPVTData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        pvtPointer,
+    OUT GT_U32        *pvtData
+);
+
+
+/* gtEvents.c */
+
+/*******************************************************************************
+* geventGetDevIntStatus
+*
+* DESCRIPTION:
+*         Check to see which device interrupts (WatchDog, JamLimit, Duplex Mismatch, and
+*        SERDES Link Int) have occurred.
+*
+* INPUTS:
+*       intType - the type of interrupt which causes an interrupt.
+*                  any combination of
+*                    GT_DEV_INT_WATCHDOG,
+*                    GT_DEV_INT_JAMLIMIT,
+*                    GT_DEV_INT_DUPLEX_MISMATCH,
+*                    GT_DEV_INT_SERDES_LINK
+*        port    - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
+*                  valid only if GT_DEV_INT_DUPLEX_MISMATCH is set in intType.
+*        linkInt - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
+*                  asserted. It's in vector format, Bit 10 is for port 10,
+*                  Bit 9 is for port 9, etc.
+*                  valid only if GT_DEV_INT_SERDES_LINK bit is set in intType.
+*                  These bits are only valid of the port that is in 1000Base-X mode.
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventGetDevIntStatus
+(
+    IN  GT_QD_DEV             *dev,
+    OUT GT_DEV_INT_STATUS    *devIntStatus
+);
+
+/*******************************************************************************
+* geventSetAgeOutIntEn
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Out Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventSetAgeOutIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* geventGetAgeOutIntEn
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_TRUE, if Age Out Interrupt is enabled
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventGetAgeOutIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* geventSetOverLimitInt
+*
+* DESCRIPTION:
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbGetPortAtuLimitReached API).
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventSetOverLimitInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+);
+
+/*******************************************************************************
+* geventGetOverLimitInt
+*
+* DESCRIPTION:
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbSetPortAtuLearnLimit API).
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventGetOverLimitInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* geventGetPortAtuLimitReached
+*
+* DESCRIPTION:
+*       This routine checks if learn limit has been reached.
+*        When it reached, the port can no longer auto learn any more MAC addresses
+*        because the address learn limit set on this port has been reached.
+*
+* INPUTS:
+*       port  - logical port number
+*
+* OUTPUTS:
+*       limit - GT_TRUE, if limit has been reached
+*                GT_FALSE, otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*
+*******************************************************************************/
+GT_STATUS geventGetPortAtuLimitReached
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_BOOL       *limit
+);
+
+/*******************************************************************************
+* eventSetDevInt
+*
+* DESCRIPTION:
+*        Device Interrupt.
+*        The following device interrupts are supported:
+*            GT_DEV_INT_WATCHDOG    -
+*                WatchDog event interrupt (WatchDog event can be configured with
+*                gwdSetEvent API)
+*            GT_DEV_INT_JAMLIMIT    -
+*                any of the ports detect an Ingress Jam Limit violation
+*                (see gprtSetPauseLimitIn API)
+*            GT_DEV_INT_DUPLEX_MISMATCH -
+*                any of the ports detect a duplex mismatch (i.e., the local port is
+*                in half duplex mode while the link partner is in full duplex mode)
+*            GT_DEV_INT_SERDES_LINK -
+*                SERDES link chage interrupt.
+*                An interrupt occurs when a SERDES port changes link status
+*                (link up or link down)
+*
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled event when GT_DEV_INT is enabled with
+*        eventSetActive API.
+*
+* INPUTS:
+*        devInt - GT_DEV_INT
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS eventSetDevInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_DEV_EVENT    *devInt
+);
+
+/*******************************************************************************
+* gwdSetEvent
+*
+* DESCRIPTION:
+*        Watch Dog Event.
+*        The following Watch Dog events are supported:
+*            GT_WD_QC  - Queue Controller Watch Dog enable.
+*                        When enabled, the QC's watch dog circuit checks for link
+*                        list errors and any errors found in the QC.
+*            GT_WD_EGRESS - Egress Watch Dog enable.
+*                        When enabled, each port's egress circuit checks for problems
+*                        between the port and the Queue Controller.
+*            GT_WD_FORCE - Force a Watch Dog event.
+*
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled WatchDog event when GT_DEV_INT_WATCHDOG is
+*        enabled with eventSetDevActive API and GT_DEV_INT is enabled with
+*        eventSetActive API.
+*
+* INPUTS:
+*        wdEvent - Watch Dog Events
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdSetEvent
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        wdEvent
+);
+
+/*******************************************************************************
+* gwdSetSWResetOnWD
+*
+* DESCRIPTION:
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API)
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
+*
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this
+*        automatic SWReset. This allows the user to know if any watch dog event
+*        ever occurred even if the swich is configured to automatically recover
+*        from a watch dog.
+*
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
+*
+* INPUTS:
+*        en   - GT_TRUE to enable SWReset on WD
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdSetSWResetOnWD
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        en
+);
+
+/*******************************************************************************
+* gwdGetSWResetOnWD
+*
+* DESCRIPTION:
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API)
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
+*
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this
+*        automatic SWReset. This allows the user to know if any watch dog event
+*        ever occurred even if the swich is configured to automatically recover
+*        from a watch dog.
+*
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en   - GT_TRUE, if SWReset on WD is enabled
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdGetSWResetOnWD
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gwdGetHistory
+*
+* DESCRIPTION:
+*        This routine retrieves Watch Dog history. They are
+*
+*        wdEvent -
+*            When it's set to GT_TRUE, some enabled Watch Dog event occurred.
+*            The following events are possible:
+*                QC WatchDog Event (GT_WD_QC)
+*                Egress WatchDog Event (GT_WD_EGRESS)
+*                Forced WatchDog Event (GT_WD_FORCE)
+*        egressEvent -
+*            If any port's egress logic detects an egress watch dog issue,
+*            this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
+*            event.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        history - GT_WD_EVENT_HISTORY structure
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdGetHistory
+(
+    IN  GT_QD_DEV            *dev,
+    OUT GT_WD_EVENT_HISTORY    *history
+);
+
+
+/* gtPIRL2.c */
+
+/*******************************************************************************
+* gpirl2WriteResource
+*
+* DESCRIPTION:
+*       This routine writes resource bucket parameters to the given resource
+*        of the port.
+*
+* INPUTS:
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*        pirlData - PIRL resource parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirl2WriteResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    IN  GT_PIRL2_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirl2ReadResource
+*
+* DESCRIPTION:
+*       This routine retrieves IRL Parameter.
+*
+* INPUTS:
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirl2ReadResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    OUT GT_PIRL2_DATA    *pirlData
+);
+
+/*******************************************************************************
+* gpirl2DisableResource
+*
+* DESCRIPTION:
+*       This routine disables Ingress Rate Limiting for the given bucket.
+*
+* INPUTS:
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirl2DisableResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes
+);
+
+
+/* gtPolicy.c */
+
+/*******************************************************************************
+* gprtSetPolicy
+*
+* DESCRIPTION:
+*       This routine sets the Policy for ports.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*
+* INPUTS:
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*       policy     - policy (GT_FRAME_POLICY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*       GT_BAD_PARAM     - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    IN    GT_FRAME_POLICY    policy
+);
+
+/*******************************************************************************
+* gprtGetPolicy
+*
+* DESCRIPTION:
+*       This routine gets the Policy of the given policy type.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*
+* INPUTS:
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*
+* OUTPUTS:
+*       policy     - policy (GT_FRAME_POLICY)
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*       GT_BAD_PARAM     - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    OUT GT_FRAME_POLICY    *policy
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetPauseLimitOut
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
+*
+* INPUTS:
+*        port - the logical port number
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPauseLimitOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        limit
+);
+
+/*******************************************************************************
+* gprtGetPauseLimitOut
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPauseLimitOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *limit
+);
+
+/*******************************************************************************
+* gprtSetPauseLimitIn
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that
+*        the limit was reached on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPauseLimitIn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        limit
+);
+
+/*******************************************************************************
+* gprtGetPauseLimitIn
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that
+*        the limit was reached on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPauseLimitIn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *limit
+);
+
+/*******************************************************************************
+* gprtSetFrameMode
+*
+* DESCRIPTION:
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to
+*                be used on ports that connect to a CPU.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_FRAME_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is unknown
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetFrameMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_FRAME_MODE    mode
+);
+
+/*******************************************************************************
+* gprtGetFrameMode
+*
+* DESCRIPTION:
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to
+*                be used on ports that connect to a CPU.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_FRAME_MODE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFrameMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_FRAME_MODE    *mode
+);
+
+/*******************************************************************************
+* gprtSetHoldAt1
+*
+* DESCRIPTION:
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetHoldAt1
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetHoldAt1
+*
+* DESCRIPTION:
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHoldAt1
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
+);
+
+
+/*******************************************************************************
+* gprtSetIntOnAgeOut
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable AgeOutViloation interrupt
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIntOnAgeOut
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetIntOnAgeOut
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable AgeOutViloation interrupt
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIntOnAgeOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
+);
+
+/*******************************************************************************
+* gprtSetRefreshLocked
+*
+* DESCRIPTION:
+*        Auto Refresh known addresses when port is Locked. Already known addresses
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetRefreshLocked
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetRefreshLocked
+*
+* DESCRIPTION:
+*        Auto Refresh known addresses when port is Locked. Already known addresses
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetRefreshLocked
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
+);
+
+/*******************************************************************************
+* gprtSetPortEType
+*
+* DESCRIPTION:
+*        This routine sets the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*
+* INPUTS:
+*        port  - the logical port number
+*        etype - port's special ether type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortEType
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_ETYPE        etype
+);
+
+/*******************************************************************************
+* gprtGetPortEType
+*
+* DESCRIPTION:
+*        This routine retrieves the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*
+* INPUTS:
+*        port  - the logical port number
+*
+* OUTPUTS:
+*        etype - port's special ether type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortEType
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_ETYPE    *etype
+);
+
+
+/* gtPortRateCtr.c */
+
+/*******************************************************************************
+* grcSetFrameOverhead
+*
+* DESCRIPTION:
+*       Egress rate frame overhead adjustment.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
+*
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
+*
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
+*
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
+*
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
+*
+* INPUTS:
+*       port     - logical port number.
+*       overhead - Frame overhead (0 ~ 15)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetFrameOverhead
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT            port,
+    IN GT_32            overhead
+);
+
+/*******************************************************************************
+* grcGetFrameOverhead
+*
+* DESCRIPTION:
+*       Egress rate frame overhead adjustment.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
+*
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
+*
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
+*
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
+*
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       overhead - Frame overhead (0 ~ 15)
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+*******************************************************************************/
+GT_STATUS grcGetFrameOverhead
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_32    *overhead
+);
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetBufHigh
+*
+* DESCRIPTION:
+*        Output from QC telling the MAC that it should perform Flow Control.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        bufHigh - GT_TRUE, if Flow control required
+*                  GT_FALSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetBufHigh
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *bufHigh
+);
+
+/*******************************************************************************
+* gprtGetFcEn
+*
+* DESCRIPTION:
+*        Input into the QC telling it that Flow Control is enabled on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        fcEn - GT_TRUE, if Flow control is enabled
+*               GT_FALSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFcEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *fcEn
+);
+
+/*******************************************************************************
+* gprtGetRsvSize
+*
+* DESCRIPTION:
+*        This routine gets Ingress reserved queue size counter.
+*        This counter reflects the current number of reserved ingress buffers
+*        assigned to this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        count - reserved ingress queue size counter value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetRsvSize
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *count
+);
+
+
+/* gtPriTable.c */
+
+/*******************************************************************************
+* gsysSetQPriOverrideTable
+*
+* DESCRIPTION:
+*       Queue Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysSetQPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
+);
+
+/*******************************************************************************
+* gsysGetQPriOverrideTable
+*
+* DESCRIPTION:
+*       Queue Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysGetQPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
+);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetCPUDest
+*
+* DESCRIPTION:
+*        This routine sets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria
+*        are mapped to the CPU Destination port, overriding where the frame would
+*        normally go. In the case of ARP, the frame will be mapped normally and it
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring
+*        will occur and ingressing To_CPU frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetCPUDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetCPUDest
+*
+* DESCRIPTION:
+*        This routine gets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria
+*        are mapped to the CPU Destination port, overriding where the frame would
+*        normally go. In the case of ARP, the frame will be mapped normally and it
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring
+*        will occur and ingressing To_CPU frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetCPUDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+/*******************************************************************************
+* gsysSetMirrorDest
+*
+* DESCRIPTION:
+*        This routine sets Mirror Destination Port. Frames that ingress a port
+*        that trigger a policy mirror are mapped (copied) to this port as long as
+*        the frame is not filtered or discarded.
+*        The Mirror Destination port should point to the port that directs these
+*        frames to the CPU that will process these frames. This target port should
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU
+*        Policy Mirror frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetMirrorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+);
+
+/*******************************************************************************
+* gsysGetMirrorDest
+*
+* DESCRIPTION:
+*        This routine gets Mirror Destination Port. Frames that ingress a port
+*        that trigger a policy mirror are mapped (copied) to this port as long as
+*        the frame is not filtered or discarded.
+*        The Mirror Destination port should point to the port that directs these
+*        frames to the CPU that will process these frames. This target port should
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU
+*        Policy Mirror frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetMirrorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+);
+
+/*******************************************************************************
+* gsysSetRMPort
+*
+* DESCRIPTION:
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047
+*        device allows logical port 4 and 5.
+*
+* INPUTS:
+*        port - Remote Management Port
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on unallowable port
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+);
+
+/*******************************************************************************
+* gsysGetRMPort
+*
+* DESCRIPTION:
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047
+*        device allows logical port 4 and 5.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - Remote Management Port
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMPort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
+);
+
+/*******************************************************************************
+* gsysSetRMDACheck
+*
+* DESCRIPTION:
+*        Check the DA on Remote Management frames.
+*        When DA Check is enabled, the DA of Remote Management frames must be
+*        contained in this device's address database (ATU) as a Static entry
+*        (either unicast or multicast). If the DA of the frame is not contained
+*        in this device's address database, the frame will be not be processed as
+*        a Frame-to-Regter frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not
+*        validated before processing the frame.
+*
+* INPUTS:
+*        en - GT_TRUE to enable DA Check,
+*             GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMDACheck
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
+);
+
+/*******************************************************************************
+* gsysGetRMDACheck
+*
+* DESCRIPTION:
+*        Check the DA on Remote Management frames.
+*        When DA Check is enabled, the DA of Remote Management frames must be
+*        contained in this device's address database (ATU) as a Static entry
+*        (either unicast or multicast). If the DA of the frame is not contained
+*        in this device's address database, the frame will be not be processed as
+*        a Frame-to-Regter frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not
+*        validated before processing the frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if DA Check is enabled,
+*             GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMDACheck
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *en
+);
+
+/*******************************************************************************
+* gsysSetHeaderType
+*
+* DESCRIPTION:
+*   To set Header Type. These bits are used to configure the bits that are placed
+*   into the Egress Header when it is enabled on a port (Port offset 0x04)
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*
+* INPUTS:
+*        hdType
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetHeaderType
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       hdType
+);
+
+/*******************************************************************************
+* gsysGetHeaderType
+*
+* DESCRIPTION:
+*   To get Header Type. These bits are used to configure the bits that are placed
+*   into the Egress Header when it is enabled on a port (Port offset 0x04)
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        hdType
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetHeaderType
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16     *hdType
+);
+
+/*******************************************************************************
+* gsysSetRMEnable
+*
+* DESCRIPTION:
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*
+* INPUTS:
+*        en - GT_TRUE to enable Remote Management feature,
+*             GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMEnable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
+);
+
+/*******************************************************************************
+* gsysGetRMEnable
+*
+* DESCRIPTION:
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Remote Management feature is enabled,
+*             GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMEnable
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *en
+);
+
+/*******************************************************************************
+* gsysSetCtrMode
+*
+* DESCRIPTION:
+*        Set Counter Modes. These bits control the operating modes of the two of
+*        the Ports MIB counters.
+*
+* INPUTS:
+*        ctrMode - Counter mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetCtrMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       ctrMode
+);
+
+/*******************************************************************************
+* gsysGetCtrMode
+*
+* DESCRIPTION:
+*        Get Counter Modes. These bits control the operating modes of the two of
+*        the Ports MIB counters.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        ctrMode - Counter mode
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetCtrMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16       *ctrMode
+);
+
+/*******************************************************************************
+* gsysSetRsvd2CpuEnables2X
+*
+* DESCRIPTION:
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved
+*        multicast DA addresses, whose bit in this register are also set to a one,
+*        are treadted as MGMT frames. All the reserved DA's take the form
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested.
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2CpuEnables2X
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        enBits
+);
+
+/*******************************************************************************
+* gsysGetRsvd2CpuEnables2X
+*
+* DESCRIPTION:
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved
+*        multicast DA addresses, whose bit in this register are also set to a one,
+*        are treadted as MGMT frames. All the reserved DA's take the form
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested.
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2CpuEnables2X
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *enBits
+);
+
+/*******************************************************************************
+* gsysSetLoopbackFilter
+*
+* DESCRIPTION:
+*        Loopback Filter.
+*        When Loopback Filter is enabled,Forward DSA frames that ingress a DSA port
+*        that came from the same Src_Dev will be filtered to the same Src_Port,
+*        i.e., the frame will not be allowed to egress the source port on the
+*        source device as indicated in the DSA Forward's Tag.
+*
+* INPUTS:
+*        en - GT_TRUE to enable LoopbackFilter, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetLoopbackFilter
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetLoopbackFilter
+*
+* DESCRIPTION:
+*        Loopback Filter.
+*        When Loopback Filter is enabled,Forward DSA frames that ingress a DSA port
+*        that came from the same Src_Dev will be filtered to the same Src_Port,
+*        i.e., the frame will not be allowed to egress the source port on the
+*        source device as indicated in the DSA Forward's Tag.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if LoopbackFilter is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetLoopbackFilter
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetFloodBC
+*
+* DESCRIPTION:
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and
+*        other switch policy still applies to these Broadcast frames.
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's
+*        Egress Floods mode.
+*
+* INPUTS:
+*        en - GT_TRUE to enable Flood Broadcast, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFloodBC
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetFloodBC
+*
+* DESCRIPTION:
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and
+*        other switch policy still applies to these Broadcast frames.
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's
+*        Egress Floods mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Flood Broadcast is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetFloodBC
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetRemove1PTag
+*
+* DESCRIPTION:
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be
+*        performed. Only the first Provider Tag found on the frame will be
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive
+*        Provider Tag stripping will be performed. The first Provider Tag's data
+*        will be extracted and used for switching, and then all subsequent Provider
+*        Tags found in the frame will also be removed. This will only occur if the
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*
+* INPUTS:
+*        en - GT_TRUE to enable Remove One Provider Tag, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRemove1PTag
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetRemove1PTag
+*
+* DESCRIPTION:
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be
+*        performed. Only the first Provider Tag found on the frame will be
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive
+*        Provider Tag stripping will be performed. The first Provider Tag's data
+*        will be extracted and used for switching, and then all subsequent Provider
+*        Tags found in the frame will also be removed. This will only occur if the
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Remove One Provider Tag is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRemove1PTag
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gsysSetTagFlowControl
+*
+* DESCRIPTION:
+*        Use and generate source port Flow Control status for Cross-Chip Flow
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is
+*        defined to be Src_FC and it is added to these frames when generated and
+*        it is inspected on these frames when received. The QC will use the Src_FC
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to
+*        be Reserved and it will be zero on these frames when generated and it
+*        will not be used on these frames when received (this is a backwards
+*        compatibility mode).
+*
+* INPUTS:
+*        en - GT_TRUE to enable Tag Flow Control, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetTagFlowControl
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetTagFlowControl
+*
+* DESCRIPTION:
+*        Use and generate source port Flow Control status for Cross-Chip Flow
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is
+*        defined to be Src_FC and it is added to these frames when generated and
+*        it is inspected on these frames when received. The QC will use the Src_FC
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to
+*        be Reserved and it will be zero on these frames when generated and it
+*        will not be used on these frames when received (this is a backwards
+*        compatibility mode).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Tag Flow Control is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetTagFlowControl
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetAlwaysUseVTU
+*
+* DESCRIPTION:
+*        Always use VTU.
+*        When this feature is enabled, VTU hit data will be used to map frames
+*        even if 802.1Q is Disabled on the port.
+*        When it's disabled, data will be ignored when mapping frames on ports
+*        where 802.1Q is Disabled.
+*
+* INPUTS:
+*        en - GT_TRUE to use VTU always, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetAlwaysUseVTU
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetAlwaysUseVTU
+*
+* DESCRIPTION:
+*        Always use VTU.
+*        When this feature is enabled, VTU hit data will be used to map frames
+*        even if 802.1Q is Disabled on the port.
+*        When it's disabled, data will be ignored when mapping frames on ports
+*        where 802.1Q is Disabled.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if VTU is always used, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetAlwaysUseVTU
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetQVlansOnly
+*
+* DESCRIPTION:
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is
+*        limited by the frame's VID (using the MemberTag data found in the VTU)
+*        together with the port based VLANs (using the source port's PortVLANTable,
+*        gvlnSetPortVlanPorts API). The two methods are always used together in
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
+*
+* INPUTS:
+*        en - GT_TRUE to use 802.1Q Vlan Only feature, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetQVlansOnly
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGetQVlansOnly
+*
+* DESCRIPTION:
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is
+*        limited by the frame's VID (using the MemberTag data found in the VTU)
+*        together with the port based VLANs (using the source port's PortVLANTable,
+*        gvlnSetPortVlanPorts API). The two methods are always used together in
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 802.1Q Vlan Only feature is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetQVlansOnly
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSet5BitPort
+*
+* DESCRIPTION:
+*        Use 5 bits for Port data in the Port VLAN Table (PVT).
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
+*
+* INPUTS:
+*        en - GT_TRUE to use 5 bit as a Source port in PVT, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSet5BitPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+/*******************************************************************************
+* gsysGet5BitPort
+*
+* DESCRIPTION:
+*        Use 5 bits for Port data in the Port VLAN Table (PVT).
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 5 bit is used as a Source Port in PVT, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGet5BitPort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+/*******************************************************************************
+* gsysSetSDETPolarity
+*
+* DESCRIPTION:
+*        SDET (Signal Detect) Polarity select bits for each port.
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help
+*        determine link on fiber ports. This bit affects the active level of a
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other
+*        port modes the SDET pins are ignored and these bits have no effect.
+*
+* INPUTS:
+*        sdetVec - SDET Polarity for each port in Vector format
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sdetVec is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetSDETPolarity
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          sdetVec
+);
+
+/*******************************************************************************
+* gsysSetSDETPolarity
+*
+* DESCRIPTION:
+*        SDET (Signal Detect) Polarity select bits for each port.
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help
+*        determine link on fiber ports. This bit affects the active level of a
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other
+*        port modes the SDET pins are ignored and these bits have no effect.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        sdetVec - SDET Polarity for each port in Vector format
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetSDETPolarity
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32      *sdetVec
+);
+
+
+/* gtBrgVlan.c for 2.6 release */
+
+/*******************************************************************************
+* gvlnSetNoEgrPolicy
+*
+* DESCRIPTION:
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress
+*        even if the VID assigned to the frame is not found in the VTU.
+*
+* INPUTS:
+*        mode - no egress policy mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gvlnSetNoEgrPolicy
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
+);
+
+
+/*******************************************************************************
+* gvlnGetNoEgrPolicy
+*
+* DESCRIPTION:
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress
+*        even if the VID assigned to the frame is not found in the VTU.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - no egress policy mode
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gvlnGetNoEgrPolicy
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gwdSetRMUTimeOut
+*
+* DESCRIPTION:
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
+*
+*        When this bit is cleared to a zero the Wait on Bit command will wait
+*        until the bit that is being tested has changed to the specified value.
+*
+* INPUTS:
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdSetRMUTimeOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        en
+);
+
+/*******************************************************************************
+* gwdGetRMUTimeOut
+*
+* DESCRIPTION:
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
+*
+*        When this bit is cleared to a zero the Wait on Bit command will wait
+*        until the bit that is being tested has changed to the specified value.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdGetRMUTimeOut
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gwdGetEgressWDEvent
+*
+* DESCRIPTION:
+*        If any port's egress logic detects an egress watch dog issue, this bit
+*        will be set to a one, regardless of the setting of the GT_WD_EGRESS in
+*        gwdSetEvent function.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        event - GT_TRUE, if egress logic has detected any egress watch dog issue
+*                GT_FALUSE, otherwise
+*
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdGetEgressWDEvent
+(
+    IN  GT_QD_DEV        *dev,
+    OUT GT_BOOL            *event
+);
+
+
+/*******************************************************************************
+* gsysSetQoSWeight
+*
+* DESCRIPTION:
+*       Programmable Round Robin Weights.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and
+*        Queue 0 has the lowest priority. When a scheduling mode of port is
+*        configured as Weighted Round Robin queuing mode, the access sequece of the
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This sequence can be configured with this API.
+*
+* INPUTS:
+*       weight - access sequence of the queue
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysSetQoSWeight
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_QoS_WEIGHT    *weight
+);
+
+/*******************************************************************************
+* gsysGetQoSWeight
+*
+* DESCRIPTION:
+*       Programmable Round Robin Weights.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and
+*        Queue 0 has the lowest priority. When a scheduling mode of port is
+*        configured as Weighted Round Robin queuing mode, the access sequece of the
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This routine retrieves the access sequence of the Queue.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       weight - access sequence of the queue
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysGetQoSWeight
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_QoS_WEIGHT    *weight
+);
+
+
+/*
+ *    gtPortCtrl.c
+*/
+
+/*******************************************************************************
+* gsysSetJumboMode
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed to be received and transmitted
+*        from or to a given port.
+*
+* INPUTS:
+*        port - the logical port number
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gsysSetJumboMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_JUMBO_MODE   mode
+);
+
+/*******************************************************************************
+* gsysGetJumboMode
+*
+* DESCRIPTION:
+*       This routine gets the max frame size allowed to be received and transmitted
+*        from or to a given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gsysGetJumboMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_JUMBO_MODE   *mode
+);
+
+/*
+ *  gtPhyCtrl.c
+*/
+/*******************************************************************************
+* gprtGetEnergyDetect
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       mode - GT_EDETECT_MODE type
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEnergyDetect
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
+);
+
+/*******************************************************************************
+* gprtSetEnergyDetect
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*       mode - GT_EDETECT_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetEnergyDetect
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
+);
+
+
+/*
+ *    gtSysCtrl.c
+*/
+
+/*******************************************************************************
+* gsysSetRMUMode
+*
+* DESCRIPTION:
+*        Set Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10,
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote
+*        Management Response frame will be generated and sent out.
+*
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*
+* INPUTS:
+*        rmu - GT_RMU structure
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMUMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_RMU        *rmu
+);
+
+/*******************************************************************************
+* gsysGetRMUMode
+*
+* DESCRIPTION:
+*        Get Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10,
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote
+*        Management Response frame will be generated and sent out.
+*
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        rmu - GT_RMU structure
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMUMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_RMU        *rmu
+);
+
+/*******************************************************************************
+* gsysPort2Lport
+*
+* DESCRIPTION:
+*        This routine converts physical port number to logical port number.
+*
+* INPUTS:
+*        port - physical port number
+*
+* OUTPUTS:
+*        lport - logical port number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysPort2Lport
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         port,
+    OUT GT_LPORT    *lport
+);
+
+/*******************************************************************************
+* gsysLport2Port
+*
+* DESCRIPTION:
+*        This routine converts logical port number to physical port number.
+*
+* INPUTS:
+*        lport - logical port number
+*
+* OUTPUTS:
+*        port - physical port number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysLport2Port
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    lport,
+    OUT GT_U32         *port
+);
+
+/*******************************************************************************
+* gsysPortvec2Lportvec
+*
+* DESCRIPTION:
+*        This routine converts physical port vector to logical port vector.
+*
+* INPUTS:
+*        portvec - physical port vector
+*
+* OUTPUTS:
+*        lportvec - logical port vector
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysPortvec2Lportvec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        portvec,
+    OUT GT_U32         *lportvec
+);
+
+/*******************************************************************************
+* gsysLportvec2Portvec
+*
+* DESCRIPTION:
+*        This routine converts logical port vector to physical port vector.
+*
+* INPUTS:
+*        lportvec - logical port vector
+*
+* OUTPUTS:
+*        portvec - physical port vector
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysLportvec2Portvec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        lportvec,
+    OUT GT_U32         *portvec
+);
+
+
+/*
+ * gtPIRL.c
+ */
+
+/*******************************************************************************
+* gpirlSetCurTimeUpInt
+*
+* DESCRIPTION:
+*       This function sets the current time update interval.
+*        Please contact FAE for detailed information.
+*
+* INPUTS:
+*       upInt - updata interval (0 ~ 7)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpirlSetCurTimeUpInt
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                upInt
+);
+
+
+/*
+ * gtPIRL2.c
+ */
+
+/*******************************************************************************
+* gpirl2SetCurTimeUpInt
+*
+* DESCRIPTION:
+*       This function sets the current time update interval.
+*        Please contact FAE for detailed information.
+*
+* INPUTS:
+*       upInt - updata interval (0 ~ 7)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpirl2SetCurTimeUpInt
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                upInt
+);
+
+
+/*
+ * gtPTP.c
+ */
+
+/*******************************************************************************
+* gptpSetConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpGetConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpSetGlobalConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP global configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP global configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetGlobalConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_GLOBAL_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpGetGlobalConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP global configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP global configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetGlobalConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_GLOBAL_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpSetPortConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP port configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP port configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_PORT_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpGetPortConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP configuration parameters for a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP port configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_PORT_CONFIG    *ptpData
+);
+
+/*******************************************************************************
+* gptpSetPTPEn
+*
+* DESCRIPTION:
+*       This routine enables or disables PTP.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+);
+
+/*******************************************************************************
+* gptpGetPTPEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gptpSetPortTsMode
+*
+* DESCRIPTION:
+*       This routine set PTP arrive 0 TS mode on a port.
+*
+* INPUTS:
+*        tsMod - GT_PTP_TS_MODE_IN_REG
+*                GT_PTP_TS_MODE_IN_RESERVED_2
+*                GT_PTP_TS_MODE_IN_FRAME_END
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortTsMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_TS_MODE  tsMode
+);
+
+/*******************************************************************************
+* gptpGetPortTsMode
+*
+* DESCRIPTION:
+*       This routine get PTP arrive 0 TS mode on a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        tsMod - GT_PTP_TS_MODE_IN_REG
+*                GT_PTP_TS_MODE_IN_RESERVED_2
+*                GT_PTP_TS_MODE_IN_FRAME_END
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortTsMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_TS_MODE  *tsMode
+);
+
+/*******************************************************************************
+* gptpSetPortPTPEn
+*
+* DESCRIPTION:
+*       This routine enables or disables PTP on a port.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+);
+
+/*******************************************************************************
+* gptpGetPortPTPEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP is enabled on a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+);
+
+
+/*******************************************************************************
+* gptpGetPTPInt
+*
+* DESCRIPTION:
+*       This routine gets PTP interrupt status for each port.
+*        The PTP Interrupt bit gets set for a given port when an incoming PTP
+*        frame is time stamped and PTPArrIntEn for that port is set to 0x1.
+*        Similary PTP Interrupt bit gets set for a given port when an outgoing
+*        PTP frame is time stamped and PTPDepIntEn for that port is set to 0x1.
+*        This bit gets cleared upon software reading and clearing the corresponding
+*        time counter valid bits that are valid for that port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt     - interrupt status for each port (bit 0 for port 0, bit 1 for port 1, etc.)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
+);
+
+/*******************************************************************************
+* gptpGetPTPGlobalTime
+*
+* DESCRIPTION:
+*       This routine gets the global timer value that is running off of the free
+*        running switch core clock.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpTime    - PTP global time
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPGlobalTime
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpTime
+);
+
+/*******************************************************************************
+* gptpGetTimeStamped
+*
+* DESCRIPTION:
+*        This routine retrieves the PTP port status that includes time stamp value
+*        and sequce Id that are captured by PTP logic for a PTP frame that needs
+*        to be time stamped.
+*
+* INPUTS:
+*       port         - logical port number.
+*       timeToRead    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*
+* OUTPUTS:
+*        ptpStatus    - PTP port status
+*
+* RETURNS:
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetTimeStamped
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToRead,
+    OUT GT_PTP_TS_STATUS    *ptpStatus
+);
+
+/*******************************************************************************
+* gptpResetTimeStamp
+*
+* DESCRIPTION:
+*        This routine resets PTP Time valid bit so that PTP logic can time stamp
+*        a next PTP frame that needs to be time stamped.
+*
+* INPUTS:
+*       port         - logical port number.
+*       timeToReset    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpResetTimeStamp
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToReset
+);
+
+/*******************************************************************************
+* gptpGetReg
+*
+* DESCRIPTION:
+*       This routine reads PTP register.
+*
+* INPUTS:
+*       port         - logical port number.
+*       regOffset    - register to read
+*
+* OUTPUTS:
+*        data        - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    OUT GT_U32        *data
+);
+
+/*******************************************************************************
+* gptpSetReg
+*
+* DESCRIPTION:
+*       This routine writes data to PTP register.
+*
+* INPUTS:
+*       port         - logical port number
+*       regOffset    - register to be written
+*        data        - data to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    IN  GT_U32        data
+);
+
+
+#ifdef CONFIG_AVB_FPGA
+
+/*******************************************************************************
+* gptpSetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine sets interrupt status of PTP logic.
+*
+* INPUTS:
+*        intStatus    - PTP Int Status
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    intStatus
+);
+
+
+/*******************************************************************************
+* gptpGetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine gets interrupt status of PTP logic.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus    - PTP Int Status
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    *intStatus
+);
+
+
+/*******************************************************************************
+* gptpSetFPGAIntEn
+*
+* DESCRIPTION:
+*       This routine enables PTP interrupt.
+*
+* INPUTS:
+*        intEn    - enable/disable PTP interrupt (1 to enable, 0 to disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    intEn
+);
+
+/*******************************************************************************
+* gptpGetClockSource
+*
+* DESCRIPTION:
+*       This routine gets PTP Clock source mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
+);
+
+/*******************************************************************************
+* gptpSetClockSource
+*
+* DESCRIPTION:
+*       This routine sets PTP Clock source mode.
+*
+* INPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
+);
+
+/*******************************************************************************
+* gptpGetP9Mode
+*
+* DESCRIPTION:
+*       This routine gets Port 9 Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
+);
+
+/*******************************************************************************
+* gptpSetP9Mode
+*
+* DESCRIPTION:
+*       This routine sets Port 9 Mode.
+*
+* INPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
+);
+
+/*******************************************************************************
+* gptpReset
+*
+* DESCRIPTION:
+*       This routine performs software reset for PTP logic.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpReset
+(
+    IN  GT_QD_DEV     *dev
+);
+
+
+/*******************************************************************************
+* gptpGetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
+);
+
+
+/*******************************************************************************
+* gptpSetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PTP Duty Cycle Adjustment.
+*
+* INPUTS:
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
+);
+
+
+/*******************************************************************************
+* gptpGetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine gets clock duty cycle adjustment value.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT        *adj
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine sets clock duty cycle adjustment value.
+*
+* INPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT        *adj
+);
+
+/*******************************************************************************
+* gptpGetPLLEn
+*
+* DESCRIPTION:
+*       This routine checks if PLL is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpGetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
+);
+
+/*******************************************************************************
+* gptpSetPLLEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpSetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
+);
+#endif
+
+/* Amber APIs */
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbGetMacAvb
+*
+* DESCRIPTION:
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and
+*            GT_UC_STATIC_AVB_ENTRY
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
+*
+*        When disabled, ATU entries operate in non-AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and
+*            GT_UC_STATIC_NRL
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if MacAvb is enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*
+*******************************************************************************/
+GT_STATUS gfdbGetMacAvb
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *mode
+);
+
+/*******************************************************************************
+* gfdbSetMacAvb
+*
+* DESCRIPTION:
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and
+*            GT_UC_STATIC_AVB_ENTRY
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
+*
+*        When disabled, ATU entries operate in non-AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and
+*            GT_UC_STATIC_NRL
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*
+* INPUTS:
+*        mode - GT_TRUE to enable MacAvb, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetMacAvb
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gfdbGetPortAtuLearnLimit
+*
+* DESCRIPTION:
+*      Port's auto learning limit. When the limit is non-zero value, the number
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame
+*        that ingresses this port with a source MAC address not already in the
+*        address database that is associated with this port will be discarded.
+*        Normal auto-learning will resume on the port as soon as the number of
+*        active unicast MAC addresses associated to this port is less than the
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) dsable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
+*
+* INPUTS:
+*        port  - logical port number
+*
+* OUTPUTS:
+*        limit - auto learning limit ( 0 ~ 255 )
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetPortAtuLearnLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    OUT GT_U32       *limit
+);
+
+/* gtPCSCtrl.c */
+
+/*******************************************************************************
+* gpcsGetRGMIITimingDelay
+*
+* DESCRIPTION:
+*        RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
+*        IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
+*        Change to this bit are disruptive to normal operation. Hence any changes
+*        to this register must be done only while the port's link is down.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
+*        txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetRGMIITimingDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *rxmode,
+    OUT GT_BOOL      *txmode
+);
+
+/*******************************************************************************
+* gpcsSetRGMIITimingDelay
+*
+* DESCRIPTION:
+*        RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
+*        IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
+*        Change to this bit are disruptive to normal operation. Hence any changes
+*        to this register must be done only while the port's link is down.
+*
+* INPUTS:
+*        port - the logical port number.
+*        rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
+*        txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetRGMIITimingDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      rxmode,
+    IN  GT_BOOL      txmode
+);
+
+
+/* gtPortLed.c */
+
+/*******************************************************************************
+* gprtSetLED
+*
+* DESCRIPTION:
+*        This API allows to configure 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
+*
+* INPUTS:
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
+*        value     - value to be configured
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtSetLED
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value
+);
+
+
+/*******************************************************************************
+* gprtGetLED
+*
+* DESCRIPTION:
+*        This API allows to retrieve 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
+*
+* INPUTS:
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
+*
+* OUTPUTS:
+*        value     - configured value
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtGetLED
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    OUT GT_U32        *value
+);
+
+
+
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetQSizePerQPri
+*
+* DESCRIPTION:
+*        This routine gets egress queue size for port's each QPri (0 ~ 3).
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        counts - egress queue size per QPri (should be 4 * 16bytes)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetQSizePerQPri
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *counts
+);
+
+
+/* gtSysCtrl.c */
+
+
+/*******************************************************************************
+* gsysGetARPwoBC
+*
+* DESCRIPTION:
+*       ARP detection without Broadcast checking. When enabled the switch core
+*       does not check for a Btoadcast MAC address as part of the ARP frame
+*       detection. It only checkes the Ether Type (0x0806).
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE if enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetARPwoBC
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gsysSetARPwoBC
+*
+* DESCRIPTION:
+*       ARP detection without Broadcast checking. When enabled the switch core
+*       does not check for a Btoadcast MAC address as part of the ARP frame
+*       detection. It only checkes the Ether Type (0x0806).
+*
+* INPUTS:
+*       en - GT_TRUE to enable, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetARPwoBC
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL     en
+);
+
+
+/*******************************************************************************
+* gsysGetCLK125En
+*
+* DESCRIPTION:
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 125MHz clock is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetCLK125En
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+);
+
+
+/*******************************************************************************
+* gsysSetCLK125En
+*
+* DESCRIPTION:
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
+*
+* INPUTS:
+*        en - GT_TRUE to enable 125 MHz clock, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetCLK125En
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+);
+
+
+/* gtPriTable.c */
+
+/*******************************************************************************
+* gsysSetFPriOverrideTable
+*
+* DESCRIPTION:
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysSetFPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_FPRI_TBL_ENTRY    *entry
+);
+
+
+/*******************************************************************************
+* gsysGetFPriOverrideTable
+*
+* DESCRIPTION:
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_BAD_PARAM     - on unknown frame type
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysGetFPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_FPRI_TBL_ENTRY    *entry
+);
+
+
+/*******************************************************************************
+* gsysSetQPriAvbOverrideTable
+*
+* DESCRIPTION:
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysSetQPriAvbOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
+);
+
+
+/*******************************************************************************
+* gsysGetQPriAvbOverrideTable
+*
+* DESCRIPTION:
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysGetQPriAvbOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtGet200Base
+*
+* DESCRIPTION:
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*        0 = 25MHz Px_GTXCLK
+*        1 = 50MHz Px_GTXCLK
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - 0 for 100Mbps, 1 for 200Mbps
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        C_Mode should be set to 0x2 in order for this API to work
+*
+*******************************************************************************/
+GT_STATUS gprtGet200Base
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_U32      *mode
+);
+
+
+/*******************************************************************************
+* gprtSet200Base
+*
+* DESCRIPTION:
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*            0 = 25MHz Px_GTXCLK
+*            1 = 50MHz Px_GTXCLK
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - 0 for 100Mbps, 1 for 200Mbps
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        C_Mode should be set to 0x2 in order for this API to work
+*
+*******************************************************************************/
+GT_STATUS gprtSet200Base
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32      mode
+);
+
+
+/*******************************************************************************
+* gprtSetQueueCtrl
+*
+* DESCRIPTION:
+*        Set port queue control data to the Port Queue Control register.
+*        The registers of Port Queue control are.
+*         Hard Queue Limits register space
+*         Reserved for future Hard Queue Limits use
+*
+* INPUTS:
+*        port  - logical port number
+*        point - Pointer to the Port Queue Control register.
+*        data  - Port Queue Control data written to the register
+*                pointed to by the point above.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtSetQueueCtrl
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    IN  GT_U32           point,
+    IN  GT_U8            data
+);
+
+/*******************************************************************************
+* gprtGetQueueCtrl
+*
+* DESCRIPTION:
+*        Get port queue control data from the Port Queue Control register.
+*        The registers of Port Queue control are.
+*         Hard Queue Limits register space
+*         Reserved for future Hard Queue Limits use
+*
+* INPUTS:
+*        port  - logical port number
+*        point - Pointer to the Port Queue Control register.
+*
+* OUTPUTS:
+*        data  - Port Queue Control data written to the register
+*                pointed to by the point above.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtGetQueueCtrl
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    IN  GT_U32           point,
+    OUT GT_U8            *data
+);
+
+/*******************************************************************************
+* gprtGetDebugCounter
+*
+* DESCRIPTION:
+*        Get Port Debug Counter, bad counter and good counter.
+*
+* INPUTS:
+*        port  - logical port number
+*
+* OUTPUTS:
+*        badCounter  - When CtrMode is cleared to a zero (Global 1 offset 0x1C) this
+*  counter increments each time a frame enters this port that was an error on the
+*  wire. It does not matter if the frames CRC is fixed by ForceGoodFCS (Port
+*  offset 0x08) being set to a one, this counter will still increment. A CRC error
+*  frame is one that is 64 bytes to MaxFrameSize (Global 1, offset 0x04) with a
+*  bad CRC (including alignment errors but not dribbles). Fragments and
+*  properly formed frames are not counted. The RxBadFrames counter counts
+*  frames that are counted in the MIB counters as InUndersize, InOversize,
+*  InJabber, InRxErr and InFCSErr.
+*  When CtrMode is set to a one this counter increments each time a transmit
+*  collision occurs on this port.
+*        goodCounter  - When CtrMode is cleared to a zero (Global 1 offset 0x1C) this
+*  counter increments each time a frame enters this port that was not an error
+*  frame on the wire. It does not matter if the frame was filtered or discarded,
+*  only that the frame was received as good on the wire (i.e., its wire size is in the
+*  range of 64 bytes to MaxFrameSize (Global 1, offset 0x04) and its CRC was
+*  good. The RxGoodFrames counter counts frames that are not counted
+*  above as long as they are not being counted in the MIB counters as
+*  InFragments.
+*  When CtrMode is set to a one this counter increments each time a frame is
+*  transmitted out this port.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtGetDebugCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    OUT  GT_U8            *badCounter,
+    OUT  GT_U8            *goodCounter
+);
+
+/*******************************************************************************
+* gprtSetCutThrough
+*
+* DESCRIPTION:
+*        Set port Cut Through configuration.
+*
+* INPUTS:
+*        port  - logical port number
+*        cutThru - Cut through configuration.
+*                    enableSelect;     Port Enable Select.
+*                    enable;           Cut Through enable.
+*                    cutThruQueue;     Cut Through Queues.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtSetCutThrough
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    IN  GT_CUT_THROUGH   *cutThru
+);
+
+/*******************************************************************************
+* gprtGetCutThrough
+*
+* DESCRIPTION:
+*        Get port Cut Through configuration.
+*
+* INPUTS:
+*        port  - logical port number
+*
+* OUTPUTS:
+*        cutThru - Cut through configuration.
+*                    enableSelect;     Port Enable Select.
+*                    enable;           Cut Through enable.
+*                    cutThruQueue;     Cut Through Queues.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtGetCutThrough
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    OUT GT_CUT_THROUGH   *cutThru
+);
+
+/* gtPIRL2.c */
+
+/*******************************************************************************
+* gpirl2WriteTSMResource
+*
+* DESCRIPTION:
+*        This routine writes rate resource bucket parameters in Time Slot Metering
+*        mode to the given resource of the port.
+*
+* INPUTS:
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*        pirlData - PIRL TSM resource parameters.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Only Resource 0 and 1 can be supported for TSM Mode.
+*
+*******************************************************************************/
+GT_STATUS gpirl2WriteTSMResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    IN  GT_PIRL2_TSM_DATA    *pirlData
+);
+
+
+/*******************************************************************************
+* gpirl2ReadTSMResource
+*
+* DESCRIPTION:
+*        This routine retrieves IRL Parameter.
+*        Returned ingressRate would be rough number. Instead, customSetup will
+*        have the exact configured value.
+*
+* INPUTS:
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Only Resource 0 and 1 can be supported for TSM Mode.
+*
+*******************************************************************************/
+GT_STATUS gpirl2ReadTSMResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    OUT GT_PIRL2_TSM_DATA    *pirlData
+);
+
+
+/* gtPTP.c */
+
+/*******************************************************************************
+* gtaiSetEventConfig
+*
+* DESCRIPTION:
+*       This routine sets TAI Event Capture configuration parameters.
+*
+* INPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetEventConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_EVENT_CONFIG    *eventData
+);
+
+
+/*******************************************************************************
+* gtaiGetEventConfig
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_CONFIG    *eventData
+);
+
+/*******************************************************************************
+* gtaiGetEventStatus
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_STATUS    *status
+);
+
+/*******************************************************************************
+* gtaiGetEventInt
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus     - interrupt status for TAI Event capture
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
+);
+
+/*******************************************************************************
+* gtaiClearEventInt
+*
+* DESCRIPTION:
+*       This routine clear TAI Event Capture Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiClearEventInt
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gtaiSetClockSelect
+*
+* DESCRIPTION:
+*       This routine sets several clock select in TAI.
+*
+* INPUTS:
+*        clkSelect  - TAI clock select configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_CLOCK_SELECT    *clkSelect
+);
+
+/*******************************************************************************
+* gtaiGetClockSelect
+*
+* DESCRIPTION:
+*       This routine gets several clock select in TAI.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       clkSelect  - TAI clock select configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_TAI_CLOCK_SELECT    *clkSelect
+);
+
+/*******************************************************************************
+* gtaiGetTrigInt
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus     - interrupt status for TAI Trigger
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
+);
+
+/*******************************************************************************
+* gtaiClearTrigInt
+*
+* DESCRIPTION:
+*       This routine clear TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiClearTrigInt
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gtaiSetTrigConfig
+*
+* DESCRIPTION:
+*       This routine sets TAI Trigger configuration parameters.
+*
+* INPUTS:
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTrigConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     trigEn,
+    IN  GT_TAI_TRIGGER_CONFIG    *trigData
+);
+
+/*******************************************************************************
+* gtaiGetTrigConfig
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *trigEn,
+    OUT GT_TAI_TRIGGER_CONFIG    *trigData
+);
+
+
+/*******************************************************************************
+* gtaiSetTrigLock
+*
+* DESCRIPTION:
+*       This routine sets TAI Trigger lock.
+*
+* INPUTS:
+*        trigLock       - trigger lock set.
+*        trigLockRange  - trigger lock range.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTrigLock
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL    trigLock,
+    IN  GT_U8      trigLockRange
+);
+
+/*******************************************************************************
+* gtaiGetTrigLock
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger lock and trigger lock range.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        trigLock       - trigger lock set.
+*        trigLockRange  - trigger lock range.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigLock
+(
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_BOOL    *trigLock,
+    OUT  GT_U8      *trigLockRange
+);
+
+/*******************************************************************************
+* gtaiGetTSClkPer
+*
+* DESCRIPTION:
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP
+*        Global Time Counter.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        clk        - time stamping clock period
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTSClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *clk
+);
+
+
+/*******************************************************************************
+* gtaiSetTSClkPer
+*
+* DESCRIPTION:
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP
+*        Global Time Counter.
+*
+* INPUTS:
+*        clk        - time stamping clock period
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTSClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        clk
+);
+
+/*******************************************************************************
+* gtaiSetMultiPTPSync
+*
+* DESCRIPTION:
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
+*
+* INPUTS:
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
+*
+*******************************************************************************/
+GT_STATUS gtaiSetMultiPTPSync
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     multiEn,
+    IN  GT_32        syncTime
+);
+
+/*******************************************************************************
+* gtaiGetMultiPTPSync
+*
+* DESCRIPTION:
+*         This routine gets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
+*
+*******************************************************************************/
+GT_STATUS gtaiGetMultiPTPSync
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *multiEn,
+    OUT GT_32        *syncTime
+);
+
+/*******************************************************************************
+* gtaiGetTimeIncDec
+*
+* DESCRIPTION:
+*         This routine retrieves Time increment/decrement setup.
+*        This amount specifies the number of units of PTP Global Time that need to be
+*        incremented or decremented. This is used for adjusting the PTP Global Time
+*        counter value by a certain amount.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        inc        - GT_TRUE if increment, GT_FALSE if decrement
+*        amount    - increment/decrement amount
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTimeIncDec
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_BOOL        *inc,
+    OUT GT_U32        *amount
+);
+
+/*******************************************************************************
+* gtaiSetTimeInc
+*
+* DESCRIPTION:
+*         This routine enables time increment by the specifed time increment amount.
+*        The amount specifies the number of units of PTP Global Time that need to be
+*        incremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Increment occurs just once.
+*
+* INPUTS:
+*        amount    - time increment amount (0 ~ 0xFF)
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTimeInc
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
+);
+
+/*******************************************************************************
+* gtaiSetTimeDec
+*
+* DESCRIPTION:
+*         This routine enables time decrement by the specifed time decrement amount.
+*        The amount specifies the number of units of PTP Global Time that need to be
+*        decremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Decrement occurs just once.
+*
+* INPUTS:
+*        amount    - time decrement amount (0 ~ 0x7FF)
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTimeDec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
+);
+
+
+/*******************************************************************************
+* gavbGetPriority
+*
+* DESCRIPTION:
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
+*
+* INPUTS:
+*         priType    - GT_AVB_PRI_TYPE
+*
+* OUTPUTS:
+*        pri    - priority
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetPriority
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    OUT GT_U32        *pri
+);
+
+/*******************************************************************************
+* gavbSetPriority
+*
+* DESCRIPTION:
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
+*
+* INPUTS:
+*         priType    - GT_AVB_PRI_TYPE
+*        pri    - priority
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetPriority
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    IN  GT_U32        pri
+);
+
+/*******************************************************************************
+* gavbGetAVBHiLimit
+*
+* DESCRIPTION:
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs.
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override
+*        Table
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        limit    - Hi Frame Limit
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAVBHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *limit
+);
+
+/*******************************************************************************
+* gavbSetAVBHiLimit
+*
+* DESCRIPTION:
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs.
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override
+*        Table
+*
+* INPUTS:
+*        limit    - Hi Frame Limit
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAVBHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        limit
+);
+
+/*******************************************************************************
+* gavbGetPtpExtClk
+*
+* DESCRIPTION:
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from
+*        an internal 125MHz clock based on the device's XTAL_IN input.
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetPtpExtClk
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *extClk
+);
+
+/*******************************************************************************
+* gavbSetPtpExtClk
+*
+* DESCRIPTION:
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from
+*        an internal 125MHz clock based on the device's XTAL_IN input.
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
+*
+* INPUTS:
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetPtpExtClk
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        extClk
+);
+
+/*******************************************************************************
+* gavbGetRecClkSel
+*
+* DESCRIPTION:
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*
+* INPUTS:
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
+*
+* OUTPUTS:
+*        clkSel    - recovered clock selection
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetRecClkSel
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    OUT GT_U32        *clkSel
+);
+
+
+/*******************************************************************************
+* gavbSetRecClkSel
+*
+* DESCRIPTION:
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*
+* INPUTS:
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
+*        clkSel    - recovered clock selection (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetRecClkSel
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    IN  GT_U32        clkSel
+);
+
+/*******************************************************************************
+* gavbGetAvbOuiBytes
+*
+* DESCRIPTION:
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three
+*        AvbOui Bytes or the frame will be filtered.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbOuiBytes
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *obiBytes
+);
+
+/*******************************************************************************
+* gavbSetAvbOuiBytes
+*
+* DESCRIPTION:
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three
+*        AvbOui Bytes or the frame will be filtered.
+*
+* INPUTS:
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbOuiBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        *obiBytes
+);
+
+/*******************************************************************************
+* gavbGetAvbMode
+*
+* DESCRIPTION:
+*        Port's AVB Mode.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        mode    - GT_AVB_MODE type
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_AVB_MODE    *mode
+);
+
+/*******************************************************************************
+* gavbSetAvbMode
+*
+* DESCRIPTION:
+*        Port's AVB Mode.
+*
+* INPUTS:
+*        port    - the logical port number
+*        mode    - GT_AVB_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_AVB_MODE    mode
+);
+
+/*******************************************************************************
+* gavbGetAvbOverride
+*
+* DESCRIPTION:
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if
+*        the ingress portion is not.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbOverride
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gavbSetAvbOverride
+*
+* DESCRIPTION:
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if
+*        the ingress portion is not.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbOverride
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+);
+
+
+/*******************************************************************************
+* gavbGetFilterBadAvb
+*
+* DESCRIPTION:
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetFilterBadAvb
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gavbSetFilterBadAvb
+*
+* DESCRIPTION:
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetFilterBadAvb
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+);
+
+
+/*******************************************************************************
+* gavbGetAvbTunnel
+*
+* DESCRIPTION:
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbTunnel
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+);
+
+
+/*******************************************************************************
+* gavbSetAvbTunnel
+*
+* DESCRIPTION:
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbTunnel
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+);
+
+
+/*******************************************************************************
+* gavbGetAvbFramePolicy
+*
+* DESCRIPTION:
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
+*
+* INPUTS:
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE
+*
+* OUTPUTS:
+*        policy    - GT_AVB_FRAME_POLICY
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbFramePolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    OUT GT_AVB_FRAME_POLICY        *policy
+);
+
+
+/*******************************************************************************
+* gavbSetAvbFramePolicy
+*
+* DESCRIPTION:
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
+*
+* INPUTS:
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE
+*        policy    - GT_AVB_FRAME_POLICY
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbFramePolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    IN  GT_AVB_FRAME_POLICY        policy
+);
+
+/* Amber QAV API */
+/*******************************************************************************/
+/* Amber QAV API */
+/*******************************************************************************
+* gqavSetPortQpriXQTSToken
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each
+*        QTS interval boundary.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue     - 0 - 3
+*        qtsToken - number of tokens.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXQTSToken
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        qtsToken
+);
+
+/*******************************************************************************
+* gqavGetPortQpriXQTSToken
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each
+*        QTS interval boundary.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 0 - 3
+*
+* OUTPUTS:
+*        qtsToken - number of tokens
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXQTSToken
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *qtsToken
+);
+
+/*******************************************************************************
+* gqavSetPortQpriXBurstBytes
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be
+*        accumulated when the queue is blocked from sending out a frame due to
+*        higher priority queue frames being sent out.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 0 - 3
+*        burst - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXBurstBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        burst
+);
+
+/*******************************************************************************
+* gqavGetPortQpriXBurstBytes
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be
+*        accumulated when the queue is blocked from sending out a frame due to
+*        higher priority queue frames being sent out.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 0 - 3
+*
+* OUTPUTS:
+*        burst - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXBurstBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *burst
+);
+
+/*******************************************************************************
+* gqavSetPortQavEnable
+*
+* DESCRIPTION:
+*        This routine set QAV enable status on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQavEnable
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+);
+
+/*******************************************************************************
+* gqavSetPortQpriXRate
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 2-3 rate on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 2 - 3
+*        rate - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXRate
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        rate
+);
+
+/*******************************************************************************
+* gqavGetPortQpriXRate
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 2-3 rate Bytes on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 2 - 3
+*
+* OUTPUTS:
+*        rate - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXRate
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *rate
+);
+
+/*******************************************************************************
+* gqavSetPortQpriXHiLimit
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 2-3 HiLimit on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 2 - 3
+*        hiLimit - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        hiLimit
+);
+
+/*******************************************************************************
+* gqavGetPortQpriXHiLimit
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 2-3 HiLimit Bytes on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 2 - 3
+*
+* OUTPUTS:
+*        hiLimit - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *hiLimit
+);
+
+/*******************************************************************************
+* gqavGetPortQavEnable
+*
+* DESCRIPTION:
+*        This routine get QAV enable status on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQavEnable
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************/
+/* QAV Global registers processing */
+/*******************************************************************************
+* gqavSetGlobalAdminMGMT
+*
+* DESCRIPTION:
+*        This routine set to accept Admit Management Frames always.
+*
+* INPUTS:
+*        en - GT_TRUE to set MGMT frame accepted always,
+*             GT_FALSE do not set MGMT frame accepted always
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalAdminMGMT
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+);
+
+/*******************************************************************************
+* gqavGetGlobalAdminMGMT
+*
+* DESCRIPTION:
+*        This routine get setting of Admit Management Frames always.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to set MGMT frame accepted always,
+*             GT_FALSE do not set MGMT frame accepted always
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalAdminMGMT
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoPtrThreshold
+*
+* DESCRIPTION:
+*        This routine set Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers
+*        that are reserved for isochronous streams. The value is expected to be
+*        computed in SRP software and programmed into hardware based on the total
+*        aggregate isochronous streams configured to go through this device..
+*
+* INPUTS:
+*        isoPtrs -  total number of isochronous pointers
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoPtrThreshold
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        isoPtrs
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoPtrThreshold
+*
+* DESCRIPTION:
+*        This routine get Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers
+*        that are reserved for isochronous streams. The value is expected to be
+*        computed in SRP software and programmed into hardware based on the total
+*        aggregate isochronous streams configured to go through this device..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        isoPtrs -  total number of isochronous pointers
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoPtrThreshold
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *isoPtrs
+);
+
+/*******************************************************************************
+* gqavSetGlobalDisQSD4MGMT
+*
+* DESCRIPTION:
+*        This routine set Disable Queue Scheduler Delays for Management frames..
+*
+* INPUTS:
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalDisQSD4MGMT
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+);
+
+/*******************************************************************************
+* gqavGetGlobalDisQSD4MGMT
+*
+* DESCRIPTION:
+*        This routine Get Disable Queue Scheduler Delays for Management frames..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalDisQSD4MGMT
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gqavSetGlobalInterrupt
+*
+* DESCRIPTION:
+*        This routine set QAV interrupt enable,
+*        The QAV interrypts include:
+*        [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                              Interrupt Enable
+*
+* INPUTS:
+*        intEn - [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalInterrupt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        intEn
+);
+
+/*******************************************************************************
+* gqavGetGlobalInterrupt
+*
+* DESCRIPTION:
+*       This routine get QAV interrupt status and enable status,
+*        The QAV interrypt status include:
+*         [GT_QAV_INT_STATUS_ENQ_LMT_BIT]      # Enqueue Delay Limit exceeded
+*         [GT_QAV_INT_STATUS_ISO_DEL_BIT]      # Iso Delay Interrupt Status
+*         [GT_QAV_INT_STATUS_ISO_DIS_BIT]      # Iso Discard Interrupt Status
+*         [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                                Interrupt Status
+*        The QAV interrypt enable status include:
+*         [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                                  Interrupt Enable
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        intEnSt - [GT_QAV_INT_STATUS_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] OR
+*                [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalInterrupt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *intEnSt
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoInterruptPort
+*
+* DESCRIPTION:
+*        This routine get Isochronous interrupt port.
+*        This field indicates the port number for IsoDisInt or IsoLimitExInt
+*        bits. Only one such interrupt condition can be detected by hardware at one
+*        time. Once an interrupt bit has been set along with the IsoIntPort, the
+*        software would have to come and clear the bits before hardware records
+*        another interrupt event.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - port number for IsoDisInt or IsoLimitExInt bits.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoInterruptPort
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *port
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoDelayLmt
+*
+* DESCRIPTION:
+*        This routine set Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that
+*        will be checked by the queue controller logic to ensure no isochronous
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
+*
+* INPUTS:
+*        limit - per-port isochronous delay limit.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoDelayLmt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        limit
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoDelayLmt
+*
+* DESCRIPTION:
+*        This routine get Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that
+*        will be checked by the queue controller logic to ensure no isochronous
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        limit - per-port isochronous delay limit.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoDelayLmt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *limit
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoMonEn
+*
+* DESCRIPTION:
+*       This routine set Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
+*
+* INPUTS:
+*        en - GT_TRUE / GT_FALSE.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoMonEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoMonEn
+*
+* DESCRIPTION:
+*        This routine get Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE / GT_FALSE.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoMonEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoMonPort
+*
+* DESCRIPTION:
+*        This routine set Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit
+*        (Qav Global Status, offset 0xD) and it indicates the port number that
+*        the software wants the hardware to start monitoring i.e., start updating
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears
+*        the above stats when IsoMonPort is changed..
+*
+* INPUTS:
+*        port -  port number .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoMonPort
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        port
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoMonPort
+*
+* DESCRIPTION:
+*        This routine get Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit
+*        (Qav Global Status, offset 0xD) and it indicates the port number that
+*        the software wants the hardware to start monitoring i.e., start updating
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears
+*        the above stats when IsoMonPort is changed..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port -  port number.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoMonPort
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *port
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoHiDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous hi packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        disCtr - upcounter of number of isochronous hi packets discarded
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoHiDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        disCtr
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoHiDisCtr
+*
+* DESCRIPTION:
+*        This routine get Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous hi packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        disCtr - upcounter of number of isochronous hi packets discarded
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoHiDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *disCtr
+);
+
+/*******************************************************************************
+* gqavSetGlobalIsoLoDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous lo packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        disCtr - upcounter of number of isochronous lo packets discarded
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoLoDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        disCtr
+);
+
+/*******************************************************************************
+* gqavGetGlobalIsoLoDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous lo packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        disCtr - upcounter of number of isochronous lo packets discarded
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoLoDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *disCtr
+);
+
+/*******************************************************************************
+* gsysSetUseIpMappingTable
+*
+* DESCRIPTION:
+*        This API set to use IP Frame Priorities from this table.
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*
+* INPUTS:
+*        en    - [GT_TRUE] / [GT_FALSE]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetUseIpMappingTable
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_BOOL            en
+);
+
+/*******************************************************************************
+* gsysGetUseIpMappingTable
+*
+* DESCRIPTION:
+*        This API get to use IP Frame Priorities from this table.
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en    - [GT_TRUE] / [GT_FALSE]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetUseIpMappingTable
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_BOOL            *en
+);
+
+/*******************************************************************************
+* gsysSetIpMappingPrio
+*
+* DESCRIPTION:
+*        Set IPv4 and IPv6 Frame Priority Mapping, and
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frames initial FPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04)
+*        is configured to use IP FPris.
+*       The ipQpri value is used as the frames initial QPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth
+*        registers (Port offset 0x04) are configured to use IP QPris.
+*
+* INPUTS:
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetIpMappingPrio
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    IN  GT_U8            ipFpri,
+    IN  GT_U8            ipQpri
+);
+
+/*******************************************************************************
+* gsysGetIpMappingPrio
+*
+* DESCRIPTION:
+*        Get IPv4 and IPv6 Frame Priority Mapping, and
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frames initial FPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04)
+*        is configured to use IP FPris.
+*        The ipQpri value is used as the frames initial QPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth
+*        registers (Port offset 0x04) are configured to use IP QPris.
+*
+* INPUTS:
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
+*
+* OUTPUTS:
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetIpMappingPrio
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    OUT  GT_U8            *ipFpri,
+    OUT  GT_U8            *ipQpri
+);
+
+/*******************************************************************************
+* gsysReadEeprom
+*
+* DESCRIPTION:
+*        Read EEPROM from EEPROMs address where the EEOp is performed.
+*
+* INPUTS:
+*        addr - EEPROM Address.
+*
+* OUTPUTS:
+*        data -  Data that was read back from the EEPROM.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysReadEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr,
+    OUT  GT_U8            *data
+);
+
+/*******************************************************************************
+* gsysWriteEeprom
+*
+* DESCRIPTION:
+*        Write EEPROM at the EEPROMs address where the EEOp is performed.
+*
+* INPUTS:
+*        addr - EEPROM Address.
+*        data - Data to be written to the EEPROM
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysWriteEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr,
+    IN  GT_U8            data
+);
+
+/*******************************************************************************
+* gsysRestartEeprom
+*
+* DESCRIPTION:
+*        Restart Register Loader execution at the EEPROMs address where the EEOp
+*        is performed
+*
+* INPUTS:
+*        addr - EEPROM Address. .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysRestartEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr
+);
+
+/*******************************************************************************
+* gsysHaltEeprom
+*
+* DESCRIPTION:
+*        Halt (stop executing the EEPROM if its not already stopped)
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysHaltEeprom
+(
+    IN  GT_QD_DEV         *dev
+);
+
+/*******************************************************************************
+* gsysGetStEeprom
+*
+* DESCRIPTION:
+*        Get EEPROM status. They are Register Loader Running status and EEPROM
+*        Write Enable status
+*        runSt is GT_TRUE: Register Loader Running, whenever the register loader
+*            is busy executing the instructions contained in the EEPROM.
+*        writeEn is GT_TRUE: EEPROM Write Enable, that indicates that writing to
+*            the EEPROM is possible.
+*        writeEn is GT_FALSE: the Write EEPROM EEOp above will not do anything.
+*            This reflects the value of the EE_WE configuration pin after Reset.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        runSt   -   [GT_TRUE] / [GT_FALSE)
+*        writeEn -   [GT_TRUE] / [GT_FALSE)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetStEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_BOOL            *writeEn,
+    OUT GT_BOOL            *runSt
+);
+
+/*******************************************************************************
+* gsysSetScratchMiscCtrl
+*
+* DESCRIPTION:
+*        Set Scratch and Misc control data to the Scratch and Misc Control register.
+*        The register of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
+*
+* INPUTS:
+*        point - Pointer to the Scratch and Misc. Control register.
+*        data  - Scratch and Misc. Control data written to the register
+*                pointed to by the point above.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetScratchMiscCtrl
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    IN  GT_U8            data
+);
+
+/*******************************************************************************
+* gsysGetScratchMiscCtrl
+*
+* DESCRIPTION:
+*        Get Scratch and Misc control data from the Scratch and Misc Control register.
+*        The register of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
+
+*
+* INPUTS:
+*        point - Pointer to the Scratch and Misc. Control register.
+*
+* OUTPUTS:
+*        data - Scratch and Misc. Control data read from the register
+*                pointed to by the point above.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetScratchMiscCtrl
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    OUT  GT_U8            *data
+);
+
+/*******************************************************************************
+* gsysSetScratchBits
+*
+* DESCRIPTION:
+*        Set bits to the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired.
+*        These bits do not connect to any hardware function.
+*
+* INPUTS:
+*        scritch - written bits.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetScratchBits
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U16            scratch
+);
+
+/*******************************************************************************
+* gsysGetScratchBits
+*
+* DESCRIPTION:
+*        Get bits from the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired.
+*        These bits do not connect to any hardware function.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        scritch - read bits.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetScratchBits
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U16            *scratch
+);
+
+/*******************************************************************************
+* gsysSetGpioConfigMod
+*
+* DESCRIPTION:
+*        Set bits to the Scratch and Misc Control register <GPIO Configuration>
+*        to configure GPIO mode.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only.
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
+*
+* INPUTS:
+*        mode - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetGpioConfigMod
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            mode
+);
+
+/*******************************************************************************
+* gsysGetGpioConfigMod
+*
+* DESCRIPTION:
+*        Get mode from the Scratch and Misc Control register <GPIO Configuration>.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only.
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetGpioConfigMod
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            *mode
+);
+
+/*******************************************************************************
+* gsysSetGpioDirection
+*
+* DESCRIPTION:
+*        Set Gpio direction to the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0].
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        dir - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetGpioDirection
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            dir
+);
+
+/*******************************************************************************
+* gsysGetGpioDirection
+*
+* DESCRIPTION:
+*        get Gpio direction from the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0].
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        dir - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetGpioDirection
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U32            *dir
+);
+
+/*******************************************************************************
+* gsysSetGpioData
+*
+* DESCRIPTION:
+*        Set Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go
+*        to a holding register but will not appear on the pin nor in this register.
+*        Reads of this register will return the actual, real-time, data that is
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go
+*        to a holding register and will appear on the GPIOs pin. Reads of this register
+*        will return the actual, real-time, data that is appearing on the GPIOs pin
+*        (which in this case should be the data written, but if its isnt that would
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        data - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetGpioData
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            data
+);
+
+/*******************************************************************************
+* gsysGetGpioData
+*
+* DESCRIPTION:
+*        get Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go
+*        to a holding register but will not appear on the pin nor in this register.
+*        Reads of this register will return the actual, real-time, data that is
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go
+*        to a holding register and will appear on the GPIOs pin. Reads of this register
+*        will return the actual, real-time, data that is appearing on the GPIOs pin
+*        (which in this case should be the data written, but if its isnt that would
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        data - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetGpioData
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            *data
+);
+
+/*******************************************************************************
+* gsysGetConfigData
+*
+* DESCRIPTION:
+*        Get Reset Configuration Pin Data 0-3.
+*        These registers return the values observed after a hardware Reset on the
+*        listed CONFIG data listed below.
+*            Config data 0:
+*              Bit    Config    Pin's Primary Name
+*                0    USER[0]        P6_OUTD[5]
+*                1    USER[1]        P6_OUTD[6]
+*                2    USER[2]        P6_OUTD[7]
+*                3    ADDR[0]        P5_OUTD[0]
+*                4    ADDR[1]        P5_OUTD[5]
+*                5    ADDR[2]        P5_OUTD[6]
+*                6    ADDR]3]        P5_OUTD[7]
+*                7    ADDR[4]        P5_OUTD[1]
+*            Config data 1:
+*                0    LED_SEL[0]    P1_LED
+*                1    LED_SEL[1]    P2_LED
+*                2    4COL P3_LED
+*                3    NormCx        P4_LED
+*                4    Jumbo        P0_LED
+*                5    EE_WE        EE_CS/C2_LED
+*                6    FD_FLOW        EE_CLK/C1_LED
+*                7    HD_FLOW        EE_DIN/C0_LED
+*            Config data 2:
+*                0    P5_MODE[0]    P5_OUTD[2]
+*                1    P5_MODE[1]    P5_OUTD[3]
+*                2    P5_MODE[2]    P5_OUTD[4]
+*                3    Reserved for future use
+*                4    P6_MODE[0]    P6_OUTD[2]
+*                5    P6_MODE[1]    P6_OUTD[3]
+*                6    P6_MODE[2]    P6_OUTD[4]
+*                7    Reserved for future use
+*            Config data 3:
+*                0    RMU_MODE[0] P6_OUTD[0]
+*                1    RMU_MODE[1] P6_OUTD[1]
+*                2    S_VDDOS[0]    PTP_TRIG
+*                3    CLK125EN    CLK125
+*                4    P5_VDDOS[0] P5_GTXCLK
+*                5    P5_VDDOS[1] P5_OUTEN
+*                6    P6_VDDOS[0] P5_GTXCLK
+*                7    P6_VDDOS[1] P6_OUTEN
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       cfgDat - GT_CONFIG_DTTA
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetConfigData
+(
+    IN  GT_QD_DEV             *dev,
+    OUT  GT_CONFIG_DATA        *cfgData
+);
+
+/*******************************************************************************
+* gsysSetSyncETai
+*
+* DESCRIPTION:
+*        Set SyncE and Tai to the Scratch and Misc. Control register <SyncE and TAI pad>.
+*
+* INPUTS:
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetSyncETai
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
+);
+
+/*******************************************************************************
+* gsysGetSyncETai
+*
+* DESCRIPTION:
+*        Get SyncE and Tai from the Scratch and Misc Control register <SyncE and TAI pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI*
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetSyncETai
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
+);
+
+/*******************************************************************************
+* gsysSetP6_Clock
+*
+* DESCRIPTION:
+*        Set P6_clock to the Scratch and Misc Control register <P6_Clock pad>.
+*
+* INPUTS:
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetP6_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
+);
+
+/*******************************************************************************
+* gsysGetP6_Clock
+*
+* DESCRIPTION:
+*       Get P6_clock from the Scratch and Misc Control register <P6_Clock pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetP6_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
+);
+
+/*******************************************************************************
+* gsysSetP5_Clock
+*
+* DESCRIPTION:
+*       Set P5_clock to the Scratch and Misc Control register <P5_Clock pad>.
+*
+* INPUTS:
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetP5_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
+);
+
+/*******************************************************************************
+* gsysGetP5_Clock
+*
+* DESCRIPTION:
+*       Get P5_clock from the Scratch and Misc Control register <P5_Clock pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetP5_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
+);
+
+/*******************************************************************************
+* gsysSetEEPROM
+*
+* DESCRIPTION:
+*       Set EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
+*
+* INPUTS:
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetEEPROM
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            dsm,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
+);
+
+/*******************************************************************************
+* gsysGetEEPROM
+*
+* DESCRIPTION:
+*       Get EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetEEPROM
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *dsm,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
+);
+
+
+/* gtAdvVct.c */
+
+/*******************************************************************************
+* gvctGetAdvCableDiag
+*
+* DESCRIPTION:
+*       This routine perform the advanced virtual cable test for the requested
+*       port and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*       mode - advance VCT mode (either First Peak or Maximum Peak)
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are supporting this API.
+*
+*******************************************************************************/
+GT_STATUS gvctGetAdvCableDiag
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+);
+
+/*******************************************************************************
+* gvctGetAdvExtendedStatus
+*
+* DESCRIPTION:
+*        This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*        DSP based cable length is also provided.
+*
+* INPUTS:
+*       dev  - pointer to GT driver structure returned from mdLoadDriver
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*        Supporting Device list:
+*           88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys
+*            in 88E6165 family and 88E6351 family devices
+*
+*******************************************************************************/
+GT_STATUS gvctGetAdvExtendedStatus
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT   port,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+);
+
+#ifdef CONFIG_AVB_FPGA
+
+/*******************************************************************************
+* gptpGetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine gets interrupt status of PTP logic.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt    - PTP Int Status
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
+);
+
+/*******************************************************************************
+* gptpSetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine sets interrupt status of PTP logic.
+*
+* INPUTS:
+*    ptpInt    - PTP Int Status
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32    ptpInt
+);
+
+/*******************************************************************************
+* gptpSetFPGAIntEn
+*
+* DESCRIPTION:
+*       This routine enables PTP interrupt.
+*
+* INPUTS:
+*        ptpInt    - PTP Int Status (1 to enable, 0 to disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        ptpInt
+);
+
+/*******************************************************************************
+* gptpGetClockSource
+*
+* DESCRIPTION:
+*       This routine gets PTP Clock source setup.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
+);
+
+/*******************************************************************************
+* gptpSetClockSource
+*
+* DESCRIPTION:
+*       This routine sets PTP Clock source setup.
+*
+* INPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
+);
+
+/*******************************************************************************
+* gptpGetP9Mode
+*
+* DESCRIPTION:
+*       This routine gets Port 9 Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
+);
+
+/*******************************************************************************
+* gptpSetP9Mode
+*
+* DESCRIPTION:
+*       This routine sets Port 9 Mode.
+*
+* INPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
+);
+
+/*******************************************************************************
+* gptpReset
+*
+* DESCRIPTION:
+*       This routine performs software reset for PTP logic.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpReset
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gptpGetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PTP Duty Cycle Adjustment.
+*
+* INPUTS:
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
+);
+
+/*******************************************************************************
+* gptpGetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine gets clock duty cycle adjustment value.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT    *adj
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine sets clock duty cycle adjustment value.
+*
+* INPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT    *adj
+);
+
+/*******************************************************************************
+* gptpGetPLLEn
+*
+* DESCRIPTION:
+*       This routine checks if PLL is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpGetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
+);
+
+/*******************************************************************************
+* gptpSetPLLEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpSetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
+);
+
+/*******************************************************************************
+* gptpGetDDSReg
+*
+* DESCRIPTION:
+*       This routine gets DDS register data.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*
+* OUTPUTS:
+*    ddsData    - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    OUT GT_U32    *ddsData
+);
+
+/*******************************************************************************
+* gptpSetDDSReg
+*
+* DESCRIPTION:
+*       This routine sets DDS register data.
+*    DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*    ddsData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    IN  GT_U32    ddsData
+);
+
+/*******************************************************************************
+* gptpUpdateDDSReg
+*
+* DESCRIPTION:
+*       This routine updates DDS register data.
+*    DDS register data written by gptpSetDDSReg are not affected until this API is called.
+*
+* INPUTS:
+*    none
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpUpdateDDSReg
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gptpSetADFReg
+*
+* DESCRIPTION:
+*       This routine sets ADF4156 register data.
+*
+* INPUTS:
+*    adfData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetADFReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    adfData
+);
+#endif  /*  CONFIG_AVB_FPGA */
+
+/* gtTCAM.c */
+/*******************************************************************************
+* gtcamFlushAll
+*
+* DESCRIPTION:
+*       This routine is to flush all entries. A Flush All command will initialize
+*       TCAM Pages 0 and 1, offsets 0x02 to 0x1B to 0x0000, and TCAM Page 2 offset
+*       0x02 to 0x05 to 0x0000 for all TCAM entries with the exception that TCAM
+*       Page 0 offset 0x02 will be initialized to 0x00FF.
+*
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamFlushAll
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gtcamFlushEntry
+*
+* DESCRIPTION:
+*       This routine is to flush a single entry. A Flush a single TCAM entry command
+*       will write the same values to a TCAM entry as a Flush All command, but it is
+*       done to the selected single TCAM entry only.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamFlushEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer
+);
+
+/*******************************************************************************
+* gtcamLoadEntry
+*
+* DESCRIPTION:
+*       This routine loads a TCAM entry.
+*        The load sequence of TCAM entry is critical. Each TCAM entry is made up of
+*       3 pages of data. All 3 pages need to loaded in a particular order for the TCAM
+*       to operate correctly while frames are flowing through the switch.
+*       If the entry is currently valid, it must first be flushed. Then page 2 needs
+*       to be loaded first, followed by page 1 and then finally page 0.
+*       Each page load requires its own write TCAMOp with these TCAM page bits set
+*       accordingly.
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamLoadEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
+);
+
+/*******************************************************************************
+* gtcamPurgyEntry
+*
+* DESCRIPTION:
+*       This routine Purgy a TCAM entry.
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamPurgyEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
+);
+
+/*******************************************************************************
+* gtcamReadTCAMData
+*
+* DESCRIPTION:
+*       This routine loads the global 3 offsets 0x02 to 0x1B registers with
+*       the data found in the TCAM entry and its TCAM page pointed to by the TCAM
+*       entry and TCAM page bits of this register (bits 7:0 and 11:10 respectively.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*
+* OUTPUTS:
+*        tcamData    - Tcam entry Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamReadTCAMData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
+);
+
+/*******************************************************************************
+* gtcamGetNextTCAMData
+*
+* DESCRIPTION:
+*       This routine  finds the next higher TCAM Entry number that is valid (i.e.,
+*       any entry whose Page 0 offset 0x02 is not equal to 0x00FF). The TCAM Entry
+*       register (bits 7:0) is used as the TCAM entry to start from. To find
+*       the lowest number TCAM Entry that is valid, start the Get Next operation
+*       with TCAM Entry set to 0xFF.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 255)
+*
+* OUTPUTS:
+*        tcamPointer - next pointer entry of TCAM (0 ~ 255)
+*        tcamData    - Tcam entry Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamGetNextTCAMData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        *tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
+);
+
+/*******************************************************************************
+* gprtGetSerdesMode
+*
+* DESCRIPTION:
+*       This routine reads Serdes Interface Mode.
+*
+* INPUTS:
+*        port -  The physical SERDES device address(4/5)
+*
+* OUTPUTS:
+*       mode    - Serdes Interface Mode
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       logical port number is supported only for the devices made production
+*       before 2009.
+*  (Serdes devices: 88E6131, 88E6122, 88E6108, 88E6161, 88E6165 and 88E352 family)
+*
+*******************************************************************************/
+GT_STATUS gprtGetSerdesMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE *mode
+);
+
+
+/*******************************************************************************
+* gprtSetSerdesMode
+*
+* DESCRIPTION:
+*       This routine sets Serdes Interface Mode.
+*
+* INPUTS:
+*       port -  The physical SERDES device address(4/5)
+*       mode    - Serdes Interface Mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       logical port number is supported only for the devices made production
+*       before 2009.
+*  (Serdes devices: 88E6131, 88E6122, 88E6108, 88E6161, 88E6165 and 88E352 family)
+*
+*******************************************************************************/
+GT_STATUS gprtSetSerdesMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE mode
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApi_h */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiSelect.h
@@ -0,0 +1,55 @@
+ #include <Copyright.h>
+
+/********************************************************************************
+* msApiSelect.h
+*
+* DESCRIPTION:
+*       API selection for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiSelect_h
+#define __msApiSelect_h
+
+/* Micro definitions */
+/* Customers set self selection for DSDT  in here */
+
+/* DSDT phy API use Mad driver(DSDT/phy) */
+#if 1
+#undef GT_USE_MAD
+#else
+#define GT_USE_MAD 1
+#endif
+
+/* DSDT uses RMGMT to replace SMI */
+#if 1
+#undef GT_RMGMT_ACCESS
+#else
+#define GT_RMGMT_ACCESS 1
+#endif
+
+/* Only for Keystone FPGA design of PTP */
+#if 1
+#undef CONFIG_AVB_FPGA
+#undef CONFIG_AVB_FPGA_2
+/*
+#else
+#define CONFIG_AVB_FPGA  1
+#define CONFIG_AVB_FPGA_2 1
+*/
+#endif
+
+/* To use port mapping functions in Dev configuration */
+#if 1
+#undef GT_PORT_MAP_IN_DEV
+#else
+#define GT_PORT_MAP_IN_DEV  1
+#endif
+
+
+
+#endif /* __msApiSelect_h */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiTypes.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2002, Marvell International Ltd.
+ *
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_types.h $
+ * REVISION:    $Revision: 3 $
+ * LAST UPDATE: $Modtime: 12/24/02 5:37p $
+ *
+ * DESCRIPTION:
+ *     This file defines common data types used on Host and NetGX sides.
+ */
+
+
+#ifndef MV_TYPES_H
+#define MV_TYPES_H
+
+
+/* general */
+
+#undef IN
+#define IN
+#undef OUT
+#define OUT
+#undef INOUT
+#define INOUT
+
+
+#ifndef NULL
+#define NULL ((void*)0)
+#endif
+
+typedef void  GT_VOID;
+typedef char  GT_8;
+typedef short GT_16;
+typedef long  GT_32;
+
+typedef unsigned char  GT_U8;
+typedef unsigned short GT_U16;
+typedef unsigned long  GT_U32;
+typedef unsigned int   GT_UINT;
+
+typedef union {
+    GT_U8    c[8];
+    GT_U16    s[4];
+    GT_U32    l[2];
+} GT_U64;
+
+
+typedef enum {
+    GT_FALSE = 0,
+    GT_TRUE  = 1
+} GT_BOOL;
+
+typedef void          (*GT_VOIDFUNCPTR) (void); /* ptr to function returning void */
+typedef unsigned int  (*GT_INTFUNCPTR)  (void); /* ptr to function returning int  */
+
+
+/* module state */
+typedef enum {
+    GT_STATE_NONE = 0,    /* Uninitialized */
+    GT_STATE_IDLE,        /* Initialized, but not started (or stopped) */
+    GT_STATE_ACTIVE        /* Started */
+} GT_STATE;
+
+
+#define    GT_ETHERNET_HEADER_SIZE        (6)
+
+typedef struct
+{
+    GT_U8       arEther[GT_ETHERNET_HEADER_SIZE];
+}GT_ETHERADDR;
+
+/* This macro checks for a multicast mac address    */
+#define GT_IS_MULTICAST_MAC(mac)  ((mac.arEther[0] & 0x1) == 1)
+
+
+/* This macro checks for an broadcast mac address     */
+#define GT_IS_BROADCAST_MAC(mac) (((mac).arEther[0] == 0xFF) && ((mac).arEther[1] == 0xFF) && ((mac).arEther[2] == 0xFF) && ((mac).arEther[3] == 0xFF) && ((mac).arEther[4] == 0xFF) && ((mac).arEther[5] == 0xFF))
+
+
+/* status / error codes */
+typedef int GT_STATUS;
+
+#define GT_ERROR           (-1)
+#define GT_OK               (0x00)    /* Operation succeeded                   */
+#define GT_FAIL               (0x01)    /* Operation failed                      */
+#define GT_BAD_VALUE       (0x02)   /* Illegal value (general)               */
+#define GT_BAD_PARAM       (0x04)   /* Illegal parameter in function called  */
+#define GT_NOT_FOUND       (0x0B)   /* Item not found                        */
+#define GT_NO_MORE         (0x0C)   /* No more items found                   */
+#define GT_NO_SUCH         (0x0D)   /* No such item                          */
+#define GT_TIMEOUT         (0x0E)   /* Time Out                              */
+#define GT_NOT_SUPPORTED   (0x10)   /* This request is not support           */
+#define GT_ALREADY_EXIST   (0x1B)   /* Tried to create existing item         */
+#define GT_BAD_CPU_PORT    (0x20)   /* Input CPU Port is not valid physical port number */
+
+extern GT_U8 qdLong2Char(GT_U32 data);
+extern GT_U8 qdShort2Char(GT_U16 data);
+extern GT_U16 qdLong2Short(GT_U32 data);
+
+#endif /* MV_TYPES_H */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/Include/msApiWince.h
@@ -0,0 +1,556 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* msApiWince.h
+*
+* DESCRIPTION:
+*       Wince Application need to include only this header file.
+*
+* DEPENDENCIES:   None
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiFunc_h
+#define __msApiFunc_h
+
+#include "msApiDefs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef GT_STATUS (*FGT_PRT_ATUSIZE)(ATU_SIZE);
+typedef GT_STATUS (*FGT_PRT_U32_U32)(GT_U32*,GT_U32*);
+typedef GT_STATUS (*FGT_VALUE_U32)(GT_U32);
+typedef GT_STATUS (*FGT_PTR_U32)(GT_U32*);
+typedef GT_STATUS (*FGT_PTR_U16)(GT_U16*);
+typedef GT_STATUS (*FGT_PTR_U32_U32_U32)(GT_U32,GT_U32,GT_U32*);
+typedef GT_STATUS (*FGT_PTR_ATUENTRY)(GT_ATU_ENTRY*);
+typedef GT_STATUS (*FGT_PTR_ATUENTRY_BOOL)(GT_ATU_ENTRY*, GT_BOOL*);
+typedef GT_STATUS (*FGT_VALUE_FLUSHCMD)(GT_FLUSH_CMD);
+typedef GT_STATUS (*FGT_PTR_ETHERADDR)(GT_ETHERADDR*);
+typedef GT_STATUS (*FGT_PTR_BOOL)(GT_BOOL*);
+typedef GT_STATUS (*FGT_VALUE_BOOL)(GT_BOOL);
+typedef GT_STATUS (*FGT_VALUE_PORT_STPSTATE)(GT_LPORT,GT_PORT_STP_STATE);
+typedef GT_STATUS (*FGT_PTR_PORT_STPSTATE)(GT_LPORT,GT_PORT_STP_STATE*);
+typedef GT_STATUS (*FGT_VALUE_PORT_EGRESSMODE)(GT_LPORT,GT_EGRESS_MODE);
+typedef GT_STATUS (*FGT_PTR_PORT_EGRESSMODE)(GT_LPORT,GT_EGRESS_MODE*);
+typedef GT_STATUS (*FGT_VALUE_PORT_BOOL)(GT_LPORT,GT_BOOL);
+typedef GT_STATUS (*FGT_PTR_PORT_BOOL)(GT_LPORT,GT_BOOL*);
+typedef GT_STATUS (*FGT_VALUE_PORT_PORTS_U8)(GT_LPORT,GT_LPORT*,GT_U8);
+typedef GT_STATUS (*FGT_PTR_PORT_PORTS_U8)(GT_LPORT,GT_LPORT*,GT_U8*);
+typedef GT_STATUS (*FGT_VALUE_PORT_U16)(GT_LPORT,GT_U16);
+typedef GT_STATUS (*FGT_PTR_PORT_U16)(GT_LPORT,GT_U16*);
+typedef GT_STATUS (*FGT_VALUE_PORT_AUTOMODE)(GT_LPORT,GT_PHY_AUTO_MODE);
+
+typedef GT_STATUS (*FGT_VALUE_PORT)(GT_LPORT);
+typedef GT_STATUS (*FGT_VALUE_U8)(GT_U8);
+typedef GT_STATUS (*FGT_PTR_U8)(GT_U8*);
+typedef GT_STATUS (*FGT_VALUE_PORT_U8)(GT_LPORT,GT_U8);
+typedef GT_STATUS (*FGT_PTR_PORT_U8)(GT_LPORT,GT_U8*);
+typedef GT_STATUS (*FGT_VALUE_PORT_INGRESSMODE)(GT_LPORT,GT_INGRESS_MODE);
+typedef GT_STATUS (*FGT_PTR_PORT_INGRESSMODE)(GT_LPORT,GT_INGRESS_MODE*);
+typedef GT_STATUS (*FGT_VALUE_PORT_MCRATE)(GT_LPORT,GT_MC_RATE);
+typedef GT_STATUS (*FGT_PTR_PORT_MCRATE)(GT_LPORT,GT_MC_RATE*);
+typedef GT_STATUS (*FGT_VALUE_CTRMODE)(GT_CTR_MODE);
+typedef GT_STATUS (*FGT_PTR_CTRMODE)(GT_CTR_MODE*);
+typedef GT_STATUS (*FGT_VOID)(void);
+typedef GT_STATUS (*FGT_PTR_PORT_PORTSTAT)(GT_LPORT,GT_PORT_STAT*);
+typedef GT_STATUS (*FGT_VALUE_U8_U8)(GT_U8,GT_U8);
+typedef GT_STATUS (*FGT_PTR_U8_U8)(GT_U8,GT_U8*);
+typedef GT_STATUS (*FGT_PTR_CONFIG_INFO)(GT_SYS_CONFIG*,GT_SYS_INFO*);
+typedef GT_STATUS (*FGT_PTR_VERSION)(GT_VERSION*);
+typedef GT_STATUS (*FGT_PTR_REGISTER)(BSP_FUNCTIONS*);
+typedef GT_STATUS (*FGT_PTR_INT_HANDLER)(FGT_INT_HANDLER*);
+
+typedef GT_STATUS (*FGT_PTR_U32_U32_U16)(GT_U32,GT_U32,GT_U16);
+
+
+extern FGT_PRT_ATUSIZE             gfdbSetAtuSize;
+extern FGT_PRT_U32_U32             gfdbGetAgingTimeRange;
+extern FGT_VALUE_U32             gfdbSetAgingTimeout;
+extern FGT_PTR_U32                 gfdbGetAtuDynamicCount;
+extern FGT_PTR_ATUENTRY         gfdbGetAtuEntryFirst;
+extern FGT_PTR_ATUENTRY         gfdbGetAtuEntryNext;
+extern FGT_PTR_ATUENTRY_BOOL     gfdbFindAtuMacEntry;
+extern FGT_VALUE_FLUSHCMD         gfdbFlush;
+extern FGT_PTR_ATUENTRY         gfdbAddMacEntry; //liane
+extern FGT_PTR_ETHERADDR         gfdbDelMacEntry;
+extern FGT_VALUE_BOOL             gfdbLearnEnable;
+extern FGT_VALUE_BOOL                 gstpSetMode;
+extern FGT_VALUE_PORT_STPSTATE         gstpSetPortState;
+extern FGT_PTR_PORT_STPSTATE         gstpGetPortState;
+extern FGT_VALUE_PORT_EGRESSMODE     gprtSetEgressMode;
+extern FGT_PTR_PORT_EGRESSMODE         gprtGetEgressMode;
+extern FGT_VALUE_PORT_BOOL             gprtSetVlanTunnel;
+extern FGT_PTR_PORT_BOOL             gprtGetVlanTunnel;
+extern FGT_VALUE_PORT_PORTS_U8        gvlnSetPortVlanPorts;
+extern FGT_PTR_PORT_PORTS_U8        gvlnGetPortVlanPorts;
+extern FGT_VALUE_PORT_BOOL            gvlnSetPortUserPriLsb;
+extern FGT_PTR_PORT_BOOL            gvlnGetPortUserPriLsb;
+extern FGT_VALUE_PORT_U16            gvlnSetPortVid;
+extern FGT_PTR_PORT_U16                gvlnGetPortVid;
+extern FGT_VALUE_U32                eventSetActive;
+extern FGT_PTR_U16                    eventGetIntStatus;
+extern FGT_VALUE_PORT                gprtPhyReset;
+extern FGT_VALUE_PORT_BOOL            gprtSetPortLoopback;
+extern FGT_VALUE_PORT_BOOL            gprtSetPortSpeed;
+extern FGT_VALUE_PORT_BOOL            gprtPortAutoNegEnable;
+extern FGT_VALUE_PORT_BOOL            gprtPortPowerDown;
+extern FGT_VALUE_PORT                gprtPortRestartAutoNeg;
+extern FGT_VALUE_PORT_BOOL            gprtSetPortDuplexMode;
+extern FGT_VALUE_PORT_AUTOMODE        gprtSetPortAutoMode;
+extern FGT_VALUE_PORT_BOOL            gprtSetPause;
+extern FGT_VALUE_PORT_U16            gprtPhyIntEnable;
+extern FGT_PTR_PORT_U16                gprtGetPhyIntStatus;
+extern FGT_PTR_U16                    gprtGetPhyIntPortSummary;
+extern FGT_VALUE_PORT_BOOL            gprtSetForceFc;
+extern FGT_PTR_PORT_BOOL            gprtGetForceFc;
+extern FGT_VALUE_PORT_BOOL            gprtSetTrailerMode;
+extern FGT_PTR_PORT_BOOL            gprtGetTrailerMode;
+extern FGT_VALUE_PORT_INGRESSMODE    gprtSetIngressMode;
+extern FGT_PTR_PORT_INGRESSMODE        gprtGetIngressMode;
+extern FGT_VALUE_PORT_MCRATE        gprtSetMcRateLimit;
+extern FGT_PTR_PORT_MCRATE            gprtGetMcRateLimit;
+extern FGT_VALUE_CTRMODE            gprtSetCtrMode;
+extern FGT_VOID                    gprtClearAllCtr;
+extern FGT_PTR_PORT_PORTSTAT    gprtGetPortCtr;
+extern FGT_PTR_PORT_BOOL        gprtGetPartnerLinkPause;
+extern FGT_PTR_PORT_BOOL        gprtGetSelfLinkPause;
+extern FGT_PTR_PORT_BOOL        gprtGetResolve;
+extern FGT_PTR_PORT_BOOL        gprtGetLinkState;
+extern FGT_PTR_PORT_BOOL        gprtGetPortMode;
+extern FGT_PTR_PORT_BOOL        gprtGetPhyMode;
+extern FGT_PTR_PORT_BOOL        gprtGetDuplex;
+extern FGT_PTR_PORT_BOOL        gprtGetSpeed;
+extern FGT_VALUE_PORT_U8        gcosSetPortDefaultTc;
+extern FGT_VALUE_PORT_BOOL        gqosSetPrioMapRule;
+extern FGT_PTR_PORT_BOOL        gqosGetPrioMapRule;
+extern FGT_VALUE_PORT_BOOL        gqosIpPrioMapEn;
+extern FGT_PTR_PORT_BOOL        gqosGetIpPrioMapEn;
+extern FGT_VALUE_PORT_BOOL        gqosUserPrioMapEn;
+extern FGT_PTR_PORT_BOOL        gqosGetUserPrioMapEn;
+extern FGT_PTR_U8_U8            gcosGetUserPrio2Tc;
+extern FGT_VALUE_U8_U8            gcosSetUserPrio2Tc;
+extern FGT_PTR_U8_U8            gcosGetDscp2Tc;
+extern FGT_VALUE_U8_U8            gcosSetDscp2Tc;
+extern FGT_PTR_CONFIG_INFO        sysConfig;
+extern FGT_VOID                    sysEnable;
+extern FGT_VOID                    gsysSwReset;
+extern FGT_VALUE_BOOL            gsysSetDiscardExcessive;
+extern FGT_PTR_BOOL                gsysGetDiscardExcessive;
+extern FGT_VALUE_BOOL            gsysSetSchedulingMode;
+extern FGT_PTR_BOOL                gsysGetSchedulingMode;
+extern FGT_VALUE_BOOL            gsysSetMaxFrameSize;
+extern FGT_PTR_BOOL                gsysGetMaxFrameSize;
+extern FGT_VOID                    gsysReLoad;
+extern FGT_VALUE_BOOL            gsysSetWatchDog;
+extern FGT_PTR_BOOL                gsysGetWatchDog;
+extern FGT_PTR_ETHERADDR        gsysSetDuplexPauseMac;
+extern FGT_PTR_ETHERADDR        gsysGetDuplexPauseMac;
+extern FGT_VALUE_BOOL            gsysSetPerPortDuplexPauseMac;
+extern FGT_PTR_BOOL                gsysGetPerPortDuplexPauseMac;
+extern FGT_PTR_U32_U32_U32        gsysReadMiiReg;
+extern FGT_PTR_VERSION            gtVersion;
+extern FGT_PTR_REGISTER            gtRegister;
+
+extern FGT_PTR_U32_U32_U16        gsysWriteMiiReg;
+
+/*
+ * This function will get the all the MS APIs and assign to local function pointers.
+ */
+int qdGetMSApiFunc();
+
+GT_U32 gtStrlen
+(
+    IN const void * source
+);
+
+//*****************************************************************************
+//  I O C T L S
+//*****************************************************************************
+#include "windev.h"
+
+typedef struct _GT_IOCTL_PARAM
+{
+    union
+    {
+        GT_LPORT    portList[8];
+        GT_LPORT    port;
+        GT_U8          u8Data;
+        GT_U16      u16Data;
+        GT_U32      u32Data;
+        GT_BOOL     boolData;
+
+        GT_CTR_MODE    ctrMode;
+        GT_PORT_STP_STATE    stpState;
+        GT_EGRESS_MODE        egressMode;
+        GT_INGRESS_MODE        ingressMode;
+        GT_MC_RATE        mcRate;
+        GT_PORT_STAT    portStat;
+        ATU_SIZE         atuSize;
+        GT_FLUSH_CMD     flushCmd;
+
+        GT_ATU_ENTRY     atuEntry;
+        GT_ETHERADDR     etherAddr;
+        GT_SYS_CONFIG     sysConfig;
+        GT_SYS_INFO        sysInfo;
+
+    } FirstParam;
+
+    union
+    {
+        GT_LPORT    port;
+        GT_LPORT    portList[8];
+        GT_U8        u8Data;
+        GT_U16        u16Data;
+        GT_U32        u32Data;
+        GT_BOOL        boolData;
+        GT_PORT_STP_STATE    stpState;
+        GT_EGRESS_MODE        egressMode;
+        GT_INGRESS_MODE        ingressMode;
+        GT_MC_RATE        mcRate;
+
+        GT_PORT_STAT    portStat;
+
+        GT_PHY_AUTO_MODE    phyAutoMode;
+
+    } SecondParam;
+
+    union
+    {
+        GT_U8    u8Data;
+        GT_U16    u16Data;
+        GT_U32    u32Data;
+
+    } ThirdParam;
+
+} GT_IOCTL_PARAM, *PGT_IOCTL_PARAM;
+
+#define GET_FUNC_FROM_CTL_CODE(_ioctl) ((_ioctl>>2) & 0xFFF)
+
+/*
+    Microsoft allows for us to use 0x800 ~ 0xFFF
+    So, our program is using 6 bits for function group,
+    and 6 bits for each function.
+*/
+#define SUB_FUNC_MASK        0xFC0
+#define SYS_CFG_FUNC_MASK    (1 << 6) | 0x800
+#define SYS_CTRL_FUNC_MASK    (2 << 6) | 0x800
+#define FDB_FUNC_MASK        (3 << 6) | 0x800
+#define VLAN_FUNC_MASK        (4 << 6) | 0x800
+#define STP_FUNC_MASK        (5 << 6) | 0x800
+#define PORT_CTRL_FUNC_MASK        (6 << 6) | 0x800
+#define PORT_STATUS_FUNC_MASK    (7 << 6) | 0x800
+#define PORT_STATS_FUNC_MASK    (8 << 6) | 0x800
+#define QOS_FUNC_MASK            (9 << 6) | 0x800
+#define PHY_CTRL_FUNC_MASK        (10 << 6) | 0x800
+#define SYS_EVENT_FUNC_MASK        (11 << 6) | 0x800
+#define PHY_INT_FUNC_MASK        (12 << 6) | 0x800
+
+/*
+    Functions for SYS Configuration
+*/
+#define IOCTL_sysConfig    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysReadMiiReg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysWriteMiiReg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gtVersion    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+    Functions for ATU
+*/
+#define IOCTL_gfdbSetAtuSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAgingTimeRange    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbSetAgingTimeout    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuDynamicCount    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuEntryFirst    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuEntryNext    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFindAtuMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFlush    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbAddMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbDelMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbLearnEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+    Functions for STP
+*/
+#define IOCTL_gstpSetMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstpSetPortState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstpGetPortState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+    Functions for VLAN
+*/
+#define IOCTL_gprtSetEgressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetEgressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetVlanTunnel    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetVlanTunnel    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVlanPorts    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVlanPorts    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortUserPriLsb    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortUserPriLsb    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVid    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVid    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+    Functions for System Event
+*/
+#define IOCTL_eventSetActive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_EVENT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_eventGetIntStatus    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_EVENT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+    Functions for Phy Control
+*/
+#define IOCTL_gprtPhyReset    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortLoopback    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortSpeed    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortAutoNegEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortPowerDown    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortRestartAutoNeg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortDuplexMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortAutoMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+    Functions for Phy Interrupt
+*/
+#define IOCTL_gprtPhyIntEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyIntStatus    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyIntPortSummary    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+    Functions for Port Control
+*/
+#define IOCTL_gprtSetForceFc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetForceFc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetTrailerMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetTrailerMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetIngressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetIngressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetMcRateLimit    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetMcRateLimit    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+    Functions for Port Statistics
+*/
+#define IOCTL_gprtSetCtrMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtClearAllCtr    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPortCtr    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+    Functions for Port Status
+*/
+#define IOCTL_gprtGetPartnerLinkPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetSelfLinkPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetResolve    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetLinkState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPortMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetDuplex    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetSpeed    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+    Functions for QoS Mapping
+*/
+#define IOCTL_gcosSetPortDefaultTc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosSetPrioMapRule    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetPrioMapRule    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosIpPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetIpPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosUserPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetUserPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetUserPrio2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosSetUserPrio2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetDscp2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosSetDscp2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+    Functions for Sys Control
+*/
+#define IOCTL_gsysSwReset    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetDiscardExcessive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetDiscardExcessive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetSchedulingMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetSchedulingMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetMaxFrameSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetMaxFrameSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysReLoad    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetWatchDog    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetWatchDog    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetPerPortDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetPerPortDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/README_SW.txt
@@ -0,0 +1,382 @@
+
+                    Switch driver in DSDT Release version 3.3
+                   ============================================
+
+Table of Content:
+-----------------
+1) Release History
+2) Source Code Organization
+3) General Introduction
+4) HOW TO - Build qdDrv.o for vxWorks
+5) HOW TO - Build qdDrv.lib for WinCE
+6) HOW TO - Build qdDrv.o for Linux
+7) HOW TO - Use phy driver (madDrv) in qdDrv.o
+8) HOW TO - select features in msApiSelect.h
+9) HOW TO - Build kinds of driver
+10) Changes - DSDT 3.3 change list
+
+
+1) Release History
+------------------
+DSDT_3.3/switch - Feb.1. 2013.
+          0. Added and completed to support 88E6320 family.
+		  1. Fixed errors.
+
+DSDT_3.2/switch - Mar.1. 2012.
+          0. Added to support 88E6320 family.
+          1. Added to support full functions of 88E6352 family, and SpinnakerAv.
+          2. Added TCAM function of 88E6320.
+          3. Fixed page phy access problem of 88E6352.
+
+DSDT_3.1/switch - Mar.31. 2011.
+          0. Update phy.
+          1. Added new PTP and TAI feature of 88E6352.
+          2. Added msApiSelect.h to allow Customer to select DSDT functions.
+          3. Moved port mapping functions into Dev structure, which is selected by Customer.
+          4. Fixed bugs of Melody.
+          5. Added 88E6352 family.
+          6. Added semaphore for Remote management access.
+          7. Added port mapping functions into system config.
+          8. Fixed 6152/6155 port vector.
+          9. Fixed warning problems for long to short.
+         10. Fixed API gatuGetViolation DB Number error.
+DSDT_3.0/switch - May 26. 2010.
+          0. Based on DSDT2.8a.
+          1. Support Marvell F2R (Remote management) function.
+          2. Added device group 1 to extend device number.
+          3. Added to support 88EC0xx.
+          4. Added to use Marvell Phy driver (madDrv).
+          5. Changed name form DSDT* to DSDT*/switch. The name QD is kept to indicate DSDT switch driver.
+          6. Added to support 88EC0XX and 88E6250 group.
+DSDT2.8a.zip - Jan. 2009. Fixed problem.
+              1. Deleted to support 6095 family for Ingress Rate Limit withFlow control.
+              2. Deleted unused definition in GT_QPRI_TBL_ENTRY.
+DSDT2.8.zip - Nov. 2008. added support for 88E6351 family (88E6351, 88E6175, 88E6124)
+          1. New APIs are added to support new devices.
+
+DSDT2.7a.zip - March. 2008.
+          1. Fixed known bugs.
+          2. Enhanced some of the APIs.
+
+DSDT2.7.zip - May. 2007. added support for 88E6165 family (88E6123, 88E6125, 88E6140, 88E6161)
+          1. New APIs are added to support new devices.
+          2. Bug fix
+            GT_PIRL2_DATA structure includes GT_PIRL_COUNT_MODE enum type,
+            which should be GT_PIRL2_COUNT_MODE.
+            88E6083 support Static Management frame.
+            gprtSetForwardUnknown deals with wrong bit.
+          3. Removed Diag program that make user confused with missing files.
+
+DSDT2.6b.zip - Jan. 2007.
+          1. Bug Fixes
+          2. PIRL Rate Limiting Parameter update
+
+DSDT2.6a.zip - Nov. 2006. added support for 88E6045.
+
+DSDT2.6.zip - Jul. 2006. added support for 88E6097, 88E6096, 88E6046, 88E6047, and 88E6085.
+          1. New APIs are added to support new devices.
+          2. Bug fixes those were in 2.6 preliminary release.
+
+DSDT2.6pre.zip - Apr. 2006. added preliminary support for 88E6097.
+          1. New features are added.
+          2. Some parameters in the existing APIs are modified to support extended feature.
+
+DSDT2.5b.zip - Jan. 2006.
+          1. added gtDelay function after disabling PPU
+              Since delay function is system/OS dependent, it is required that DSDT user
+              fill up the gtDelay function based its platform parameters.
+              gtDelay function is located in src\msApi\gtUtils.c
+          2. Unused GT_STATUS definitions are removed.
+
+DSDT2.5a.zip - Jan. 2006, added support for 88E6122 and 88E6121 and new feature that bypasses
+          initial device setup, and bug fixes in the previous release.
+          1. Bypass initial configuration when loading driver.
+          2. Bug fixes:
+              1) synchronization issues.
+              2) port vector of 0xFF was treated as an invalid vector.
+
+DSDT2.5.zip - Nov. 2005, added support for 88E6065, 88E6035, 88E6055, 88E6061, and 88E6031,
+          and bug fixes in the previous release.
+          1. New APIs are added to support new devices.
+          2. Bug fixes:
+              1) gfdbGetAtuEntryNext API returns GT_NO_SUCH when Entry's MAC is Broadcast address.
+              2) entryState in GT_ATU_ENTRY follows the definition.
+              3) gsysSetTrunkMaskTable API does not overwrite HashTrunk value anymore.
+              4) 10/100 FastEthernet Phy Reset occurs along with Speed, Duplex modification.
+
+
+DSDT2.4a.zip - Oct. 2005, added support for 88E6131 and a bug fix.
+          1. gprtPortPowerDown(gtPhyCtrl.c) didn't work due to reset - reset is not called after PowerDown bit change.
+
+DSDT2.4.zip - Aug. 2005, bug fixes and modifications
+          1. gprtSetPktGenEnable(gtPhyCtrl.c) didn't work with Serdes Device - resolved.
+          2. gprtSetPortAutoMode(gtPhyCtrl.c) dropped 1000Mbps Half duplex mode - resolved.
+          3. gprtGetPhyLinkStatus(gtPhyCtrl.c) returned LinkOn when there is no phy connected - resolved.
+          4. gprtSetPortDuplexMode(gtPhyCtrl.c) reset 1000M Speed - resolved.
+          5. gfdbSetAtuSize(gtBrgFdb.c), now, returns GT_NOT_SUPPORT if ATU size of the device
+             is not configurable.
+          6. gprtSetPortLoopback(gtPhyCtrl.c) treats Fast Ethernet Phy and Gigabit Ethernet Phy
+               differently.
+          7. GT_GET_SERDES_PORT, now, does the error checking.
+          8. IS_CONFIGURABLE_PHY reads PHY ID and returns the ID
+
+DSDT2.4pre.zip - July. 2005, added support for 88E6108
+          1. New features are added.
+          2. Arguments in gprtSetPause and gprtSetPortSpeed are modified to support
+             1000M Phys.
+          3. Driver functions are added to support Marvell Alask Phys and to be
+             expanded easily for the future Phys.
+
+DSDT2.3c.zip - May. 2005,
+          1. New features in Rev1 or Rev2 of 88E6095 are added
+          2. gfdbGetAgingTimeout, and gfdbGetLearnEnable are added
+          3. Bug fixes in grcSetEgressRate and grcSetPri0Rate
+          4. Resetting TrunkID, when gprtSetTrunkPort is called to disable Trunk, is applied
+             only to Rev0 of 88E6095 and 88E6185
+
+DSDT2.3b.zip - Mar. 2005,
+          1. gstpSetMode function does not modify Port State any more, since STP module
+             sets the port state. gstpSetMode sets the switch so that it can receive
+              BPDU packets.
+          2. gtLoadDriver clears Rsvd2Cpu and Rsvd2CpuEn bits.
+          3. TrunkID will be reset when gprtSetTrunkPort is called to disable Trunk.
+          4. "Check PPU Status in order to verify PPU disabled" is applied to gtVct.c
+
+DSDT2.3a.zip - Jan. 2005, added support for 88E6152, 88E6155, 88E6182, and 88E6092
+          devices, removed non-existing devices, and bug fix in 2.3 release.
+          Fix :
+          Check PPU Status in order to verify PPU disabled.
+
+DSDT2.3.zip - Nov. 2004, support for 88E6185 and bug fixes in 2.3 preliminary release.
+          Fixes :
+          1) Provide some delay after disabling PPU.
+          2) VCT runs after disabling PPU.
+
+DSDT2.3pre.zip - Nov. 2004, added preliminary support for 88E6185.
+
+DSDT2.2a.zip - Nov. 2004, added semaphore support for MII Access with multi address mode.
+
+DSDT2.2.zip - Oct. 2004, support for 88E6095 and bug fixes in 2.2 preliminary release.
+
+DSDT2.2pre.zip - Sep. 2004, added preliminary support for 88E6095 and work-around for VCT
+          based on VCT Application Note.
+
+DSDT2.1a.zip - Apr. 2004, support 88E6093 and bug fixes.
+          Device Driver Package name has been changed from QDDriver to DSDT(Datacom
+          Same Driver Technology).
+          Bug Fixes :
+          1) DBNum was not correctly handled while getting entry from VTU Table.
+          2) Member Tag in VTU entry was not defined correctly for 88E6183 family.
+          3) Correction of 88E6183 RMON Counter Structure and Enum.
+          4) ATU Interrupt Handling routine
+
+qdDriver2.1-pre.zip - Apr. 2004, added preliminary support for 88E6093 and bug fixes.
+          Bug Fixes :
+          1) DBNum was not incorrectly handled while getting entry from
+          VTU Table.
+          2) Member Tag in VTU entry was not defined correctly for 88E6183 family.
+
+qdDriver2.0a.zip - Dec. 2003, provides functions, which can read/write
+          Switch Port Registers and Switch Global Registers:
+          gprtGetSwitchReg,
+          gprtSetSwitchReg,
+          gprtGetGlobalReg, and
+          gprtSetGlobalReg
+
+qdDriver2.0.zip - July. 2003, supports Multi Address Mode for upcoming device.
+          AUTO_SCAN_MODE, MANUAL_MODE, and MULTI_ADDR_MODE are added
+          to find a QD Family device.
+          Supports Sapphire (10 port Gigabit switch).
+
+qdDriver1.4a.zip - Apr. 2003, bug fixes.
+          Bug fixes on portVec in GT_ATU_ENTRY structure, which supported only
+          total of 8 ports (defined as GT_U8). It's now defined as GT_U32.
+          utils.c and testApi.c in Diag directory also modified to support
+          the switch with more than 8 ports.
+
+qdDriver1.4.zip - Apr. 2003, added support for Ocatne (6083).
+          Removed NO-OPs, which created when DBG_PRINT is undefined.
+          Bug fixes on gprtSetIGMPSnoop and gprtGetIGMPSnoop functions,
+          and GT_PRI0_RATE enum type.
+
+qdDriver1.3h.zip - Feb. 2003, added support for Extended Cable Status,
+          such as Impediance mismatch, Pair Skew, Pair Swap and Pair Polarity.
+          Bug fixes on FFox-EG and FFox-XP device ID.
+
+qdDriver1.3g.zip - Dec. 2002, added preliminary support for Octane (6083)
+
+qdDriver1.3.zip - Oct. 2002, added support for ClipperShip (6063)
+          This driver works with all released devices, including
+          6051, 6052, 6021, and 6063
+
+qdDriver1.2.zip - Aug. 2002, added support for FullSail (6021)
+
+qdDriver1.1.zip - June, 2002 OS independent QuarterDeck Driver Release
+          Based on 1.0 release, but removed OS dependency. The driver
+          is designed to work with any OS without code changes.
+
+qdDriver1.0.zip - Feb. 2002, Initial QuaterDeck Driver Release
+          Based on vxWorks OS, support 6051/6052
+
+
+2) Source Code Organization
+--------------------------
+    2.1) src
+        Switch Driver Suite Source Code.
+
+    2.2) Include directory
+        Switch Driver Suite Header files and Prototype files
+
+    2.3) Library
+        Object files for Switch driver Suite
+
+    2.4) Sample
+        Sample Code that shows how to use MSAPIs, e.g., init Switch driver, setup VLAN for Home Gateway, etc.
+
+    2.5) Tools
+	Building related files
+
+    2.6) Phy
+        The phy part of switch has alternative individual driver, Marvell Phy Driver (madDrv).
+        The code is in DSDT_X.Y/phy.
+        See DSDT_X.Y/phy/README.txt for more detail.
+
+
+    * The Switch Driver Suite Source Code is OS independent, and fully supported by Marvell.
+    * The Sample Codes are tested under vxworks and Linux, and is provided for reference only.
+
+
+3) General Introduction
+-----------------------
+
+The Switch driver suite is standalone program, which is independent of both OS and Platform.
+As such, applications of MSAPIs need to register platform specific functions.
+This is done by calling qdLoadDriver function. This function returns a pointer (*dev),
+which contains the device and platform information. It will then be used for each MSAPI call.
+
+msApiInit.c file in Diag directory and Sample\Initialization directory demonstrate
+how you can register those functions.
+
+msApiInit.c
+    qdStart is the main function to initialize Switch Driver and does the
+    followings:
+    a) register the platform specific functions.
+       1.1 and 1.2 below are required.
+       1.3 to 1.4 is for F2R(Remote management), it is selected
+          by flag GT_RMGMT_ACCESS in IncludemsApiDefs.h.
+       1.5 to 1.8 is optional.
+        1.1) readMii - BSP specific MII read function
+        1.2) writeMii - BSP specific MII write function
+        1.3) hwAccessMod - BSP supported function mode
+        1.4) hwAccess - BSP specific hardware access function
+        1.5) semCreate - OS specific semaphore create function.
+        1.6) semDelete - OS specific semaphore delete function.
+        1.7) semTake - OS specific semaphore take function.
+        1.8) semGive - OS specific semaphore give function.
+
+        Notes) The given example will use DB-88E6218 BSP as an example.
+
+    b) Initialize BSP provided routine (if required).
+
+    c) Calls qdLoadDriver routine.
+        1.1) Input (GT_SYS_CONFIG) - CPU Port Number (Board Specific) and Port Mode
+        (either 1 for Forwarding mode or 0 for Hardware default mode)
+        1.2) Output (GT_QD_DEV) - Contains all device (Switch) and platform specific info.
+             It will be used for all API calls.
+
+    d) Calls sysEnable (for future use.)
+
+
+4) HOW TO - Build qdDrv.o for vxWorks
+-------------------------------------
+
+1. Extract the given ZIP file into c:\DSDT_3.x\switch directory
+   You may change the directory name to your choice, and change the environment variable below accordingly.
+2. Edit setenv.bat file in c:\DSDT_3.x\switch\tools
+3. Modify the following variables according to your setup.
+set DSDT_USER_BASE=C:\DSDT_3.x\switch
+set DSDT_PROJ_NAME=qdDrv
+set DSDT_USE_MAD=FALSE or TRUE
+set WIND_BASE=C:\Tornado
+set TARGETCPU=MIPS        ;ARM for ARM Cpu
+set WIND_HOST_TYPE=x86-win32
+4. run "setenv"
+5. Change directory to c:\DSDT_3.x\switch\src
+6. run "make"
+7. qdDrv.o and qdDrv.map will be created in c:\DSDT_3.x\switch\Library.
+
+
+5) HOW TO - Build qdDrv.lib for WinCE
+-------------------------------------
+
+1. Extract the given ZIP file into c:\DSDT_3.x\switch directory(directory can be changed)
+2. Edit setenv.bat file in c:\DSDT_3.x\switch\tools
+3. Modify the following variables according to your setup.
+set DSDT_USER_BASE=C:\DSDT_3.x\switch
+set DSDT_PROJ_NAME=qdDrv
+set DSDT_USE_MAD=FALSE or TRUE
+set TARGETCPU=x86        ;MIPSIV for MIPS IV
+set WCEROOT=C:\WINCE400
+
+4. run "setenv WINCE"
+5. Change directory to c:\DSDT_3.x\switch\src
+6. run "make"
+7. qdDrv.lib will be created in c:\DSDT_3.x\switch\Library.
+
+
+6) HOW TO - Build qdDrv.o for Linux
+-----------------------------------
+
+1. Extract the given ZIP file into $HOME/DSDT_3.x/switch directory(directory can be changed)
+ `   in Linux system (verified with Fedore 8.x)
+2. Edit setenv file in $HOME/DSDT_3.x/switch/tools
+3. Modify the following variables according to your setup.
+    declare -x DSDT_USER_BASE=$HOME/DSDT_3.x/switch
+    declare -x DSDT_PROJ_NAME=qdDrv
+    declare -x DSDT_USE_MAD=FALSE or TRUE
+4. run "source setenv"
+5. Change directory to $HOME/DSDT_3.x/switch/src
+6. run "make"
+7. qdDrv.o and qdDrv.map will be created in $HOME/DSDT_3.x/switch/Library.
+
+7) HOW TO - Use Phy driver in qdDrv.o
+-------------------------------------
+
+ The Phy driver(DSDT/phy or MAD) supports Marvell Phy products. It includes the phys in switch chips.
+ From DSDT 3.0A, the Switch driver added functions to merge MAD driver
+ to replace original Phy regarded functions. This is an option.
+ There is no any difference from API point of view, if it uses QD over MAD APIs.
+ For old chips, it is selectable to use ether original Phy API function or call MAD functions. To use latest Phy functions, it should us QD over MAD. The selection is to define <GT_USE_MAD> in <msApiSelect.h>.
+
+8) HOW TO - select features in msApiSelect.h
+---------------------------------------------
+
+ Customer can ignore the selections. The default selections are <undef> for all.
+
+ From DSDT_3.0D, DSDT adds file <msApiSelect.h> in DSDT*.*/Include.
+ The file allows customer to select self features.
+ Now selections are:
+    GT_PORT_MAP_IN_DEV: To use port mapping functions in Dev configuration.
+    GT_RMGMT_ACCESS: DSDT uses RMGMT to replace SMI.
+    GT_USE_MAD: the phy APIs of switch use Mad driver(DSDT/phy).
+
+ If customer wants to use the selection,
+   1. Adds a Micro definition <CHECK_API_SELECT> in customers build environment.
+     For example, in <makefile>, adds <CFLAGS += -DCHECK_API_SELECT>.
+   2. In file <Include/msApiSelect>, set correct selections.
+   3. Re-build DSDT/switch.
+
+
+9) HOW TO - build driver
+-----------------------------------
+
+ Change directory to $HOME/DSDT_3.x/
+ <make switch>: to build switch driver image only.
+ <make phy>: to build phy driver image only.
+ <make>: to build switch and phy driver images, and switch driver does not use MAD APIs.
+ <make DSDT_USE_MAD=TRUE>: to build switch and phy driver images, and switch driver uses MAD APIs.
+
+10) CHANGES
+-----------
+1. Completed to supports Marvell 88E6320.
+2. Fixed Phy access problem.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/makedefs
@@ -0,0 +1,14 @@
+VPATH = $(DSDT_PATH)/src/driver $(DSDT_PATH)/src/msapi $(DSDT_PATH)/src/platform
+
+DSDT_INCLUDE = -I$(DSDT_PATH)/Include -I$(DSDT_PATH)/Include/h/driver -I$(DSDT_PATH)/Include/h/msApi -I$(DSDT_PATH)/Include/h/platform  -I$(DSDT_PATH)/../include
+
+DSDT_OBJS = ./gtDrvConfig.o ./gtDrvEvents.o ./gtHwCntl.o             \
+./gtBrgStu.o ./gtBrgFdb.o ./gtBrgStp.o ./gtBrgVlan.o ./gtBrgVtu.o ./gtEvents.o    \
+        gtPCSCtrl.o gtPhyCtrl.o gtPhyInt.o gtPortCtrl.o gtPortPav.o    \
+        gtPortRateCtrl.o gtPortRmon.o gtPortStat.o gtPortStatus.o    \
+        gtQosMap.o gtSysConfig.o gtSysCtrl.o gtSysStatus.o gtUtils.o \
+        gtVct.o gtVersion.o gtPIRL.o gtPIRL2.o        \
+            gtCCPVT.o gtPolicy.o \
+            gtPriTable.o gtWeight.o gtPTP.o gtPortLed.o gtMisc.o \
+            gtTCAM.o \
+        ./gtDebug.o ./gtMiiSmiIf.o ./gtSem.o ./platformDeps.o
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/802.1Q/802_1q.c
@@ -0,0 +1,332 @@
+#include <Copyright.h>
+/*******************************************************************************
+* 802_1q.c
+*
+* DESCRIPTION:
+*        There are three 802.1Q modes (GT_SECURE, GT_CHECK, and GT_FALLBACK).
+*        In GT_SECURE mode, the VID for the given frame must be contained in
+*        the VTU, and the Ingress port must be a member of the VLAN or the
+*        frame will be discarded.
+*        In GT_CHECK mode, the VID for the given frame must be contained in
+*        the VTU or the frame will be discarded (the frame will not be
+*        discarded if the Ingress port is not a memeber of the VLAN).
+*        In GT_FALLBACK mode, Frames are not discarded if their VID's are not
+*        contained in the VTU. If the frame's VID is contained in the VTU, the
+*        frame is allowed to exit only those ports that are members of the
+*        frame's VLAN; otherwise the switch 'falls back' into Port Based VLAN
+*        mode for the frame (88E6021 Spec. section 3.5.2.1).
+*
+*        Egress Tagging for a member port of a Vlan has the following three
+*        choices:
+*        1) Unmodified,
+*        2) Untagged, and
+*        3) Tagged
+*
+*        This sample shows how to utilize 802.1Q feature in the device.
+*        For more information, please refer to 88E6021 Spec. section 3.5.2.3
+*
+* DEPENDENCIES:
+*        88E6021 and 88E6063 are supporting this feature.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include "msSample.h"
+
+
+/*****************************************************************************
+* sample802_1qSetup
+*
+* DESCRIPTION:
+*        This routine will show how to configure the switch device so that it
+*        can be a Home Gateway. This example assumes that all the frames are not
+*        VLAN-Tagged.
+*        1) to clear VLAN ID Table,
+*         2) to enable 802.1Q in SECURE mode for each port except CPU port,
+*        3) to enable 802.1Q in FALL BACK mode for the CPU port.
+*        4) to add VLAN ID 1 with member port 0 and CPU port
+*        (untagged egress),
+*        5) to add VLAN ID 2 with member the rest of the ports and CPU port
+*        (untagged egress),
+*        6) to configure the default vid of each port:
+*        Port 0 have PVID 1, CPU port has PVID 3, and the rest ports have PVID 2.
+*        Note: CPU port's PVID should be unknown VID, so that QuarterDeck can use
+*        VlanTable (header info) for TX.
+*
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*
+* COMMENTS:
+*        WARNING!!
+*        If you create just two VLAN for this setup, Trailer mode or Header mode
+*        for the CPU port has to be enabled and Ethernet driver which connects to
+*        CPU port should understand VLAN-TAGGING, Trailer mode, or Header mode.
+*
+*******************************************************************************/
+GT_STATUS sample802_1qSetup(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_DOT1Q_MODE mode;
+        GT_VTU_ENTRY vtuEntry;
+    GT_U16 vid;
+    GT_LPORT port;
+    int i;
+
+    /*
+     *    1) Clear VLAN ID Table
+    */
+    if((status = gvtuFlush(dev)) != GT_OK)
+    {
+        MSG_PRINT(("gvtuFlush returned fail.\n"));
+        return status;
+    }
+
+    /*
+     *    2) Enable 802.1Q for each port as GT_SECURE mode except CPU port.
+    */
+    mode = GT_SECURE;
+    for(i=0; i<dev->numOfPorts; i++)
+    {
+        port = i;
+        if (port == dev->cpuPortNum)
+            continue;
+
+        if((status = gvlnSetPortVlanDot1qMode(dev,port, mode)) != GT_OK)
+        {
+            MSG_PRINT(("gvlnSetPortVlanDot1qMode return Failed\n"));
+            return status;
+        }
+    }
+
+    /*
+     *    3) Enable 802.1Q for CPU port as GT_FALLBACK mode
+    */
+    if((status = gvlnSetPortVlanDot1qMode(dev, dev->cpuPortNum, GT_FALLBACK)) != GT_OK)
+    {
+        MSG_PRINT(("gvlnSetPortVlanDot1qMode return Failed\n"));
+        return status;
+    }
+
+    /*
+     *    4) Add VLAN ID 1 with Port 0 and CPU Port as members of the Vlan.
+    */
+    gtMemSet(&vtuEntry,0,sizeof(GT_VTU_ENTRY));
+    vtuEntry.DBNum = 0;
+    vtuEntry.vid = 1;
+    for(i=0; i<dev->numOfPorts; i++)
+    {
+        port = i;
+        if((i==0) || (port == dev->cpuPortNum))
+            vtuEntry.vtuData.memberTagP[port] = MEMBER_EGRESS_UNTAGGED;
+        else
+            vtuEntry.vtuData.memberTagP[port] = NOT_A_MEMBER;
+    }
+
+    if((status = gvtuAddEntry(dev,&vtuEntry)) != GT_OK)
+    {
+        MSG_PRINT(("gvtuAddEntry returned fail.\n"));
+        return status;
+    }
+
+    /*
+     *    5) Add VLAN ID 2 with the rest of the Ports and CPU Port as members of
+     *    the Vlan.
+    */
+    gtMemSet(&vtuEntry,0,sizeof(GT_VTU_ENTRY));
+    vtuEntry.DBNum = 0;
+    vtuEntry.vid = 2;
+    for(i=0; i<dev->numOfPorts; i++)
+    {
+        port = i;
+        if(i == 0)
+            vtuEntry.vtuData.memberTagP[port] = NOT_A_MEMBER;
+        else
+            vtuEntry.vtuData.memberTagP[port] = MEMBER_EGRESS_UNTAGGED;
+    }
+
+    if((status = gvtuAddEntry(dev,&vtuEntry)) != GT_OK)
+    {
+        MSG_PRINT(("gvtuAddEntry returned fail.\n"));
+        return status;
+    }
+
+
+    /*
+     *    6) Configure the default vid for each port.
+     *    Port 0 has PVID 1, CPU port has PVID 3, and the rest ports have PVID 2.
+    */
+    for(i=0; i<dev->numOfPorts; i++)
+    {
+        port = i;
+        if(i==0)
+            vid = 1;
+        else if(port == dev->cpuPortNum)
+            vid = 3;
+        else
+            vid = 2;
+
+        if((status = gvlnSetPortVid(dev,port,vid)) != GT_OK)
+        {
+            MSG_PRINT(("gvlnSetPortVid returned fail.\n"));
+            return status;
+        }
+    }
+
+    return GT_OK;
+
+}
+
+
+/*****************************************************************************
+* sampleAdmitOnlyTaggedFrame
+*
+* DESCRIPTION:
+*        This routine will show how to configure a port to accept only vlan
+*        tagged frames.
+*        This routine assumes that 802.1Q has been enabled for the given port.
+*
+* INPUTS:
+*       port - logical port to be configured.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*
+* COMMENTS:
+*        Some device support Discard Untagged feature. If so, gprtSetDiscardUntagged
+*        function will do the work.
+*
+*******************************************************************************/
+GT_STATUS sampleAdmitOnlyTaggedFrame(GT_QD_DEV *dev,GT_LPORT port)
+{
+    GT_STATUS status;
+    GT_VTU_ENTRY vtuEntry;
+    int i;
+
+    /*
+     *    0) If device support gprtSetDiscardUntagged, call the function.
+    */
+    status = gprtSetDiscardUntagged(dev, port, GT_TRUE);
+    switch (status)
+    {
+        case GT_OK:
+            MSG_PRINT(("Done.\n"));
+            return status;
+        case GT_NOT_SUPPORTED:
+            MSG_PRINT(("Try other method.\n"));
+            break;
+        default:
+            MSG_PRINT(("Failure accessing device.\n"));
+            return status;
+    }
+
+
+    /*
+     *    1) Add VLAN ID 0xFFF with the given port as a member.
+    */
+    gtMemSet(&vtuEntry,0,sizeof(GT_VTU_ENTRY));
+    vtuEntry.DBNum = 0;
+    vtuEntry.vid = 0xFFF;
+    for(i=0; i<dev->numOfPorts; i++)
+    {
+        vtuEntry.vtuData.memberTagP[i] = NOT_A_MEMBER;
+    }
+    vtuEntry.vtuData.memberTagP[port] = MEMBER_EGRESS_TAGGED;
+
+    if((status = gvtuAddEntry(dev,&vtuEntry)) != GT_OK)
+    {
+        MSG_PRINT(("gvtuAddEntry returned fail.\n"));
+        return status;
+    }
+
+    /*
+     *    2) Configure the default vid for the given port with VID 0xFFF
+    */
+    if((status = gvlnSetPortVid(dev,port,0xFFF)) != GT_OK)
+    {
+        MSG_PRINT(("gvlnSetPortVid returned fail.\n"));
+        return status;
+    }
+
+    return GT_OK;
+
+}
+
+
+/*****************************************************************************
+* sampleDisplayVIDTable
+*
+* DESCRIPTION:
+*        This routine will show how to enumerate each vid entry in the VTU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS sampleDisplayVIDTable(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+        GT_VTU_ENTRY vtuEntry;
+    GT_LPORT port;
+    int portIndex;
+
+    gtMemSet(&vtuEntry,0,sizeof(GT_VTU_ENTRY));
+    vtuEntry.vid = 0xfff;
+    if((status = gvtuGetEntryFirst(dev,&vtuEntry)) != GT_OK)
+    {
+        MSG_PRINT(("gvtuGetEntryCount returned fail.\n"));
+        return status;
+    }
+
+    MSG_PRINT(("DBNum:%i, VID:%i \n",vtuEntry.DBNum,vtuEntry.vid));
+
+    for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
+    {
+        port = portIndex;
+
+        MSG_PRINT(("Tag%i:%#x  ",port,vtuEntry.vtuData.memberTagP[port]));
+    }
+
+    MSG_PRINT(("\n"));
+
+    while(1)
+    {
+        if((status = gvtuGetEntryNext(dev,&vtuEntry)) != GT_OK)
+        {
+            break;
+        }
+
+        MSG_PRINT(("DBNum:%i, VID:%i \n",vtuEntry.DBNum,vtuEntry.vid));
+
+        for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
+        {
+            port = portIndex;
+
+            MSG_PRINT(("Tag%i:%#x  ",port,vtuEntry.vtuData.memberTagP[port]));
+        }
+
+        MSG_PRINT(("\n"));
+
+    }
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/802.1Q/readme.txt
@@ -0,0 +1,46 @@
+========================================================================
+			802.1Q Feature
+========================================================================
+
+There are three 802.1Q modes (GT_SECURE, GT_CHECK, and GT_FALLBACK).
+In GT_SECURE mode, the VID for the given frame must be contained in
+the VTU, and the Ingress port must be a member of the VLAN or the
+frame will be discarded.
+In GT_CHECK mode, the VID for the given frame must be contained in
+the VTU or the frame will be discarded (the frame will not be
+discarded if the Ingress port is not a memeber of the VLAN).
+In GT_FALLBACK mode, Frames are not discarded if their VID's are not
+contained in the VTU. If the frame's VID is contained in the VTU, the
+frame is allowed to exit only those ports that are members of the
+frame's VLAN; otherwise the switch 'falls back' into Port Based VLAN
+mode for the frame (88E6021 Spec. section 3.5.2.1).
+
+Egress Tagging for a member port of a Vlan has the following three
+choices:
+1) Unmodified,
+2) Untagged, and
+3) Tagged
+
+This sample shows how to utilize 802.1Q feature in the device.
+For more information, please refer to 88E6021 Spec. section 3.5.2.3.
+
+802_1q.c
+	sample802_1qSetup
+		This routine will show
+		1) how to enable 802.1Q feature for each port,
+		2) how to clear VLAN ID (VTU) Table,
+		3) how to enable 802.1Q in SECURE mode for each port,
+		4) how to add VLAN ID 1 with member port 0 and CPU port
+		(unmodified egress),
+		5) how to add VLAN ID 2 with member the rest of the ports and CPU port
+		(untagged egress),
+		6) how to configure the default vid of each port:
+		Port 0 and CPU port have PVID 1 and the rest ports have PVID 2.
+
+	sampleAdmitOnlyTaggedFrame
+		This routine will show how to configure a port to accept only vlan
+		tagged frames.
+		This routine assumes that 802.1Q has been enabled for the given port.
+
+	sampleDisplayVIDTable
+		This routine will show how to enumerate each vid entry in the VTU table
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CableTest/advCableTest.c
@@ -0,0 +1,205 @@
+#include <Copyright.h>
+/********************************************************************************
+* testApi.c
+*
+* DESCRIPTION:
+*       API test functions
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+GT_STATUS advVctTest(GT_QD_DEV *dev, GT_LPORT port);
+GT_STATUS getAdvExtendedStatus(GT_QD_DEV *dev, GT_LPORT port);
+
+void displayAdvVCTResult
+(
+    GT_ADV_CABLE_STATUS *cableStatus,
+    int    channel
+)
+{
+    int i;
+
+    switch(cableStatus->cableStatus[channel])
+    {
+        case GT_ADV_VCT_FAIL:
+            MSG_PRINT(("Advanced Cable Test Failed\n"));
+            break;
+        case GT_ADV_VCT_NORMAL:
+            MSG_PRINT(("Cable Test Passed. No problem found.\n"));
+            break;
+        case GT_ADV_VCT_IMP_GREATER_THAN_115:
+            MSG_PRINT(("Cable Test Passed. Impedance is greater than 115 Ohms.\n"));
+            MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableStatus->u[channel].dist2fault));
+            break;
+        case GT_ADV_VCT_IMP_LESS_THAN_85:
+            MSG_PRINT(("Cable Test Passed. Impedance is less than 85 Ohms.\n"));
+            MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableStatus->u[channel].dist2fault));
+            break;
+        case GT_ADV_VCT_OPEN:
+            MSG_PRINT(("Cable Test Passed. Open Cable.\n"));
+            MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableStatus->u[channel].dist2fault));
+            break;
+        case GT_ADV_VCT_SHORT:
+            MSG_PRINT(("Cable Test Passed. Shorted Cable.\n"));
+            MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableStatus->u[channel].dist2fault));
+            break;
+        case GT_ADV_VCT_CROSS_PAIR_SHORT:
+            MSG_PRINT(("Cable Test Passed.\n"));
+            for(i=0; i<GT_MDI_PAIR_NUM; i++)
+            {
+                if(cableStatus->u[channel].crossShort.channel[i] == GT_TRUE)
+                {
+                    MSG_PRINT(("\tCross pair short with channel %i.\n",i));
+                    MSG_PRINT(("\tApproximatly %i meters from the tested port.\n",
+                                    cableStatus->u[channel].crossShort.dist2fault[i]));
+                }
+            }
+            break;
+        default:
+            MSG_PRINT(("Unknown Test Result.\n"));
+            break;
+    }
+}
+
+/* Advanced VCT (TDR) */
+GT_STATUS advVctTest(GT_QD_DEV *dev, GT_LPORT port)
+{
+    GT_STATUS status;
+    int i, j;
+    GT_ADV_VCT_MODE mode;
+    GT_ADV_CABLE_STATUS advCableStatus;
+
+    GT_ADV_VCT_MOD mod[2] = {
+        GT_ADV_VCT_FIRST_PEAK,
+        GT_ADV_VCT_MAX_PEAK
+    };
+
+    char modeStr[2][32] = {
+        "(Adv VCT First PEAK)",
+        "(Adv VCT MAX PEAK)"
+    };
+printf("!!!! sample adv Cable Test Result for Port %i\n",port);
+
+    if (dev == 0)
+    {
+        MSG_PRINT(("GT driver is not initialized\n"));
+        return GT_FAIL;
+    }
+
+    for (j=0; j<2; j++)
+    {
+        mode.mode=mod[j];
+        mode.transChanSel=GT_ADV_VCT_TCS_NO_CROSSPAIR;
+        mode.sampleAvg = 0;
+        mode.peakDetHyst =0;
+
+        /*
+         *    Start and get Cable Test Result
+         */
+        status = GT_OK;
+printf("!!!! 1 sample adv Cable Test Result for Port %i\n",port);
+
+        if((status = gvctGetAdvCableDiag(dev,port,
+                                mode,&advCableStatus)) != GT_OK)
+        {
+            MSG_PRINT(("gvctGetAdvCableDiag return Failed\n"));
+            return status;
+        }
+
+        MSG_PRINT(("\nCable Test Result %s for Port %i\n", modeStr[j], (int)port));
+
+        for(i=0; i<GT_MDI_PAIR_NUM; i++)
+        {
+            MSG_PRINT(("MDI PAIR %i:\n",i));
+            displayAdvVCTResult(&advCableStatus, i);
+        }
+    }
+
+    return GT_OK;
+}
+
+/* Advanced DSP VCT */
+GT_STATUS getAdvExtendedStatus(GT_QD_DEV *dev, GT_LPORT port)
+{
+    GT_STATUS status;
+    GT_ADV_EXTENDED_STATUS extendedStatus;
+    int i;
+    char ch;
+
+    if (dev == 0)
+    {
+        MSG_PRINT(("GT driver is not initialized\n"));
+        return GT_FAIL;
+    }
+
+    /*
+     *     Start getting Extended Information.
+     */
+    if((status = gvctGetAdvExtendedStatus(dev,port, &extendedStatus)) != GT_OK)
+    {
+        MSG_PRINT(("gvctGetAdvExtendedStatus return Failed\n"));
+        return status;
+    }
+
+    if (!extendedStatus.isValid)
+    {
+        MSG_PRINT(("Not able to get Extended Status.\n"));
+        MSG_PRINT(("Please check if 1000B-T Link is established on Port %i.\n",(int)port));
+        return status;
+    }
+
+    /* Pair Polarity */
+    MSG_PRINT(("Pair Polarity:\n"));
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        MSG_PRINT(("MDI PAIR %i: %s\n",i,
+                    (extendedStatus.pairPolarity[i] == GT_POSITIVE)?"Positive":"Negative"));
+    }
+
+    /* Pair Swap */
+    MSG_PRINT(("Pair Swap:\n"));
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        switch(extendedStatus.pairSwap[i])
+        {
+            case GT_CHANNEL_A:
+                ch = 'A';
+                break;
+            case GT_CHANNEL_B:
+                ch = 'B';
+                break;
+            case GT_CHANNEL_C:
+                ch = 'C';
+                break;
+            case GT_CHANNEL_D:
+                ch = 'D';
+                break;
+            default:
+                MSG_PRINT(("Error: reported unknown Pair Swap %i\n",extendedStatus.pairSwap[i]));
+                ch = 'U';
+                break;
+        }
+
+        MSG_PRINT(("MDI PAIR %i: Channel %c\n",i,ch));
+    }
+
+    /* Pair Polarity */
+    MSG_PRINT(("Pair Skew:\n"));
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        MSG_PRINT(("MDI PAIR %i: %ins\n",i,(int)extendedStatus.pairSkew[i]));
+    }
+
+    /* Pair Polarity */
+    MSG_PRINT(("Cable Len:\n"));
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        MSG_PRINT(("MDI PAIR %i: approximately %im\n",i,(int)extendedStatus.cableLen[i]));
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CableTest/cableTest.c
@@ -0,0 +1,109 @@
+#include <Copyright.h>
+/********************************************************************************
+* cableTest.c
+*
+* DESCRIPTION:
+*        This sample shows how to run Virtual Cable Test and how to use the
+*        test result.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+* COMMENTS:
+*******************************************************************************/
+
+#include "msSample.h"
+
+void sampleDisplayCableTestResult
+(
+    GT_TEST_STATUS *cableStatus,
+    GT_CABLE_LEN *cableLen
+)
+{
+    switch(*cableStatus)
+    {
+        case GT_TEST_FAIL:
+            MSG_PRINT(("Cable Test Failed\n"));
+            break;
+        case GT_NORMAL_CABLE:
+            MSG_PRINT(("Cable Test Passed. No problem found.\n"));
+            switch(cableLen->normCableLen)
+            {
+                case GT_LESS_THAN_50M:
+                    MSG_PRINT(("Cable Length is less than 50M.\n"));
+                    break;
+                case GT_50M_80M:
+                    MSG_PRINT(("Cable Length is between 50M and 80M.\n"));
+                    break;
+                case GT_80M_110M:
+                    MSG_PRINT(("Cable Length is between 80M and 110M.\n"));
+                    break;
+                case GT_110M_140M:
+                    MSG_PRINT(("Cable Length is between 110M and 140M.\n"));
+                    break;
+                case GT_MORE_THAN_140:
+                    MSG_PRINT(("Cable Length is over 140M.\n"));
+                    break;
+                default:
+                    MSG_PRINT(("Cable Length is unknown.\n"));
+                    break;
+            }
+            break;
+        case GT_IMPEDANCE_MISMATCH:
+            MSG_PRINT(("Cable Test Passed. Cable has Impedance Mismatch .\n"));
+            MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableLen->errCableLen));
+            break;
+        case GT_OPEN_CABLE:
+            MSG_PRINT(("Cable Test Passed. Cable is open.\n"));
+            MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableLen->errCableLen));
+            break;
+        case GT_SHORT_CABLE:
+            MSG_PRINT(("Cable Test Passed. Cable is short.\n"));
+            MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableLen->errCableLen));
+            break;
+        default:
+            MSG_PRINT(("Unknown Test Result.\n"));
+            break;
+    }
+}
+
+GT_STATUS sampleCableTest(GT_QD_DEV *dev,GT_LPORT port)
+{
+    GT_STATUS status;
+    GT_CABLE_STATUS cableStatus;
+    int i;
+
+    /*
+     *    Start and get Cable Test Result
+    */
+
+    if((status = gvctGetCableDiag(dev,port, &cableStatus)) != GT_OK)
+    {
+        MSG_PRINT(("gvctGetCableDiag return Failed\n"));
+        return status;
+    }
+
+    MSG_PRINT(("Cable Test Result for Port %i\n",port));
+
+    if(cableStatus.phyType == PHY_100M)
+    {
+        MSG_PRINT(("RX PAIR :\n"));
+        sampleDisplayCableTestResult(&cableStatus.cableStatus[MDI_RX_PAIR],
+                                    &cableStatus.cableLen[MDI_RX_PAIR]);
+        MSG_PRINT(("TX PAIR :\n"));
+        sampleDisplayCableTestResult(&cableStatus.cableStatus[MDI_TX_PAIR],
+                                    &cableStatus.cableLen[MDI_TX_PAIR]);
+    }
+    else /* phyType must be PHY_1000M */
+    {
+        for(i=0; i<GT_MDI_PAIR_NUM; i++)
+        {
+            MSG_PRINT(("MDI PAIR %i:\n",i));
+            sampleDisplayCableTestResult(&cableStatus.cableStatus[i],
+                                    &cableStatus.cableLen[i]);
+        }
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CableTest/readme.txt
@@ -0,0 +1,13 @@
+========================================================================
+		Cable Test
+========================================================================
+
+This sample shows how to run VCT(Virtual Cable Tester).
+
+Notes:
+
+cableTest.c
+	The function, sampleCableTest, can be used to run and display the result.
+
+advCableTest.c
+	The functions, advVctTest and getAdvExtendedStatus, can be used to run advanced VCT and display the result.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CrossChipTrunk/crossChipTrunk.c
@@ -0,0 +1,347 @@
+#include <Copyright.h>
+/********************************************************************************
+* crossChipTrunk.c
+*
+* DESCRIPTION:
+*        This sample shows how to setup the Cross Chip TRUNK
+*
+* DEPENDENCIES:
+*        Please check the device's spec. if the device supports this feature.
+*        At the moment this sample was written, 88E6095 was the only device support
+*        this feature.
+*
+* FILE REVISION NUMBER:
+*
+* COMMENTS:
+*******************************************************************************/
+
+#include "msSample.h"
+
+#define N_OF_QD_DEVICES    2
+
+/* qdMultiDev is defined in sample/MultiDevice/msApiInit.c */
+extern GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES];
+
+/*
+#ifndef TRUNK_MEMBER
+#define MAX_PORT_IN_TRUNK 4
+
+typedef struct _TRUNK_SET {
+    GT_U32    devIndex;
+    GT_U32    port;
+} TRUNK_SET;
+
+typedef struct _TRUNK_MEMBER {
+    GT_U32    trunkId;
+    GT_U32    nTrunkPort;
+    TRUNK_SET trunkSet[MAX_PORT_IN_TRUNK];
+} TRUNK_MEMBER;
+
+#endif
+*/
+
+GT_STATUS sampleCrossChipTrunk(GT_QD_DEV *dev[], TRUNK_MEMBER* tm);
+
+/*
+    Setup Trunk with the following member ports:
+        Port 0,1,2 of Device 0, and
+        Port 0 of Device 1,
+    where Device 0 is the first Switch Device Structure in qdMultiDev array
+    and Device 1 is the second Switch Device Structure in qdMultiDev array.
+*/
+GT_STATUS crossChipTrunkSetup()
+{
+    TRUNK_MEMBER tm;
+
+    tm.trunkId = 1;
+    tm.nTrunkPort = 4;
+    tm.trunkSet[0].devIndex = 0;
+    tm.trunkSet[0].port = 0;
+    tm.trunkSet[1].devIndex = 0;
+    tm.trunkSet[1].port = 1;
+    tm.trunkSet[2].devIndex = 0;
+    tm.trunkSet[2].port = 2;
+    tm.trunkSet[3].devIndex = 1;
+    tm.trunkSet[3].port = 0;
+
+    return sampleCrossChipTrunk(qdMultiDev, &tm);
+}
+
+GT_STATUS sampleCrossChipTrunk(GT_QD_DEV *dev[], TRUNK_MEMBER* tm)
+{
+    GT_STATUS status;
+    int i,j,index;
+    GT_U32 mask, trunkId;
+    TRUNK_SET* ts;
+    GT_U32 portVec[N_OF_QD_DEVICES];
+    GT_U32 casecadeVec = 0xC0;    /* Port 6 and 7. ToDo : get this value from user or device */
+
+    /*
+     *    Enable Trunk for each member of the Trunk and set the Trunk ID (1).
+    */
+
+    printf("Setting TRUNK\n");
+    printf("Trunk ID : %i\n",(unsigned int)tm->trunkId);
+    printf("N Ports  : %i\n",(unsigned int)tm->nTrunkPort);
+    printf("1st Port  : Dev %i, Port %i\n",
+            (unsigned int)tm->trunkSet[0].devIndex,(unsigned int)tm->trunkSet[0].port);
+    printf("2nd Port  : Dev %i, Port %i\n",
+            (unsigned int)tm->trunkSet[1].devIndex,(unsigned int)tm->trunkSet[1].port);
+    printf("3rd Port  : Dev %i, Port %i\n",
+            (unsigned int)tm->trunkSet[2].devIndex,(unsigned int)tm->trunkSet[2].port);
+    printf("4th Port  : Dev %i, Port %i\n",
+            (unsigned int)tm->trunkSet[3].devIndex,(unsigned int)tm->trunkSet[3].port);
+
+    trunkId = tm->trunkId;
+
+    for(i=0; i<N_OF_QD_DEVICES; i++)
+        portVec[i] = 0;
+
+    printf("Enabling TRUNK for each member port.\n");
+    for(i=0; i<tm->nTrunkPort; i++)
+    {
+        ts = &tm->trunkSet[i];
+
+        if(ts->devIndex >= N_OF_QD_DEVICES)
+        {
+            printf("Device %i is supported. Max Device Number is %i\n",(unsigned int)ts->devIndex,N_OF_QD_DEVICES-1);
+            return GT_FAIL;
+        }
+
+        if((dev[ts->devIndex] == NULL) || (!dev[ts->devIndex]->devEnabled))
+        {
+            printf("Device %i is not initialized\n",(unsigned int)ts->devIndex);
+            return GT_FAIL;
+        }
+
+        /* enabled trunk on the given port */
+        if((status = gprtSetTrunkPort(dev[ts->devIndex],ts->port,GT_TRUE,trunkId)) != GT_OK)
+        {
+            MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+            return status;
+        }
+
+        portVec[ts->devIndex] |= (1 << ts->port);
+    }
+
+    /*
+     *    Set Trunk Route Table for the given Trunk ID.
+    */
+    printf("Setting TRUNK Routing Table\n");
+    for(i=0; i<N_OF_QD_DEVICES; i++)
+    {
+        if((dev[i] == NULL) || (!dev[i]->devEnabled))
+        {
+            printf("Device %i is not initialized\n",i);
+            break;
+        }
+
+        if((status = gsysSetTrunkRouting(dev[i],trunkId,portVec[i]|casecadeVec)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
+            return status;
+        }
+    }
+
+    /*
+     *    Set Trunk Mask Table for load balancing.
+    */
+    printf("Setting TRUNK Mask for Load Balancing\n");
+    for(i=0; i<8; i++)
+    {
+        /* choose a port to be used for the given addr combo index */
+        index = i % tm->nTrunkPort;
+        ts = &tm->trunkSet[index];
+
+        for(j=0; j<N_OF_QD_DEVICES; j++)
+        {
+            if((dev[j] == NULL) || (!dev[j]->devEnabled))
+            {
+                printf("Device %i is not initialized\n",j);
+                continue;
+            }
+
+            if(portVec[j] == 0)
+                continue;
+
+            if((status = gsysGetTrunkMaskTable(dev[j],i,&mask)) != GT_OK)
+            {
+                MSG_PRINT(("gsysGetTrunkMaskTable return Failed\n"));
+                return status;
+            }
+
+            mask &= ~portVec[j];
+
+            if(ts->devIndex == j)
+                mask |= (1 << ts->port);
+
+            if((status = gsysSetTrunkMaskTable(dev[j],i,mask)) != GT_OK)
+            {
+                MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
+                return status;
+            }
+        }
+    }
+
+    return GT_OK;
+}
+
+
+
+/*
+    Assumption 1: Device ID, Cascading Port, CPU Port, and Interswitch Port are
+        already set properly. For more information, please refer to the
+        sample/MultiDevice/msApiInit.c
+
+    Assumption 2: Port 0,1,2 of Device 0 and Port 0 of Device 1 are member of a
+        trunk with Trunk ID 1.
+*/
+
+GT_STATUS sampleFixedCrossChipTrunk(GT_QD_DEV *dev[])
+{
+    GT_STATUS status;
+    int i;
+    GT_U32 mask, trunkBit, trunkId;
+
+    /*
+     *    Enable Trunk for each member of the Trunk and set the Trunk ID (1).
+    */
+
+    trunkId = 1;
+
+    if((dev[0] == NULL) || (!dev[0]->devEnabled))
+    {
+        printf("Device 0 is not initialized\n");
+        return GT_FAIL;
+    }
+    if((dev[1] == NULL) || (!dev[1]->devEnabled))
+    {
+        printf("Device 1 is not initialized\n");
+        return GT_FAIL;
+    }
+
+    /* setup for Device 0 port 0 */
+    if((status = gprtSetTrunkPort(dev[0],0,GT_TRUE,trunkId)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+        return status;
+    }
+
+    /* setup for Device 0 port 1 */
+    if((status = gprtSetTrunkPort(dev[0],1,GT_TRUE,trunkId)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+        return status;
+    }
+
+    /* setup for Device 0 port 2 */
+    if((status = gprtSetTrunkPort(dev[0],2,GT_TRUE,trunkId)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+        return status;
+    }
+
+    /* setup for Device 1 port 0 */
+    if((status = gprtSetTrunkPort(dev[1],0,GT_TRUE,trunkId)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+        return status;
+    }
+
+
+    /*
+     *    Set Trunk Route Table for the given Trunk ID.
+    */
+
+    /* setup for Device 0, trunk ID 1 : port 0,1,2, and 9 (cascading port, assumption1) */
+    if((status = gsysSetTrunkRouting(dev[0],trunkId,0x7|0x200)) != GT_OK)
+    {
+        MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
+        return status;
+    }
+
+    /* setup for Device 1, trunk ID 1 : port 0, and 8 (cascading port, assumption1) */
+    if((status = gsysSetTrunkRouting(dev[1],trunkId,0x1|0x100)) != GT_OK)
+    {
+        MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
+        return status;
+    }
+
+
+    /*
+     *    Set Trunk Mask Table for load balancing.
+    */
+
+    /*
+       Trunk Mask Table for Device 0:
+
+                        10    9    8    7    6    5    4    3    2    1    0
+       TrunkMask[0]        1    1    1    1    1    1    1    1    0    0    1
+       TrunkMask[1]        1    1    1    1    1    1    1    1    0    1    0
+       TrunkMask[2]        1    1    1    1    1    1    1    1    1    0    0
+       TrunkMask[3]        1    1    1    1    1    1    1    1    0    0    0
+       TrunkMask[4]        1    1    1    1    1    1    1    1    0    0    1
+       TrunkMask[5]        1    1    1    1    1    1    1    1    0    1    0
+       TrunkMask[6]        1    1    1    1    1    1    1    1    1    0    0
+       TrunkMask[7]        1    1    1    1    1    1    1    1    0    0    0
+
+
+       Trunk Mask Table for Device 1:
+
+                        10    9    8    7    6    5    4    3    2    1    0
+       TrunkMask[0]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[1]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[2]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[3]        1    1    1    1    1    1    1    1    1    1    1
+       TrunkMask[4]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[5]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[6]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[7]        1    1    1    1    1    1    1    1    1    1    1
+
+    */
+
+    /* setup for Device 0 */
+    for(i=0; i<8; i++)
+    {
+        if((i%4) == 3)
+        {
+            trunkBit = 0;
+        }
+        else
+        {
+            trunkBit = 1 << (i%4);
+        }
+
+        mask = 0x7F8 | trunkBit;
+
+        if((status = gsysSetTrunkMaskTable(dev[0],i,mask)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
+            return status;
+        }
+
+    }
+
+    /* setup for Device 1 */
+    for(i=0; i<8; i++)
+    {
+        if((i%4) == 3)
+        {
+            trunkBit = 1;
+        }
+        else
+        {
+            trunkBit = 0;
+        }
+
+        mask = 0x7FE | trunkBit;
+
+        if((status = gsysSetTrunkMaskTable(dev[1],i,mask)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
+            return status;
+        }
+
+    }
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/CrossChipTrunk/readme.txt
@@ -0,0 +1,12 @@
+========================================================================
+		Setup for Cross Chip Trunk
+========================================================================
+
+This sample shows how to setup the Cross Chip Trunk with the following
+assumptions.
+	Assumption 1: Device ID, Cascading Port, CPU Port, and Interswitch Port are
+		already set properly. For more information, please refer to the
+		sample/MultiDevice/msApiInit.c
+
+	Assumption 2: Port 0,1,2 of Device 0 and Port 0 of Device 1 are member of a
+		trunk with Trunk ID, 1.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/FlowControl/flowCtrl.c
@@ -0,0 +1,55 @@
+#include <Copyright.h>
+/********************************************************************************
+* flowCtrl.c
+*
+* DESCRIPTION:
+*       Sample program which will show how to Enable or Disable Flow Control of
+*        the given Port of the QuaterDeck.
+*
+*
+* DEPENDENCIES:   None.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include "msSample.h"
+
+/*
+ *    Enable or Disable Flow Control of the given port.
+ *    Input - port : port to be programmed.
+ *            enalble : either Enable or Disable.
+*/
+GT_STATUS sampleSetFlowControl(GT_QD_DEV *dev, GT_LPORT port, GT_BOOL enable)
+{
+    GT_STATUS status;
+
+    /*
+     *    Program Phy's Pause bit in AutoNegotiation Advertisement Register.
+     */
+    if((status = gprtSetPause(dev,port,enable)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetForceFC return Failed\n"));
+        return status;
+    }
+
+    /*
+     *    Restart AutoNegotiation of the given Port's phy
+     */
+    if((status = gprtPortRestartAutoNeg(dev,port)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetForceFC return Failed\n"));
+        return status;
+    }
+
+    /*
+     *    Program Port's Flow Control.
+     */
+    if((status = gprtSetForceFc(dev,port,enable)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetForceFC return Failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/FlowControl/readme.txt
@@ -0,0 +1,10 @@
+========================================================================
+		Flow Contorl Enable or Disable
+========================================================================
+
+Flow Control Setup requires multiple of DSDT API calls which can be
+examined in this sample.
+
+flowCtrl.c
+	sampleSetFlowControl can be used to enable or disable flow control
+	of the given port
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Header/header.c
@@ -0,0 +1,44 @@
+#include <Copyright.h>
+/********************************************************************************
+* header.c
+*
+* DESCRIPTION:
+*        This sample shows how to enable/disable CPU port's ingress and egress
+*        Header mode. For more information about Header mode, please refer to
+*        88E6063 Data Book. Header mode sould be handled by Ethernet Device/Driver
+*        as well, since 88E6063, with header mode enabled, sends out a packet with
+*        header, which cannot be recognized by regular Ethernet device/driver,
+*        and expects header for every received packet.
+*
+* DEPENDENCIES:
+*        88E6051, 88E6052, and 88E6021 are not supporting this feature.
+*
+* FILE REVISION NUMBER:
+*
+* COMMENTS:
+*        WARNING!!
+*        When Header mode for the CPU port is enabled, Ethernet Device/Driver
+*        which connects to the CPU port should understand Header Format.
+*        If Ethernet Device does not know about Header mode, then user may set
+*        the device to Promiscuous mode in order to receive packets from QD's CPU
+*        port. After that, it is Ethernet Device Driver's responsibility to handle
+*        Header properly.
+*******************************************************************************/
+
+#include "msSample.h"
+
+GT_STATUS sampleHeaderEnable(GT_QD_DEV *dev,GT_BOOL en)
+{
+    GT_STATUS status;
+
+    /*
+     *    Enable/Disable Header mode
+    */
+    if((status = gprtSetHeaderMode(dev,dev->cpuPortNum, en)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetHeaderMode return Failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Header/readme.txt
@@ -0,0 +1,19 @@
+========================================================================
+		CPU Header Mode Enable or Disable
+========================================================================
+
+This sample shows how to enable/disable header mode for CPU port.
+For more information about header mode, please refer to 88E6063 Spec.
+section 3.5.10 and section 3.7.5.
+
+Notes:
+When Header mode for the CPU port is enabled, Ethernet Device/Driver
+which is directly connected to the CPU port should understand Header Format.
+If Ethernet Device does not know about Header mode, then user may set
+the device to Promiscuous mode in order to receive packets from switch's CPU
+port. After that, it is Ethernet Device Driver's responsibility to handle
+Header properly.
+
+header.c
+	sampleHeaderEnable can be used to enable or disable CPU port's
+	header mode
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Include/msSample.h
@@ -0,0 +1,146 @@
+#include <Copyright.h>
+/********************************************************************************
+* msSample.h
+*
+* DESCRIPTION:
+*       Types definitions for Sample program
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __pfTesth
+#define __pfTesth
+
+#ifdef _VXWORKS
+#include "vxWorks.h"
+#include "logLib.h"
+#endif
+#include "stdio.h"
+#include "stdarg.h"
+#include "stdlib.h"
+#include "time.h"
+#include "string.h"
+
+#include "msApi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef GT_U32 (*GT_API_VOID) (GT_QD_DEV*);
+typedef int (*GT_CMP_FUNC) (void*, int, int);
+
+typedef GT_STATUS (*GT_API_SET_BOOL) (GT_QD_DEV*, GT_BOOL);
+typedef GT_STATUS (*GT_API_GET_BOOL) (GT_QD_DEV*, GT_BOOL*);
+
+typedef GT_STATUS (*GT_API_MAC_ADDR) (GT_QD_DEV*, GT_ETHERADDR*);
+
+typedef GT_STATUS (*GT_API_SET_PORT_BOOL) (GT_QD_DEV*, GT_LPORT,GT_BOOL);
+typedef GT_STATUS (*GT_API_GET_PORT_BOOL) (GT_QD_DEV*, GT_LPORT,GT_BOOL*);
+
+typedef GT_STATUS (*GT_API_SET_PORT_U16) (GT_QD_DEV*, GT_LPORT,GT_U16);
+typedef GT_STATUS (*GT_API_GET_PORT_U16) (GT_QD_DEV*, GT_LPORT,GT_U16*);
+
+typedef GT_STATUS (*GT_API_SET_PORT_U32) (GT_QD_DEV*, GT_LPORT,GT_U32);
+typedef GT_STATUS (*GT_API_GET_PORT_U32) (GT_QD_DEV*, GT_LPORT,GT_U32*);
+
+typedef GT_STATUS (*GT_API_SET_PORT_U8) (GT_QD_DEV*, GT_LPORT,GT_U8);
+typedef GT_STATUS (*GT_API_GET_PORT_U8) (GT_QD_DEV*, GT_LPORT,GT_U8*);
+
+typedef struct _TEST_API
+{
+    union
+    {
+        GT_API_SET_BOOL bool;
+        GT_API_MAC_ADDR mac;
+        GT_API_SET_PORT_BOOL port_bool;
+        GT_API_SET_PORT_U8 port_u8;
+        GT_API_SET_PORT_U16 port_u16;
+        GT_API_SET_PORT_U32 port_u32;
+    } setFunc;
+
+    union
+    {
+        GT_API_GET_BOOL bool;
+        GT_API_MAC_ADDR mac;
+        GT_API_GET_PORT_BOOL port_bool;
+        GT_API_GET_PORT_U8 port_u8;
+        GT_API_GET_PORT_U16 port_u16;
+        GT_API_GET_PORT_U32 port_u32;
+    } getFunc;
+
+}TEST_API;
+
+typedef struct _TEST_STRUCT
+{
+    char strTest[16];
+    GT_API_VOID testFunc;
+    GT_U32 testResults;
+} TEST_STRUCT;
+
+#define MSG_PRINT(x) testPrint x
+
+#define TEST_MAC_ENTRIES    32
+typedef struct _TEST_ATU_ENTRY
+{
+    GT_ATU_ENTRY atuEntry[TEST_MAC_ENTRIES];
+}TEST_ATU_ENTRY;
+
+typedef struct _ATU_ENTRY_INFO
+{
+    GT_ATU_ENTRY atuEntry;
+    GT_U16    hash;
+    GT_U16    bucket;
+} ATU_ENTRY_INFO;
+
+extern GT_SYS_CONFIG   pfTestSysCfg;
+extern ATU_ENTRY_INFO *gAtuEntry;
+extern GT_QD_DEV       *dev;
+
+GT_STATUS qdStart(int,int,int);
+GT_STATUS qdSimSetPhyInt(unsigned int portNumber, unsigned short u16Data);
+GT_STATUS qdSimSetGlobalInt(unsigned short u16Data);
+
+GT_STATUS testAll(GT_QD_DEV*);
+void testPrint(char* format, ...);
+
+extern FGT_INT_HANDLER qdIntHandler;
+
+int vtuEntryCmpFunc(void* buf, int a, int b);
+int atuEntryCmpFunc(void* buf, int a, int b);
+GT_STATUS gtSort(int list[], GT_CMP_FUNC cmpFunc, void* buf, GT_U32 len);
+GT_U16 createATUList(GT_QD_DEV *dev, TEST_ATU_ENTRY atuEntry[], GT_U16 entrySize, GT_U16 dbNumSize,
+                    GT_U16 sameMacsInEachDb, GT_U16 bSize);
+GT_STATUS testFillUpAtu(GT_QD_DEV *dev, ATU_ENTRY_INFO *atuEntry, GT_U8 atuSize,
+                    GT_U8 dbNum, GT_U16 first2Bytes, GT_ATU_UC_STATE state);
+GT_U16 runQDHash(GT_U8* eaddr, GT_U16 dbNum, int bSize, GT_U16* pHash,
+                    GT_U16* preBucket, GT_U16* posBucket);
+GT_STATUS testDisplayATUList();
+
+#undef USE_SEMAPHORE
+
+#ifdef USE_SEMAPHORE
+GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state);
+GT_STATUS osSemDelete(GT_SEM smid);
+GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut);
+GT_STATUS osSemSignal(GT_SEM smid);
+#endif
+
+GT_BOOL gtBspReadMii ( GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
+                      unsigned int* value);
+GT_BOOL gtBspWriteMii ( GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
+                       unsigned int value);
+void gtBspMiiInit();
+
+GT_BOOL qdSimRead (GT_QD_DEV* dev,unsigned int portNumber , unsigned int miiReg, unsigned int* value);
+GT_BOOL qdSimWrite (GT_QD_DEV* dev,unsigned int portNumber , unsigned int miiReg, unsigned int value);
+void qdSimInit();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* __pfTesth */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Include/qdSimRegs.h
@@ -0,0 +1,132 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtSimRegs.h
+*
+* DESCRIPTION:
+*       This file includes the declaration of the struct to hold the addresses
+*       of switch (global & per-port).
+*
+* DEPENDENCIES:
+*       QuarterDeck register MAP.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __qdSimRegsh
+#define __qdSimRegsh
+
+/* QuarterDeck Per Port Registers */
+#define QD_REG_PORT_STATUS        0x0
+#define QD_REG_SWITCH_ID        0x3
+#define QD_REG_PORT_CONTROL        0x4
+#define QD_REG_PORT_VLAN_MAP    0x6
+#define QD_REG_PVID                0x7
+#define QD_REG_RATE_CTRL        0xA
+#define QD_REG_PAV                0xB
+#define QD_REG_RXCOUNTER        0x10
+#define QD_REG_TXCOUNTER        0x11
+#define QD_REG_Q_COUNTER        0x1B
+
+/* QuarterDeck Global Registers */
+#define QD_REG_GLOBAL_STATUS    0x0
+#define QD_REG_MACADDR_01        0x1
+#define QD_REG_MACADDR_23        0x2
+#define QD_REG_MACADDR_45        0x3
+#define QD_REG_GLOBAL_CONTROL    0x4
+
+/* the following VTU entries are added for Fullsail and Clippership */
+#define QD_REG_VTU_OPERATION        0x5
+#define QD_REG_VTU_VID_REG        0x6
+#define QD_REG_VTU_DATA1_REG        0x7
+#define QD_REG_VTU_DATA2_REG        0x8
+#define QD_REG_VTU_DATA3_REG        0x9
+#define QD_REG_STATS_OPERATION        0x1D
+#define QD_REG_STATS_COUNTER3_2        0x1E
+#define QD_REG_STATS_COUNTER1_0        0x1F
+
+#define QD_REG_ATU_CONTROL        0xA
+#define QD_REG_ATU_OPERATION    0xB
+#define QD_REG_ATU_DATA_REG        0xC
+#define QD_REG_ATU_MAC_BASE        0xD
+#define QD_REG_ATU_MAC_01        0xD
+#define QD_REG_ATU_MAC_23        0xE
+#define QD_REG_ATU_MAC_45        0xF
+#define QD_REG_IP_PRI_BASE        0x10
+#define QD_REG_IP_PRI_REG0        0x10
+#define QD_REG_IP_PRI_REG1        0x11
+#define QD_REG_IP_PRI_REG2        0x12
+#define QD_REG_IP_PRI_REG3        0x13
+#define QD_REG_IP_PRI_REG4        0x14
+#define QD_REG_IP_PRI_REG5        0x15
+#define QD_REG_IP_PRI_REG6        0x16
+#define QD_REG_IP_PRI_REG7        0x17
+#define QD_REG_IEEE_PRI            0x18
+
+/* Definition for QD_REG_PORT_STATUS */
+#define QD_PORT_STATUS_DUPLEX    0x200
+
+/* Definitions for MIB Counter */
+#define GT_STATS_NO_OP            0x0
+#define GT_STATS_FLUSH_ALL        0x1
+#define GT_STATS_FLUSH_PORT        0x2
+#define GT_STATS_READ_COUNTER        0x4
+#define GT_STATS_CAPTURE_PORT        0x5
+#define GT_STATS_CAPTURE_PORT_CLEAR  0x6  /* RMU page 2 */
+
+#define QD_PHY_CONTROL_REG                0
+#define QD_PHY_AUTONEGO_AD_REG            4
+#define QD_PHY_NEXTPAGE_TX_REG            7
+#define QD_PHY_SPEC_CONTROL_REG            16
+#define QD_PHY_INT_ENABLE_REG            18
+#define QD_PHY_INT_STATUS_REG            19
+#define QD_PHY_INT_PORT_SUMMARY_REG        20
+
+/* Bit Definition for QD_PHY_CONTROL_REG */
+#define QD_PHY_RESET            0x8000
+#define QD_PHY_LOOPBACK            0x4000
+#define QD_PHY_SPEED            0x2000
+#define QD_PHY_AUTONEGO            0x1000
+#define QD_PHY_POWER            0x800
+#define QD_PHY_ISOLATE            0x400
+#define QD_PHY_RESTART_AUTONEGO        0x200
+#define QD_PHY_DUPLEX            0x100
+
+#define QD_PHY_POWER_BIT                11
+#define QD_PHY_RESTART_AUTONEGO_BIT        9
+
+/* Bit Definition for QD_PHY_AUTONEGO_AD_REG */
+#define QD_PHY_NEXTPAGE            0x8000
+#define QD_PHY_REMOTEFAULT        0x4000
+#define QD_PHY_PAUSE            0x400
+#define QD_PHY_100_FULL            0x100
+#define QD_PHY_100_HALF            0x80
+#define QD_PHY_10_FULL            0x40
+#define QD_PHY_10_HALF            0x20
+
+#define QD_PHY_MODE_AUTO_AUTO    (QD_PHY_100_FULL | QD_PHY_100_HALF | QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_100_AUTO    (QD_PHY_100_FULL | QD_PHY_100_HALF)
+#define QD_PHY_MODE_10_AUTO        (QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_AUTO_FULL    (QD_PHY_100_FULL | QD_PHY_10_FULL)
+#define QD_PHY_MODE_AUTO_HALF    (QD_PHY_100_HALF | QD_PHY_10_HALF)
+
+#define QD_PHY_MODE_100_FULL    QD_PHY_100_FULL
+#define QD_PHY_MODE_100_HALF    QD_PHY_100_HALF
+#define QD_PHY_MODE_10_FULL        QD_PHY_10_FULL
+#define QD_PHY_MODE_10_HALF        QD_PHY_10_HALF
+
+/* Bit definition for QD_PHY_INT_ENABLE_REG */
+#define QD_PHY_INT_SPEED_CHANGED        0x4000
+#define QD_PHY_INT_DUPLEX_CHANGED        0x2000
+#define QD_PHY_INT_PAGE_RECEIVED        0x1000
+#define QD_PHY_INT_AUTO_NEG_COMPLETED        0x800
+#define QD_PHY_INT_LINK_STATUS_CHANGED        0x400
+#define QD_PHY_INT_SYMBOL_ERROR            0x200
+#define QD_PHY_INT_FALSE_CARRIER        0x100
+#define QD_PHY_INT_FIFO_FLOW            0x80
+#define QD_PHY_INT_CROSSOVER_CHANGED        0x40
+#define QD_PHY_INT_POLARITY_CHANGED        0x2
+#define QD_PHY_INT_JABBER            0x1
+
+#endif /* __qdSimRegsh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/ev96122mii.c
@@ -0,0 +1,213 @@
+#include <Copyright.h>
+/********************************************************************************
+* ev96122mii.c
+*
+* DESCRIPTION:
+*       SMI access routines for EV-96122 board
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include <msSample.h>
+
+/*
+ * For each platform, all we need is
+ * 1) Assigning functions into
+ *         fgtReadMii : to read MII registers, and
+ *         fgtWriteMii : to write MII registers.
+ *
+ * 2) Register Interrupt (Not Defined Yet.)
+*/
+
+/*
+ *  EV-96122 Specific Definition
+*/
+
+#define SMI_OP_CODE_BIT_READ                    1
+#define SMI_OP_CODE_BIT_WRITE                   0
+#define SMI_BUSY                                1<<28
+#define READ_VALID                              1<<27
+
+#ifdef FIREFOX
+#define ETHER_SMI_REG                   0x10
+#define internalRegBaseAddr 0x80008000
+#define NONE_CACHEABLE        0x00000000
+#define CACHEABLE            0x00000000
+#define SMI_RX_TIMEOUT        1000
+#else
+#define ETHER_SMI_REG                   0x080810
+#define internalRegBaseAddr 0x14000000
+#define NONE_CACHEABLE        0xa0000000
+#define CACHEABLE            0x80000000
+#define SMI_RX_TIMEOUT        10000000
+#endif
+
+typedef unsigned int              SMI_REG;
+
+#ifdef LE /* Little Endian */
+#define SHORT_SWAP(X) (X)
+#define WORD_SWAP(X) (X)
+#define LONG_SWAP(X) ((l64)(X))
+
+#else    /* Big Endian */
+#define SHORT_SWAP(X) ((X <<8 ) | (X >> 8))
+
+#define WORD_SWAP(X) (((X)&0xff)<<24)+      \
+                    (((X)&0xff00)<<8)+      \
+                    (((X)&0xff0000)>>8)+    \
+                    (((X)&0xff000000)>>24)
+
+#define LONG_SWAP(X) ( (l64) (((X)&0xffULL)<<56)+               \
+                            (((X)&0xff00ULL)<<40)+              \
+                            (((X)&0xff0000ULL)<<24)+            \
+                            (((X)&0xff000000ULL)<<8)+           \
+                            (((X)&0xff00000000ULL)>>8)+         \
+                            (((X)&0xff0000000000ULL)>>24)+      \
+                            (((X)&0xff000000000000ULL)>>40)+    \
+                            (((X)&0xff00000000000000ULL)>>56))
+
+#endif
+
+#define GT_REG_READ(offset, pData)                                          \
+*pData = ( (volatile unsigned int)*((unsigned int *)                        \
+           (NONE_CACHEABLE | internalRegBaseAddr | (offset))) );            \
+*pData = WORD_SWAP(*pData)
+
+#define GT_REG_WRITE(offset, data)                                          \
+(volatile unsigned int)*((unsigned int *)(NONE_CACHEABLE |                  \
+          internalRegBaseAddr | (offset))) = WORD_SWAP(data)
+
+typedef enum _bool{false,true} bool;
+
+/*****************************************************************************
+*
+* bool etherReadMIIReg (unsigned int portNumber , unsigned int MIIReg,
+* unsigned int* value)
+*
+* Description
+* This function will access the MII registers and will read the value of
+* the MII register , and will retrieve the value in the pointer.
+* Inputs
+* portNumber - one of the 2 possiable Ethernet ports (0-1).
+* MIIReg - the MII register offset.
+* Outputs
+* value - pointer to unsigned int which will receive the value.
+* Returns Value
+* true if success.
+* false if fail to make the assignment.
+* Error types (and exceptions if exist)
+*/
+
+GT_BOOL gtBspReadMii (GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
+                        unsigned int* value)
+{
+SMI_REG smiReg;
+unsigned int phyAddr;
+unsigned int timeOut = 10; /* in 100MS units */
+int i;
+
+/* first check that it is not busy */
+    GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
+    if(smiReg & SMI_BUSY)
+    {
+        for(i = 0 ; i < SMI_RX_TIMEOUT ; i++);
+        do {
+            GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
+            if(timeOut-- < 1 ) {
+                return false;
+            }
+        } while (smiReg & SMI_BUSY);
+    }
+/* not busy */
+
+    phyAddr = portNumber;
+
+    smiReg =  (phyAddr << 16) | (SMI_OP_CODE_BIT_READ << 26) | (MIIReg << 21) |
+         SMI_OP_CODE_BIT_READ<<26;
+
+    GT_REG_WRITE (ETHER_SMI_REG,*((unsigned int*)&smiReg));
+    timeOut = 10; /* initialize the time out var again */
+    GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
+    if(!(smiReg & READ_VALID))
+        {
+            i=0;
+            while(i < SMI_RX_TIMEOUT)
+            {
+                i++;
+            }
+        {
+        }
+        do {
+            GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
+            if(timeOut-- < 1 ) {
+                return false;
+            }
+        } while (!(smiReg & READ_VALID));
+     }
+    *value = (unsigned int)(smiReg & 0xffff);
+
+    return true;
+
+
+}
+
+/*****************************************************************************
+*
+* bool etherWriteMIIReg (unsigned int portNumber , unsigned int MIIReg,
+* unsigned int value)
+*
+* Description
+* This function will access the MII registers and will write the value
+* to the MII register.
+* Inputs
+* portNumber - one of the 2 possiable Ethernet ports (0-1).
+* MIIReg - the MII register offset.
+* value -the value that will be written.
+* Outputs
+* Returns Value
+* true if success.
+* false if fail to make the assignment.
+* Error types (and exceptions if exist)
+*/
+
+GT_BOOL gtBspWriteMii (GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
+                       unsigned int value)
+{
+SMI_REG smiReg;
+unsigned int phyAddr;
+unsigned int timeOut = 10; /* in 100MS units */
+int i;
+
+/* first check that it is not busy */
+    GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
+    if(smiReg & SMI_BUSY)
+    {
+        for(i = 0 ; i < SMI_RX_TIMEOUT ; i++);
+        do {
+            GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
+            if(timeOut-- < 1 ) {
+                return false;
+            }
+        } while (smiReg & SMI_BUSY);
+    }
+/* not busy */
+
+    phyAddr = portNumber;
+
+    smiReg = 0; /* make sure no garbage value in reserved bits */
+    smiReg = smiReg | (phyAddr << 16) | (SMI_OP_CODE_BIT_WRITE << 26) |
+             (MIIReg << 21) | (value & 0xffff);
+
+    GT_REG_WRITE (ETHER_SMI_REG,*((unsigned int*)&smiReg));
+
+    return(true);
+}
+
+
+void gtBspMiiInit(GT_QD_DEV* dev)
+{
+    return;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/msApiInit.c
@@ -0,0 +1,117 @@
+#include <Copyright.h>
+/********************************************************************************
+* msApiInit.c
+*
+* DESCRIPTION:
+*       MS API initialization routine
+*
+* DEPENDENCIES:   Platform
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+/*
+#define MULTI_ADDR_MODE
+#define MANUAL_MODE
+*/
+
+GT_SYS_CONFIG   cfg;
+GT_QD_DEV       diagDev;
+GT_QD_DEV       *dev=&diagDev;
+
+
+/*
+ *  Initialize the QuarterDeck. This should be done in BSP driver init routine.
+ *    Since BSP is not combined with QuarterDeck driver, we are doing here.
+*/
+
+GT_STATUS qdStart(int cpuPort, int useQdSim, int devId) /* devId is used for simulator only */
+{
+GT_STATUS status;
+
+    /*
+     *  Register all the required functions to QuarterDeck Driver.
+    */
+    memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
+    memset((char*)&diagDev,0,sizeof(GT_QD_DEV));
+
+    if(useQdSim == 0) /* use EV-96122 */
+    {
+        cfg.BSPFunctions.readMii   = gtBspReadMii;
+        cfg.BSPFunctions.writeMii  = gtBspWriteMii;
+#ifdef GT_RMGMT_ACCESS
+    cfg.BSPFunctions.hwAccess  = gtBspHwAccess;
+#endif
+#ifdef USE_SEMAPHORE
+        cfg.BSPFunctions.semCreate = osSemCreate;
+        cfg.BSPFunctions.semDelete = osSemDelete;
+        cfg.BSPFunctions.semTake   = osSemWait;
+        cfg.BSPFunctions.semGive   = osSemSignal;
+#else
+        cfg.BSPFunctions.semCreate = NULL;
+        cfg.BSPFunctions.semDelete = NULL;
+        cfg.BSPFunctions.semTake   = NULL;
+        cfg.BSPFunctions.semGive   = NULL;
+#endif
+        gtBspMiiInit(dev);
+    }
+    else    /* use QuaterDeck Simulator (No QD Device Required.) */
+    {
+        cfg.BSPFunctions.readMii   = qdSimRead;
+        cfg.BSPFunctions.writeMii  = qdSimWrite;
+#ifdef USE_SEMAPHORE
+        cfg.BSPFunctions.semCreate = osSemCreate;
+        cfg.BSPFunctions.semDelete = osSemDelete;
+        cfg.BSPFunctions.semTake   = osSemWait;
+        cfg.BSPFunctions.semGive   = osSemSignal;
+#else
+        cfg.BSPFunctions.semCreate = NULL;
+        cfg.BSPFunctions.semDelete = NULL;
+        cfg.BSPFunctions.semTake   = NULL;
+        cfg.BSPFunctions.semGive   = NULL;
+#endif
+
+        qdSimInit(devId,0);
+    }
+
+    cfg.initPorts = GT_TRUE;    /* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
+    cfg.cpuPortNum = cpuPort;
+#ifdef MANUAL_MODE    /* not defined. this is only for sample */
+    /* user may want to use this mode when there are two QD switchs on the same MII bus. */
+    cfg.mode.scanMode = SMI_MANUAL_MODE;    /* Use QD located at manually defined base addr */
+    cfg.mode.baseAddr = 0x10;    /* valid value in this case is either 0 or 0x10 */
+#else
+#ifdef MULTI_ADDR_MODE
+    cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;    /* find a QD in indirect access mode */
+    cfg.mode.baseAddr = 1;        /* this is the phyAddr used by QD family device.
+                                Valid value are 1 ~ 31.*/
+#else
+    cfg.mode.scanMode = SMI_AUTO_SCAN_MODE;    /* Scan 0 or 0x10 base address to find the QD */
+    cfg.mode.baseAddr = 0;
+#endif
+#endif
+    if((status=qdLoadDriver(&cfg, dev)) != GT_OK)
+    {
+        MSG_PRINT(("qdLoadDriver return Failed\n"));
+        return status;
+    }
+
+    MSG_PRINT(("Device ID     : 0x%x\n",dev->deviceId));
+    MSG_PRINT(("Base Reg Addr : 0x%x\n",dev->baseRegAddr));
+    MSG_PRINT(("No of Ports   : %d\n",dev->numOfPorts));
+    MSG_PRINT(("CPU Ports     : %d\n",dev->cpuPortNum));
+
+    /*
+     *  start the QuarterDeck
+    */
+    if((status=sysEnable(dev)) != GT_OK)
+    {
+        MSG_PRINT(("sysConfig return Failed\n"));
+        return status;
+    }
+
+    MSG_PRINT(("QuarterDeck has been started.\n"));
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/msSample.h
@@ -0,0 +1,157 @@
+#include <Copyright.h>
+/********************************************************************************
+* msSample.h
+*
+* DESCRIPTION:
+*       Types definitions for Sample program
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __pfTesth
+#define __pfTesth
+
+#ifdef _VXWORKS
+#include "vxWorks.h"
+#include "logLib.h"
+#endif
+
+#ifndef __KERNEL__
+#include "stdio.h"
+#include "stdarg.h"
+#include "stdlib.h"
+#include "time.h"
+#include "string.h"
+#endif
+
+#include "msApi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef GT_U32 (*GT_API_VOID) (GT_QD_DEV*);
+typedef int (*GT_CMP_FUNC) (void*, int, int);
+
+typedef GT_STATUS (*GT_API_SET_BOOL) (GT_QD_DEV*, GT_BOOL);
+typedef GT_STATUS (*GT_API_GET_BOOL) (GT_QD_DEV*, GT_BOOL*);
+
+typedef GT_STATUS (*GT_API_MAC_ADDR) (GT_QD_DEV*, GT_ETHERADDR*);
+
+typedef GT_STATUS (*GT_API_SET_PORT_BOOL) (GT_QD_DEV*, GT_LPORT,GT_BOOL);
+typedef GT_STATUS (*GT_API_GET_PORT_BOOL) (GT_QD_DEV*, GT_LPORT,GT_BOOL*);
+
+typedef GT_STATUS (*GT_API_SET_PORT_U16) (GT_QD_DEV*, GT_LPORT,GT_U16);
+typedef GT_STATUS (*GT_API_GET_PORT_U16) (GT_QD_DEV*, GT_LPORT,GT_U16*);
+
+typedef GT_STATUS (*GT_API_SET_PORT_U32) (GT_QD_DEV*, GT_LPORT,GT_U32);
+typedef GT_STATUS (*GT_API_GET_PORT_U32) (GT_QD_DEV*, GT_LPORT,GT_U32*);
+
+typedef GT_STATUS (*GT_API_SET_PORT_U8) (GT_QD_DEV*, GT_LPORT,GT_U8);
+typedef GT_STATUS (*GT_API_GET_PORT_U8) (GT_QD_DEV*, GT_LPORT,GT_U8*);
+
+typedef struct _TEST_API
+{
+    union
+    {
+        GT_API_SET_BOOL bool;
+        GT_API_MAC_ADDR mac;
+        GT_API_SET_PORT_BOOL port_bool;
+        GT_API_SET_PORT_U8 port_u8;
+        GT_API_SET_PORT_U16 port_u16;
+        GT_API_SET_PORT_U32 port_u32;
+    } setFunc;
+
+    union
+    {
+        GT_API_GET_BOOL bool;
+        GT_API_MAC_ADDR mac;
+        GT_API_GET_PORT_BOOL port_bool;
+        GT_API_GET_PORT_U8 port_u8;
+        GT_API_GET_PORT_U16 port_u16;
+        GT_API_GET_PORT_U32 port_u32;
+    } getFunc;
+
+}TEST_API;
+
+typedef struct _TEST_STRUCT
+{
+    char strTest[16];
+    GT_API_VOID testFunc;
+    GT_U32 testResults;
+} TEST_STRUCT;
+
+#define MSG_PRINT(x) testPrint x
+
+#define TEST_MAC_ENTRIES    32
+typedef struct _TEST_ATU_ENTRY
+{
+    GT_ATU_ENTRY atuEntry[TEST_MAC_ENTRIES];
+}TEST_ATU_ENTRY;
+
+typedef struct _ATU_ENTRY_INFO
+{
+    GT_ATU_ENTRY atuEntry;
+    GT_U16    hash;
+    GT_U16    bucket;
+} ATU_ENTRY_INFO;
+
+extern GT_SYS_CONFIG   pfTestSysCfg;
+extern ATU_ENTRY_INFO *gAtuEntry;
+extern GT_QD_DEV       *dev;
+
+GT_STATUS qdStart(int,int,int);
+GT_STATUS qdSimSetPhyInt(unsigned int portNumber, unsigned short u16Data);
+GT_STATUS qdSimSetGlobalInt(unsigned short u16Data);
+
+GT_STATUS testAll(GT_QD_DEV*);
+
+#ifdef __KERNEL__
+#define testPrint  printk
+#define printf  printk
+#define puts  printk
+#define rand  random32
+#else
+#define  testPrint printf
+#endif
+
+extern FGT_INT_HANDLER qdIntHandler;
+
+int vtuEntryCmpFunc(void* buf, int a, int b);
+int atuEntryCmpFunc(void* buf, int a, int b);
+GT_STATUS gtSort(int list[], GT_CMP_FUNC cmpFunc, void* buf, GT_U32 len);
+GT_U16 createATUList(GT_QD_DEV *dev, TEST_ATU_ENTRY atuEntry[], GT_U16 entrySize, GT_U16 dbNumSize,
+                    GT_U16 sameMacsInEachDb, GT_U16 bSize);
+GT_STATUS testFillUpAtu(GT_QD_DEV *dev, ATU_ENTRY_INFO *atuEntry, GT_U8 atuSize,
+                    GT_U8 dbNum, GT_U16 first2Bytes, GT_ATU_UC_STATE state);
+GT_U16 runQDHash(GT_U8* eaddr, GT_U16 dbNum, int bSize, GT_U16* pHash,
+                    GT_U16* preBucket, GT_U16* posBucket);
+GT_STATUS testDisplayATUList();
+
+#undef USE_SEMAPHORE
+
+#ifdef USE_SEMAPHORE
+GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state);
+GT_STATUS osSemDelete(GT_SEM smid);
+GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut);
+GT_STATUS osSemSignal(GT_SEM smid);
+#endif
+
+GT_BOOL gtBspReadMii ( GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
+                      unsigned int* value);
+GT_BOOL gtBspWriteMii ( GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
+                       unsigned int value);
+void gtBspMiiInit();
+
+GT_BOOL qdSimRead (GT_QD_DEV* dev,unsigned int portNumber , unsigned int miiReg, unsigned int* value);
+GT_BOOL qdSimWrite (GT_QD_DEV* dev,unsigned int portNumber , unsigned int miiReg, unsigned int value);
+void qdSimInit();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* __pfTesth */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/osSem.c
@@ -0,0 +1,233 @@
+#include <Copyright.h>
+/********************************************************************************
+* osSem.c
+*
+* DESCRIPTION:
+*       Semaphore related routines
+*
+* DEPENDENCIES:
+*       OS Dependent.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifdef _VXWORKS
+#include "vxWorks.h"
+#include "semLib.h"
+#include "errnoLib.h"
+#include "objLib.h"
+
+int sysClkRateGet(void);
+
+#elif defined(WIN32)
+#include "windows.h"
+#include "wdm.h"
+#elif defined(LINUX)
+#include "/usr/include/semaphore.h"
+typedef    sem_t          semaphore ;
+#endif
+
+#include <msApi.h>
+
+GT_SEM osSemCreate( GT_SEM_BEGIN_STATE state);
+GT_STATUS osSemDelete(GT_SEM smid);
+GT_STATUS osSemWait(  GT_SEM smid, GT_U32 timeOut);
+GT_STATUS osSemSignal(GT_SEM smid);
+
+/*******************************************************************************
+* osSemCreate
+*
+* DESCRIPTION:
+*       Create semaphore.
+*
+* INPUTS:
+*       name   - semaphore Name
+*       init   - init value of semaphore counter
+*       count  - max counter (must be >= 1)
+*
+* OUTPUTS:
+*       smid - semaphore Id
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state)
+{
+#ifdef _VXWORKS
+#if 0
+    return (GT_SEM)semBCreate(SEM_Q_FIFO, state);
+#else
+    GT_SEM semid;
+    semid =(GT_SEM)semBCreate(SEM_Q_FIFO, state);
+    return semid;
+#endif
+
+#elif defined(WIN32)
+    return (GT_SEM)CreateSemaphore(NULL, state, 1, NULL);
+#elif defined(LINUX)
+    semaphore lxSem;
+
+    sem_init(&lxSem, state, 1);
+    return lxSem;
+#else
+    return 1;
+#endif
+    return GT_OK;
+}
+
+/*******************************************************************************
+* osSemDelete
+*
+* DESCRIPTION:
+*       Delete semaphore.
+*
+* INPUTS:
+*       smid - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS osSemDelete(GT_SEM smid)
+{
+#ifdef _VXWORKS
+    STATUS rc;
+
+    rc = semDelete((SEM_ID) smid);
+    if (rc != OK)
+        return GT_FAIL;
+
+#elif defined(WIN32)
+    if (CloseHandle((HANDLE)smid) == 0)
+        return GT_FAIL;
+
+#elif defined(LINUX)
+    sem_destroy((semaphore*) smid);
+#else
+    return GT_OK;
+#endif
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* osSemWait
+*
+* DESCRIPTION:
+*       Wait on semaphore.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*       timeOut - time out in miliseconds or 0 to wait forever
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       OS_TIMEOUT - on time out
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut)
+{
+#ifdef _VXWORKS
+    STATUS rc;
+
+    if (timeOut == 0)
+    rc = semTake ((SEM_ID) smid, WAIT_FOREVER);
+    else
+    {
+        int num, delay;
+
+        num = sysClkRateGet();
+        delay = (num * timeOut) / 1000;
+        if (delay < 1)
+            rc = semTake ((SEM_ID) smid, 1);
+        else
+            rc = semTake ((SEM_ID) smid, delay);
+    }
+
+    if (rc != OK)
+    {
+        if (errno == S_objLib_OBJ_TIMEOUT)
+            return GT_TIMEOUT;
+        else
+            return GT_FAIL;
+    }
+
+#elif defined(WIN32)
+    DWORD rc;
+
+    rc = WaitForSingleObject((HANDLE)smid, timeOut);
+
+    if (rc == WAIT_ABANDONED)
+        return GT_FAIL;
+    if (rc == WAIT_TIMEOUT)
+        return GT_TIMEOUT;
+
+#elif defined(LINUX)
+    sem_wait((semaphore*) smid) ;
+#else
+    return GT_OK;
+
+#endif
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* osSemSignal
+*
+* DESCRIPTION:
+*       Signal a semaphore.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS osSemSignal(GT_SEM smid)
+{
+#ifdef _VXWORKS
+    STATUS rc;
+    rc = semGive ((SEM_ID) smid);
+    if (rc != OK)
+        return GT_FAIL;
+
+#elif defined(WIN32)
+    if(ReleaseSemaphore((HANDLE) smid, 1, NULL) == 0)
+        return GT_FAIL;
+
+#elif defined(LINUX)
+    sem_post((semaphore*) smid) ;
+#else
+    return GT_OK;
+#endif
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/qdSim.c
@@ -0,0 +1,2004 @@
+#include <Copyright.h>
+/********************************************************************************
+* qdSim.c
+*
+* DESCRIPTION:
+*       Simulate QuaterDeck Device(88E6052)'s register map. When QuareterDeck API
+*        try to read/write a bit or bits into QuaterDeck, the simulator will redirect to
+*         its own memory place and performing the function very close to QuaterDeck.
+*        For example,
+*        1) user can set/reset a certain bit of QuarterDeck registers(Phy,Port,and General registers).
+*        2) user can access ATU (flush, load, purge, etc. with max MAC addresses of 32)
+*        3) user can manually generate an Interrupt and test the Interrupt routine.
+*        4) when user read a register, it will clear a certain register if it's a Self Clear register.
+*        5) when user write a register, it will return ERROR if it's read only register.
+*
+*
+* DEPENDENCIES:   QuaterDeck (88E6052) Register MAP.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include <msApi.h>
+#include <qdSimRegs.h>
+
+#define IS_BROADCAST_ADDR(_addr)                                \
+            (((_addr)[0] == 0xFF) && ((_addr)[1] == 0xFF) &&    \
+             ((_addr)[2] == 0xFF) && ((_addr)[3] == 0xFF) &&    \
+             ((_addr)[4] == 0xFF) && ((_addr)[5] == 0xFF))
+
+#define IS_GLOBAL_REG(_port)    ((int)(_port) == qdSimDev.qdSimGlobalRegBase)
+#define IS_PORT_REG(_port) (((int)(_port) >= qdSimDev.qdSimPortBase) && ((int)(_port) < qdSimDev.qdSimPortBase + qdSimDev.qdSimNumOfPorts))
+#define IS_PHY_REG(_port) (((int)(_port) >= qdSimDev.qdSimPhyBase) && ((int)(_port) < qdSimDev.qdSimPhyBase + qdSimDev.qdSimNumOfPhys))
+
+typedef struct _QD_SIM_DEV
+{
+    int qdSimUsed;
+    unsigned int qdSimDevId;
+    int qdSimNumOfPorts;
+    int qdSimPortBase;
+    int qdSimNumOfPhys;
+    int qdSimPhyBase;
+    int qdSimGlobalRegBase;
+    int qdSimPortStatsClear[10];
+    int qdSimStatsCapturedPort;
+    int vtuSize;
+    int atuSize;
+} QD_SIM_DEV;
+
+static QD_SIM_DEV qdSimDev = {0};
+
+void qdSimRegsInit();
+GT_BOOL qdSimRead (GT_QD_DEV *dev, unsigned int portNumber , unsigned int miiReg, unsigned int* value);
+GT_BOOL qdSimWrite(GT_QD_DEV *dev, unsigned int portNumber , unsigned int miiReg, unsigned int value);
+
+/*
+ *    This Array will simulate the QuarterDeck Registers.
+ *    To use it, qdSimRegs has to be initialized with its default values and
+ *    Call qdSimRead and qdSimWrite functions.
+*/
+#define MAX_SMI_ADDRESS        0x20
+#define MAX_REG_ADDRESS        0x20
+#define MAX_ATU_ADDRESS        0x800
+#define MAX_QD_VTU_ENTRIES    0x40
+
+GT_U16 qdSimRegs[MAX_SMI_ADDRESS][MAX_REG_ADDRESS];
+
+typedef struct _QDSIM_ATU_ENTRY
+{
+    GT_U16 atuData;
+    GT_U16 DBNum;
+    GT_U8 atuMac[6];
+} QDSIM_ATU_ENTRY;
+
+/*
+    Since QuarterDeck Simulator supports only fixed size of atu entry,
+    we are going with array list not dynamic linked list.
+*/
+typedef struct _QDSIM_ATU_NODE
+{
+    QDSIM_ATU_ENTRY atuEntry;
+    GT_U32 nextEntry;
+} QDSIM_ATU_NODE;
+
+typedef struct _QDSIM_ATU_LIST
+{
+    int atuSize;
+    GT_U32 head;
+} QDSIM_ATU_LIST;
+
+QDSIM_ATU_NODE ATUNode[MAX_ATU_ADDRESS];
+QDSIM_ATU_LIST ATUList;
+
+typedef struct _QDSIM_VTU_ENTRY
+{
+    GT_U16 DBNum;
+    GT_U16 memberTag[10];
+    GT_U16 vid;
+} QDSIM_VTU_ENTRY;
+
+/*
+    Since QuarterDeck Simulator supports only fixed size of atu entry,
+    we are going with array list not dynamic linked list.
+*/
+typedef struct _QDSIM_VTU_NODE
+{
+    QDSIM_VTU_ENTRY vtuEntry;
+    GT_U32 nextEntry;
+} QDSIM_VTU_NODE;
+
+typedef struct _QDSIM_VTU_LIST
+{
+    int vtuSize;
+    GT_U32 head;
+} QDSIM_VTU_LIST;
+
+QDSIM_VTU_NODE VTUNode[MAX_QD_VTU_ENTRIES];
+QDSIM_VTU_LIST VTUList;
+
+/*******************************************************************************
+* qdMemSet
+*
+* DESCRIPTION:
+*       Set a block of memory
+*
+* INPUTS:
+*       start  - start address of memory block for setting
+*       simbol - character to store, converted to an unsigned char
+*       size   - size of block to be set
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to set memory block
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * qdMemSet
+(
+    IN void * start,
+    IN int    symbol,
+    IN GT_U32 size
+)
+{
+    GT_U32 i;
+    char* buf;
+
+    buf = (char*)start;
+
+    for(i=0; i<size; i++)
+    {
+        *buf++ = (char)symbol;
+    }
+
+    return start;
+}
+
+/*******************************************************************************
+* qdMemCpy
+*
+* DESCRIPTION:
+*       Copies 'size' characters from the object pointed to by 'source' into
+*       the object pointed to by 'destination'. If copying takes place between
+*       objects that overlap, the behavior is undefined.
+*
+* INPUTS:
+*       destination - destination of copy
+*       source      - source of copy
+*       size        - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to destination
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * qdMemCpy
+(
+    IN void *       destination,
+    IN const void * source,
+    IN GT_U32       size
+)
+{
+    GT_U32 i;
+    char* buf;
+    char* src;
+
+    buf = (char*)destination;
+    src = (char*)source;
+
+    for(i=0; i<size; i++)
+    {
+        *buf++ = *src++;
+    }
+
+    return destination;
+}
+
+/*******************************************************************************
+* qdMemCmp
+*
+* DESCRIPTION:
+*       Compares given memories.
+*
+* INPUTS:
+*       src1 - source 1
+*       src2 - source 2
+*       size - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0, if equal.
+*        negative number, if src1 < src2.
+*        positive number, if src1 > src2.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int qdMemCmp
+(
+    IN char src1[],
+    IN char src2[],
+    IN GT_U32 size
+)
+{
+    GT_U32 i;
+    int value;
+
+    for(i=0; i<size; i++)
+    {
+        if((value = (int)(src1[i] - src2[i])) != 0)
+            return value;
+    }
+
+    return 0;
+}
+
+/*
+    Compare the given ethernet addresses.
+    0, if they are equal.
+    Negative int, if mac2 is bigger than mac1.
+    Positive int, if mac1 is bigger than mac2.
+*/
+int cmpEtherMac(unsigned char* mac1, unsigned char* mac2)
+{
+    int i, tmp;
+
+    for(i=0; i<6; i++)
+    {
+        if((tmp = mac1[i] - mac2[i]) != 0)
+            return tmp;
+    }
+    return 0;
+}
+
+/*
+    entry index, if found.
+    MAX_ATU_ADDRESS, otherwise.
+*/
+int qdSimATUFindNext(QDSIM_ATU_ENTRY* entry)
+{
+    int i;
+    int node = ATUList.head;
+
+    if (IS_BROADCAST_ADDR(entry->atuMac))
+    {
+        if(ATUList.atuSize != 0)
+        {
+            if (ATUNode[node].atuEntry.DBNum == entry->DBNum)
+                return node;
+            else
+            {
+                for(i=0; i<ATUList.atuSize; i++)
+                {
+                    if(ATUNode[node].atuEntry.DBNum == entry->DBNum)
+                        return node;
+                    node = ATUNode[node].nextEntry;
+                }
+            }
+
+        }
+        return MAX_ATU_ADDRESS;
+    }
+
+    for(i=0; i<ATUList.atuSize; i++)
+    {
+        if(cmpEtherMac(ATUNode[node].atuEntry.atuMac,entry->atuMac) > 0)
+        {
+            if(ATUNode[node].atuEntry.DBNum == entry->DBNum)
+                break;
+        }
+        node = ATUNode[node].nextEntry;
+    }
+
+    if (i == ATUList.atuSize)
+        return MAX_ATU_ADDRESS;
+
+    return node;
+}
+
+/*
+    Return 1, if added successfully.
+    Return 0, otherwise.
+*/
+GT_BOOL qdSimATUAdd(QDSIM_ATU_ENTRY* entry)
+{
+    int i, freeNode, preNode, node;
+
+    preNode = node = ATUList.head;
+
+    if (ATUList.atuSize >= MAX_ATU_ADDRESS)
+        return GT_FALSE;
+
+    /* find a free entry from our global memory. */
+    for(i=0; i<MAX_ATU_ADDRESS; i++)
+    {
+        if(ATUNode[i].nextEntry == MAX_ATU_ADDRESS)
+            break;
+    }
+
+    if (i==MAX_ATU_ADDRESS)
+    {
+        return GT_FALSE;
+    }
+
+    freeNode = i;
+
+    /* find the smallest entry which is bigger than the given entry */
+    for(i=0; i<ATUList.atuSize; i++)
+    {
+        if(cmpEtherMac(ATUNode[node].atuEntry.atuMac,entry->atuMac) >= 0)
+            break;
+        preNode = node;
+        node = ATUNode[node].nextEntry;
+    }
+
+    /* if the same Mac address is in the list and dbnum is identical, then just update and return. */
+    if (i != ATUList.atuSize)
+        if(cmpEtherMac(ATUNode[node].atuEntry.atuMac,entry->atuMac) == 0)
+        {
+            if(ATUNode[node].atuEntry.DBNum == entry->DBNum)
+            {
+                ATUNode[node].atuEntry.atuData = entry->atuData;
+                return GT_TRUE;
+            }
+        }
+
+    qdMemCpy(ATUNode[freeNode].atuEntry.atuMac, entry->atuMac, 6);
+    ATUNode[freeNode].atuEntry.atuData = entry->atuData;
+    ATUNode[freeNode].atuEntry.DBNum = entry->DBNum;
+
+    /* Add it to head */
+    if (i == 0)
+    {
+        ATUNode[freeNode].nextEntry = ATUList.head;
+        ATUList.head = freeNode;
+    }
+    /* Add it to tail */
+    else if (i == ATUList.atuSize)
+    {
+        ATUNode[preNode].nextEntry = freeNode;
+        ATUNode[freeNode].nextEntry = ATUList.head;
+    }
+    /* Add it in the middle of the list */
+    else
+    {
+        ATUNode[freeNode].nextEntry = ATUNode[preNode].nextEntry;
+        ATUNode[preNode].nextEntry = freeNode;
+    }
+    ATUList.atuSize++;
+    return GT_TRUE;
+}
+
+
+/*
+    Return 1, if added successfully.
+    Return 0, otherwise.
+*/
+GT_BOOL qdSimATUDel(QDSIM_ATU_ENTRY* entry)
+{
+    int i, preNode, node;
+
+    preNode = node = ATUList.head;
+
+    /* find the entry */
+    for(i=0; i<ATUList.atuSize; i++)
+    {
+        if(cmpEtherMac(ATUNode[node].atuEntry.atuMac,entry->atuMac) == 0)
+        {
+            if(ATUNode[node].atuEntry.DBNum == entry->DBNum)
+                break;
+        }
+        preNode = node;
+        node = ATUNode[node].nextEntry;
+    }
+
+    if (i == ATUList.atuSize)
+    {
+        /* cannot find the given entry to be deleted. */
+        return GT_FALSE;
+    }
+
+    /* Delete it from head */
+    if (i == 0)
+    {
+        ATUList.head = ATUNode[node].nextEntry;
+    }
+    /* Delete it in the middle of the list */
+    else if (i != ATUList.atuSize-1)
+    {
+        ATUNode[preNode].nextEntry = ATUNode[node].nextEntry;
+    }
+    ATUList.atuSize--;
+    ATUNode[node].nextEntry = MAX_ATU_ADDRESS;
+
+    return GT_TRUE;
+}
+
+
+GT_BOOL qdSimATUFlushUnlockedEntry()
+{
+    int i;
+
+    for (i=0; i<MAX_ATU_ADDRESS; i++)
+    {
+        if(((ATUNode[i].atuEntry.atuData & 0xF) != 0xF)    &&
+            (!(ATUNode[i].atuEntry.atuMac[0] & 1))         &&
+            (ATUNode[i].nextEntry != MAX_ATU_ADDRESS))
+        {
+            qdSimATUDel(&ATUNode[i].atuEntry);
+        }
+    }
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimATUFlushInDB(int dbNum)
+{
+    int i;
+
+    for (i=0; i<MAX_ATU_ADDRESS; i++)
+    {
+        if(ATUNode[i].atuEntry.DBNum != dbNum)
+            continue;
+        qdSimATUDel(&ATUNode[i].atuEntry);
+    }
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimATUFlushUnlockedInDB(int dbNum)
+{
+    int i;
+
+    for (i=0; i<MAX_ATU_ADDRESS; i++)
+    {
+        if(ATUNode[i].atuEntry.DBNum != dbNum)
+            continue;
+
+        if(((ATUNode[i].atuEntry.atuData & 0xF) != 0xF)    &&
+            (!(ATUNode[i].atuEntry.atuMac[0] & 1))         &&
+            (ATUNode[i].nextEntry != MAX_ATU_ADDRESS))
+        {
+            qdSimATUDel(&ATUNode[i].atuEntry);
+        }
+    }
+    return GT_TRUE;
+}
+
+
+void qdSimATUInit()
+{
+    int i;
+
+    qdMemSet((char*)ATUNode, 0, sizeof(ATUNode));
+
+    /* MAX_ATU_ADDRESS means entry i is free, otherwise, it's not free */
+    for (i=0; i<MAX_ATU_ADDRESS; i++)
+        ATUNode[i].nextEntry = MAX_ATU_ADDRESS;
+
+    ATUList.atuSize = 0;
+    ATUList.head = 0;
+}
+
+void qdSimGetATUInfo(QDSIM_ATU_ENTRY* entry)
+{
+    entry->atuData = qdSimRegs[qdSimDev.qdSimGlobalRegBase][12];
+    entry->atuMac[0] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] >> 8) & 0xFF;
+    entry->atuMac[1] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] & 0xFF;
+    entry->atuMac[2] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] >> 8) & 0xFF;
+    entry->atuMac[3] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] & 0xFF;
+    entry->atuMac[4] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] >> 8) & 0xFF;
+    entry->atuMac[5] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] & 0xFF;
+    entry->DBNum = qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] & 0xF;
+    return;
+}
+
+void qdSimSetATUInfo(QDSIM_ATU_ENTRY* entry)
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][12] = entry->atuData;
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] = (entry->atuMac[0]<<8) | entry->atuMac[1];
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] = (entry->atuMac[2]<<8) | entry->atuMac[3];
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] = (entry->atuMac[4]<<8) | entry->atuMac[5];
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] |= (entry->DBNum & 0xF);
+
+    return;
+}
+
+void qdSimReSetATUInfo()
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][12] = 0;
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] = 0xFFFF;
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] = 0xFFFF;
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] = 0xFFFF;
+
+    return;
+}
+
+GT_BOOL qdSimATUOperation(unsigned int value)
+{
+    QDSIM_ATU_ENTRY entry;
+    int    index;
+
+    switch((value & 0x7000) >> 12)
+    {
+        case 1:
+            /* Flush ALL */
+            qdSimATUInit();
+            break;
+        case 2:
+            /* Flush all unlocked entries */
+            return qdSimATUFlushUnlockedEntry();
+        case 3:
+            /* Load or Purge entry */
+            qdSimGetATUInfo(&entry);
+            if(entry.atuData & 0xF)
+                return qdSimATUAdd(&entry);
+            else
+                return qdSimATUDel(&entry);
+            break;
+        case 4:
+            /* Get Next Entry */
+            qdSimGetATUInfo(&entry);
+            index = qdSimATUFindNext(&entry);
+            if (index == MAX_ATU_ADDRESS)
+            {
+                qdSimReSetATUInfo();
+                return GT_TRUE;
+            }
+            else
+            {
+                qdSimSetATUInfo(&ATUNode[index].atuEntry);
+                return GT_TRUE;
+            }
+            break;
+        case 5:
+            /* Flush ALL in a DBNum */
+            return qdSimATUFlushInDB(value & 0xF);
+            break;
+        case 6:
+            /* Flush all unlocked entries */
+            return qdSimATUFlushUnlockedInDB(value & 0xF);
+        default:
+            break;
+    }
+    return GT_TRUE;
+}
+
+/*
+    VTU Related Routines
+*/
+
+/*
+    entry index, if found.
+    MAX_QD_VTU_ENTRIES, otherwise.
+*/
+int qdSimVTUFindNext(QDSIM_VTU_ENTRY* entry)
+{
+    int i;
+    int node = VTUList.head;
+
+    if (entry->vid == 0xFFF)
+    {
+        if(VTUList.vtuSize != 0)
+            return node;
+        else
+            return MAX_QD_VTU_ENTRIES;
+    }
+
+    for(i=0; i<VTUList.vtuSize; i++)
+    {
+        if(VTUNode[node].vtuEntry.vid > entry->vid)
+            break;
+        node = VTUNode[node].nextEntry;
+    }
+
+    if (i == VTUList.vtuSize)
+        return MAX_QD_VTU_ENTRIES;
+
+    return node;
+}
+
+/*
+    Return 1, if added successfully.
+    Return 0, otherwise.
+*/
+GT_BOOL qdSimVTUAdd(QDSIM_VTU_ENTRY* entry)
+{
+    int i, freeNode, preNode, node;
+
+    preNode = node = VTUList.head;
+
+    if (VTUList.vtuSize >= qdSimDev.vtuSize)
+        return GT_FALSE;
+
+    /* find a free entry from our global memory. */
+    for(i=0; i<MAX_QD_VTU_ENTRIES; i++)
+    {
+        if(VTUNode[i].nextEntry == MAX_QD_VTU_ENTRIES)
+            break;
+    }
+
+    if (i==MAX_QD_VTU_ENTRIES)
+    {
+        return GT_FALSE;
+    }
+
+    freeNode = i;
+
+    /* find the smallest entry which is bigger than the given entry */
+    for(i=0; i<VTUList.vtuSize; i++)
+    {
+        if(VTUNode[node].vtuEntry.vid >= entry->vid)
+            break;
+        preNode = node;
+        node = VTUNode[node].nextEntry;
+    }
+
+    /* if the same vid is in the list, then just update and return. */
+    if (i != VTUList.vtuSize)
+        if(VTUNode[node].vtuEntry.vid == entry->vid)
+        {
+            qdMemCpy(&VTUNode[node].vtuEntry, entry, sizeof(QDSIM_VTU_ENTRY));
+            return GT_TRUE;
+        }
+
+    qdMemCpy(&VTUNode[freeNode].vtuEntry, entry, sizeof(QDSIM_VTU_ENTRY));
+
+    /* Add it to head */
+    if (i == 0)
+    {
+        VTUNode[freeNode].nextEntry = VTUList.head;
+        VTUList.head = freeNode;
+    }
+    /* Add it to tail */
+    else if (i == VTUList.vtuSize)
+    {
+        VTUNode[preNode].nextEntry = freeNode;
+        VTUNode[freeNode].nextEntry = VTUList.head;
+    }
+    /* Add it in the middle of the list */
+    else
+    {
+        VTUNode[freeNode].nextEntry = VTUNode[preNode].nextEntry;
+        VTUNode[preNode].nextEntry = freeNode;
+    }
+    VTUList.vtuSize++;
+    return GT_TRUE;
+}
+
+
+/*
+    Return 1, if added successfully.
+    Return 0, otherwise.
+*/
+GT_BOOL qdSimVTUDel(QDSIM_VTU_ENTRY* entry)
+{
+    int i, preNode, node;
+
+    preNode = node = VTUList.head;
+
+    /* find the entry */
+    for(i=0; i<VTUList.vtuSize; i++)
+    {
+        if(VTUNode[node].vtuEntry.vid == entry->vid)
+            break;
+        preNode = node;
+        node = VTUNode[node].nextEntry;
+    }
+
+    if (i == VTUList.vtuSize)
+    {
+        /* cannot find the given entry to be deleted. */
+        return GT_FALSE;
+    }
+
+    /* Delete it from head */
+    if (i == 0)
+    {
+        VTUList.head = VTUNode[node].nextEntry;
+    }
+    /* Delete it in the middle of the list */
+    else if (i != VTUList.vtuSize-1)
+    {
+        VTUNode[preNode].nextEntry = VTUNode[node].nextEntry;
+    }
+    VTUList.vtuSize--;
+    VTUNode[node].nextEntry = MAX_QD_VTU_ENTRIES;
+
+    return GT_TRUE;
+}
+
+
+/*
+    Return 1, if added successfully.
+    Return 0, otherwise.
+*/
+GT_BOOL qdSimVTUUpdate(QDSIM_VTU_ENTRY* entry)
+{
+    int i;
+    int node = VTUList.head;
+
+    /* find the entry */
+    for(i=0; i<VTUList.vtuSize; i++)
+    {
+        if(VTUNode[node].vtuEntry.vid == entry->vid)
+            break;
+        node = VTUNode[node].nextEntry;
+    }
+
+    if (i == VTUList.vtuSize)
+    {
+        /* cannot find the given entry to be deleted. */
+        return GT_FALSE;
+    }
+
+    /* Update the found entry */
+    qdMemCpy(&VTUNode[node].vtuEntry, entry, sizeof(QDSIM_VTU_ENTRY));
+
+    return GT_TRUE;
+}
+
+void qdSimVTUInit()
+{
+    int i;
+
+    qdMemSet((char*)VTUNode, 0, sizeof(VTUNode));
+
+    /* MAX_ATU_ADDRESS means entry i is free, otherwise, it's not free */
+    for (i=0; i<MAX_QD_VTU_ENTRIES; i++)
+        VTUNode[i].nextEntry = MAX_QD_VTU_ENTRIES;
+
+    VTUList.vtuSize = 0;
+    VTUList.head = 0;
+}
+
+void qdSimGetVTUInfo(QDSIM_VTU_ENTRY* entry)
+{
+    entry->DBNum = qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] & 0xF;
+    entry->vid = qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] & 0x1FFF;
+    entry->memberTag[0] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] & 0x3;
+    entry->memberTag[1] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] >> 4) & 0x3;
+    entry->memberTag[2] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] >> 8) & 0x3;
+    entry->memberTag[3] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] >> 12) & 0x3;
+    entry->memberTag[4] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] & 0x3;
+    entry->memberTag[5] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] >> 4) & 0x3;
+    entry->memberTag[6] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] >> 8) & 0x3;
+    entry->memberTag[7] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] >> 12) & 0x3;
+    entry->memberTag[8] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][9] & 0x3;
+    entry->memberTag[9] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][9] >> 4) & 0x3;
+
+    return;
+}
+
+void qdSimSetVTUInfo(QDSIM_VTU_ENTRY* entry)
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= entry->DBNum;
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = (entry->vid & 0xFFF) | 0x1000;
+
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] =     entry->memberTag[0] |
+                        (entry->memberTag[1] << 4) |
+                        (entry->memberTag[2] << 8) |
+                        (entry->memberTag[3] << 12);
+
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] =     entry->memberTag[4] |
+                        (entry->memberTag[5] << 4) |
+                        (entry->memberTag[6] << 8) |
+                        (entry->memberTag[7] << 12);
+
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][9] =     entry->memberTag[8] |
+                        (entry->memberTag[9] << 4);
+
+    return;
+}
+
+void qdSimReSetVTUInfo()
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 0xFFF;
+
+    return;
+}
+
+void qdSimVTUGetViolation()
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0xFFF;
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= 1;    /* assume port 1 causes the violation */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 1;    /* assume vid 1 causes the violation */
+}
+
+void qdSimVTUResetBusy()
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0x8000;
+
+    return;
+}
+
+GT_BOOL qdSimVTUOperation(unsigned int value)
+{
+    QDSIM_VTU_ENTRY entry;
+    int    index;
+
+    if(!(value & 0x8000))
+        return GT_FALSE;
+
+    qdSimVTUResetBusy();
+
+    switch((value & 0x7000) >> 12)
+    {
+        case 1:
+            /* Flush ALL */
+            qdSimVTUInit();
+            break;
+        case 3:
+            /* Load or Purge entry */
+            qdSimGetVTUInfo(&entry);
+            if(entry.vid & 0x1000)
+            {
+                entry.vid &= ~0x1000;
+                return qdSimVTUAdd(&entry);
+            }
+            else
+                return qdSimVTUDel(&entry);
+            break;
+        case 4:
+            /* Get Next Entry */
+            qdSimGetVTUInfo(&entry);
+            entry.vid &= ~0x1000;
+            index = qdSimVTUFindNext(&entry);
+            if (index == MAX_QD_VTU_ENTRIES)
+            {
+                qdSimReSetVTUInfo();
+                return GT_TRUE;
+            }
+            else
+            {
+                qdSimSetVTUInfo(&VTUNode[index].vtuEntry);
+                return GT_TRUE;
+            }
+            break;
+        case 7:
+            qdSimVTUGetViolation();
+            break;
+        default:
+            break;
+    }
+    return GT_TRUE;
+}
+
+void qdSimStatsInit()
+{
+    int i;
+
+    for(i=0; i<qdSimDev.qdSimNumOfPorts; i++)
+        qdSimDev.qdSimPortStatsClear[i] = 0;
+
+}
+
+GT_BOOL qdSimStatsOperation(unsigned int value)
+{
+    int    i;
+
+    if(!(value & 0x8000))
+        return GT_FALSE;
+
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][29] &= ~0x8000;
+
+    switch((value & 0x7000) >> 12)
+    {
+        case 1:
+            /* Flush ALL */
+            for(i=0; i<qdSimDev.qdSimNumOfPorts; i++)
+                qdSimDev.qdSimPortStatsClear[i] = 1;
+            break;
+        case 2:
+            /* Flush a port */
+            if ((value & 0x3F) >= (unsigned int)qdSimDev.qdSimNumOfPorts)
+                return GT_FALSE;
+            qdSimDev.qdSimPortStatsClear[value & 0x3F] = 1;
+            break;
+        case 4:
+            /* Read a counter */
+            if(qdSimDev.qdSimPortStatsClear[qdSimDev.qdSimStatsCapturedPort] == 1)
+            {
+                qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = 0;
+                qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = 0;
+            }
+            else
+            {
+                qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = qdSimDev.qdSimStatsCapturedPort;
+                qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = value & 0x3F;
+            }
+            break;
+        case 5:
+            if ((value & 0x3F) >= (unsigned int)qdSimDev.qdSimNumOfPorts)
+                return GT_FALSE;
+            qdSimDev.qdSimStatsCapturedPort = value & 0x3F;
+            break;
+        default:
+            return GT_FALSE;
+    }
+    return GT_TRUE;
+}
+
+#define QD_PHY_CONTROL_RW (QD_PHY_RESET|QD_PHY_LOOPBACK|QD_PHY_SPEED|QD_PHY_AUTONEGO|QD_PHY_POWER|QD_PHY_RESTART_AUTONEGO|QD_PHY_DUPLEX)
+#define QD_PHY_CONTROL_RO (~QD_PHY_CONTROL_RW)
+
+GT_BOOL qdSimPhyControl(unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+
+    /* reset all the Read Only bits. */
+    value &= QD_PHY_CONTROL_RW;
+
+    /* If powerDown is set, add Reset and Restart Auto bits. */
+    if(value & QD_PHY_POWER)
+    {
+        value |= (QD_PHY_RESET|QD_PHY_RESTART_AUTONEGO);
+        qdSimRegs[portNumber][miiReg] = (GT_U16)value;
+        return GT_TRUE;
+    }
+
+    /* If Power Down was set, clear Reset and Restart Auto bits. */
+    if(qdSimRegs[portNumber][miiReg] & QD_PHY_POWER)
+    {
+        value &= ~(QD_PHY_RESET|QD_PHY_RESTART_AUTONEGO);
+        qdSimRegs[portNumber][miiReg] = (GT_U16)value;
+        return GT_TRUE;
+    }
+
+    /* If Reset or Restart Auto set, replace with current value and clear Reset/Restart Auto. */
+    if (value & (QD_PHY_RESET|QD_PHY_RESTART_AUTONEGO))
+    {
+        value &= ~(QD_PHY_RESET|QD_PHY_RESTART_AUTONEGO);
+        qdSimRegs[portNumber][miiReg] = (GT_U16)value;
+        return GT_TRUE;
+    }
+    else
+    {
+        value &= ~(QD_PHY_SPEED|QD_PHY_AUTONEGO|QD_PHY_DUPLEX);
+        qdSimRegs[portNumber][miiReg] &= (QD_PHY_SPEED|QD_PHY_AUTONEGO|QD_PHY_DUPLEX);
+        qdSimRegs[portNumber][miiReg] |= (GT_U16)value;
+        return GT_TRUE;
+    }
+
+    return GT_TRUE;
+}
+
+void qdSimRegsInit_6021()
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] = 0;    /* VTU Operation Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 0;    /* VTU VID Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] = 0;    /* VTU Data Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][29] = 0;    /* Stats Operation Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = 0;    /* Stats Counter Register Bytes 3,2 */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = 0;    /* Stats Counter Register Bytes 1,0 */
+}
+
+void qdSimRegsInit_6063()
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] = 0;    /* VTU Operation Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 0;    /* VTU VID Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] = 0;    /* VTU Data Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] = 0;    /* VTU Data Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][29] = 0;    /* Stats Operation Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = 0;    /* Stats Counter Register Bytes 3,2 */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = 0;    /* Stats Counter Register Bytes 1,0 */
+}
+
+void qdSimRegsInit_6083()
+{
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] = 0;    /* VTU Operation Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 0;    /* VTU VID Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] = 0;    /* VTU Data Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] = 0;    /* VTU Data Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][9] = 0;    /* VTU Data Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][29] = 0;    /* Stats Operation Register */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = 0;    /* Stats Counter Register Bytes 3,2 */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = 0;    /* Stats Counter Register Bytes 1,0 */
+}
+
+void qdSimRegsInit()
+{
+    int i;
+
+    qdMemSet(qdSimRegs, 0xff, sizeof(qdSimRegs));
+
+    /*
+        PHY Registers Setup
+    */
+    for(i=0; i<qdSimDev.qdSimNumOfPhys; i++)
+    {
+        qdSimRegs[i][0] = 0x3100;    /* PHY Control */
+        qdSimRegs[i][1] = 0x7849;    /* PHY Status */
+        qdSimRegs[i][2] = 0x0141;    /* PHY Id 1 */
+        qdSimRegs[i][3] = 0x0c1f;    /* PHY Id 2 */
+        qdSimRegs[i][4] = 0x01e1;    /* AutoNego Ad */
+        qdSimRegs[i][5] = 0;        /* Partner Ability */
+        qdSimRegs[i][6] = 4;        /* AutoNego Expansion */
+        qdSimRegs[i][7] = 0x2001;    /* Next Page Transmit */
+        qdSimRegs[i][8] = 0;        /* Link Partner Next Page */
+        qdSimRegs[i][16] = 0x130;    /* Phy Specific Control */
+        qdSimRegs[i][17] = 0x40;    /* Phy Specific Status */
+        qdSimRegs[i][18] = 0;        /* Phy Interrupt Enable */
+        qdSimRegs[i][19] = 0x40;    /* Phy Interrupt Status */
+        qdSimRegs[i][20] = 0;        /* Interrupt Port Summary */
+        qdSimRegs[i][21] = 0;        /* Receive Error Counter */
+        qdSimRegs[i][22] = 0xa34;    /* LED Parallel Select */
+        qdSimRegs[i][23] = 0x3fc;    /* LED Stream Select */
+        qdSimRegs[i][24] = 0x42bf;    /* LED Control */
+    }
+
+    /*
+        Port Registers Setup
+    */
+    for(i=qdSimDev.qdSimPortBase; i<qdSimDev.qdSimNumOfPorts+qdSimDev.qdSimPortBase; i++)
+    {
+        qdSimRegs[i][0] = 0x800;    /* Port Status */
+        qdSimRegs[i][3] = (GT_U16)qdSimDev.qdSimDevId << 4;    /* Switch ID */
+        qdSimRegs[i][4] = 0x7f;    /* Port Control */
+        qdSimRegs[i][6] = 0x7f & (~(1 << (i-8)));    /* Port Based Vlan Map */
+        qdSimRegs[i][7] = 1;        /* Default Port Vlan ID & Priority */
+        qdSimRegs[i][16] = 0;        /* Rx Frame Counter */
+        qdSimRegs[i][17] = 0;        /* Tx Frame Counter */
+    }
+
+    /*
+        Global Registers Setup
+    */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][0] = 0x3c01;    /* Global Status */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][1] = 0;        /* Switch Mac Addr 0 ~ 1 byte */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][2] = 0;        /* Switch Mac Addr 2 ~ 3 byte */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][3] = 0;        /* Switch Mac Addr 4 ~ 5 byte */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][4] = 0x81;    /* Global Control */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][10] = 0x1130;        /* ATU Control */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] = 0;                /* ATU Operation */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][12] = 0;                /* ATU Data */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] = 0;                /* ATU Mac Addr 0 ~ 1 byte */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] = 0;                /* ATU Mac Addr 2 ~ 3 byte */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] = 0;                /* ATU Mac Addr 4 ~ 5 byte */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][16] = 0;            /* IP-PRI Mapping */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][17] = 0;            /* IP-PRI Mapping */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][18] = 0x5555;    /* IP-PRI Mapping */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][19] = 0x5555;    /* IP-PRI Mapping */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][20] = 0xaaaa;    /* IP-PRI Mapping */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][21] = 0xaaaa;    /* IP-PRI Mapping */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][22] = 0xffff;    /* IP-PRI Mapping */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][23] = 0xffff;    /* IP-PRI Mapping */
+    qdSimRegs[qdSimDev.qdSimGlobalRegBase][24] = 0xfa41;    /* IEEE-PRI Mapping */
+
+    switch(qdSimDev.qdSimDevId)
+    {
+        case GT_88E6021:
+            qdSimRegsInit_6021();
+            break;
+        case GT_88E6063:
+        case GT_FF_HG:
+        case GT_FF_EG:
+        case GT_FH_VPN:
+            qdSimRegsInit_6063();
+            break;
+        case GT_88E6083:
+            qdSimRegsInit_6083();
+            break;
+        default:
+            break;
+    }
+}
+
+GT_BOOL qdSimRead_6052(unsigned int portNumber , unsigned int miiReg, unsigned int* value)
+{
+    *value = (unsigned int) qdSimRegs[portNumber][miiReg];
+
+    if (IS_GLOBAL_REG(portNumber))    /* Global register */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_GLOBAL_STATUS:
+                    qdSimRegs[portNumber][miiReg] &= ~0xF;
+                    if(qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG])
+                        qdSimRegs[portNumber][miiReg] |= 0x2;
+
+                    break;
+            case QD_REG_MACADDR_01:
+            case QD_REG_MACADDR_23:
+            case QD_REG_MACADDR_45:
+            case QD_REG_GLOBAL_CONTROL:
+            case QD_REG_ATU_CONTROL:
+            case QD_REG_ATU_OPERATION:
+            case QD_REG_ATU_DATA_REG:
+            case QD_REG_ATU_MAC_01:
+            case QD_REG_ATU_MAC_23:
+            case QD_REG_ATU_MAC_45:
+            case QD_REG_IP_PRI_REG0:
+            case QD_REG_IP_PRI_REG1:
+            case QD_REG_IP_PRI_REG2:
+            case QD_REG_IP_PRI_REG3:
+            case QD_REG_IP_PRI_REG4:
+            case QD_REG_IP_PRI_REG5:
+            case QD_REG_IP_PRI_REG6:
+            case QD_REG_IP_PRI_REG7:
+            case QD_REG_IEEE_PRI:
+                    break;
+        }
+    }
+    else if(IS_PORT_REG(portNumber))    /* Port registers */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_PORT_STATUS:
+            case QD_REG_SWITCH_ID:
+            case QD_REG_PORT_CONTROL:
+            case QD_REG_PORT_VLAN_MAP:
+            case QD_REG_PVID:
+            case QD_REG_RXCOUNTER:
+            case QD_REG_TXCOUNTER:
+                    break;
+        }
+    }
+    else if(IS_PHY_REG(portNumber))    /* phy registers */
+    {
+        switch(miiReg)
+        {
+            case QD_PHY_CONTROL_REG:
+                    break;
+            case QD_PHY_INT_ENABLE_REG:
+                    break;
+            case QD_PHY_INT_STATUS_REG:
+                    qdSimRegs[portNumber][miiReg] = 0;
+                    qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
+                    break;
+            case QD_PHY_INT_PORT_SUMMARY_REG:
+                    *value = (unsigned int) qdSimRegs[0][miiReg];
+                    break;
+        }
+    }
+
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimRead_6021(unsigned int portNumber , unsigned int miiReg, unsigned int* value)
+{
+    *value = (unsigned int) qdSimRegs[portNumber][miiReg];
+
+    if (IS_GLOBAL_REG(portNumber))    /* Global register */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_GLOBAL_STATUS:
+                    qdSimRegs[portNumber][miiReg] &= ~0x7F;
+                    if(qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG])
+                        qdSimRegs[portNumber][miiReg] |= 0x2;
+
+                    break;
+            case QD_REG_MACADDR_01:
+            case QD_REG_MACADDR_23:
+            case QD_REG_MACADDR_45:
+            case QD_REG_VTU_OPERATION:
+            case QD_REG_VTU_VID_REG:
+            case QD_REG_VTU_DATA1_REG:
+            case QD_REG_VTU_DATA2_REG:
+            case QD_REG_GLOBAL_CONTROL:
+            case QD_REG_ATU_CONTROL:
+            case QD_REG_ATU_OPERATION:
+            case QD_REG_ATU_DATA_REG:
+            case QD_REG_ATU_MAC_01:
+            case QD_REG_ATU_MAC_23:
+            case QD_REG_ATU_MAC_45:
+            case QD_REG_IP_PRI_REG0:
+            case QD_REG_IP_PRI_REG1:
+            case QD_REG_IP_PRI_REG2:
+            case QD_REG_IP_PRI_REG3:
+            case QD_REG_IP_PRI_REG4:
+            case QD_REG_IP_PRI_REG5:
+            case QD_REG_IP_PRI_REG6:
+            case QD_REG_IP_PRI_REG7:
+            case QD_REG_IEEE_PRI:
+            case QD_REG_STATS_OPERATION:
+            case QD_REG_STATS_COUNTER3_2:
+            case QD_REG_STATS_COUNTER1_0:
+                    break;
+        }
+    }
+    else if(IS_PORT_REG(portNumber))    /* Port registers */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_PORT_STATUS:
+            case QD_REG_SWITCH_ID:
+            case QD_REG_PORT_CONTROL:
+            case QD_REG_PORT_VLAN_MAP:
+            case QD_REG_PVID:
+            case QD_REG_RATE_CTRL:
+            case QD_REG_PAV:
+            case QD_REG_RXCOUNTER:
+            case QD_REG_TXCOUNTER:
+            case QD_REG_Q_COUNTER:
+                    break;
+        }
+    }
+    else if(IS_PHY_REG(portNumber))    /* phy registers */
+    {
+        switch(miiReg)
+        {
+            case QD_PHY_CONTROL_REG:
+                    break;
+            case QD_PHY_INT_ENABLE_REG:
+                    break;
+            case QD_PHY_INT_STATUS_REG:
+                    qdSimRegs[portNumber][miiReg] = 0;
+                    qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
+                    break;
+            case QD_PHY_INT_PORT_SUMMARY_REG:
+                    *value = (unsigned int) qdSimRegs[0][miiReg];
+                    break;
+        }
+    }
+
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimRead_6063(unsigned int portNumber , unsigned int miiReg, unsigned int* value)
+{
+    *value = (unsigned int) qdSimRegs[portNumber][miiReg];
+
+    if (IS_GLOBAL_REG(portNumber))    /* Global register */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_GLOBAL_STATUS:
+                    qdSimRegs[portNumber][miiReg] &= ~0x7F;
+                    if(qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG])
+                        qdSimRegs[portNumber][miiReg] |= 0x2;
+
+                    break;
+            case QD_REG_MACADDR_01:
+            case QD_REG_MACADDR_23:
+            case QD_REG_MACADDR_45:
+            case QD_REG_VTU_OPERATION:
+            case QD_REG_VTU_VID_REG:
+            case QD_REG_VTU_DATA1_REG:
+            case QD_REG_VTU_DATA2_REG:
+            case QD_REG_GLOBAL_CONTROL:
+            case QD_REG_ATU_CONTROL:
+            case QD_REG_ATU_OPERATION:
+            case QD_REG_ATU_DATA_REG:
+            case QD_REG_ATU_MAC_01:
+            case QD_REG_ATU_MAC_23:
+            case QD_REG_ATU_MAC_45:
+            case QD_REG_IP_PRI_REG0:
+            case QD_REG_IP_PRI_REG1:
+            case QD_REG_IP_PRI_REG2:
+            case QD_REG_IP_PRI_REG3:
+            case QD_REG_IP_PRI_REG4:
+            case QD_REG_IP_PRI_REG5:
+            case QD_REG_IP_PRI_REG6:
+            case QD_REG_IP_PRI_REG7:
+            case QD_REG_IEEE_PRI:
+            case QD_REG_STATS_OPERATION:
+            case QD_REG_STATS_COUNTER3_2:
+            case QD_REG_STATS_COUNTER1_0:
+                    break;
+        }
+    }
+    else if(IS_PORT_REG(portNumber))    /* Port registers */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_PORT_STATUS:
+            case QD_REG_SWITCH_ID:
+            case QD_REG_PORT_CONTROL:
+            case QD_REG_PORT_VLAN_MAP:
+            case QD_REG_PVID:
+            case QD_REG_RATE_CTRL:
+            case QD_REG_PAV:
+            case QD_REG_RXCOUNTER:
+            case QD_REG_TXCOUNTER:
+            case QD_REG_Q_COUNTER:
+                    break;
+        }
+    }
+    else if(IS_PHY_REG(portNumber))    /* phy registers */
+    {
+        switch(miiReg)
+        {
+            case QD_PHY_CONTROL_REG:
+                    break;
+            case QD_PHY_INT_ENABLE_REG:
+                    break;
+            case QD_PHY_INT_STATUS_REG:
+                    qdSimRegs[portNumber][miiReg] = 0;
+                    qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
+                    break;
+            case QD_PHY_INT_PORT_SUMMARY_REG:
+                    *value = (unsigned int) qdSimRegs[0][miiReg];
+                    break;
+        }
+    }
+
+    return GT_TRUE;
+}
+
+
+GT_BOOL qdSimRead_6083(unsigned int portNumber , unsigned int miiReg, unsigned int* value)
+{
+    *value = (unsigned int) qdSimRegs[portNumber][miiReg];
+
+    if (IS_GLOBAL_REG(portNumber))    /* Global register */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_GLOBAL_STATUS:
+                    qdSimRegs[portNumber][miiReg] &= ~0x7F;
+                    if(qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG])
+                        qdSimRegs[portNumber][miiReg] |= 0x2;
+
+                    break;
+            case QD_REG_MACADDR_01:
+            case QD_REG_MACADDR_23:
+            case QD_REG_MACADDR_45:
+            case QD_REG_VTU_OPERATION:
+            case QD_REG_VTU_VID_REG:
+            case QD_REG_VTU_DATA1_REG:
+            case QD_REG_VTU_DATA2_REG:
+            case QD_REG_GLOBAL_CONTROL:
+            case QD_REG_ATU_CONTROL:
+            case QD_REG_ATU_OPERATION:
+            case QD_REG_ATU_DATA_REG:
+            case QD_REG_ATU_MAC_01:
+            case QD_REG_ATU_MAC_23:
+            case QD_REG_ATU_MAC_45:
+            case QD_REG_IP_PRI_REG0:
+            case QD_REG_IP_PRI_REG1:
+            case QD_REG_IP_PRI_REG2:
+            case QD_REG_IP_PRI_REG3:
+            case QD_REG_IP_PRI_REG4:
+            case QD_REG_IP_PRI_REG5:
+            case QD_REG_IP_PRI_REG6:
+            case QD_REG_IP_PRI_REG7:
+            case QD_REG_IEEE_PRI:
+            case QD_REG_STATS_OPERATION:
+            case QD_REG_STATS_COUNTER3_2:
+            case QD_REG_STATS_COUNTER1_0:
+                    break;
+        }
+    }
+    else if(IS_PORT_REG(portNumber))    /* Port registers */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_PORT_STATUS:
+            case QD_REG_SWITCH_ID:
+            case QD_REG_PORT_CONTROL:
+            case QD_REG_PORT_VLAN_MAP:
+            case QD_REG_PVID:
+            case QD_REG_RATE_CTRL:
+            case QD_REG_PAV:
+            case QD_REG_RXCOUNTER:
+            case QD_REG_TXCOUNTER:
+            case QD_REG_Q_COUNTER:
+                    break;
+        }
+    }
+    else if(IS_PHY_REG(portNumber))    /* phy registers */
+    {
+        switch(miiReg)
+        {
+            case QD_PHY_CONTROL_REG:
+                    break;
+            case QD_PHY_INT_ENABLE_REG:
+                    break;
+            case QD_PHY_INT_STATUS_REG:
+                    qdSimRegs[portNumber][miiReg] = 0;
+                    qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
+                    break;
+            case QD_PHY_INT_PORT_SUMMARY_REG:
+                    *value = (unsigned int) qdSimRegs[0][miiReg];
+                    break;
+        }
+    }
+
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimRead (GT_QD_DEV *dev,unsigned int portNumber , unsigned int miiReg, unsigned int* value)
+{
+    if (portNumber >= MAX_SMI_ADDRESS)
+        portNumber -= MAX_SMI_ADDRESS;
+
+    if ((portNumber >= MAX_SMI_ADDRESS) || (miiReg >= MAX_REG_ADDRESS))
+        return GT_FALSE;
+
+    switch(qdSimDev.qdSimDevId)
+    {
+        case GT_88E6051:
+        case GT_88E6052:
+            return qdSimRead_6052(portNumber, miiReg, value);
+        case GT_88E6021:
+            return qdSimRead_6021(portNumber, miiReg, value);
+        case GT_88E6063:
+        case GT_FF_HG:
+        case GT_FF_EG:
+        case GT_FH_VPN:
+            return qdSimRead_6063(portNumber, miiReg, value);
+        case GT_88E6083:
+            return qdSimRead_6083(portNumber, miiReg, value);
+        default:
+            break;
+    }
+
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimWrite_6052 (unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+    GT_BOOL status;
+
+    if (IS_GLOBAL_REG(portNumber))    /* Global register */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_GLOBAL_STATUS:
+                    /* readonly register */
+                    return GT_FALSE;
+            case QD_REG_MACADDR_01:
+            case QD_REG_MACADDR_23:
+            case QD_REG_MACADDR_45:
+                    break;
+            case QD_REG_GLOBAL_CONTROL:
+                    if(value & 0x200)
+                    {
+                        /* Reload EEPROM values */
+                        qdSimRegsInit();
+                        qdSimRegs[portNumber][QD_REG_GLOBAL_STATUS] |= 0x1;
+                        return GT_TRUE;
+                    }
+                    break;
+            case QD_REG_ATU_CONTROL:
+                    value &= ~0x8000;
+                    break;
+            case QD_REG_ATU_OPERATION:
+                    status = qdSimATUOperation(value);
+                    return status;
+            case QD_REG_ATU_DATA_REG:
+            case QD_REG_ATU_MAC_01:
+            case QD_REG_ATU_MAC_23:
+            case QD_REG_ATU_MAC_45:
+            case QD_REG_IP_PRI_REG0:
+            case QD_REG_IP_PRI_REG1:
+            case QD_REG_IP_PRI_REG2:
+            case QD_REG_IP_PRI_REG3:
+            case QD_REG_IP_PRI_REG4:
+            case QD_REG_IP_PRI_REG5:
+            case QD_REG_IP_PRI_REG6:
+            case QD_REG_IP_PRI_REG7:
+            case QD_REG_IEEE_PRI:
+                    break;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else if(IS_PORT_REG(portNumber))    /* Port registers */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_PORT_STATUS:
+            case QD_REG_SWITCH_ID:
+                    /* readonly registers */
+                    return GT_FALSE;
+            case QD_REG_PORT_CONTROL:
+            case QD_REG_PORT_VLAN_MAP:
+            case QD_REG_PVID:
+                    break;
+            case QD_REG_RXCOUNTER:
+            case QD_REG_TXCOUNTER:
+                    /* readonly registers */
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else if(IS_PHY_REG(portNumber))    /* phy registers */
+    {
+        switch(miiReg)
+        {
+            case QD_PHY_CONTROL_REG:
+                    return qdSimPhyControl(portNumber,miiReg,value);
+            case QD_PHY_INT_ENABLE_REG:
+            case QD_PHY_AUTONEGO_AD_REG:
+            case QD_PHY_NEXTPAGE_TX_REG:
+            case QD_PHY_SPEC_CONTROL_REG:
+                    break;
+            case QD_PHY_INT_STATUS_REG:
+            case QD_PHY_INT_PORT_SUMMARY_REG:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else
+        return GT_FALSE;
+
+    qdSimRegs[portNumber][miiReg] = (GT_U16)value;
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimWrite_6021 (unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+    GT_BOOL status;
+
+    if (IS_GLOBAL_REG(portNumber))    /* Global register */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_GLOBAL_STATUS:
+                    /* readonly register */
+                    return GT_FALSE;
+            case QD_REG_MACADDR_01:
+            case QD_REG_MACADDR_23:
+            case QD_REG_MACADDR_45:
+                    break;
+            case QD_REG_VTU_OPERATION:
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0xF;
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= (value & 0xF);
+                    status = qdSimVTUOperation(value);
+                    return status;
+            case QD_REG_VTU_VID_REG:
+            case QD_REG_VTU_DATA1_REG:
+            case QD_REG_VTU_DATA2_REG:
+                    break;
+            case QD_REG_GLOBAL_CONTROL:
+                    if(value & 0x200)
+                    {
+                        /* Reload EEPROM values */
+                        qdSimRegsInit();
+                        qdSimRegs[portNumber][QD_REG_GLOBAL_STATUS] |= 0x1;
+                        return GT_TRUE;
+                    }
+                    break;
+            case QD_REG_ATU_CONTROL:
+                    value &= ~0x8000;
+                    break;
+            case QD_REG_ATU_OPERATION:
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] |= (value & 0xF);
+                    status = qdSimATUOperation(value);
+                    return status;
+            case QD_REG_ATU_DATA_REG:
+            case QD_REG_ATU_MAC_01:
+            case QD_REG_ATU_MAC_23:
+            case QD_REG_ATU_MAC_45:
+            case QD_REG_IP_PRI_REG0:
+            case QD_REG_IP_PRI_REG1:
+            case QD_REG_IP_PRI_REG2:
+            case QD_REG_IP_PRI_REG3:
+            case QD_REG_IP_PRI_REG4:
+            case QD_REG_IP_PRI_REG5:
+            case QD_REG_IP_PRI_REG6:
+            case QD_REG_IP_PRI_REG7:
+            case QD_REG_IEEE_PRI:
+                    break;
+            case QD_REG_STATS_OPERATION:
+                    status = qdSimStatsOperation(value);
+                    return status;
+            case QD_REG_STATS_COUNTER3_2:
+            case QD_REG_STATS_COUNTER1_0:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else if(IS_PORT_REG(portNumber))    /* Port registers */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_PORT_STATUS:
+                    if(portNumber > 9)
+                    {
+                        qdSimRegs[portNumber][miiReg] &= ~QD_PORT_STATUS_DUPLEX;
+                        qdSimRegs[portNumber][miiReg] |= (value & QD_PORT_STATUS_DUPLEX);
+                        return GT_TRUE;
+                    }
+            case QD_REG_SWITCH_ID:
+                    /* readonly registers */
+                    return GT_FALSE;
+            case QD_REG_PORT_CONTROL:
+            case QD_REG_PORT_VLAN_MAP:
+            case QD_REG_PVID:
+                    break;
+            case QD_REG_RATE_CTRL:
+            case QD_REG_PAV:
+            case QD_REG_RXCOUNTER:
+            case QD_REG_TXCOUNTER:
+                    /* readonly registers */
+                    return GT_FALSE;
+            case QD_REG_Q_COUNTER:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else if(IS_PHY_REG(portNumber))    /* phy registers */
+    {
+        switch(miiReg)
+        {
+            case QD_PHY_CONTROL_REG:
+                    return qdSimPhyControl(portNumber,miiReg,value);
+            case QD_PHY_INT_ENABLE_REG:
+            case QD_PHY_AUTONEGO_AD_REG:
+            case QD_PHY_NEXTPAGE_TX_REG:
+            case QD_PHY_SPEC_CONTROL_REG:
+                    break;
+            case QD_PHY_INT_STATUS_REG:
+            case QD_PHY_INT_PORT_SUMMARY_REG:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else
+        return GT_FALSE;
+
+    qdSimRegs[portNumber][miiReg] = (GT_U16)value;
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimWrite_6063 (unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+    GT_BOOL status;
+
+    if (IS_GLOBAL_REG(portNumber))    /* Global register */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_GLOBAL_STATUS:
+                    /* readonly register */
+                    return GT_FALSE;
+            case QD_REG_MACADDR_01:
+            case QD_REG_MACADDR_23:
+            case QD_REG_MACADDR_45:
+                    break;
+            case QD_REG_VTU_OPERATION:
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0xF;
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= (value & 0xF);
+                    status = qdSimVTUOperation(value);
+                    return status;
+            case QD_REG_VTU_VID_REG:
+            case QD_REG_VTU_DATA1_REG:
+            case QD_REG_VTU_DATA2_REG:
+                    break;
+            case QD_REG_GLOBAL_CONTROL:
+                    if(value & 0x200)
+                    {
+                        /* Reload EEPROM values */
+                        qdSimRegsInit();
+                        qdSimRegs[portNumber][QD_REG_GLOBAL_STATUS] |= 0x1;
+                        return GT_TRUE;
+                    }
+                    break;
+            case QD_REG_ATU_CONTROL:
+                    value &= ~0x8000;
+                    break;
+            case QD_REG_ATU_OPERATION:
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] |= (value & 0xF);
+                    status = qdSimATUOperation(value);
+                    return status;
+            case QD_REG_ATU_DATA_REG:
+            case QD_REG_ATU_MAC_01:
+            case QD_REG_ATU_MAC_23:
+            case QD_REG_ATU_MAC_45:
+            case QD_REG_IP_PRI_REG0:
+            case QD_REG_IP_PRI_REG1:
+            case QD_REG_IP_PRI_REG2:
+            case QD_REG_IP_PRI_REG3:
+            case QD_REG_IP_PRI_REG4:
+            case QD_REG_IP_PRI_REG5:
+            case QD_REG_IP_PRI_REG6:
+            case QD_REG_IP_PRI_REG7:
+            case QD_REG_IEEE_PRI:
+                    break;
+            case QD_REG_STATS_OPERATION:
+                    status = qdSimStatsOperation(value);
+                    return status;
+            case QD_REG_STATS_COUNTER3_2:
+            case QD_REG_STATS_COUNTER1_0:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else if(IS_PORT_REG(portNumber))    /* Port registers */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_PORT_STATUS:
+                    if(portNumber > 12)
+                    {
+                        qdSimRegs[portNumber][miiReg] &= ~QD_PORT_STATUS_DUPLEX;
+                        qdSimRegs[portNumber][miiReg] |= (value & QD_PORT_STATUS_DUPLEX);
+                        return GT_TRUE;
+                    }
+            case QD_REG_SWITCH_ID:
+                    /* readonly registers */
+                    return GT_FALSE;
+            case QD_REG_PORT_CONTROL:
+            case QD_REG_PORT_VLAN_MAP:
+            case QD_REG_PVID:
+            case QD_REG_RATE_CTRL:
+            case QD_REG_PAV:
+                    break;
+            case QD_REG_RXCOUNTER:
+            case QD_REG_TXCOUNTER:
+                    /* readonly registers */
+                    return GT_FALSE;
+            case QD_REG_Q_COUNTER:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else if(IS_PHY_REG(portNumber))    /* phy registers */
+    {
+        switch(miiReg)
+        {
+            case QD_PHY_CONTROL_REG:
+                    return qdSimPhyControl(portNumber,miiReg,value);
+            case QD_PHY_INT_ENABLE_REG:
+            case QD_PHY_AUTONEGO_AD_REG:
+            case QD_PHY_NEXTPAGE_TX_REG:
+            case QD_PHY_SPEC_CONTROL_REG:
+                    break;
+            case QD_PHY_INT_STATUS_REG:
+            case QD_PHY_INT_PORT_SUMMARY_REG:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else
+        return GT_FALSE;
+
+    qdSimRegs[portNumber][miiReg] = (GT_U16)value;
+    return GT_TRUE;
+}
+
+GT_BOOL qdSimWrite_6083 (unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+    GT_BOOL status;
+
+    if (IS_GLOBAL_REG(portNumber))    /* Global register */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_GLOBAL_STATUS:
+                    /* readonly register */
+                    return GT_FALSE;
+            case QD_REG_MACADDR_01:
+            case QD_REG_MACADDR_23:
+            case QD_REG_MACADDR_45:
+                    break;
+            case QD_REG_VTU_OPERATION:
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0xF;
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= (value & 0xF);
+                    status = qdSimVTUOperation(value);
+                    return status;
+            case QD_REG_VTU_VID_REG:
+            case QD_REG_VTU_DATA1_REG:
+            case QD_REG_VTU_DATA2_REG:
+            case QD_REG_VTU_DATA3_REG:
+                    break;
+            case QD_REG_GLOBAL_CONTROL:
+                    if(value & 0x200)
+                    {
+                        /* Reload EEPROM values */
+                        qdSimRegsInit();
+                        qdSimRegs[portNumber][QD_REG_GLOBAL_STATUS] |= 0x1;
+                        return GT_TRUE;
+                    }
+                    break;
+            case QD_REG_ATU_CONTROL:
+                    value &= ~0x8000;
+                    break;
+            case QD_REG_ATU_OPERATION:
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
+                    qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] |= (value & 0xF);
+                    status = qdSimATUOperation(value);
+                    return status;
+            case QD_REG_ATU_DATA_REG:
+            case QD_REG_ATU_MAC_01:
+            case QD_REG_ATU_MAC_23:
+            case QD_REG_ATU_MAC_45:
+            case QD_REG_IP_PRI_REG0:
+            case QD_REG_IP_PRI_REG1:
+            case QD_REG_IP_PRI_REG2:
+            case QD_REG_IP_PRI_REG3:
+            case QD_REG_IP_PRI_REG4:
+            case QD_REG_IP_PRI_REG5:
+            case QD_REG_IP_PRI_REG6:
+            case QD_REG_IP_PRI_REG7:
+            case QD_REG_IEEE_PRI:
+                    break;
+            case QD_REG_STATS_OPERATION:
+                    status = qdSimStatsOperation(value);
+                    return status;
+            case QD_REG_STATS_COUNTER3_2:
+            case QD_REG_STATS_COUNTER1_0:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else if(IS_PORT_REG(portNumber))    /* Port registers */
+    {
+        switch(miiReg)
+        {
+            case QD_REG_PORT_STATUS:
+                    if(portNumber > 12)
+                    {
+                        qdSimRegs[portNumber][miiReg] &= ~QD_PORT_STATUS_DUPLEX;
+                        qdSimRegs[portNumber][miiReg] |= (value & QD_PORT_STATUS_DUPLEX);
+                        return GT_TRUE;
+                    }
+            case QD_REG_SWITCH_ID:
+                    /* readonly registers */
+                    return GT_FALSE;
+            case QD_REG_PORT_CONTROL:
+            case QD_REG_PORT_VLAN_MAP:
+            case QD_REG_PVID:
+            case QD_REG_RATE_CTRL:
+            case QD_REG_PAV:
+                    break;
+            case QD_REG_RXCOUNTER:
+            case QD_REG_TXCOUNTER:
+                    /* readonly registers */
+                    return GT_FALSE;
+            case QD_REG_Q_COUNTER:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else if(IS_PHY_REG(portNumber))    /* phy registers */
+    {
+        switch(miiReg)
+        {
+            case QD_PHY_CONTROL_REG:
+                    return qdSimPhyControl(portNumber,miiReg,value);
+            case QD_PHY_INT_ENABLE_REG:
+            case QD_PHY_AUTONEGO_AD_REG:
+            case QD_PHY_NEXTPAGE_TX_REG:
+            case QD_PHY_SPEC_CONTROL_REG:
+                    break;
+            case QD_PHY_INT_STATUS_REG:
+            case QD_PHY_INT_PORT_SUMMARY_REG:
+                    return GT_FALSE;
+            default:
+                    return GT_FALSE;
+        }
+    }
+    else
+        return GT_FALSE;
+
+    qdSimRegs[portNumber][miiReg] = (GT_U16)value;
+    return GT_TRUE;
+}
+
+
+GT_BOOL qdSimWrite (GT_QD_DEV *dev,unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+    if (portNumber >= MAX_SMI_ADDRESS)
+        portNumber -= MAX_SMI_ADDRESS;
+
+    if ((portNumber >= MAX_SMI_ADDRESS) || (miiReg >= MAX_REG_ADDRESS))
+        return GT_FALSE;
+
+    switch(qdSimDev.qdSimDevId)
+    {
+        case GT_88E6051:
+        case GT_88E6052:
+            return qdSimWrite_6052(portNumber, miiReg, value);
+        case GT_88E6021:
+            return qdSimWrite_6021(portNumber, miiReg, value);
+        case GT_88E6063:
+        case GT_FF_HG:
+        case GT_FF_EG:
+        case GT_FH_VPN:
+            return qdSimWrite_6063(portNumber, miiReg, value);
+        case GT_88E6083:
+            return qdSimWrite_6083(portNumber, miiReg, value);
+
+        default:
+            break;
+    }
+
+    return GT_TRUE;
+}
+
+GT_STATUS qdSimSetPhyInt(unsigned int portNumber, unsigned short u16Data)
+{
+    if(!qdSimDev.qdSimUsed)
+        return GT_FAIL;
+
+    qdSimRegs[portNumber][QD_PHY_INT_STATUS_REG] = u16Data;
+    if(u16Data)
+        qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] |= (1<<portNumber);
+    else
+        qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
+
+    qdSimRegs[MAX_SMI_ADDRESS-1][QD_REG_GLOBAL_STATUS] |= 0x2;
+    return GT_OK;
+}
+
+GT_STATUS qdSimSetGlobalInt(unsigned short u16Data)
+{
+    if(!qdSimDev.qdSimUsed)
+        return GT_FAIL;
+
+    qdSimRegs[MAX_SMI_ADDRESS-1][QD_REG_GLOBAL_STATUS] |= (u16Data & 0xF);
+    return GT_OK;
+}
+
+
+void qdSimInit(GT_DEVICE devId, int baseAddr)
+{
+    qdSimDev.qdSimUsed = 1;
+
+    qdSimDev.qdSimDevId = devId;
+    qdSimDev.vtuSize = 0;
+
+    qdSimDev.qdSimPhyBase = baseAddr;
+    qdSimDev.qdSimPortBase = baseAddr + 0x8;
+    qdSimDev.qdSimGlobalRegBase = baseAddr + 0xF;
+
+    switch(devId)
+    {
+        case GT_88E6021:
+            qdSimDev.vtuSize = 16;
+            qdSimDev.qdSimNumOfPhys = 2;
+            qdSimDev.qdSimNumOfPorts = 3;
+            break;
+        case GT_88E6051:
+            qdSimDev.qdSimNumOfPhys = 5;
+            qdSimDev.qdSimNumOfPorts = 6;
+            break;
+        case GT_88E6063:
+        case GT_FH_VPN:
+            qdSimDev.vtuSize = 64;
+        case GT_88E6052:
+        case GT_FF_HG:
+        case GT_FF_EG:
+            qdSimDev.qdSimNumOfPhys = 5;
+            qdSimDev.qdSimNumOfPorts = 7;
+            break;
+        case GT_88E6083:
+            qdSimDev.vtuSize = 64;
+            qdSimDev.qdSimNumOfPhys = 8;
+            qdSimDev.qdSimNumOfPorts = 10;
+            qdSimDev.qdSimPhyBase = 0;
+            qdSimDev.qdSimPortBase = 0x10;
+            qdSimDev.qdSimGlobalRegBase = 0x1b;
+            break;
+        default:
+            qdSimDev.vtuSize = 64;
+            qdSimDev.qdSimDevId = GT_88E6063;
+            qdSimDev.qdSimNumOfPhys = 5;
+            qdSimDev.qdSimNumOfPorts = 7;
+            break;
+    }
+
+    qdSimATUInit();
+    qdSimVTUInit();
+    qdSimRegsInit();
+
+    return;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Initialization/readme.txt
@@ -0,0 +1,85 @@
+========================================================================
+		QuaterDeck Initialization called by BSP
+========================================================================
+
+Initialization Sample Program will show how to initialize the QuaterDeck
+Driver/Device.
+
+This Sample includes the following files:
+	- msApiInit.c
+	- qdSim.c
+	- qdSimRegs.h
+	- ev96122mii.c
+	- osSem.c
+
+msApiInit.c
+	qdStart is the main function of this Sample and does the followings:
+	1) register the required functions.(gtRegister API)
+		1.1) readMii - BSP specific MII read function
+						(provided by BSP and required by all QuarterDeck API)
+		1.2) writeMii - BSP specific MII write function
+						(provided by BSP and required by all QuarterDeck API)
+		1.3) semCreate - OS specific semaphore create function.
+						(provided by BSP and recommanded by QuarterDeck MAC
+						address database API)
+		1.4) semDelete - OS specific semaphore delete function.
+						(provided by BSP and recommanded by QuarterDeck MAC
+						address database API)
+		1.5) semTake - OS specific semaphore take function.
+						(provided by BSP and recommanded by QuarterDeck MAC
+						address database API)
+		1.6) semGive - OS specific semaphore give function.
+						(provided by BSP and recommanded by QuarterDeck MAC
+						address database API)
+		Notes) The given example will use EV96122 BSP and QuarterDeck Simulator
+		as an example.
+
+	2) Initialize BSP provided routine (if required).
+		Notes) QuarterDeck Simulator needs to be initialized.(qdSimInit)
+
+	3) Calls sysConfig routine.
+		1.1) Input (GT_SYS_CONFIG) - CPU Port Number (Board Specific,
+		either port 5 or port 6) and Port state (either 1 for Forwarding mode
+		or 0 for Blocked mode)
+		1.2) Output (GT_SYS_INFO) - Device ID, Base MII Address (either 0 or
+		0x10), Number of Ports, and CPU port number.
+
+	4) Calls sysEnable (for future use.)
+
+qdSim.c (QuaterDeck Simulator)
+    Simulates QuaterDeck Device(88E6052)'s register map. When QuareterDeck API
+	try to read/write a bit or bits into QuaterDeck, the simulator will
+	redirect to its own memory place and performing the function very close to
+	QuaterDeck. For example,
+	1) user can set/reset a certain bit of QuarterDeck registers
+		(Phy,Port,and General registers).
+	2) user can access ATU (flush, load, purge, etc. with max MAC addresses
+		of 32)
+	3) user can manually generate an Interrupt and test the Interrupt routine.
+	4) when user read a register, it will clear a certain register if it's a
+		Self Clear register.
+	5) when user write a register, it will return ERROR if it's read only
+		register.
+	Notes) Simulator can be used when user has no QuarterDeck device connected Board.
+
+	Exported routines are :
+		qdSimRead 	for reading MII registers,
+		qdSimWrite 	for writing to MII registers, and
+		qdSimInit 	for initializing Simulator.
+
+ev96122mii.c
+	Provides EV-96122 Board specific MII access functions.
+
+	Exported routines are :
+		gtBspReadMii 	for reading MII registers,
+		gtBspWriteMii	for writing to MII registers, and
+		gtBspMiiInit 	for initializing EV-96122 and QuarterDeck connection.
+
+osSem.c
+	Provides OS specific Semapore Functions.
+
+	Exported routines are :
+		osSemCreate 	for semaphore creation
+		osSemDelete 	for semaphore deletion
+		osSemWait 		for taking semaphore
+		osSemSignal 	for releasing semaphore
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Interrupt/qdInt.c
@@ -0,0 +1,386 @@
+#include <Copyright.h>
+/********************************************************************************
+* qdInt.c
+*
+* DESCRIPTION:
+*        This sample shows how to call QuarterDeck Interrupt handler when QD INT
+*        raised, and how to take care each Interrupt Cause.
+*
+* DEPENDENCIES:   NONE.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include "msSample.h"
+
+
+/*
+ *    To enable quarterDeck interrupt, you need to call eventSetActive() and
+ *    gprtPhyIntEnable(), as following sample routine.
+ *    sampleQDIntEnable will enable all interrupt causes.
+ *    For Port, GT_ATU_FULL, GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT
+ *    are enabled.
+ *
+ *    In this sample, GT_SPEED_CHANGED, GT_DUPLEX_CHANGED, and
+ *  GT_LINK_STATUS_CHANGED are enabled for ports 0 ~ 2.
+*/
+GT_STATUS sampleQDIntEnable(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_LPORT port;
+    GT_U16 data;
+
+    /*
+     *    Enable QuarterDeck interrupt for ATUFull, ATUDone, PHYInt, and EEInt.
+     *    If writing 0 into eventSetActive(), all port interrupt will be disabled.
+    */
+    data = GT_STATS_DONE|GT_VTU_PROB|GT_VTU_DONE|
+           GT_ATU_FULL|GT_ATU_DONE|GT_EE_INTERRUPT;
+/*           GT_ATU_FULL|GT_ATU_DONE|GT_PHY_INTERRUPT|GT_EE_INTERRUPT; */
+    if((status = eventSetActive(dev,data)) != GT_OK)
+    {
+        MSG_PRINT(("eventSetActive returned fail.\n"));
+        return status;
+    }
+
+    /*
+     *    Enable Phy interrupt for every possible interrupt cause.
+     *    If writing 0 into gprtPhyIntEnable(), all port interrupt will be disabled.
+    */
+    data =     GT_SPEED_CHANGED|GT_DUPLEX_CHANGED|GT_LINK_STATUS_CHANGED;
+
+    for(port=0; port<3; port++)
+    {
+        if((status = gprtPhyIntEnable(dev,port,data)) != GT_OK)
+        {
+            MSG_PRINT(("gprtPhyIntEnable returned fail.\n"));
+            return status;
+        }
+    }
+
+    return GT_OK;
+}
+
+/*
+ *    Disable QuarterDeck Interrupt.
+*/
+GT_STATUS sampleQDIntDisable(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_LPORT port;
+
+    /*
+     *    Writing 0 into eventSetActive(), all port interrupt will be disabled.
+    */
+    if((status = eventSetActive(dev,0)) != GT_OK)
+    {
+        MSG_PRINT(("eventSetActive returned fail.\n"));
+        return status;
+    }
+
+    /*
+     *    Writing 0 into gprtPhyIntEnable(), all port interrupt will be disabled.
+    */
+    for(port=0; port<3; port++)
+    {
+        if((status = gprtPhyIntEnable(dev,port,0)) != GT_OK)
+        {
+            MSG_PRINT(("gprtPhyIntEnable returned fail.\n"));
+            return status;
+        }
+    }
+    return GT_OK;
+}
+
+
+/*
+ *    Assume that the following function, sampleQDIntVector(), is registered
+ *    when BSP calls intConnect for QD Interrupt.
+ *    This sample will show how to deal with QuarterDeck Interrupt.
+*/
+GT_STATUS sampleQDIntVector(GT_QD_DEV *dev)
+{
+    GT_U16 intCause, phyIntCause;
+    GT_U16 portVec;
+    GT_LPORT port;
+    GT_VTU_INT_STATUS vtuInt;
+    GT_ATU_INT_STATUS atuInt;
+
+    /*
+     *    Disable QuarterDeck Interrupt in System Level.
+     *    ToDo...
+    */
+
+    /*
+     *    Check if QD generated the interrupt.
+    */
+    if(eventGetIntStatus(dev,&intCause) != GT_OK)
+    {
+        /* QD didn't generate the interrupt. */
+        return GT_FAIL;
+    }
+
+    /*
+     *    QD generated interrupt with the reason in intCause.
+    */
+
+    if(intCause & GT_STATS_DONE)
+    {
+        /*
+         *    Statistics Done Interrupt
+         *    ToDo...
+        */
+
+    }
+    if(intCause & GT_VTU_DONE)
+    {
+        /*
+         *    VTU Done Interrupt
+         *    ToDo...
+        */
+
+    }
+
+    if(intCause & GT_VTU_PROB)
+    {
+        /*
+         *    Vlan Table Problem/Violation.
+         *    Need to read the cause.
+        */
+        do {
+            if(gvtuGetIntStatus(dev,&vtuInt) != GT_OK)
+            {
+                /* failed to retrieve VTU Interrupt cause */
+                break;
+            }
+
+            if(vtuInt.vtuIntCause & GT_VTU_FULL_VIOLATION)
+            {
+                /*
+                 *    Vlan Table is Full
+                 *    ToDo...
+                */
+            }
+
+            if(vtuInt.vtuIntCause & GT_MEMBER_VIOLATION)
+            {
+                /*
+                 *    Member Violation
+                 *    ToDo...
+                */
+            }
+
+            if(vtuInt.vtuIntCause & GT_MISS_VIOLATION)
+            {
+                /*
+                 *    Miss Violation
+                 *    ToDo...
+                */
+            }
+        } while(vtuInt.vtuIntCause != 0);
+    }
+
+    if(intCause & GT_ATU_PROB)
+    {
+        /*
+         *    ATU cannot load or learn a new mapping due to all the available
+         *    locations for an address being locked.
+         *    ToDo...
+        */
+        do {
+            if(gatuGetIntStatus(dev,&atuInt) != GT_OK)
+            {
+                /* failed to retrieve VTU Interrupt cause */
+                break;
+            }
+
+            if(atuInt.atuIntCause & GT_FULL_VIOLATION)
+            {
+                /*
+                 *    Table is Full
+                 *    ToDo...
+                */
+            }
+
+            if(atuInt.atuIntCause & GT_MEMBER_VIOLATION)
+            {
+                /*
+                 *    Member Violation
+                 *    ToDo...
+                */
+            }
+
+            if(atuInt.atuIntCause & GT_MISS_VIOLATION)
+            {
+                /*
+                 *    Miss Violation
+                 *    ToDo...
+                */
+            }
+        } while(atuInt.atuIntCause != 0);
+
+    }
+
+    if(intCause & GT_ATU_DONE)
+    {
+        /*
+         *    There is a transitions from a one to a zero on ATUBusy bit
+         *    (Refer to ATU Operation Register.)
+         *    ToDo...
+        */
+
+    }
+
+    if(intCause & GT_PHY_INTERRUPT)
+    {
+        /*
+         *    At least one of the Phy generated interrupt.
+         *    We need to read Phy Interrupt Summary and go through each phy
+         *    based on the summary.
+        */
+
+        if(gprtGetPhyIntPortSummary(dev,&portVec) != GT_OK)
+        {
+            return GT_FAIL;
+        }
+
+        port = 0;
+        while(portVec)
+        {
+            if(portVec & 0x01)
+            {
+                /*
+                 *    Call gprtGetPhyIntStatus to get intCause
+                */
+                if(gprtGetPhyIntStatus(dev,port,&phyIntCause) != GT_OK)
+                {
+                    /*
+                     *    Something wrong with the system. Need to do the
+                     *    necessary work.
+                     *    ToDo...
+                    */
+                }
+
+                if(phyIntCause & GT_SPEED_CHANGED)
+                {
+                    /*
+                     *    Speed has been changed.
+                     *    ToDo...
+                    */
+                }
+
+                if(phyIntCause & GT_DUPLEX_CHANGED)
+                {
+                    /*
+                     *    Duplex mode has been changed.
+                     *    ToDo...
+                    */
+                }
+
+                if(phyIntCause & GT_PAGE_RECEIVED)
+                {
+                    /*
+                     *    Page received.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_AUTO_NEG_COMPLETED)
+                {
+                    /*
+                     *    AutoNegotiation completed.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_LINK_STATUS_CHANGED)
+                {
+                    /*
+                     *    Link Status changed.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_SYMBOL_ERROR)
+                {
+                    /*
+                     *    Symbol error
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_FALSE_CARRIER)
+                {
+                    /*
+                     *    False Carrier.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_FIFO_FLOW)
+                {
+                    /*
+                     *    Fifo Overflow/underflow error
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_CROSSOVER_CHANGED)
+                {
+                    /*
+                     *    MDI/MDIX crossover changed.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_POLARITY_CHANGED)
+                {
+                    /*
+                     *    Polarity changed.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_JABBER)
+                {
+                    /*
+                     *    Jabber
+                     *    ToDo...
+                    */
+
+                }
+            }
+
+            portVec >>= 1;
+            port++;
+        }
+    }
+
+    if(intCause & GT_EE_INTERRUPT)
+    {
+        /*
+         *    EEPROM is done loading registers.
+         *    ToDo...
+        */
+
+    }
+
+
+    /*
+     *    Now, all the QuarterDeck related interrupt have been cleared,
+     *    so it's OK to enable QuarterDeck Interrupt in System Level.
+     *    ToDo...
+    */
+
+    return GT_OK;
+
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Interrupt/readme.txt
@@ -0,0 +1,13 @@
+========================================================================
+		QuaterDeck Interrupt Handler called by BSP Interrupt Vector
+========================================================================
+
+This sample shows how to enable/disable QuaterDeck Interrupt, and how to
+handle each Interrupt.
+
+qdInt.c
+	sampleQDIntEnable() will enable all the interrupt supported by
+	QuaterDeck.
+	sampleQDIntDisable() will disable QuarterDeck Interrupt.
+	sampleQDIntVector() will show how BSP interrupt service routine can
+	deal with QuarterDeck Interrupt.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/LoadBalance/loadBalance.c
@@ -0,0 +1,57 @@
+#include <Copyright.h>
+/********************************************************************************
+* loadBalance.c
+*
+* DESCRIPTION:
+*        This sample shows how to setup load balance among Trunk ports.
+*        In this sample, port 0,1,2, and 3 will be in the Trunk group.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+* COMMENTS:
+*******************************************************************************/
+
+#include "msSample.h"
+
+
+/*
+   The following sample sets Trunk Mask Table as follows:
+
+                      10    9    8    7    6    5    4    3    2    1    0
+   TrunkMask[0]        1    1    1    1    1    1    1    0    0    0    1
+   TrunkMask[1]        1    1    1    1    1    1    1    0    0    1    0
+   TrunkMask[2]        1    1    1    1    1    1    1    0    1    0    0
+   TrunkMask[3]        1    1    1    1    1    1    1    1    0    0    0
+   TrunkMask[4]        1    1    1    1    1    1    1    0    0    0    1
+   TrunkMask[5]        1    1    1    1    1    1    1    0    0    1    0
+   TrunkMask[6]        1    1    1    1    1    1    1    0    1    0    0
+   TrunkMask[7]        1    1    1    1    1    1    1    1    0    0    0
+*/
+
+GT_STATUS sampleLoadBalance(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    int i;
+    GT_U32 mask, baseMask;
+
+    baseMask = (1 << dev->numOfPorts) - 1;
+    baseMask &= 0xFFF0;    /* clear bits for port 0 ~ 3 */
+
+    /*
+     *    Set the trunk mask table for load balancing.
+    */
+    for(i=0; i<8; i++)
+    {
+        mask = baseMask | (1 << (i%4));
+
+        if((status = gsysSetTrunkMaskTable(dev,i,mask)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
+            return status;
+        }
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/LoadBalance/readme.txt
@@ -0,0 +1,9 @@
+========================================================================
+		Setup for Load Balancing
+========================================================================
+
+This sample shows how to setup Trunk Mask Table for load balancing.
+For more information about load balancing, please refer to 88E6095 Spec.
+
+loadBalance.c
+	sampleLoadBalance demonstrates how to setup Trunk Mask Table.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MACAddress/macAddr.c
@@ -0,0 +1,223 @@
+#include <Copyright.h>
+/********************************************************************************
+* macAddr.c
+*
+* DESCRIPTION:
+*    This sample will demonstrate how to add/delete a static MAC Address
+*    into/from the QuaterDeck MAC Address Data Base.
+*
+* DEPENDENCIES:   None.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+/*
+ *    Add the CPU MAC address into the QuaterDeck MAC Address database.
+ *    Input - None
+*/
+GT_STATUS sampleAddCPUMac(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_ATU_ENTRY macEntry;
+
+    /*
+     *    Assume that Ethernet address for the CPU MAC is
+     *    00-50-43-00-01-02.
+    */
+    macEntry.macAddr.arEther[0] = 0x00;
+    macEntry.macAddr.arEther[1] = 0x50;
+    macEntry.macAddr.arEther[2] = 0x43;
+    macEntry.macAddr.arEther[3] = 0x00;
+    macEntry.macAddr.arEther[4] = 0x01;
+    macEntry.macAddr.arEther[5] = 0x02;
+
+    macEntry.portVec = 1 << dev->cpuPortNum;     /* CPU Port number. 7bits are used for portVector. */
+
+    macEntry.prio = 0;            /* Priority (2bits). When these bits are used they override
+                                any other priority determined by the frame's data. This value is
+                                meaningful only if the device does not support extended priority
+                                information such as MAC Queue Priority and MAC Frame Priority */
+
+    macEntry.exPrio.macQPri = 0;    /* If device doesnot support MAC Queue Priority override,
+                                    this field is ignored. */
+    macEntry.exPrio.macFPri = 0;    /* If device doesnot support MAC Frame Priority override,
+                                    this field is ignored. */
+    macEntry.exPrio.useMacFPri = 0;    /* If device doesnot support MAC Frame Priority override,
+                                    this field is ignored. */
+
+    macEntry.entryState.ucEntryState = GT_UC_STATIC;
+                                /* This address is locked and will not be aged out.
+                                Refer to GT_ATU_UC_STATE in msApiDefs.h for other option. */
+
+    /*
+     *    Add the MAC Address.
+     */
+    if((status = gfdbAddMacEntry(dev,&macEntry)) != GT_OK)
+    {
+        MSG_PRINT(("gfdbAddMacEntry returned fail.\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ *    Delete the CPU MAC address from the QuaterDeck MAC Address database.
+ *    Input - None
+*/
+GT_STATUS sampleDelCPUMac(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_ATU_ENTRY macEntry;
+
+    /*
+     *    Assume that Ethernet address for the CPU MAC is
+     *    00-50-43-00-01-02.
+    */
+    macEntry.macAddr.arEther[0] = 0x00;
+    macEntry.macAddr.arEther[1] = 0x50;
+    macEntry.macAddr.arEther[2] = 0x43;
+    macEntry.macAddr.arEther[3] = 0x00;
+    macEntry.macAddr.arEther[4] = 0x01;
+    macEntry.macAddr.arEther[5] = 0x02;
+
+    /*
+     *    Delete the CPU MAC Address.
+     */
+    if((status = gfdbDelMacEntry(dev,&macEntry.macAddr)) != GT_OK)
+    {
+        MSG_PRINT(("gfdbDelMacEntry returned fail.\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ *    Add a multicast MAC address into the QuaterDeck MAC Address database,
+ *    where address is 01-00-18-1a-00-00 and frames with this destination has
+ *    to be forwarding to Port 1, Port 2 and Port 4 (port starts from Port 0)
+ *    Input - None
+*/
+GT_STATUS sampleAddMulticastAddr(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_ATU_ENTRY macEntry;
+
+    /*
+     *    Assume that we want to add the following multicast address
+     *    01-50-43-00-01-02.
+    */
+    macEntry.macAddr.arEther[0] = 0x01;
+    macEntry.macAddr.arEther[1] = 0x50;
+    macEntry.macAddr.arEther[2] = 0x43;
+    macEntry.macAddr.arEther[3] = 0x00;
+    macEntry.macAddr.arEther[4] = 0x01;
+    macEntry.macAddr.arEther[5] = 0x02;
+
+    /*
+     *     Assume that a packet needs to be forwarded to the second Port (port 1),
+     *    the third Port (port 2) and cpu Port, if the frame has destination of
+     *    01-00-18-1a-00-00.
+    */
+    macEntry.portVec =     (1<<1) | /* the second port */
+                (1<<2) | /* the third port */
+                (1<<dev->cpuPortNum);
+
+    macEntry.prio = 0;            /* Priority (2bits). When these bits are used they override
+                                any other priority determined by the frame's data. This value is
+                                meaningful only if the device does not support extended priority
+                                information such as MAC Queue Priority and MAC Frame Priority */
+
+    macEntry.exPrio.macQPri = 0;    /* If device doesnot support MAC Queue Priority override,
+                                    this field is ignored. */
+    macEntry.exPrio.macFPri = 0;    /* If device doesnot support MAC Frame Priority override,
+                                    this field is ignored. */
+    macEntry.exPrio.useMacFPri = 0;    /* If device doesnot support MAC Frame Priority override,
+                                    this field is ignored. */
+
+    macEntry.entryState.ucEntryState = GT_MC_STATIC;
+                                /* This address is locked and will not be aged out.
+                                Refer to GT_ATU_MC_STATE in msApiDefs.h for other option.*/
+
+    /*
+     *    Add the MAC Address.
+     */
+    if((status = gfdbAddMacEntry(dev,&macEntry)) != GT_OK)
+    {
+        MSG_PRINT(("gfdbAddMacEntry returned fail.\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ *    Delete the Multicast MAC address of 01-00-18-1a-00-00.
+ *    Input - None
+*/
+GT_STATUS sampleDelMulticastAddr(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_ATU_ENTRY macEntry;
+
+    /*
+     *    Assume that Ethernet address for the CPU MAC is
+     *    01-50-43-00-01-02.
+    */
+    macEntry.macAddr.arEther[0] = 0x01;
+    macEntry.macAddr.arEther[1] = 0x50;
+    macEntry.macAddr.arEther[2] = 0x43;
+    macEntry.macAddr.arEther[3] = 0x00;
+    macEntry.macAddr.arEther[4] = 0x01;
+    macEntry.macAddr.arEther[5] = 0x02;
+
+    /*
+     *    Delete the given Multicast Address.
+     */
+    if((status = gfdbDelMacEntry(dev,&macEntry.macAddr)) != GT_OK)
+    {
+        MSG_PRINT(("gfdbDelMacEntry returned fail.\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ *    This sample function will show how to display all the MAC address
+ *    in the ATU.
+*/
+GT_STATUS sampleShowMacEntry(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_ATU_ENTRY tmpMacEntry;
+
+    MSG_PRINT(("ATU List:\n"));
+    memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
+
+    while(1)
+    {
+        /* Get the sorted list of MAC Table. */
+        if((status = gfdbGetAtuEntryNext(dev,&tmpMacEntry)) != GT_OK)
+        {
+            return status;
+        }
+
+        MSG_PRINT(("(%02x-%02x-%02x-%02x-%02x-%02x) PortVec %#x\n",
+                tmpMacEntry.macAddr.arEther[0],
+                tmpMacEntry.macAddr.arEther[1],
+                tmpMacEntry.macAddr.arEther[2],
+                tmpMacEntry.macAddr.arEther[3],
+                tmpMacEntry.macAddr.arEther[4],
+                tmpMacEntry.macAddr.arEther[5],
+                tmpMacEntry.portVec));
+    }
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MACAddress/readme.txt
@@ -0,0 +1,16 @@
+========================================================================
+		MAC Address ADD/DELETE Sample
+========================================================================
+
+This sample will demonstrate how to add/delete a static MAC Address
+into/from the QuaterDeck MAC Address Data Base and how to enumerate
+all the MAC addresses in the Data Base.
+
+macAddr.c
+	sampleAddCPUMac : show how to add CPU Mac address into the QuterDeck
+		Database.
+	sampleDelCPUMac : show how to delete CPU Mac address from the database.
+	sampleAddMulticastAddr : show how to add a multicast address into
+		the QuaterDeck Database.
+	sampleDelMulticastAddr : show how to delete a multicast address.
+	sampleShowMacEntry : show how to get all the Mac addresses in the database.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MinimizeCPUTraffic/minimizeCPUTraffic.c
@@ -0,0 +1,184 @@
+#include <Copyright.h>
+/********************************************************************************
+* minizeCPUTraffic.c
+*
+* DESCRIPTION:
+*        This sample shows how to setup the CPU port not to be a member of any
+*        VLAN, while it still be a manager of a switch.
+*
+* DEPENDENCIES:
+*        Please check the device's spec. if the device supports this feature.
+*        At the moment this sample was written, 88E6095 was the only device support
+*        this feature.
+*
+* FILE REVISION NUMBER:
+*
+* COMMENTS:
+*******************************************************************************/
+
+#include "msSample.h"
+
+/*
+    For the devices that support gsysSetARPDest API:
+
+    0) Remove CPU port from VLAN Member Table.
+       (this sample deals with Port Based Vlan only.)
+    1) Mirror ARPs to the CPU with To_CPU Marvell Tag
+    2) Convert unicast frames directed to the CPU into To_CPU Marvell Tag
+    Assumption : Device ID, Cascading Port, CPU Port, and Interswitch Port are
+        already set properly. For more information, please refer to the
+        sample/MultiDevice/msApiInit.c
+*/
+
+GT_STATUS sampleMinimizeCPUTraffic1(GT_QD_DEV *dev, GT_U8* macAddr)
+{
+    GT_STATUS status;
+    int i;
+    GT_LPORT memPorts[16], cpuPort;
+    GT_U8 memPortsLen, index;
+    GT_ATU_ENTRY macEntry;
+
+    cpuPort = (GT_LPORT)dev->cpuPortNum;
+
+    /*
+     *    Remove CPU port from VLAN Member Table.
+    */
+    for(i=0; i<dev->numOfPorts; i++)
+    {
+        if((status = gvlnGetPortVlanPorts(dev,(GT_LPORT)i,memPorts,&memPortsLen)) != GT_OK)
+        {
+            MSG_PRINT(("gvlnGetPortVlanPorts return Failed\n"));
+            return status;
+        }
+
+        for(index=0; index<memPortsLen; index++)
+        {
+            if (memPorts[index] == cpuPort)
+                break;
+        }
+
+        if(index != memPortsLen)
+        {
+            /* CPU Port is the member of the port vlan */
+            if((memPortsLen-1) != index)
+            {
+                memPorts[index] = memPorts[memPortsLen-1];
+            }
+            memPortsLen--;
+
+            if((status = gvlnSetPortVlanPorts(dev,(GT_LPORT)i,memPorts,memPortsLen)) != GT_OK)
+            {
+                MSG_PRINT(("gvlnSetPortVlanPorts return Failed\n"));
+                return status;
+            }
+        }
+    }
+
+    /*
+     *    Mirror ARPs to the CPU with To_CPU Marvell Tag.
+    */
+    if((status = gsysSetARPDest(dev,cpuPort)) != GT_OK)
+    {
+        MSG_PRINT(("gsysSetARPDest return Failed\n"));
+        return status;
+    }
+
+    /*
+     *    Convert unicast frames directed to the CPU into To_CPU Marvell Tag.
+     *  This sample assumes that DBNum is not used. If DBNum is used,
+     *  the macEntry has to be added for each DBNum used.
+    */
+    memset(&macEntry,0,sizeof(GT_ATU_ENTRY));
+    memcpy(macEntry.macAddr.arEther,macAddr,6);
+    macEntry.portVec = 1 << dev->cpuPortNum;
+    macEntry.prio = 0;            /* Priority (2bits). When these bits are used they override
+                                any other priority determined by the frame's data */
+    macEntry.entryState.ucEntryState = GT_UC_TO_CPU_STATIC;
+    macEntry.DBNum = 0;
+    macEntry.trunkMember = GT_FALSE;
+
+    if((status = gfdbAddMacEntry(dev,&macEntry)) != GT_OK)
+    {
+        MSG_PRINT(("gfdbAddMacEntry return Failed\n"));
+        return status;
+    }
+
+
+    return GT_OK;
+}
+
+
+/*
+    For the devices that support gprtSetARPtoCPU API:
+
+    1) Enable ARP to CPU feature fore each port.
+    2) Set Egress Flood Mode to be Block Unknown DA on CPU Port.
+    3) Add CPU Port's MAC into address table.
+    4) Remove Broadcast address from address table.
+*/
+
+GT_STATUS sampleMinimizeCPUTraffic2(GT_QD_DEV *dev, GT_U8* macAddr)
+{
+    GT_STATUS status;
+    int i;
+    GT_LPORT cpuPort;
+    GT_ATU_ENTRY macEntry;
+
+    cpuPort = (GT_LPORT)dev->cpuPortNum;
+
+    /*
+     *    Remove CPU port from VLAN Member Table.
+    */
+    for(i=0; i<dev->numOfPorts; i++)
+    {
+        if (i == cpuPort)
+            continue;
+
+        if((status = gprtSetARPtoCPU(dev,i,GT_TRUE)) != GT_OK)
+        {
+            MSG_PRINT(("gprtSetARPtoCPU return Failed\n"));
+            return status;
+        }
+    }
+
+    /*
+     * Set Egress Flood Mode to be Block Unknown DA on CPU Port.
+    */
+    if((status = gprtSetEgressFlood(dev,cpuPort,GT_BLOCK_EGRESS_UNKNOWN)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetEgressFlood return Failed\n"));
+        return status;
+    }
+
+
+    /*
+     *    Add CPU's MAC into address table.
+     *  This sample assumes that DBNum is not used. If DBNum is used,
+     *  the macEntry has to be added for each DBNum used.
+    */
+    memset(&macEntry,0,sizeof(GT_ATU_ENTRY));
+    memcpy(macEntry.macAddr.arEther,macAddr,6);
+    macEntry.portVec = 1 << dev->cpuPortNum;
+    macEntry.prio = 0;            /* Priority (2bits). When these bits are used they override
+                                any other priority determined by the frame's data */
+    macEntry.entryState.ucEntryState = GT_UC_STATIC;
+    macEntry.DBNum = 0;
+    macEntry.trunkMember = GT_FALSE;
+
+    if((status = gfdbAddMacEntry(dev,&macEntry)) != GT_OK)
+    {
+        MSG_PRINT(("gfdbAddMacEntry return Failed\n"));
+        return status;
+    }
+
+    /*
+     *  Delete BroadCast Entry from address table if exists.
+     *  This sample assumes that DBNum is not used. If DBNum is used,
+     *  the macEntry has to be added for each DBNum used.
+    */
+    memset(&macEntry,0,sizeof(GT_ATU_ENTRY));
+    memset(macEntry.macAddr.arEther,0xFF,6);
+    gfdbDelAtuEntry(dev,&macEntry);
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MinimizeCPUTraffic/readme.txt
@@ -0,0 +1,22 @@
+========================================================================
+		Setup for CPU Port which is not a member of any VLAN
+========================================================================
+
+Previous SOHO switch devices were low port count and/or used for Routers.
+In this environment, the CPU must be a member of all VLANs, so it can
+route the frames from one VLAN to another.
+In a high port count managed switch, the CPU is not a router but the
+manager of the switch. In this environment, the CPU doesn't want to be a
+member of any VLAN. If it is, it can get saturated with non-management
+frames preventing it from receiving the important management frames.
+
+In order to support the feature, the following has to be provided:
+
+1. For the devices that support gsysSetARPDest API:
+	0) Remove CPU port from VLAN Member Table.
+	1) Mirror ARPs to the CPU with To_CPU Marvell Tag.
+	2) Convert unicast frames directed to the CPU into To_CPU Marvell Tag.
+
+2. For the devices that support gprtSetARPtoCPU API:
+	0) Remove CPU port from VLAN Member Table.
+	1) Enable ARP to CPU for each port.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/MultiDevice/msApiInit.c
@@ -0,0 +1,271 @@
+#include <Copyright.h>
+/********************************************************************************
+* msApiInit.c
+*
+* DESCRIPTION:
+*        MS API initialization routine for devices supporting Multi Address Mode,
+*        such as 88E6183. Following setup will be used for this sample code.
+*
+*          ------------------
+*        |CPU Ethernet Dev|
+*        ------------------
+*         |
+*         |
+*         |   8--------------9     8--------------9      8--------------
+*         |----| QD Device 0|------| QD Device 1|-----| QD Device 2|
+*             --------------          --------------        --------------
+*               0 1 2 ... 7             0 1 2 ... 7          0 1 2 ... 7
+*
+*
+*        Ethernet port of CPU is connected to port 8 of Device 0,
+*        port 9 of Device 0 is connected to port 8 of Device 1, and
+*        port 9 of Device 1 is connected to port 8 of Device 2.
+*
+*        Device 0 uses Phy Address 1,
+*        Device 1 uses Phy Address 2, and
+*        Device 2 uses Phy Address 3
+*        Notes: Phy Address 0 cannot be used in a Multi Chip Address Mode.
+*
+*        Each Switch Device has to be configured to Multi Chip Address Mode.
+*        For detailed information for Multi Chip Address Mode configuration,
+*        please refer to your device's Datasheet.
+*
+* DEPENDENCIES:   Platform
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+/*
+#define MULTI_ADDR_MODE
+#define MANUAL_MODE
+*/
+
+#define MULTI_ADDR_MODE
+#define N_OF_QD_DEVICES        3    /* number of 88E6183 devices connected */
+
+#define DEVICE0_ID        10
+#define DEVICE1_ID        DEVICE0_ID + 1
+#define DEVICE2_ID        DEVICE0_ID + 2
+
+#define DEVICE0_PHY_ADDR    1
+#define DEVICE1_PHY_ADDR    DEVICE0_PHY_ADDR + 1
+#define DEVICE2_PHY_ADDR    DEVICE0_PHY_ADDR + 2
+
+#define S_CPU_DEVICE        DEVICE0_ID
+
+#define DEVICE0_CPU_PORT        8
+#define DEVICE0_CASCADE_PORT    9
+#define DEVICE1_CPU_PORT        8
+#define DEVICE1_CASCADE_PORT    9
+#define DEVICE2_CPU_PORT        8
+#define DEVICE2_CASCADE_PORT    9
+
+GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES] = {0,};
+
+/*
+ * Initialize each Switch Devices. This should be done in BSP driver init routine.
+ *    Since BSP is not combined with QuarterDeck driver, we are doing here.
+ * This routine will setup Switch Devices according to the above description.
+*/
+
+GT_STATUS qdMultiDevStart()
+{
+    GT_STATUS status = GT_FAIL;
+    GT_SYS_CONFIG   cfg;
+    int cpuPort;
+    int cascadePort;
+    int i,j;
+
+    memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
+
+    /*
+     *    Create QD Device Structure for each device.
+     */
+    for(i=0; i<N_OF_QD_DEVICES; i++)
+    {
+        qdMultiDev[i] = (GT_QD_DEV*)malloc(sizeof(GT_QD_DEV));
+
+        if(qdMultiDev[i] == NULL)
+        {
+            while(i--)
+                free(qdMultiDev[i]);
+            return GT_FAIL;
+        }
+
+        memset((char*)qdMultiDev[i],0,sizeof(GT_QD_DEV));
+    }
+
+    /*
+     *  Register all the required functions to QuarterDeck Driver for each device.
+    */
+    for(i=0; i<N_OF_QD_DEVICES; i++)
+    {
+        cfg.BSPFunctions.readMii   = gtBspReadMii;
+        cfg.BSPFunctions.writeMii  = gtBspWriteMii;
+#ifdef USE_SEMAPHORE
+        cfg.BSPFunctions.semCreate = osSemCreate;
+        cfg.BSPFunctions.semDelete = osSemDelete;
+        cfg.BSPFunctions.semTake   = osSemWait;
+        cfg.BSPFunctions.semGive   = osSemSignal;
+#else
+        cfg.BSPFunctions.semCreate = NULL;
+        cfg.BSPFunctions.semDelete = NULL;
+        cfg.BSPFunctions.semTake   = NULL;
+        cfg.BSPFunctions.semGive   = NULL;
+#endif
+
+        cfg.initPorts = GT_TRUE;    /* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
+        switch (i)
+        {
+            case 0: /* if we are registering device 0 */
+                cfg.cpuPortNum = DEVICE0_CPU_PORT;
+                break;
+            case 1: /* if we are registering device 1 */
+                cfg.cpuPortNum = DEVICE1_CPU_PORT;    /* where device 0 is connected */
+                break;
+            case 2: /* if we are registering device 2 */
+                cfg.cpuPortNum = DEVICE2_CPU_PORT;    /* where device 1 is connected */
+                break;
+            default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+                goto errorExit;
+        }
+
+#ifdef MANUAL_MODE    /* not defined. this is only for sample */
+        /* user may want to use this mode when there are two QD switchs on the same MII bus. */
+        cfg.mode.scanMode = SMI_MANUAL_MODE;    /* Use QD located at manually defined base addr */
+        cfg.mode.baseAddr = 0x10;    /* valid value in this case is either 0 or 0x10 */
+#else
+#ifdef MULTI_ADDR_MODE    /* It should have been defined for this sample code */
+        cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;    /* find a QD in indirect access mode */
+        cfg.mode.baseAddr = DEVICE0_PHY_ADDR + i;        /* this is the phyAddr used by QD family device.
+                                                                        Valid values are 1 ~ 31.*/
+#else
+        cfg.mode.scanMode = SMI_AUTO_SCAN_MODE;    /* Scan 0 or 0x10 base address to find the QD */
+        cfg.mode.baseAddr = 0;
+#endif
+#endif
+
+        if((status=qdLoadDriver(&cfg, qdMultiDev[i])) != GT_OK)
+        {
+            MSG_PRINT(("qdLoadDriver return Failed\n"));
+            goto errorExit;
+        }
+
+        MSG_PRINT(("Device ID     : 0x%x\n",qdMultiDev[i]->deviceId));
+        MSG_PRINT(("Base Reg Addr : 0x%x\n",qdMultiDev[i]->baseRegAddr));
+        MSG_PRINT(("No of Ports   : %d\n",qdMultiDev[i]->numOfPorts));
+        MSG_PRINT(("CPU Ports     : %d\n",qdMultiDev[i]->cpuPortNum));
+
+        /*
+         *  start the QuarterDeck
+        */
+        if((status=sysEnable(qdMultiDev[i])) != GT_OK)
+        {
+            MSG_PRINT(("sysConfig return Failed\n"));
+            goto errorExit;
+        }
+    }
+
+    /*
+        Now, we need to configure Cascading information for each devices.
+        1. Set Interswitch port mode for port 8 and 9 for device 0,1,and 2,
+            so that switch device can expect Marvell Tag from frames
+            ingressing/egressing this port.
+        2. Set CPU Port information (for To_CPU frame) for each port of device.
+        3. Set Cascading Port information (for From_CPU fram) for each device.
+        4. Set Device ID (if required)
+            Note: DeviceID is hardware configurable.
+    */
+    for(i=0; i<N_OF_QD_DEVICES; i++)
+    {
+        switch (i)
+        {
+            case 0: /* if we are registering device 0 */
+                cpuPort = DEVICE0_CPU_PORT;         /* where CPU Enet port is connected */
+                cascadePort = DEVICE0_CASCADE_PORT;    /* where device 1 is connected */
+                break;
+            case 1: /* if we are registering device 1 */
+                cpuPort = DEVICE1_CPU_PORT;         /* where device 0 is connected */
+                cascadePort = DEVICE1_CASCADE_PORT;    /* where device 2 is connected */
+                break;
+            case 2: /* if we are registering device 2 */
+                cpuPort = DEVICE2_CPU_PORT;         /* where device 1 is connected */
+                cascadePort = DEVICE2_CASCADE_PORT;    /* no need to setup for the given sample setup */
+                break;
+            default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+                goto errorExit;
+        }
+
+        /*
+            1. Set Interswitch port mode for port 8 and 9 for device 0,1,and 2,
+                so that switch device can expect Marvell Tag from frames
+                ingressing/egressing this port.
+            2. Set CPU Port information (for To_CPU frame) for each port of device.
+        */
+        for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
+        {
+            if((i == cpuPort) || (i == cascadePort))
+            {
+                if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_TRUE)) != GT_OK)
+                {
+                    MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode TRUE)\n",status,j));
+                    goto errorExit;
+                }
+            }
+            else
+            {
+                if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_FALSE)) != GT_OK)
+                {
+                    MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode FALSE)\n",status,j));
+                    goto errorExit;
+                }
+            }
+
+            if((status=gprtSetCPUPort(qdMultiDev[i],j,cpuPort)) != GT_OK)
+            {
+                MSG_PRINT(("gprtSetCPUPort returned %i\n",status));
+                goto errorExit;
+            }
+        }
+
+        /*
+            3. Set Cascading Port information (for From_CPU fram) for each device.
+        */
+        if((status=gsysSetCascadePort(qdMultiDev[i],cascadePort)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetCascadePort returned %i\n",status));
+            goto errorExit;
+        }
+
+        /*
+            4. Set Device ID (if required)
+        */
+        if((status=gsysSetDeviceNumber(qdMultiDev[i],DEVICE0_ID+i)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetDeviceNumber returned %i\n",status));
+            goto errorExit;
+        }
+
+    }
+
+    MSG_PRINT(("QuarterDeck has been started.\n"));
+
+    return GT_OK;
+
+errorExit:
+
+    for(i=0; i<N_OF_QD_DEVICES; i++)
+    {
+        if(qdMultiDev[i] != NULL)
+        {
+            qdUnloadDriver(qdMultiDev[i]);
+              free(qdMultiDev[i]);
+        }
+    }
+
+    MSG_PRINT(("QuarterDeck initialization failed.\n"));
+
+    return status;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PIRL/pirl.c
@@ -0,0 +1,92 @@
+#include <Copyright.h>
+/********************************************************************************
+* pirl.c
+*
+* DESCRIPTION:
+*       Setup PIRL buckets
+*
+* DEPENDENCIES:   None.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+
+/*
+ *  This setup function configures the Port 0 of Marvell SOHO Switch Device with
+ *    capability of PIRL to be :
+ *
+ *    1) Ingress Rate    : 128Kbps (128K bit per sec)
+ *    2) Discarded frame : Do not account discarded frame due to queue congestion
+ *    3) Filtered frame  : Account filtered frame
+ *    4) Limit action    : Drop packets when the incoming rate exceeds the limit
+ *    5) Rate type       : Rate is based on Traffic type
+ *    6) Traffic type    : ARP, MGMT, Multicast, Broadcast, and Unicast frames are
+ *                         tracked as part of the rate resource calculation.
+ *    7) Byte counted    : Account only Layer 3 bytes (IP header and payload)
+ *
+ *    Notes: This sample uses IRL Unit 0. The available number of IRL Units are
+ *    various depending on the device. Please refer to the datasheet for detailed
+ *    information.
+ *
+ *    Notes: Port 0 will be blocked while programming PIRL.
+*/
+
+GT_STATUS samplePIRLSetup(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_PIRL_DATA pirlData;
+    GT_U32        irlUnit;
+    GT_LPORT     port;
+
+    /* change Current Timer Update Interval */
+    status = gpirlSetCurTimeUpInt(dev,4);
+    switch (status)
+    {
+        case GT_OK:
+            break;
+        case GT_NOT_SUPPORTED:
+            MSG_PRINT(("Device is not supporting PIRL.\n"));
+            return status;
+        default:
+            MSG_PRINT(("Failure to configure device.\n"));
+            return status;
+    }
+
+    irlUnit = 0;
+    port = 0;
+
+    pirlData.ingressRate         = 128;
+    pirlData.accountQConf         = GT_FALSE;
+    pirlData.accountFiltered    = GT_TRUE;
+    pirlData.ebsLimitAction        = ESB_LIMIT_ACTION_DROP;
+    pirlData.bktRateType        = BUCKET_TYPE_TRAFFIC_BASED;
+    pirlData.bktTypeMask        = BUCKET_TRAFFIC_BROADCAST |
+                                  BUCKET_TRAFFIC_MULTICAST |
+                                  BUCKET_TRAFFIC_UNICAST   |
+                                  BUCKET_TRAFFIC_MGMT_FRAME|
+                                  BUCKET_TRAFFIC_ARP;
+
+    pirlData.byteTobeCounted    = GT_PIRL_COUNT_ALL_LAYER3;
+
+    status = gpirlActivate(dev,irlUnit,(1<<port),&pirlData);
+
+    switch (status)
+    {
+        case GT_OK:
+            MSG_PRINT(("IRL Unit 0 is activated.\n"));
+            break;
+        case GT_BAD_PARAM:
+            MSG_PRINT(("Invalid parameters are given.\n"));
+            break;
+        case GT_NOT_SUPPORTED:
+            MSG_PRINT(("Device is not supporting PIRL.\n"));
+            break;
+        default:
+            MSG_PRINT(("Failure to configure device.\n"));
+            break;
+    }
+
+    return status;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PIRL/pirl2.c
@@ -0,0 +1,199 @@
+#include <Copyright.h>
+/********************************************************************************
+* pirl2.c
+*
+* DESCRIPTION:
+*       Setup PIRL buckets for 88E6097 device family
+*
+* DEPENDENCIES:   None.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+
+/*
+ *  This setup function configures the resource 0 of Port 0 of Marvell SOHO
+ *    Switch Device with capability of PIRL to be :
+ *
+ *    1) Ingress Rate    : 128Kbps (128K bit per sec)
+ *    2) Custom setup for Ingress Rate : disabled
+ *    3) Discarded frame : Do not account discarded frame due to queue congestion
+ *    4) Filtered frame  : Account filtered frame
+ *    5) Mgmt frame      : Exclude management frame from rate limiting calculation
+ *    6) SA found in ATU : Exclude from ingress rate limiting calculation if the SA of the
+ *                         frame is in ATU with EntryState that indicates Non Rate Limited.
+ *    7) DA found in ATU : Include to ingress rate limiting calculation even though the DA of the
+ *                         frame is in ATU with EntryState that indicates Non Rate Limited.
+ *    8) Sampling Mode   : Disable the mode
+ *    9) Action Mode     : Follow Limit action when there are not enough tokens to accept the
+ *                         entire imcoming frame.
+ *    10) Limit action   : Drop packets when the incoming rate exceeds the limit
+ *    11) Rate type      : Rate is based on Traffic type
+ *    12) Traffic type   : ARP, MGMT, Multicast, Broadcast, and Unicast frames are
+ *                           tracked as part of the rate resource calculation.
+ *    13) Byte counted   : Account only Layer 3 bytes (IP header and payload)
+ *
+*/
+
+GT_STATUS samplePIRL2Setup(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_PIRL2_DATA pirlData;
+    GT_U32        irlRes;
+    GT_LPORT     port;
+
+    /* change Current Timer Update Interval */
+    status = gpirl2SetCurTimeUpInt(dev,4);
+    switch (status)
+    {
+        case GT_OK:
+            break;
+        case GT_NOT_SUPPORTED:
+            MSG_PRINT(("Device is not supporting PIRL.\n"));
+            return status;
+        default:
+            MSG_PRINT(("Failure to configure device.\n"));
+            return status;
+    }
+
+    port = 0;
+    irlRes = 0;
+
+    pirlData.ingressRate         = 128;
+
+    pirlData.customSetup.isValid = GT_FALSE;
+
+    pirlData.accountQConf         = GT_FALSE;
+    pirlData.accountFiltered    = GT_TRUE;
+
+    pirlData.mgmtNrlEn = GT_TRUE;
+    pirlData.saNrlEn   = GT_TRUE;
+    pirlData.daNrlEn   = GT_FALSE;
+    pirlData.samplingMode = GT_FALSE;
+    pirlData.actionMode = PIRL_ACTION_USE_LIMIT_ACTION;
+
+    pirlData.ebsLimitAction        = ESB_LIMIT_ACTION_DROP;
+    pirlData.bktRateType        = BUCKET_TYPE_TRAFFIC_BASED;
+    pirlData.bktTypeMask        = BUCKET_TRAFFIC_BROADCAST |
+                                  BUCKET_TRAFFIC_MULTICAST |
+                                  BUCKET_TRAFFIC_UNICAST   |
+                                  BUCKET_TRAFFIC_MGMT_FRAME|
+                                  BUCKET_TRAFFIC_ARP;
+
+    pirlData.priORpt = GT_TRUE;
+    pirlData.priMask = 0;
+
+    pirlData.byteTobeCounted    = GT_PIRL2_COUNT_ALL_LAYER3;
+
+    status = gpirl2WriteResource(dev,port,irlRes,&pirlData);
+
+    switch (status)
+    {
+        case GT_OK:
+            MSG_PRINT(("PIRL2 writing completed.\n"));
+            break;
+        case GT_BAD_PARAM:
+            MSG_PRINT(("Invalid parameters are given.\n"));
+            break;
+        case GT_NOT_SUPPORTED:
+            MSG_PRINT(("Device is not supporting PIRL2.\n"));
+            break;
+        default:
+            MSG_PRINT(("Failure to configure device.\n"));
+            break;
+    }
+
+    return status;
+}
+
+
+
+/*
+ *    This setup function shows how to configure Ingress Rate of 128Kbps with the
+ *    custom data information.
+ *  it configures the resource 0 of Port 0 of Marvell SOHO Switch Device with
+ *    capability of PIRL to be :
+ *
+ *    1) Custom setup for Ingress Rate : Enabled
+ *    2) Custom EBS Limit : 0xFFFFFF
+ *    3) Custom CBS Limit : 0x200000
+ *    4) Custom Bucket Increament  : 0x3D
+ *    5) Custom Bucket Rate Factor : 2
+ *    6) Discarded frame : Do not account discarded frame due to queue congestion
+ *    7) Filtered frame  : Account filtered frame
+ *    8) Mgmt frame      : Exclude management frame from rate limiting calculation
+ *    9) SA found in ATU : Exclude from ingress rate limiting calculation if the SA of the
+ *                         frame is in ATU with EntryState that indicates Non Rate Limited.
+ *    10) DA found in ATU : Include to ingress rate limiting calculation even though the DA of the
+ *                         frame is in ATU with EntryState that indicates Non Rate Limited.
+ *    11) Sampling Mode   : Disable the mode
+ *    12) Action Mode     : Follow Limit action when there are not enough tokens to accept the
+ *                         entire imcoming frame.
+ *    13) Limit action   : Drop packets when the incoming rate exceeds the limit
+ *    14) Rate type      : Rate is based on Traffic type
+ *    15) Traffic type   : ARP, MGMT, Multicast, Broadcast, and Unicast frames are
+ *                           tracked as part of the rate resource calculation.
+ *    16) Byte counted   : Account only Layer 3 bytes (IP header and payload)
+ *
+*/
+
+GT_STATUS samplePIRL2CustomSetup(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_PIRL2_DATA pirlData;
+    GT_U32        irlRes;
+    GT_LPORT     port;
+
+    port = 0;
+    irlRes = 0;
+
+    pirlData.customSetup.isValid = GT_TRUE;
+    pirlData.customSetup.ebsLimit = 0xFFFFFF;
+    pirlData.customSetup.cbsLimit = 0x200000;
+    pirlData.customSetup.bktIncrement = 0x3D;
+    pirlData.customSetup.bktRateFactor = 2;
+
+    pirlData.accountQConf         = GT_FALSE;
+    pirlData.accountFiltered    = GT_TRUE;
+
+    pirlData.mgmtNrlEn = GT_TRUE;
+    pirlData.saNrlEn   = GT_TRUE;
+    pirlData.daNrlEn   = GT_FALSE;
+    pirlData.samplingMode = GT_FALSE;
+    pirlData.actionMode = PIRL_ACTION_USE_LIMIT_ACTION;
+
+    pirlData.ebsLimitAction        = ESB_LIMIT_ACTION_DROP;
+    pirlData.bktRateType        = BUCKET_TYPE_TRAFFIC_BASED;
+    pirlData.bktTypeMask        = BUCKET_TRAFFIC_BROADCAST |
+                                  BUCKET_TRAFFIC_MULTICAST |
+                                  BUCKET_TRAFFIC_UNICAST   |
+                                  BUCKET_TRAFFIC_MGMT_FRAME|
+                                  BUCKET_TRAFFIC_ARP;
+
+    pirlData.priORpt = GT_TRUE;
+    pirlData.priMask = 0;
+
+    pirlData.byteTobeCounted    = GT_PIRL2_COUNT_ALL_LAYER3;
+
+    status = gpirl2WriteResource(dev,port,irlRes,&pirlData);
+
+    switch (status)
+    {
+        case GT_OK:
+            MSG_PRINT(("PIRL2 writing completed.\n"));
+            break;
+        case GT_BAD_PARAM:
+            MSG_PRINT(("Invalid parameters are given.\n"));
+            break;
+        case GT_NOT_SUPPORTED:
+            MSG_PRINT(("Device is not supporting PIRL2.\n"));
+            break;
+        default:
+            MSG_PRINT(("Failure to configure device.\n"));
+            break;
+    }
+
+    return status;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PIRL/readme.txt
@@ -0,0 +1,16 @@
+==================================================================
+		PIRL (Port based Ingress Rate Limit) Setup
+==================================================================
+
+88E6065 device family, 88E6097 device family, and recent Marvell SOHO
+Switch Devices support 'Best-in-Class' per port TCP/IP ingress rate limiting
+(based on some kind of a bucket scheme to keep track of the bandwidth) along
+with independent Storm prevention.
+
+This sample shows how to use PIRL resources.
+
+pirl.c
+    this sample routines support 88E6065 device family.
+
+pirl2.c
+    this sample routines support 88E6097 device family.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PTP/ptp.c
@@ -0,0 +1,281 @@
+#include <Copyright.h>
+/********************************************************************************
+* ptp.c
+*
+* DESCRIPTION:
+*       Setup PTP for 88E6165 device family.
+*
+* DEPENDENCIES:   None.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+
+/*
+ *  PTP Init routine
+ *
+ *    1) Setup each port to forward PTP frame to CPU port
+ *    2) Enable PTP Interrupt (assumes that no other interrupt is used, but PTP)
+ *    3) Configure PTP
+ *    4) Enable PTP
+ *
+ *    Notes: This sample uses the following configuration
+ *    1) Enables only PTP interrupt
+ *    2) Assumes PTP Ethernet Type is 0x88F7
+ *    3) Time Stamp is enabled only for Message ID 0, 2, and 3
+ *    4) Message ID 0 and 2 use Arr0 pointer and ID 3 uses Arr1 pointer
+ *    5) PTP interrtups are enabled on Port 0 ~ 5
+ *
+ *    Notes: Forwarding PTP fram to CPU port is based on Ether Type DSA Tag (8 bytes).
+ *    Therefore, Ethernet device driver, that actually rx/tx the PTP frame,
+ *    should expect/insert Ether Type DSA Tag.
+*/
+
+GT_STATUS samplePTPInit(GT_QD_DEV *dev)
+{
+     GT_PTP_CONFIG ptpCfg;
+    GT_LPORT port;
+    GT_STATUS status;
+
+
+    /*
+     *    1) Setup each port to forward PTP frame to CPU port
+    */
+
+    /* setup EtypeType and Policy */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if ((status = gprtSetPortEType(dev, port, (GT_ETYPE)0x88F7)) != GT_OK)
+        {
+            MSG_PRINT(("gprtSetPortEType returned not OK\n"));
+            return status;
+        }
+
+        if (port == dev->cpuPortNum)
+            continue;
+
+        if ((status = gprtSetPolicy(dev, port, POLICY_TYPE_ETYPE, FRAME_POLICY_TRAP)) != GT_OK)
+        {
+            MSG_PRINT(("gprtSetPolicy returned not OK\n"));
+            return status;
+        }
+    }
+
+    /* setup Frame Mode for CPU port */
+    if ((status = gprtSetFrameMode(dev, dev->cpuPortNum, GT_FRAME_MODE_ETHER_TYPE_DSA)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetFrameMode return failed\n"));
+        return status;
+    }
+
+    /*
+     *    2) Enable PTP Interrupt
+    */
+    eventSetActive(dev, GT_AVB_INT);
+
+
+    /*
+     *    3) Configure PTP
+    */
+    ptpCfg.ptpEType = 0x88F7;
+    ptpCfg.msgIdTSEn = 0xd;        /* id 0, 2, and 3 */
+    ptpCfg.tsArrPtr = 0x8;        /* id 0 and 2 for ARR0, id 3 for ARR1 */
+
+    /* Transport specific bits present in PTP Common Header */
+    ptpCfg.transSpec = 1;
+
+    /* starting bit location for the Message ID field in the PTP Common Header */
+    ptpCfg.msgIdStartBit = 4;
+
+    ptpCfg.ptpArrIntEn = 0x3F;
+    ptpCfg.ptpDepIntEn = 0x3F;
+    ptpCfg.disTSOverwrite = 0;
+
+
+    if ((status = gptpSetConfig(dev, &ptpCfg)) != GT_OK)
+    {
+        MSG_PRINT(("gptpSetConfig return failed\n"));
+        return status;
+    }
+    if ((status = gptpSetPTPEn(dev, GT_TRUE)) != GT_OK)
+    {
+        MSG_PRINT(("gptpSetPTPEn return failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ *  PTP Interrupt Handler
+ *
+ *    1) for each port that causes PTP interrup, do the followings
+ *    2) check Arrival 0 Time Stamp
+ *    3) check Arrival 1 Time Stamp
+ *    4) check Departure Time Stamp
+*/
+
+GT_STATUS samplePTPIntHandler(GT_QD_DEV *dev)
+{
+    GT_U32 int_ports, i, int_status;
+    GT_STATUS status;
+    GT_PTP_TS_STATUS    ptpStatus;
+
+    /* disable AVB Interrupt */
+    eventSetActive(dev, 0);
+
+    /* read interrupt cause */
+    if((status=eventGetIntStatus(dev,(GT_U16*)&int_status))!=GT_OK)
+    {
+        return GT_FAIL;
+    }
+
+
+    if ((int_status & GT_AVB_INT) == 0)
+    {
+        MSG_PRINT(("eventGetIntStatus return No AVB Interrupt\n"));
+        /* it's not PTP interrupt */
+        goto ret_int;
+    }
+
+    /* read AVB Int status */
+    if((status = gptpGetPTPInt(dev, &int_ports)) != GT_OK)
+    {
+        MSG_PRINT(("gptpGetPTPInt return failed\n"));
+        goto ret_int;
+    }
+
+    /* for each port, get the timestamp information if necessary */
+    i = 0;
+    while(int_ports)
+    {
+        if(!(int_ports & 0x1))
+        {
+            i++;
+            int_ports >>= 1;
+            continue;
+        }
+
+        /* check Arrival0 Time Stamp */
+        if((status = gptpGetTimeStamped(dev, i, PTP_ARR0_TIME, &ptpStatus)) != GT_OK)
+        {
+            MSG_PRINT(("gptpGetTimeStamped return failed\n"));
+            goto ret_int;
+        }
+
+        if (ptpStatus.isValid == GT_TRUE)
+        {
+            switch(ptpStatus.status)
+            {
+                case PTP_INT_NORMAL:
+                    /* To Do: No error condition occurred. So store the time stamp and seqId */
+                    break;
+
+                case PTP_INT_OVERWRITE:
+                    /* To Do: PTP Logic received several PTP frames and only the last one is valid */
+                    break;
+
+                case PTP_INT_DROP:
+                    /* To Do: PTP Logic received several PTP frames and only the first one is valid */
+                    break;
+
+                default:
+                    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
+                    status = GT_FAIL;
+                    goto ret_int;
+
+            }
+
+            if((status = gptpResetTimeStamp(dev, i, PTP_ARR0_TIME)) != GT_OK)
+            {
+                MSG_PRINT(("gptpResetTimeStamp return failed\n"));
+                goto ret_int;
+            }
+        }
+
+        /* check Arrival1 Time Stamp */
+        if((status = gptpGetTimeStamped(dev, i, PTP_ARR1_TIME, &ptpStatus)) != GT_OK)
+        {
+            MSG_PRINT(("gptpGetTimeStamped return failed\n"));
+            goto ret_int;
+        }
+
+        if (ptpStatus.isValid == GT_TRUE)
+        {
+            switch(ptpStatus.status)
+            {
+                case PTP_INT_NORMAL:
+                    /* To Do: No error condition occurred. So store the time stamp and seqId */
+                    break;
+
+                case PTP_INT_OVERWRITE:
+                    /* To Do: PTP Logic received several PTP frames and only the last one is valid */
+                    break;
+
+                case PTP_INT_DROP:
+                    /* To Do: PTP Logic received several PTP frames and only the first one is valid */
+                    break;
+
+                default:
+                    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
+                    status = GT_FAIL;
+                    goto ret_int;
+            }
+
+            if((status = gptpResetTimeStamp(dev, i, PTP_ARR1_TIME)) != GT_OK)
+            {
+                MSG_PRINT(("gptpResetTimeStamp return failed\n"));
+                goto ret_int;
+            }
+
+        }
+
+        /* check Departure Time Stamp */
+        if((status = gptpGetTimeStamped(dev, i, PTP_DEP_TIME, &ptpStatus)) != GT_OK)
+        {
+            MSG_PRINT(("gptpGetTimeStamped return failed\n"));
+            goto ret_int;
+        }
+
+        if (ptpStatus.isValid == GT_TRUE)
+        {
+            switch(ptpStatus.status)
+            {
+                case PTP_INT_NORMAL:
+                    /* To Do: No error condition occurred. So store the time stamp and seqId */
+                    break;
+
+                case PTP_INT_OVERWRITE:
+                    /* To Do: PTP Logic received several PTP frames and only the last one is valid */
+                    break;
+
+                case PTP_INT_DROP:
+                    /* To Do: PTP Logic received several PTP frames and only the first one is valid */
+                    break;
+
+                default:
+                    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
+                    status = GT_FAIL;
+                    goto ret_int;
+            }
+
+            if((status = gptpResetTimeStamp(dev, i, PTP_DEP_TIME)) != GT_OK)
+            {
+                MSG_PRINT(("gptpResetTimeStamp return failed\n"));
+                goto ret_int;
+            }
+
+        }
+
+        int_ports >>= 1;
+
+    }
+
+ret_int:
+    eventSetActive(dev, GT_AVB_INT);
+
+    return status;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PTP/readme.txt
@@ -0,0 +1,7 @@
+==================================================================
+                PTP (Precise Time Protocol) Setup
+==================================================================
+
+88E6165 device family Switch Devices support PTP.
+
+This sample shows how to use PTP APIs.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PktGen/phyPktGenSample.c
@@ -0,0 +1,86 @@
+#include <Copyright.h>
+/********************************************************************************
+* phyPktGenSample.c
+*
+* DESCRIPTION:
+*       Packet Generator setup sample (startQdPktGenerator and stopQdPktGenerator).
+*
+* DEPENDENCIES:
+*        Please check the phy device's spec. if the device supports this feature.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+
+/*
+ * Start Packet Generator.
+ * Input:
+ *      pktload - enum GT_PG_PAYLOAD (GT_PG_PAYLOAD_RANDOM or GT_PG_PAYLOAD_5AA5)
+ *      length  - enum GT_PG_LENGTH  (GT_PG_LENGTH_64 or GT_PG_LENGTH_1514)
+ *      tx      - enum GT_PG_TX      (GT_PG_TX_NORMAL or GT_PG_TX_ERROR)
+*/
+GT_STATUS startQdPktGenerator
+(
+    GT_QD_DEV      *dev,
+    GT_LPORT       port,
+    GT_PG_PAYLOAD  payload,
+    GT_PG_LENGTH   length,
+    GT_PG_TX       tx
+)
+{
+    GT_STATUS status;
+    GT_PG     pktInfo;
+
+    if (dev == 0)
+    {
+        MSG_PRINT(("GT driver is not initialized\n"));
+        return GT_FAIL;
+    }
+
+    MSG_PRINT(("Start Packet Generator for port %i\n",(int)port));
+
+    pktInfo.payload = payload; /* Pseudo-random, 5AA55AA5... */
+    pktInfo.length = length;   /* 64 bytes, 1514 bytes */
+    pktInfo.tx = tx;           /* normal packet, error packet */
+
+    /*
+     *    Start Packet Generator
+    */
+    if((status = gprtSetPktGenEnable(dev,port,GT_TRUE,&pktInfo)) != GT_OK)
+    {
+        MSG_PRINT(("mdDiagSetPktGenEnable return Failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ * Stop Packet Generator.
+ */
+GT_STATUS stopQdPktGenerator(GT_QD_DEV *dev,GT_LPORT port)
+{
+    GT_STATUS status;
+
+    if (dev == 0)
+    {
+        MSG_PRINT(("GT driver is not initialized\n"));
+        return GT_FAIL;
+    }
+
+    MSG_PRINT(("Stopping Packet Generator for port %i\n",(int)port));
+
+    /*
+     *    Start Packet Generator
+    */
+    if((status = gprtSetPktGenEnable(dev,port,GT_FALSE,NULL)) != GT_OK)
+    {
+        MSG_PRINT(("mdDiagSetPktGenEnable return Failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PktGen/readme.txt
@@ -0,0 +1,12 @@
+
+            Sample for Packet Generator
+=======================================================
+
+This sample shows how to start/stop Packet Generator.
+
+Main Functions:
+    startPktGenerator - start Packet Generator
+    stopPktGenerator  - stop Packet Generator
+
+Used APIs:
+    gprtSetPktGenEnable
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PortMonitor/portMonitor.c
@@ -0,0 +1,107 @@
+#include <Copyright.h>
+/********************************************************************************
+* portMonitor.c
+*
+* DESCRIPTION:
+*        This sample shows how to monitor a certain port. Port monitoring is
+*        supported by the ClipperShip device with Egress only monitoring or
+*        Egress and Ingress monitoring.
+*
+* DEPENDENCIES:
+*        Only ClipperShip Family supports this feature.
+*
+* FILE REVISION NUMBER:
+*
+* COMMENTS:
+*******************************************************************************/
+
+#include "msSample.h"
+
+/*
+ *    Enable EgressMonitoring for the monitoredPort.
+ *    With this setup, monitoringPort will receive every packet
+ *    which egressed from monitoredPort.
+*/
+GT_STATUS sampleEgressMonitor(GT_QD_DEV *dev,GT_LPORT monitoredPort, GT_LPORT monitoringPort)
+{
+    GT_STATUS status;
+    GT_U16 pav;
+
+    /*
+     *    Enable EgressMonitoring for the monitoredPort.
+    */
+    pav = (1<<monitoringPort) || (1<<monitoredPort);
+
+    if((status = gpavSetPAV(dev,monitoredPort, pav)) != GT_OK)
+    {
+        MSG_PRINT(("gpavSetPAV return Failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+/*
+ *    Enable Egress Monitoring and Ingress Monitoring for the monitoredPort.
+ *    With this setup, monitoringPort will receive every packet
+ *    which is both from monitoredPort and to monitoredPort.
+*/
+GT_STATUS samplePortMonitor(GT_QD_DEV *dev,GT_LPORT monitoredPort, GT_LPORT monitoringPort)
+{
+    GT_STATUS status;
+    GT_U16 pav;
+
+    /*
+     *    Enable Egress Monitoring for the monitoredPort.
+    */
+    pav = (1<<monitoringPort) || (1<<monitoredPort);
+
+    if((status = gpavSetPAV(dev,monitoredPort, pav)) != GT_OK)
+    {
+        MSG_PRINT(("gpavSetPAV return Failed\n"));
+        return status;
+    }
+
+    /*
+     *    Enable Ingress Monitoring for the monitoredPort.
+    */
+    if((status = gpavSetIngressMonitor(dev,monitoredPort, GT_TRUE)) != GT_OK)
+    {
+        MSG_PRINT(("gpavSetIngressMonitor return Failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ *    Disable Egress Monitoring and Ingress Monitoring for the monitoredPort.
+*/
+GT_STATUS sampleDisablePortMonitor(GT_QD_DEV *dev,GT_LPORT monitoredPort)
+{
+    GT_STATUS status;
+    GT_U16 pav;
+
+    /*
+     *    Disable Egress Monitoring for the monitoredPort.
+    */
+    pav = (1<<monitoredPort);
+
+    if((status = gpavSetPAV(dev,monitoredPort, pav)) != GT_OK)
+    {
+        MSG_PRINT(("gpavSetPAV return Failed\n"));
+        return status;
+    }
+
+    /*
+     *    Disable Ingress Monitoring for the monitoredPort.
+    */
+    if((status = gpavSetIngressMonitor(dev,monitoredPort, GT_FALSE)) != GT_OK)
+    {
+        MSG_PRINT(("gpavSetIngressMonitor return Failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/PortMonitor/readme.txt
@@ -0,0 +1,21 @@
+========================================================================
+		Port Monitor Setup
+========================================================================
+
+88E6063 device supports Port Monitoring, which allows a user to monitor
+all the traffic of a certain port.
+This sample shows how to enable/disable Port Monitoring.
+For more information about Port Monitoring, please refer to 88E6063 Spec.
+
+Note :
+Port monitoring supported by ClipperShip has two modes:
+1. Egress only monitoring (monitor packets comming out of the
+monitored port, and
+2. Egress and Ingress monitoring (monitor packet comming in and out
+from the monitored port)
+
+portMonitor.c
+	sampleEgressMonitor can be used to enable Egress only port monitoring.
+	samplePortMonitor can be used to enable Egress and Ingress monitoring.
+	sampleDisablePortMonitor can be used to disable monitoring
+	(both Egress only mode and Egress and Ingress mode).
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/QoSSetup/qos.c
@@ -0,0 +1,195 @@
+#include <Copyright.h>
+/********************************************************************************
+* qos.c
+*
+* DESCRIPTION:
+*       Sample program which will show how to setup the Priority Queue for QoS
+*
+*
+* DEPENDENCIES:   None.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+/*
+ *    sampleQoS will enable using both IEEE 802.3ac Tag and IPv4/IPv6 Traffic
+ *    Class field and IEEE 802.3ac has a higher priority than IPv4/IPv6.
+ *    The following is the QoS mapping programmed by sampleQos:
+ *    1) IEEE 802.3ac Tag (Priority 0 ~ 7, 3 bits)
+ *        Priority 1~3 is using QuarterDeck Queue 0.
+ *        Priority 0,4 is using QuarterDeck Queue 1.
+ *        Priority 6,7 is using QuarterDeck Queue 2.
+ *        Priority 5 is using QuarterDeck Queue 3.
+ *    2) IPv4/IPv6 (Priority 0 ~ 63, 6 bits)
+ *        Priority 0~7 is using QuaterDeck Queue 0.
+ *        Priority 8~31 is using QuaterDeck Queue 1.
+ *        Priority 32~55 is using QuaterDeck Queue 2.
+ *        Priority 56~63 is using QuaterDeck Queue 3.
+ *    3) Each port's default priority is set to 1.
+*/
+GT_STATUS sampleQos(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_U8 priority;
+    GT_LPORT port;
+
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+       /*
+         *  Use IEEE Tag
+         */
+        if((status = gqosUserPrioMapEn(dev,port,GT_TRUE)) != GT_OK)
+        {
+            MSG_PRINT(("gqosUserPrioMapEn return Failed\n"));
+            return status;
+        }
+
+        /*
+         *  Use IPv4/IPv6 priority fields (use IP)
+         */
+        if((status = gqosIpPrioMapEn(dev,port,GT_TRUE)) != GT_OK)
+        {
+            MSG_PRINT(("gqosIpPrioMapEn return Failed\n"));
+            return status;
+        }
+
+        /*
+         *  IEEE Tag has higher priority than IP priority fields
+         */
+        if((status = gqosSetPrioMapRule(dev,port,GT_TRUE)) != GT_OK)
+        {
+            MSG_PRINT(("gqosSetPrioMapRule return Failed\n"));
+            return status;
+        }
+        MSG_PRINT(("sampleQos port %d Ok\n", port));
+    }
+
+    /*
+     *    IEEE 802.3ac Tag (Priority 0 ~ 7, 3 bits)
+     *    Priority 1~3 is using QuarterDeck Queue 0.
+     *    Priority 0,4 is using QuarterDeck Queue 1.
+     *    Priority 6,7 is using QuarterDeck Queue 2.
+     *    Priority 5 is using QuarterDeck Queue 3.
+    */
+
+    /*    Priority 0 is using QuarterDeck Queue 1. */
+    if((status = gcosSetUserPrio2Tc(dev,0,1)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 1 is using QuarterDeck Queue 0. */
+    if((status = gcosSetUserPrio2Tc(dev,1,0)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 2 is using QuarterDeck Queue 0. */
+    if((status = gcosSetUserPrio2Tc(dev,2,0)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 3 is using QuarterDeck Queue 0. */
+    if((status = gcosSetUserPrio2Tc(dev,3,0)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 4 is using QuarterDeck Queue 1. */
+    if((status = gcosSetUserPrio2Tc(dev,4,1)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 5 is using QuarterDeck Queue 3. */
+    if((status = gcosSetUserPrio2Tc(dev,5,3)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 6 is using QuarterDeck Queue 2. */
+    if((status = gcosSetUserPrio2Tc(dev,6,2)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 7 is using QuarterDeck Queue 2. */
+    if((status = gcosSetUserPrio2Tc(dev,7,2)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+
+    /*
+     *    IPv4/IPv6 (Priority 0 ~ 63, 6 bits)
+     *    Priority 0~7 is using QuaterDeck Queue 0.
+     *    Priority 8~31 is using QuaterDeck Queue 1.
+     *    Priority 32~55 is using QuaterDeck Queue 2.
+     *    Priority 56~63 is using QuaterDeck Queue 3.
+    */
+
+    /*    Priority 0~7 is using QuaterDeck Queue 0. */
+    for(priority=0; priority<8; priority++)
+    {
+        if((status = gcosSetDscp2Tc(dev,priority,0)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*    Priority 8~31 is using QuaterDeck Queue 1. */
+    for(priority=8; priority<32; priority++)
+    {
+        if((status = gcosSetDscp2Tc(dev,priority,1)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*    Priority 32~55 is using QuaterDeck Queue 2. */
+    for(priority=32; priority<56; priority++)
+    {
+        if((status = gcosSetDscp2Tc(dev,priority,2)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*    Priority 56~63 is using QuaterDeck Queue 3. */
+    for(priority=56; priority<64; priority++)
+    {
+        if((status = gcosSetDscp2Tc(dev,priority,3)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*
+     * Each port's default priority is set to 1.
+    */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if((status = gcosSetPortDefaultTc(dev,port,1)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/QoSSetup/readme.txt
@@ -0,0 +1,32 @@
+========================================================================
+		Priority Queue Setup for QoS
+========================================================================
+
+QuarterDeck Device has 4 Priority Queues to support QoS. The priority of
+a frame is determined by (in priority order):
+	1) The CPU's Trailer if enabled on the port.
+	2) The DA address in the frame if the frame's DA address is in the address
+		database with a priority defined.
+	3) The IEEE 802.3ac Tag containing IEEE 802.1p priority information
+		if enabled on the port.
+	4) The IPv4 Type of Service (TOS)/DiffServ field or IPv6 Traffic Class
+		field if enabled on the port.
+	5) The Port's default priority defined in DefPri.
+
+This sample program will deal with the above 3) ~ 5) cases.
+
+qos.c
+	sampleQoS will enable using both IEEE 802.3ac Tag and IPv4/IPv6 Traffic
+	Class field and IEEE 802.3ac has a higher priority than IPv4/IPv6.
+	The following is the QoS mapping programmed by sampleQos:
+	1) IEEE 802.3ac Tag (Priority 0 ~ 7, 3 bits)
+		Priority 1~3 is using QuarterDeck Queue 0.
+		Priority 0,4 is using QuarterDeck Queue 1.
+		Priority 6,7 is using QuarterDeck Queue 2.
+		Priority 5 is using QuarterDeck Queue 3.
+	2) IPv4/IPv6 (Priority 0 ~ 63, 6 bits)
+		Priority 0~7 is using QuaterDeck Queue 0.
+		Priority 8~31 is using QuaterDeck Queue 1.
+		Priority 32~55 is using QuaterDeck Queue 2.
+		Priority 56~63 is using QuaterDeck Queue 3.
+	3) Each port's default priority is set to 1.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/README
@@ -0,0 +1,2 @@
+This directory includes sample code that demonstrats how to use the API of
+the DSDT Suite. There is a readme.txt file in each of the subdirectories.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/RMON/readme.txt
@@ -0,0 +1,28 @@
+========================================================================
+		RMON Counters
+========================================================================
+
+This sample shows how to read/clear RMON counter in the device.
+Please notes that there are three groups of RMON counters in Marvell SOHO Switchs.
+Each group has different set of counters. Therefore it is necessary to find out
+which group the switch device belongs to.
+
+Group for GT_STATS_COUNTERS : 88E6021, 88E6063, and 88E6083
+Group for GT_STATS_COUNTERS2 : 88E6183
+Group for GT_STATS_COUNTERS3 : 88E6093, 88E6095, 88E6185, and 88E6065
+
+rmon.c
+	sampleClearRMONCounter
+		shows how to reset RMON counter for the given port
+
+	sampleGetRMONCounter
+		shows how to read RMON counter for each port
+        this routine is for the devices that use GT_STATS_COUNTERS.
+
+	sampleGetRMONCounter2
+		shows how to read RMON counter for each port
+        this routine is for the devices that use GT_STATS_COUNTERS2.
+
+	sampleGetRMONCounter3
+		shows how to read RMON counter for each port
+        this routine is for the devices that use GT_STATS_COUNTERS3.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/RMON/rmon.c
@@ -0,0 +1,237 @@
+#include <Copyright.h>
+/********************************************************************************
+* rmon.c
+*
+* DESCRIPTION:
+*        This sample shows how to read/clear RMON counter in the device
+*
+* DEPENDENCIES:   NONE.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include "msSample.h"
+
+
+/*
+ * This sample is for every device that support RMON counter.
+*/
+GT_STATUS sampleClearRMONCounter(GT_QD_DEV *dev,GT_LPORT port)
+{
+    GT_STATUS status;
+
+    if((status = gstatsFlushPort(dev,port)) != GT_OK)
+    {
+        MSG_PRINT(("gstatsFlushPort returned fail (%#x).\n",status));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+/*
+ * This sample is for 88E6021, 88E6063, and 88E6083.
+*/
+void sampleDisplayCounter(GT_STATS_COUNTER_SET *statsCounter)
+{
+    MSG_PRINT(("InUnicasts    %08i    ", statsCounter->InUnicasts));
+    MSG_PRINT(("InBroadcasts  %08i   \n", statsCounter->InBroadcasts));
+    MSG_PRINT(("InPause       %08i    ", statsCounter->InPause));
+    MSG_PRINT(("InMulticasts  %08i   \n", statsCounter->InMulticasts));
+    MSG_PRINT(("InFCSErr      %08i    ", statsCounter->InFCSErr));
+    MSG_PRINT(("AlignErr      %08i   \n", statsCounter->AlignErr));
+    MSG_PRINT(("InGoodOctets  %08i    ", statsCounter->InGoodOctets));
+    MSG_PRINT(("InBadOctets   %08i   \n", statsCounter->InBadOctets));
+    MSG_PRINT(("Undersize     %08i    ", statsCounter->Undersize));
+    MSG_PRINT(("Fragments     %08i   \n", statsCounter->Fragments));
+    MSG_PRINT(("In64Octets    %08i    ", statsCounter->In64Octets));
+    MSG_PRINT(("In127Octets   %08i   \n", statsCounter->In127Octets));
+    MSG_PRINT(("In255Octets   %08i    ", statsCounter->In255Octets));
+    MSG_PRINT(("In511Octets   %08i   \n", statsCounter->In511Octets));
+    MSG_PRINT(("In1023Octets  %08i    ", statsCounter->In1023Octets));
+    MSG_PRINT(("InMaxOctets   %08i   \n", statsCounter->InMaxOctets));
+    MSG_PRINT(("Jabber        %08i    ", statsCounter->Jabber));
+    MSG_PRINT(("Oversize      %08i   \n", statsCounter->Oversize));
+    MSG_PRINT(("InDiscards    %08i    ", statsCounter->InDiscards));
+    MSG_PRINT(("Filtered      %08i   \n", statsCounter->Filtered));
+    MSG_PRINT(("OutUnicasts   %08i    ", statsCounter->OutUnicasts));
+    MSG_PRINT(("OutBroadcasts %08i   \n", statsCounter->OutBroadcasts));
+    MSG_PRINT(("OutPause      %08i    ", statsCounter->OutPause));
+    MSG_PRINT(("OutMulticasts %08i   \n", statsCounter->OutMulticasts));
+    MSG_PRINT(("OutFCSErr     %08i    ", statsCounter->OutFCSErr));
+    MSG_PRINT(("OutGoodOctets %08i   \n", statsCounter->OutGoodOctets));
+    MSG_PRINT(("Out64Octets   %08i    ", statsCounter->Out64Octets));
+    MSG_PRINT(("Out127Octets  %08i   \n", statsCounter->Out127Octets));
+    MSG_PRINT(("Out255Octets  %08i    ", statsCounter->Out255Octets));
+    MSG_PRINT(("Out511Octets  %08i   \n", statsCounter->Out511Octets));
+    MSG_PRINT(("Out1023Octets %08i    ", statsCounter->Out1023Octets));
+    MSG_PRINT(("OutMaxOctets  %08i   \n", statsCounter->OutMaxOctets));
+    MSG_PRINT(("Collisions    %08i    ", statsCounter->Collisions));
+    MSG_PRINT(("Late          %08i   \n", statsCounter->Late));
+    MSG_PRINT(("Excessive     %08i    ", statsCounter->Excessive));
+    MSG_PRINT(("Multiple      %08i   \n", statsCounter->Multiple));
+    MSG_PRINT(("Single        %08i    ", statsCounter->Single));
+    MSG_PRINT(("Deferred      %08i   \n", statsCounter->Deferred));
+    MSG_PRINT(("OutDiscards   %08i   \n", statsCounter->OutDiscards));
+}
+
+/*
+ * This sample is for 88E6021, 88E6063, and 88E6083.
+*/
+GT_STATUS sampleGetRMONCounter(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_LPORT port;
+    GT_STATS_COUNTER_SET    statsCounterSet;
+
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        MSG_PRINT(("Port %i :\n",port));
+
+        if((status = gstatsGetPortAllCounters(dev,port,&statsCounterSet)) != GT_OK)
+        {
+            MSG_PRINT(("gstatsGetPortAllCounters returned fail (%#x).\n",status));
+            return status;
+        }
+
+        sampleDisplayCounter(&statsCounterSet);
+
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ * This sample is for 88E6183
+*/
+void sampleDisplayCounter2(GT_STATS_COUNTER_SET2 *statsCounter)
+{
+    MSG_PRINT(("InGoodOctetsHi  %08i    ", statsCounter->InGoodOctetsHi));
+    MSG_PRINT(("InGoodOctetsLo  %08i   \n", statsCounter->InGoodOctetsLo));
+    MSG_PRINT(("InBadOctets     %08i    ", statsCounter->InBadOctets));
+    MSG_PRINT(("OutDiscards     %08i   \n", statsCounter->OutDiscards));
+    MSG_PRINT(("InGoodFrames    %08i    ", statsCounter->InGoodFrames));
+    MSG_PRINT(("InBadFrames     %08i   \n", statsCounter->InBadFrames));
+    MSG_PRINT(("InBroadcasts    %08i    ", statsCounter->InBroadcasts));
+    MSG_PRINT(("InMulticasts    %08i   \n", statsCounter->InMulticasts));
+    MSG_PRINT(("64Octets        %08i    ", statsCounter->Octets64));
+    MSG_PRINT(("127Octets       %08i   \n", statsCounter->Octets127));
+    MSG_PRINT(("255Octets       %08i    ", statsCounter->Octets255));
+    MSG_PRINT(("511Octets       %08i   \n", statsCounter->Octets511));
+    MSG_PRINT(("1023Octets      %08i    ", statsCounter->Octets1023));
+    MSG_PRINT(("MaxOctets       %08i   \n", statsCounter->OctetsMax));
+    MSG_PRINT(("OutOctetsHi     %08i    ", statsCounter->OutOctetsHi));
+    MSG_PRINT(("OutOctetsLo     %08i   \n", statsCounter->OutOctetsLo));
+    MSG_PRINT(("OutFrames       %08i    ", statsCounter->OutFrames));
+    MSG_PRINT(("Excessive       %08i   \n", statsCounter->Excessive));
+    MSG_PRINT(("OutMulticasts   %08i    ", statsCounter->OutMulticasts));
+    MSG_PRINT(("OutBroadcasts   %08i    ", statsCounter->OutBroadcasts));
+    MSG_PRINT(("InBadMACCtrl    %08i    ", statsCounter->InBadMACCtrl));
+    MSG_PRINT(("OutPause        %08i   \n", statsCounter->OutPause));
+    MSG_PRINT(("InPause         %08i    ", statsCounter->InPause));
+    MSG_PRINT(("InDiscards      %08i   \n", statsCounter->InDiscards));
+    MSG_PRINT(("Undersize       %08i    ", statsCounter->Undersize));
+    MSG_PRINT(("Fragments       %08i   \n", statsCounter->Fragments));
+    MSG_PRINT(("Oversize        %08i    ", statsCounter->Oversize));
+    MSG_PRINT(("Jabber          %08i   \n", statsCounter->Jabber));
+    MSG_PRINT(("MACRcvErr       %08i    ", statsCounter->MACRcvErr));
+    MSG_PRINT(("InFCSErr        %08i   \n", statsCounter->InFCSErr));
+    MSG_PRINT(("Collisions      %08i    ", statsCounter->Collisions));
+    MSG_PRINT(("Late            %08i   \n", statsCounter->Late));
+}
+
+/*
+ * This sample is for 88E6183
+*/
+GT_STATUS sampleGetRMONCounter2(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_LPORT port;
+    GT_STATS_COUNTER_SET2 statsCounterSet;
+
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        MSG_PRINT(("Port %i :\n",port));
+
+        if((status = gstatsGetPortAllCounters2(dev,port,&statsCounterSet)) != GT_OK)
+        {
+            MSG_PRINT(("gstatsGetPortAllCounters2 returned fail (%#x).\n",status));
+            return status;
+        }
+
+        sampleDisplayCounter2(&statsCounterSet);
+
+    }
+
+    return GT_OK;
+}
+
+
+
+/*
+ * This sample is for 88E6093, 88E6095, 88E6185, and 88E6065
+*/
+void sampleDisplayCounter3(GT_STATS_COUNTER_SET3 *statsCounter)
+{
+    MSG_PRINT(("InGoodOctetsLo  %08i    ", statsCounter->InGoodOctetsLo));
+    MSG_PRINT(("InGoodOctetsHi  %08i   \n", statsCounter->InGoodOctetsHi));
+    MSG_PRINT(("InBadOctets     %08i    ", statsCounter->InBadOctets));
+    MSG_PRINT(("OutFCSErr       %08i   \n", statsCounter->OutFCSErr));
+    MSG_PRINT(("InUnicasts      %08i    ", statsCounter->InUnicasts));
+    MSG_PRINT(("Deferred        %08i   \n", statsCounter->Deferred));
+    MSG_PRINT(("InBroadcasts    %08i    ", statsCounter->InBroadcasts));
+    MSG_PRINT(("InMulticasts    %08i   \n", statsCounter->InMulticasts));
+    MSG_PRINT(("64Octets        %08i    ", statsCounter->Octets64));
+    MSG_PRINT(("127Octets       %08i   \n", statsCounter->Octets127));
+    MSG_PRINT(("255Octets       %08i    ", statsCounter->Octets255));
+    MSG_PRINT(("511Octets       %08i   \n", statsCounter->Octets511));
+    MSG_PRINT(("1023Octets      %08i    ", statsCounter->Octets1023));
+    MSG_PRINT(("MaxOctets       %08i   \n", statsCounter->OctetsMax));
+    MSG_PRINT(("OutOctetsLo     %08i    ", statsCounter->OutOctetsLo));
+    MSG_PRINT(("OutOctetsHi     %08i   \n", statsCounter->OutOctetsHi));
+    MSG_PRINT(("OutUnicasts     %08i    ", statsCounter->OutUnicasts));
+    MSG_PRINT(("Excessive       %08i   \n", statsCounter->Excessive));
+    MSG_PRINT(("OutMulticasts   %08i    ", statsCounter->OutMulticasts));
+    MSG_PRINT(("OutBroadcasts   %08i   \n", statsCounter->OutBroadcasts));
+    MSG_PRINT(("Single          %08i    ", statsCounter->Single));
+    MSG_PRINT(("OutPause        %08i   \n", statsCounter->OutPause));
+    MSG_PRINT(("InPause         %08i    ", statsCounter->InPause));
+    MSG_PRINT(("Multiple        %08i   \n", statsCounter->Multiple));
+    MSG_PRINT(("Undersize       %08i    ", statsCounter->Undersize));
+    MSG_PRINT(("Fragments       %08i   \n", statsCounter->Fragments));
+    MSG_PRINT(("Oversize        %08i    ", statsCounter->Oversize));
+    MSG_PRINT(("Jabber          %08i   \n", statsCounter->Jabber));
+    MSG_PRINT(("InMACRcvErr     %08i    ", statsCounter->InMACRcvErr));
+    MSG_PRINT(("InFCSErr        %08i   \n", statsCounter->InFCSErr));
+    MSG_PRINT(("Collisions      %08i    ", statsCounter->Collisions));
+    MSG_PRINT(("Late            %08i   \n", statsCounter->Late));
+}
+
+
+/*
+ * This sample is for 88E6093, 88E6095, 88E6185, and 88E6065
+*/
+GT_STATUS sampleGetRMONCounter3(GT_QD_DEV *dev)
+{
+    GT_STATUS status;
+    GT_LPORT port;
+    GT_STATS_COUNTER_SET3 statsCounterSet;
+
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        MSG_PRINT(("Port %i :\n",port));
+
+        if((status = gstatsGetPortAllCounters3(dev,port,&statsCounterSet)) != GT_OK)
+        {
+            MSG_PRINT(("gstatsGetPortAllCounters3 returned fail (%#x).\n",status));
+            return status;
+        }
+
+        sampleDisplayCounter3(&statsCounterSet);
+
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Trailer/readme.txt
@@ -0,0 +1,12 @@
+========================================================================
+		CPU Trailer Mode Enable or Disable
+========================================================================
+
+This sample shows how to enable/disable CPU port's ingress trailer mode
+and engress trailer mode.
+For more information about trailer mode, please refer to 88E6052 Spec.
+section 3.5.5 and section 3.7.3
+
+trailer.c
+	sampleCPUTrailerEnable can be used to enable or disable CPU port's
+	trailer mode
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/Trailer/trailer.c
@@ -0,0 +1,50 @@
+#include <Copyright.h>
+/********************************************************************************
+* trailer.c
+*
+* DESCRIPTION:
+*        This sample shows how to enable/disable CPU port's ingress and egress
+*        Trailer mode.
+*
+* DEPENDENCIES:   NONE.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include "msSample.h"
+
+GT_STATUS sampleCPUTrailerEnable(GT_QD_DEV *dev, GT_BOOL en)
+{
+    GT_STATUS status;
+    GT_INGRESS_MODE    inMode;
+
+    if (en)    /* Enable Trailer Mode */
+    {
+        inMode = GT_TRAILER_INGRESS;
+    }
+    else
+    {
+        inMode = GT_UNMODIFY_INGRESS;
+    }
+
+    /*
+     *    Enable CPU's Ingress Trailer
+    */
+    if((status = gprtSetIngressMode(dev,dev->cpuPortNum, inMode)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetIngressMode return Failed\n"));
+        return status;
+    }
+
+    /*
+     *    Enable CPU's Egress Trailer
+    */
+    if((status = gprtSetTrailerMode(dev,dev->cpuPortNum, en)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrailerMode return Failed\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/VlanSetup/hgVlan.c
@@ -0,0 +1,135 @@
+#include <Copyright.h>
+/********************************************************************************
+* hgVlan.c
+*
+* DESCRIPTION:
+*       Setup the VLAN table of QuaterDeck so that it can be used as a Home
+*        Gateway.
+*
+*
+* DEPENDENCIES:   None.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+
+static GT_STATUS sampleHomeGatewayVlan(GT_QD_DEV *dev,
+                               GT_LPORT numOfPorts,
+                       GT_LPORT cpuPort);
+
+/*
+ *  Get the required parameter from QuarterDeck driver.
+ *    Notes: This routine should be called after QuarterDeck Driver has been initialized.
+ *        (Refer to Initialization Sample)
+*/
+
+GT_STATUS sampleVlanSetup(GT_QD_DEV *dev)
+{
+    sampleHomeGatewayVlan(dev,dev->numOfPorts, dev->cpuPortNum);
+
+    return GT_OK;
+}
+
+
+/*
+ *    WAN Port (Port 0) and CPU Port (Port 5) are in VLAN 1 and
+ *    all ports (including CPU Port) except WAN Port are in VLAN 2.
+ *    1) Set PVID for each port. (CPU port has PVID 2, which is the same as LAN)
+ *    2) Set Port Based VLAN Map for each port. (CPU port's VLAN Map is set for all LAN ports)
+ *  Notes:
+ *        1) Trailer Mode
+ *            When Ethernet Device, which is directly connected to CPU port, sends out a packet
+ *            to WAN, DPV in Trailer Tag should have WAN port bit set (bit 0 in this case), and
+ *            to LAN, Trailer Tag should be set to 0.
+ *            Restriction : Only one group of VLAN can have multiple ports.
+ *        2) Header Mode
+ *            When Ethernet Device, which is directly connected to CPU port, sends out a packet
+ *            to WAN, VlanTable in Header Tag should have WAN ports bits set (bit 0 in this case), and
+ *            to LAN, VlanTable in Header Tag should have LAN ports bits set (bit 1~4 and 6 in this case)
+*/
+static GT_STATUS sampleHomeGatewayVlan(GT_QD_DEV *dev,GT_LPORT numOfPorts, GT_LPORT cpuPort)
+{
+    GT_STATUS status;
+    GT_LPORT index,port,portToSet;
+    GT_LPORT portList[MAX_SWITCH_PORTS];
+
+    /*
+     *  set PVID for each port.
+     *    the first port(port 0, WAN) has default VID 2 and all others has 1.
+     */
+
+    if((status = gvlnSetPortVid(dev,0,2)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetPortVid returned fail.\n"));
+        return status;
+    }
+
+    for (port=1; port<numOfPorts; port++)
+    {
+        if((status = gvlnSetPortVid(dev,port,1)) != GT_OK)
+        {
+            MSG_PRINT(("gprtSetPortVid returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*
+     *  set Port VLAN Mapping.
+     *    port 0 (WAN) and cpu port are in a vlan 2.
+     *    And all the rest ports (LAN) and cpu port are in a vlan 1.
+     */
+
+    /* port 0 : set cpuPort only */
+    portList[0] = cpuPort;
+    if((status = gvlnSetPortVlanPorts(dev,0,portList,1)) != GT_OK)
+    {
+        MSG_PRINT(("gvlnSetPortVlanPorts returned fail.\n"));
+        return status;
+    }
+
+    /* set all ports except port 0 and itself */
+    for (portToSet=1; portToSet<numOfPorts; portToSet++)
+    {
+        /* port 0 and cpuPort will be taken cared seperately. */
+        if (portToSet == cpuPort)
+        {
+            continue;
+        }
+
+        index = 0;
+        for (port=1; port<numOfPorts; port++)
+        {
+            if (port == portToSet)
+            {
+                continue;
+            }
+            portList[index++] = port;
+        }
+
+        if((status = gvlnSetPortVlanPorts(dev,(GT_U8)portToSet,portList,index)) != GT_OK)
+        {
+            MSG_PRINT(("gvlnSetPortVlanPorts returned fail.\n"));
+            return status;
+        }
+    }
+
+    /* cpuPort : set all port except cpuPort and WAN port */
+    index = 0;
+    for (port=1; port<numOfPorts; port++)
+    {
+        if (port == cpuPort)
+        {
+            continue;
+        }
+        portList[index++] = port;
+    }
+
+    if((status = gvlnSetPortVlanPorts(dev,cpuPort,portList,index)) != GT_OK)
+    {
+        MSG_PRINT(("gvlnSetPortVlanPorts returned fail.\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/VlanSetup/readme.txt
@@ -0,0 +1,31 @@
+========================================================================
+		VLAN Setup for Home Gateway Solution
+========================================================================
+
+Vlan Setup Program will show how to setup the QuaterDeck's vlan
+for Home Gateway.
+In the sample program, Port 0 (WAN port) and CPU Port (Port 5) are in
+a VLAN 2, and Port 1 ~ Port 6 (including CPU Port) are in a VLAN 1.
+
+VLAN MAP setting for the given sample program is:
+Port 0 (WAN) = 0x20,
+Port 1 (LAN) = 0x7C,
+Port 2 (LAN) = 0x7A,
+Port 3 (LAN) = 0x76,
+Port 4 (LAN) = 0x6E,
+Port 5 (CPU) = 0x5E, and
+Port 6 (LAN) = 0x3E
+
+Notes:
+	1) Trailer Mode is enabled:
+		When Ethernet Device, which is directly connected to CPU port, sends out a packet
+		to WAN, DPV in Trailer Tag should have WAN port bit set (bit 0 in this case), and
+		to LAN, Trailer Tag should be set to 0.
+		Restriction : Only one group of VLANs can have multiple ports.
+	2) Header Mode is enabled:
+		When Ethernet Device, which is directly connected to CPU port, sends out a packet
+		to WAN, VlanTable in Header Tag should have WAN ports bits set (bit 0 in this case), and
+		to LAN, VlanTable in Header Tag should have LAN ports bits set (bit 1~4 and 6 in this case)
+
+hgVlan.c
+	sampleHGVlanSetup is the main function for the Home Gateway setup.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/makefile
@@ -0,0 +1,53 @@
+# makefile - build main object file
+#
+# modification history
+# --------------------
+# 04-15-02,mj	created
+#
+#######################################################################
+
+DEMONAME = sample
+WORK_TO_DO = $(DEMONAME).o
+
+exe : $(WORK_TO_DO)
+
+# Include common variable definitions
+include $(DSDT_TOOL_DIR)\make.defs
+
+.PHONY : exe
+
+QDLIB = $(LIB_DIR)/$(DSDT_PROJ_NAME).o
+
+OBJDIRS	= $(subst /,\,$(dir $(QDLIB)))
+
+CSOURCES = FlowControl/flowCtrl.c Initialization/osSem.c Initialization/ev96122mii.c \
+           Initialization/qdSim.c Initialization/msApiInit.c  \
+	   MACAddress/macAddr.c QoSSetup/qos.c VlanSetup/hgVlan.c Interrupt/qdInt.c \
+		   Trailer/trailer.c RMON/rmon.c 802.1Q/802_1q.c Header/header.c \
+		   CableTest/cableTest.c CableTest/advCableTest.c PortMonitor/portMonitor.c MultiDevice/msApiInit.c \
+			CrossChipTrunk/crossChipTrunk.c MinimizeCPUTraffic\minimizeCPUTraffic.c	\
+			PktGen/phyPktGenSample.c PIRL/pirl.c PIRL/pirl2.c ptp/ptp.c
+
+EXTRA_INCLUDE = -I./Include -I./Initialization
+COBJECTS  	= $(CSOURCES:.c=.o)
+AOBJECTS  	= $(ASOURCES:.s=.o)
+ifeq ($(OBJECTS),)
+OBJECTS  	= $(COBJECTS) $(AOBJECTS)
+endif
+
+OBJECTS_MS= $(subst /,\,$(OBJECTS))
+
+$(DEMONAME).o : $(OBJECTS) $(QDLIB)
+	$(LD) $(LDFLAGS) -Map $(DEMONAME).map -o $(DEMONAME).o $(OBJECTS) $(QDLIB)
+
+$(OBJECTS) : %.o : %.c
+.c.o :
+	$(CC) $(CFLAGS) $(EXTRA_DEFINE) $(EXTRA_INCLUDE) $(ADDED_CFLAGS) -c $< -o $@
+
+.PHONY : clean
+clean :
+	@for %x in ($(OBJECTS_MS)) do \
+		$(RM) %x
+	$(RM) $(DEMONAME).*
+
+#end of file
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/tcam/readme.txt
@@ -0,0 +1,7 @@
+==================================================================
+                TCAM (Ternary Content Addressable Memory) Setup
+==================================================================
+
+88E3520 device family Switch Devices support TCAM.
+
+This sample shows how to use TCAM APIs.
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/sample/tcam/tcam.c
@@ -0,0 +1,408 @@
+#include <Copyright.h>
+/********************************************************************************
+* tcam.c
+*
+* DESCRIPTION:
+*      iHow to use TCAM API functions
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+#include "msSample.h"
+#include "gtHwCntl.h"
+
+static void testDisplayStatus(GT_STATUS status)
+{
+    switch(status)
+    {
+        case GT_OK :
+            MSG_PRINT(("Passed.\n"));
+            break;
+        case GT_FAIL :
+            MSG_PRINT(("Failed.\n"));
+            break;
+        case GT_BAD_PARAM :
+            MSG_PRINT(("Bad Parameter.\n"));
+            break;
+        case GT_NOT_SUPPORTED :
+            MSG_PRINT(("Not Supported.\n"));
+            break;
+        case GT_NOT_FOUND :
+            MSG_PRINT(("Not Found.\n"));
+            break;
+        case GT_NO_MORE :
+            MSG_PRINT(("No more Item.\n"));
+            break;
+        case GT_NO_SUCH :
+            MSG_PRINT(("No Such Item.\n"));
+            break;
+        default:
+            MSG_PRINT(("Failed.\n"));
+            break;
+    }
+}
+
+/* sample TCAM */
+void getTcamFrameHd(GT_U8 destAddr[], GT_U8 srcAddr[], GT_U16 *tag,
+        GT_U16 *pri, GT_U16 *vid, GT_U16 *ethType, GT_TCAM_FRM_HD *tcamHrData)
+{
+  MSG_PRINT(("Get TCAM Frame header.\n"));
+
+  memcpy(destAddr, tcamHrData->paraFrmHd.destAddr, 6);
+  memcpy(srcAddr, tcamHrData->paraFrmHd.srcAddr, 6);
+  *tag = tcamHrData->paraFrmHd.tag;
+  *pri = (tcamHrData->paraFrmHd.priVid>>12)&0xf;
+  *vid = tcamHrData->paraFrmHd.priVid&0xfff;
+  *ethType = tcamHrData->paraFrmHd.ethType;
+}
+
+void setTcamFrameHd(GT_U8 destAddr[], GT_U8 srcAddr[], GT_U16 tag,
+GT_U16 pri, GT_U16 vid, GT_U16 ethType, GT_TCAM_FRM_HD *tcamHrData)
+{
+  MSG_PRINT(("Set TCAM Frame header.\n"));
+
+  memcpy(tcamHrData->paraFrmHd.destAddr, destAddr, 6);
+  memcpy(tcamHrData->paraFrmHd.srcAddr, srcAddr, 6);
+  tcamHrData->paraFrmHd.tag = tag;
+  tcamHrData->paraFrmHd.priVid = (pri<<12)|(vid&0xfff);
+  tcamHrData->paraFrmHd.ethType = ethType;
+}
+
+static void displayTcamFrameHd(GT_TCAM_FRM_HD *tcamHrData)
+{
+  MSG_PRINT(("TCAM Frame header.\n"));
+
+  MSG_PRINT(("Dest address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+  tcamHrData->paraFrmHd.destAddr[0], tcamHrData->paraFrmHd.destAddr[1],
+  tcamHrData->paraFrmHd.destAddr[2], tcamHrData->paraFrmHd.destAddr[3],
+  tcamHrData->paraFrmHd.destAddr[4], tcamHrData->paraFrmHd.destAddr[5]
+  ));
+  MSG_PRINT(("Src address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+  tcamHrData->paraFrmHd.srcAddr[0], tcamHrData->paraFrmHd.srcAddr[1],
+  tcamHrData->paraFrmHd.srcAddr[2], tcamHrData->paraFrmHd.srcAddr[3],
+  tcamHrData->paraFrmHd.srcAddr[4], tcamHrData->paraFrmHd.srcAddr[5]
+  ));
+  MSG_PRINT(("Tag: %x\n", tcamHrData->paraFrmHd.tag));
+  MSG_PRINT(("PRI: %x\n", (tcamHrData->paraFrmHd.priVid&0xf000)>>12));
+  MSG_PRINT(("VID: %x\n", tcamHrData->paraFrmHd.priVid&0xfff));
+  MSG_PRINT(("ether type: %x\n", tcamHrData->paraFrmHd.ethType));
+
+}
+
+/* show=0: no display.
+   show=1: display basic parameters.
+   show=2: display basic and data parameters.
+   show=4: display frame raw data.
+   show=0xf: display all parameters. */
+void displayTcamData(GT_TCAM_DATA *tcamData, int show)
+{
+  int i;
+  if(!show)
+    return;
+  MSG_PRINT(("TCAM data.\n"));
+
+#if 1
+  if(show&4)
+  {
+    MSG_PRINT(("\nFirst part of TCAM Frame\n"));
+    for(i=0; i<28; i++)
+    {
+      if(i%14==0)
+      MSG_PRINT(("\nframeOctet[%02d]: %04x ", i, tcamData->rawFrmData[0].frame0.frame[i]));
+      else
+      MSG_PRINT(("%04x ", tcamData->rawFrmData[0].frame0.frame[i]));
+    }
+    for(i=0; i<28; i++)
+    {
+      if(i%14==0)
+      MSG_PRINT(("\nframeOctet[%02d]: %04x ", i, tcamData->rawFrmData[0].frame1.frame[i]));
+      else
+      MSG_PRINT(("%04x ", tcamData->rawFrmData[0].frame1.frame[i]));
+    }
+    for(i=0; i<28; i++)
+    {
+      if(i%14==0)
+      MSG_PRINT(("\nframeOctet[%02d]: %04x ", i, tcamData->rawFrmData[0].frame2.frame[i]));
+      else
+      MSG_PRINT(("%04x ", tcamData->rawFrmData[0].frame2.frame[i]));
+    }
+    MSG_PRINT(("\nSecond part of TCAM Frame\n"));
+    for(i=0; i<28; i++)
+    {
+      if(i%14==0)
+      MSG_PRINT(("\nframeOctet[%02d]: %04x ", i, tcamData->rawFrmData[1].frame0.frame[i]));
+      else
+      MSG_PRINT(("%04x ", tcamData->rawFrmData[1].frame0.frame[i]));
+    }
+    for(i=0; i<28; i++)
+    {
+      if(i%14==0)
+      MSG_PRINT(("\nframeOctet[%02d]: %04x ", i, tcamData->rawFrmData[1].frame1.frame[i]));
+      else
+      MSG_PRINT(("%04x ", tcamData->rawFrmData[1].frame1.frame[i]));
+    }
+    for(i=0; i<28; i++)
+    {
+      if(i%14==0)
+      MSG_PRINT(("\nframeOctet[%02d]: %04x ", i, tcamData->rawFrmData[1].frame2.frame[i]));
+      else
+      MSG_PRINT(("%04x ", tcamData->rawFrmData[1].frame2.frame[i]));
+    }
+  }
+#endif
+
+  if(show&3)
+  {
+  MSG_PRINT(("frameType: %x frameTypeMask: %x\n", tcamData->frameType, tcamData->frameTypeMask));
+  MSG_PRINT(("spv: %x spvMask: %x\n", tcamData->spv, tcamData->spvMask));
+  MSG_PRINT(("ppri: %x ppriMask: %x\n", tcamData->ppri, tcamData->ppriMask));
+  MSG_PRINT(("pvid: %x pvidMask: %x\n", tcamData->pvid, tcamData->pvidMask));
+
+  displayTcamFrameHd((GT_TCAM_FRM_HD *)tcamData->frameOctet);
+  }
+#if 1
+  if(show&2)
+  for(i=0; i<96; i++)
+    MSG_PRINT(("frameOctet[%d]: %x frameOctetMask[%d]: %x\n",  \
+             i, tcamData->frameOctet[i], i, tcamData->frameOctetMask[i]));
+#endif
+
+  if(show&3)
+  {
+  MSG_PRINT(("continu: %x\n", tcamData->continu));
+  MSG_PRINT(("interrupt: %x\n", tcamData->interrupt));
+  MSG_PRINT(("IncTcamCtr: %x\n", tcamData->IncTcamCtr));
+  MSG_PRINT(("vidData: %x\n", tcamData->vidData));
+  MSG_PRINT(("nextId: %x\n", tcamData->nextId));
+  MSG_PRINT(("qpriData: %x\n", tcamData->qpriData));
+  MSG_PRINT(("fpriData: %x\n", tcamData->fpriData));
+  MSG_PRINT(("qpriAvbData: %x\n", tcamData->qpriAvbData));
+  MSG_PRINT(("dpvData: %x\n", tcamData->dpvData));
+  MSG_PRINT(("factionData: %x\n", tcamData->factionData));
+  MSG_PRINT(("ldBalanceData: %x\n", tcamData->ldBalanceData));
+  MSG_PRINT(("debugPort: %x\n", tcamData->debugPort));
+  MSG_PRINT(("highHit: %x\n", tcamData->highHit));
+  MSG_PRINT(("lowHit: %x\n", tcamData->lowHit));
+  }
+}
+
+
+GT_U32 sampleTcam(GT_QD_DEV *dev)
+{
+  GT_STATUS status;
+  GT_U32 testResults = 0;
+  int i, j;
+
+  GT_TCAM_DATA     tcamData;
+  GT_U32        tcamPointer;
+#define NumberOfEntry 10
+#define  Is96Frame  1
+
+  MSG_PRINT(("TCAM API test \n"));
+
+  MSG_PRINT(("\n  TCAM API Flush all test \n"));
+  status = GT_OK;
+  if((status = gtcamFlushAll(dev)) != GT_OK)
+  {
+    MSG_PRINT(("gtcamFlushAll returned "));
+    testDisplayStatus(status);
+    return status;
+  }
+#if 1
+  for(i=0; i<NumberOfEntry; i+=2)
+  {
+    tcamPointer = i;
+    tcamData.is96Frame = Is96Frame;
+
+    MSG_PRINT(("gtcamReadTCAMData tcam entry: %d \n", (int)tcamPointer));
+    if((status = gtcamReadTCAMData(dev, tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamReadTCAMData returned \n"));
+        testDisplayStatus(status);
+        return status;
+    }
+    displayTcamData(&tcamData, 4);
+  }
+#endif
+#if 0
+  MSG_PRINT(("\n  TCAM API Purge and read test \n"));
+//    displayTcamData(&tcamData, 1);
+//  for(i=0; i<NumberOfEntry; i++)
+  for(i=0; i<3; i++)
+  {
+    tcamPointer = i;
+//    memset((char *)&tcamData, 0x55+i, sizeof(GT_TCAM_DATA));
+    tcamData.is96Frame = Is96Frame;
+    MSG_PRINT(("gtcamPurgyEntry entry: %d \n", (int)tcamPointer));
+
+    if((status = gtcamPurgyEntry(dev, tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamPurgyEntry returned "));
+        testDisplayStatus(status);
+        return status;
+    }
+
+    MSG_PRINT(("gtcamReadTCAMData tcam entry: %d \n", (int)tcamPointer));
+    if((status = gtcamReadTCAMData(dev, tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamReadTCAMData returned \n"));
+        testDisplayStatus(status);
+        return status;
+    }
+    displayTcamData(&tcamData, 1);
+  }
+#endif
+#if 1
+    MSG_PRINT(("TCAM API Load and read test \n"));
+    /* fill Tcam data */
+  for(i=4; i<NumberOfEntry+4; i+=2)
+  {
+    tcamData.frameType = 0x5;
+    tcamData.frameTypeMask = 0x5;
+    tcamData.spv = 0x7;
+    tcamData.spvMask = 0x7;
+    tcamData.ppri = 0x9;
+    tcamData.ppriMask = 0x9;
+    tcamData. pvid = 0xb;
+    tcamData.pvidMask = 0xb;
+
+    for(j=0; j<96; j++)
+    {
+      tcamData.frameOctet[j] = 10+j;
+      tcamData.frameOctetMask[j] = 80+j;
+    }
+
+#if 1
+    {
+      GT_U8 destAddr[6] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+      GT_U8 srcAddr[6] = {0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd};
+      GT_U16 tag = 0x3456;
+      GT_U16 pri = 0xa;
+      GT_U16 vid = 0x123;
+      GT_U16 ethType = 0x88f7;
+      GT_TCAM_FRM_HD *tcamHrData = (GT_TCAM_FRM_HD *)tcamData.frameOctet;
+
+      setTcamFrameHd(destAddr, srcAddr, tag, pri, vid, ethType, tcamHrData);
+    }
+#endif
+    tcamData.continu = 0x51;
+    tcamData.interrupt = 0x52;
+    tcamData.IncTcamCtr = 0x53;
+    tcamData.vidData = 0x55;
+    tcamData.nextId = 0x56;
+    tcamData.qpriData = 0x58;
+    tcamData.qpriAvbData = 0x5b;
+    tcamData.dpvData = 0x5d;
+    tcamData.factionData = 0x5f;
+    tcamData.ldBalanceData = 0x61;
+    tcamData.debugPort = 0x62;
+    tcamData.highHit = 0x63;
+    tcamData.lowHit = 0x64;
+
+    tcamPointer = i;
+    MSG_PRINT(("TCAM API Load test for entry %d\n", (int)tcamPointer));
+    if((status = gtcamLoadEntry(dev, tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamLoadEntry returned "));
+        testDisplayStatus(status);
+        return status;
+    }
+  }
+  for(i=0; i<NumberOfEntry; i+=2)
+  {
+    tcamPointer = i;
+    MSG_PRINT(("TCAM API read test for entry %d\n", (int)tcamPointer));
+    if((status = gtcamReadTCAMData(dev, tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamReadTCAMData returned "));
+        testDisplayStatus(status);
+        return status;
+    }
+    displayTcamData(&tcamData, 1);
+  }
+#endif
+
+#if 0
+    MSG_PRINT(("TCAM API Flush single and read test on entry %d \n", (int)tcamPointer));
+    if((status = gtcamFlushEntry(dev, tcamPointer)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamFlushEntry returned "));
+        testDisplayStatus(status);
+        return status;
+    }
+    if((status = gtcamReadTCAMData(dev, tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamReadTCAMData returned "));
+        testDisplayStatus(status);
+        return status;
+    }
+    displayTcamData(&tcamData, 7);
+
+#endif
+
+
+
+#if 0
+  MSG_PRINT(("\n  TCAM API Purge and read then next \n"));
+//    displayTcamData(&tcamData, 1);
+//  for(i=0; i<NumberOfEntry; i++)
+  for(i=0; i<3; i++)
+  {
+    tcamPointer = i;
+//    memset((char *)&tcamData, 0x55+i, sizeof(GT_TCAM_DATA));
+    tcamData.is96Frame = Is96Frame;
+    MSG_PRINT(("gtcamPurgyEntry entry: %d \n", (int)tcamPointer));
+
+    if((status = gtcamPurgyEntry(dev, tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamPurgyEntry returned "));
+        testDisplayStatus(status);
+        return status;
+    }
+
+    MSG_PRINT(("gtcamReadTCAMData tcam entry: %d \n", (int)tcamPointer));
+    if((status = gtcamReadTCAMData(dev, tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamReadTCAMData returned \n"));
+        testDisplayStatus(status);
+        return status;
+    }
+    displayTcamData(&tcamData, 1);
+  }
+#endif
+
+#if 1
+    tcamPointer = 0;
+    MSG_PRINT(("TCAM API Get next test start entry %d \n", (int)tcamPointer));
+
+    if((status = gtcamGetNextTCAMData(dev, &tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamGetNextTCAMData returned "));
+        testDisplayStatus(status);
+        return status;
+    }
+
+    MSG_PRINT(("TCAM API Get next test next entry %d \n", (int)tcamPointer));
+    displayTcamData(&tcamData, 3);
+
+    tcamPointer = 4;
+    MSG_PRINT(("TCAM API Get next test start entry %d \n", (int)tcamPointer));
+
+    if((status = gtcamGetNextTCAMData(dev, &tcamPointer, &tcamData)) != GT_OK)
+    {
+        MSG_PRINT(("gtcamGetNextTCAMData returned "));
+        testDisplayStatus(status);
+        return status;
+    }
+
+    MSG_PRINT(("TCAM API Get next test next entry %d \n", (int)tcamPointer));
+    displayTcamData(&tcamData, 3);
+
+#endif
+    MSG_PRINT(("Tcam API test done "));
+    testDisplayStatus(status);
+
+    return testResults;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/driver/gtDrvConfig.c
@@ -0,0 +1,963 @@
+#include <Copyright.h>
+/********************************************************************************
+* gtDrvConfig.h
+*
+* DESCRIPTION:
+*       Includes driver level configuration and initialization function.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 8 $
+*
+*******************************************************************************/
+
+#include <gtDrvSwRegs.h>
+#include <gtDrvConfig.h>
+#include <gtMiiSmiIf.h>
+#include <gtHwCntl.h>
+#include <gtVct.h>
+#include <msApiDefs.h>
+
+
+/*******************************************************************************
+* lport2port
+*
+* DESCRIPTION:
+*       This function converts logical port number to physical port number
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        port    - logical port number
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       physical port number
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_U8 lport2port
+(
+    IN GT_U16    portVec,
+    IN GT_LPORT     port
+)
+{
+    GT_U8    hwPort, tmpPort;
+
+    tmpPort = hwPort = 0;
+
+    while (portVec)
+    {
+        if(portVec & 0x1)
+        {
+            if((GT_LPORT)tmpPort == port)
+                break;
+            tmpPort++;
+        }
+        hwPort++;
+        portVec >>= 1;
+    }
+
+    if (!portVec)
+        hwPort = GT_INVALID_PORT;
+
+    return hwPort;
+}
+
+/*******************************************************************************
+* port2lport
+*
+* DESCRIPTION:
+*       This function converts physical port number to logical port number
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        port    - logical port number
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       physical port number
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_LPORT port2lport
+(
+    IN GT_U16    portVec,
+    IN GT_U8     hwPort
+)
+{
+    GT_U8        tmpPort,port;
+
+    port = 0;
+
+    if (hwPort == GT_INVALID_PORT)
+        return (GT_LPORT)hwPort;
+
+    if (!GT_IS_PORT_SET(portVec, hwPort))
+        return (GT_LPORT)GT_INVALID_PORT;
+
+    for (tmpPort = 0; tmpPort <= hwPort; tmpPort++)
+    {
+        if(portVec & 0x1)
+        {
+            port++;
+        }
+        portVec >>= 1;
+    }
+
+    return (GT_LPORT)port-1;
+}
+
+/*******************************************************************************
+* lportvec2portvec
+*
+* DESCRIPTION:
+*       This function converts logical port vector to physical port vector
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        lVec     - logical port vector
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       physical port vector
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_U32 lportvec2portvec
+(
+    IN GT_U16    portVec,
+    IN GT_U32     lVec
+)
+{
+    GT_U32    pVec, vec;
+
+    pVec = 0;
+    vec = 1;
+
+    while (portVec)
+    {
+        if(portVec & 0x1)
+        {
+            if(lVec & 0x1)
+            {
+                pVec |= vec;
+            }
+            lVec >>= 1;
+        }
+
+        vec <<= 1;
+        portVec >>= 1;
+    }
+
+    if(lVec)
+        return GT_INVALID_PORT_VEC;
+
+    return pVec;
+}
+
+/*******************************************************************************
+* portvec2lportvec
+*
+* DESCRIPTION:
+*       This function converts physical port vector to logical port vector
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        pVec     - physical port vector
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       logical port vector
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_U32 portvec2lportvec
+(
+    IN GT_U16    portVec,
+    IN GT_U32     pVec
+)
+{
+    GT_U32    lVec, vec;
+
+    lVec = 0;
+    vec = 1;
+
+    while (portVec)
+    {
+        if(portVec & 0x1)
+        {
+            if(pVec & 0x1)
+            {
+                lVec |= vec;
+            }
+            vec <<= 1;
+        }
+
+        pVec >>= 1;
+        portVec >>= 1;
+    }
+
+    return lVec;
+}
+
+/*******************************************************************************
+* lport2phy
+*
+* DESCRIPTION:
+*       This function converts logical port number to physical phy number.
+*
+* INPUTS:
+*        portVec - physical port list in vector
+*        port    - logical port number
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       physical port number
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_U8 lport2phy
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+)
+{
+    GT_U8    hwPort;
+
+    /* check if it's for SERDES */
+    if(dev->validSerdesVec & (1<<port))
+    {
+        hwPort = (GT_U8)port;
+    }
+    else
+    {
+        hwPort = GT_LPORT_2_PORT(port);
+    }
+
+    return hwPort;
+}
+
+
+/*******************************************************************************
+* driverConfig
+*
+* DESCRIPTION:
+*       This function initializes the driver level of the quarterDeck software.
+*
+* INPUTS:
+*        None.
+* OUTPUTS:
+*        None.
+* RETURNS:
+*       GT_OK               - on success, or
+*       GT_OUT_OF_CPU_MEM   - if failed to allocate CPU memory,
+*       GT_FAIL             - otherwise.
+*
+* COMMENTS:
+*       1.  This function should perform the following:
+*           -   Initialize the global switch configuration structure.
+*           -   Initialize Mii Interface
+*
+*******************************************************************************/
+GT_STATUS driverConfig
+(
+    IN GT_QD_DEV    *dev
+)
+{
+    GT_U16          deviceId;
+    GT_BOOL         highSmiDevAddr;
+
+
+    if(dev->accessMode == SMI_AUTO_SCAN_MODE)
+    {
+        /* Initialize the MII / SMI interface, search for the device */
+        if((deviceId = miiSmiIfInit(dev,&highSmiDevAddr)) == 0)
+        {
+            return GT_FAIL;
+        }
+
+        dev->baseRegAddr = (highSmiDevAddr)?0x10:0;
+    }
+    else
+    {
+        if((deviceId = miiSmiManualIfInit(dev,(GT_U32)dev->baseRegAddr)) == 0)
+        {
+            return GT_FAIL;
+        }
+    }
+
+    /* Init the device's config struct.             */
+    dev->deviceId       = deviceId >> 4;
+    dev->revision       = (GT_U8)deviceId & 0xF;
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* driverEnable
+*
+* DESCRIPTION:
+*       This function enables the switch for full operation, after the driver
+*       Config function was called.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverEnable
+(
+    IN GT_QD_DEV    *dev
+)
+{
+    GT_UNUSED_PARAM(dev);
+    return GT_OK;
+}
+
+
+GT_STATUS driverGetSerdesPort(GT_QD_DEV *dev, GT_U8* hwPort)
+{
+    switch(dev->deviceId)
+    {
+        case GT_88E6122:
+            if ((*hwPort<3) || (*hwPort>6))
+            {
+                *hwPort = GT_INVALID_PORT;
+            }
+            else
+            {
+                *hwPort += 9;
+            }
+            break;
+        case GT_88E6131:
+        case GT_88E6108:
+            if ((*hwPort<4) || (*hwPort>7))
+            {
+                *hwPort = GT_INVALID_PORT;
+            }
+            else
+            {
+                *hwPort += 8;
+            }
+            break;
+        case GT_88E6123:
+        case GT_88E6140:
+        case GT_88E6161:
+        case GT_88E6165:
+        case GT_88E6172:
+        case GT_88E6176:
+        case GT_88E6240:
+        case GT_88E6352:
+
+            if ((*hwPort<4) || (*hwPort>5))
+            {
+                *hwPort = GT_INVALID_PORT;
+            }
+            else
+            {
+              *hwPort += 8;
+              if(!(IS_IN_DEV_GROUP(dev,DEV_88E6165_FAMILY)))
+                *hwPort = 0xF;
+            }
+            break;
+        default:
+            *hwPort = GT_INVALID_PORT;
+            break;
+    }
+    return GT_OK;
+}
+
+/*******************************************************************************
+* driverFindPhyID
+*
+* DESCRIPTION:
+*       This function get Phy ID from Phy register 2 and 3.
+*
+* INPUTS:
+*       hwPort    - port number where the Phy is connected
+*
+* OUTPUTS:
+*       phyId    - Phy ID
+*
+* RETURNS:
+*       GT_OK     - if found Marvell Phy,
+*       GT_FAIL - othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static GT_STATUS driverFindPhyID
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    OUT    GT_U32         *phyID
+)
+{
+    GT_U16 ouiMsb, ouiLsb;
+    GT_STATUS status;
+
+    if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Register.\n"));
+        return status;
+    }
+
+    if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Register.\n"));
+        return status;
+    }
+
+    if(ouiMsb != MARVELL_OUI_MSb)
+        return GT_FAIL;
+
+    *phyID = (GT_U32)ouiLsb;
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* driverIsPhyAttached
+*
+* DESCRIPTION:
+*       This function verifies Marvell Phy.
+*
+* INPUTS:
+*       hwPort    - port number where the Phy is connected
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       1 - if Marvell Phy exists
+*        0 - otherwise
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U32 driverIsPhyAttached
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort
+)
+{
+    GT_U32         phyId;
+
+    if(hwPort > dev->maxPhyNum)
+        return 0;
+
+    if(driverFindPhyID(dev,hwPort,&phyId) != GT_OK)
+    {
+        DBG_INFO(("cannot find Marvell Phy.\n"));
+        return 0;
+    }
+
+    return 1;
+}
+
+/*******************************************************************************
+* driverGetPhyID
+*
+* DESCRIPTION:
+*       This function reads and returns Phy ID (register 3) of Marvell Phy.
+*
+* INPUTS:
+*       hwPort    - port number where the Phy is connected
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       phyId - if Marvell Phy exists
+*        GT_INVALID_PORT      - otherwise
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U32 driverGetPhyID
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort
+)
+{
+    GT_U32         phyId;
+
+    if(hwPort > dev->maxPhyNum)
+        return GT_INVALID_PHY;
+
+    if(driverFindPhyID(dev,hwPort,&phyId) != GT_OK)
+    {
+        DBG_INFO(("cannot find Marvell Phy.\n"));
+        return GT_INVALID_PHY;
+    }
+
+    return phyId;
+}
+
+
+/*******************************************************************************
+* driverPagedAccessStart
+*
+* DESCRIPTION:
+*       This function stores page register and Auto Reg Selection mode if needed.
+*
+* INPUTS:
+*       hwPort     - port number where the Phy is connected
+*        pageType - type of the page registers
+*
+* OUTPUTS:
+*       autoOn    - GT_TRUE if Auto Reg Selection enabled, GT_FALSE otherwise.
+*        pageReg - Page Register Data
+*
+* RETURNS:
+*       GT_OK     - if success
+*       GT_FAIL - othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverPagedAccessStart
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    IN    GT_U8         pageType,
+    OUT    GT_BOOL         *autoOn,
+    OUT    GT_U16         *pageReg
+)
+{
+    GT_U16 data;
+    GT_STATUS status;
+
+    switch(pageType)
+    {
+        case GT_PHY_PAGE_WRITE_BACK:
+            break;
+        case GT_PHY_PAGE_DIS_AUTO1:    /* 88E1111 Type */
+            if((status= hwGetPhyRegField(dev,hwPort,27,9,1,&data)) != GT_OK)
+            {
+                DBG_INFO(("Not able to read Phy Register.\n"));
+                return status;
+            }
+
+            data ^= 0x1;    /* toggle bit 0 */
+            BIT_2_BOOL(data, *autoOn);
+
+            if (*autoOn) /* Auto On */
+            {
+                if((status= hwSetPhyRegField(dev,hwPort,27,9,1,data)) != GT_OK)
+                {
+                    DBG_INFO(("Not able to write Phy Register.\n"));
+                    return status;
+                }
+            }
+
+            break;
+        case GT_PHY_PAGE_DIS_AUTO2:    /* 88E1112 Type */
+            if((status= hwGetPhyRegField(dev,hwPort,22,15,1,&data)) != GT_OK)
+            {
+                DBG_INFO(("Not able to read Phy Register.\n"));
+                return status;
+            }
+
+            BIT_2_BOOL(data, *autoOn);
+            data ^= 0x1;    /* toggle bit 0 */
+
+            if (*autoOn) /* Auto On */
+            {
+                if((status= hwSetPhyRegField(dev,hwPort,22,15,1,data)) != GT_OK)
+                {
+                    DBG_INFO(("Not able to write Phy Register.\n"));
+                    return status;
+                }
+            }
+
+            break;
+
+        case GT_PHY_NO_PAGE:
+        default:
+            /* Nothing to do */
+            return GT_OK;
+    }
+
+
+    if((status= hwGetPhyRegField(dev,hwPort,22,0,8,pageReg)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Register.\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* driverPagedAccessStop
+*
+* DESCRIPTION:
+*       This function restores page register and Auto Reg Selection mode if needed.
+*
+* INPUTS:
+*       hwPort     - port number where the Phy is connected
+*        pageType - type of the page registers
+*       autoOn     - GT_TRUE if Auto Reg Selection enabled, GT_FALSE otherwise.
+*        pageReg  - Page Register Data
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK     - if success
+*       GT_FAIL - othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverPagedAccessStop
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    IN    GT_U8         pageType,
+    IN    GT_BOOL         autoOn,
+    IN    GT_U16         pageReg
+)
+{
+    GT_U16 data;
+    GT_STATUS status;
+
+    switch(pageType)
+    {
+        case GT_PHY_PAGE_WRITE_BACK:
+            break;
+        case GT_PHY_PAGE_DIS_AUTO1:    /* 88E1111 Type */
+            if (autoOn) /* Auto On */
+            {
+                data = 0;
+                if((status= hwSetPhyRegField(dev,hwPort,27,9,1,data)) != GT_OK)
+                {
+                    DBG_INFO(("Not able to write Phy Register.\n"));
+                    return status;
+                }
+            }
+
+            break;
+        case GT_PHY_PAGE_DIS_AUTO2:    /* 88E1112 Type */
+            if (autoOn) /* Auto On */
+            {
+                data = 1;
+                if((status= hwSetPhyRegField(dev,hwPort,22,15,1,data)) != GT_OK)
+                {
+                    DBG_INFO(("Not able to write Phy Register.\n"));
+                    return status;
+                }
+            }
+
+            break;
+
+        case GT_PHY_NO_PAGE:
+        default:
+            /* Nothing to do */
+            return GT_OK;
+    }
+
+
+    if((status= hwSetPhyRegField(dev,hwPort,22,0,8,pageReg)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Register.\n"));
+        return status;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* driverFindPhyInformation
+*
+* DESCRIPTION:
+*       This function gets information of Phy connected to the given port.
+*        PhyInfo structure should have valid Phy ID.
+*
+* INPUTS:
+*       hwPort    - port number where the Phy is connected
+*
+* OUTPUTS:
+*       phyId    - Phy ID
+*
+* RETURNS:
+*       GT_OK     - if found Marvell Phy,
+*       GT_FAIL - othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverFindPhyInformation
+(
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    OUT    GT_PHY_INFO     *phyInfo
+)
+{
+    GT_U32 phyId;
+    GT_U16 data;
+
+    phyId = phyInfo->phyId;
+
+    switch (phyId & PHY_MODEL_MASK)
+    {
+        case DEV_E3082:
+        case DEV_MELODY:
+                phyInfo->anyPage = 0xFFFFFFFF;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_COPPER;
+                phyInfo->vctType = GT_PHY_VCT_TYPE1;
+                phyInfo->exStatusType = 0;
+                if ((phyId & PHY_REV_MASK) < 9)
+                    phyInfo->dteType = GT_PHY_DTE_TYPE1;    /* need workaround */
+                else
+                    phyInfo->dteType = GT_PHY_DTE_TYPE5;
+
+                phyInfo->pktGenType = 0;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_NO_PAGE;
+                break;
+
+        case DEV_E104X:
+                phyInfo->anyPage = 0xFFFFFFFF;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_GIGABIT|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_EXTERNAL_LOOP;
+
+                phyInfo->dteType = 0;
+                if ((phyId & PHY_REV_MASK) < 3)
+                    phyInfo->flag &= ~GT_PHY_VCT_CAPABLE; /* VCT is not supported */
+                else if ((phyId & PHY_REV_MASK) == 3)
+                    phyInfo->vctType = GT_PHY_VCT_TYPE3;    /* Need workaround */
+                else
+                    phyInfo->vctType = GT_PHY_VCT_TYPE2;
+                phyInfo->exStatusType = 0;
+
+                phyInfo->pktGenType = 0;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_NO_PAGE;
+
+                break;
+
+        case DEV_E1111:
+                phyInfo->anyPage = 0xFFF1FE0C;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE;
+
+                phyInfo->vctType = GT_PHY_VCT_TYPE2;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE1;
+                if ((phyId & PHY_REV_MASK) < 2)
+                    phyInfo->dteType = GT_PHY_DTE_TYPE3;    /* Need workaround */
+                else
+                    phyInfo->dteType = GT_PHY_DTE_TYPE2;
+
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE1;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO1;
+                break;
+
+        case DEV_E1112:
+                phyInfo->anyPage = 0x1BC0780C;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_PKT_GENERATOR;
+
+                phyInfo->vctType = GT_PHY_VCT_TYPE4;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE2;
+                phyInfo->dteType = GT_PHY_DTE_TYPE4;
+
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO2;
+                break;
+
+        case DEV_E114X:
+                phyInfo->anyPage = 0x2FF1FE0C;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE;
+
+                phyInfo->vctType = GT_PHY_VCT_TYPE2;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE1;
+                if ((phyId & PHY_REV_MASK) < 4)
+                    phyInfo->dteType = GT_PHY_DTE_TYPE3;    /* Need workaround */
+                else
+                    phyInfo->dteType = GT_PHY_DTE_TYPE2;
+
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE1;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO1;
+
+                break;
+
+        case DEV_E1149:
+                phyInfo->anyPage = 0x2040FFFF;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_GIGABIT|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_PKT_GENERATOR;
+                phyInfo->vctType = GT_PHY_VCT_TYPE4;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE3;
+                phyInfo->dteType = GT_PHY_DTE_TYPE4;
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                break;
+
+        case DEV_G15LV:
+                if (dev->devName1 &DEV_88E6108)
+                {
+                    phyInfo->anyPage = 0x0000FFFF;
+                    phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                    GT_PHY_EX_CABLE_STATUS|
+                                    GT_PHY_GIGABIT|
+                                    GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                    GT_PHY_PKT_GENERATOR;
+                    phyInfo->vctType = GT_PHY_VCT_TYPE4;
+                    phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE3;
+                    phyInfo->dteType = GT_PHY_DTE_TYPE4;
+                    phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                    phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                    phyInfo->lineLoopType = 0;
+                    phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                    phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                }
+                else /* 88E6165 family */
+                {
+                    phyInfo->anyPage = 0x0000FFFF;
+                    phyInfo->flag = GT_PHY_ADV_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                    GT_PHY_EX_CABLE_STATUS|
+                                    GT_PHY_GIGABIT|
+                                    GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                    GT_PHY_PKT_GENERATOR;
+                    phyInfo->vctType = GT_PHY_ADV_VCT_TYPE2;
+                    phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE6;
+                    phyInfo->dteType = GT_PHY_DTE_TYPE4;
+                    phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                    phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                    phyInfo->lineLoopType = 0;
+                    phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                    phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                }
+                break;
+
+        case DEV_EC010:
+                phyInfo->anyPage = 0x2040780C;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP;
+                phyInfo->vctType = GT_PHY_VCT_TYPE2;
+                phyInfo->exStatusType = 0;
+                phyInfo->dteType = GT_PHY_DTE_TYPE3;    /* Need workaround */
+                phyInfo->pktGenType = 0;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                break;
+
+        case DEV_S15LV:
+                phyInfo->anyPage = 0xFFFFFFFF;
+                phyInfo->flag = GT_PHY_SERDES_CORE|GT_PHY_GIGABIT|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_PKT_GENERATOR;
+                phyInfo->vctType = 0;
+                phyInfo->exStatusType = 0;
+                phyInfo->dteType = 0;
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE3;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE3;
+                phyInfo->lineLoopType = GT_PHY_LINE_LB_TYPE4;
+                phyInfo->exLoopType = 0;
+                phyInfo->pageType = GT_PHY_NO_PAGE;
+                break;
+
+        case DEV_G65G:
+        case DEV_E1540:
+                phyInfo->anyPage = 0x0000FFFF;
+                phyInfo->flag = GT_PHY_ADV_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_GIGABIT|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_PKT_GENERATOR;
+                phyInfo->vctType = GT_PHY_ADV_VCT_TYPE2;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE6;
+                phyInfo->dteType = GT_PHY_DTE_TYPE4;
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                break;
+        default:
+            return GT_FAIL;
+    }
+
+    if (phyInfo->flag & GT_PHY_GIGABIT)
+    {
+        if(hwGetPhyRegField(dev,hwPort,15,12,4,&data) != GT_OK)
+        {
+            DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,15));
+               return GT_FAIL;
+        }
+
+        if(data & QD_GIGPHY_1000X_CAP)
+            phyInfo->flag |= GT_PHY_FIBER;
+
+        if(data & QD_GIGPHY_1000T_CAP)
+        {
+            phyInfo->flag |= GT_PHY_COPPER;
+        }
+        else
+        {
+            phyInfo->flag &= ~(GT_PHY_VCT_CAPABLE|GT_PHY_EX_CABLE_STATUS|GT_PHY_DTE_CAPABLE|GT_PHY_ADV_VCT_CAPABLE);
+        }
+    }
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/driver/gtDrvEvents.c
@@ -0,0 +1,94 @@
+#include <Copyright.h>
+/********************************************************************************
+* gtDrvEvents.c
+*
+* DESCRIPTION:
+*       This file includes function declarations for QuarterDeck interrupts
+*       configuration and handling.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*
+*******************************************************************************/
+
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtDrvEvents.h>
+
+/*******************************************************************************
+* drvEventsInit
+*
+* DESCRIPTION:
+*       This function initializes the driver's interrupt handling mechanism.
+*
+* INPUTS:
+*       intVecNum   - The interrupt vector the switch is connected to.
+*       isrFunc     - A pointer to the Interrupt Service Routine to be
+*                     connected to the given interrupt vector.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success,
+*       GT_FAIL - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS drvEventsInit
+(
+    IN  GT_QD_DEV       *dev,
+    IN GT_U32           intVecNum,
+    IN GT_VOIDFUNCPTR   isrFunc
+)
+{
+    GT_UNUSED_PARAM(dev);
+    GT_UNUSED_PARAM(intVecNum);
+    GT_UNUSED_PARAM(isrFunc);
+#if 0
+    return osInterruptConnect(intVecNum,isrFunc,0);
+#endif
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* eventQdSr
+*
+* DESCRIPTION:
+*       QuarterDeck interrupt service routine.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL eventQdSr
+(
+    IN  GT_QD_DEV* dev,
+    OUT GT_U16* intCause
+)
+{
+    GT_STATUS       retVal;         /* Function calls return value.     */
+
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,0,4,intCause);
+
+    if(retVal != GT_OK)
+        return GT_FALSE;
+
+    return (*intCause)?GT_TRUE:GT_FALSE;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/driver/gtHwCntl.c
@@ -0,0 +1,2931 @@
+#include <Copyright.h>
+/********************************************************************************
+* gtHwCntl.c
+*
+* DESCRIPTION:
+*       Functions declarations for Hw accessing quarterDeck phy, internal and
+*       global registers.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*
+*******************************************************************************/
+
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtMiiSmiIf.h>
+#include <gtSem.h>
+
+
+static GT_STATUS hwReadPPU(GT_QD_DEV *dev, GT_U16 *data);
+static GT_STATUS hwWritePPU(GT_QD_DEV *dev, GT_U16 data);
+static GT_STATUS coreReadPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+);
+static GT_STATUS coreWritePhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+);
+static GT_STATUS coreReadPagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
+);
+static GT_STATUS coreWritePagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
+);
+
+GT_STATUS phyRegReadPPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
+                        GT_U16* value);
+GT_STATUS phyRegWritePPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
+                       GT_U16 value);
+#ifndef GT_RMGMT_ACCESS
+static GT_STATUS phyReadGlobal2Reg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+);
+static GT_STATUS phyWriteGlobal2Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+);
+#endif
+
+
+/*******************************************************************************
+* portToSmiMapping
+*
+* DESCRIPTION:
+*       This function mapps port to smi address
+*
+* INPUTS:
+*        dev - device context
+*       portNum - Port number to read the register for.
+*        accessType - type of register (Phy, Port, or Global)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       smiAddr    - smi address.
+*
+*******************************************************************************/
+GT_U8 portToSmiMapping
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8    portNum,
+    IN GT_U32    accessType
+)
+{
+    GT_U8 smiAddr;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_8PORT_SWITCH))
+    {
+        switch(accessType)
+        {
+            case PHY_ACCESS:
+              if (dev->validPhyVec & (1<<portNum))
+                smiAddr = PHY_REGS_START_ADDR_8PORT + portNum;
+              else
+			  {
+                smiAddr = 0xFF;
+                if(IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+				{
+                  if (dev->validSerdesVec & (1<<portNum))
+                    smiAddr = PHY_REGS_START_ADDR_8PORT + portNum;
+				}
+			  }
+              break;
+            case PORT_ACCESS:
+                    if (dev->validPortVec & (1<<portNum))
+                        smiAddr = PORT_REGS_START_ADDR_8PORT + portNum;
+                    else
+                        smiAddr = 0xFF;
+                    break;
+            case GLOBAL_REG_ACCESS:
+                    smiAddr = GLOBAL_REGS_START_ADDR_8PORT;
+                    break;
+            case GLOBAL3_REG_ACCESS:
+                    smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 2;
+                    break;
+            default:
+                    smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 1;
+                    break;
+        }
+    }
+    else
+    {
+        smiAddr = dev->baseRegAddr;
+        switch(accessType)
+        {
+            case PHY_ACCESS:
+              if (dev->validPhyVec & (1<<portNum))
+                smiAddr += PHY_REGS_START_ADDR + portNum;
+              else
+			  {
+                smiAddr = 0xFF;
+                if(IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+				{
+                  if (dev->validSerdesVec & (1<<portNum))
+                    smiAddr += PHY_REGS_START_ADDR + portNum;
+				}
+			  }
+              break;
+            case PORT_ACCESS:
+                    if (dev->validPortVec & (1<<portNum))
+                        smiAddr += PORT_REGS_START_ADDR + portNum;
+                    else
+                        smiAddr = 0xFF;
+                    break;
+            case GLOBAL_REG_ACCESS:
+                    smiAddr += GLOBAL_REGS_START_ADDR;
+                    break;
+            default:
+                    /*  88EC0XX uses PORT_REGS_START_ADDR -1 */
+                    if(IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+                      smiAddr += PORT_REGS_START_ADDR - 1;
+                    else
+                      smiAddr += GLOBAL_REGS_START_ADDR - 1;
+                    break;
+        }
+    }
+    return smiAddr;
+}
+
+
+/****************************************************************************/
+/* Phy registers related functions.                                         */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadPhyReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port phy register.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = coreReadPhyReg(dev, portNum, regAddr, data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWritePhyReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port phy register.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = coreWritePhyReg(dev, portNum, regAddr, data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwGetPhyRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port phy register.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPhyRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = coreReadPhyReg(dev, portNum, regAddr, &tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    if (retVal != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+
+    DBG_INFO(("Read from phy(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwSetPhyRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port phy register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPhyRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = coreReadPhyReg(dev, portNum, regAddr, &tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+
+    retVal = coreWritePhyReg(dev, portNum, regAddr, tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwReadPagedPhyReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port phy register in page mode.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       pageNum - Page number of the register to be read.
+*       regAddr - The register's address.
+*        anyPage - Any Page register vector
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
+)
+{
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = coreReadPagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWritePagedPhyReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port phy register in page mode.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       pageNum - Page number of the register to be written.
+*       regAddr - The register's address.
+*        anyPage - Any Page register vector
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
+)
+{
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = coreWritePagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwGetPagedPhyRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port phy register
+*        in page mode.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       pageNum     - Page number of the register to be read.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*        anyPage     - Any Page register vector
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPagedPhyRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = coreReadPagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,&tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+
+    DBG_INFO(("Read from phy(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetPagedPhyRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port phy register
+*        in page mode
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       pageNum     - Page number of the register to be read.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*        anyPage     - Any Page register vector
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPagedPhyRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    if((retVal=coreReadPagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,&tmpData)) != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+    retVal = coreWritePagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwPhyReset
+*
+* DESCRIPTION:
+*       This function performs softreset and waits until reset completion.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       u16Data     - data should be written into Phy control register.
+*                      if this value is 0xFF, normal operation occcurs (read,
+*                      update, and write back.)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS hwPhyReset
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U8        portNum,
+    IN    GT_U16        u16Data
+)
+{
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U32 retryCount;
+    GT_BOOL    pd = GT_FALSE;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    if((retVal=coreReadPhyReg(dev,portNum,0,&tmpData))
+           != GT_OK)
+    {
+           DBG_INFO(("Reading Register failed\n"));
+        gtSemGive(dev,dev->multiAddrSem);
+           return retVal;
+    }
+
+    if (tmpData & 0x800)
+    {
+        pd = GT_TRUE;
+    }
+
+    if (u16Data != 0xFF)
+    {
+        tmpData = u16Data;
+    }
+
+    /* Set the desired bits to 0. */
+    if (pd)
+    {
+        tmpData |= 0x800;
+    }
+    else
+    {
+        tmpData |= 0x8000;
+    }
+
+    if((retVal=coreWritePhyReg(dev,portNum,0,tmpData))
+        != GT_OK)
+    {
+        DBG_INFO(("Writing to register failed\n"));
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    if (pd)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return GT_OK;
+    }
+
+    for (retryCount = 0x1000; retryCount > 0; retryCount--)
+    {
+        if((retVal=coreReadPhyReg(dev,portNum,0,&tmpData)) != GT_OK)
+        {
+            DBG_INFO(("Reading register failed\n"));
+            gtSemGive(dev,dev->multiAddrSem);
+            return retVal;
+        }
+        if ((tmpData & 0x8000) == 0)
+            break;
+    }
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    if (retryCount == 0)
+    {
+        DBG_INFO(("Reset bit is not cleared\n"));
+        return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+/****************************************************************************/
+/* Per port registers related functions.                                    */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadPortReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port register.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPortReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    DBG_INFO(("Read from port(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+              portNum,phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWritePortReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port register.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePortReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8   phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    DBG_INFO(("Write to port(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+              portNum,phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwGetPortRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPortRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    if (retVal != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+    DBG_INFO(("Read from port(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetPortRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPortRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+    DBG_INFO(("Write to port(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwSetPortRegBits
+*
+* DESCRIPTION:
+*       This function writes to specified bits in a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       mask         - The bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
+*            and 0010b is written to bit[3:0]
+*
+*******************************************************************************/
+GT_STATUS hwSetPortRegBits
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   mask,
+    IN  GT_U16   data
+)
+{
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= (data & mask);
+    DBG_INFO(("Write to port(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("mask %d, data 0x%x.\n",mask,data));
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+
+/****************************************************************************/
+/* Global registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadGlobalReg
+*
+* DESCRIPTION:
+*       This function reads a switch's global register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobalReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    DBG_INFO(("read from global register: phyAddr 0x%x, regAddr 0x%x, ",
+              phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWriteGlobalReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobalReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8   phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+
+    DBG_INFO(("Write to global register: phyAddr 0x%x, regAddr 0x%x, ",
+              phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwGetGlobalRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobalRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+    DBG_INFO(("Read from global register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetGlobalRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobalRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+
+    DBG_INFO(("Write to global register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* hwReadGlobal2Reg
+*
+* DESCRIPTION:
+*       This function reads a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobal2Reg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    DBG_INFO(("read from global 2 register: phyAddr 0x%x, regAddr 0x%x, ", phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWriteGlobal2Reg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobal2Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8   phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    DBG_INFO(("Write to global 2 register: phyAddr 0x%x, regAddr 0x%x, ", phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwGetGlobal2RegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobal2RegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    if(retVal != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+    DBG_INFO(("Read from global 2 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetGlobal2RegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal2RegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+
+    DBG_INFO(("Write to global 2 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* hwSetGlobal2RegBits
+*
+* DESCRIPTION:
+*       This function writes to specified bits in a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       mask         - The bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
+*            and 0010b is written to bit[3:0]
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal2RegBits
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   mask,
+    IN  GT_U16   data
+)
+{
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= (data & mask);
+
+    DBG_INFO(("Write to global 2 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("mask %d, data 0x%x.\n",mask,data));
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwReadGlobal3Reg
+*
+* DESCRIPTION:
+*       This function reads a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobal3Reg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    DBG_INFO(("read from global 3 register: phyAddr 0x%x, regAddr 0x%x, ", phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWriteGlobal3Reg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobal3Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8   phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    DBG_INFO(("Write to global 3 register: phyAddr 0x%x, regAddr 0x%x, ", phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwGetGlobal3RegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobal3RegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    if(retVal != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+    DBG_INFO(("Read from global 3 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetGlobal3RegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal3RegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+
+    DBG_INFO(("Write to global 3 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* hwSetGlobal3RegBits
+*
+* DESCRIPTION:
+*       This function writes to specified bits in a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       mask         - The bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
+*            and 0010b is written to bit[3:0]
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal3RegBits
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   mask,
+    IN  GT_U16   data
+)
+{
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= (data & mask);
+
+    DBG_INFO(("Write to global 3 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("mask %d, data 0x%x.\n",mask,data));
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*********************************************************************************************/
+
+/*******************************************************************************
+* hwReadMiiReg
+*
+* DESCRIPTION:
+*       This function reads a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadMiiReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+)
+{
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+     gtSemGive(dev,dev->multiAddrSem);
+
+    DBG_INFO(("Read from phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
+              phyAddr,regAddr,*data));
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWriteMiiReg
+*
+* DESCRIPTION:
+*       This function writes a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteMiiReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    phyAddr,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    DBG_INFO(("Write to phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
+              phyAddr,regAddr,data));
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwReadPPU
+*
+* DESCRIPTION:
+*            This function reads PPU bit in Global Register
+*
+* INPUTS:
+*            None.
+*
+* OUTPUTS:
+*            data    - The read register's data.
+*
+* RETURNS:
+*            GT_OK on success, or
+*            GT_FAIL otherwise.
+*
+* COMMENTS:
+*            This function can be used to access PHY register connected to Gigabit
+*            Switch.
+*            Semaphore should be acquired before this function get called.
+*
+*******************************************************************************/
+static GT_STATUS hwReadPPU
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_U16    *data
+)
+{
+    GT_STATUS   retVal;
+    GT_U16        tmpData;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,4,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *data = (tmpData >> 14) & 0x1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* hwWritePPU
+*
+* DESCRIPTION:
+*            This function writes PPU bit in Global Register
+*
+* INPUTS:
+*            data - The value to write into PPU bit
+*
+* OUTPUTS:
+*            None.
+*
+* RETURNS:
+*            GT_OK on success, or
+*            GT_FAIL otherwise.
+*
+* COMMENTS:
+*            This function can be used to access PHY register connected to Gigabit
+*            Switch.
+*            Semaphore should be acquired before this function get called.
+*
+*******************************************************************************/
+static GT_STATUS hwWritePPU
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U16    data
+)
+{
+    GT_STATUS   retVal;
+    GT_U16        tmpData;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,4,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    if (data)
+        tmpData |= (0x1 << 14);
+    else
+        tmpData &= ~(0x1 << 14);
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,4,tmpData);
+
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* busy wait - till PPU is actually disabled */
+    if (data == 0) /* disable PPU */
+    {
+        gtDelay(250);
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+static GT_STATUS coreReadPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal, retPPU = 0;
+    GT_U16        orgPPU;
+    GT_BOOL        usePPU = GT_FALSE;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    orgPPU = 0;
+
+    if(IS_IN_DEV_GROUP(dev, DEV_PPU_READ_ONLY))
+    {
+        if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec & (1<<phyAddr)))
+        {
+            if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+
+            if(orgPPU)
+            {
+                /* Disable PPU so that External Phy can be accessible */
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+        else
+        usePPU = GT_TRUE;
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+    {
+        if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+        {
+            return retPPU;
+        }
+
+        if(orgPPU)
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
+                {
+                    if(dev->revision != 0)
+                        usePPU = GT_TRUE;
+                }
+                else
+                {
+                     usePPU = GT_TRUE;
+                }
+            }
+
+            /* Disable PPU so that External Phy can be accessible */
+            if (!usePPU)
+            {
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_PHY_ACCESS_NO_DIRECTLY))
+    {
+      usePPU = GT_TRUE;
+    }
+
+    if (usePPU)
+    {
+        retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
+    }
+    else
+    {
+        retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+    }
+
+    DBG_INFO(("Read from phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ", portNum,phyAddr,regAddr));
+
+    if(orgPPU && (!usePPU))
+    {
+      if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+      {
+        return retPPU;
+      }
+    }
+
+    return retVal;
+}
+
+
+static GT_STATUS coreWritePhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8           phyAddr;
+    GT_STATUS   retVal, retPPU;
+    GT_U16        orgPPU = 0;
+    GT_BOOL        usePPU = GT_FALSE;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec & (1<<phyAddr)))
+        {
+            if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+
+            if(orgPPU)
+            {
+                /* Disable PPU so that External Phy can be accessible */
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                        return retPPU;
+                }
+            }
+        }
+        else
+          usePPU = GT_TRUE;
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+    {
+        if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+        {
+            return retPPU;
+        }
+
+        if(orgPPU)
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
+                {
+                    if(dev->revision != 0)
+                        usePPU = GT_TRUE;
+                }
+                else
+                {
+                     usePPU = GT_TRUE;
+                }
+            }
+
+            /* Disable PPU so that External Phy can be accessible */
+            if (!usePPU)
+            {
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_PHY_ACCESS_NO_DIRECTLY))
+    {
+      usePPU = GT_TRUE;
+    }
+
+    DBG_INFO(("Write to phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+                portNum,phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    if (usePPU)
+    {
+        retVal = phyRegWritePPUEn (dev,phyAddr,regAddr,data);
+    }
+    else
+    {
+        retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+    }
+
+        if(orgPPU && (!usePPU))
+        {
+            if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+        }
+
+    return retVal;
+}
+
+
+static GT_STATUS coreReadPagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr,pageAddr;
+    GT_STATUS   retVal, retPPU;
+    GT_U16        orgPPU, tmpData, orgPage;
+    GT_BOOL        usePPU = GT_FALSE;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    orgPPU = 0;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec & (1<<phyAddr)))
+        {
+            if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+
+            if(orgPPU)
+            {
+                /* Disable PPU so that External Phy can be accessible */
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+        else
+             usePPU = GT_TRUE;
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+    {
+        if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+        {
+            return retPPU;
+        }
+
+        if(orgPPU)
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
+                {
+                    if(dev->revision != 0)
+                        usePPU = GT_TRUE;
+                }
+                else
+                {
+                     usePPU = GT_TRUE;
+                }
+            }
+
+            /* Disable PPU so that External Phy can be accessible */
+            if (!usePPU)
+            {
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+    }
+
+    if(anyPage & (1 << regAddr))
+    {
+        if (usePPU)
+        {
+            retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
+        }
+        else
+        {
+            retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+        }
+        DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
+                    portNum,phyAddr,pageNum,regAddr));
+    }
+    else
+    {
+        pageAddr = GT_GET_PAGE_ADDR(regAddr);
+
+        if (usePPU)
+        {
+            retVal = phyRegReadPPUEn (dev,phyAddr,pageAddr,&orgPage);
+        }
+        else
+        {
+            retVal = miiSmiIfReadRegister(dev,phyAddr,pageAddr,&orgPage);
+        }
+
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("Reading page register failed\n"));
+            return retVal;
+        }
+
+        if(pageAddr == 22)
+            tmpData = orgPage & 0xFF00;
+        else
+            tmpData = orgPage & 0xFFC0;
+        tmpData |= pageNum;
+
+        if (usePPU)
+        {
+            if((retVal = phyRegWritePPUEn(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
+            {
+                retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
+
+                DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
+                            portNum,phyAddr,pageNum,regAddr));
+            }
+        }
+        else
+        {
+            if((retVal = miiSmiIfWriteRegister(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
+            {
+                retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+                DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
+                            portNum,phyAddr,pageNum,regAddr));
+            }
+        }
+    }
+
+        if(orgPPU && (!usePPU))
+        {
+            if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+        }
+
+    return retVal;
+
+}
+
+
+static GT_STATUS coreWritePagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
+)
+{
+    GT_U8           phyAddr,pageAddr;
+    GT_STATUS   retVal, retPPU;
+    GT_U16        orgPPU, tmpData, orgPage;
+    GT_BOOL        usePPU = GT_FALSE;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    orgPPU = 0;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec & (1<<phyAddr)))
+        {
+            if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+
+            if(orgPPU)
+            {
+                /* Disable PPU so that External Phy can be accessible */
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+        else
+             usePPU = GT_TRUE;
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+    {
+        if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+        {
+            return retPPU;
+        }
+
+        if(orgPPU)
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
+                {
+                    if(dev->revision != 0)
+                        usePPU = GT_TRUE;
+                }
+                else
+                {
+                     usePPU = GT_TRUE;
+                }
+            }
+
+            /* Disable PPU so that External Phy can be accessible */
+            if (!usePPU)
+            {
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+    }
+
+    DBG_INFO(("Write to phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
+                portNum,phyAddr,pageNum,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    if(anyPage & (1 << regAddr))
+    {
+        if (usePPU)
+        {
+            retVal = phyRegWritePPUEn (dev,phyAddr,regAddr,data);
+        }
+        else
+        {
+            retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+        }
+    }
+    else
+    {
+        pageAddr = GT_GET_PAGE_ADDR(regAddr);
+
+        if (usePPU)
+        {
+            retVal = phyRegReadPPUEn (dev,phyAddr,pageAddr,&orgPage);
+        }
+        else
+        {
+            retVal = miiSmiIfReadRegister(dev,phyAddr,pageAddr,&orgPage);
+        }
+
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("Reading page register failed\n"));
+            return retVal;
+        }
+
+        if(pageAddr == 22)
+            tmpData = orgPage & 0xFF00;
+        else
+            tmpData = orgPage & 0xFFC0;
+        tmpData |= pageNum;
+
+        if (usePPU)
+        {
+            if((retVal = phyRegWritePPUEn(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
+            {
+                retVal = phyRegWritePPUEn(dev,phyAddr,regAddr,data);
+            }
+        }
+        else
+        {
+            if((retVal = miiSmiIfWriteRegister(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
+            {
+                retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+            }
+        }
+    }
+
+        if(orgPPU && (!usePPU))
+        {
+            if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+        }
+
+    return retVal;
+}
+
+
+/*****************************************************************************
+* phyRegReadPPUEn
+*
+* DESCRIPTION:
+*       This function reads phy register data when PPU is enabled.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The storage where register date to be saved.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS phyRegReadPPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
+                        unsigned short* value)
+#ifdef GT_RMGMT_ACCESS
+{
+  GT_U16 smiReg;
+  GT_STATUS   retVal;
+
+  HW_DEV_REG_ACCESS regAccess;
+
+  DBG_INFO(("Read Phy register while PPU Enabled\n"));
+
+  regAccess.entries = 4;
+
+  regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[0].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[0].data = 15;
+  smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) | (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+  regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[1].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[1].data = smiReg;
+
+  regAccess.rw_reg_list[2].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[2].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[2].data = 15;
+
+  regAccess.rw_reg_list[3].cmd = HW_REG_READ;
+  regAccess.rw_reg_list[3].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[3].reg = QD_REG_SMI_PHY_DATA;
+  regAccess.rw_reg_list[3].data = 0;
+  retVal = hwAccessMultiRegs(dev, &regAccess);
+  if(retVal != GT_OK)
+  {
+    return retVal;
+  }
+  *value = (unsigned short)regAccess.rw_reg_list[3].data;
+
+  return GT_OK;
+}
+#else
+{
+    volatile unsigned int timeOut; /* in 100MS units */
+    volatile int i;
+    GT_U16 smiReg;
+
+    DBG_INFO(("Read Phy register while PPU Enabled\n"));
+
+    /* first check that it is not busy */
+    if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+    {
+        DBG_INFO(("Reading Phy register Failed\n"));
+        return GT_FAIL;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+
+    if(smiReg & QD_SMI_BUSY)
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+        do
+        {
+            if(timeOut-- < 1 )
+            {
+                DBG_INFO(("Reading Phy register Timed Out\n"));
+                return GT_FAIL;
+            }
+            if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+            {
+                DBG_INFO(("Reading Phy register Failed\n"));
+                return GT_FAIL;
+            }
+        } while (smiReg & QD_SMI_BUSY);
+    }
+
+    smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) |
+            (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+    if(phyWriteGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, smiReg) != GT_OK)
+    {
+        return GT_FAIL;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+    if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+    {
+        return GT_FAIL;
+    }
+
+    if(smiReg & QD_SMI_BUSY)
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+        do
+        {
+            if(timeOut-- < 1 )
+            {
+                DBG_INFO(("Reading Phy register Timed Out\n"));
+                return GT_FALSE;
+            }
+            if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+            {
+                DBG_INFO(("Reading Phy register Failed\n"));
+                return GT_FAIL;
+            }
+        } while (smiReg & QD_SMI_BUSY);
+    }
+    if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_DATA, &smiReg) != GT_OK)
+    {
+        DBG_INFO(("Reading Phy register Failed\n"));
+        return GT_FAIL;
+    }
+    *value = (unsigned short)smiReg;
+
+    return GT_OK;
+}
+#endif
+
+/*****************************************************************************
+* phyRegWritePPUEn
+*
+* DESCRIPTION:
+*       This function writes data to a phy register when PPU is enabled.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The data to be written into the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+
+GT_STATUS phyRegWritePPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
+                       unsigned short value)
+#ifdef GT_RMGMT_ACCESS
+{
+  GT_U16 smiReg;
+  GT_STATUS   retVal;
+
+  HW_DEV_REG_ACCESS regAccess;
+
+  DBG_INFO(("Write Phy register while PPU Enabled\n"));
+
+  regAccess.entries = 3;
+
+  regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[0].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[0].data = 15;
+
+  regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[1].reg = QD_REG_SMI_PHY_DATA;
+  regAccess.rw_reg_list[1].data = value;
+
+  smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) | (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+  regAccess.rw_reg_list[2].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[2].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[2].data = smiReg;
+
+  retVal = hwAccessMultiRegs(dev, &regAccess);
+  if(retVal != GT_OK)
+  {
+    return retVal;
+  }
+
+  return GT_OK;
+}
+#else
+{
+    volatile unsigned int timeOut; /* in 100MS units */
+    volatile int i;
+    GT_U16 smiReg;
+
+    DBG_INFO(("Writing Phy register while PPU Enabled\n"));
+
+    /* first check that it is not busy */
+    if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+    {
+        DBG_INFO(("Reading Phy register Failed\n"));
+        return GT_FAIL;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+
+
+    if(smiReg & QD_SMI_BUSY)
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+        do
+        {
+            if(timeOut-- < 1 )
+            {
+                DBG_INFO(("Writing Phy register Timed Out\n"));
+                return GT_FALSE;
+            }
+            if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+            {
+                DBG_INFO(("Writing Phy register Failed\n"));
+                return GT_FAIL;
+            }
+        } while (smiReg & QD_SMI_BUSY);
+    }
+
+    if(phyWriteGlobal2Reg(dev,QD_REG_SMI_PHY_DATA, value) != GT_OK)
+    {
+        DBG_INFO(("Writing Phy Data register Failed\n"));
+        return GT_FAIL;
+    }
+    smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) |
+            (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+    if(phyWriteGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, smiReg) != GT_OK)
+    {
+        DBG_INFO(("Writing Phy Command register Failed\n"));
+        return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+static GT_STATUS phyReadGlobal2Reg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+    DBG_INFO(("read from global 2 register: phyAddr 0x%x, regAddr 0x%x, ",
+              phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
+    return retVal;
+}
+
+
+static GT_STATUS phyWriteGlobal2Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8   phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    return retVal;
+}
+#endif
+
+#ifdef GT_RMGMT_ACCESS
+/*******************************************************************************
+* hwAccessMultiRegs
+*
+* DESCRIPTION:
+*       This function accesses switch's registers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1
+*     addr - SMI Address
+*     reg  - Register offset
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwAccessMultiRegs
+(
+    IN GT_QD_DEV *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+)
+{
+  GT_STATUS   retVal;
+
+  gtSemTake(dev,dev->hwAccessRegsSem,OS_WAIT_FOREVER);
+
+  retVal = qdAccessRegs(dev, regList);
+
+  gtSemGive(dev,dev->hwAccessRegsSem);
+
+  return retVal;
+}
+#endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/driver/makefile
@@ -0,0 +1,33 @@
+# Source files in this directory
+TARGET =
+CSOURCES    = gtDrvConfig.c gtDrvEvents.c gtHwCntl.c
+ASOURCES    =
+
+# Include common variable definitions
+ifeq ($(OS_RUN),VXWORKS)
+include $(DSDT_TOOL_DIR)\make.defs
+endif
+ifeq ($(OS_RUN),WIN32)
+include $(DSDT_TOOL_DIR)\makewce.defs
+endif
+ifeq ($(OS_RUN),LINUX)
+include $(DSDT_TOOL_DIR)/makelnx.defs
+endif
+
+# Add in extra stuffs
+EXTRA_INCLUDE    +=
+EXTRA_DEFINE    +=
+ADDED_CFLAGS    +=
+
+# Include common build rules
+ifeq ($(OS_RUN),VXWORKS)
+include $(DSDT_TOOL_DIR)\make.rules
+endif
+ifeq ($(OS_RUN),WIN32)
+include $(DSDT_TOOL_DIR)\makewce.rules
+endif
+ifeq ($(OS_RUN),LINUX)
+include $(DSDT_TOOL_DIR)/makelnx.rules
+endif
+
+# end of file
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/makefile
@@ -0,0 +1,106 @@
+# makefile - build main object file
+#
+# modification history
+# --------------------
+# 04-15-02,mj	created
+#
+#######################################################################
+
+TARGET = $(DSDT_PROJ_NAME)
+
+ifeq ($(OS_RUN),VXWORKS)
+WORK_TO_DO = $(DSDT_PROJ_NAME).o
+
+# Include common variable definitions
+include $(DSDT_TOOL_DIR)\make.defs
+endif
+
+ifeq ($(OS_RUN),LINUX)
+WORK_TO_DO = $(DSDT_PROJ_NAME).o
+
+# Include common variable definitions
+include $(DSDT_TOOL_DIR)/makelnx.defs
+endif
+
+exe : $(WORK_TO_DO)
+
+.PHONY : exe
+
+vpath %.o    $(OBJDIR)
+vpath %.lib  $(OBJDIR)
+
+MAINDRV_PATH = $(SRC_BASE_PATH)
+MAD_ROOT = $(SRC_BASE_PATH)/../../phy
+
+SRC_OBJ_DIR = $(MAINDRV_PATH)/driver \
+               $(MAINDRV_PATH)/msapi \
+               $(MAINDRV_PATH)/platform
+
+OBJECTS_LIST = $(MAINDRV_PATH)/driver/$(OBJDIR)/driver.o \
+               $(MAINDRV_PATH)/msapi/$(OBJDIR)/msapi.o \
+               $(MAINDRV_PATH)/platform/$(OBJDIR)/platform.o
+
+OBJECTS = $(OBJECTS_LIST)
+
+OBJDIRS	= $(subst /,\,$(dir $(OBJECTS)))
+LIBDIRS	= $(subst /,\,$(LIB_DIR))
+
+OBJDIRS_/ = $(subst \,/,$(OBJDIRS))
+LIBDIRS_/ = $(subst \,/,$(LIBDIRS))
+
+ifeq ($(OS_RUN),VXWORKS)
+$(DSDT_PROJ_NAME).o : $(OBJECTS) $(MAD_OBJ)
+	@ $(ECHO) '------------'
+	@ $(ECHO) 'Building $@'
+	$(LD) $(LDFLAGS) -Map $(LIB_DIR)/$(DSDT_PROJ_NAME).map -o $(LIB_DIR)/$(DSDT_PROJ_NAME).o $(OBJECTS) $(MAD_OBJ)
+
+$(OBJECTS) : FORCE
+	@($(CD) $(subst /,\,$(dir $(@D)))) && $(MAKE)
+
+$(MAD_OBJ) : FORCE
+	$(MAKE) -C $(MAD_ROOT)/src
+
+endif
+
+ifeq ($(OS_RUN),LINUX)
+$(DSDT_PROJ_NAME).o : $(OBJECTS) $(MAD_OBJ)
+	@ $(ECHO) '------------'
+	@ $(ECHO) 'Building $@'
+	$(LD) $(LDFLAGS) -Map $(LIB_DIR)/$(DSDT_PROJ_NAME).map -o $(LIB_DIR)/$(DSDT_PROJ_NAME).o $(OBJECTS) $(MAD_OBJ)
+
+$(OBJECTS) : FORCE
+	@cd $(dir $(@D)); $(MAKE)
+
+$(MAD_OBJ) : FORCE
+	$(MAKE) -C $(MAD_ROOT)/src
+
+endif
+
+FORCE :
+
+.PHONY : clean
+ifeq ($(OS_RUN),VXWORKS)
+clean :
+	@for %x in ($(OBJDIRS)) do \
+	    @($(CD) %x..) && $(MAKE) clean
+	- ($(CD) $(LIBDIRS)) && $(RM) $(DSDT_PROJ_NAME).o
+	- ($(CD) $(LIBDIRS)) && $(RM) $(DSDT_PROJ_NAME).map
+	@if exist $(MAD_ROOT) $(MAKE) -C $(MAD_ROOT)/src clean
+endif
+
+ifeq ($(OS_RUN),LINUX)
+clean :
+	@for i in $(SRC_OBJ_DIR); do	\
+		cd $$i; $(RM) -r -f *.o *.map makedeps *obj; 	\
+	done
+#		cd $$i; $(RM) -f *.o *.map;
+	@for i in $(OBJDIRS_/); do	\
+		$(RM) -r -f  $$i;	\
+	done
+#		cd $$i..; $(MAKE) clean;
+	@cd $(LIB_DIR); $(RM) *.o
+	@cd $(LIB_DIR); $(RM) *.map
+	$(MAKE) -C $(MAD_ROOT)/src clean
+endif
+
+#end of file
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtAVB.c
@@ -0,0 +1,4018 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtAVB.c
+*
+* DESCRIPTION:
+*       API definitions for Precise Time Protocol logic
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+#ifdef CONFIG_AVB_FPGA
+
+#undef USE_SINGLE_READ
+
+#define AVB_SMI_ADDR        0xC
+
+#define QD_REG_PTP_INT_OFFSET        0
+#define QD_REG_PTP_INTEN_OFFSET        1
+#define QD_REG_PTP_FREQ_OFFSET        4
+#define QD_REG_PTP_PHASE_OFFSET        6
+#define QD_REG_PTP_CLK_CTRL_OFFSET    4
+#define QD_REG_PTP_CYCLE_INTERVAL_OFFSET        5
+#define QD_REG_PTP_CYCLE_ADJ_OFFSET                6
+#define QD_REG_PTP_PLL_CTRL_OFFSET    7
+#define QD_REG_PTP_CLK_SRC_OFFSET    0x9
+#define QD_REG_PTP_P9_MODE_OFFSET    0xA
+#define QD_REG_PTP_RESET_OFFSET        0xB
+
+#define GT_PTP_MERGE_32BIT(_high16,_low16)    (((_high16)<<16)|(_low16))
+#define GT_PTP_GET_HIGH16(_data)    ((_data) >> 16) & 0xFFFF
+#define GT_PTP_GET_LOW16(_data)        (_data) & 0xFFFF
+
+#if 0
+
+#define AVB_FPGA_READ_REG       gprtGetPhyReg
+#define AVB_FPGA_WRITE_REG      gprtSetPhyReg
+unsigned int (*avbFpgaReadReg)(void* unused, unsigned int port, unsigned int reg, unsigned int* data);
+unsigned int (*avbFpgaWriteReg)(void* unused, unsigned int port, unsigned int reg, unsigned int data);
+#else
+
+/* for RMGMT access  and can be controlled by <sw_apps -rmgmt 0/1> */
+unsigned int (*avbFpgaReadReg)(void* unused, unsigned int port, unsigned int reg, GT_U32* data)=gprtGetPhyReg;
+unsigned int (*avbFpgaWriteReg)(void* unused, unsigned int port, unsigned int reg, GT_U32 data)=gprtSetPhyReg;
+#define AVB_FPGA_READ_REG       avbFpgaReadReg
+#define AVB_FPGA_WRITE_REG      avbFpgaWriteReg
+
+#endif /* 0 */
+
+#endif
+
+#if 0
+#define GT_PTP_BUILD_TIME(_time1, _time2)    (((_time1) << 16) | (_time2))
+#define GT_PTP_L16_TIME(_time1)    ((_time1) & 0xFFFF)
+#define GT_PTP_H16_TIME(_time1)    (((_time1) >> 16) & 0xFFFF)
+#endif
+
+
+/****************************************************************************/
+/* PTP operation function declaration.                                    */
+/****************************************************************************/
+extern GT_STATUS ptpOperationPerform
+(
+    IN   GT_QD_DEV             *dev,
+    IN   GT_PTP_OPERATION    ptpOp,
+    INOUT GT_PTP_OP_DATA     *opData
+);
+
+
+/*******************************************************************************
+* gavbGetPriority
+*
+* DESCRIPTION:
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
+*
+* INPUTS:
+*         priType    - GT_AVB_PRI_TYPE
+*
+* OUTPUTS:
+*        pri    - priority
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetPriority
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    OUT GT_U32        *pri
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U16        mask, reg, bitPos;
+
+    DBG_INFO(("gavbGetPriority Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    switch (priType)
+    {
+        case GT_AVB_HI_FPRI:
+            mask = 0x7;
+            reg = 0;
+            bitPos = 12;
+            break;
+        case GT_AVB_HI_QPRI:
+            mask = 0x3;
+            reg = 0;
+            bitPos = 8;
+            break;
+        case GT_AVB_LO_FPRI:
+            mask = 0x7;
+            reg = 0;
+            bitPos = 4;
+            break;
+        case GT_AVB_LO_QPRI:
+            mask = 0x3;
+            reg = 0;
+            bitPos = 0;
+            break;
+        case GT_LEGACY_HI_FPRI:
+            mask = 0x7;
+            reg = 4;
+            bitPos = 12;
+            break;
+        case GT_LEGACY_HI_QPRI:
+            mask = 0x3;
+            reg = 4;
+            bitPos = 8;
+            break;
+        case GT_LEGACY_LO_FPRI:
+            mask = 0x7;
+            reg = 4;
+            bitPos = 4;
+            break;
+        case GT_LEGACY_LO_QPRI:
+            mask = 0x3;
+            reg = 4;
+            bitPos = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = reg;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    *pri = (GT_U32)(opData.ptpData >> bitPos) & mask;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbSetPriority
+*
+* DESCRIPTION:
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
+*
+* INPUTS:
+*         priType    - GT_AVB_PRI_TYPE
+*        pri    - priority
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetPriority
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    IN  GT_U32        pri
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U16        mask, reg, bitPos;
+
+    DBG_INFO(("gavbSetPriority Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    switch (priType)
+    {
+        case GT_AVB_HI_FPRI:
+            mask = 0x7;
+            reg = 0;
+            bitPos = 12;
+            break;
+        case GT_AVB_HI_QPRI:
+            mask = 0x3;
+            reg = 0;
+            bitPos = 8;
+            break;
+        case GT_AVB_LO_FPRI:
+            mask = 0x7;
+            reg = 0;
+            bitPos = 4;
+            break;
+        case GT_AVB_LO_QPRI:
+            mask = 0x3;
+            reg = 0;
+            bitPos = 0;
+            break;
+        case GT_LEGACY_HI_FPRI:
+            mask = 0x7;
+            reg = 4;
+            bitPos = 12;
+            break;
+        case GT_LEGACY_HI_QPRI:
+            mask = 0x3;
+            reg = 4;
+            bitPos = 8;
+            break;
+        case GT_LEGACY_LO_FPRI:
+            mask = 0x7;
+            reg = 4;
+            bitPos = 4;
+            break;
+        case GT_LEGACY_LO_QPRI:
+            mask = 0x3;
+            reg = 4;
+            bitPos = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    if (pri & (~mask))
+    {
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = reg;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(mask << bitPos);
+    opData.ptpData |= (pri << bitPos);
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gavbGetAVBHiLimit
+*
+* DESCRIPTION:
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs.
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override
+*        Table
+*
+* INPUTS:
+*         None
+*
+* OUTPUTS:
+*        limit    - Hi Frame Limit
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAVBHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *limit
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gavbGetAVBHiLimit Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 8;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *limit = (GT_U32)(opData.ptpData & 0x7FF);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbSetAVBHiLimit
+*
+* DESCRIPTION:
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs.
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override
+*        Table
+*
+* INPUTS:
+*        limit    - Hi Frame Limit
+*
+* OUTPUTS:
+*         None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAVBHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        limit
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gavbSetAVBHiLimit Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 8;
+    opData.ptpData = (GT_U16)limit;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbGetPtpExtClk
+*
+* DESCRIPTION:
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from
+*        an internal 125MHz clock based on the device's XTAL_IN input.
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
+*
+* INPUTS:
+*         None
+*
+* OUTPUTS:
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetPtpExtClk
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *extClk
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gavbGetPtpExtClk Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY_RECOVER_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0xB;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *extClk = (GT_U32)(opData.ptpData >> 15) & 0x1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gavbSetPtpExtClk
+*
+* DESCRIPTION:
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from
+*        an internal 125MHz clock based on the device's XTAL_IN input.
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
+*
+* INPUTS:
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
+*
+* OUTPUTS:
+*         None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetPtpExtClk
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        extClk
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gavbSetPtpExtClk Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY_RECOVER_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0xB;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    if(extClk)
+        opData.ptpData |= 0x8000;
+    else
+        opData.ptpData &= ~0x8000;
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbGetRecClkSel
+*
+* DESCRIPTION:
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*
+* INPUTS:
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
+*
+* OUTPUTS:
+*        clkSel    - recovered clock selection
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetRecClkSel
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    OUT GT_U32        *clkSel
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U16        bitPos;
+
+    DBG_INFO(("gavbGetRecClkSel Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY_RECOVER_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    switch (recClk)
+    {
+        case GT_PRIMARY_RECOVERED_CLOCK:
+            bitPos = 0;
+            break;
+        case GT_SECONDARY_RECOVERED_CLOCK:
+            bitPos = 4;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0xB;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *clkSel = (GT_U32)(opData.ptpData >> bitPos) & 0x7;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbSetRecClkSel
+*
+* DESCRIPTION:
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*
+* INPUTS:
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
+*        clkSel    - recovered clock selection (should be less than 8)
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetRecClkSel
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    IN  GT_U32        clkSel
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U16        bitPos;
+
+    DBG_INFO(("gavbSetRecClkSel Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY_RECOVER_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    if (clkSel > 0x7)
+        return GT_BAD_PARAM;
+
+    switch (recClk)
+    {
+        case GT_PRIMARY_RECOVERED_CLOCK:
+            bitPos = 0;
+            break;
+        case GT_SECONDARY_RECOVERED_CLOCK:
+            bitPos = 4;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0xB;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(0x7 << bitPos);
+    opData.ptpData |= clkSel << bitPos;
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbGetAvbOuiBytes
+*
+* DESCRIPTION:
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three
+*        AvbOui Bytes or the frame will be filtered.
+*
+* INPUTS:
+*         None
+*
+* OUTPUTS:
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbOuiBytes
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *obiBytes
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gavbGetAvbOuiBytes Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0xC;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    obiBytes[0] = (GT_U8)((opData.ptpData >> 8) & 0xFF);
+    obiBytes[1] = (GT_U8)(opData.ptpData & 0xFF);
+
+    opData.ptpAddr = 0xD;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    obiBytes[2] = (GT_U8)((opData.ptpData >> 8) & 0xFF);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gavbSetAvbOuiBytes
+*
+* DESCRIPTION:
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three
+*        AvbOui Bytes or the frame will be filtered.
+*
+* INPUTS:
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
+*
+* OUTPUTS:
+*         None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbOuiBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        *obiBytes
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gavbSetAvbOuiBytes Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0xC;
+
+    opData.ptpData = (obiBytes[0] << 8) | obiBytes[1];
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 0xD;
+    opData.ptpData = (obiBytes[2] << 8);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbGetAvbMode
+*
+* DESCRIPTION:
+*        Port's AVB Mode.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        mode    - GT_AVB_MODE type
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_AVB_MODE    *mode
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gavbGetAvbMode Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *mode = (GT_AVB_MODE)((opData.ptpData >> 14) & 0x3);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbSetAvbMode
+*
+* DESCRIPTION:
+*        Port's AVB Mode.
+*
+* INPUTS:
+*        port    - the logical port number
+*        mode    - GT_AVB_MODE type
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_AVB_MODE    mode
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gavbSetAvbMode Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(0x3 << 14);
+    opData.ptpData |= (mode << 14);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gavbGetAvbOverride
+*
+* DESCRIPTION:
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if
+*        the ingress portion is not.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbOverride
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gavbGetAvbOverride Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    *en = (opData.ptpData >> 13) & 0x1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbSetAvbOverride
+*
+* DESCRIPTION:
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if
+*        the ingress portion is not.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbOverride
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gavbSetAvbOverride Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    if (en)
+        opData.ptpData |= (0x1 << 13);
+    else
+        opData.ptpData &= ~(0x1 << 13);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbGetFilterBadAvb
+*
+* DESCRIPTION:
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetFilterBadAvb
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gavbGetFilterBadAvb Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    *en = (opData.ptpData >> 12) & 0x1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbSetFilterBadAvb
+*
+* DESCRIPTION:
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetFilterBadAvb
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gavbSetFilterBadAvb Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    if (en)
+        opData.ptpData |= (0x1 << 12);
+    else
+        opData.ptpData &= ~(0x1 << 12);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbGetAvbTunnel
+*
+* DESCRIPTION:
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbTunnel
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gavbGetAvbTunnel Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    *en = (opData.ptpData >> 11) & 0x1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbSetAvbTunnel
+*
+* DESCRIPTION:
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbTunnel
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("GT_STATUS gavbGetAvbTunnel Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    if (en)
+        opData.ptpData |= (0x1 << 11);
+    else
+        opData.ptpData &= ~(0x1 << 11);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gavbGetAvbFramePolicy
+*
+* DESCRIPTION:
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
+*
+* INPUTS:
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE
+*
+* OUTPUTS:
+*        policy    - GT_AVB_FRAME_POLICY
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbGetAvbFramePolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    OUT GT_AVB_FRAME_POLICY        *policy
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8         hwPort;         /* the physical port number     */
+    GT_U16        bitPos;
+
+    DBG_INFO(("gavbGetAvbFramePolicy Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    switch (fType)
+    {
+        case AVB_HI_FRAME:
+            bitPos = 2;
+            break;
+        case AVB_LO_FRAME:
+            bitPos = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    *policy = (opData.ptpData >> bitPos) & 0x3;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gavbSetAvbFramePolicy
+*
+* DESCRIPTION:
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
+*
+* INPUTS:
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE
+*        policy    - GT_AVB_FRAME_POLICY
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gavbSetAvbFramePolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    IN  GT_AVB_FRAME_POLICY        policy
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8         hwPort;         /* the physical port number     */
+    GT_U16        bitPos;
+
+    DBG_INFO(("gavbSetAvbFramePolicy Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
+
+    switch (fType)
+    {
+        case AVB_HI_FRAME:
+            bitPos = 2;
+            break;
+        case AVB_LO_FRAME:
+            bitPos = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
+
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(0x3 << bitPos);
+    opData.ptpData |= (policy & 0x3) << bitPos;
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/******************************************************************************
+*
+*
+*******************************************************************************/
+/* Amber QAV API */
+/*******************************************************************************
+* gqavSetPortQpriXQTSToken
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each
+*        QTS interval boundary.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue     - 0 - 3
+*        qtsToken - number of tokens.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXQTSToken
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        qtsToken
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavSetPortQpriXQTSToken Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_QTS_TOKEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if queue is beyond range */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+    {
+      if (queue>0x3)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+    else
+    {
+      if ((queue>0x3)||(queue<0x2))
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+
+    /* check if qtsToken is beyond range */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+    {
+      if (qtsToken>0x7fff)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+    else
+    {
+      if (qtsToken>0x3fff)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = queue*2;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_WRITE_DATA;
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+      opData.ptpData = qtsToken&0x7fff;
+    else
+      opData.ptpData = qtsToken&0x3fff;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing QTS token for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavGetPortQpriXQTSToken
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each
+*        QTS interval boundary.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 0 - 3
+*
+* OUTPUTS:
+*        qtsToken - number of tokens
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXQTSToken
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *qtsToken
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavGetPortQpriXQTSToken Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_QTS_TOKEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if queue is beyond range */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+    {
+      if (queue>0x3)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+    else
+    {
+      if ((queue>0x3)||(queue<0x2))
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+
+    opData.ptpAddr = queue*2;
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading QTS token for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+      *qtsToken =(GT_U16)opData.ptpData&0x7fff;
+    else
+      *qtsToken =(GT_U16)opData.ptpData&0x3fff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gqavSetPortQpriXBurstBytes
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be
+*        accumulated when the queue is blocked from sending out a frame due to
+*        higher priority queue frames being sent out.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 0 - 3
+*        burst - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXBurstBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        burst
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavSetPortQpriXBurstBytes Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_QTS_TOKEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if queue is beyond range */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+    {
+      if (queue>0x3)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+    else
+    {
+      if ((queue>0x3)||(queue<0x2))
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+
+    /* check if burst is beyond range */
+    if (burst>0x7fff)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = queue*2+1;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData = burst&0x7fff;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Burst bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+/*******************************************************************************
+* gqavGetPortQpriXBurstBytes
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be
+*        accumulated when the queue is blocked from sending out a frame due to
+*        higher priority queue frames being sent out.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 0 - 3
+*
+* OUTPUTS:
+*        burst - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXBurstBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *burst
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavgetPortQpriXBurstBytes Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_QTS_TOKEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+
+    }
+    /* check if queue is beyond range */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+    {
+      if (queue>0x3)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+    else
+    {
+      if ((queue>0x3)||(queue<0x2))
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+
+    opData.ptpAddr = queue*2+1;
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Burst bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    *burst = (GT_U16)opData.ptpData&0x7fff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gqavSetPortQpriXRate
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 2-3 rate on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 2 - 3
+*        rate - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXRate
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        rate
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavSetPortQpriXRate Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev, DEV_QAV_QPRI_RATE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if queue is beyond range */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+    {
+      if (queue>0x3)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+    else
+    {
+      if ((queue>0x3)||(queue<0x2))
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+
+    /* check if rate  is beyond range */
+    if (rate>0x0fff)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = queue*2+1;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData = rate&0x0fff;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing rate bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+/*******************************************************************************
+* gqavGetPortQpriXRate
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 2-3 rate Bytes on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 2 - 3
+*
+* OUTPUTS:
+*        rate - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXRate
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *rate
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavgetPortQpriXRate Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_RATE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+
+    }
+    /* check if queue is beyond range */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+    {
+      if (queue>0x3)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+    else
+    {
+      if ((queue>0x3)||(queue<0x2))
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+
+    opData.ptpAddr = queue*2+1;
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Rate bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    *rate = (GT_U16)opData.ptpData&0x0fff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+/*******************************************************************************
+* gqavSetPortQpriXHiLimit
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 2-3 HiLimit on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 2 - 3
+*        hiLimit - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        hiLimit
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavSetPortQpriXHiLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev, DEV_QAV_QPRI_RATE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if queue is beyond range */
+    if ((queue>0x3)||(queue<2))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* check if rate  is beyond range */
+    if (hiLimit>0x0fff)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = queue*2+1;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData = hiLimit&0x0fff;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Burst bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+/*******************************************************************************
+* gqavGetPortQpriXHiLimit
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 2-3 HiLimit Bytes on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 2 - 3
+*
+* OUTPUTS:
+*        hiLimit - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *hiLimit
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavgetPortQpriXHiLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_RATE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+
+    }
+    /* check if queue is beyond range */
+    if ((queue>0x3)||(queue<2))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+
+    opData.ptpAddr = queue*2+1;
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Hi Limit bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    *hiLimit = (GT_U16)opData.ptpData&0x7fff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gqavSetPortQavEnable
+*
+* DESCRIPTION:
+*        This routine set QAV enable status on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQavEnable
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavSetPortQavEnable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 8;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData = (en==GT_TRUE)?0x8000:0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing QAV enable for port %d.\n", port));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavGetPortQavEnable
+*
+* DESCRIPTION:
+*        This routine get QAV enable status on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*
+* OUTPUTS:
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQavEnable
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavGetPortQavEnable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 8;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading QAV enable for port %d.\n", port));
+        return GT_FAIL;
+    }
+
+    *en = ((opData.ptpData&0x8000)==0)?GT_FALSE:GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************/
+/* QAV Global resters processing */
+/*******************************************************************************
+* gqavSetGlobalAdminMGMT
+*
+* DESCRIPTION:
+*        This routine set to accept Admit Management Frames always.
+*
+* INPUTS:
+*        en - GT_TRUE to set MGMT frame accepted always,
+*             GT_FALSE do not set MGMT frame accepted always
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalAdminMGMT
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalAdminMGMT Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 0;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading QAV global config admin MGMT.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= ~0x8000;
+    if (en)
+        opData.ptpData |= 0x8000;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing QAV global config admin MGMT.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavGetGlobalAdminMGMT
+*
+* DESCRIPTION:
+*        This routine get setting of Admit Management Frames always.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to set MGMT frame accepted always,
+*             GT_FALSE do not set MGMT frame accepted always
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalAdminMGMT
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalAdminMGMT Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 0;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading QAV global config admin MGMT.\n"));
+        return GT_FAIL;
+    }
+
+    if (opData.ptpData&0x8000)
+      *en = GT_TRUE;
+    else
+      *en = GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavSetGlobalIsoPtrThreshold
+*
+* DESCRIPTION:
+*        This routine set Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers
+*        that are reserved for isochronous streams. The value is expected to be
+*        computed in SRP software and programmed into hardware based on the total
+*        aggregate isochronous streams configured to go through this device..
+*
+* INPUTS:
+*        isoPtrs -  total number of isochronous pointers
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoPtrThreshold
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        isoPtrs
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalIsoPtrThreshold Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if isoPtrs is beyond range */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY)))
+    {
+      if (isoPtrs>0x3ff)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+    else
+    {
+      if (isoPtrs>0x1ff)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 0;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading QAV global config Isochronous Queue Pointer Threshold.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    if (!(IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY)))
+      opData.ptpData &= ~0x3ff;
+    else
+      opData.ptpData &= ~0x1ff;
+    opData.ptpData |= isoPtrs;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing QAV global config Isochronous Queue Pointer Threshold.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavGetGlobalIsoPtrThreshold
+*
+* DESCRIPTION:
+*        This routine get Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers
+*        that are reserved for isochronous streams. The value is expected to be
+*        computed in SRP software and programmed into hardware based on the total
+*        aggregate isochronous streams configured to go through this device..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        isoPtrs -  total number of isochronous pointers
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoPtrThreshold
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *isoPtrs
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalIsoPtrThreshold Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 0;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous Queue Pointer Threshold.\n"));
+        return GT_FAIL;
+    }
+
+    if (!(IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY)))
+      *isoPtrs = (GT_U16)opData.ptpData&0x3ff;
+    else
+      *isoPtrs = (GT_U16)opData.ptpData&0x1ff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavSetGlobalDisQSD4MGMT
+*
+* DESCRIPTION:
+*        This routine set Disable Queue Scheduler Delays for Management frames..
+*
+* INPUTS:
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalDisQSD4MGMT
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalDisQSD4MGMT Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 3;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Disable Queue Scheduler Delay for MGMT frames.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= ~0x4000;
+    if (en==GT_TRUE)
+        opData.ptpData |= 0x4000;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Disable Queue Scheduler Delay for MGMT frames.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavGetGlobalDisQSD4MGMT
+*
+* DESCRIPTION:
+*        This routine Get Disable Queue Scheduler Delays for Management frames..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalDisQSD4MGMT
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalDisQSD4MGMT Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 3;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Disable Queue Scheduler Delay for MGMT frames.\n"));
+        return GT_FAIL;
+    }
+
+    if (opData.ptpData&0x4000)
+      *en = GT_TRUE;
+    else
+      *en = GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavSetGlobalInterrupt
+*
+* DESCRIPTION:
+*        This routine set QAV interrupt enable,
+*        The QAV interrypts include:
+*        [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable
+*        [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                              Interrupt Enable
+*
+* INPUTS:
+*        intEn - [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalInterrupt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        intEn
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalInterrupt Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 8;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Interrupt enable status.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= ~0xffff;
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6351_AVB_FAMILY))
+      opData.ptpData |= (intEn&0x87);
+    else
+      opData.ptpData |= (intEn&0x03);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Interrupt enable status.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavGetGlobalInterrupt
+*
+* DESCRIPTION:
+*       This routine get QAV interrupt status and enable status,
+*        The QAV interrypt status include:
+*         [GT_QAV_INT_STATUS_ENQ_LMT_BIT]      # Enqueue Delay Limit exceeded
+*         [GT_QAV_INT_STATUS_ISO_DEL_BIT]      # Iso Delay Interrupt Status
+*         [GT_QAV_INT_STATUS_ISO_DIS_BIT]      # Iso Discard Interrupt Status
+*         [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                                Interrupt Status
+*        The QAV interrypt enable status include:
+*         [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable
+*         [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded
+*                                                  Interrupt Enable
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        intEnSt - [GT_QAV_INT_STATUS_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] OR
+*                [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalInterrupt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *intEnSt
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalInterrupt Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 8;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Interrupt status.\n"));
+        return GT_FAIL;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6351_AVB_FAMILY))
+      *intEnSt = (GT_U16)opData.ptpData & 0x8787;
+    else
+      *intEnSt = (GT_U16)opData.ptpData & 0x0303;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavGetGlobalIsoInterruptPort
+*
+* DESCRIPTION:
+*        This routine get Isochronous interrupt port.
+*        This field indicates the port number for IsoDisInt or IsoLimitExInt
+*        bits. Only one such interrupt condition can be detected by hardware at one
+*        time. Once an interrupt bit has been set along with the IsoIntPort, the
+*        software would have to come and clear the bits before hardware records
+*        another interrupt event.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - port number for IsoDisInt or IsoLimitExInt bits.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoInterruptPort
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *port
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalIsoInterruptPort Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 9;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous interrupt port..\n"));
+        return GT_FAIL;
+    }
+
+    *port = (GT_U8)opData.ptpData&0xf;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavSetGlobalIsoDelayLmt
+*
+* DESCRIPTION:
+*        This routine set Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that
+*        will be checked by the queue controller logic to ensure no isochronous
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
+*
+* INPUTS:
+*        limit - per-port isochronous delay limit.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoDelayLmt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        limit
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalIsoDelayLmt Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_ISO_DELAY_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 10;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous queue delay Limit.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= ~0xff;
+    opData.ptpData |= (limit&0xff);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Isochronous queue delay Limit.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavGetGlobalIsoDelayLmt
+*
+* DESCRIPTION:
+*        This routine get Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that
+*        will be checked by the queue controller logic to ensure no isochronous
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        limit - per-port isochronous delay limit.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoDelayLmt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *limit
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalIsoDelayLmt Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_ISO_DELAY_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 10;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous queue delay Limit.\n"));
+        return GT_FAIL;
+    }
+
+    *limit = (GT_U8)(opData.ptpData)&0xff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavSetGlobalIsoMonEn
+*
+* DESCRIPTION:
+*       This routine set Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
+*
+* INPUTS:
+*        en - GT_TRUE / GT_FALSE.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoMonEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalIsoMonEn Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 12;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous monitor enable.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= ~0x8000;
+    if (en)
+        opData.ptpData |= 0x8000;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Isochronous monitor enable.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavGetGlobalIsoMonEn
+*
+* DESCRIPTION:
+*        This routine get Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE / GT_FALSE.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoMonEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalIsoMonEn Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 12;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous monitor enable.\n"));
+        return GT_FAIL;
+    }
+
+    if (opData.ptpData&0x8000)
+      *en = 1;
+    else
+      *en = 0;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavSetGlobalIsoMonPort
+*
+* DESCRIPTION:
+*        This routine set Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit
+*        (Qav Global Status, offset 0xD) and it indicates the port number that
+*        the software wants the hardware to start monitoring i.e., start updating
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears
+*        the above stats when IsoMonPort is changed..
+*
+* INPUTS:
+*        port -  port number .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoMonPort
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        port
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalIsoMonPort Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if port is beyond range */
+    if (port>0xf)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 12;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous monitoring port.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= ~0xf;
+    opData.ptpData |= port;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Isochronous monitoring port.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavGetGlobalIsoMonPort
+*
+* DESCRIPTION:
+*        This routine get Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit
+*        (Qav Global Status, offset 0xD) and it indicates the port number that
+*        the software wants the hardware to start monitoring i.e., start updating
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears
+*        the above stats when IsoMonPort is changed..
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port -  port number.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoMonPort
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *port
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalIsoMonPort Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 12;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous monitoring port.\n"));
+        return GT_FAIL;
+    }
+
+    *port = (GT_U16)opData.ptpData&0xf;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavSetGlobalIsoHiDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous hi packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        disCtr - upcounter of number of isochronous hi packets discarded
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoHiDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        disCtr
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalIsoHiDisCtr Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 13;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous hi queue discard counter..\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= ~0xff00;
+    if (disCtr)
+        opData.ptpData |= (disCtr<<8);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Isochronous hi queue discard counter..\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gqavGetGlobalIsoHiDisCtr
+*
+* DESCRIPTION:
+*        This routine get Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous hi packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        disCtr - upcounter of number of isochronous hi packets discarded
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoHiDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *disCtr
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalIsoHiDisCtr Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 13;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous hi queue discard counter.\n"));
+        return GT_FAIL;
+    }
+
+    *disCtr = (GT_U8)(opData.ptpData>>8)&0xff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavSetGlobalIsoLoDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous lo packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        disCtr - upcounter of number of isochronous lo packets discarded
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetGlobalIsoLoDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        disCtr
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavSetGlobalIsoLoDisCtr Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 13;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous lo queue discard counter.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= ~0xff;
+    opData.ptpData |= (disCtr&0xff);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Isochronous lo queue discard counter.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqavGetGlobalIsoLoDisCtr
+*
+* DESCRIPTION:
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD.
+*        This is an upcounter of number of isochronous lo packets discarded
+*        by Queue Controller.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        disCtr - upcounter of number of isochronous lo packets discarded
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetGlobalIsoLoDisCtr
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *disCtr
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gqavGetGlobalIsoLoDisCtr Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 13;
+
+    opData.ptpPort = 0xF;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous lo queue discard counter.\n"));
+        return GT_FAIL;
+    }
+
+    *disCtr = (GT_U8)(opData.ptpData)&0xff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtAdvVct.c
@@ -0,0 +1,1876 @@
+#include <Copyright.h>
+/*******************************************************************************
+* gtAdvVct.c
+*
+* DESCRIPTION:
+*       API for Marvell Virtual Cable Tester.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+#include <msApi.h>
+#include <gtVct.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtSem.h>
+#ifdef GT_USE_MAD
+#include <gtMad.h>
+#endif
+
+#ifdef GT_USE_MAD
+#include "gtAdvVct_mad.c"
+#endif
+
+#define GT_LOOKUP_TABLE_ENTRY  128  /* 73 */
+
+#define GT_ADV_VCT_ACCEPTABLE_SHORT_CABLE  11
+
+static  GT_U8 tbl_1181[GT_LOOKUP_TABLE_ENTRY] =
+                    {  2,  4,  8, 14, 18, 20, 25, 30, 33, 36,
+                      39, 42, 46, 48, 51, 54, 57, 59, 62, 64,
+                      66, 69, 71, 73, 75, 77, 80, 81, 83, 85,
+                      87, 88, 90, 93, 95, 97, 98,100,101,103,
+                     104,106,106,107,109,110,111,113,114,115,
+                     116,118,119,120,121,122,124,125,126,127,
+                     128,129,130,131,132,133,134,135,136,137,
+                     138,139,140};
+
+static  GT_U8 tbl_1111[GT_LOOKUP_TABLE_ENTRY] =
+                    {  0,  2,  4, 5, 6, 9, 13, 17, 20, 23,
+                      27, 30, 33, 35, 38, 41, 43, 46, 48, 51,
+                      53, 55, 58, 60, 62, 64, 66, 68, 70, 72,
+                      73, 75, 77, 79, 80, 82, 84, 85, 87, 88,
+                      90, 91, 93, 94, 96, 97, 98,100,101,102,
+                     104,105,106,107,109,110,111,112,113,114,
+                     116,117,118,119,120,121,122,123,124,125,
+                     126,127,128,129,130,131,132,133,134,134};
+
+static  GT_U8 tbl_1112[GT_LOOKUP_TABLE_ENTRY] =   /* from 17*/
+                    {  0,  4,  8, 11, 14, 18, 21, 24, 28, 31,
+                      34, 37, 39, 42, 44, 47, 49, 52, 54, 56,
+                      58, 60, 62, 64, 66, 68, 70, 72, 74, 75,
+                      77, 79, 80, 82, 83, 85, 87, 88, 89, 91,
+                      92, 94, 95, 96, 98, 99,100,101,103,104,
+                      105,106,107,108,109,111,112,113,114,115,
+                      116,117,118,119,120,121,122,123,124,124,
+                      125,126,127,128,129,130,131,131,132,133,
+                      134,135,135,136,137,138,139,139,140,141,
+                      142,142,143,144,144,145,146,147,147,148};
+
+static  GT_U8 tbl_1116[GT_LOOKUP_TABLE_ENTRY] =   /* from 16*/
+                    {  2,  4,  8, 14, 18, 20, 25, 30, 33, 36,
+                      39, 42, 46, 48, 51, 54, 57, 59, 62, 64,
+                      66, 69, 71, 73, 75, 77, 80, 81, 83, 85,
+                      87, 88, 90, 93, 95, 97, 98, 100, 101, 103,
+                      104,106,106,107,109,110,111,113,114,115,
+                      116,118,119,120,121,122,124,125,126,127,
+                      128,129,130,131,132,133,134,135,136,137,
+                      138,139,140};
+
+static  GT_U8 tbl_1240[GT_LOOKUP_TABLE_ENTRY] =
+                    {  1,  2,  5, 10, 13, 15, 18, 22, 26, 30,
+                      33, 35, 38, 40, 43, 45, 48, 51, 53, 55,
+                      58, 60, 63, 65, 68, 69, 70, 71, 73, 75,
+                      77, 79, 80, 81, 82, 83, 85, 87, 88, 90,
+                      91, 92, 93, 95, 97, 98,100,101,102,103,
+                     105,106,107,108,109,110,111,112,113,114,
+                     115,116,117,118,119,120,121,122,123,124,
+                     125,126,127,128,129,130};
+
+/*******************************************************************************
+* getDetailedAdvVCTResult
+*
+* DESCRIPTION:
+*        This routine differenciate Open/Short from Impedance mismatch.
+*
+* INPUTS:
+*        amp - amplitude
+*        len - distance to fault
+*        vctResult - test result
+*                    (Impedance mismatch, either > 115 ohms, or < 85 ohms)
+*
+* OUTPUTS:
+*
+* RETURNS:
+*       GT_ADV_VCT_STATUS
+*
+* COMMENTS:
+*       This routine assumes test result is not normal nor cross pair short.
+*
+*******************************************************************************/
+static
+GT_ADV_VCT_STATUS getDetailedAdvVCTResult
+(
+    IN  GT_U32  devType,
+    IN  GT_U32  amp,
+    IN  GT_U32  len,
+    IN  GT_ADV_VCT_STATUS result
+)
+{
+    GT_ADV_VCT_STATUS vctResult;
+    GT_BOOL    update = GT_FALSE;
+
+    DBG_INFO(("getDetailedAdvVCTResult Called.\n"));
+
+    if (devType == GT_PHY_ADV_VCT_TYPE2)
+    {
+        if(len < 10)
+        {
+            if(amp > 54)  /* 90 x 0.6 */
+                update = GT_TRUE;
+        }
+        else if(len < 50)
+        {
+            if(amp > 42) /* 70 x 0.6 */
+                update = GT_TRUE;
+        }
+        else if(len < 110)
+        {
+            if(amp > 30)  /* 50 x 0.6 */
+                update = GT_TRUE;
+        }
+        else if(len < 140)
+        {
+            if(amp > 24)  /* 40 x 0.6 */
+                update = GT_TRUE;
+        }
+        else
+        {
+            if(amp > 18) /* 30 x 0.6 */
+                update = GT_TRUE;
+        }
+    }
+    else
+    {
+        if(len < 10)
+        {
+            if(amp > 90)
+                update = GT_TRUE;
+        }
+        else if(len < 50)
+        {
+            if(amp > 70)
+                update = GT_TRUE;
+        }
+        else if(len < 110)
+        {
+            if(amp > 50)
+                update = GT_TRUE;
+        }
+        else if(len < 140)
+        {
+            if(amp > 40)
+                update = GT_TRUE;
+        }
+        else
+        {
+            if(amp > 30)
+                update = GT_TRUE;
+        }
+    }
+
+
+    switch (result)
+    {
+        case GT_ADV_VCT_IMP_GREATER_THAN_115:
+                if(update)
+                    vctResult = GT_ADV_VCT_OPEN;
+                else
+                    vctResult = result;
+                break;
+        case GT_ADV_VCT_IMP_LESS_THAN_85:
+                if(update)
+                    vctResult = GT_ADV_VCT_SHORT;
+                else
+                    vctResult = result;
+                break;
+        default:
+                vctResult = result;
+                break;
+    }
+
+    return vctResult;
+}
+
+/*******************************************************************************
+* analizeAdvVCTResult
+*
+* DESCRIPTION:
+*        This routine analize the Advanced VCT result.
+*
+* INPUTS:
+*        channel - channel number where test was run
+*        crossChannelReg - register values after the test is completed
+*        mode    - use formula for normal cable case
+*
+* OUTPUTS:
+*        cableStatus - analized test result.
+*
+* RETURNS:
+*        -1, or distance to fault
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+static
+GT_16 analizeAdvVCTNoCrosspairResult
+(
+    IN  GT_U32  devType,
+    IN  int     channel,
+    IN  GT_U16 *crossChannelReg,
+    IN  GT_BOOL isShort,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+)
+{
+    int len;
+    GT_16 dist2fault;
+    GT_ADV_VCT_STATUS vctResult = GT_ADV_VCT_NORMAL;
+
+    DBG_INFO(("analizeAdvVCTNoCrosspairResult Called.\n"));
+    DBG_INFO(("analizeAdvVCTNoCrosspairResult chan %d reg data %x\n", channel, crossChannelReg[channel]));
+
+    dist2fault = -1;
+
+    /* check if test is failed */
+    if(IS_VCT_FAILED(crossChannelReg[channel]))
+    {
+        cableStatus->cableStatus[channel] = GT_ADV_VCT_FAIL;
+        return dist2fault;
+    }
+
+    /* Check if fault detected */
+    if(IS_ZERO_AMPLITUDE(crossChannelReg[channel]))
+    {
+        cableStatus->cableStatus[channel] = GT_ADV_VCT_NORMAL;
+        return dist2fault;
+    }
+
+    /* find out test result by reading Amplitude */
+    if(IS_POSITIVE_AMPLITUDE(crossChannelReg[channel]))
+    {
+        vctResult = GT_ADV_VCT_IMP_GREATER_THAN_115;
+    }
+    else
+    {
+        vctResult = GT_ADV_VCT_IMP_LESS_THAN_85;
+    }
+
+    /*
+     * now, calculate the distance for GT_ADV_VCT_IMP_GREATER_THAN_115 and
+     * GT_ADV_VCT_IMP_LESS_THAN_85
+     */
+    switch (vctResult)
+    {
+        case GT_ADV_VCT_IMP_GREATER_THAN_115:
+        case GT_ADV_VCT_IMP_LESS_THAN_85:
+            if(!isShort)
+            {
+                len = (int)GT_ADV_VCT_CALC(crossChannelReg[channel] & 0xFF);
+            }
+            else
+            {
+                len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[channel] & 0xFF);
+            }
+            DBG_INFO(("@@@@ no cross len %d\n", len));
+
+            if (len < 0)
+                len = 0;
+            cableStatus->u[channel].dist2fault = (GT_16)len;
+            vctResult = getDetailedAdvVCTResult(
+                                    devType,
+                                    GET_AMPLITUDE(crossChannelReg[channel]),
+                                    len,
+                                    vctResult);
+            dist2fault = (GT_16)len;
+            break;
+        default:
+            break;
+    }
+
+    cableStatus->cableStatus[channel] = vctResult;
+
+    return dist2fault;
+}
+
+
+static
+GT_16 analizeAdvVCTResult
+(
+    IN  GT_U32  devType,
+    IN  int     channel,
+    IN  GT_U16 *crossChannelReg,
+    IN  GT_BOOL isShort,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+)
+{
+    int i, len;
+    GT_16 dist2fault;
+    GT_ADV_VCT_STATUS vctResult = GT_ADV_VCT_NORMAL;
+
+    DBG_INFO(("analizeAdvVCTResult(Crosspair) chan %d reg data %x\n", channel, crossChannelReg[channel]));
+    DBG_INFO(("analizeAdvVCTResult Called.\n"));
+
+    dist2fault = -1;
+
+    /* check if test is failed */
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        if(IS_VCT_FAILED(crossChannelReg[i]))
+        {
+            cableStatus->cableStatus[channel] = GT_ADV_VCT_FAIL;
+            return dist2fault;
+        }
+    }
+
+    /* find out test result by reading Amplitude */
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        if (i == channel)
+        {
+            if(!IS_ZERO_AMPLITUDE(crossChannelReg[i]))
+            {
+                if(IS_POSITIVE_AMPLITUDE(crossChannelReg[i]))
+                {
+                    vctResult = GT_ADV_VCT_IMP_GREATER_THAN_115;
+                }
+                else
+                {
+                    vctResult = GT_ADV_VCT_IMP_LESS_THAN_85;
+                }
+            }
+            continue;
+        }
+
+        if(IS_ZERO_AMPLITUDE(crossChannelReg[i]))
+            continue;
+
+        vctResult = GT_ADV_VCT_CROSS_PAIR_SHORT;
+        break;
+    }
+
+    /* if it is cross pair short, check the distance for each channel */
+    if(vctResult == GT_ADV_VCT_CROSS_PAIR_SHORT)
+    {
+        cableStatus->cableStatus[channel] = GT_ADV_VCT_CROSS_PAIR_SHORT;
+        for (i=0; i<GT_MDI_PAIR_NUM; i++)
+        {
+            if(IS_ZERO_AMPLITUDE(crossChannelReg[i]))
+            {
+                cableStatus->u[channel].crossShort.channel[i] = GT_FALSE;
+                cableStatus->u[channel].crossShort.dist2fault[i] = 0;
+                continue;
+            }
+
+            cableStatus->u[channel].crossShort.channel[i] = GT_TRUE;
+            if(!isShort)
+                len = (int)GT_ADV_VCT_CALC(crossChannelReg[i] & 0xFF);
+            else
+                len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[i] & 0xFF);
+            DBG_INFO(("@@@@ len %d\n", len));
+
+            if (len < 0)
+                len = 0;
+            cableStatus->u[channel].crossShort.dist2fault[i] = (GT_16)len;
+            dist2fault = (GT_16)len;
+        }
+
+        return dist2fault;
+    }
+
+    /*
+     * now, calculate the distance for GT_ADV_VCT_IMP_GREATER_THAN_115 and
+     * GT_ADV_VCT_IMP_LESS_THAN_85
+     */
+    switch (vctResult)
+    {
+        case GT_ADV_VCT_IMP_GREATER_THAN_115:
+        case GT_ADV_VCT_IMP_LESS_THAN_85:
+            if(isShort)
+                len = (int)GT_ADV_VCT_CALC(crossChannelReg[channel] & 0xFF);
+            else
+                len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[channel] & 0xFF);
+            if (len < 0)
+                len = 0;
+            cableStatus->u[channel].dist2fault = (GT_16)len;
+            vctResult = getDetailedAdvVCTResult(
+                                    devType,
+                                    GET_AMPLITUDE(crossChannelReg[channel]),
+                                    len,
+                                    vctResult);
+            dist2fault = (GT_16)len;
+            break;
+        default:
+            break;
+    }
+
+    cableStatus->cableStatus[channel] = vctResult;
+
+    return dist2fault;
+}
+
+
+/*******************************************************************************
+* runAdvCableTest_1181
+*
+* DESCRIPTION:
+*        This routine performs the advanced virtual cable test for the PHY with
+*        multiple page mode and returns the the status per MDIP/N.
+*
+* INPUTS:
+*        port - logical port number.
+*        mode - GT_TRUE, if short cable detect is required
+*               GT_FALSE, otherwise
+*
+* OUTPUTS:
+*        cableStatus - the port copper cable status.
+*        tooShort    - if known distance to fault is too short
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+static
+GT_STATUS runAdvCableTest_1181
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_BOOL         mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus,
+    OUT GT_BOOL         *tooShort
+)
+{
+    GT_STATUS retVal;
+    GT_U16 u16Data;
+    GT_U16 crossChannelReg[GT_MDI_PAIR_NUM];
+    int i,j;
+    GT_16  dist2fault;
+
+    VCT_REGISTER regList[GT_MDI_PAIR_NUM][GT_MDI_PAIR_NUM] = {
+                            {{8,16},{8,17},{8,18},{8,19}},  /* channel 0 */
+                            {{8,24},{8,25},{8,26},{8,27}},  /* channel 1 */
+                            {{9,16},{9,17},{9,18},{9,19}},  /* channel 2 */
+                            {{9,24},{9,25},{9,26},{9,27}}   /* channel 3 */
+                            };
+
+    DBG_INFO(("runAdvCableTest_1181 Called.\n"));
+
+    if (mode)
+        *tooShort = GT_FALSE;
+
+    /*
+     * start Advanced Virtual Cable Tester
+     */
+    if((retVal = hwSetPagedPhyRegField(
+                        dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,15,1,phyInfo->anyPage,1)) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    /*
+     * loop until test completion and result is valid
+     */
+    do
+    {
+        if((retVal = hwReadPagedPhyReg(
+                            dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            DBG_INFO(("Reading from paged phy reg failed.\n"));
+            return retVal;
+        }
+    } while(u16Data & 0x8000);
+
+    DBG_INFO(("Page 8 of Reg20 after test : %0#x.\n", u16Data));
+
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        /*
+         * read the test result for the cross pair against selected MDI Pair
+         */
+        for (j=0; j<GT_MDI_PAIR_NUM; j++)
+        {
+            if((retVal = hwReadPagedPhyReg(
+                                dev,hwPort,
+                                regList[i][j].page,
+                                regList[i][j].regOffset,
+                                phyInfo->anyPage,
+                                &crossChannelReg[j])) != GT_OK)
+            {
+                DBG_INFO(("Reading from paged phy reg failed.\n"));
+                return retVal;
+            }
+        }
+
+        /*
+         * analyze the test result for RX Pair
+         */
+        dist2fault = analizeAdvVCTResult(phyInfo->vctType, i, crossChannelReg, mode, cableStatus);
+
+        if(mode)
+        {
+            if ((dist2fault>=0) && (dist2fault<GT_ADV_VCT_ACCEPTABLE_SHORT_CABLE))
+            {
+                DBG_INFO(("Distance to Fault is too Short. So, rerun after changing pulse width\n"));
+                *tooShort = GT_TRUE;
+                break;
+            }
+        }
+    }
+
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* getAdvCableStatus_1181
+*
+* DESCRIPTION:
+*        This routine performs the virtual cable test for the PHY with
+*        multiple page mode and returns the the status per MDIP/N.
+*
+* INPUTS:
+*        port - logical port number.
+*        mode - advance VCT mode (either First Peak or Maximum Peak)
+*
+* OUTPUTS:
+*        cableStatus - the port copper cable status.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+static
+GT_STATUS getAdvCableStatus_1181
+(
+    IN  GT_QD_DEV          *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS retVal;
+    GT_U16 orgPulse, u16Data;
+    GT_BOOL flag, tooShort;
+
+    flag = GT_TRUE;
+
+    /*
+     * set Adv VCT Mode
+     */
+    switch (mode.mode)
+    {
+        case GT_ADV_VCT_FIRST_PEAK:
+            break;
+        case GT_ADV_VCT_MAX_PEAK:
+            break;
+        default:
+            DBG_INFO(("Unknown Advanced VCT Mode.\n"));
+            return GT_BAD_PARAM;
+    }
+
+    u16Data = (mode.mode<<6) | (mode.peakDetHyst) | (mode.sampleAvg<<8);
+    if((retVal = hwSetPagedPhyRegField(
+                        dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,0,11,phyInfo->anyPage,u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    if (flag)
+    {
+        /* save original Pulse Width */
+        if((retVal = hwGetPagedPhyRegField(
+                            dev,hwPort,9,23,10,2,phyInfo->anyPage,&orgPulse)) != GT_OK)
+        {
+            DBG_INFO(("Reading paged phy reg failed.\n"));
+            return retVal;
+        }
+
+        /* set the Pulse Width with default value */
+        if (orgPulse != 0)
+        {
+            if((retVal = hwSetPagedPhyRegField(
+                                dev,hwPort,9,23,10,2,phyInfo->anyPage,0)) != GT_OK)
+            {
+                DBG_INFO(("Writing to paged phy reg failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    if((retVal=runAdvCableTest_1181(dev,hwPort,phyInfo,flag,cableStatus,&tooShort)) != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT failed.\n"));
+        return retVal;
+    }
+
+    if (flag)
+    {
+        if(tooShort)
+        {
+            /* set the Pulse Width with minimum width */
+            if((retVal = hwSetPagedPhyRegField(
+                                dev,hwPort,9,23,10,2,phyInfo->anyPage,3)) != GT_OK)
+            {
+                DBG_INFO(("Writing to paged phy reg failed.\n"));
+                return retVal;
+            }
+
+            /* run the Adv VCT again */
+            if((retVal=runAdvCableTest_1181(dev,hwPort,phyInfo,GT_FALSE,cableStatus,&tooShort)) != GT_OK)
+            {
+                DBG_INFO(("Running advanced VCT failed.\n"));
+                return retVal;
+            }
+
+        }
+
+        /* set the Pulse Width back to the original value */
+        if((retVal = hwSetPagedPhyRegField(
+                            dev,hwPort,9,23,10,2,phyInfo->anyPage,orgPulse)) != GT_OK)
+        {
+            DBG_INFO(("Writing to paged phy reg failed.\n"));
+            return retVal;
+        }
+
+    }
+
+    return GT_OK;
+}
+
+
+static
+GT_STATUS runAdvCableTest_1116_set
+(
+    IN  GT_QD_DEV          *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_32           channel,
+    IN  GT_ADV_VCT_TRANS_CHAN_SEL        crosspair
+)
+{
+    GT_STATUS retVal;
+
+    DBG_INFO(("runAdvCableTest_1116_set Called.\n"));
+
+    /*
+     * start Advanced Virtual Cable Tester
+     */
+    if((retVal = hwSetPagedPhyRegField(
+                        dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,15,1,phyInfo->anyPage,1)) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+static
+GT_STATUS runAdvCableTest_1116_check
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo
+)
+{
+    GT_STATUS retVal;
+    GT_U16 u16Data;
+
+    /*
+     * loop until test completion and result is valid
+     */
+    do {
+        if((retVal = hwReadPagedPhyReg(
+                            dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            DBG_INFO(("Reading from paged phy reg failed.\n"));
+            return retVal;
+        }
+    } while (u16Data & 0x8000);
+
+    return GT_OK;
+}
+
+static
+GT_STATUS runAdvCableTest_1116_get
+(
+    IN  GT_QD_DEV          *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_ADV_VCT_TRANS_CHAN_SEL    crosspair,
+    IN  GT_32            channel,
+    OUT GT_ADV_CABLE_STATUS *cableStatus,
+    OUT GT_BOOL         *tooShort
+)
+{
+    GT_STATUS retVal;
+    GT_U16 u16Data;
+    GT_U16 crossChannelReg[GT_MDI_PAIR_NUM];
+    int j;
+    GT_16  dist2fault;
+    GT_BOOL         mode;
+    GT_BOOL         localTooShort[GT_MDI_PAIR_NUM];
+
+    VCT_REGISTER regList[GT_MDI_PAIR_NUM] = { {5,16},{5,17},{5,18},{5,19} };
+
+    mode = GT_TRUE;
+
+    DBG_INFO(("runAdvCableTest_1116_get Called.\n"));
+
+    if ((retVal = hwReadPagedPhyReg(
+                        dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Reading from paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("Page 5 of Reg23 after test : %0#x.\n", u16Data));
+
+    /*
+     * read the test result for the cross pair against selected MDI Pair
+     */
+    for (j=0; j<GT_MDI_PAIR_NUM; j++)
+    {
+        if((retVal = hwReadPagedPhyReg(
+                                dev,hwPort,
+                                regList[j].page,
+                                regList[j].regOffset,
+                                phyInfo->anyPage,
+                                &crossChannelReg[j])) != GT_OK)
+        {
+            DBG_INFO(("Reading from paged phy reg failed.\n"));
+            return retVal;
+        }
+        DBG_INFO(("@@@@@ reg channel %d is %x \n", j, crossChannelReg[j]));
+    }
+
+    /*
+     * analyze the test result for RX Pair
+     */
+    for (j=0; j<GT_MDI_PAIR_NUM; j++)
+    {
+        if (crosspair!=GT_ADV_VCT_TCS_NO_CROSSPAIR)
+            dist2fault = analizeAdvVCTResult(phyInfo->vctType, j, crossChannelReg, mode&(*tooShort), cableStatus);
+        else
+            dist2fault = analizeAdvVCTNoCrosspairResult(phyInfo->vctType, j, crossChannelReg, mode&(*tooShort), cableStatus);
+
+        localTooShort[j]=GT_FALSE;
+        if((mode)&&(*tooShort==GT_FALSE))
+        {
+            if ((dist2fault>=0) && (dist2fault<GT_ADV_VCT_ACCEPTABLE_SHORT_CABLE))
+            {
+                DBG_INFO(("@@@#@@@@ it is too short dist2fault %d\n", dist2fault));
+                DBG_INFO(("Distance to Fault is too Short. So, rerun after changing pulse width\n"));
+                localTooShort[j]=GT_TRUE;
+            }
+        }
+    }
+
+    /* check and decide if length is too short */
+    for (j=0; j<GT_MDI_PAIR_NUM; j++)
+    {
+        if (localTooShort[j]==GT_FALSE) break;
+    }
+
+    if (j==GT_MDI_PAIR_NUM)
+        *tooShort = GT_TRUE;
+
+    return GT_OK;
+}
+
+static
+GT_STATUS runAdvCableTest_1116
+(
+    IN  GT_QD_DEV          *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_BOOL         mode,
+    IN  GT_ADV_VCT_TRANS_CHAN_SEL   crosspair,
+    OUT GT_ADV_CABLE_STATUS *cableStatus,
+    OUT GT_BOOL         *tooShort
+)
+{
+    GT_STATUS retVal;
+    GT_32  channel;
+
+    DBG_INFO(("runAdvCableTest_1116 Called.\n"));
+
+    if (crosspair!=GT_ADV_VCT_TCS_NO_CROSSPAIR)
+    {
+        channel = crosspair - GT_ADV_VCT_TCS_CROSSPAIR_0;
+    }
+    else
+    {
+        channel = 0;
+    }
+
+    /* Set transmit channel */
+    if((retVal=runAdvCableTest_1116_set(dev,hwPort, phyInfo,channel, crosspair)) != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT failed.\n"));
+        return retVal;
+    }
+
+    /*
+     * check test completion
+     */
+    retVal = runAdvCableTest_1116_check(dev,hwPort,phyInfo);
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT failed.\n"));
+        return retVal;
+    }
+
+    /*
+     * read the test result for the cross pair against selected MDI Pair
+     */
+    retVal = runAdvCableTest_1116_get(dev, hwPort, phyInfo, crosspair,
+                                    channel,cableStatus,(GT_BOOL *)tooShort);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT get failed.\n"));
+    }
+
+    return retVal;
+}
+
+static
+GT_STATUS getAdvCableStatus_1116
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS retVal;
+    GT_U16 orgPulse, u16Data;
+    GT_BOOL flag, tooShort;
+    GT_ADV_VCT_TRANS_CHAN_SEL crosspair;
+
+    flag = GT_TRUE;
+    crosspair = mode.transChanSel;
+
+    /*
+     * Check Adv VCT Mode
+     */
+    switch (mode.mode)
+    {
+        case GT_ADV_VCT_FIRST_PEAK:
+        case GT_ADV_VCT_MAX_PEAK:
+                break;
+
+        default:
+                DBG_INFO(("Unknown ADV VCT Mode.\n"));
+                return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal = hwGetPagedPhyRegField(
+                            dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,0,13,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Reading paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    u16Data |= ((mode.mode<<6) | (mode.transChanSel<<11));
+    if (mode.peakDetHyst) u16Data |= (mode.peakDetHyst);
+    if (mode.sampleAvg) u16Data |= (mode.sampleAvg<<8) ;
+
+    if((retVal = hwSetPagedPhyRegField(
+                        dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,0,13,phyInfo->anyPage,u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    if (flag)
+    {
+        /* save original Pulse Width */
+        if((retVal = hwGetPagedPhyRegField(dev,hwPort,5,28,10,2,phyInfo->anyPage,&orgPulse)) != GT_OK)
+        {
+            DBG_INFO(("Reading paged phy reg failed.\n"));
+            return retVal;
+        }
+
+        /* set the Pulse Width with default value */
+        if (orgPulse != 0)
+        {
+            if((retVal = hwSetPagedPhyRegField(dev,hwPort,5,28,10,2,phyInfo->anyPage,0)) != GT_OK)
+            {
+                DBG_INFO(("Writing to paged phy reg failed.\n"));
+                return retVal;
+            }
+        }
+        tooShort=GT_FALSE;
+    }
+
+    if((retVal=runAdvCableTest_1116(dev,hwPort,phyInfo,flag,crosspair,
+                                    cableStatus,&tooShort)) != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT failed.\n"));
+        return retVal;
+    }
+
+    if (flag)
+    {
+        if(tooShort)
+        {
+            /* set the Pulse Width with minimum width */
+            if((retVal = hwSetPagedPhyRegField(
+                                        dev,hwPort,5,28,10,2,phyInfo->anyPage,3)) != GT_OK)
+            {
+                DBG_INFO(("Writing to paged phy reg failed.\n"));
+                return retVal;
+            }
+
+            /* run the Adv VCT again */
+            if((retVal=runAdvCableTest_1116(dev,hwPort,phyInfo,GT_FALSE,crosspair,
+                                        cableStatus,&tooShort)) != GT_OK)
+            {
+                DBG_INFO(("Running advanced VCT failed.\n"));
+                return retVal;
+            }
+
+        }
+
+        /* set the Pulse Width back to the original value */
+        if((retVal = hwSetPagedPhyRegField(
+                                dev,hwPort,5,28,10,2,phyInfo->anyPage,orgPulse)) != GT_OK)
+        {
+            DBG_INFO(("Writing to paged phy reg failed.\n"));
+            return retVal;
+        }
+
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvctGetAdvCableStatus
+*
+* DESCRIPTION:
+*       This routine perform the advanced virtual cable test for the requested
+*       port and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*       mode - advance VCT mode (either First Peak or Maximum Peak)
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are supporting this API.
+*
+*******************************************************************************/
+GT_STATUS gvctGetAdvCableDiag
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status;
+    GT_U8 hwPort;
+    GT_U16 u16Data, org0;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn, autoNeg;
+    GT_U16            pageReg;
+    int i;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gvctGetAdvCableDiag_mad(dev, port, mode, cableStatus);
+#endif
+
+    DBG_INFO(("gvctGetCableDiag Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_ADV_VCT_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /*
+     * If Fiber is used, simply return with test fail.
+     */
+    if(phyInfo.flag & GT_PHY_FIBER)
+    {
+        if((status= hwReadPagedPhyReg(dev,hwPort,1,17,phyInfo.anyPage,&u16Data)) != GT_OK)
+        {
+        gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+
+        if(u16Data & 0x400)
+        {
+            for (i=0; i<GT_MDI_PAIR_NUM; i++)
+            {
+                cableStatus->cableStatus[i] = GT_ADV_VCT_FAIL;
+            }
+        gtSemGive(dev,dev->phyRegsSem);
+            return GT_OK;
+        }
+    }
+
+    /*
+     * Check the link
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to reset the Phy.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return status;
+    }
+
+    autoNeg = GT_FALSE;
+    org0 = 0;
+    if (!(u16Data & 0x400))
+    {
+        /* link is down, so disable auto-neg if enabled */
+        if((status= hwReadPagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,&u16Data)) != GT_OK)
+        {
+            DBG_INFO(("Not able to reset the Phy.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+
+        org0 = u16Data;
+
+        if (u16Data & 0x1000)
+        {
+            u16Data = 0x140;
+
+            /* link is down, so disable auto-neg if enabled */
+            if((status= hwWritePagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,u16Data)) != GT_OK)
+            {
+                DBG_INFO(("Not able to reset the Phy.\n"));
+                return status;
+            }
+
+            if((status= hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+            {
+                DBG_INFO(("Not able to reset the Phy.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+                return status;
+            }
+            autoNeg = GT_TRUE;
+        }
+    }
+
+    switch(phyInfo.vctType)
+    {
+        case GT_PHY_ADV_VCT_TYPE1:
+            status = getAdvCableStatus_1181(dev,hwPort,&phyInfo,mode,cableStatus);
+            break;
+        case GT_PHY_ADV_VCT_TYPE2:
+            status = getAdvCableStatus_1116(dev,hwPort,&phyInfo,mode,cableStatus);
+            break;
+        default:
+            status = GT_FAIL;
+            break;
+    }
+
+    if (autoNeg)
+    {
+        if((status= hwPhyReset(dev,hwPort,org0)) != GT_OK)
+        {
+            DBG_INFO(("Not able to reset the Phy.\n"));
+            goto cableDiagCleanup;
+        gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+    }
+cableDiagCleanup:
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;
+}
+
+
+/*******************************************************************************
+* dspLookup
+*
+* DESCRIPTION:
+*       This routine returns cable length (meters) by reading DSP Lookup table.
+*
+* INPUTS:
+*       regValue - register 21
+*
+* OUTPUTS:
+*       cableLen - cable length (unit of meters).
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static
+GT_STATUS dspLookup
+(
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_U16 regValue,
+    OUT GT_32  *cableLen
+)
+{
+    GT_U16 startEntry,tableEntry;
+    GT_U8* tbl;
+    switch(phyInfo->exStatusType)
+    {
+        case GT_PHY_EX_STATUS_TYPE1:    /* 88E1111/88E1141/E1145 */
+            startEntry = 18-1;
+            tableEntry = 80;
+            tbl = tbl_1111;
+            break;
+
+        case GT_PHY_EX_STATUS_TYPE2:    /* 88E1112 */
+            startEntry = 17;
+            tableEntry = 100;
+            tbl = tbl_1112;
+            break;
+
+        case GT_PHY_EX_STATUS_TYPE3:   /* 88E1149 has no reference constans*/
+            startEntry = 16;
+            tableEntry = 73;
+            tbl = tbl_1181;
+            break;
+
+        case GT_PHY_EX_STATUS_TYPE4:   /* 88E1181 */
+            startEntry = 16;
+            tableEntry = 73;
+            tbl = tbl_1181;
+            break;
+
+        case GT_PHY_EX_STATUS_TYPE5:   /* 88E1116 88E1121 */
+            startEntry = 16;
+            tableEntry = 73;
+            tbl = tbl_1116;
+            break;
+
+        case GT_PHY_EX_STATUS_TYPE6:   /* 88E6165 Internal Phy */
+            if ((phyInfo->phyId & PHY_MODEL_MASK) == DEV_G65G)
+                startEntry = 18;
+            else
+                startEntry = 21;
+            tableEntry = 76;
+            tbl = tbl_1240;
+            break;
+
+        default:
+            return GT_NOT_SUPPORTED;
+    }
+
+    if (tbl == NULL)
+    {
+        *cableLen = -1;
+        return GT_OK;
+    }
+
+    if (regValue < startEntry)
+    {
+        *cableLen = 0;
+        return GT_OK;
+    }
+
+    if (regValue >= (tableEntry+startEntry-1))
+    {
+        regValue = tableEntry-1;
+    }
+    else
+    {
+        regValue -= startEntry;
+    }
+
+    *cableLen = (GT_32)tbl[regValue];
+    return GT_OK;
+}
+
+/*******************************************************************************
+* getDSPDistance_1111
+*
+* DESCRIPTION:
+*       This routine returns cable length (meters) from DSP method.
+*       This routine is for the 88E1111 like devices.
+*
+* INPUTS:
+*       mdi - pair of each MDI (0..3).
+*
+* OUTPUTS:
+*       cableLen - cable length (unit of meters).
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static
+GT_STATUS getDSPDistance_1111
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8  hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_U32 mdi,
+    OUT GT_32 *cableLen
+)
+{
+    GT_U16     data, pageNum;
+    GT_STATUS  retVal;
+
+    DBG_INFO(("getDSPDistance Called.\n"));
+
+    pageNum = 0x8754 + (GT_U16)((mdi << 12)&0xf000);
+
+    if((retVal = hwReadPagedPhyReg(dev,hwPort,(GT_U8)pageNum,31,phyInfo->anyPage,&data)) != GT_OK)
+    {
+        DBG_INFO(("Reading length of MDI pair failed.\n"));
+        return retVal;
+    }
+
+    return dspLookup(phyInfo,data,cableLen);
+}
+
+
+/*******************************************************************************
+* getDSPDistance_1181
+*
+* DESCRIPTION:
+*       This routine returns cable length (meters) from DSP method.
+*       This routine is for the 88E1181 like devices.
+*
+* INPUTS:
+*       mdi - pair of each MDI (0..3).
+*
+* OUTPUTS:
+*       cableLen - cable length (unit of meters).
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static
+GT_STATUS getDSPDistance_1181
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8  hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_U32 mdi,
+    OUT GT_32 *cableLen
+)
+{
+    GT_U16     data, retryCount;
+    GT_STATUS  retVal;
+
+    DBG_INFO(("getDSPDistance Called.\n"));
+
+    /* Set the required bits for Cable length register */
+    if((retVal = hwWritePagedPhyReg(dev,hwPort,0xff,19,phyInfo->anyPage,(GT_U16)(0x1018+(0xff&mdi)))) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    retryCount = 1000;
+
+    do
+    {
+        if(retryCount == 0)
+        {
+            DBG_INFO(("Ready bit of Cable length resiter is not set.\n"));
+            return GT_FAIL;
+        }
+
+        /* Check the ready bit of Cable length register */
+        if((retVal = hwGetPagedPhyRegField(dev,hwPort,0xff,19,15,1,phyInfo->anyPage,&data)) != GT_OK)
+        {
+            DBG_INFO(("Writing to paged phy reg failed.\n"));
+            return retVal;
+        }
+
+        retryCount--;
+
+    } while(!data);
+
+    /* read length of MDI pair */
+    if((retVal = hwReadPagedPhyReg(dev,hwPort,0xff,21,phyInfo->anyPage,&data)) != GT_OK)
+    {
+        DBG_INFO(("Reading length of MDI pair failed.\n"));
+        return retVal;
+    }
+
+    return dspLookup(phyInfo,data,cableLen);
+}
+
+
+/*******************************************************************************
+* getDSPDistance_1240
+*
+* DESCRIPTION:
+*       This routine returns cable length (meters) from DSP method.
+*       This routine is for the 88E1181 like devices.
+*
+* INPUTS:
+*       mdi - pair of each MDI (0..3).
+*
+* OUTPUTS:
+*       cableLen - cable length (unit of meters).
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static
+GT_STATUS getDSPDistance_1240
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8  hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_U32 mdi,
+    OUT GT_32 *cableLen
+)
+{
+    GT_U16     data, retryCount;
+    GT_STATUS  retVal;
+
+    DBG_INFO(("getDSPDistance Called.\n"));
+
+    /* Set the required bits for Cable length register */
+    if((retVal = hwWritePagedPhyReg(dev,hwPort,0xff,16,phyInfo->anyPage,(GT_U16)(0x1118+(0xff&mdi)))) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    retryCount = 1000;
+
+    do
+    {
+        if(retryCount == 0)
+        {
+            DBG_INFO(("Ready bit of Cable length resiter is not set.\n"));
+            return GT_FAIL;
+        }
+
+        /* Check the ready bit of Cable length register */
+        if((retVal = hwGetPagedPhyRegField(dev,hwPort,0xff,16,15,1,phyInfo->anyPage,&data)) != GT_OK)
+        {
+            DBG_INFO(("Writing to paged phy reg failed.\n"));
+            return retVal;
+        }
+
+        retryCount--;
+
+    } while(!data);
+
+    /* read length of MDI pair */
+    if((retVal = hwReadPagedPhyReg(dev,hwPort,0xff,18,phyInfo->anyPage,&data)) != GT_OK)
+    {
+        DBG_INFO(("Reading length of MDI pair failed.\n"));
+        return retVal;
+    }
+
+    return dspLookup(phyInfo,data,cableLen);
+}
+
+
+
+/*******************************************************************************
+* getExStatus_28
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*        for 1000M phy with multiple page mode
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static GT_STATUS getExStatus_28
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS retVal;
+    GT_U16 u16Data, i;
+
+    extendedStatus->isValid = GT_FALSE;
+    /* DSP based cable length */
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        if((retVal = getDSPDistance_1111(dev,hwPort,phyInfo,i,(GT_32 *)&(extendedStatus->cableLen[i]))) != GT_OK)
+        {
+            DBG_INFO(("getDSPDistance failed.\n"));
+            return retVal;
+        }
+    }
+
+
+    /*
+     * get data from 28_5 register for pair swap
+     */
+    if((retVal = hwReadPagedPhyReg(
+                    dev,hwPort,5,28,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Reading from paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    /* if bit 6 is not set, it's not valid. */
+    if (!(u16Data & 0x40))
+    {
+        DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+        return GT_OK;
+    }
+
+    extendedStatus->isValid = GT_TRUE;
+
+    /* get Pair Polarity */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        switch((u16Data >> i) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairPolarity[i] = GT_POSITIVE;
+                break;
+            default:
+                extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+            break;
+        }
+    }
+
+    /* get Pair Swap for Channel A and B */
+    if (u16Data & 0x10)
+    {
+        extendedStatus->pairSwap[0] = GT_CHANNEL_A;
+        extendedStatus->pairSwap[1] = GT_CHANNEL_B;
+    }
+    else
+    {
+        extendedStatus->pairSwap[0] = GT_CHANNEL_B;
+        extendedStatus->pairSwap[1] = GT_CHANNEL_A;
+    }
+
+    /* get Pair Swap for Channel C and D */
+    if (u16Data & 0x20)
+    {
+        extendedStatus->pairSwap[2] = GT_CHANNEL_C;
+        extendedStatus->pairSwap[3] = GT_CHANNEL_D;
+    }
+    else
+    {
+        extendedStatus->pairSwap[2] = GT_CHANNEL_D;
+        extendedStatus->pairSwap[3] = GT_CHANNEL_C;
+    }
+
+    /*
+     * get data from 28_4 register for pair skew
+     */
+    if((retVal = hwReadPagedPhyReg(
+                    dev,hwPort,4,28,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Reading from paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    /* get Pair Skew */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* getExStatus
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*        for 1000M phy with multiple page mode
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static GT_STATUS getExStatus
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS retVal;
+    GT_U16 u16Data, i;
+
+    extendedStatus->isValid = GT_FALSE;
+    /* DSP based cable length */
+    switch(phyInfo->exStatusType)
+    {
+        case GT_PHY_EX_STATUS_TYPE1:
+        case GT_PHY_EX_STATUS_TYPE2:
+            for (i=0; i<GT_MDI_PAIR_NUM; i++)
+            {
+                if((retVal = getDSPDistance_1111(dev,hwPort,phyInfo,i,(GT_32 *)&extendedStatus->cableLen[i])) != GT_OK)
+                {
+                    DBG_INFO(("getDSPDistance failed.\n"));
+                    return retVal;
+                }
+            }
+            break;
+        case GT_PHY_EX_STATUS_TYPE3:
+        case GT_PHY_EX_STATUS_TYPE4:
+        case GT_PHY_EX_STATUS_TYPE5:
+            for (i=0; i<GT_MDI_PAIR_NUM; i++)
+            {
+                if((retVal = getDSPDistance_1181(dev,hwPort,phyInfo,i,(GT_32 *)&extendedStatus->cableLen[i])) != GT_OK)
+                {
+                    DBG_INFO(("getDSPDistance failed.\n"));
+                    return retVal;
+                }
+            }
+            break;
+
+        case GT_PHY_EX_STATUS_TYPE6:
+            for (i=0; i<GT_MDI_PAIR_NUM; i++)
+            {
+                if((retVal = getDSPDistance_1240(dev,hwPort,phyInfo,i,(GT_32 *)&extendedStatus->cableLen[i])) != GT_OK)
+                {
+                    DBG_INFO(("getDSPDistance failed.\n"));
+                    return retVal;
+                }
+            }
+            break;
+
+        default:
+            return GT_NOT_SUPPORTED;
+    }
+
+    /*
+     * get data from 21_5 register for pair swap
+     */
+    if((retVal = hwReadPagedPhyReg(
+                    dev,hwPort,5,QD_REG_PAIR_SWAP_STATUS,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Reading from paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    /* if bit 6 is not set, it's not valid. */
+    if (!(u16Data & 0x40))
+    {
+        DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+        return GT_OK;
+    }
+
+    extendedStatus->isValid = GT_TRUE;
+
+    /* get Pair Polarity */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        switch((u16Data >> i) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairPolarity[i] = GT_POSITIVE;
+                break;
+            default:
+                extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+            break;
+        }
+    }
+
+    /* get Pair Swap for Channel A and B */
+    if (u16Data & 0x10)
+    {
+        extendedStatus->pairSwap[0] = GT_CHANNEL_A;
+        extendedStatus->pairSwap[1] = GT_CHANNEL_B;
+    }
+    else
+    {
+        extendedStatus->pairSwap[0] = GT_CHANNEL_B;
+        extendedStatus->pairSwap[1] = GT_CHANNEL_A;
+    }
+
+    /* get Pair Swap for Channel C and D */
+    if (u16Data & 0x20)
+    {
+        extendedStatus->pairSwap[2] = GT_CHANNEL_C;
+        extendedStatus->pairSwap[3] = GT_CHANNEL_D;
+    }
+    else
+    {
+        extendedStatus->pairSwap[2] = GT_CHANNEL_D;
+        extendedStatus->pairSwap[3] = GT_CHANNEL_C;
+    }
+
+    /*
+     * get data from 20_5 register for pair skew
+     */
+    if((retVal = hwReadPagedPhyReg(
+                    dev,hwPort,5,QD_REG_PAIR_SKEW_STATUS,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Reading from paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    /* get Pair Skew */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+    }
+
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvctGetAdvExtendedStatus
+*
+* DESCRIPTION:
+*       This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*        Note: Since DSP based cable length in extended status is based on
+*             constants from test results. At present, only E1181, E1111, and
+*             E1112 are available.
+*
+* INPUTS:
+*       dev  - pointer to GT driver structure returned from qdLoadDriver
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*        Supporting Device list:
+*           88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys
+*            in 88E6165 family and 88E6351 family devices
+*
+*******************************************************************************/
+GT_STATUS gvctGetAdvExtendedStatus
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT   port,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS retVal;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gvctGetAdvExtendedStatus_mad(dev, port, extendedStatus);
+#endif
+
+    DBG_INFO(("gvctGetAdvExtendedStatus Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((retVal = gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+        gtDelay(250);
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    switch(phyInfo.exStatusType)
+    {
+        case GT_PHY_EX_STATUS_TYPE1:
+            if((retVal = getExStatus_28(dev,hwPort,&phyInfo,extendedStatus)) != GT_OK)
+            {
+                DBG_INFO(("Getting Extanded Cable Status failed.\n"));
+                break;
+            }
+            break;
+
+        case GT_PHY_EX_STATUS_TYPE2:
+        case GT_PHY_EX_STATUS_TYPE3:
+        case GT_PHY_EX_STATUS_TYPE4:
+        case GT_PHY_EX_STATUS_TYPE5:
+        case GT_PHY_EX_STATUS_TYPE6:
+            if((retVal = getExStatus(dev,hwPort,&phyInfo,extendedStatus)) != GT_OK)
+            {
+                DBG_INFO(("Getting Extanded Cable Status failed.\n"));
+                break;
+            }
+
+            break;
+        default:
+            retVal = GT_NOT_SUPPORTED;
+    }
+
+        gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtAdvVct_mad.c
@@ -0,0 +1,227 @@
+#include <Copyright.h>
+/*******************************************************************************
+* gtAdvVct.c
+*
+* DESCRIPTION:
+*       API for Marvell Virtual Cable Tester.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+#include <msApi.h>
+#include <gtVct.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtSem.h>
+
+#include <madApi.h>
+
+/*******************************************************************************
+* gvctGetAdvCableStatus_mad
+*
+* DESCRIPTION:
+*       This routine perform the advanced virtual cable test for the requested
+*       port and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*       mode - advance VCT mode (either First Peak or Maximum Peak)
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are supporting this API.
+*
+*******************************************************************************/
+GT_STATUS gvctGetAdvCableDiag_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status=GT_OK;
+    GT_BOOL ppuEn;
+    GT_U8 hwPort;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gvctGetCableDiag_mad Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_ADV_VCT_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+
+    if ( mdDiagGetAdvCableStatus(&(dev->mad_dev),port,*((MAD_ADV_VCT_MODE *)&mode),(MAD_ADV_CABLE_STATUS*)cableStatus) != MAD_OK)
+    {
+      DBG_INFO(("Failed to run mdDiagGetAdvCableStatus.\n"));
+      gtSemGive(dev,dev->phyRegsSem);
+      return GT_FALSE;
+    }
+
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;
+}
+
+
+/*******************************************************************************
+* gvctGetAdvExtendedStatus_mad
+*
+* DESCRIPTION:
+*       This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*        Note: Since DSP based cable length in extended status is based on
+*             constants from test results. At present, only E1181, E1111, and
+*             E1112 are available.
+*
+* INPUTS:
+*       dev  - pointer to GT driver structure returned from qdLoadDriver
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*        Supporting Device list:
+*           88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys
+*            in 88E6165 family and 88E6351 family devices
+*
+*******************************************************************************/
+GT_STATUS gvctGetAdvExtendedStatus_mad
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT   port,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS retVal=GT_OK;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gvctGetAdvExtendedStatus_mad Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((retVal = gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+        gtDelay(250);
+    }
+
+    if ( mdDiagGet1000BTExtendedStatus(&(dev->mad_dev),port,(MAD_1000BT_EXTENDED_STATUS*)extendedStatus) != MAD_OK)
+    {
+      DBG_INFO(("Failed to run mdDiagGet1000BTExtendedStatus.\n"));
+      gtSemGive(dev,dev->phyRegsSem);
+      return GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+           DBG_INFO(("Not able to enable PPUEn.\n"));
+           return GT_FALSE;
+        }
+    }
+
+        gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgFdb.c
@@ -0,0 +1,3289 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtBrgFdb.c
+*
+* DESCRIPTION:
+*       API definitions for Multiple Forwarding Databases
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 9 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* Forward function declaration.                                            */
+/****************************************************************************/
+static GT_STATUS atuOperationPerform
+(
+    IN      GT_QD_DEV           *dev,
+    IN      GT_ATU_OPERATION    atuOp,
+    INOUT    GT_EXTRA_OP_DATA    *opData,
+    INOUT     GT_ATU_ENTRY        *atuEntry
+);
+
+static GT_STATUS atuStateAppToDev
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        unicast,
+    IN  GT_U32        state,
+    OUT GT_U32        *newOne
+);
+
+static GT_STATUS atuStateDevToApp
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        unicast,
+    IN  GT_U32        state,
+    OUT GT_U32        *newOne
+);
+
+static GT_STATUS atuGetStats
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_ATU_STAT    *atuStat,
+    OUT GT_U32        *count
+);
+
+
+/*******************************************************************************
+* gfdbSetPortAtuLearnLimit
+*
+* DESCRIPTION:
+*       Port's auto learning limit. When the limit is non-zero value, the number
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame
+*        that ingresses this port with a source MAC address not already in the
+*        address database that is associated with this port will be discarded.
+*        Normal auto-learning will resume on the port as soon as the number of
+*        active unicast MAC addresses associated to this port is less than the
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) dsable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
+*
+* INPUTS:
+*       port  - logical port number
+*       limit - auto learning limit ( 0 ~ 255 )
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetPortAtuLearnLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_U32       limit
+)
+{
+    GT_U16          data, mask;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gfdbSetPortAtuLearnLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Check device if it has fixed ATU Size. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (limit > 0xFF)
+    {
+        DBG_INFO(("Bad Parameter\n"));
+        return GT_BAD_PARAM;
+    }
+
+    mask = 0x80FF;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT_READ))
+        mask |= 0x1000;
+
+    data = (GT_U16) limit;
+
+    /* Set the learn limit bits.                  */
+    retVal = hwSetPortRegBits(dev,hwPort, QD_REG_PORT_ATU_CONTROL, mask, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetPortAtuLearnLimit
+*
+* DESCRIPTION:
+*      Port's auto learning limit. When the limit is non-zero value, the number
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame
+*        that ingresses this port with a source MAC address not already in the
+*        address database that is associated with this port will be discarded.
+*        Normal auto-learning will resume on the port as soon as the number of
+*        active unicast MAC addresses associated to this port is less than the
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) dsable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
+*
+* INPUTS:
+*        port  - logical port number
+*
+* OUTPUTS:
+*        limit - auto learning limit ( 0 ~ 255 )
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetPortAtuLearnLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    OUT GT_U32       *limit
+)
+{
+    GT_U16          data, mask;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gfdbGetPortAtuLearnLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Check device if it has fixed ATU Size. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT_READ))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    mask = 0x9000;
+    data = (GT_U16) 0x1000;
+
+    /* Set the learn limit bits.                  */
+    retVal = hwSetPortRegBits(dev,hwPort, QD_REG_PORT_ATU_CONTROL, mask, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Get the ReadLearnLimit bit. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 0, 8, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *limit = (GT_U32)data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gfdbGetPortAtuLearnCnt
+*
+* DESCRIPTION:
+*       Read the current number of active unicast MAC addresses associated with
+*        the given port. This counter (LearnCnt) is held at zero if learn limit
+*        (gfdbSetPortAtuLearnLimit API) is set to zero.
+*
+* INPUTS:
+*       port  - logical port number
+*
+* OUTPUTS:
+*       count - current auto learning count
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetPortAtuLearnCnt
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_U32       *count
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gfdbGetPortAtuLearnCnt Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Check device if this feature is supported. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the ReadLearnCnt bit. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 15, 1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 0)
+    {
+        /* Set the ReadLearnCnt bit. */
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 15, 1, 1);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+
+    /* Get the LearnCnt bits. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 0, 8, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *count = (GT_U32)data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetAtuAllCount
+*
+* DESCRIPTION:
+*       Counts all entries in the Address Translation Unit.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       count - number of valid entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuAllCount
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32         *count
+)
+{
+    GT_U32          dbNum, maxDbNum, numOfEntries;
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_ATU_STAT        atuStat;
+
+    DBG_INFO(("gfdbGetAtuAllCount Called.\n"));
+
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
+    {
+        atuStat.op = GT_ATU_STATS_ALL;
+        return atuGetStats(dev,&atuStat,count);
+    }
+
+    numOfEntries = 0;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL))
+        maxDbNum = 16;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+        maxDbNum = 64;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+        maxDbNum = 256;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
+        maxDbNum = 4096;
+    else
+        maxDbNum = 1;
+
+    for(dbNum=0; dbNum<maxDbNum; dbNum++)
+    {
+        entry.DBNum = (GT_U16)dbNum;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+            gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+        else
+            gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+        while(1)
+        {
+            retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("Failed.\n"));
+                return retVal;
+            }
+
+            if(IS_BROADCAST_MAC(entry.macAddr))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+                    break;
+                else if(entry.entryState.ucEntryState == 0)
+                    break;
+                numOfEntries++;
+                break;
+            }
+
+            numOfEntries++;
+        }
+    }
+
+    *count = numOfEntries;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetAtuAllCountInDBNum
+*
+* DESCRIPTION:
+*       Counts all entries in the defined FID (or DBNum).
+*
+* INPUTS:
+*       dbNum -
+*
+* OUTPUTS:
+*       count - number of valid entries in FID (or DBNum).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuAllCountInDBNum
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32         dbNum,
+    OUT GT_U32         *count
+)
+{
+    GT_U32          numOfEntries;
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_ATU_STAT        atuStat;
+
+    DBG_INFO(("gfdbGetAtuAllCountInDBNum Called.\n"));
+
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
+    {
+        atuStat.op = GT_ATU_STATS_ALL_FID;
+        atuStat.DBNum = dbNum;
+        return atuGetStats(dev,&atuStat,count);
+    }
+
+    numOfEntries = 0;
+
+    entry.DBNum = (GT_U16)dbNum;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+    else
+        gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+    while(1)
+    {
+        retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if(IS_BROADCAST_MAC(entry.macAddr))
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+                break;
+            else if(entry.entryState.ucEntryState == 0)
+                break;
+            numOfEntries++;
+            break;
+        }
+
+        numOfEntries++;
+    }
+
+    *count = numOfEntries;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetAtuDynamicCountInDBNum
+*
+* DESCRIPTION:
+*       Counts all non-static entries in the defined FID (or DBNum).
+*
+* INPUTS:
+*       dbNum -
+*
+* OUTPUTS:
+*       count - number of valid non-static entries in FID (or DBNum).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuDynamicCountInDBNum
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32         dbNum,
+    OUT GT_U32         *count
+)
+{
+    GT_U32          numOfEntries, tmpState;
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_ATU_UC_STATE    state;
+    GT_ATU_STAT        atuStat;
+
+    DBG_INFO(("gfdbGetAtuDynamicCountInDBNum Called.\n"));
+
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
+    {
+        atuStat.op = GT_ATU_STATS_NON_STATIC_FID;
+        atuStat.DBNum = dbNum;
+        return atuGetStats(dev,&atuStat,count);
+    }
+
+    numOfEntries = 0;
+
+    entry.DBNum = (GT_U16)dbNum;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+    else
+        gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+    while(1)
+    {
+        retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if(IS_BROADCAST_MAC(entry.macAddr))
+            break;
+
+        if(IS_MULTICAST_MAC(entry.macAddr))
+        {
+            continue;
+        }
+
+        atuStateDevToApp(dev,GT_TRUE,entry.entryState.ucEntryState,&tmpState);
+        state = (GT_ATU_UC_STATE)tmpState;
+        if (state == GT_UC_DYNAMIC)
+        {
+            numOfEntries++;
+        }
+    }
+
+    *count = numOfEntries;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gfdbSetAtuSize
+*
+* DESCRIPTION:
+*       Sets the Mac address table size.
+*
+* INPUTS:
+*       size    - Mac address table size.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetAtuSize
+(
+    IN GT_QD_DEV    *dev,
+    IN ATU_SIZE     size
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gfdbSetAtuSize Called.\n"));
+
+    switch(size)
+    {
+        case ATU_SIZE_256:
+            if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
+                data = 0;
+            else
+                return GT_NOT_SUPPORTED;
+            break;
+        case ATU_SIZE_512:
+        case ATU_SIZE_1024:
+        case ATU_SIZE_2048:
+            if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
+                data = (GT_U16)size;
+            else
+                data = (GT_U16)size - 1;
+            break;
+
+        case ATU_SIZE_4096:
+            if ((IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))||(IS_IN_DEV_GROUP(dev,DEV_ATU_562_2048)))
+                return GT_NOT_SUPPORTED;
+            else
+                data = 3;
+            break;
+        default:
+            return GT_NOT_SUPPORTED;
+    }
+
+    /* Check device if it has fixed ATU Size. */
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_SIZE_FIXED))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set the Software reset bit.                  */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Make sure the reset operation is completed.  */
+#ifdef GT_RMGMT_ACCESS
+    /*    if (IS_IN_DEV_GROUP(dev,DEV_RMGMT)) */
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_1;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_GLOBAL_STATUS;
+      regAccess.rw_reg_list[0].data = 11;
+
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->atuRegsSem);
+        return retVal;
+      }
+    }
+#else
+    {
+    data = 0;
+    while(data == 0)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,11,1,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+    }
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetAgingTimeRange
+*
+* DESCRIPTION:
+*       Gets the maximal and minimum age times that the hardware can support.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       maxTimeout - max aging time in secounds.
+*       minTimeout - min aging time in secounds.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAgingTimeRange
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_U32 *maxTimeout,
+    OUT GT_U32 *minTimeout
+)
+{
+    DBG_INFO(("gfdbGetAgingTimeRange Called.\n"));
+    if((maxTimeout == NULL) || (minTimeout == NULL))
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
+    {
+        *minTimeout = 15;
+        *maxTimeout = 3825;
+    }
+    else
+    {
+        *minTimeout = 16;
+        *maxTimeout = 4080;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetAgingTimeout
+*
+* DESCRIPTION:
+*       Gets the timeout period in seconds for aging out dynamically learned
+*       forwarding information. The returned value may not be the same as the value
+*        programmed with <gfdbSetAgingTimeout>. Please refer to the description of
+*        <gfdbSetAgingTimeout>.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       timeout - aging time in seconds.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAgingTimeout
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32       *timeout
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U16            timeBase;
+
+    DBG_INFO(("gfdbGetAgingTimeout Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
+        timeBase = 15;
+    else
+        timeBase = 16;
+
+    /* Get the Time Out value.              */
+    retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL,4,8,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *timeout = data*timeBase;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbSetAgingTimeout
+*
+* DESCRIPTION:
+*       Sets the timeout period in seconds for aging out dynamically learned
+*       forwarding information. The standard recommends 300 sec.
+*        Supported aging timeout values are multiple of time-base, where time-base
+*        is either 15 or 16 seconds, depending on the Switch device. For example,
+*        88E6063 uses time-base 16, and so supported aging timeouts are 0,16,32,
+*        48,..., and 4080. If unsupported timeout value (bigger than 16) is used,
+*        the value will be rounded to the nearest supported value smaller than the
+*        given timeout. If the given timeout is less than 16, minimum timeout value
+*        16 will be used instead. E.g.) 35 becomes 32 and 5 becomes 16.
+*        <gfdbGetAgingTimeRange> function can be used to find the time-base.
+*
+* INPUTS:
+*       timeout - aging time in seconds.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetAgingTimeout
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32 timeout
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U16            timeBase;
+
+    DBG_INFO(("gfdbSetAgingTimeout Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
+        timeBase = 15;
+    else
+        timeBase = 16;
+
+    if((timeout < timeBase) && (timeout != 0))
+    {
+        data = 1;
+    }
+    else
+    {
+        data = (GT_U16)(timeout/timeBase);
+       if (data & 0xFF00)
+            data = 0xFF;
+    }
+
+    /* Set the Time Out value.              */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,4,8,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetLearn2All
+*
+* DESCRIPTION:
+*        When more than one Marvell device is used to form a single 'switch', it
+*        may be desirable for all devices in the 'switch' to learn any address this
+*        device learns. When this bit is set to a one all other devices in the
+*        'switch' learn the same addresses this device learns. When this bit is
+*        cleared to a zero, only the devices that actually receive frames will learn
+*        from those frames. This mode typically supports more active MAC addresses
+*        at one time as each device in the switch does not need to learn addresses
+*        it may nerver use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*
+*******************************************************************************/
+GT_STATUS gfdbGetLearn2All
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetLearn2All Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if ((!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_88EC000_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Learn2All. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gfdbSetLearn2All
+*
+* DESCRIPTION:
+*        Enable or disable Learn2All mode.
+*
+* INPUTS:
+*        mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetLearn2All
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gprtSetLearn2All Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if ((!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_88EC000_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Learn2All. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gfdbGetMacAvb
+*
+* DESCRIPTION:
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and
+*            GT_UC_STATIC_AVB_ENTRY
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
+*
+*        When disabled, ATU entries operate in non-AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and
+*            GT_UC_STATIC_NRL
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if MacAvb is enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*
+*******************************************************************************/
+GT_STATUS gfdbGetMacAvb
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gfdbGetMacAvb Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MAC_AVB))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the bit. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL, 15, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gfdbSetMacAvb
+*
+* DESCRIPTION:
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and
+*            GT_UC_STATIC_AVB_ENTRY
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
+*
+*        When disabled, ATU entries operate in non-AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and
+*            GT_UC_STATIC_NRL
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*
+* INPUTS:
+*        mode - GT_TRUE to enable MacAvb, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetMacAvb
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gprtSetMacAvb Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MAC_AVB))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the bit */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL, 15, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gfdbGetAtuDynamicCount
+*
+* DESCRIPTION:
+*       Gets the current number of dynamic unicast (non-static) entries in this
+*       Filtering Database.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numDynEntries - number of dynamic entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuDynamicCount
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32         *numDynEntries
+)
+{
+    GT_U32          dbNum, maxDbNum, numOfEntries, tmpState;
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_ATU_UC_STATE    state;
+    GT_ATU_STAT        atuStat;
+
+    DBG_INFO(("gfdbGetAtuDynamicCount Called.\n"));
+
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
+    {
+        atuStat.op = GT_ATU_STATS_NON_STATIC;
+        return atuGetStats(dev,&atuStat,numDynEntries);
+    }
+
+    numOfEntries = 0;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL))
+        maxDbNum = 16;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+        maxDbNum = 64;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+        maxDbNum = 256;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
+        maxDbNum = 4096;
+    else
+        maxDbNum = 1;
+
+    for(dbNum=0; dbNum<maxDbNum; dbNum++)
+    {
+        entry.DBNum = (GT_U16)dbNum;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+            gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+        else
+            gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+        while(1)
+        {
+            retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("Failed.\n"));
+                return retVal;
+            }
+
+            if(IS_BROADCAST_MAC(entry.macAddr))
+                break;
+
+            if(IS_MULTICAST_MAC(entry.macAddr))
+            {
+                continue;
+            }
+
+            atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,&tmpState);
+            state = (GT_ATU_UC_STATE)tmpState;
+            if (state == GT_UC_DYNAMIC)
+            {
+                numOfEntries++;
+            }
+        }
+    }
+
+    *numDynEntries = numOfEntries;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic MAC address entry from the ATU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from Mac[00:00:00:00:00:00]
+*
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuEntryFirst
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_ATU_ENTRY    *atuEntry
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_U32 data;
+
+    DBG_INFO(("gfdbGetAtuEntryFirst Called.\n"));
+
+    if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+    else
+        gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+    entry.DBNum = atuEntry->DBNum;
+
+    DBG_INFO(("DBNum : %i\n",entry.DBNum));
+
+    retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    if(IS_BROADCAST_MAC(entry.macAddr))
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
+        else if(entry.entryState.ucEntryState == 0)
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
+    }
+
+    gtMemCpy(atuEntry->macAddr.arEther,entry.macAddr.arEther,6);
+    atuEntry->portVec   = GT_PORTVEC_2_LPORTVEC(entry.portVec);
+    atuEntry->prio      = entry.prio;
+    atuEntry->trunkMember = entry.trunkMember;
+    atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
+    atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
+    atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
+
+    if(IS_MULTICAST_MAC(entry.macAddr))
+    {
+        if(dev->deviceId == GT_88E6051)
+        {
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+        }
+
+        atuStateDevToApp(dev,GT_FALSE,entry.entryState.ucEntryState,
+                        &data);
+        atuEntry->entryState.mcEntryState = data;
+    }
+    else
+    {
+        atuStateDevToApp(dev,GT_TRUE,entry.entryState.ucEntryState,
+                        &data);
+        atuEntry->entryState.ucEntryState = data;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic MAC address from the specified Mac Addr.
+*
+* INPUTS:
+*       atuEntry - the Mac Address to start the search.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
+*       user.
+*
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuEntryNext
+(
+    IN GT_QD_DEV    *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_U32 data;
+
+    DBG_INFO(("gfdbGetAtuEntryNext Called.\n"));
+
+    if(IS_BROADCAST_MAC(atuEntry->macAddr))
+    {
+           return GT_NO_SUCH;
+    }
+
+    gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+
+    entry.DBNum = atuEntry->DBNum;
+    DBG_INFO(("DBNum : %i\n",entry.DBNum));
+
+    retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    if(IS_BROADCAST_MAC(entry.macAddr))
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
+        else if(entry.entryState.ucEntryState == 0)
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
+    }
+
+    gtMemCpy(atuEntry->macAddr.arEther,entry.macAddr.arEther,6);
+    atuEntry->portVec   = GT_PORTVEC_2_LPORTVEC(entry.portVec);
+    atuEntry->prio      = entry.prio;
+    atuEntry->trunkMember = entry.trunkMember;
+    atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
+    atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
+    atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
+
+    if(IS_MULTICAST_MAC(entry.macAddr))
+    {
+        if(dev->deviceId == GT_88E6051)
+        {
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+        }
+
+        atuStateDevToApp(dev,GT_FALSE,(GT_U32)entry.entryState.ucEntryState,
+                        &data);
+        atuEntry->entryState.mcEntryState = data;
+    }
+    else
+    {
+        atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,
+                        &data);
+        atuEntry->entryState.ucEntryState = data;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gfdbFindAtuMacEntry
+*
+* DESCRIPTION:
+*       Find FDB entry for specific MAC address from the ATU.
+*
+* INPUTS:
+*       atuEntry - the Mac address to search.
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       atuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*       GT_BAD_PARAM    - on bad parameter
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbFindAtuMacEntry
+(
+    IN GT_QD_DEV    *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry,
+    OUT GT_BOOL         *found
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    int           i;
+    GT_U32 data;
+
+    DBG_INFO(("gfdbFindAtuMacEntry Called.\n"));
+    *found = GT_FALSE;
+    gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+    entry.DBNum = atuEntry->DBNum;
+    /* Decrement 1 from mac address.    */
+    for(i=5; i >= 0; i--)
+    {
+        if(entry.macAddr.arEther[i] != 0)
+        {
+            entry.macAddr.arEther[i] -= 1;
+            break;
+        }
+        else
+            entry.macAddr.arEther[i] = 0xFF;
+    }
+
+    /* Check if the given mac equals zero   */
+    if((i == -1) && IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+    {
+        DBG_INFO(("Address should not be all zeros.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(IS_BROADCAST_MAC(entry.macAddr))
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        {
+            DBG_INFO(("Failed (Broadcast addr is not valid).\n"));
+            return GT_NO_SUCH;
+        }
+        else if(entry.entryState.ucEntryState == 0)
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
+    }
+    if(gtMemCmp((char*)atuEntry->macAddr.arEther,(char*)entry.macAddr.arEther,ETHERNET_HEADER_SIZE))
+    {
+#ifdef __KERNELL__
+      DBG_INFO(("@@@@@@@@@@@@@  error gfdbFindAtuMacEntry:check: %02x:%02x:%02x:%02x:%02x:%02x get: %02x:%02x:%02x:%02x:%02x:%02x\n",
+      atuEntry->macAddr.arEther[0],
+      atuEntry->macAddr.arEther[1],
+      atuEntry->macAddr.arEther[2],
+      atuEntry->macAddr.arEther[3],
+      atuEntry->macAddr.arEther[4],
+      atuEntry->macAddr.arEther[5],
+      entry.macAddr.arEther[0],
+      entry.macAddr.arEther[1],
+      entry.macAddr.arEther[2],
+      entry.macAddr.arEther[3],
+      entry.macAddr.arEther[4],
+      entry.macAddr.arEther[5]
+      ));
+#endif
+        DBG_INFO(("Failed.\n"));
+        return GT_NO_SUCH;
+    }
+
+    atuEntry->portVec   = GT_PORTVEC_2_LPORTVEC(entry.portVec);
+    atuEntry->prio      = entry.prio;
+    atuEntry->trunkMember = entry.trunkMember;
+    atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
+    atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
+    atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
+
+    if(IS_MULTICAST_MAC(entry.macAddr))
+    {
+        if(dev->deviceId == GT_88E6051)
+        {
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+        }
+
+        atuStateDevToApp(dev,GT_FALSE,(GT_U32)entry.entryState.ucEntryState,
+                        &data);
+        atuEntry->entryState.mcEntryState = data;
+    }
+    else
+    {
+        atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,
+                        &data);
+        atuEntry->entryState.ucEntryState = data;
+    }
+
+    *found = GT_TRUE;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gfdbFlush
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the MAC Address
+*       Table.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbFlush
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_FLUSH_CMD flushCmd
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbFlush Called.\n"));
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    entry.DBNum = 0;
+    entry.entryState.ucEntryState = 0;
+
+    if(flushCmd == GT_FLUSH_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL,NULL,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED,NULL,&entry);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbFlushInDB
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the particular
+*       ATU Database (DBNum). If multiple address databases are being used, this
+*        API can be used to flush entries in a particular DBNum database.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*        DBNum     - ATU MAC Address Database Number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbFlushInDB
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_FLUSH_CMD flushCmd,
+    IN GT_U32 DBNum
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbFlush Called.\n"));
+    DBG_INFO(("gfdbFush: dev=%x, dev->atuRegsSem=%d \n",dev, dev->atuRegsSem));
+
+    /* check if device supports this feature */
+    if ((!IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL)) &&
+        (!IS_IN_DEV_GROUP(dev,DEV_DBNUM_64)) &&
+        (!IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096)) &&
+        (!IS_IN_DEV_GROUP(dev,DEV_DBNUM_256)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    entry.DBNum = (GT_U16)DBNum;
+    entry.entryState.ucEntryState = 0;
+
+    if(flushCmd == GT_FLUSH_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL_IN_DB,NULL,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED_IN_DB,NULL,&entry);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbMove
+*
+* DESCRIPTION:
+*       This routine moves all or unblocked addresses from a port to another.
+*
+* INPUTS:
+*         moveCmd  - the move operation type.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMove
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD  moveCmd,
+    IN GT_LPORT        moveFrom,
+    IN GT_LPORT        moveTo
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_EXTRA_OP_DATA    opData;
+
+    DBG_INFO(("gfdbMove Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    entry.DBNum = 0;
+    entry.entryState.ucEntryState = 0xF;
+    if (moveTo == 0xF)
+        opData.moveTo = moveTo;
+    else
+        opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
+    opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
+
+    if((opData.moveTo == 0xFF) || (opData.moveFrom == 0xFF))
+        return GT_BAD_PARAM;
+
+    if(moveCmd == GT_MOVE_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL,&opData,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED,&opData,&entry);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbMoveInDB
+*
+* DESCRIPTION:
+*       This routine move all or unblocked addresses which are in the particular
+*       ATU Database (DBNum) from a port to another.
+*
+* INPUTS:
+*       moveCmd  - the move operation type.
+*        DBNum     - ATU MAC Address Database Number.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMoveInDB
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_U32         DBNum,
+    IN GT_LPORT        moveFrom,
+    IN GT_LPORT        moveTo
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_EXTRA_OP_DATA    opData;
+
+    DBG_INFO(("gfdbMoveInDB Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    entry.DBNum = (GT_U16)DBNum;
+    entry.entryState.ucEntryState = 0xF;
+
+    if (moveTo == 0xF)
+        opData.moveTo = moveTo;
+    else
+        opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
+    opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
+
+    if((opData.moveTo == 0xFF) || (opData.moveFrom == 0xFF))
+        return GT_BAD_PARAM;
+
+    if(moveCmd == GT_MOVE_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL_IN_DB,&opData,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED_IN_DB,&opData,&entry);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbRemovePort
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port.
+*
+* INPUTS:
+*       moveCmd - the move operation type.
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbRemovePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port
+)
+{
+    DBG_INFO(("gfdbRemovePort Called.\n"));
+
+    return gfdbMove(dev,moveCmd,port,(GT_LPORT)0xF);
+}
+
+
+/*******************************************************************************
+* gfdbRemovePortInDB
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port in the
+*       particular ATU Database (DBNum).
+*
+* INPUTS:
+*       moveCmd  - the move operation type.
+*       port - the logical port number.
+*        DBNum     - ATU MAC Address Database Number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbRemovePortInDB
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port,
+    IN GT_U32         DBNum
+)
+{
+    DBG_INFO(("gfdbRemovePortInDB Called.\n"));
+
+    return gfdbMoveInDB(dev,moveCmd,DBNum,port,(GT_LPORT)0xF);
+}
+
+
+/*******************************************************************************
+* gfdbAddMacEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in MAC address table.
+*
+* INPUTS:
+*       macEntry    - mac address entry to insert to the ATU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK          - on success
+*       GT_FAIL        - on error
+*       GT_BAD_PARAM   - on invalid port vector
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbAddMacEntry
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ATU_ENTRY *macEntry
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    GT_U32 data;
+
+    DBG_INFO(("gfdbAddMacEntry Called.\n"));
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtMemCpy(entry.macAddr.arEther,macEntry->macAddr.arEther,6);
+    entry.DBNum        = macEntry->DBNum;
+    entry.portVec     = GT_LPORTVEC_2_PORTVEC(macEntry->portVec);
+    if(entry.portVec == GT_INVALID_PORT_VEC)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_FQPRI_IN_TABLE))
+        {
+            entry.exPrio.useMacFPri = macEntry->exPrio.useMacFPri;
+            entry.exPrio.macFPri = macEntry->exPrio.macFPri;
+            entry.exPrio.macQPri = macEntry->exPrio.macQPri;
+        }
+        else
+        {
+            entry.exPrio.useMacFPri = 0;
+            entry.exPrio.macFPri = macEntry->exPrio.macQPri;
+            entry.exPrio.macQPri = macEntry->exPrio.macQPri;
+        }
+        entry.prio        = 0;
+    }
+    else
+    {
+        entry.exPrio.useMacFPri = 0;
+        entry.exPrio.macFPri = 0;
+        entry.exPrio.macQPri = 0;
+        entry.prio        = macEntry->prio;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        entry.trunkMember = macEntry->trunkMember;
+    }
+    else
+    {
+        entry.trunkMember = GT_FALSE;
+    }
+
+    if(IS_MULTICAST_MAC(entry.macAddr))
+    {
+        atuStateAppToDev(dev,GT_FALSE,(GT_U32)macEntry->entryState.mcEntryState,
+                        &data);
+        entry.entryState.ucEntryState = data;
+    }
+    else
+    {
+        atuStateAppToDev(dev,GT_TRUE,(GT_U32)macEntry->entryState.ucEntryState,
+                        &data);
+        entry.entryState.ucEntryState = data;
+    }
+
+    if (entry.entryState.ucEntryState == 0)
+    {
+        DBG_INFO(("Entry State should not be ZERO.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gfdbDelMacEntry
+*
+* DESCRIPTION:
+*       Deletes MAC address entry. If DBNum or FID is used, gfdbDelAtuEntry API
+*        would be the better choice to delete an entry in ATU.
+*
+* INPUTS:
+*       macAddress - mac address.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gfdbDelMacEntry
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR  *macAddress
+)
+{
+    GT_STATUS retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbDelMacEntry Called.\n"));
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtMemCpy(entry.macAddr.arEther,macAddress->arEther,6);
+    entry.DBNum = 0;
+    entry.prio = 0;
+    entry.portVec = 0;
+    entry.entryState.ucEntryState = 0;
+    entry.trunkMember = GT_FALSE;
+    entry.exPrio.useMacFPri = GT_FALSE;
+    entry.exPrio.macFPri = 0;
+    entry.exPrio.macQPri = 0;
+
+    retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbDelAtuEntry
+*
+* DESCRIPTION:
+*       Deletes ATU entry.
+*
+* INPUTS:
+*       atuEntry - the ATU entry to be deleted.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*        DBNum in atuEntry -
+*            ATU MAC Address Database number. If multiple address
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbDelAtuEntry
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ATU_ENTRY  *atuEntry
+)
+{
+    GT_ATU_ENTRY    entry;
+    GT_STATUS retVal;
+
+    DBG_INFO(("gfdbDelMacEntry Called.\n"));
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+    entry.DBNum = atuEntry->DBNum;
+    entry.prio = 0;
+    entry.portVec = 0;
+    entry.entryState.ucEntryState = 0;
+    entry.trunkMember = GT_FALSE;
+    entry.exPrio.useMacFPri = GT_FALSE;
+    entry.exPrio.macFPri = 0;
+    entry.exPrio.macQPri = 0;
+
+    retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gfdbLearnEnable
+*
+* DESCRIPTION:
+*       Enable/disable automatic learning of new source MAC addresses on port
+*       ingress.
+*
+* INPUTS:
+*       en - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbLearnEnable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL  en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_LPORT    port;
+    GT_BOOL        mode;
+
+    DBG_INFO(("gfdbLearnEnable Called.\n"));
+    BOOL_2_BIT(en,data);
+    data = 1 - data;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        mode = (en)?GT_FALSE:GT_TRUE;
+
+        for (port=0; port<dev->numOfPorts; port++)
+        {
+            retVal = gprtSetLearnDisable(dev,port,mode);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("Failed.\n"));
+                return retVal;
+            }
+        }
+    }
+    else
+    {
+        /* Set the Learn Enable bit.            */
+        retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,14,1,data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetLearnEnable
+*
+* DESCRIPTION:
+*       Get automatic learning status of new source MAC addresses on port ingress.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       en - GT_TRUE if enabled  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetLearnEnable
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_BOOL  *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gfdbGetLearnEnable Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+    else
+    {
+        /* Get the Learn Enable bit.            */
+        retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL,14,1,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+
+    data = 1 - data;
+    BOOL_2_BIT(data, *en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* gatuGetViolation
+*
+* DESCRIPTION:
+*       Get ATU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*        This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gatuGetViolation
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_ATU_INT_STATUS *atuIntStatus
+)
+{
+    GT_U16              intCause;
+    GT_STATUS           retVal;
+    GT_ATU_ENTRY        entry;
+    GT_EXTRA_OP_DATA    opData;
+    GT_BOOL                found, ageInt;
+
+    DBG_INFO(("gatuGetViolation Called.\n"));
+
+    /* check which Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,3,1,&intCause);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("ERROR to read ATU OPERATION Register.\n"));
+        return retVal;
+    }
+
+    if (!intCause)
+    {
+        /* No Violation occurred. */
+        atuIntStatus->atuIntCause = 0;
+        return GT_OK;
+    }
+
+    entry.DBNum = 0;
+
+    retVal = atuOperationPerform(dev,SERVICE_VIOLATIONS,&opData,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    gtMemCpy(atuIntStatus->macAddr.arEther,entry.macAddr.arEther,6);
+
+    atuIntStatus->atuIntCause = (GT_U16)opData.intCause;
+    atuIntStatus->spid = entry.entryState.ucEntryState;
+    atuIntStatus->dbNum = qdShort2Char(entry.DBNum);
+
+    if(atuIntStatus->spid != 0xF)
+        atuIntStatus->spid = (GT_U8)GT_PORT_2_LPORT(atuIntStatus->spid);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    {
+        if (opData.intCause == GT_AGE_VIOLATION)
+        {
+            atuIntStatus->atuIntCause = GT_AGE_OUT_VIOLATION;
+        }
+        else if (opData.intCause == GT_MISS_VIOLATION)
+        {
+            /* check if it's AGE Violation */
+            if((retVal = gsysGetAgeInt(dev, &ageInt)) != GT_OK)
+                return retVal;
+
+            if(ageInt)
+            {
+                gfdbFindAtuMacEntry(dev, &entry, &found);
+                if ((found) && (entry.entryState.ucEntryState <= 4))
+                    atuIntStatus->atuIntCause = GT_AGE_VIOLATION;
+            }
+
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* atuOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all ATU control functions, and is responsible
+*       to write the required operation into the ATU registers.
+*
+* INPUTS:
+*       atuOp       - The ATU operation bits to be written into the ATU
+*                     operation register.
+*       DBNum       - ATU Database Number for CPU accesses
+*       entryPri    - The EntryPri field in the ATU Data register.
+*       portVec     - The portVec field in the ATU Data register.
+*       entryState  - The EntryState field in the ATU Data register.
+*       atuMac      - The Mac address to be written to the ATU Mac registers.
+*
+* OUTPUTS:
+*       entryPri    - The EntryPri field in case the atuOp is GetNext.
+*       portVec     - The portVec field in case the atuOp is GetNext.
+*       entryState  - The EntryState field in case the atuOp is GetNext.
+*       atuMac      - The returned Mac address in case the atuOp is GetNext.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  if atuMac == NULL, nothing needs to be written to ATU Mac registers.
+*
+*******************************************************************************/
+static GT_STATUS atuOperationPerform
+(
+    IN      GT_QD_DEV           *dev,
+    IN      GT_ATU_OPERATION    atuOp,
+    INOUT    GT_EXTRA_OP_DATA    *opData,
+    INOUT     GT_ATU_ENTRY        *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U16          opcodeData;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           i;
+    GT_U16            portMask;
+
+    gtSemTake(dev,dev->atuRegsSem,OS_WAIT_FOREVER);
+
+    portMask = (1 << dev->maxPorts) - 1;
+
+    /* Wait until the ATU in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_ATU_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->atuRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    opcodeData = 0;
+
+    switch (atuOp)
+    {
+        case LOAD_PURGE_ENTRY:
+                if ((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY) &&
+                    (!((IS_IN_DEV_GROUP(dev,DEV_88EC000_FAMILY))||
+                       (IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY))))) ||
+                    IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+                {
+                    if (IS_IN_DEV_GROUP(dev,DEV_TRUNK) && entry->trunkMember)
+                    {
+                        /* portVec represents trunk ID */
+                        data = (GT_U16)( 0x8000 | (((entry->portVec) & 0xF) << 4) |
+                             (((entry->entryState.ucEntryState) & 0xF)) );
+                    }
+                    else
+                    {
+                        data = (GT_U16)( (((entry->portVec) & portMask) << 4) |
+                             (((entry->entryState.ucEntryState) & 0xF)) );
+                    }
+                    opcodeData |= (entry->prio & 0x7) << 8;
+                }
+                else if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
+                {
+                  if(IS_IN_DEV_GROUP(dev,DEV_MACPRI_IN_TABLE))
+                  {
+                    data = (GT_U16)( (((entry->portVec) & portMask) << 4) |
+                             ((entry->entryState.ucEntryState) & 0xF) );
+                    data |= ((entry->prio & 0x7) << 13);
+                  }
+                  else
+                  {
+                    data = (GT_U16)( (((entry->portVec) & portMask) << 4) |
+                             (((entry->entryState.ucEntryState) & 0xF)) |
+                             (((entry->exPrio.macQPri) & 0x3) << 14) );
+                    if(entry->exPrio.useMacFPri == GT_TRUE)
+                        data |= ((1 << 13) | ((entry->exPrio.macFPri & 0x7) << 10));
+                  }
+                }
+                else
+                {
+                    data = (GT_U16)( (((entry->prio) & 0x3) << 14) |
+                            (((entry->portVec) & portMask) << 4) |
+                            (((entry->entryState.ucEntryState) & 0xF)) );
+                }
+                retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->atuRegsSem);
+                    return retVal;
+                }
+                /* pass thru */
+
+        case GET_NEXT_ENTRY:
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      for(i = 0; i < 3; i++)
+      {
+        data=(entry->macAddr.arEther[2*i] << 8)|(entry->macAddr.arEther[1 + 2*i]);
+        regAccess.rw_reg_list[i].cmd = HW_REG_WRITE;
+        regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+        regAccess.rw_reg_list[i].reg = QD_REG_ATU_MAC_BASE+i;
+        regAccess.rw_reg_list[i].data = data;
+      }
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->atuRegsSem);
+        return retVal;
+      }
+    }
+#else
+                for(i = 0; i < 3; i++)
+                {
+                    data=(entry->macAddr.arEther[2*i] << 8)|(entry->macAddr.arEther[1 + 2*i]);
+                    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),data);
+                    if(retVal != GT_OK)
+                    {
+                        gtSemGive(dev,dev->atuRegsSem);
+                        return retVal;
+                    }
+                }
+#endif
+                break;
+
+        case FLUSH_ALL:
+        case FLUSH_UNLOCKED:
+        case FLUSH_ALL_IN_DB:
+        case FLUSH_UNLOCKED_IN_DB:
+                if (entry->entryState.ucEntryState == 0xF)
+                {
+                    data = (GT_U16)(0xF | ((opData->moveFrom & 0xF) << 4) | ((opData->moveTo & 0xF) << 8));
+                }
+                else
+                {
+                    data = 0;
+                }
+                retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
+                   if(retVal != GT_OK)
+                {
+                       gtSemGive(dev,dev->atuRegsSem);
+                    return retVal;
+                   }
+                break;
+
+        case SERVICE_VIOLATIONS:
+
+                break;
+
+        default :
+                return GT_FAIL;
+    }
+
+    /* Set DBNum */
+    if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+    {
+        retVal = hwSetGlobalRegField(dev,QD_REG_ATU_FID_REG,0,12,(GT_U16)(entry->DBNum & 0xFFF));
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+    }
+    else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+    {
+        retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,4,(GT_U16)((entry->DBNum & 0xF0) >> 4));
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+    }
+    else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+    {
+        opcodeData |= ((entry->DBNum & 0x30) << 4);    /* Op Reg bit 9:8 */
+    }
+
+    /* Set the ATU Operation register in addtion to DBNum setup  */
+
+    if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        opcodeData |= ((1 << 15) | (atuOp << 12));
+    else
+    {
+        opcodeData |= ((1 << 15) | (atuOp << 12) | (entry->DBNum & 0xF));
+    }
+
+    retVal = hwWriteGlobalReg(dev,QD_REG_ATU_OPERATION,opcodeData);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->atuRegsSem);
+        return retVal;
+    }
+
+    /* If the operation is to service violation operation wait for the response   */
+    if(atuOp == SERVICE_VIOLATIONS)
+    {
+        /* Wait until the VTU in ready. */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 1;
+
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_ATU_OPERATION;
+          regAccess.rw_reg_list[0].data = 15;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->atuRegsSem);
+          return retVal;
+          }
+        }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+        }
+#endif
+
+        /* get the Interrupt Cause */
+        retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,4,4,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+        if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+        {
+            data &= 0x7;    /* only 3 bits are valid for non age_out_int group */
+        }
+
+        switch (data)
+        {
+            case 8:    /* Age Interrupt */
+                opData->intCause = GT_AGE_VIOLATION;
+                break;
+            case 4:    /* Member Violation */
+                opData->intCause = GT_MEMBER_VIOLATION;
+                break;
+            case 2:    /* Miss Violation */
+                opData->intCause = GT_MISS_VIOLATION;
+                break;
+            case 1:    /* Full Violation */
+                opData->intCause = GT_FULL_VIOLATION;
+                break;
+            default:
+                opData->intCause = 0;
+                gtSemGive(dev,dev->atuRegsSem);
+                return GT_OK;
+        }
+
+        /* get the DBNum that was involved in the violation */
+
+        entry->DBNum = 0;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_FID_REG,0,12,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->DBNum = (GT_U16)data;
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,4,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->DBNum = (GT_U16)data << 4;
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,8,2,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->DBNum = (GT_U16)data << 4;
+        }
+
+        if(!IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,0,4,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+
+            entry->DBNum |= (GT_U8)(data & 0xF);
+        }
+
+        /* get the Source Port ID that was involved in the violation */
+
+        retVal = hwReadGlobalReg(dev,QD_REG_ATU_DATA_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+
+        entry->entryState.ucEntryState = data & 0xF;
+
+        /* Get the Mac address  */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 3;
+
+          for(i = 0; i < 3; i++)
+          {
+            regAccess.rw_reg_list[i].cmd = HW_REG_READ;
+            regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+            regAccess.rw_reg_list[i].reg = QD_REG_ATU_MAC_BASE+i;
+            regAccess.rw_reg_list[i].data = 0;
+          }
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+          }
+          for(i = 0; i < 3; i++)
+          {
+            entry->macAddr.arEther[2*i] = qdLong2Char(regAccess.rw_reg_list[i].data >> 8);
+            entry->macAddr.arEther[1 + 2*i] = qdLong2Char(regAccess.rw_reg_list[i].data & 0xFF);
+          }
+        }
+#else
+        for(i = 0; i < 3; i++)
+        {
+            retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->macAddr.arEther[2*i] = data >> 8;
+            entry->macAddr.arEther[1 + 2*i] = data & 0xFF;
+        }
+#endif
+
+
+    } /* end of service violations */
+    /* If the operation is a gen next operation wait for the response   */
+    if(atuOp == GET_NEXT_ENTRY)
+    {
+        entry->trunkMember = GT_FALSE;
+        entry->exPrio.useMacFPri = GT_FALSE;
+        entry->exPrio.macFPri = 0;
+        entry->exPrio.macQPri = 0;
+
+        /* Wait until the ATU in ready. */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 5;
+
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_ATU_OPERATION;
+          regAccess.rw_reg_list[0].data = 15;
+
+          for(i = 1; i < 4; i++)
+          {
+            regAccess.rw_reg_list[i].cmd = HW_REG_READ;
+            regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+            regAccess.rw_reg_list[i].reg = QD_REG_ATU_MAC_BASE+i-1;
+            regAccess.rw_reg_list[i].data = 0;
+          }
+
+          regAccess.rw_reg_list[4].cmd = HW_REG_READ;
+          regAccess.rw_reg_list[4].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[4].reg = QD_REG_ATU_DATA_REG;
+          regAccess.rw_reg_list[4].data = 0;
+
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+          }
+          for(i = 0; i < 3; i++)
+          {
+            entry->macAddr.arEther[2*i] = qdLong2Char(regAccess.rw_reg_list[i+1].data >> 8);
+            entry->macAddr.arEther[1 + 2*i] = qdLong2Char(regAccess.rw_reg_list[i+1].data & 0xFF);
+          }
+          data = qdLong2Short(regAccess.rw_reg_list[4].data);
+        }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+        }
+
+        /* Get the Mac address  */
+        for(i = 0; i < 3; i++)
+        {
+            retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->macAddr.arEther[2*i] = data >> 8;
+            entry->macAddr.arEther[1 + 2*i] = data & 0xFF;
+        }
+
+        retVal = hwReadGlobalReg(dev,QD_REG_ATU_DATA_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+#endif
+
+        /* Get the Atu data register fields */
+        if ((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY) &&
+            (!((IS_IN_DEV_GROUP(dev,DEV_88EC000_FAMILY))||
+               (IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY))))) ||
+            IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+        {
+            if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+            {
+                entry->trunkMember = (data & 0x8000)?GT_TRUE:GT_FALSE;
+            }
+
+            entry->portVec = (data >> 4) & portMask;
+            entry->entryState.ucEntryState = data & 0xF;
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,8,3,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->prio = (GT_U8)data;
+        }
+        else if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
+        {
+          if(IS_IN_DEV_GROUP(dev,DEV_MACPRI_IN_TABLE))
+          {
+            entry->portVec = (data >> 4) & portMask;
+            entry->entryState.ucEntryState = data & 0xF;
+            entry->prio = (data >> 13) & 0x7;
+            entry->exPrio.macFPri = entry->prio;
+            entry->exPrio.macQPri = entry->prio;
+            entry->prio = 0;
+            entry->exPrio.useMacFPri = GT_FALSE; /* doesn't care */
+          }
+          else
+          {
+            entry->prio = 0;
+            entry->portVec = (data >> 4) & portMask;
+            entry->entryState.ucEntryState = data & 0xF;
+            entry->exPrio.useMacFPri = (data & 0x2000)?GT_TRUE:GT_FALSE;
+            entry->exPrio.macFPri = (data >> 10) & 0x7;
+            entry->exPrio.macQPri = data >> 14;
+          }
+        }
+        else
+        {
+            entry->prio = data >> 14;
+            entry->portVec = (data >> 4) & portMask;
+            entry->entryState.ucEntryState = data & 0xF;
+        }
+    }
+
+    gtSemGive(dev,dev->atuRegsSem);
+    return GT_OK;
+}
+
+static GT_STATUS atuStateAppToDev
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        unicast,
+    IN  GT_U32        state,
+    OUT GT_U32        *newOne
+)
+{
+    GT_U32    newState;
+    GT_STATUS    retVal = GT_OK;
+
+    if(unicast)
+    {
+        switch ((GT_ATU_UC_STATE)state)
+        {
+            case GT_UC_INVALID:
+                newState = state;
+                break;
+
+            case GT_UC_DYNAMIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC))
+                {
+                    newState = 7;
+                }
+                else
+                {
+                    newState = 0xE;
+                }
+                break;
+
+            case GT_UC_NO_PRI_TO_CPU_STATIC_NRL:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_TO_CPU_STATIC_NRL))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_TO_CPU_STATIC_NRL:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_TO_CPU_STATIC_NRL))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_NO_PRI_STATIC_NRL:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_STATIC_NRL))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_STATIC_NRL:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_STATIC_NRL))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_NO_PRI_TO_CPU_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_TO_CPU_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_TO_CPU_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_TO_CPU_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_NO_PRI_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            default:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC))
+                {
+                    newState = 7;
+                }
+                else
+                {
+                    newState = 0xE;
+                }
+                retVal = GT_BAD_PARAM;
+                break;
+
+        }
+    }
+    else
+    {
+        switch ((GT_ATU_UC_STATE)state)
+        {
+            case GT_MC_INVALID:
+                newState = state;
+                break;
+
+            case GT_MC_MGM_STATIC_UNLIMITED_RATE:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_MGM_STATIC_UNLIMITED_RATE))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_STATIC_UNLIMITED_RATE:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_STATIC_UNLIMITED_RATE))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_MGM_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_MGM_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_MGM_STATIC_UNLIMITED_RATE))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_PRIO_STATIC_UNLIMITED_RATE:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_STATIC_UNLIMITED_RATE))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_PRIO_MGM_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_MGM_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_PRIO_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            default:
+                newState = (GT_U32)GT_MC_STATIC;
+                retVal = GT_BAD_PARAM;
+                break;
+
+        }
+    }
+
+    *newOne = newState;
+    return retVal;
+}
+
+static GT_STATUS atuStateDevToApp
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        unicast,
+    IN  GT_U32        state,
+    OUT GT_U32        *newOne
+)
+{
+    GT_U32    newState;
+    GT_STATUS    retVal = GT_OK;
+
+    if(unicast)
+    {
+        if (state == 0)
+        {
+            newState = (GT_U32)GT_UC_INVALID;
+        }
+        else if (state <= 7)
+        {
+            newState = (GT_U32)GT_UC_DYNAMIC;
+        }
+        else if ((state <= 0xE) && (!IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC)))
+        {
+            newState = (GT_U32)GT_UC_DYNAMIC;
+        }
+        else
+        {
+            newState = state;
+        }
+    }
+    else
+    {
+        newState = state;
+    }
+
+    *newOne = newState;
+    return retVal;
+}
+
+
+static GT_STATUS atuGetStats
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_ATU_STAT    *atuStat,
+    OUT GT_U32        *count
+)
+{
+    GT_U32          numOfEntries, dbNum;
+    GT_ATU_ENTRY    entry;
+    GT_U16            data,mode,bin;
+    GT_STATUS       retVal;
+
+    DBG_INFO(("atuGetStats Called.\n"));
+
+    switch (atuStat->op)
+    {
+        case GT_ATU_STATS_ALL:
+        case GT_ATU_STATS_NON_STATIC:
+            dbNum = 0;
+            break;
+        case GT_ATU_STATS_ALL_FID:
+        case GT_ATU_STATS_NON_STATIC_FID:
+            dbNum = atuStat->DBNum;
+            break;
+        default:
+            return GT_FALSE;
+    }
+
+    numOfEntries = 0;
+    mode = atuStat->op;
+
+    for(bin=0; bin<4; bin++)
+    {
+        data = (bin << 14) | (mode << 12);
+
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_ATU_STATS, data);
+           if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+
+        entry.DBNum = (GT_U16)dbNum;
+        gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+
+        retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+           if(retVal == GT_FAIL)
+        {
+               DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev, QD_REG_ATU_STATS, &data);
+           if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+
+        numOfEntries += (data & 0xFFF);
+    }
+
+    *count = numOfEntries;
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgStp.c
@@ -0,0 +1,333 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtBrgStp.c
+*
+* DESCRIPTION:
+*       API definitions to handle port spanning tree state.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+static GT_STATUS enhancedBPDUSet(GT_QD_DEV *dev,GT_BOOL en)
+{
+    GT_STATUS       retVal = GT_OK; /* Functions return value.      */
+    GT_U16            enBits;
+
+    /* If disable, reset the BPDU bit(bit0) from Rsvd2CpuEnables register */
+       if(en == GT_FALSE)
+    {
+        if((retVal = gsysGetRsvd2CpuEnables(dev,&enBits)) != GT_OK)
+        {
+            DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+            return retVal;
+        }
+        enBits &= ~0x1;
+
+        if((retVal = gsysSetRsvd2CpuEnables(dev,enBits)) != GT_OK)
+        {
+            DBG_INFO(("gsysSetRsvd2CpuEnables failed.\n"));
+            return retVal;
+        }
+
+        return retVal;
+    }
+
+    /*
+        If enable,
+        1) Set MGMT Pri bits,
+        2) Set BPDU bit(bit0) from Rsvd2CpuEnables register,
+        3) Enable Rsvd2Cpu
+    */
+    if((retVal = gsysSetMGMTPri(dev,7)) != GT_OK)
+    {
+        DBG_INFO(("gsysSetMGMTPri failed.\n"));
+        return retVal;
+    }
+
+    if((retVal = gsysGetRsvd2CpuEnables(dev,&enBits)) != GT_OK)
+    {
+        DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+        return retVal;
+    }
+    enBits |= 0x1;
+    if((retVal = gsysSetRsvd2CpuEnables(dev,enBits)) != GT_OK)
+    {
+        DBG_INFO(("gsysSetRsvd2CpuEnables failed.\n"));
+        return retVal;
+    }
+
+    if((retVal = gsysSetRsvd2Cpu(dev,GT_TRUE)) != GT_OK)
+    {
+        DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+        return retVal;
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gstpSetMode
+*
+* DESCRIPTION:
+*       This routine Enable the Spanning tree.
+*
+* INPUTS:
+*       en - GT_TRUE for enable, GT_FALSE for disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       when enabled, this function sets all port to blocking state, and inserts
+*       the BPDU MAC into the ATU to be captured to CPU, on disable all port are
+*       being modified to be in forwarding state.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpSetMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_BOOL  en
+)
+{
+    GT_STATUS       retVal = GT_OK; /* Functions return value.      */
+    GT_ATU_ENTRY        atuEntry;   /* The ATU entry data to be set */
+    GT_U32          i, dbNum;
+
+    DBG_INFO(("gstpSetMode Called.\n"));
+    if(dev->deviceId == GT_88E6051)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    if((en == GT_TRUE) && (dev->stpMode == 1))
+    {
+        DBG_INFO(("OK.\n"));
+        return GT_OK;
+    }
+
+    switch(dev->deviceId)
+    {
+        case GT_88E6051:
+        case GT_88E6052:
+            dbNum = 1;
+            break;
+        case GT_FF_HG:
+        case GT_FF_EG:
+        case GT_88E6021:
+        case GT_88E6060:
+        case GT_88E6031:
+        case GT_88E6061:
+        case GT_88E6063:
+        case GT_FH_VPN:
+        case GT_88E6083:
+        case GT_88E6153:
+        case GT_88E6181:
+        case GT_88E6183:
+        case GT_88E6093:
+            dbNum = 16;
+            break;
+        case GT_88E6035:
+        case GT_88E6055:
+        case GT_88E6065:
+            dbNum = 64;
+            break;
+        default:
+            if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+            {
+                dbNum = 64;
+            }
+            else
+            {
+                dbNum = 0;
+                retVal = enhancedBPDUSet(dev,en);
+            }
+            break;
+    }
+
+    for (i=0; i<dbNum; i++)
+    {
+        /* Set the Atu entry parameters.    */
+        atuEntry.macAddr.arEther[0] = 0x01;
+        atuEntry.macAddr.arEther[1] = 0x80;
+        atuEntry.macAddr.arEther[2] = 0xC2;
+        atuEntry.macAddr.arEther[3] = 0x00;
+        atuEntry.macAddr.arEther[4] = 0x00;
+        atuEntry.macAddr.arEther[5] = 0x00;
+        atuEntry.portVec = GT_LPORTVEC_2_PORTVEC((1<<dev->cpuPortNum));
+        if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_FQPRI_IN_TABLE))
+            {
+                atuEntry.exPrio.useMacFPri = GT_TRUE;
+                atuEntry.exPrio.macFPri = 7;
+            }
+            else
+            {
+                atuEntry.exPrio.useMacFPri = 0;
+                atuEntry.exPrio.macFPri = 0;
+            }
+            atuEntry.exPrio.macQPri = 3;
+            atuEntry.prio    = 0;
+        }
+        else
+        {
+            atuEntry.prio    = 3;
+            atuEntry.exPrio.useMacFPri = 0;
+            atuEntry.exPrio.macFPri = 0;
+            atuEntry.exPrio.macQPri = 0;
+        }
+        atuEntry.DBNum = (GT_U8)i;
+        atuEntry.entryState.mcEntryState = GT_MC_PRIO_MGM_STATIC;
+
+        if(en == GT_TRUE)
+        {
+            retVal = gfdbAddMacEntry(dev,&atuEntry);
+        }
+        else
+        {
+            if(dev->stpMode == 0)
+                break;
+            retVal = gfdbDelAtuEntry(dev,&atuEntry);
+        }
+
+        if (retVal != GT_OK)
+            break;
+    }
+
+    if(retVal == GT_OK)
+    {
+        if(en == GT_TRUE)
+            dev->stpMode = 1;
+        else
+            dev->stpMode = 2;
+        DBG_INFO(("OK.\n"));
+    }
+    else
+    {
+           dev->stpMode = 0;
+        DBG_INFO(("Failed.\n"));
+    }
+
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gstpSetPortState
+*
+* DESCRIPTION:
+*       This routine set the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       state - the port state to set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpSetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT           port,
+    IN GT_PORT_STP_STATE  state
+)
+{
+    GT_U8           phyPort;        /* Physical port                */
+    GT_U16          data;           /* Data to write to register.   */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gstpSetPortState Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    data    = state;
+
+    /* Set the port state bits.             */
+    retVal= hwSetPortRegField(dev,phyPort, QD_REG_PORT_CONTROL,0,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gstpGetPortState
+*
+* DESCRIPTION:
+*       This routine returns the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       state - the current port state.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpGetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT           port,
+    OUT GT_PORT_STP_STATE  *state
+)
+{
+    GT_U8           phyPort;        /* Physical port                */
+    GT_U16          data;           /* Data read from register.     */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gstpGetPortState Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* Get the port state bits.             */
+    retVal = hwGetPortRegField(dev,phyPort, QD_REG_PORT_CONTROL,0,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *state = data & 0x3;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgStu.c
@@ -0,0 +1,848 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtBrgStu.c
+*
+* DESCRIPTION:
+*       API definitions for SID (VTU 802.1s Port State Information Database)
+*        Translation Unit.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* Forward function declaration.                                            */
+/****************************************************************************/
+
+static GT_STATUS stuOperationPerform
+(
+    IN        GT_QD_DEV           *dev,
+    IN      GT_STU_OPERATION    stuOp,
+    INOUT   GT_U8               *valid,
+    INOUT     GT_STU_ENTRY        *stuEntry
+);
+
+/*******************************************************************************
+* gstuGetEntryCount
+*
+* DESCRIPTION:
+*       Gets the current number of valid entries in the STU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numEntries - number of STU entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gstuGetEntryCount
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_U32    *numEntries
+)
+{
+    GT_U8               valid;
+    GT_U32                numOfEntries;
+    GT_STATUS           retVal;
+    GT_STU_ENTRY        entry;
+
+    DBG_INFO(("gstuGetEntryCount Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    entry.sid = 0;
+    numOfEntries = 0;
+
+    while(1)
+    {
+        retVal = stuOperationPerform(dev,GET_NEXT_STU_ENTRY,&valid,&entry);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed (stuOperationPerform returned GT_FAIL).\n"));
+            return retVal;
+        }
+
+        if( entry.sid==0x3F )
+        {
+            if (valid==1) numOfEntries++;
+            break;
+        }
+
+        numOfEntries++;
+    }
+
+    *numEntries = numOfEntries;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstuGetEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic entry from the STU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       stuEntry - find the first valid STU entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstuGetEntryFirst
+(
+    IN  GT_QD_DEV       *dev,
+    OUT GT_STU_ENTRY    *stuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_U8               port;
+    GT_LPORT               lport;
+    GT_STU_ENTRY        entry;
+
+    DBG_INFO(("gstuGetEntryFirst Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    entry.sid = 0;
+    valid = 0;
+
+    retVal = stuOperationPerform(dev,GET_NEXT_STU_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (stuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrieve the value from the operation */
+
+    if((entry.sid == 0x3F) && (valid == 0))
+        return GT_NO_SUCH;
+
+    stuEntry->sid = entry.sid;
+
+    for(lport=0; lport<dev->numOfPorts; lport++)
+    {
+        port = GT_LPORT_2_PORT(lport);
+        stuEntry->portState[lport]=entry.portState[port];
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gstuGetEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic STU entry from the specified SID.
+*
+* INPUTS:
+*       stuEntry - the SID to start the search.
+*
+* OUTPUTS:
+*       stuEntry - next STU entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstuGetEntryNext
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_STU_ENTRY  *stuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_U8               port;
+    GT_LPORT               lport;
+    GT_STU_ENTRY        entry;
+
+    DBG_INFO(("gstuGetEntryNext Called.\n"));
+
+    /* check if device supports this feature */
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(stuEntry->sid >= 0x3F)
+    {
+        return GT_NO_SUCH;
+    }
+    else
+    {
+        entry.sid = stuEntry->sid;
+    }
+    valid = 0;
+
+    retVal = stuOperationPerform(dev,GET_NEXT_STU_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (stuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrieve the value from the operation */
+
+    if((entry.sid == 0x3F) && (valid == 0))
+        return GT_NO_SUCH;
+
+    stuEntry->sid = entry.sid;
+
+    for(lport=0; lport<dev->numOfPorts; lport++)
+    {
+        port = GT_LPORT_2_PORT(lport);
+        stuEntry->portState[lport]=entry.portState[port];
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gstuFindSidEntry
+*
+* DESCRIPTION:
+*       Find STU entry for a specific SID, it will return the entry, if found,
+*       along with its associated data
+*
+* INPUTS:
+*       stuEntry - contains the SID to searche for
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       stuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no such entry.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Valid SID is 1 ~ 63.
+*
+*******************************************************************************/
+GT_STATUS gstuFindSidEntry
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_STU_ENTRY  *stuEntry,
+    OUT GT_BOOL         *found
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_U8               port;
+    GT_LPORT            lport;
+    GT_STU_ENTRY        entry;
+
+    DBG_INFO(("gstuFindSidEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((stuEntry->sid == 0) || (stuEntry->sid > 0x3F))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    *found = GT_FALSE;
+
+    /* Decrement 1 from sid */
+    entry.sid   = stuEntry->sid-1;
+    valid = 0; /* valid is not used as input in this operation */
+
+    retVal = stuOperationPerform(dev,GET_NEXT_STU_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (stuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrive the value from the operation */
+    if ((entry.sid != stuEntry->sid) | (valid == 0))
+        return GT_NO_SUCH;
+
+    for(lport=0; lport<dev->numOfPorts; lport++)
+    {
+        port = GT_LPORT_2_PORT(lport);
+        stuEntry->portState[lport]=entry.portState[port];
+    }
+
+    *found = GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gstuAddEntry
+*
+* DESCRIPTION:
+*       Creates or update the entry in STU table based on user input.
+*
+* INPUTS:
+*       stuEntry    - stu entry to insert to the STU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Valid SID is 1 ~ 63.
+*
+*******************************************************************************/
+GT_STATUS gstuAddEntry
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_STU_ENTRY    *stuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_U8           port;
+    GT_LPORT           lport;
+    GT_STU_ENTRY     tmpStuEntry;
+    GT_BOOL             found;
+    int                count = 50000;
+    GT_STU_ENTRY        entry;
+
+    DBG_INFO(("gstuAddEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((stuEntry->sid == 0) || (stuEntry->sid > 0x3F))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    entry.sid = stuEntry->sid;
+
+    valid = 1; /* for load operation */
+
+    for(port=0; port<dev->maxPorts; port++)
+    {
+        lport = GT_PORT_2_LPORT(port);
+        if (lport == GT_INVALID_PORT)
+            entry.portState[port] = 0;
+        else
+            entry.portState[port] = stuEntry->portState[lport];
+    }
+
+    retVal = stuOperationPerform(dev,LOAD_PURGE_STU_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (stuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* verify that the given entry has been added */
+    tmpStuEntry.sid = stuEntry->sid;
+
+    if((retVal = gstuFindSidEntry(dev,&tmpStuEntry,&found)) != GT_OK)
+    {
+        while(count--);
+        if((retVal = gstuFindSidEntry(dev,&tmpStuEntry,&found)) != GT_OK)
+        {
+            DBG_INFO(("Added entry cannot be found\n"));
+            return retVal;
+        }
+    }
+    if(found == GT_FALSE)
+    {
+        DBG_INFO(("Added entry cannot be found\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gstuDelEntry
+*
+* DESCRIPTION:
+*       Deletes STU entry specified by user.
+*
+* INPUTS:
+*       stuEntry - the STU entry to be deleted
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Valid SID is 1 ~ 63.
+*
+*******************************************************************************/
+GT_STATUS gstuDelEntry
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_STU_ENTRY     *stuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_STU_ENTRY        entry;
+
+    DBG_INFO(("gstuDelEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((stuEntry->sid == 0) || (stuEntry->sid > 0x3F))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    entry.sid = stuEntry->sid;
+    valid = 0; /* for delete operation */
+
+    retVal = stuOperationPerform(dev,LOAD_PURGE_STU_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (stuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+static GT_STATUS stuSetSTUData
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_STU_ENTRY        *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data1,data2,data3;           /* Data to be set into the      */
+    GT_U16            nStuData = 0;
+
+    data1 = data2 = data3 = 0;
+
+    switch (dev->maxPorts)
+    {
+        case 11:
+            data3 |= (entry->portState[10] & 3) << 10;
+            /* pass through */
+        case 10:
+            data3 |= (entry->portState[9] & 3) << 6;
+            /* pass through */
+        case 9:
+            data3 |= (entry->portState[8] & 3) << 2;
+            nStuData++;
+
+            /* pass through */
+        case 8:
+            data2 |= (entry->portState[7] & 3) << 14;
+            /* pass through */
+        case 7:
+            data2 |= (entry->portState[6] & 3) << 10;
+            /* pass through */
+        case 6:
+            data2 |= (entry->portState[5] & 3) << 6;
+            /* pass through */
+        case 5:
+            data2 |= (entry->portState[4] & 3) << 2;
+            nStuData++;
+
+            /* pass through */
+        case 4:
+            data1 |= (entry->portState[3] & 3) << 14;
+            /* pass through */
+        case 3:
+            data1 |= (entry->portState[2] & 3) << 10;
+            /* pass through */
+        case 2:
+            data1 |= (entry->portState[1] & 3) << 6;
+            /* pass through */
+        case 1:
+            data1 |= (entry->portState[0] & 3) << 2;
+            nStuData++;
+            break;
+
+        default:
+            return GT_FAIL;
+    }
+
+    switch(nStuData)
+    {
+        case 3:
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data3);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+            /* pass through */
+        case 2:
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA2_REG,data2);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+            /* pass through */
+        case 1:
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA1_REG,data1);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+            break;
+        default:
+            return GT_FAIL;
+    }
+
+    return retVal;
+}
+
+static GT_STATUS stuGetSTUData
+(
+    IN    GT_QD_DEV           *dev,
+    OUT    GT_STU_ENTRY        *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data1,data2,data3;           /* Data to be set into the      */
+    GT_U16            nStuData = 0;
+
+    data1 = data2 = data3 = 0;
+
+    gtMemSet((void*)entry->portState,0,sizeof(entry->portState));
+
+    switch (dev->maxPorts)
+    {
+        case 11:
+        case 10:
+        case 9:
+            nStuData = 3;
+            break;
+
+        case 8:
+        case 7:
+        case 6:
+        case 5:
+            nStuData = 2;
+            break;
+
+        case 4:
+        case 3:
+        case 2:
+        case 1:
+            nStuData = 1;
+            break;
+
+        default:
+            return GT_FAIL;
+    }
+
+    switch(nStuData)
+    {
+        case 3:
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data3);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+            /* pass through */
+        case 2:
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA2_REG,&data2);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+            /* pass through */
+        case 1:
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA1_REG,&data1);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+            break;
+        default:
+            return GT_FAIL;
+    }
+
+    switch (dev->maxPorts)
+    {
+        case 11:
+            entry->portState[10]  = (data3 >> 10) & 3 ;
+            /* pass through */
+        case 10:
+            entry->portState[9]  = (data3 >> 6) & 3 ;
+            /* pass through */
+        case 9:
+            entry->portState[8]  = (data3 >> 2) & 3 ;
+            /* pass through */
+        case 8:
+            entry->portState[7]  = (data2 >> 14) & 3 ;
+            /* pass through */
+        case 7:
+            entry->portState[6]  = (data2 >> 10) & 3 ;
+            /* pass through */
+        case 6:
+            entry->portState[5]  = (data2 >> 6) & 3 ;
+            /* pass through */
+        case 5:
+            entry->portState[4]  = (data2 >> 2) & 3 ;
+            /* pass through */
+        case 4:
+            entry->portState[3]  = (data1 >> 14) & 3 ;
+            /* pass through */
+        case 3:
+            entry->portState[2]  = (data1 >> 10) & 3 ;
+            /* pass through */
+        case 2:
+            entry->portState[1]  = (data1 >> 6) & 3 ;
+            /* pass through */
+        case 1:
+            entry->portState[0]  = (data1 >> 2) & 3 ;
+            break;
+
+        default:
+            return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* stuOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all STU control functions, and is responsible
+*       to write the required operation into the STU registers.
+*
+* INPUTS:
+*       stuOp       - The STU operation bits to be written into the STU
+*                     operation register.
+*       sid         - sid
+*       valid       - valid bit
+*       stuData     - STU Data with port state information
+*
+* OUTPUTS:
+*       sid         - sid
+*       valid       - valid bit
+*       stuData     - STU Data with port state information
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static GT_STATUS stuOperationPerform
+(
+    IN        GT_QD_DEV           *dev,
+    IN      GT_STU_OPERATION    stuOp,
+    INOUT   GT_U8               *valid,
+    INOUT    GT_STU_ENTRY        *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                /* register.                    */
+
+    gtSemTake(dev,dev->vtuRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the VTU in ready. */
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+    }
+
+    /* Set the VTU data register if Load operation is required. */
+    if (stuOp == LOAD_PURGE_STU_ENTRY)
+    {
+        if (*valid == 1)
+        {
+            /* set the Port State for all the ports */
+            retVal = stuSetSTUData(dev,entry);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+
+            /* Set the valid bit (QD_REG_VTU_VID_REG) */
+               data= *valid << 12 ;
+            retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_VID_REG),data);
+               if(retVal != GT_OK)
+            {
+                   gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+                  }
+        }
+        else
+        {
+            /* Clear the valid bit (QD_REG_VTU_VID_REG) */
+               data= 0 ;
+            retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_VID_REG),data);
+               if(retVal != GT_OK)
+            {
+                   gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+                  }
+        }
+    }
+
+    /* Set the SID register (QD_REG_STU_SID_REG) */
+       data= (entry->sid) & 0x3F;
+    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_STU_SID_REG),data);
+       if(retVal != GT_OK)
+    {
+           gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+       }
+
+    /* Start the STU Operation by defining the stuOp and VTUBusy */
+    data = (1 << 15) | (stuOp << 12);
+
+    retVal = hwWriteGlobalReg(dev,QD_REG_VTU_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+    }
+
+    /* If the operation is a get next operation wait for the response   */
+    if(stuOp == GET_NEXT_STU_ENTRY)
+    {
+        /* Wait until the STU in ready. */
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+
+        /****************** get the valid bit *******************/
+        retVal = hwGetGlobalRegField(dev,QD_REG_VTU_VID_REG,12,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        *valid = (GT_U8)data;
+
+        /****************** get the sid *******************/
+
+        retVal = hwReadGlobalReg(dev,QD_REG_STU_SID_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /* the sid is bits 0-5 */
+        entry->sid   = data & 0x3F;
+
+        if (*valid)
+        {
+            /* get the Port State for all the ports */
+            retVal = stuGetSTUData(dev,entry);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+
+        } /* entry is valid */
+
+    } /* end of get next entry */
+
+    gtSemGive(dev,dev->vtuRegsSem);
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgVlan.c
@@ -0,0 +1,1312 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtBrgVlan.c
+*
+* DESCRIPTION:
+*       API definitions to handle port-based vlan configuration.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gprtSetEgressMode
+*
+* DESCRIPTION:
+*       This routine set the egress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the egress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressMode
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_EGRESS_MODE  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gprtSetEgressMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_TAGGING)) != GT_OK )
+      return retVal;
+
+    switch (mode)
+    {
+        case (GT_UNMODIFY_EGRESS):
+            data = 0;
+            break;
+
+        case (GT_TAGGED_EGRESS):
+            data = 2;
+            break;
+
+        case (GT_UNTAGGED_EGRESS):
+            data = 1;
+            break;
+
+        case (GT_ADD_TAG):
+            if(!IS_IN_DEV_GROUP(dev,DEV_EGRESS_DOUBLE_TAGGING))
+            {
+                DBG_INFO(("GT_NOT_SUPPORTED\n"));
+                return GT_NOT_SUPPORTED;
+            }
+            data = 3;
+            break;
+        default:
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+    }
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,12,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetEgressMode
+*
+* DESCRIPTION:
+*       This routine get the egress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the egress mode.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressMode
+(
+    IN GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_EGRESS_MODE  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    if(mode == NULL)
+        return GT_BAD_PARAM;
+
+    DBG_INFO(("gprtGetEgressMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,12,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    switch (data)
+    {
+        case (0):
+            *mode = GT_UNMODIFY_EGRESS;
+            break;
+
+        case (2):
+            *mode = GT_TAGGED_EGRESS;
+            break;
+
+        case (1):
+            *mode = GT_UNTAGGED_EGRESS;
+            break;
+
+        case (3):
+            *mode = GT_ADD_TAG;
+            break;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtSetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine sets the vlan tunnel mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the vlan tunnel mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gprtSetVlanTunnel Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    BOOL_2_BIT(mode,data);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,7,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine get the vlan tunnel mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the vlan tunnel mode..
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gprtGetVlanTunnel Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,7,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnSetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*       memPorts    - array of logical ports in the same vlan.
+*       memPortsLen - number of members in memPorts array
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_LPORT  memPorts[],
+    IN GT_U8     memPortsLen
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U8           i;
+
+    DBG_INFO(("gvlnSetPortVlanPorts Called.\n"));
+    if(memPorts == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+    data = 0;
+
+    if(memPortsLen > dev->numOfPorts)
+    {
+        DBG_INFO(("Failed (PortsLen Too Big).\n"));
+        return GT_BAD_PARAM;
+    }
+
+    for(i = 0; i < memPortsLen; i++)
+        data |= (1 << GT_LPORT_2_PORT(memPorts[i]));
+
+    /* numOfPorts = 3 for fullsail, = 10 for octane, = 7 for others */
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,0,dev->maxPorts,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine gets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*
+* OUTPUTS:
+*       memPorts    - array of logical ports in the same vlan.
+*       memPortsLen - number of members in memPorts array
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_LPORT memPorts[],
+    OUT GT_U8    *memPortsLen
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U8           i;
+
+    DBG_INFO(("gvlnGetPortVlanPorts Called.\n"));
+    if((memPorts == NULL) || (memPortsLen == NULL))
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* memPortsLen = 3 for fullsail, =7 for others */
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,0,dev->maxPorts,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    i = 0;
+    for(phyPort = 0; phyPort < dev->maxPorts; phyPort++)
+    {
+        if(!GT_IS_PORT_SET(dev->validPortVec, phyPort))
+            continue;
+
+        if(((1 << phyPort) & data) != 0)
+        {
+            memPorts[i] = GT_PORT_2_LPORT(phyPort);
+            i++;
+        }
+    }
+    *memPortsLen = i;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvlnSetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine Set the user priority (VPT) LSB bit, to be added to the
+*       user priority on the egress.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortUserPriLsb
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   userPriLsb
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnSetPortUserPriLsb Called.\n"));
+
+    /* Gigabit Switch does not support this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+    BOOL_2_BIT(userPriLsb,data);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,13,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnGetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine gets the user priority (VPT) LSB bit.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*
+* OUTPUTS:
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortUserPriLsb
+(
+    IN GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *userPriLsb
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnGetPortUserPriLsb Called.\n"));
+
+    /* Gigabit Switch does not support this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(userPriLsb == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*userPriLsb);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvlnSetPortVid
+*
+* DESCRIPTION:
+*       This routine Set the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*       vid  - the port vlan id.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVid
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_U16       vid
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnSetPortVid Called.\n"));
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,0,12, vid);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvlnGetPortVid
+*
+* DESCRIPTION:
+*       This routine Get the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*
+* OUTPUTS:
+*       vid  - the port vlan id.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVid
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U16   *vid
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnGetPortVid Called.\n"));
+    if(vid == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,0,12, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *vid = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvlnSetPortVlanDBNum
+*
+* DESCRIPTION:
+*       This routine sets the port's default VLAN database number (DBNum or
+*        FID, Forwarding Information Database).
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       DBNum     - database number for this port (or FID)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_U32    DBNum
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnSetPortVlanDBNum Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
+    {
+        if(DBNum > 4095)
+        {
+            return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,8,(GT_U16)((DBNum & 0xFF0) >> 4));
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x000F));
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+    {
+        if(DBNum > 255)
+        {
+            return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4,(GT_U16)((DBNum & 0xF0) >> 4));
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+    {
+        if(DBNum > 63)
+        {
+            return GT_BAD_PARAM;
+        }
+        if(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+        {
+          retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,2,(GT_U16)((DBNum & 0x30) >> 4));
+          retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+        }
+        else
+        {
+          retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,6,2,(GT_U16)((DBNum & 0x30) >> 4));
+          retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+        }
+    }
+    else
+    {
+        if(DBNum > 15)
+        {
+            return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanDBNum
+*
+* DESCRIPTION:
+*       This routine gets the port's default VLAN database number (DBNum or
+*        FID, Forwarding Information Database).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       DBNum     - database number for this port (or FID)
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U32   *DBNum
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data,dataH;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnGetPortVlanDBNum Called.\n"));
+
+    if(DBNum == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,8, &dataH);
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4, &dataH);
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))
+        {
+          retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,2, &dataH);
+          retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+        }
+        else
+        {
+          retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,6,2, &dataH);
+          retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+        }
+    }
+    else
+    {
+        dataH = 0;
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *DBNum = (GT_U32)(data | (dataH << 4));
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/********************************************************************
+* gvlnSetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine sets the IEEE 802.1q mode for this port (11:10)
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode     - 802.1q mode for this port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanDot1qMode
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT     port,
+    IN GT_DOT1Q_MODE    mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnSetPortVlanDot1qMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK )
+      return retVal;
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2,(GT_U16)mode );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2,(GT_U16)mode );
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvlnGetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine gets the IEEE 802.1q mode for this (bit 11:10).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       mode     - 802.1q mode for this port
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanDot1qMode
+(
+    IN GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_DOT1Q_MODE   *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnGetPortVlanDot1qMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK )
+      return retVal;
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2, &data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2, &data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/********************************************************************
+* gvlnSetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine sets the mode for forcing to use default VID
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode    - GT_TRUE, force to use default VID
+*                 GT_FAULSE, otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U16          data;           /* Data to be set into the      */
+
+    DBG_INFO(("gvlnSetPortForceDefaultVID Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK )
+      return retVal;
+
+    BOOL_2_BIT(mode,data);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,12,1,data );
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine gets the port mode for ForceDefaultVID (bit 12).
+*
+* INPUTS:
+*       port     - logical port number to get.
+*
+* OUTPUTS:
+*       mode     - ForceDefaultVID mode for this port
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV        *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+
+    DBG_INFO(("gvlnGetPortVlanDot1qMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK )
+      return retVal;
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,12,1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/********************************************************************
+* gvlnSetForceMap
+*
+* DESCRIPTION:
+*       This routine enables/disables Force Map feature.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode    - GT_TRUE, to enable force map feature
+*                 GT_FAULSE, otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetForceMap
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U16          data;           /* Data to be set into the reg  */
+
+    DBG_INFO(("gvlnSetForceMap Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_MAP))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(mode,data);
+
+    retVal = hwSetPortRegField(dev,phyPort, QD_REG_PORT_VLAN_MAP, 8, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/********************************************************************
+* gvlnGetForceMap
+*
+* DESCRIPTION:
+*       This routine checks if Force Map feature is enabled.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*
+* OUTPUTS:
+*       mode    - GT_TRUE, to enable force map feature
+*                 GT_FAULSE, otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetForceMap
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U16          data;           /* Data to be set into the reg  */
+
+    DBG_INFO(("gvlnGetForceMap Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_MAP))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort, QD_REG_PORT_VLAN_MAP, 8, 1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvlnSetNoEgrPolicy
+*
+* DESCRIPTION:
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress
+*        even if the VID assigned to the frame is not found in the VTU.
+*
+* INPUTS:
+*        mode - no egress policy mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gvlnSetNoEgrPolicy
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+
+    DBG_INFO(("gvlnSetNoEgrPolicy Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NO_EGRESS_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(mode,data);
+
+    /* Set related register */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY,13,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvlnGetNoEgrPolicy
+*
+* DESCRIPTION:
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress
+*        even if the VID assigned to the frame is not found in the VTU.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - no egress policy mode
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gvlnGetNoEgrPolicy
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gvlnGetNoEgrPolicy Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NO_EGRESS_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related register */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtBrgVtu.c
@@ -0,0 +1,1592 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtBrgVtu.c
+*
+* DESCRIPTION:
+*       API definitions for Vlan Translation Unit for 802.1Q.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 9 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* Forward function declaration.                                            */
+/****************************************************************************/
+#define MEMBER_TAG_CONV_FOR_APP(_dev,_tag)    memberTagConversionForApp(_dev,_tag)
+#define MEMBER_TAG_CONV_FOR_DEV(_dev,_tag)    memberTagConversionForDev(_dev,_tag)
+
+static GT_U8 memberTagConversionForApp
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_U8               tag
+)
+{
+    GT_U8 convTag;
+
+    /* check if memberTag needs to be converted */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+        return tag;
+
+    switch(tag)
+    {
+        case 0:
+                convTag = MEMBER_EGRESS_UNMODIFIED;
+                break;
+        case 1:
+                convTag = MEMBER_EGRESS_UNTAGGED;
+                break;
+        case 2:
+                convTag = MEMBER_EGRESS_TAGGED;
+                break;
+        case 3:
+                convTag = NOT_A_MEMBER;
+                break;
+        default:
+                DBG_INFO(("Unknown Tag (%#x) from Device !!!.\n",tag));
+                convTag = 0xFF;
+                break;
+
+    }
+
+    return convTag;
+}
+
+static GT_U8 memberTagConversionForDev
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_U8               tag
+)
+{
+    GT_U8 convTag;
+
+    /* check if memberTag needs to be converted */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+        return tag;
+
+    switch(tag)
+    {
+        case MEMBER_EGRESS_UNMODIFIED:
+                convTag = 0;
+                break;
+        case NOT_A_MEMBER:
+                convTag = 3;
+                break;
+        case MEMBER_EGRESS_UNTAGGED:
+                convTag = 1;
+                break;
+        case MEMBER_EGRESS_TAGGED:
+                convTag = 2;
+                break;
+        default:
+                DBG_INFO(("Unknown Tag (%#x) from App. !!!.\n",tag));
+                convTag = 0xFF;
+                break;
+
+    }
+
+    return convTag;
+}
+
+static GT_STATUS vtuOperationPerform
+(
+    IN        GT_QD_DEV           *dev,
+    IN      GT_VTU_OPERATION    vtuOp,
+    INOUT   GT_U8               *valid,
+    INOUT     GT_VTU_ENTRY        *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuGetEntryCount
+*
+* DESCRIPTION:
+*       Gets the current number of valid entries in the VTU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numEntries - number of VTU entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryCount
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_U32    *numEntries
+)
+{
+    GT_U8               valid;
+    GT_U32        numOfEntries;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuGetEntryCount Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK)
+      return retVal;
+
+    entry.vid = 0xFFF;
+    entry.DBNum = 0;
+
+    numOfEntries = 0;
+    while(1)
+    {
+        retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid,&entry);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+            return retVal;
+        }
+
+        if( entry.vid==0xFFF )
+        {
+            if (valid==1) numOfEntries++;
+            break;
+        }
+
+        numOfEntries++;
+    }
+
+    *numEntries = numOfEntries;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gvtuGetEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic entry from the VTU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from vid of all one's
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryFirst
+(
+    IN  GT_QD_DEV       *dev,
+    OUT GT_VTU_ENTRY    *vtuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_U8               port;
+    GT_LPORT               lport;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuGetEntryFirst Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK)
+      return retVal;
+
+    entry.vid = 0xFFF;
+    entry.DBNum = 0;
+
+    retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrive the value from the operation */
+
+    if((entry.vid == 0xFFF) && (valid == 0))
+        return GT_NO_SUCH;
+
+    vtuEntry->DBNum = entry.DBNum;
+    vtuEntry->vid   = entry.vid;
+
+    vtuEntry->vidPriOverride = entry.vidPriOverride;
+    vtuEntry->vidPriority = entry.vidPriority;
+
+    vtuEntry->vidPolicy = entry.vidPolicy;
+    vtuEntry->sid = entry.sid;
+
+    vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
+    vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
+    vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
+    vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
+    vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
+
+    for(lport=0; lport<dev->numOfPorts; lport++)
+    {
+        port = GT_LPORT_2_PORT(lport);
+        vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
+        vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvtuGetEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic VTU entry from the specified VID.
+*
+* INPUTS:
+*       vtuEntry - the VID to start the search.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU  entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from the VID specified by the user.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryNext
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_U8               port;
+    GT_LPORT               lport;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuGetEntryNext Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK)
+      return retVal;
+
+    entry.DBNum = vtuEntry->DBNum;
+    entry.vid   = vtuEntry->vid;
+    valid = 0;
+
+    retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrieve the value from the operation */
+
+    if((entry.vid == 0xFFF) && (valid == 0))
+        return GT_NO_SUCH;
+
+    vtuEntry->DBNum = entry.DBNum;
+    vtuEntry->vid   = entry.vid;
+
+    vtuEntry->vidPriOverride = entry.vidPriOverride;
+    vtuEntry->vidPriority = entry.vidPriority;
+
+    vtuEntry->vidPolicy = entry.vidPolicy;
+    vtuEntry->sid = entry.sid;
+
+    vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
+    vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
+    vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
+    vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
+    vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
+
+    for(lport=0; lport<dev->numOfPorts; lport++)
+    {
+        port = GT_LPORT_2_PORT(lport);
+        vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
+        vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvtuFindVidEntry
+*
+* DESCRIPTION:
+*       Find VTU entry for a specific VID, it will return the entry, if found,
+*       along with its associated data
+*
+* INPUTS:
+*       vtuEntry - contains the VID to searche for
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       vtuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuFindVidEntry
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry,
+    OUT GT_BOOL         *found
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_U8               port;
+    GT_LPORT            lport;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuFindVidEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK)
+      return retVal;
+
+    *found = GT_FALSE;
+
+    /* Decrement 1 from vid    */
+    entry.vid   = vtuEntry->vid-1;
+    valid = 0; /* valid is not used as input in this operation */
+    entry.DBNum = vtuEntry->DBNum;
+
+    retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrive the value from the operation */
+
+    if( (entry.vid !=vtuEntry->vid) | (valid !=1) )
+    {
+          DBG_INFO(("Failed.\n"));
+          return GT_NO_SUCH;
+    }
+
+    vtuEntry->DBNum = entry.DBNum;
+
+    vtuEntry->vidPriOverride = entry.vidPriOverride;
+    vtuEntry->vidPriority = entry.vidPriority;
+
+    vtuEntry->vidPolicy = entry.vidPolicy;
+    vtuEntry->sid = entry.sid;
+
+    vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
+    vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
+    vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
+    vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
+    vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
+
+    for(lport=0; lport<dev->numOfPorts; lport++)
+    {
+        port = GT_LPORT_2_PORT(lport);
+        vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
+        vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
+    }
+
+    *found = GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvtuFlush
+*
+* DESCRIPTION:
+*       This routine removes all entries from VTU Table.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuFlush
+(
+    IN  GT_QD_DEV       *dev
+)
+{
+    GT_STATUS       retVal;
+
+    DBG_INFO(("gvtuFlush Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = vtuOperationPerform(dev,FLUSH_ALL,NULL,NULL);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvtuAddEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in VTU table based on user input.
+*
+* INPUTS:
+*       vtuEntry    - vtu entry to insert to the VTU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_FULL              - vtu table is full
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuAddEntry
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_VTU_ENTRY *vtuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_U8           port;
+    GT_LPORT           lport;
+    GT_VTU_ENTRY     tmpVtuEntry;
+    GT_BOOL             found;
+    int                count = 5000;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuAddEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK)
+      return retVal;
+
+    entry.DBNum = vtuEntry->DBNum;
+    entry.vid   = vtuEntry->vid;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
+    {
+        entry.vidPriOverride = 0;
+        entry.vidPriority = 0;
+
+        entry.vidPolicy = GT_FALSE;
+        entry.sid = 0;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_FQPRI_IN_TABLE))
+        {
+            entry.vidExInfo.useVIDFPri = vtuEntry->vidExInfo.useVIDFPri;
+            entry.vidExInfo.vidFPri = vtuEntry->vidExInfo.vidFPri;
+            entry.vidExInfo.useVIDQPri = vtuEntry->vidExInfo.useVIDQPri;
+            entry.vidExInfo.vidQPri = vtuEntry->vidExInfo.vidQPri;
+            entry.vidExInfo.vidNRateLimit = vtuEntry->vidExInfo.vidNRateLimit;
+        }
+        else
+        {
+            entry.vidExInfo.useVIDFPri = 0;
+            entry.vidExInfo.vidFPri = 0;
+            entry.vidExInfo.useVIDQPri = 0;
+            entry.vidExInfo.vidQPri = 0;
+            entry.vidExInfo.vidNRateLimit = vtuEntry->vidExInfo.vidNRateLimit;
+        }
+    }
+    else
+    {
+        entry.vidPriOverride = vtuEntry->vidPriOverride;
+        entry.vidPriority = vtuEntry->vidPriority;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
+        {
+            entry.vidPolicy = vtuEntry->vidPolicy;
+        }
+        else
+        {
+            entry.vidPolicy = GT_FALSE;
+        }
+
+        if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+        {
+            entry.sid = vtuEntry->sid;
+        }
+        else
+        {
+            entry.sid = 0;
+        }
+
+        entry.vidExInfo.useVIDFPri = 0;
+        entry.vidExInfo.vidFPri = 0;
+        entry.vidExInfo.useVIDQPri = 0;
+        entry.vidExInfo.vidQPri = 0;
+        entry.vidExInfo.vidNRateLimit = 0;
+    }
+
+    valid = 1; /* for load operation */
+
+    for(port=0; port<dev->maxPorts; port++)
+    {
+        lport = GT_PORT_2_LPORT(port);
+        if(lport == GT_INVALID_PORT)
+        {
+            entry.vtuData.memberTagP[port] = MEMBER_TAG_CONV_FOR_DEV(dev,NOT_A_MEMBER);
+            entry.vtuData.portStateP[port] = 0;
+        }
+        else
+        {
+            entry.vtuData.memberTagP[port] = MEMBER_TAG_CONV_FOR_DEV(dev,vtuEntry->vtuData.memberTagP[lport]);
+            if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                entry.vtuData.portStateP[port] = vtuEntry->vtuData.portStateP[lport];
+            else
+                entry.vtuData.portStateP[port] = 0;
+        }
+    }
+
+    retVal = vtuOperationPerform(dev,LOAD_PURGE_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* verify that the given entry has been added */
+    tmpVtuEntry.vid = vtuEntry->vid;
+    tmpVtuEntry.DBNum = vtuEntry->DBNum;
+
+    if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
+    {
+        while(count--);
+        if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
+        {
+            DBG_INFO(("Added entry cannot be found\n"));
+            return retVal;
+        }
+    }
+    if(found == GT_FALSE)
+    {
+        DBG_INFO(("Added entry cannot be found\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvtuDelEntry
+*
+* DESCRIPTION:
+*       Deletes VTU entry specified by user.
+*
+* INPUTS:
+*       vtuEntry - the VTU entry to be deleted
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuDelEntry
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_VTU_ENTRY *vtuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuDelEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK)
+      return retVal;
+
+    entry.DBNum = vtuEntry->DBNum;
+    entry.vid   = vtuEntry->vid;
+    valid = 0; /* for delete operation */
+
+    retVal = vtuOperationPerform(dev,LOAD_PURGE_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* gvtuGetViolation
+*
+* DESCRIPTION:
+*       Get VTU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*        This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+)
+{
+    GT_U8               spid;
+    GT_U16               vid;
+    GT_U16               intCause;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuGetViolation Called.\n"));
+
+    /* check which Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,4,3,&intCause);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        return retVal;
+    }
+
+    if (intCause == 0)
+    {
+        /* No Violation occurred. */
+        vtuIntStatus->vtuIntCause = 0;
+        return GT_OK;
+    }
+
+    entry.DBNum = 0;
+
+    retVal = vtuOperationPerform(dev,SERVICE_VIOLATIONS,NULL, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    spid = entry.DBNum & 0xF;
+    vid = entry.vid;
+
+    if(spid == 0xF)
+    {
+        vtuIntStatus->vtuIntCause = GT_VTU_FULL_VIOLATION;
+        vtuIntStatus->spid = spid;
+        vtuIntStatus->vid = 0;
+    }
+    else
+    {
+        vtuIntStatus->vtuIntCause = intCause & (GT_MEMBER_VIOLATION | GT_MISS_VIOLATION);
+        vtuIntStatus->spid = spid;
+        vtuIntStatus->vid = vid;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvtuGetViolation2
+*
+* DESCRIPTION:
+*       Get VTU Violation data (for Gigabit Device)
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*        This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation2
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+)
+{
+    GT_U16               intCause;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuGetViolation2 Called.\n"));
+
+    /* check if Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,5,1,&intCause);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        return retVal;
+    }
+
+    if (intCause == 0)
+    {
+        /* No Violation occurred. */
+        vtuIntStatus->vtuIntCause = 0;
+        return GT_OK;
+    }
+
+    entry.DBNum = 0;
+
+    retVal = vtuOperationPerform(dev,SERVICE_VIOLATIONS,NULL, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* check which Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,5,2,&intCause);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        return retVal;
+    }
+
+    switch (intCause)
+    {
+        case 0:
+            /* No Violation occurred. */
+            vtuIntStatus->vtuIntCause = 0;
+            return GT_OK;
+        case 1:
+            /* Miss Violation */
+            vtuIntStatus->vtuIntCause = GT_MISS_VIOLATION;
+            break;
+        case 2:
+            /* Member Violation */
+            vtuIntStatus->vtuIntCause = GT_MEMBER_VIOLATION;
+            break;
+        default :
+            return GT_FAIL;
+    }
+
+    vtuIntStatus->spid = entry.DBNum & 0xF;
+    vtuIntStatus->vid = entry.vid;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvtuGetViolation3
+*
+* DESCRIPTION:
+*       Get VTU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*        This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation3
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+)
+{
+    GT_U16               intCause;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
+
+    DBG_INFO(("gvtuGetViolation3 Called.\n"));
+
+    /* check if Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,5,1,&intCause);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        return retVal;
+    }
+
+    if (intCause == 0)
+    {
+        /* No Violation occurred. */
+        vtuIntStatus->vtuIntCause = 0;
+        return GT_OK;
+    }
+
+    entry.DBNum = 0;
+
+    retVal = vtuOperationPerform(dev,SERVICE_VIOLATIONS,NULL, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* check which Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,4,3,&intCause);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        return retVal;
+    }
+
+    vtuIntStatus->vtuIntCause = 0;
+
+    if(intCause & 0x1)
+    {
+        vtuIntStatus->vtuIntCause |= GT_VTU_FULL_VIOLATION;
+    }
+
+    if(intCause & 0x2)
+    {
+        vtuIntStatus->vtuIntCause |= GT_MISS_VIOLATION;
+    }
+
+    if(intCause & 0x4)
+    {
+        vtuIntStatus->vtuIntCause |= GT_MEMBER_VIOLATION;
+    }
+
+    vtuIntStatus->spid = entry.DBNum & 0xF;
+    vtuIntStatus->vid = entry.vid;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* vtuOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all VTU control functions, and is responsible
+*       to write the required operation into the VTU registers.
+*
+* INPUTS:
+*       vtuOp       - The VTU operation bits to be written into the VTU
+*                     operation register.
+*       DBNum       - DBNum where the given vid belongs to
+*       vid         - vlan id
+*       valid       - valid bit
+*       vtuData     - VTU Data with memberTag information
+*
+* OUTPUTS:
+*       DBNum       - DBNum where the given vid belongs to
+*       vid         - vlan id
+*       valid       - valid bit
+*       vtuData     - VTU Data with memberTag information
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static GT_STATUS vtuOperationPerform
+(
+    IN        GT_QD_DEV           *dev,
+    IN      GT_VTU_OPERATION    vtuOp,
+    INOUT   GT_U8               *valid,
+    INOUT    GT_VTU_ENTRY        *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                /* register.                    */
+
+    gtSemTake(dev,dev->vtuRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the VTU in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_VTU_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    /* Set the VTU data register    */
+    /* There is no need to setup data reg. on flush, get next, or service violation */
+    if((vtuOp != FLUSH_ALL) && (vtuOp != GET_NEXT_ENTRY) && (vtuOp != SERVICE_VIOLATIONS))
+    {
+
+        /****************** VTU DATA 1 REG *******************/
+
+        /* get data and wirte to QD_REG_VTU_DATA1_REG (ports 0 to 3) */
+
+        data =  (entry->vtuData.memberTagP[0] & 3)     |
+                ((entry->vtuData.memberTagP[1] & 3)<<4) |
+                ((entry->vtuData.memberTagP[2] & 3)<<8);
+
+        if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+            data |= ((entry->vtuData.portStateP[0] & 3)<<2)    |
+                    ((entry->vtuData.portStateP[1] & 3)<<6) |
+                    ((entry->vtuData.portStateP[2] & 3)<<10);
+
+        if(dev->maxPorts > 3)
+        {
+            data |= ((entry->vtuData.memberTagP[3] & 3)<<12) ;
+            if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                data |= ((entry->vtuData.portStateP[3] & 3)<<14) ;
+        }
+
+        retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA1_REG,data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /****************** VTU DATA 2 REG *******************/
+
+        /* get data and wirte to QD_REG_VTU_DATA2_REG (ports 4 to 7) */
+
+        if(dev->maxPorts > 4)
+        {
+            /* also need to set data register  ports 4 to 6 */
+
+            data =  (entry->vtuData.memberTagP[4] & 3)   |
+                    ((entry->vtuData.memberTagP[5] & 3) << 4);
+
+            if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                data |= ((entry->vtuData.portStateP[4] & 3) << 2) |
+                        ((entry->vtuData.portStateP[5] & 3) << 6);
+
+            if(dev->maxPorts > 6)
+            {
+                data |= ((entry->vtuData.memberTagP[6] & 3)<<8) ;
+                if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                    data |= ((entry->vtuData.portStateP[6] & 3)<<10) ;
+            }
+
+            if(dev->maxPorts > 7)
+            {
+                data |= ((entry->vtuData.memberTagP[7] & 3)<<12) ;
+                if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                    data |= ((entry->vtuData.portStateP[7] & 3)<<14) ;
+            }
+
+            if (IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
+            {
+                if(entry->vidExInfo.useVIDFPri == GT_TRUE)
+                    data |= ((1 << 15) | ((entry->vidExInfo.vidFPri & 0x7) << 12));
+                if(entry->vidExInfo.useVIDQPri == GT_TRUE)
+                    data |= ((1 << 11) | ((entry->vidExInfo.vidQPri & 0x3) << 9));
+                if(entry->vidExInfo.vidNRateLimit == GT_TRUE)
+                    data |= (1 << 8);
+            }
+
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA2_REG,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+
+
+        /****************** VTU DATA 3 REG *******************/
+
+        /* get data and wirte to QD_REG_VTU_DATA3_REG (ports 8 to 10) */
+
+        if(dev->maxPorts > 7)
+        {
+            /* also need to set data register  ports 8 to 9 */
+
+            data =  (entry->vtuData.memberTagP[8] & 3)   |
+                    ((entry->vtuData.memberTagP[9] & 3) << 4);
+
+            if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                data |= ((entry->vtuData.portStateP[8] & 3) << 2)    |
+                        ((entry->vtuData.portStateP[9] & 3) << 6);
+
+            if(dev->maxPorts > 10)
+            {
+                data |= (entry->vtuData.memberTagP[10] & 3) << 8;
+
+                if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                    data |= (entry->vtuData.portStateP[10] & 3) << 10;
+            }
+
+            if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+            {
+                if(entry->vidPriOverride == GT_TRUE)
+                    data |= ((1 << 15) | ((entry->vidPriority & 0x7) << 12));
+            }
+
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+        {
+            if(entry->vidPriOverride == GT_TRUE)
+                data = ((1 << 15) | ((entry->vidPriority & 0x7) << 12));
+            else
+                data = 0;
+
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+    }
+
+    /* Set the VID register (QD_REG_VTU_VID_REG) */
+    /* There is no need to setup VID reg. on flush and service violation */
+    if((vtuOp != FLUSH_ALL) && (vtuOp != SERVICE_VIOLATIONS) )
+    {
+        data= ( (entry->vid) & 0xFFF ) | ( (*valid) << 12 );
+        retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_VID_REG),data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+    }
+
+    /* Set SID, FID, VIDPolicy, if it's Load operation */
+    if((vtuOp == LOAD_PURGE_ENTRY) && (*valid == 1))
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+        {
+            data= (entry->sid) & 0x3F;
+            retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_STU_SID_REG),data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+
+        data = 0;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
+            {
+                data= entry->vidPolicy << 12;
+            }
+
+            data |= (entry->DBNum & 0xFFF);
+
+            retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_FID_REG),data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+
+
+    }
+
+    /* Start the VTU Operation by defining the DBNum, vtuOp and VTUBusy    */
+    /*
+     * Flush operation will skip the above two setup (for data and vid), and
+     * come to here directly
+     */
+
+    if(vtuOp == FLUSH_ALL)
+        data = (1 << 15) | (vtuOp << 12);
+    else
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            data = (1 << 15) | (vtuOp << 12);
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+        {
+            /* Since DBNum is defined as GT_U8, it cannot be >= 256. */
+            #if 0
+            if(entry->DBNum >= 256)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return GT_BAD_PARAM;
+            }
+            #endif
+            data = (1 << 15) | (vtuOp << 12) | ((entry->DBNum & 0xF0) << 4) | (entry->DBNum & 0x0F);
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+        {
+            if(entry->DBNum >= 64)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return GT_BAD_PARAM;
+            }
+            data = (1 << 15) | (vtuOp << 12) | ((entry->DBNum & 0x30) << 4) | (entry->DBNum & 0x0F);
+        }
+        else
+        {
+            if(entry->DBNum >= 16)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return GT_BAD_PARAM;
+            }
+            data = (1 << 15) | (vtuOp << 12) | entry->DBNum;
+        }
+    }
+
+    retVal = hwWriteGlobalReg(dev,QD_REG_VTU_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+    }
+
+    /* only two operations need to go through the mess below to get some data
+     * after the operations -  service violation and get next entry
+     */
+
+    /* If the operation is to service violation operation wait for the response   */
+    if(vtuOp == SERVICE_VIOLATIONS)
+    {
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 1;
+
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_VTU_OPERATION;
+          regAccess.rw_reg_list[0].data = 15;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+          }
+        }
+#else
+        /* Wait until the VTU in ready. */
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+#endif
+
+        /* get the Source Port ID that was involved in the violation */
+        retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        entry->DBNum = (GT_U8)(data & 0xF);
+
+        /* get the VID that was involved in the violation */
+
+        retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /* Get the vid - bits 0-11 */
+        entry->vid   = data & 0xFFF;
+
+
+    } /* end of service violations */
+
+    /* If the operation is a get next operation wait for the response   */
+    if(vtuOp == GET_NEXT_ENTRY)
+    {
+        entry->vidExInfo.useVIDFPri = GT_FALSE;
+        entry->vidExInfo.vidFPri = 0;
+
+        entry->vidExInfo.useVIDQPri = GT_FALSE;
+        entry->vidExInfo.vidQPri = 0;
+
+        entry->vidExInfo.vidNRateLimit = GT_FALSE;
+
+        entry->sid = 0;
+           entry->vidPolicy = GT_FALSE;
+
+        /* Wait until the VTU in ready. */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 1;
+
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_VTU_OPERATION;
+          regAccess.rw_reg_list[0].data = 15;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+          }
+        }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+#endif
+
+        /****************** get the vid *******************/
+
+        retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /* the vid is bits 0-11 */
+        entry->vid   = data & 0xFFF;
+
+        /* the vid valid is bits 12 */
+        *valid   = (data >> 12) & 1;
+
+        if (*valid == 0)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return GT_OK;
+        }
+
+        /****************** get the SID *******************/
+        if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+        {
+            retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_STU_SID_REG),&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+            entry->sid = data & 0x3F;
+        }
+
+        /****************** get the DBNum *******************/
+        if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_VTU_FID_REG),&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+
+            if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
+            {
+                entry->vidPolicy = (data >> 12) & 0x1;
+            }
+
+            entry->DBNum = data & 0xFFF;
+
+        }
+        else
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+
+            entry->DBNum = data & 0xF;
+
+            if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+            {
+                retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,8,4,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->vtuRegsSem);
+                    return retVal;
+                }
+
+                entry->DBNum |= ((data & 0xF) << 4);
+            }
+            else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+            {
+                retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,8,2,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->vtuRegsSem);
+                    return retVal;
+                }
+
+                entry->DBNum |= ((data & 0x3) << 4);
+            }
+        }
+
+
+        /****************** get the MemberTagP *******************/
+        retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA1_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /* get data from data register for ports 0 to 2 */
+        entry->vtuData.memberTagP[0]  =  data & 3 ;
+        entry->vtuData.memberTagP[1]  = (data >> 4) & 3 ;
+        entry->vtuData.memberTagP[2]  = (data >> 8) & 3 ;
+        entry->vtuData.portStateP[0]  = (data >> 2) & 3 ;
+        entry->vtuData.portStateP[1]  = (data >> 6) & 3 ;
+        entry->vtuData.portStateP[2]  = (data >> 10) & 3 ;
+
+        /****************** for the switch more than 3 ports *****************/
+
+        if(dev->maxPorts > 3)
+        {
+            /* fullsail has 3 ports, clippership has 7 prots */
+            entry->vtuData.memberTagP[3]  = (data >>12) & 3 ;
+            entry->vtuData.portStateP[3]  = (data >>14) & 3 ;
+
+            /* get data from data register for ports 4 to 6 */
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA2_REG,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+            entry->vtuData.memberTagP[4]  = data & 3 ;
+            entry->vtuData.memberTagP[5]  = (data >> 4) & 3 ;
+            entry->vtuData.portStateP[4]  = (data >> 2) & 3 ;
+            entry->vtuData.portStateP[5]  = (data >> 6) & 3 ;
+
+            if(dev->maxPorts > 6)
+            {
+                entry->vtuData.memberTagP[6]  = (data >> 8) & 3 ;
+                entry->vtuData.portStateP[6]  = (data >> 10) & 3 ;
+            }
+
+            if (IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
+            {
+                entry->vidPriOverride = 0;
+                entry->vidPriority = 0;
+
+                entry->vidExInfo.useVIDFPri = (data & 0x8000)?GT_TRUE:GT_FALSE;
+                entry->vidExInfo.vidFPri = (data >> 12) & 0x7;
+
+                entry->vidExInfo.useVIDQPri = (data & 0x0800)?GT_TRUE:GT_FALSE;
+                entry->vidExInfo.vidQPri = (data >> 9) & 0x3;
+
+                entry->vidExInfo.vidNRateLimit = (data & 0x0100)?GT_TRUE:GT_FALSE;
+            }
+        }
+        /****************** upto 7 port switch *******************/
+
+        /****************** for the switch more than 7 ports *****************/
+
+        if(dev->maxPorts > 7)
+        {
+            /* fullsail has 3 ports, clippership has 7 prots */
+            entry->vtuData.memberTagP[7]  = (data >>12) & 3 ;
+            entry->vtuData.portStateP[7]  = (data >>14) & 3 ;
+
+            /* get data from data register for ports 4 to 6 */
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+            entry->vtuData.memberTagP[8]  = data & 3 ;
+            entry->vtuData.memberTagP[9]  = (data >> 4) & 3 ;
+            entry->vtuData.portStateP[8]  = (data >> 2) & 3 ;
+            entry->vtuData.portStateP[9]  = (data >> 6) & 3 ;
+
+            if(dev->maxPorts > 10)
+            {
+                entry->vtuData.memberTagP[10]  = (data >> 8) & 3 ;
+                entry->vtuData.portStateP[10]  = (data >> 10) & 3 ;
+            }
+
+            if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+            {
+                if (data & 0x8000)
+                {
+                    entry->vidPriOverride = GT_TRUE;
+                    entry->vidPriority = (data >> 12) & 0x7;
+                }
+                else
+                {
+                    entry->vidPriOverride = GT_FALSE;
+                    entry->vidPriority = 0;
+                }
+            }
+
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+        {
+            /* get data from data register for ports 4 to 6 */
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+
+            if (data & 0x8000)
+            {
+                entry->vidPriOverride = GT_TRUE;
+                entry->vidPriority = (data >> 12) & 0x7;
+            }
+            else
+            {
+                entry->vidPriOverride = GT_FALSE;
+                entry->vidPriority = 0;
+            }
+        }
+
+        /****************** upto 11 ports switch *******************/
+
+    } /* end of get next entry */
+
+    gtSemGive(dev,dev->vtuRegsSem);
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtCCPVT.c
@@ -0,0 +1,438 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtCCPVT.c
+*
+* DESCRIPTION:
+*       API definitions for Cross Chip Port Vlan Data Table
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* Cross Chip Port Vlan operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS pvtOperationPerform
+(
+    IN   GT_QD_DEV             *dev,
+    IN   GT_PVT_OPERATION    pvtOp,
+    INOUT GT_PVT_OP_DATA    *opData
+);
+
+
+/*******************************************************************************
+* gpvtInitialize
+*
+* DESCRIPTION:
+*       This routine initializes the PVT Table to all one's (initial state)
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpvtInitialize
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_PVT_OPERATION    op;
+
+    DBG_INFO(("gpvtInitialize Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Program Tuning register */
+    op = PVT_INITIALIZE;
+    retVal = pvtOperationPerform(dev,op,NULL);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gpvtWritePVTData
+*
+* DESCRIPTION:
+*       This routine write Cross Chip Port Vlan Data.
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0,
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
+*
+*
+* INPUTS:
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*        pvtData    - Cross Chip Port Vlan Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpvtWritePVTData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        pvtPointer,
+    IN  GT_U32        pvtData
+)
+{
+    GT_STATUS           retVal;
+    GT_PVT_OPERATION    op;
+    GT_PVT_OP_DATA        opData;
+
+    DBG_INFO(("gpvtWritePVTData Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if (pvtPointer > 0x1FF)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* check if the given pvtData is valid */
+    if (pvtData >= (GT_U32)(1 << dev->maxPorts))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = PVT_WRITE;
+    opData.pvtAddr = pvtPointer;
+
+    if((opData.pvtData = GT_LPORTVEC_2_PORTVEC(pvtData)) == GT_INVALID_PORT_VEC)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+
+    retVal = pvtOperationPerform(dev,op,&opData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gpvtReadPVTData
+*
+* DESCRIPTION:
+*       This routine reads Cross Chip Port Vlan Data.
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0,
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
+*
+*
+* INPUTS:
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*
+* OUTPUTS:
+*        pvtData    - Cross Chip Port Vlan Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpvtReadPVTData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        pvtPointer,
+    OUT GT_U32        *pvtData
+)
+{
+    GT_STATUS           retVal;
+    GT_PVT_OPERATION    op;
+    GT_PVT_OP_DATA        opData;
+
+    DBG_INFO(("gpvtReadPVTData Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if (pvtPointer > 0x1FF)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = PVT_READ;
+    opData.pvtAddr = pvtPointer;
+    retVal = pvtOperationPerform(dev,op,&opData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    opData.pvtData &= (1 << dev->maxPorts) - 1;
+    *pvtData = GT_PORTVEC_2_LPORTVEC(opData.pvtData);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/****************************************************************************/
+/* Internal functions.                                                  */
+/****************************************************************************/
+
+
+/*******************************************************************************
+* pvtOperationPerform
+*
+* DESCRIPTION:
+*       This function accesses PVT Table
+*
+* INPUTS:
+*       pvtOp   - The pvt operation
+*       pvtData - address and data to be written into PVT
+*
+* OUTPUTS:
+*       pvtData - data read from PVT pointed by address
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pvtOperationPerform
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_PVT_OPERATION   pvtOp,
+    INOUT GT_PVT_OP_DATA     *opData
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the pvt in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PVT_ADDR;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PVT_ADDR,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    /* Set the PVT Operation register */
+    switch (pvtOp)
+    {
+        case PVT_INITIALIZE:
+            data = (1 << 15) | (pvtOp << 12);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PVT_WRITE:
+            data = (GT_U16)opData->pvtData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (pvtOp << 12) | opData->pvtAddr);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PVT_READ:
+            data = (GT_U16)((1 << 15) | (pvtOp << 12) | opData->pvtAddr);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 1;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PVT_ADDR;
+              regAccess.rw_reg_list[0].data = 15;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+            }
+#else
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PVT_ADDR,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->tblRegsSem);
+                    return retVal;
+                }
+            }
+#endif
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_PVT_DATA,&data);
+            opData->pvtData = (GT_U32)data;
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+            break;
+
+        default:
+
+            gtSemGive(dev,dev->tblRegsSem);
+            return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+    return retVal;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtEvents.c
@@ -0,0 +1,1519 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtEvents.c
+*
+* DESCRIPTION:
+*       API definitions for system interrupt events handling.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/*******************************************************************************
+* eventSetActive
+*
+* DESCRIPTION:
+*       This routine enables/disables the receive of an hardware driven event.
+*
+* INPUTS:
+*       eventType - the event type. any combination of the folowing:
+*           GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL(or GT_ATU_PROB),
+*           GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, GT_DEVICE_INT,
+*            and GT_AVB_INTERRUPT
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Each switch device has its own set of event Types. Please refer to the
+*        device datasheet for the list of event types that the device supports.
+*
+*******************************************************************************/
+GT_STATUS eventSetActive
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U32      eventType
+)
+{
+    GT_STATUS   retVal;
+    GT_U16     data;
+    GT_U16    intMask;
+    GT_U8     len;
+
+    DBG_INFO(("eventSetActive Called.\n"));
+
+    data = (GT_U16) eventType;
+    len = 9;
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY_ONLY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_DEV_PHY_INTERRUPT)))
+    {
+        intMask = GT_NO_INTERNAL_PHY_INT_MASK;
+    }
+    else
+    {
+        intMask = GT_INT_MASK;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_INTERRUPT))
+    {
+        intMask &= ~GT_AVB_INT;
+        len = 8;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
+    {
+        intMask &= ~GT_DEVICE_INT;
+        len = 7;
+    }
+
+
+    if(data & ~intMask)
+    {
+        DBG_INFO(("Invalid event type.\n"));
+        return GT_FAIL;
+    }
+
+    /* Set the IntEn bit.               */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,0,len,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* eventGetIntStatus
+*
+* DESCRIPTION:
+*       This routine reads an hardware driven event status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       intCause - It provides the source of interrupt of the following:
+*               GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,
+*               GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, GT_DEVICE_INT,
+*                and GT_AVB_INTERRUPT
+*                For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_PROB and
+*                if there is no internal phy, GT_PHY_INTERRUPT is not supported.
+*
+* RETURNS:
+*       GT_OK   - read success.
+*       GT_FAIL - otherwise
+*
+* COMMENTS:
+*       Each switch device has its own set of event Types. Please refer to the
+*        device datasheet for the list of event types that the device supports.
+*
+*******************************************************************************/
+GT_STATUS eventGetIntStatus
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_U16   *intCause
+)
+{
+    GT_STATUS     retVal;         /* Function calls return value.     */
+    GT_U8         len;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_AVB_INTERRUPT))
+        len = 9;
+    else if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
+        len = 8;
+    else
+        len = 7;
+
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,0,len,intCause);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gvtuGetIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of VTU interrupt occured
+*
+* INPUTS:
+*       intType - the type of interrupt which causes an interrupt.
+*            any combination of
+*            GT_MEMEBER_VIOLATION,
+*            GT_MISS_VIOLATION,
+*            GT_FULL_VIOLATION
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*     FULL_VIOLATION is not supported by all switch devices.
+*    Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gvtuGetIntStatus
+(
+    IN GT_QD_DEV          *dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+)
+{
+    GT_STATUS       retVal;
+
+    DBG_INFO(("gvtuGetIntStatus Called.\n"));
+
+    /* check if device supports this feature */
+    if((IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK )
+      return GT_FAIL;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        retVal = gvtuGetViolation2(dev,vtuIntStatus);
+    }
+    else if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+              (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = gvtuGetViolation3(dev,vtuIntStatus);
+    }
+    else
+    {
+        retVal = gvtuGetViolation(dev,vtuIntStatus);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gatuGetIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of ATU interrupt occured
+*
+* INPUTS:
+*          intType - the type of interrupt which causes an interrupt.
+*            any combination of
+*            GT_AGE_OUT_VIOLATION,
+*            GT_AGE_VIOLATION,
+*            GT_MEMEBER_VIOLATION,
+*            GT_MISS_VIOLATION,
+*            GT_FULL_VIOLATION
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gatuGetIntStatus
+(
+    IN GT_QD_DEV          *dev,
+    OUT GT_ATU_INT_STATUS *atuIntStatus
+)
+{
+    GT_STATUS       retVal;
+
+    DBG_INFO(("gatuGetIntStatus Called.\n"));
+
+    /* check if device supports this feature */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gatuGetViolation(dev,atuIntStatus);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* geventGetDevIntStatus
+*
+* DESCRIPTION:
+*         Check to see which device interrupts (WatchDog, JamLimit, Duplex Mismatch,
+*        SERDES Link Int, and Phy Int) have occurred.
+*
+* INPUTS:
+*       intType - the type of interrupt which causes an interrupt.
+*                  any combination of
+*                    GT_DEV_INT_WATCHDOG,
+*                    GT_DEV_INT_JAMLIMIT,
+*                    GT_DEV_INT_DUPLEX_MISMATCH,
+*                    GT_DEV_INT_SERDES_LINK
+*                    GT_DEV_INT_WAKE_EVENT
+*                    GT_DEV_INT_PHY
+*        port    - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
+*                  valid only if GT_DEV_INT_DUPLEX_MISMATCH is set in intType.
+*        linkInt - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
+*                  asserted. It's in vector format, Bit 10 is for port 10,
+*                  Bit 9 is for port 9, etc.
+*                  valid only if GT_DEV_INT_SERDES_LINK bit is set in intType.
+*                  These bits are only valid of the port that is in 1000Base-X mode.
+*        phyInt  - port list where GT_DEV_INT_PHY interrupt is asserted.
+*                  It's in vector format, Bit 0 is for port 0, Bit 1 is for port 1, etc.
+*                  valid only if GT_DEV_INT_PHY bit is set in intType.
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK - on success
+*         GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS geventGetDevIntStatus
+(
+    IN  GT_QD_DEV             *dev,
+    OUT GT_DEV_INT_STATUS    *devIntStatus
+)
+{
+    GT_STATUS       retVal;
+    GT_U16            data, hwPort;
+
+    DBG_INFO(("geventGetDevIntStatus Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    devIntStatus->devIntCause = 0;
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_DEVINT_SOURCE,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* check SERDES Link Int and Phy Int, if applicable */
+    if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
+    {
+        /* check SERDES Link Int */
+        if (data & (0x7 << 8))
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_SERDES_LINK;
+            devIntStatus->linkInt = GT_PORTVEC_2_LPORTVEC((data & (7<<8)));
+        }
+    }
+    else  if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE2))  /* DEV_DEVICE_INT_TYPE2 */
+    {
+        if (data & (0x3 << 11))
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_SERDES_LINK;
+            devIntStatus->linkInt = GT_PORTVEC_2_LPORTVEC((data & (0x3 << 11)) >> 7);
+        }
+
+        if (data & 0x1F)
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_PHY;
+            devIntStatus->phyInt = GT_PORTVEC_2_LPORTVEC((data & 0x1F));
+        }
+    }
+    else /* DEV_DEVICE_INT_TYPE3 */
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE3))  /* DEV_DEVICE_INT_TYPE3 */
+      {
+        if (data & QD_DEV_INT_WAKE_EVENT)
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_WAKE_EVENT;
+        }
+      }
+
+        if (data & 0x1F)
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_PHY;
+            devIntStatus->phyInt = GT_PORTVEC_2_LPORTVEC((data & 0x1F));
+        }
+    }
+
+    if (data & QD_DEV_INT_DUPLEX_MISMATCH)
+    {
+        devIntStatus->devIntCause |= GT_DEV_INT_DUPLEX_MISMATCH;
+
+        /* read port that causes the interrupt */
+        retVal = hwGetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, &hwPort);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        /* re-arm the interrupt event */
+        retVal = hwSetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, 0xF);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        devIntStatus->port = GT_PORT_2_LPORT((GT_U8)hwPort);
+    }
+
+    if (data & QD_DEV_INT_WATCHDOG)
+    {
+        devIntStatus->devIntCause |= GT_DEV_INT_WATCHDOG;
+    }
+
+    if (data & QD_DEV_INT_JAMLIMIT)
+    {
+        devIntStatus->devIntCause |= GT_DEV_INT_JAMLIMIT;
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* geventSetAgeIntEn
+*
+* DESCRIPTION:
+*        This routine enables/disables Age Interrupt for a port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort)
+*        and the ingressing frame's SA is contained in the ATU as a non-Static
+*        entry with a EntryState less than 0x4.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventSetAgeIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("geventSetAgeIntEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_BASED_AGE_INT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Age Interrupt Enable Mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,11,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* geventGetAgeIntEn
+*
+* DESCRIPTION:
+*        This routine gets Age Interrupt Enable for the port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort)
+*        and the ingressing frame's SA is contained in the ATU as a non-Static
+*        entry with a EntryState less than 0x4.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventGetAgeIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("geventGetAgeIntEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_BASED_AGE_INT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get Age Interrupt Enable Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,11,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* geventSetAgeOutIntEn
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Out Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventSetAgeOutIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("geventSetAgeOutIntEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Age Out Interrupt Enable Mode. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,14,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* geventGetAgeOutIntEn
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_TRUE, if Age Out Interrupt is enabled
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventGetAgeOutIntEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("geventGetAgeOutIntEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get Age Out Interrupt Enable Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,14,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* geventSetOverLimitInt
+*
+* DESCRIPTION:
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbGetPortAtuLimitReached API).
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventSetOverLimitInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("geventSetOverLimitInt Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Over Limit Interrupt Enable Mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 13, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* geventGetOverLimitInt
+*
+* DESCRIPTION:
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbSetPortAtuLearnLimit API).
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS geventGetOverLimitInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("geventGetOverLimitInt Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set Over Limit Interrupt Enable Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 13, 1, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* geventGetPortAtuLimitReached
+*
+* DESCRIPTION:
+*       This routine checks if learn limit has been reached.
+*        When it reached, the port can no longer auto learn any more MAC addresses
+*        because the address learn limit set on this port has been reached.
+*
+* INPUTS:
+*       port  - logical port number
+*
+* OUTPUTS:
+*       limit - GT_TRUE, if limit has been reached
+*                GT_FALSE, otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*
+*******************************************************************************/
+GT_STATUS geventGetPortAtuLimitReached
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_BOOL       *limit
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("geventGetPortAtuLimitReached Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Check device if this feature is supported. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the LimitReached bit. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 14, 1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *limit);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* eventSetDevInt
+*
+* DESCRIPTION:
+*        Device Interrupt.
+*        The following device interrupts are supported:
+*            GT_DEV_INT_WATCHDOG    -
+*                WatchDog event interrupt (WatchDog event can be configured with
+*                gwdSetEvent API)
+*            GT_DEV_INT_JAMLIMIT    -
+*                any of the ports detect an Ingress Jam Limit violation
+*                (see gprtSetPauseLimitIn API)
+*            GT_DEV_INT_DUPLEX_MISMATCH -
+*                any of the ports detect a duplex mismatch (i.e., the local port is
+*                in half duplex mode while the link partner is in full duplex mode)
+*            GT_DEV_INT_WAKE_EVENT -
+*                any of the ports detect a Wake event interrupt
+*            GT_DEV_INT_SERDES_LINK -
+*                SERDES link change interrupt.
+*                An interrupt occurs when a SERDES port changes link status
+*                (link up or link down)
+*            GT_DEV_INT_PHY - Phy interrupt.
+*
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled event when GT_DEV_INT is enabled with
+*        eventSetActive API.
+*
+* INPUTS:
+*        devInt - GT_DEV_INT
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS eventSetDevInt
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_DEV_EVENT    *devInt
+)
+{
+    GT_U16          data, event;
+    GT_U16            serdesMask=0, phyMask=0, mask=0;
+    GT_U32            pList;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("eventSetDevInt Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    event = (GT_U16)devInt->event;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
+    {
+        serdesMask = mask = 7 << 8;    /* SERDES Port List */
+        phyMask = 0;
+    }
+    else if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE2))
+    {
+        serdesMask = mask = 3 << 11;    /* SERDES Port List */
+        mask |= 0x1F;    /* Phy list */
+        phyMask = 0x1F;
+    }
+    else
+    {
+        mask |= 0x1F;    /* Phy list */
+        phyMask = 0x1F;
+    }
+    mask |= QD_DEV_INT_WATCHDOG | QD_DEV_INT_JAMLIMIT | QD_DEV_INT_DUPLEX_MISMATCH | QD_DEV_INT_WAKE_EVENT ;
+
+    data = 0;
+
+     if (event & GT_DEV_INT_SERDES_LINK)
+     {
+        /* check for valid SERDES Port List */
+        if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
+        {
+            pList = GT_LPORTVEC_2_PORTVEC(devInt->portList);
+            if ((GT_U16)pList & (~serdesMask))
+            {
+                DBG_INFO(("GT_BAD_PARAM portList\n"));
+                return GT_BAD_PARAM;
+            }
+            data = (GT_U16)pList;
+        }
+        else
+        {
+            pList = GT_LPORTVEC_2_PORTVEC(devInt->portList);
+            pList <<= 7;
+            if ((GT_U16)pList & (~serdesMask))
+            {
+                DBG_INFO(("GT_BAD_PARAM portList\n"));
+                return GT_BAD_PARAM;
+            }
+            data = (GT_U16)pList;
+        }
+    }
+
+    if (event & GT_DEV_INT_PHY)
+    {
+        /* check for valid Phy List */
+        if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
+         {
+            DBG_INFO(("GT_BAD_PARAM: PHY Int not supported.\n"));
+             return GT_BAD_PARAM;
+         }
+        else
+        {
+            pList = GT_LPORTVEC_2_PORTVEC(devInt->phyList);
+            if ((GT_U16)pList & (~phyMask))
+            {
+                DBG_INFO(("GT_BAD_PARAM phyList\n"));
+                return GT_BAD_PARAM;
+            }
+
+            data |= (GT_U16)pList;
+        }
+     }
+
+    if (event & GT_DEV_INT_WATCHDOG)
+    {
+        data |= QD_DEV_INT_WATCHDOG;
+    }
+
+    if (event & GT_DEV_INT_JAMLIMIT)
+    {
+        data |= QD_DEV_INT_JAMLIMIT;
+    }
+
+    if (event & GT_DEV_INT_DUPLEX_MISMATCH)
+    {
+        data |= QD_DEV_INT_DUPLEX_MISMATCH;
+    }
+
+    if (event & GT_DEV_INT_WAKE_EVENT)
+    {
+        data |= QD_DEV_INT_WAKE_EVENT;
+    }
+
+    if (data & (~mask))
+    {
+        DBG_INFO(("GT_BAD_PARAM portList\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (data & GT_DEV_INT_DUPLEX_MISMATCH)
+    {
+        retVal = hwSetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, 0xF);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+
+    /* Set the related bit. */
+    retVal = hwSetGlobal2RegBits(dev,QD_REG_DEVINT_MASK, mask, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gwdSetEvent
+*
+* DESCRIPTION:
+*        Watch Dog Event.
+*        The following Watch Dog events are supported:
+*            GT_WD_QC  - Queue Controller Watch Dog enable.
+*                        When enabled, the QC's watch dog circuit checks for link
+*                        list errors and any errors found in the QC.
+*            GT_WD_EGRESS - Egress Watch Dog enable.
+*                        When enabled, each port's egress circuit checks for problems
+*                        between the port and the Queue Controller.
+*            GT_WD_FORCE - Force a Watch Dog event.
+*
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled WatchDog event when GT_DEV_INT_WATCHDOG is
+*        enabled with eventSetDevActive API and GT_DEV_INT is enabled with
+*        eventSetActive API.
+*
+* INPUTS:
+*        wdEvent - Watch Dog Events
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdSetEvent
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        wdEvent
+)
+{
+    GT_U16          data, mask;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gwdSetEvent Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    mask = (1 << 5) | (1 << 3) | (1 << 2);
+    data = 0;
+
+    if (wdEvent & GT_WD_QC)
+    {
+        data |= (1 << 5);
+    }
+
+    if (wdEvent & GT_WD_EGRESS)
+    {
+        data |= (1 << 3);
+    }
+
+    if (wdEvent & GT_WD_FORCE)
+    {
+        data |= (1 << 2);
+    }
+
+    /* Set the related bit. */
+    retVal = hwSetGlobal2RegBits(dev,QD_REG_WD_CONTROL, mask, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gwdSetSWResetOnWD
+*
+* DESCRIPTION:
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API)
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
+*
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this
+*        automatic SWReset. This allows the user to know if any watch dog event
+*        ever occurred even if the swich is configured to automatically recover
+*        from a watch dog.
+*
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
+*
+* INPUTS:
+*        en   - GT_TRUE to enable SWReset on WD
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdSetSWResetOnWD
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gwdSetSWResetOnWD Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the related bit. */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_WD_CONTROL, 0, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gwdGetSWResetOnWD
+*
+* DESCRIPTION:
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API)
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
+*
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this
+*        automatic SWReset. This allows the user to know if any watch dog event
+*        ever occurred even if the swich is configured to automatically recover
+*        from a watch dog.
+*
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en   - GT_TRUE, if SWReset on WD is enabled
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdGetSWResetOnWD
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gwdSetSWResetOnWD Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the related bit. */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_WD_CONTROL, 0, 1, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gwdGetHistory
+*
+* DESCRIPTION:
+*        This routine retrieves Watch Dog history. They are
+*
+*        wdEvent -
+*            When it's set to GT_TRUE, some enabled Watch Dog event occurred.
+*            The following events are possible:
+*                QC WatchDog Event (GT_WD_QC)
+*                Egress WatchDog Event (GT_WD_EGRESS)
+*                Forced WatchDog Event (GT_WD_FORCE)
+*        egressEvent -
+*            If any port's egress logic detects an egress watch dog issue,
+*            this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
+*            event.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        history - GT_WD_EVENT_HISTORY structure
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdGetHistory
+(
+    IN  GT_QD_DEV            *dev,
+    OUT GT_WD_EVENT_HISTORY    *history
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gwdSetSWResetOnWD Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the related bit. */
+    retVal = hwReadGlobal2Reg(dev,QD_REG_WD_CONTROL,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if (data & (1 << 4))
+    {
+        history->egressEvent = GT_TRUE;
+    }
+    else
+    {
+        history->egressEvent = GT_FALSE;
+    }
+
+    if (data & (1 << 1))
+    {
+        history->wdEvent = GT_TRUE;
+    }
+    else
+    {
+        history->wdEvent = GT_FALSE;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gwdSetRMUTimeOut
+*
+* DESCRIPTION:
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
+*
+*        When this bit is cleared to a zero the Wait on Bit command will wait
+*        until the bit that is being tested has changed to the specified value.
+*
+* INPUTS:
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE to disable
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdSetRMUTimeOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gwdSetRMUTimeOut Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the related bit. */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_WD_CONTROL, 6, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gwdGetRMUTimeOut
+*
+* DESCRIPTION:
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
+*
+*        When this bit is cleared to a zero the Wait on Bit command will wait
+*        until the bit that is being tested has changed to the specified value.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdGetRMUTimeOut
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gwdGetRMUTimeOut Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the related bit. */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_WD_CONTROL, 6, 1, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gwdGetEgressWDEvent
+*
+* DESCRIPTION:
+*        If any port's egress logic detects an egress watch dog issue, this bit
+*        will be set to a one, regardless of the setting of the GT_WD_EGRESS in
+*        gwdSetEvent function.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        event - GT_TRUE, if egress logic has detected any egress watch dog issue
+*                GT_FALUSE, otherwise
+*
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gwdGetEgressWDEvent
+(
+    IN  GT_QD_DEV        *dev,
+    OUT GT_BOOL            *event
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gwdGetEgressWDEvent Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the related bit. */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_WD_CONTROL, 7, 1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *event);
+
+    return retVal;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtMisc.c
@@ -0,0 +1,2188 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtMisc.c
+*
+* DESCRIPTION:
+*       API definitions for Ip Mapping Table
+*                            EEPROM access
+*                            Scratch and Misc Control
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gsysSetUseIpMappingTable
+*
+* DESCRIPTION:
+*        This API set to use IP Frame Priorities from this table.
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*
+* INPUTS:
+*        en    - [GT_TRUE] / [GT_FALSE]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetUseIpMappingTable
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_BOOL            en
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+
+    DBG_INFO(("gsysSetUseIpMappingTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    data = (en==GT_TRUE)?1:0;
+
+    retVal = hwSetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,14,1,data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetUseIpMappingTable
+*
+* DESCRIPTION:
+*        This API get to use IP Frame Priorities from this table.
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en    - [GT_TRUE] / [GT_FALSE]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetUseIpMappingTable
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_BOOL            *en
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+
+    DBG_INFO(("gsysGetUseIpMappingTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+
+    retVal = hwGetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,14,1,&data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *en= (data==1)?GT_TRUE:GT_FALSE;
+
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetIpMappingPrio
+*
+* DESCRIPTION:
+*        Set IPv4 and IPv6 Frame Priority Mapping, and
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frame's initial FPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04)
+*        is configured to use IP FPris.
+*       The ipQpri value is used as the frames initial QPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth
+*        registers (Port offset 0x04) are configured to use IP QPris.
+*
+* INPUTS:
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetIpMappingPrio
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    IN  GT_U8            ipFpri,
+    IN  GT_U8            ipQpri
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+
+    DBG_INFO(("gsysSetIpMappingPrio Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if ((point>0x3f)||(ipFpri>7)||(ipQpri>3))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Scratch and Misc control is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_IP_MAPPING_TABLE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
+       data = 1;
+    while(data == 1)
+       {
+        retVal = hwGetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,15,1,&data);
+           if(retVal != GT_OK)
+           {
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+           }
+    }
+#endif
+
+    data = (((ipFpri&7)<<4) | (ipQpri&3));
+    data |=  ((GT_U16)((1 << 15) | (point << 8)));
+
+    retVal = hwWriteGlobalReg(dev, QD_REG_IP_MAPPING_TABLE, data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetIpMappingPrio
+*
+* DESCRIPTION:
+*        Get IPv4 and IPv6 Frame Priority Mapping, and
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frame's initial FPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04)
+*        is configured to use IP FPris.
+*        The ipQpri value is used as the frames initial QPRI when the frame is
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth
+*        registers (Port offset 0x04) are configured to use IP QPris.
+*
+* INPUTS:
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
+*
+* OUTPUTS:
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetIpMappingPrio
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    OUT  GT_U8            *ipFpri,
+    OUT  GT_U8            *ipQpri
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+
+    DBG_INFO(("gsysGetIpMappingPrio Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (point > 0x3f)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_IP_MAPPING_TABLE;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_IP_MAPPING_TABLE;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+    do {
+        retVal = hwReadGlobalReg(dev, QD_REG_IP_MAPPING_TABLE, &data);
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+    } while (data&0x8000);
+#endif
+
+
+    *ipFpri = (data >> 4) & 7;
+    *ipQpri = (data) & 3;
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* eepromOperationPerform
+*
+* DESCRIPTION:
+*       This function accesses EEPROM Command Register and Data Register.
+*       The device supports the following EEPROM
+*            operations
+*            GT_EEPROM_NO_OP = No Operation
+*            GT_EEPROM_WRITE_DATA = Write EEPROM at Addr.
+*            GT_EEPROM_READ_DATA = Read EEPROM from Addr.
+*            GT_EEPROM_RESTART = Restart Register Loader execution at Addr
+*                (eepromData = dont care in this case)
+*            GT_EEPROM_HALT = Halt (stop executing the EEPROM if its not already
+*                stopped)
+*
+* INPUTS:
+*       eepromOp      - EEPROM Opcode.
+*       eepromData    - Data to be written to the EEPROM
+*
+* OUTPUTS:
+*       eepromData    - Data that was read back from the EEPROM.
+*
+Command register above.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*       GT_BAD_PARAM - if input parameters are beyond range.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS eepromOperationPerform
+(
+    IN    GT_QD_DEV             *dev,
+    IN    GT_EEPROM_OPERATION    eepromOp,
+    INOUT GT_EEPROM_OP_DATA        *opData
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+    DBG_INFO(("eepromOperationPerform Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EEPROM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (eepromOp>GT_EEPROM_HALT)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->eepromRegsSem,OS_WAIT_FOREVER);
+
+
+    /* Wait until the eeprom in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_EEPROM_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->eepromRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+
+    /* Set the EEPROM Operation register */
+    switch (eepromOp)
+    {
+        case GT_EEPROM_WRITE_DATA:
+            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,10,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+            if (data==0)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                DBG_INFO(("EEPROM is not writablen"));
+                return GT_FAIL;
+            }
+
+            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+            if (data==1)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                DBG_INFO(("EEPROM Loader is running"));
+                return GT_FAIL;
+            }
+
+            data = (GT_U16)opData->eepromData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (GT_EEPROM_WRITE_DATA << 12) |
+                    (opData->eepromAddr & 0xFF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+            break;
+
+        case GT_EEPROM_READ_DATA:
+            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+            if (data==1)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                DBG_INFO(("EEPROM Loader is running"));
+                return GT_FAIL;
+            }
+
+            data = (GT_U16)((1 << 15) | (GT_EEPROM_READ_DATA << 12) |
+                    (opData->eepromAddr & 0xFF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+
+
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 1;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_EEPROM_COMMAND;
+              regAccess.rw_reg_list[0].data = 15;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+              }
+            }
+#else
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->eepromRegsSem);
+                    return retVal;
+                }
+            }
+#endif
+
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_EEPROM_DATA,&data);
+            opData->eepromData = (GT_U32)data;
+
+            break;
+
+        case GT_EEPROM_RESTART:
+            data = (GT_U16)((1 << 15) | (GT_EEPROM_RESTART << 12) |
+                    (opData->eepromAddr & 0xFF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+
+
+            break;
+
+        case GT_EEPROM_HALT:
+            data = (GT_U16)((1 << 15) | (GT_EEPROM_HALT << 12) |
+                    (opData->eepromAddr & 0xFF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+
+            break;
+        default:
+            gtSemGive(dev,dev->eepromRegsSem);
+            return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->eepromRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysReadEeprom
+*
+* DESCRIPTION:
+*        Read EEPROM from EEPROMs address where the EEOp is performed.
+*
+* INPUTS:
+*        addr - EEPROM Address.
+*
+* OUTPUTS:
+*        data -  Data that was read back from the EEPROM.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysReadEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr,
+    OUT  GT_U8            *data
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_EEPROM_OPERATION    eepromOp;
+    GT_EEPROM_OP_DATA    opData;
+
+    eepromOp = GT_EEPROM_READ_DATA;
+    opData.eepromAddr = addr;
+
+    retVal = eepromOperationPerform(dev,eepromOp,&opData);
+    if(retVal != GT_OK)
+    {
+      return retVal;
+    }
+    *data = (GT_U8)opData.eepromData;
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gsysWriteEeprom
+*
+* DESCRIPTION:
+*        Write EEPROM at the EEPROMs address where the EEOp is performed.
+*
+* INPUTS:
+*        addr - EEPROM Address.
+*        data - Data to be written to the EEPROM
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysWriteEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr,
+    IN  GT_U8            data
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_EEPROM_OPERATION    eepromOp;
+    GT_EEPROM_OP_DATA    opData;
+
+    eepromOp = GT_EEPROM_WRITE_DATA;
+    opData.eepromAddr = addr;
+    opData.eepromData = data;
+
+    retVal = eepromOperationPerform(dev,eepromOp,&opData);
+    if(retVal != GT_OK)
+    {
+      return retVal;
+    }
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysRestartEeprom
+*
+* DESCRIPTION:
+*        Restart Register Loader execution at the EEPROMs address where the EEOp
+*        is performed
+*
+* INPUTS:
+*        addr - EEPROM Address. .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysRestartEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_EEPROM_OPERATION    eepromOp;
+    GT_EEPROM_OP_DATA    opData;
+
+    eepromOp = GT_EEPROM_RESTART;
+    opData.eepromAddr = addr;
+
+    retVal = eepromOperationPerform(dev,eepromOp,&opData);
+    if(retVal != GT_OK)
+    {
+      return retVal;
+    }
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysHaltEeprom
+*
+* DESCRIPTION:
+*        Halt (stop executing the EEPROM if its not already stopped)
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysHaltEeprom
+(
+    IN  GT_QD_DEV         *dev
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_EEPROM_OPERATION    eepromOp;
+    GT_EEPROM_OP_DATA    opData;
+
+    eepromOp = GT_EEPROM_HALT;
+
+    retVal = eepromOperationPerform(dev,eepromOp,  &opData);
+    if(retVal != GT_OK)
+    {
+      return retVal;
+    }
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysGetStEeprom
+*
+* DESCRIPTION:
+*        Get EEPROM status. They are Register Loader Running status and EEPROM
+*        Write Enable status
+*        runSt is GT_TRUE: Register Loader Running, whenever the register loader
+*            is busy executing the instructions contained in the EEPROM.
+*        writeEn is GT_TRUE: EEPROM Write Enable, that indicates that writing to
+*            the EEPROM is possible.
+*        writeEn is GT_FALSE: the Write EEPROM EEOp above will not do anything.
+*            This reflects the value of the EE_WE configuration pin after Reset.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        runSt   -   [GT_TRUE] / [GT_FALSE)
+*        writeEn -   [GT_TRUE] / [GT_FALSE)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetStEeprom
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_BOOL            *writeEn,
+    OUT GT_BOOL            *runSt
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16      data;             /* temporary Data storage */
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EEPROM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_EEPROM_COMMAND, &data);
+    if(retVal != GT_OK)
+    {
+           return retVal;
+    }
+
+
+    *runSt   = (data&GT_EEPROM_OP_ST_RUNNING_MASK)?GT_TRUE:GT_FALSE;
+    *writeEn = (data&GT_EEPROM_OP_ST_WRITE_EN_MASK)?GT_TRUE:GT_FALSE;
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysSetScratchMiscCtrl
+*
+* DESCRIPTION:
+*        Set Scratch and Misc control data to the Scratch and Misc Control register.
+*        The registers of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
+*
+* INPUTS:
+*        point - Pointer to the Scratch and Misc. Control register.
+*        data  - Scratch and Misc. Control data written to the register
+*                pointed to by the point above.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetScratchMiscCtrl
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    IN  GT_U8            data
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    IN  GT_U16            tmpData;
+
+    if (point > GT_SCRAT_MISC_REG_MAX)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (data &0xffffff00)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* program QoS Weight Table, 4 sequences at a time */
+
+    /* Wait until the Scratch and Misc control is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SCRATCH_MISC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
+       tmpData = 1;
+    while(tmpData == 1)
+       {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_SCRATCH_MISC,15,1,&tmpData);
+           if(retVal != GT_OK)
+           {
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+           }
+    }
+#endif
+
+    tmpData =  (GT_U16)((1 << 15) | (point << 8) | data);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_SCRATCH_MISC, tmpData);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+       return retVal;
+
+}
+
+
+
+/*******************************************************************************
+* gsysGetScratchMiscCtrl
+*
+* DESCRIPTION:
+*        Get Scratch and Misc control data from the Scratch and Misc Control register.
+*        The register of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
+
+*
+* INPUTS:
+*        point - Pointer to the Scratch and Misc. Control register.
+*
+* OUTPUTS:
+*        data - Scratch and Misc. Control data read from the register
+*                pointed to by the point above.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetScratchMiscCtrl
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    OUT  GT_U8            *data
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    OUT  GT_U16            tmpData;
+
+    if (point > GT_SCRAT_MISC_REG_MAX)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (point>0x7f)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* program QoS Weight Table, 4 sequences at a time */
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SCRATCH_MISC;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_SCRATCH_MISC;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+     }
+     tmpData = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+    do {
+        retVal = hwReadGlobal2Reg(dev, QD_REG_SCRATCH_MISC, &tmpData);
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+    } while (tmpData&0x8000);
+#endif
+
+    *data = tmpData&0xff;
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gsysSetScratchBits
+*
+* DESCRIPTION:
+*        Set bits to the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired.
+*        These bits do not connect to any hardware function.
+*
+* INPUTS:
+*        scritch - written bits.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetScratchBits
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U16            scratch
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetScratchBits Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_0, (GT_U8)(scratch&0xff));
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_1, (GT_U8)((scratch>>8)&0xff));
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gsysGetScratchBits
+*
+* DESCRIPTION:
+*        Get bits from the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired.
+*        These bits do not connect to any hardware function.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        scritch - read bits.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetScratchBits
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U16            *scratch
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysGetScratchBits Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_1, &data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+    *scratch = data;
+    *scratch = *scratch<<8;
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_0, &data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *scratch |= data;
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysSetGpioConfigMod
+*
+* DESCRIPTION:
+*        Set bits to the Scratch and Misc Control register <GPIO Configuration>
+*        to configure GPIO mode.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only.
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
+*
+* INPUTS:
+*        mode - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetGpioConfigMod
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            mode
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetGpioConfigMod Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG, (GT_U8)(mode&0x7f));
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysGetGpioConfigMod
+*
+* DESCRIPTION:
+*        Get mode from the Scratch and Misc Control register <GPIO Configuration>.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only.
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetGpioConfigMod
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            *mode
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysGetGpioConfigMod Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG, &data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *mode = 0x7f&data;
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysSetGpioDirection
+*
+* DESCRIPTION:
+*        Set Gpio direction to the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0].
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        dir - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetGpioDirection
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            dir
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetGpioDirection Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR, (GT_U8)(dir&0x7f));
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysGetGpioDirection
+*
+* DESCRIPTION:
+*        get Gpio direction from the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0].
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        dir - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetGpioDirection
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U32            *dir
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysGetGpioDirection Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR, &data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *dir = data;
+
+    return GT_OK;
+
+}
+
+
+
+/*******************************************************************************
+* gsysSetGpioData
+*
+* DESCRIPTION:
+*        Set Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go
+*        to a holding register but will not appear on the pin nor in this register.
+*        Reads of this register will return the actual, real-time, data that is
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go
+*        to a holding register and will appear on the GPIOs pin. Reads of this register
+*        will return the actual, real-time, data that is appearing on the GPIOs pin
+*        (which in this case should be the data written, but if its isnt that would
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        data - OR [GT_GPIO_BIT_x]
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetGpioData
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            data
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetGpioData Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT, (GT_U8)(data&0x7f));
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gsysGetGpioData
+*
+* DESCRIPTION:
+*        get Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go
+*        to a holding register but will not appear on the pin nor in this register.
+*        Reads of this register will return the actual, real-time, data that is
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go
+*        to a holding register and will appear on the GPIOs pin. Reads of this register
+*        will return the actual, real-time, data that is appearing on the GPIOs pin
+*        (which in this case should be the data written, but if its isnt that would
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        data - OR [GT_GPIO_BIT_x]
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetGpioData
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            *data
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        tmpData;
+
+    DBG_INFO(("gsysGetGpioData Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT, &tmpData);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *data = tmpData;
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysGetConfigData
+*
+* DESCRIPTION:
+*        Get Reset Configuration Pin Data 0-3.
+*        These registers return the values observed after a hardware Reset on the
+*        listed CONFIG data listed below.
+*            Config data 0:
+*              Bit    Config    Pin's Primary Name
+*                0    USER[0]        P6_OUTD[5]
+*                1    USER[1]        P6_OUTD[6]
+*                2    USER[2]        P6_OUTD[7]
+*                3    ADDR[0]        P5_OUTD[0]
+*                4    ADDR[1]        P5_OUTD[5]
+*                5    ADDR[2]        P5_OUTD[6]
+*                6    ADDR]3]        P5_OUTD[7]
+*                7    ADDR[4]        P5_OUTD[1]
+*            Config data 1:
+*                0    LED_SEL[0]    P1_LED
+*                1    LED_SEL[1]    P2_LED
+*                2    4COL P3_LED
+*                3    NormCx        P4_LED
+*                4    Jumbo        P0_LED
+*                5    EE_WE        EE_CS/C2_LED
+*                6    FD_FLOW        EE_CLK/C1_LED
+*                7    HD_FLOW        EE_DIN/C0_LED
+*            Config data 2:
+*                0    P5_MODE[0]    P5_OUTD[2]
+*                1    P5_MODE[1]    P5_OUTD[3]
+*                2    P5_MODE[2]    P5_OUTD[4]
+*                3    Reserved for future use
+*                4    P6_MODE[0]    P6_OUTD[2]
+*                5    P6_MODE[1]    P6_OUTD[3]
+*                6    P6_MODE[2]    P6_OUTD[4]
+*                7    Reserved for future use
+*            Config data 3:
+*                0    RMU_MODE[0] P6_OUTD[0]
+*                1    RMU_MODE[1] P6_OUTD[1]
+*                2    S_VDDOS[0]    PTP_TRIG
+*                3    CLK125EN    CLK125
+*                4    P5_VDDOS[0] P5_GTXCLK
+*                5    P5_VDDOS[1] P5_OUTEN
+*                6    P6_VDDOS[0] P5_GTXCLK
+*                7    P6_VDDOS[1] P6_OUTEN
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       cfgDat - GT_CONFIG_DTTA
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetConfigData
+(
+    IN  GT_QD_DEV             *dev,
+    OUT  GT_CONFIG_DATA        *cfgData
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        tmpData;
+
+    DBG_INFO(("gsysGetConfigData Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT0, &tmpData);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    cfgData->cfgData0.Byte = tmpData;
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT1, &tmpData);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    cfgData->cfgData1.Byte = tmpData;
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT2, &tmpData);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    cfgData->cfgData2.Byte = tmpData;
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT3, &tmpData);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    cfgData->cfgData3.Byte = tmpData;
+
+    return GT_OK;
+
+}
+
+
+
+/*******************************************************************************
+* gsysSetSyncETai
+*
+* DESCRIPTION:
+*        Set SyncE and Tai to the Scratch and Misc. Control register <SyncE and TAI pad>.
+*
+* INPUTS:
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetSyncETai
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysSetSyncETai Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if ((zpr>0x7) || (znr>0x7))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    data = ((zpr&0x7)<<3) | (znr&0x7);
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SYNCE, data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+
+}
+
+
+
+/*******************************************************************************
+* gsysGetSyncETai
+*
+* DESCRIPTION:
+*        Get SyncE and Tai from the Scratch and Misc Control register <SyncE and TAI pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI*
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetSyncETai
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysGetSyncETai Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SYNCE, &data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *zpr = 0x7 &(data>>3);
+    *znr = 0x7 &(data);
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysSetP6_Clock
+*
+* DESCRIPTION:
+*        Set P6_clock to the Scratch and Misc Control register <P6_Clock pad>.
+*
+* INPUTS:
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetP6_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysSetP6_Clock Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if ((zpr>0x7) || (znr>0x7))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    data = ((zpr&0x7)<<3) | (znr&0x7);
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P6_CLK, data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gsysGetP6_Clock
+*
+* DESCRIPTION:
+*       Get P6_clock from the Scratch and Misc Control register <P6_Clock pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetP6_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysGetP6_Clock Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P6_CLK, &data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *zpr = 0x7 &(data>>3);
+    *znr = 0x7 &(data);
+
+    return GT_OK;
+
+}
+
+
+
+
+/*******************************************************************************
+* gsysSetP5_Clock
+*
+* DESCRIPTION:
+*       Set P5_clock to the Scratch and Misc Control register <P5_Clock pad>.
+*
+* INPUTS:
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetP5_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysSetP5_Clock Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if ((zpr>0x7) || (znr>0x7))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    data = ((zpr&0x7)<<3) | (znr&0x7);
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P5_CLK, data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gsysGetP5_Clock
+*
+* DESCRIPTION:
+*       Get P5_clock from the Scratch and Misc Control register <P5_Clock pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetP5_Clock
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysGetP6_Clock Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P5_CLK, &data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *zpr = 0x7 &(data>>3);
+    *znr = 0x7 &(data);
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gsysSetEEPROM
+*
+* DESCRIPTION:
+*       Set EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
+*
+* INPUTS:
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysSetEEPROM
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            dsm,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysSetEEPROM Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if ((zpr>0x7) || (znr>0x7))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    data = ((dsm&0x3)<<6) | ((zpr&0x7)<<3) | (znr&0x7);
+
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEPROM, data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gsysGetEEPROM
+*
+* DESCRIPTION:
+*       Get EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gsysGetEEPROM
+(
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *dsm,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
+
+    DBG_INFO(("gsysGetEEPROM Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEPROM, &data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *dsm = 0x3 &(data>>6);
+    *zpr = 0x7 &(data>>3);
+    *znr = 0x7 &(data);
+
+    return GT_OK;
+
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPCSCtrl.c
@@ -0,0 +1,1937 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPCSCtrl.c
+*
+* DESCRIPTION:
+*       API implementation for 1000BASE-X PCS block register access.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gpcsGetCommaDet
+*
+* DESCRIPTION:
+*        This routine retrieves Comma Detection status in PCS
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetCommaDet
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetCommaDet Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PCS_LINK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the CommaDet bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,15,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetPCSLink
+*
+* DESCRIPTION:
+*        This routine retrieves Link up status in PCS
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSLink
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetPCSLink Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS_LINK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the PCS Link bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,15,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetSyncOK
+*
+* DESCRIPTION:
+*        This routine retrieves SynOK bit. It is set to a one when the PCS has
+*        detected a few comma patterns and is synchronized with its peer PCS
+*        layer.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if synchronized or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetSyncOK
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetSyncOK Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SyncOK bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,14,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsGetSyncFail
+*
+* DESCRIPTION:
+*        This routine retrieves SynFail bit.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetSyncFail
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetSyncFail Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SyncFail bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,13,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsGetAnBypassed
+*
+* DESCRIPTION:
+*        This routine retrieves Inband Auto-Negotiation bypass status.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetAnBypassed
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetAnBypassed Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the AnBypassed bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,12,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetAnBypassMode
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetAnBypassMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetAnBypassMode Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the AnBypass bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,11,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsSetAnBypassMode
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetAnBypassMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetAnBypassMode Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the AnBypass bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,11,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetPCSAnEn
+*
+* DESCRIPTION:
+*        This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSAnEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetPCSAnEn Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        if (!IS_IN_DEV_GROUP(dev, DEV_INTERNAL_GPHY))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+
+        if ((hwPort < 4) || (hwPort > 7))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* Get the PCSAnEn bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,10,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsSetPCSAnEn
+*
+* DESCRIPTION:
+*        This routine sets Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetPCSAnEn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetPCSAnEn Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        if (!IS_IN_DEV_GROUP(dev, DEV_INTERNAL_GPHY))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+
+        if ((hwPort < 4) || (hwPort > 7))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* Get the PCSAnEn bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,10,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsSetRestartPCSAn
+*
+* DESCRIPTION:
+*        This routine restarts PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetRestartPCSAn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetRestartPCSAn Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    data = 1;    /* to set RestartPCSAn bit */
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the RestartPCSAn bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,9,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetPCSAnDone
+*
+* DESCRIPTION:
+*        This routine retrieves completion information of PCS Auto-Negotiation.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE if PCS AN is done or never done
+*                GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSAnDone
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetPCSAnDone Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PCS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given port supports PCS */
+    if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the PCSAnDone bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,8,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetFCValue
+*
+* DESCRIPTION:
+*        This routine sets Flow Control's force value
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetFCValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetFCValue Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the FCValue bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,7,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetFCValue
+*
+* DESCRIPTION:
+*        This routine retrieves Flow Control Value which will be used for Forcing
+*        Flow Control enabled or disabled.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if FC Force value is one (flow control enabled)
+*                 GT_FALSE otherwise (flow control disabled)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetFCValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetFCValue Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the FCValue bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,7,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetForcedFC
+*
+* DESCRIPTION:
+*        This routine forces Flow Control. If FCValue is set to one, calling this
+*        routine with GT_TRUE will force Flow Control to be enabled.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedFC
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetForcedFC Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedFC bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetForcedFC
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Flow Control bit
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedFC bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedFC
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedLink bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gpcsSetLinkValue
+*
+* DESCRIPTION:
+*        This routine sets Link's force value
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force link up, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetLinkValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetLinkValue Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the LinkValue bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,5,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetLinkValue
+*
+* DESCRIPTION:
+*        This routine retrieves Link Value which will be used for Forcing Link
+*        up or down.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Link Force value is one (link up)
+*                 GT_FALSE otherwise (link down)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetLinkValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetLinkValue Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the LinkValue bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,5,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetForcedLink
+*
+* DESCRIPTION:
+*        This routine forces Link. If LinkValue is set to one, calling this
+*        routine with GT_TRUE will force Link to be up.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force link (up or down), GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedLink
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetForcedLink Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedLink bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,4,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetForcedLink
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Link bit
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedLink bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedLink
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedLink bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,4,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetDpxValue
+*
+* DESCRIPTION:
+*        This routine sets Duplex's Forced value. This function needs to be
+*        called prior to gpcsSetForcedDpx.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force full duplex, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetDpxValue
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetDpxValue Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the DpxValue bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,3,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetDpxValue
+*
+* DESCRIPTION:
+*        This routine retrieves Duplex's Forced value
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Duplex's Forced value is set to Full duplex,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetDpxValue
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the DpxValue bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,3,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetForcedDpx
+*
+* DESCRIPTION:
+*        This routine forces duplex mode. If DpxValue is set to one, calling this
+*        routine with GT_TRUE will force duplex mode to be full duplex.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE to force duplex mode, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedDpx
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetForcedDpx Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedDpx bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,2,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetForcedDpx
+*
+* DESCRIPTION:
+*        This routine retrieves Forced Duplex.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if ForcedDpx bit is one,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedDpx
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForcedDpx Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedDpx bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,2,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetForceSpeed
+*
+* DESCRIPTION:
+*        This routine forces Speed.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForceSpeed
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PORT_FORCED_SPEED_MODE  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetForceSpeed Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the Force Speed bits.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,0,2,(GT_U16)mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetForceSpeed
+*
+* DESCRIPTION:
+*        This routine retrieves Force Speed value
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForceSpeed
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PORT_FORCED_SPEED_MODE   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForceSpeed Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForceSpeed bits.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,0,2,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *mode = data;
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetRGMIITimingDelay
+*
+* DESCRIPTION:
+*        RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
+*        IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
+*        Change to this bit are disruptive to normal operation. Hence any changes
+*        to this register must be done only while the port's link is down.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
+*        txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetRGMIITimingDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *rxmode,
+    OUT GT_BOOL      *txmode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetRGMIITimingDelay Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_RGMII_TIMING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+  if(((dev->devName==DEV_88E6165)||(dev->devName==DEV_88E6161))&&
+	  ((hwPort==4)||((hwPort==5)&&(dev->revision==2)))) /* 88E6123 revision A2 */
+  {
+    if(hwWritePortReg(dev,4,0x1A,0x81E7) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+    if(hwReadPortReg(dev,5,0x1A,&data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+	if((hwPort==5)&&(dev->revision==2))  /* 88E6123 revision A2 */
+	{
+      *rxmode = (data & 0x2)?GT_TRUE:GT_FALSE;
+      *txmode = (data & 0x1)?GT_TRUE:GT_FALSE;
+	}
+	else
+	{
+      *rxmode = (data & 0x10)?GT_TRUE:GT_FALSE;
+      *txmode = (data & 0x8)?GT_TRUE:GT_FALSE;
+	}
+
+  }
+  else
+  {
+    /* Get the register bit(s).  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,14,2,&data);
+
+    *rxmode = (data & 0x2)?GT_TRUE:GT_FALSE;
+    *txmode = (data & 0x1)?GT_TRUE:GT_FALSE;
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+  }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsSetRGMIITimingDelay
+*
+* DESCRIPTION:
+*        RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
+*        IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
+*        Change to this bit are disruptive to normal operation. Hence any changes
+*        to this register must be done only while the port's link is down.
+*
+* INPUTS:
+*        port - the logical port number.
+*        rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
+*        txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetRGMIITimingDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      rxmode,
+    IN  GT_BOOL      txmode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetRGMIITimingDelay Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_RGMII_TIMING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+  if(((dev->devName==DEV_88E6165)||(dev->devName==DEV_88E6161))&&
+	  ((hwPort==4)||((hwPort==5)&&(dev->revision==2)))) /* 88E6123 revision A2 */
+  {
+    if(hwWritePortReg(dev,4,0x1A,0x81E7) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+    if(hwReadPortReg(dev,5,0x1A,&data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+	if((hwPort==5)&&(dev->revision==2))  /* 88E6123 revision A2 */
+	{
+	  data &= 0xfff9;
+      data |= (rxmode) ? 0x2 : 0;
+      data |= (txmode) ? 0x1: 0;
+	}
+	else
+	{
+	  data &= 0xffe7;
+      data |= (rxmode) ? 0x10 : 0;
+      data |= (txmode) ? 0x8: 0;
+	}
+    if(hwWritePortReg(dev,5,0x1A, data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+     if(hwWritePortReg(dev,4,0x1A,0xC1E7) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+ }
+  else
+  {
+    data = (rxmode) ? 2 : 0;
+    data |= (txmode) ? 1 : 0;
+
+    /* Set the register bit(s).  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,14,2,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+  }
+
+    /* return */
+    return retVal;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPIRL.c
@@ -0,0 +1,1827 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtPIRL.c
+*
+* DESCRIPTION:
+*       API definitions for PIRL Resources
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* STATS operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS pirlOperationPerform
+(
+    IN   GT_QD_DEV            *dev,
+    IN   GT_PIRL_OPERATION    pirlOp,
+    INOUT GT_PIRL_OP_DATA     *opData
+);
+
+static GT_STATUS pirlInitialize
+(
+    IN  GT_QD_DEV              *dev
+);
+
+static GT_STATUS pirlInitIRLUnit
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit
+);
+
+static GT_STATUS pirlDataToResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL_DATA        *pirlData,
+    OUT GT_PIRL_RESOURCE    *res
+);
+
+static GT_STATUS pirlResourceToData
+(
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL_RESOURCE    *res,
+    OUT GT_PIRL_DATA        *pirlData
+);
+
+static GT_STATUS pirlWriteResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    IN  GT_PIRL_RESOURCE    *res
+);
+
+static GT_STATUS pirlReadResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    OUT GT_PIRL_RESOURCE    *res
+);
+
+static GT_STATUS pirlSetPortVec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec
+);
+
+static GT_STATUS pirlGetPortVec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_U32        *portVec
+);
+
+static GT_STATUS pirlSetFcMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_FC_DEASSERT        mode
+);
+
+/*******************************************************************************
+* gpirlActivate
+*
+* DESCRIPTION:
+*       This routine activates Ingress Rate Limiting for the given ports by
+*        initializing a resource bucket, assigning ports, and configuring
+*        Bucket Parameters.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*       portVec  - the list of ports that share the bucket.
+*        pirlData - PIRL resource parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlActivate
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec,
+    IN  GT_PIRL_DATA    *pirlData
+)
+{
+    GT_STATUS           retVal;
+    GT_PORT_STP_STATE    pState[MAX_SWITCH_PORTS];
+    GT_LPORT            port;
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+    GT_PIRL_RESOURCE    pirlRes;
+
+    DBG_INFO(("gpirlActivate Called.\n"));
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    {
+        DBG_INFO(("GT_BAD_PARAM irlUnit\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* check if the given portVec is valid */
+    if ((!portVec) || (portVec >= (GT_U32)(1<<dev->numOfPorts)))
+    {
+        DBG_INFO(("GT_BAD_PARAM portVec\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* set or reset port's ingress resource bit based on the portVec */
+    retVal = pirlSetPortVec(dev, irlUnit, portVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    /* Disable ports that share the bucket */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(!GT_IS_PORT_SET(portVec,port))
+            continue;
+
+        retVal = gstpGetPortState(dev, port, &pState[port]);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+
+        retVal = gstpSetPortState(dev, port, GT_PORT_DISABLE);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+    }
+
+    /* Program Tuning register */
+    op = PIRL_WRITE_RESOURCE;
+    opData.irlUnit = irlUnit;
+    opData.irlReg = 0xF;
+    opData.irlData = 0x7;
+    retVal = pirlOperationPerform(dev,op,&opData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* Program the Ingress Rate Resource Parameters */
+    retVal = pirlDataToResource(dev,pirlData,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirlWriteResource(dev,irlUnit,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Initialize internal counters */
+    retVal = pirlInitIRLUnit(dev,irlUnit);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Program PirlFCMode for each port that shares Bucket */
+    if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
+    {
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if(!GT_IS_PORT_SET(portVec,port))
+                continue;
+
+            retVal = pirlSetFcMode(dev,port,pirlData->fcDeassertMode[port]);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("PIRL FC Mode set failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    /* Set the ports in their original state */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(!GT_IS_PORT_SET(portVec,port))
+            continue;
+
+        retVal = gstpSetPortState(dev, port, pState[port]);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gpirlDeactivate
+*
+* DESCRIPTION:
+*       This routine deactivates Ingress Rate Limiting for the given bucket.
+*        It simply removes every ports from the Ingress Rate Resource.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlDeactivate
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit
+)
+{
+    GT_STATUS           retVal;
+
+    DBG_INFO(("gpirlDectivate Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* reset port's ingress resource bit */
+    retVal = pirlSetPortVec(dev, irlUnit, 0);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gpirlUpdateParam
+*
+* DESCRIPTION:
+*       This routine updates IRL Parameter.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*        pirlData - PIRL resource parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlUpdateParam
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_PIRL_DATA    *pirlData
+)
+{
+    GT_STATUS           retVal;
+    GT_PORT_STP_STATE    pState[MAX_SWITCH_PORTS];
+    GT_LPORT            port;
+    GT_PIRL_RESOURCE    pirlRes;
+    GT_U32                portVec;
+
+    DBG_INFO(("gpirlUpdateParam Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get port list that share ingress resource */
+    retVal = pirlGetPortVec(dev, irlUnit, &portVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    /* check if the given portVec is valid */
+    if (!portVec)
+    {
+        DBG_INFO(("IRL Unit not Activated\n"));
+        return GT_FAIL;
+    }
+
+    /* Disable ports that share the bucket */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(!GT_IS_PORT_SET(portVec,port))
+            continue;
+
+        retVal = gstpGetPortState(dev, port, &pState[port]);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+
+        retVal = gstpSetPortState(dev, port, GT_PORT_DISABLE);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+    }
+
+    /* Program the Ingress Rate Resource Parameters */
+    retVal = pirlDataToResource(dev,pirlData,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirlWriteResource(dev,irlUnit,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Initialize internal counrters for the bucket */
+    retVal = pirlInitIRLUnit(dev,irlUnit);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Program PirlFCMode for each port that shares Bucket */
+    if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
+    {
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if(!GT_IS_PORT_SET(portVec,port))
+                continue;
+
+            retVal = pirlSetFcMode(dev,port,pirlData->fcDeassertMode[port]);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("PIRL FC Mode set failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    /* Set the ports in their original state */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(!GT_IS_PORT_SET(portVec,port))
+            continue;
+
+        retVal = gstpSetPortState(dev, port, pState[port]);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gpirlReadParam
+*
+* DESCRIPTION:
+*       This routine retrieves IRL Parameter.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlReadParam
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_PIRL_DATA    *pirlData
+)
+{
+    GT_STATUS           retVal;
+    GT_LPORT            port;
+    GT_PIRL_RESOURCE    pirlRes;
+    GT_U32                portVec;
+
+    DBG_INFO(("gpirlReadParam Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get port list that share ingress resource */
+    retVal = pirlGetPortVec(dev, irlUnit, &portVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    /* check if the given portVec is valid */
+    if (!portVec)
+    {
+        DBG_INFO(("IRL Unit not Activated\n"));
+        return GT_FAIL;
+    }
+
+    /* Read the Ingress Rate Resource Parameters */
+    retVal = pirlReadResource(dev,irlUnit,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Read Resource failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirlResourceToData(dev,&pirlRes,pirlData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Resource to PIRL Data conversion failed.\n"));
+        return retVal;
+    }
+
+    /* Program PirlFCMode for each port that shares Bucket */
+    if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
+    {
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if(!GT_IS_PORT_SET(portVec,port))
+                continue;
+
+            retVal = grcGetPirlFcMode(dev,port,&pirlData->fcDeassertMode[port]);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("PIRL FC Mode get failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+
+/*******************************************************************************
+* gpirlUpdatePortVec
+*
+* DESCRIPTION:
+*       This routine updates port list that share the bucket.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*       portVec  - the list of ports that share the bucket.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlUpdatePortVec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec
+)
+{
+    GT_STATUS       retVal;
+    GT_U32            tmpVec;
+
+    DBG_INFO(("gpirlActivate Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* check if the given portVec is valid */
+    if ((!portVec) || (portVec > (GT_U32)(1<<dev->numOfPorts)))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get port list that share ingress resource */
+    retVal = pirlGetPortVec(dev, irlUnit, &tmpVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    /* check if the given portVec is valid */
+    if (!tmpVec)
+    {
+        DBG_INFO(("IRL Unit not Activated\n"));
+        return GT_FAIL;
+    }
+
+    /* set or reset port's ingress resource bit based on the portVec */
+    retVal = pirlSetPortVec(dev, irlUnit, portVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gpirlReadPortVec
+*
+* DESCRIPTION:
+*       This routine retrieves port list that share the bucket.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used (0 ~ 11).
+*
+* OUTPUTS:
+*       portVec  - the list of ports that share the bucket.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlReadPortVec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_U32        *portVec
+)
+{
+    GT_STATUS       retVal;
+
+    DBG_INFO(("gpirlReadPortVec Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get port list that share ingress resource */
+    retVal = pirlGetPortVec(dev, irlUnit, portVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    /* check if the given portVec is valid */
+    if (!*portVec)
+    {
+        DBG_INFO(("IRL Unit not Activated\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+
+/*******************************************************************************
+* grcGetPirlFcMode
+*
+* DESCRIPTION:
+*       This routine gets Port Ingress Rate Limit Flow Control mode.
+*        When EBSLimitAction is programmed to generate a flow control message,
+*        the deassertion of flow control is controlled by this mode.
+*            GT_PIRL_FC_DEASSERT_EMPTY:
+*                De-assert when the ingress rate resource has become empty
+*            GT_PIRL_FC_DEASSERT_CBS_LIMIT
+*                De-assert when the ingress rate resource has enough room as
+*                specified by the CBSLimit.
+*        Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
+*        CBSLimit.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        mode - GT_PIRL_FC_DEASSERT enum type
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetPirlFcMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_FC_DEASSERT        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetDaNrlEn Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the PirlFcMode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,12,1,&data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *mode = (GT_PIRL_FC_DEASSERT)data;
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gpirlGetIngressRateResource
+*
+* DESCRIPTION:
+*       This routine gets Ingress Rate Limiting Resources assigned to the port.
+*        This vector is used to attach specific counter resources to the physical
+*        port. And the same counter resource can be attached to more than one port.
+*
+* INPUTS:
+*       port   - logical port number
+*
+* OUTPUTS:
+*        resVec - resource vector (bit 11:0, since there is 12 resources)
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpirlGetIngressRateResource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U32        *resVec
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+    GT_U16            data;
+
+    DBG_INFO(("grcGetIngressRateResource Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the resource vector.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,0,12,&data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *resVec = (GT_U32)data;
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gpirlSetCurTimeUpInt
+*
+* DESCRIPTION:
+*       This function sets the current time update interval.
+*        Please contact FAE for detailed information.
+*
+* INPUTS:
+*       upInt - updata interval (0 ~ 7)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpirlSetCurTimeUpInt
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                upInt
+)
+{
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (upInt > 0x7)
+        return GT_BAD_PARAM;
+
+    op = PIRL_READ_RESOURCE;
+
+    opData.irlUnit = 0xF;
+    opData.irlReg = 1;
+    opData.irlData = 0;
+
+    retVal = pirlOperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
+
+    op = PIRL_WRITE_RESOURCE;
+    opData.irlData = (opData.irlData & 0xFFF8) | (GT_U16)upInt;
+
+    retVal = pirlOperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+}
+
+/****************************************************************************/
+/* Internal functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* gpirlInitialize
+*
+* DESCRIPTION:
+*       This routine initializes PIRL Resources.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirlInitialize
+(
+    IN  GT_QD_DEV              *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_LPORT        port;
+    GT_U8           hwPort;        /* Physical port.               */
+
+    /* reset port's ingress resource bit */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        hwPort = GT_LPORT_2_PORT(port);
+
+        /* Set the resource vector.            */
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,0,12,0);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+    }
+
+    retVal = pirlInitialize(dev);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* statsOperationPerform
+*
+* DESCRIPTION:
+*       This function accesses Ingress Rate Command Register and Data Register.
+*
+* INPUTS:
+*       pirlOp       - The stats operation bits to be written into the stats
+*                     operation register.
+*       port        - port number
+*       counter     - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       pirlData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirlOperationPerform
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_PIRL_OPERATION   pirlOp,
+    INOUT GT_PIRL_OP_DATA     *opData
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+
+    gtSemTake(dev,dev->pirlRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the pirl in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->pirlRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->pirlRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    /* Set the PIRL Operation register */
+    switch (pirlOp)
+    {
+        case PIRL_INIT_ALL_RESOURCE:
+            data = (1 << 15) | (PIRL_INIT_ALL_RESOURCE << 12);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+        case PIRL_INIT_RESOURCE:
+            data = (GT_U16)((1 << 15) | (PIRL_INIT_RESOURCE << 12) |
+                    ((opData->irlUnit&0xF)<< 4));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PIRL_WRITE_RESOURCE:
+            data = (GT_U16)opData->irlData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PIRL_WRITE_RESOURCE << 12) |
+                    ((opData->irlUnit&0xF) << 4) | (opData->irlReg & 0xF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PIRL_READ_RESOURCE:
+            data = (GT_U16)((1 << 15) | (PIRL_READ_RESOURCE << 12) |
+                    ((opData->irlUnit&0xF) << 4) | (opData->irlReg & 0xF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 1;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+              regAccess.rw_reg_list[0].data = 15;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+              }
+            }
+#else
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->pirlRegsSem);
+                    return retVal;
+                }
+            }
+#endif
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,&data);
+            opData->irlData = (GT_U32)data;
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            gtSemGive(dev,dev->pirlRegsSem);
+            return retVal;
+
+        default:
+
+            gtSemGive(dev,dev->pirlRegsSem);
+            return GT_FAIL;
+    }
+
+    /* Wait until the pirl in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->pirlRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->pirlRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    gtSemGive(dev,dev->pirlRegsSem);
+    return retVal;
+}
+
+/*
+ * Initialize all PIRL resources to the inital state.
+*/
+static GT_STATUS pirlInitialize
+(
+    IN  GT_QD_DEV              *dev
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_PIRL_OPERATION    op;
+
+    op = PIRL_INIT_ALL_RESOURCE;
+
+    retVal = pirlOperationPerform(dev, op, NULL);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
+
+    retVal = gpirlSetCurTimeUpInt(dev,7);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+    }
+
+    return retVal;
+}
+
+/*
+ * Initialize the selected PIRL resource to the inital state.
+ * This function initializes only the BSM structure for the IRL Unit.
+*/
+static GT_STATUS pirlInitIRLUnit
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+
+    op = PIRL_INIT_RESOURCE;
+    opData.irlUnit = irlUnit;
+
+    retVal = pirlOperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
+
+    return retVal;
+}
+
+/*
+ * convert PIRL Data structure to PIRL Resource structure.
+ * if PIRL Data is not valid, return GT_BAD_PARARM;
+*/
+static GT_STATUS pirlDataToResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL_DATA        *pirlData,
+    OUT GT_PIRL_RESOURCE    *res
+)
+{
+    GT_U16 typeMask;
+
+    switch(pirlData->accountQConf)
+    {
+        case GT_FALSE:
+        case GT_TRUE:
+            res->accountQConf = pirlData->accountQConf;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->accountFiltered)
+    {
+        case GT_FALSE:
+        case GT_TRUE:
+            res->accountFiltered = pirlData->accountFiltered;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->ebsLimitAction)
+    {
+        case ESB_LIMIT_ACTION_DROP:
+        case ESB_LIMIT_ACTION_FC:
+            res->ebsLimitAction = pirlData->ebsLimitAction;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    if(pirlData->customSetup.isValid == GT_TRUE)
+    {
+        res->ebsLimit = pirlData->customSetup.ebsLimit;
+        res->cbsLimit = pirlData->customSetup.cbsLimit;
+        res->bktIncrement = pirlData->customSetup.bktIncrement;
+        res->bktRateFactor = pirlData->customSetup.bktRateFactor;
+    }
+    else
+    {
+        if(pirlData->ingressRate == 0)
+            return GT_BAD_PARAM;
+
+        if(pirlData->ingressRate < 1000)    /* less than 1Mbps */
+        {
+            /* it should be divided by 64 */
+            if(pirlData->ingressRate % 64)
+                return GT_BAD_PARAM;
+            res->bktRateFactor = pirlData->ingressRate/64;
+        }
+        else if(pirlData->ingressRate <= 100000)    /* less than or equal to 100Mbps */
+        {
+            /* it should be divided by 1000 */
+            if(pirlData->ingressRate % 1000)
+                return GT_BAD_PARAM;
+            res->bktRateFactor = pirlData->ingressRate/64 + ((pirlData->ingressRate % 64)?1:0);
+        }
+        else if(pirlData->ingressRate <= 200000)    /* less than or equal to 200Mbps */
+        {
+            /* it should be divided by 10000 */
+            if(pirlData->ingressRate % 10000)
+                return GT_BAD_PARAM;
+            res->bktRateFactor = pirlData->ingressRate/64 + ((pirlData->ingressRate % 64)?1:0);
+        }
+        else
+            return GT_BAD_PARAM;
+
+        res->ebsLimit = RECOMMENDED_ESB_LIMIT(dev, pirlData->ingressRate);
+        res->cbsLimit = RECOMMENDED_CBS_LIMIT(dev, pirlData->ingressRate);
+        res->bktIncrement = RECOMMENDED_BUCKET_INCREMENT(dev, pirlData->ingressRate);
+    }
+
+    switch(pirlData->bktRateType)
+    {
+        case BUCKET_TYPE_TRAFFIC_BASED:
+            res->bktRateType = pirlData->bktRateType;
+
+            if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL_RESOURCE))
+            {
+                typeMask = 0xF;
+            }
+            else
+            {
+                typeMask = 0x7F;
+            }
+
+            if (pirlData->bktTypeMask > typeMask)
+            {
+                return GT_BAD_PARAM;
+            }
+            else
+            {
+                res->bktTypeMask = pirlData->bktTypeMask;
+            }
+
+            break;
+
+        case BUCKET_TYPE_RATE_BASED:
+            if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL_RESOURCE))
+                return GT_BAD_PARAM;
+            res->bktRateType = pirlData->bktRateType;
+            res->bktTypeMask = 0;
+            break;
+
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->byteTobeCounted)
+    {
+        case GT_PIRL_COUNT_ALL_LAYER1:
+            res->byteTobeCounted = 1;
+            break;
+        case GT_PIRL_COUNT_ALL_LAYER2:
+            res->byteTobeCounted = 2;
+            break;
+        case GT_PIRL_COUNT_ALL_LAYER3:
+            res->byteTobeCounted = 6;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;
+}
+
+/*
+ * convert PIRL Resource structure to PIRL Data structure.
+*/
+static GT_STATUS pirlResourceToData
+(
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL_RESOURCE    *res,
+    OUT GT_PIRL_DATA        *pirlData
+)
+{
+    GT_U32    rate;
+    GT_U32    factor;
+
+    pirlData->accountQConf = res->accountQConf;
+    pirlData->accountFiltered = res->accountFiltered;
+    pirlData->ebsLimitAction = res->ebsLimitAction;
+
+    pirlData->customSetup.isValid = GT_FALSE;
+
+    FACTOR_FROM_BUCKET_INCREMENT(dev,res->bktIncrement,factor);
+
+    rate = res->bktRateFactor * factor;
+    if(rate == 0)
+    {
+        pirlData->ingressRate = 0;
+        pirlData->customSetup.isValid = GT_TRUE;
+        pirlData->customSetup.ebsLimit = res->ebsLimit;
+        pirlData->customSetup.cbsLimit = res->cbsLimit;
+        pirlData->customSetup.bktIncrement = res->bktIncrement;
+        pirlData->customSetup.bktRateFactor = res->bktRateFactor;
+    }
+    else if(rate < 1000)
+    {
+        pirlData->ingressRate = rate;
+    }
+    else if(rate < 100000)
+    {
+        pirlData->ingressRate = rate - (rate % 1000);
+    }
+    else
+    {
+        pirlData->ingressRate = rate - (rate % 10000);
+    }
+
+    pirlData->bktRateType = res->bktRateType;
+    pirlData->bktTypeMask = res->bktTypeMask;
+
+    switch(res->byteTobeCounted)
+    {
+        case 1:
+            pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER1;
+            break;
+        case 2:
+            pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER2;
+            break;
+        case 6:
+            pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER3;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* pirlWriteResource
+*
+* DESCRIPTION:
+*       This function writes IRL Resource to BCM (Bucket Configuration Memory)
+*
+* INPUTS:
+*        irlUnit - resource unit to be accessed
+*       res     - IRL Resource data
+*
+* OUTPUTS:
+*       Nont.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirlWriteResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    IN  GT_PIRL_RESOURCE    *res
+)
+{
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+    int                i;
+
+    op = PIRL_WRITE_RESOURCE;
+
+    /* reg0 data */
+    data[0] = (GT_U16)((res->bktRateType << 15) |    /* Bit[15] : Bucket Rate Type */
+                      (res->bktTypeMask << 4 ) |        /* Bit[14:4] : Traffic Type   */
+                      res->byteTobeCounted );            /* Bit[3:0] : Bytes to be counted */
+
+    /* reg1 data */
+    data[1] = (GT_U16)res->bktIncrement;    /* Bit[11:0] : Bucket Increment */
+
+    /* reg2 data */
+    data[2] = (GT_U16)res->bktRateFactor;    /* Bit[15:0] : Bucket Rate Factor */
+
+    /* reg3 data */
+    data[3] = (GT_U16)(res->cbsLimit & 0xFFF) << 4;    /* Bit[15:4] : CBS Limit[11:0] */
+
+    /* reg4 data */
+    data[4] = (GT_U16)(res->cbsLimit >> 12);        /* Bit[11:0] : CBS Limit[23:12] */
+
+    /* reg5 data */
+    data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);        /* Bit[15:0] : EBS Limit[15:0] */
+
+    /* reg6 data */
+    data[6] = (GT_U16)((res->ebsLimit >> 16)    |    /* Bit[7:0] : EBS Limit[23:16] */
+                    (res->ebsLimitAction << 12)    |    /* Bit[12] : EBS Limit Action */
+                    (res->accountFiltered << 14)|    /* Bit[14] : Account Filtered */
+                    (res->accountQConf << 15));        /* Bit[15] : Account QConf */
+    /* reg7 data */
+    data[7] = 0;    /* Reserved */
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlUnit = irlUnit;
+        opData.irlReg = i;
+        opData.irlData = data[i];
+
+        retVal = pirlOperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* pirlReadResource
+*
+* DESCRIPTION:
+*       This function reads IRL Resource from BCM (Bucket Configuration Memory)
+*
+* INPUTS:
+*        irlUnit - resource unit to be accessed
+*
+* OUTPUTS:
+*       res - IRL Resource data
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirlReadResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    OUT GT_PIRL_RESOURCE    *res
+)
+{
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+    int                i;
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlUnit = irlUnit;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirlOperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+
+
+    /* reg0 data */
+    res->bktRateType = (data[0] >> 15) & 0x1;
+    res->bktTypeMask = (data[0] >> 4) & 0x7F;
+
+    res->byteTobeCounted = data[0] & 0xF;
+
+    /* reg1 data */
+    res->bktIncrement = data[1] & 0xFFF;
+
+    /* reg2 data */
+    res->bktRateFactor = data[2] & 0xFFFF;
+
+    /* reg3,4 data */
+    res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xFFF) << 12);
+
+    /* reg5,6 data */
+    res->ebsLimit = data[5] | ((data[6] & 0xFF) << 16);
+
+    /* reg6 data */
+    res->ebsLimitAction = (data[6] >> 12) & 0x1;
+    res->accountFiltered = (data[6] >> 14) & 0x1;
+    res->accountQConf = (data[6] >> 15) & 0x1;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* pirlSetPortVec
+*
+* DESCRIPTION:
+*       This routine sets port list that share the bucket and resets ports that
+*        do not share the bucket.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used.
+*       portVec  - the list of ports that share the bucket.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirlSetPortVec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_LPORT        port;
+    GT_U8           hwPort;        /* Physical port.               */
+    GT_U16            data;
+
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(GT_IS_PORT_SET(portVec,port))
+            data = 1;
+        else
+            data = 0;
+
+        hwPort = GT_LPORT_2_PORT(port);
+
+        /* Set the resource vector.            */
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,(GT_U8)irlUnit,1,data);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* pirlGetPortVec
+*
+* DESCRIPTION:
+*       This routine gets port list that share the bucket.
+*
+* INPUTS:
+*        irlUnit  - bucket to be used.
+*
+* OUTPUTS:
+*       portVec  - the list of ports that share the bucket.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirlGetPortVec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_U32        *portVec
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_LPORT        port;
+    GT_U8           hwPort;        /* Physical port.               */
+    GT_U16            data;
+
+    *portVec = 0;
+
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        hwPort = GT_LPORT_2_PORT(port);
+
+        /* Set the resource vector.            */
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,(GT_U8)irlUnit,1,&data);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+
+        if(data == 1)
+            *portVec |= (1 << port);
+    }
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* pirlSetFcMode
+*
+* DESCRIPTION:
+*       This routine gets Port Ingress Rate Limit Flow Control mode.
+*        When EBSLimitAction is programmed to generate a flow control message,
+*        the deassertion of flow control is controlled by this mode.
+*            GT_PIRL_FC_DEASSERT_EMPTY:
+*                De-assert when the ingress rate resource has become empty
+*            GT_PIRL_FC_DEASSERT_CBS_LIMIT
+*                De-assert when the ingress rate resource has enough room as
+*                specified by the CBSLimit.
+*        Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
+*        CBSLimit.
+*
+* INPUTS:
+*       port - logical port number
+*        mode - GT_PIRL_FC_DEASSERT enum type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirlSetFcMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_FC_DEASSERT        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("pirlSetFcMode Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    data = (GT_U16) mode;
+
+    /* Set the PirlFcMode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,12,1,data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+#define PIRL_DEBUG
+#ifdef PIRL_DEBUG
+/*******************************************************************************
+* pirlDumpResource
+*
+* DESCRIPTION:
+*       This function dumps IRL Resource register values.
+*
+* INPUTS:
+*        irlUnit  - resource unit to be accessed
+*        dataLen  - data size.
+*
+* OUTPUTS:
+*       data - IRL Resource data
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS pirlDumpResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    IN    GT_U32                dataLen,
+    OUT GT_U16                *data
+)
+{
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+    GT_U32                i;
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<dataLen; i++)
+    {
+        opData.irlUnit = irlUnit;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirlOperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+
+    return GT_OK;
+}
+#endif /* PIRL_DEBUG */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPIRL2.c
@@ -0,0 +1,1739 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtPIRL2.c
+*
+* DESCRIPTION:
+*       API definitions for Port based PIRL Resources
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* PIRL operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS pirl2OperationPerform
+(
+    IN   GT_QD_DEV            *dev,
+    IN   GT_PIRL2_OPERATION    pirlOp,
+    INOUT GT_PIRL2_OP_DATA     *opData
+);
+
+static GT_STATUS pirl2Initialize
+(
+    IN  GT_QD_DEV              *dev
+);
+
+static GT_STATUS pirl2InitIRLResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes
+);
+
+static GT_STATUS pirl2DisableIRLResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes
+);
+
+static GT_STATUS pirl2DataToResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL2_DATA        *pirlData,
+    OUT GT_PIRL2_RESOURCE    *res
+);
+
+static GT_STATUS pirl2ResourceToData
+(
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL2_RESOURCE    *res,
+    OUT GT_PIRL2_DATA        *pirlData
+);
+
+static GT_STATUS pirl2WriteResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN  GT_PIRL2_RESOURCE    *res
+);
+
+static GT_STATUS pirl2ReadResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    OUT GT_PIRL2_RESOURCE    *res
+);
+
+static GT_STATUS pirl2WriteTSMResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN  GT_PIRL2_TSM_RESOURCE    *res
+);
+
+static GT_STATUS pirl2ReadTSMResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    OUT GT_PIRL2_TSM_RESOURCE    *res
+);
+
+/*******************************************************************************
+* gpirl2WriteResource
+*
+* DESCRIPTION:
+*        This routine writes resource bucket parameters to the given resource
+*        of the port.
+*
+* INPUTS:
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*        pirlData - PIRL resource parameters.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gpirl2WriteResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    IN  GT_PIRL2_DATA    *pirlData
+)
+{
+    GT_STATUS           retVal;
+    GT_PIRL2_RESOURCE    pirlRes;
+    GT_U32               irlPort;         /* the physical port number     */
+    GT_U32                maxRes;
+
+    DBG_INFO(("gpirl2WriteResource Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
+    {
+        maxRes = 2;
+    }
+    else
+    {
+        maxRes = 5;
+    }
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Initialize internal counters */
+    retVal = pirl2InitIRLResource(dev,irlPort,irlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Program the Ingress Rate Resource Parameters */
+    retVal = pirl2DataToResource(dev,pirlData,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirl2WriteResource(dev,irlPort,irlRes,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gpirl2ReadResource
+*
+* DESCRIPTION:
+*        This routine retrieves IRL Parameter.
+*
+* INPUTS:
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gpirl2ReadResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    OUT GT_PIRL2_DATA    *pirlData
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                irlPort;
+    GT_PIRL2_RESOURCE    pirlRes;
+    GT_U32                maxRes;
+
+    DBG_INFO(("gpirl2ReadResource Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
+    {
+        maxRes = 2;
+    }
+    else
+    {
+        maxRes = 5;
+    }
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Read the Ingress Rate Resource Parameters */
+    retVal = pirl2ReadResource(dev,irlPort,irlRes,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Read Resource failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirl2ResourceToData(dev,&pirlRes,pirlData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Resource to PIRL Data conversion failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gpirl2DisableResource
+*
+* DESCRIPTION:
+*       This routine disables Ingress Rate Limiting for the given bucket.
+*
+* INPUTS:
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirl2DisableResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                irlPort;
+    GT_U32                maxRes;
+
+    DBG_INFO(("gpirl2Dectivate Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
+    {
+        maxRes = 2;
+    }
+    else
+    {
+        maxRes = 5;
+    }
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* disable irl resource */
+    retVal = pirl2DisableIRLResource(dev, irlPort, irlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gpirl2SetCurTimeUpInt
+*
+* DESCRIPTION:
+*       This function sets the current time update interval.
+*        Please contact FAE for detailed information.
+*
+* INPUTS:
+*       upInt - updata interval (0 ~ 7)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gpirl2SetCurTimeUpInt
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                upInt
+)
+{
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (upInt > 0x7)
+        return GT_BAD_PARAM;
+
+    op = PIRL_READ_RESOURCE;
+
+    opData.irlPort = 0xF;
+    opData.irlRes = 0;
+    opData.irlReg = 1;
+    opData.irlData = 0;
+
+    retVal = pirl2OperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
+
+    op = PIRL_WRITE_RESOURCE;
+    opData.irlData = (opData.irlData & 0xFFF8) | (GT_U16)upInt;
+
+    retVal = pirl2OperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gpirl2WriteTSMResource
+*
+* DESCRIPTION:
+*        This routine writes rate resource bucket parameters in Time Slot Metering
+*        mode to the given resource of the port.
+*
+* INPUTS:
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*        pirlData - PIRL TSM resource parameters.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Only Resource 0 and 1 can be supported for TSM Mode.
+*
+*******************************************************************************/
+GT_STATUS gpirl2WriteTSMResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    IN  GT_PIRL2_TSM_DATA    *pirlData
+)
+{
+    GT_STATUS           retVal;
+    GT_PIRL2_TSM_RESOURCE    pirlRes;
+    GT_U32               irlPort;         /* the physical port number     */
+    GT_U32                maxRes;
+    GT_U32                cbs, cts, i, rate;
+
+    DBG_INFO(("gpirl2WriteTSMResource Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TSM_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    maxRes = 2;
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Initialize internal counters */
+    retVal = pirl2InitIRLResource(dev,irlPort,irlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    if (pirlData->customSetup.isValid == GT_TRUE)
+    {
+        pirlRes.cbsLimit = pirlData->customSetup.cbsLimit;
+        pirlRes.ctsIntv = pirlData->customSetup.ctsIntv;
+        pirlRes.ebsLimit = pirlData->customSetup.ebsLimit;
+        pirlRes.actionMode = pirlData->customSetup.actionMode;
+    }
+    else
+    {
+        /* convert ingressRate to cbsLimit and ctsIntv */
+        cts = 1;
+        cbs = 0;
+        i = 3;
+        rate = pirlData->ingressRate;
+        while(cts < 16)
+        {
+            cbs = TSM_GET_CBS(rate, cts);
+            if ((cbs == 0) || (cbs <= 0xFFFF))
+                break;
+            cts += i;
+            i = cts;
+        }
+
+        if (cts > 16)
+        {
+            return GT_BAD_PARAM;
+        }
+
+        switch (cts)
+        {
+            case 1:
+                pirlRes.ctsIntv = 3;
+                break;
+            case 4:
+                pirlRes.ctsIntv = 2;
+                break;
+            case 8:
+                pirlRes.ctsIntv = 1;
+                break;
+            case 16:
+                pirlRes.ctsIntv = 0;
+                break;
+            default:
+                return GT_FAIL;
+        }
+
+        pirlRes.cbsLimit = cbs;
+        pirlRes.ebsLimit = 0xFFFF;
+        pirlRes.actionMode = 1;
+    }
+
+    pirlRes.mgmtNrlEn = pirlData->mgmtNrlEn;
+    pirlRes.priMask = pirlData->priMask;
+    pirlRes.tsmMode = GT_TRUE;
+
+    if (pirlData->tsmMode == GT_FALSE)
+    {
+        pirlRes.tsmMode = 0;
+        pirlRes.cbsLimit = 0;
+        pirlRes.ctsIntv = 0;
+        pirlRes.ebsLimit = 0;
+        pirlRes.actionMode = 0;
+        pirlRes.mgmtNrlEn = 0;
+        pirlRes.priMask = 0;
+    }
+
+    retVal = pirl2WriteTSMResource(dev,irlPort,irlRes,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gpirl2ReadTSMResource
+*
+* DESCRIPTION:
+*        This routine retrieves IRL Parameter.
+*        Returned ingressRate would be rough number. Instead, customSetup will
+*        have the exact configured value.
+*
+* INPUTS:
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*
+* OUTPUTS:
+*        pirlData - PIRL resource parameters.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Only Resource 0 and 1 can be supported for TSM Mode.
+*
+*******************************************************************************/
+GT_STATUS gpirl2ReadTSMResource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    OUT GT_PIRL2_TSM_DATA    *pirlData
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                irlPort;
+    GT_PIRL2_TSM_RESOURCE    pirlRes;
+    GT_U32                maxRes, cbs, cts;
+
+    DBG_INFO(("gpirl2ReadTSMResource Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TSM_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    maxRes = 2;
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Read the Ingress Rate Resource Parameters */
+    retVal = pirl2ReadTSMResource(dev,irlPort,irlRes,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Read Resource failed.\n"));
+        return retVal;
+    }
+
+    if (pirlRes.tsmMode == 0)
+    {
+        /* TMS Mode is not enabled */
+        pirlData->tsmMode = GT_FALSE;
+        pirlData->ingressRate = 0;
+        pirlData->mgmtNrlEn = 0;
+        pirlData->priMask = 0;
+        pirlData->customSetup.isValid = 0;
+        pirlData->customSetup.cbsLimit = 0;
+        pirlData->customSetup.ctsIntv = 0;
+        pirlData->customSetup.ebsLimit = 0;
+        pirlData->customSetup.actionMode = 0;
+        return GT_OK;
+    }
+
+    cbs = pirlRes.cbsLimit;
+    switch (pirlRes.ctsIntv)
+    {
+        case 0:
+            cts = 16;
+            break;
+        case 1:
+            cts = 8;
+            break;
+        case 2:
+            cts = 4;
+            break;
+        case 3:
+            cts = 1;
+            break;
+        default:
+            return GT_FAIL;
+    }
+
+    pirlData->ingressRate = TSM_GET_RATE(cbs,cts);
+
+    pirlData->mgmtNrlEn = pirlRes.mgmtNrlEn;
+    pirlData->priMask = pirlRes.priMask;
+
+    pirlData->customSetup.isValid = GT_TRUE;
+    pirlData->customSetup.cbsLimit = pirlRes.cbsLimit;
+    pirlData->customSetup.ctsIntv = pirlRes.ctsIntv;
+    pirlData->customSetup.ebsLimit = pirlRes.ebsLimit;
+    pirlData->customSetup.actionMode = pirlRes.actionMode;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+
+/****************************************************************************/
+/* Internal functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* gpirl2Initialize
+*
+* DESCRIPTION:
+*       This routine initializes PIRL Resources.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gpirl2Initialize
+(
+    IN  GT_QD_DEV              *dev
+)
+{
+    GT_STATUS           retVal;
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = pirl2Initialize(dev);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* pirl2OperationPerform
+*
+* DESCRIPTION:
+*       This function accesses Ingress Rate Command Register and Data Register.
+*
+* INPUTS:
+*       pirlOp     - The stats operation bits to be written into the stats
+*                    operation register.
+*
+* OUTPUTS:
+*       pirlData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirl2OperationPerform
+(
+    IN    GT_QD_DEV             *dev,
+    IN    GT_PIRL2_OPERATION    pirlOp,
+    INOUT GT_PIRL2_OP_DATA        *opData
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+
+    gtSemTake(dev,dev->pirlRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the pirl in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->pirlRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->pirlRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    /* Set the PIRL Operation register */
+    switch (pirlOp)
+    {
+        case PIRL_INIT_ALL_RESOURCE:
+            data = (1 << 15) | (PIRL_INIT_ALL_RESOURCE << 12);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+        case PIRL_INIT_RESOURCE:
+            data = (GT_U16)((1 << 15) | (PIRL_INIT_RESOURCE << 12) |
+                    (opData->irlPort << 8) |
+                    (opData->irlRes << 5));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PIRL_WRITE_RESOURCE:
+            data = (GT_U16)opData->irlData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PIRL_WRITE_RESOURCE << 12) |
+                    (opData->irlPort << 8)    |
+                    (opData->irlRes << 5)    |
+                    (opData->irlReg & 0xF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PIRL_READ_RESOURCE:
+            data = (GT_U16)((1 << 15) | (PIRL_READ_RESOURCE << 12) |
+                    (opData->irlPort << 8)    |
+                    (opData->irlRes << 5)    |
+                    (opData->irlReg & 0xF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 1;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+              regAccess.rw_reg_list[0].data = 15;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+              }
+            }
+#else
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->pirlRegsSem);
+                    return retVal;
+                }
+            }
+#endif
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,&data);
+            opData->irlData = (GT_U32)data;
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            gtSemGive(dev,dev->pirlRegsSem);
+            return retVal;
+
+        default:
+
+            gtSemGive(dev,dev->pirlRegsSem);
+            return GT_FAIL;
+    }
+
+    /* Wait until the pirl in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->pirlRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->pirlRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    gtSemGive(dev,dev->pirlRegsSem);
+    return retVal;
+}
+
+/*
+ * Initialize all PIRL resources to the inital state.
+*/
+static GT_STATUS pirl2Initialize
+(
+    IN  GT_QD_DEV              *dev
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+
+    op = PIRL_INIT_ALL_RESOURCE;
+
+
+    retVal = pirl2OperationPerform(dev, op, NULL);
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL OP Failed.\n"));
+        return retVal;
+    }
+
+
+    retVal = gpirl2SetCurTimeUpInt(dev,4);
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL OP Failed.\n"));
+    }
+
+    return retVal;
+}
+
+/*
+ * Initialize the selected PIRL resource to the inital state.
+ * This function initializes only the BSM structure for the IRL Unit.
+*/
+static GT_STATUS pirl2InitIRLResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA     opData;
+
+    op = PIRL_INIT_RESOURCE;
+    opData.irlPort = irlPort;
+    opData.irlRes = irlRes;
+
+    retVal = pirl2OperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL OP Failed.\n"));
+        return retVal;
+    }
+
+    return retVal;
+}
+
+/*
+ * Disable the selected PIRL resource.
+*/
+static GT_STATUS pirl2DisableIRLResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes
+)
+{
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+    int                i;
+
+    op = PIRL_WRITE_RESOURCE;
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+    }
+
+    return GT_OK;
+}
+
+/*
+ * convert PIRL Data structure to PIRL Resource structure.
+ * if PIRL Data is not valid, return GT_BAD_PARARM;
+*/
+static GT_STATUS pirl2DataToResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL2_DATA        *pirlData,
+    OUT GT_PIRL2_RESOURCE    *res
+)
+{
+    GT_U32 typeMask;
+    GT_U32 data;
+
+    gtMemSet((void*)res,0,sizeof(GT_PIRL2_RESOURCE));
+
+    data = (GT_U32)(pirlData->accountQConf|pirlData->accountFiltered|
+                    pirlData->mgmtNrlEn|pirlData->saNrlEn|pirlData->daNrlEn|
+                    pirlData->samplingMode);
+
+    if (data > 1)
+    {
+        DBG_INFO(("GT_BAD_PARAM (Boolean)\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
+    {
+        if (pirlData->samplingMode != GT_FALSE)
+        {
+            DBG_INFO(("GT_BAD_PARAM (sampling mode)\n"));
+            return GT_BAD_PARAM;
+        }
+    }
+
+    res->accountQConf = pirlData->accountQConf;
+    res->accountFiltered = pirlData->accountFiltered;
+    res->mgmtNrlEn = pirlData->mgmtNrlEn;
+    res->saNrlEn = pirlData->saNrlEn;
+    res->daNrlEn = pirlData->daNrlEn;
+    res->samplingMode = pirlData->samplingMode;
+
+    switch(pirlData->actionMode)
+    {
+        case PIRL_ACTION_ACCEPT:
+        case PIRL_ACTION_USE_LIMIT_ACTION:
+            res->actionMode = pirlData->actionMode;
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM actionMode\n"));
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->ebsLimitAction)
+    {
+        case ESB_LIMIT_ACTION_DROP:
+        case ESB_LIMIT_ACTION_FC:
+            res->ebsLimitAction = pirlData->ebsLimitAction;
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM ebsLimitAction\n"));
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->fcDeassertMode)
+    {
+        case GT_PIRL_FC_DEASSERT_EMPTY:
+        case GT_PIRL_FC_DEASSERT_CBS_LIMIT:
+            res->fcDeassertMode = pirlData->fcDeassertMode;
+            break;
+        default:
+            if(res->ebsLimitAction != ESB_LIMIT_ACTION_FC)
+            {
+                res->fcDeassertMode    = GT_PIRL_FC_DEASSERT_EMPTY;
+                break;
+            }
+            DBG_INFO(("GT_BAD_PARAM fcDeassertMode\n"));
+            return GT_BAD_PARAM;
+    }
+
+    if(pirlData->customSetup.isValid == GT_TRUE)
+    {
+        res->ebsLimit = pirlData->customSetup.ebsLimit;
+        res->cbsLimit = pirlData->customSetup.cbsLimit;
+        res->bktIncrement = pirlData->customSetup.bktIncrement;
+        res->bktRateFactor = pirlData->customSetup.bktRateFactor;
+    }
+    else
+    {
+        if(pirlData->ingressRate == 0)
+        {
+            DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+            return GT_BAD_PARAM;
+        }
+
+        if(pirlData->ingressRate < 1000)    /* less than 1Mbps */
+        {
+            /* it should be divided by 64 */
+            if(pirlData->ingressRate % 64)
+            {
+                DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+                return GT_BAD_PARAM;
+            }
+            res->bktRateFactor = pirlData->ingressRate/64;
+        }
+        else if(pirlData->ingressRate < 10000)    /* less than or equal to 10Mbps */
+        {
+            /* it should be divided by 1000 */
+            if(pirlData->ingressRate % 1000)
+            {
+                DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+                return GT_BAD_PARAM;
+            }
+            res->bktRateFactor = pirlData->ingressRate/128 + ((pirlData->ingressRate % 128)?1:0);
+        }
+        else if(pirlData->ingressRate < 100000)    /* less than or equal to 100Mbps */
+        {
+            /* it should be divided by 1000 */
+            if(pirlData->ingressRate % 1000)
+            {
+                DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+                return GT_BAD_PARAM;
+            }
+            res->bktRateFactor = pirlData->ingressRate/1000;
+        }
+        else if(pirlData->ingressRate <= 200000)    /* less than or equal to 200Mbps */
+        {
+            /* it should be divided by 10000 */
+            if(pirlData->ingressRate % 10000)
+            {
+                DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+                return GT_BAD_PARAM;
+            }
+            res->bktRateFactor = pirlData->ingressRate/1000;
+        }
+        else
+        {
+            DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+            return GT_BAD_PARAM;
+        }
+
+        res->ebsLimit = RECOMMENDED_ESB_LIMIT(dev, pirlData->ingressRate);
+        res->cbsLimit = RECOMMENDED_CBS_LIMIT(dev, pirlData->ingressRate);
+        res->bktIncrement = RECOMMENDED_BUCKET_INCREMENT(dev, pirlData->ingressRate);
+    }
+
+    switch(pirlData->bktRateType)
+    {
+        case BUCKET_TYPE_TRAFFIC_BASED:
+            res->bktRateType = pirlData->bktRateType;
+
+            typeMask = 0x7FFF;
+
+            if (pirlData->bktTypeMask > typeMask)
+            {
+                DBG_INFO(("GT_BAD_PARAM bktTypeMask(%#x)\n",pirlData->bktTypeMask));
+                return GT_BAD_PARAM;
+            }
+
+               res->bktTypeMask = pirlData->bktTypeMask;
+
+            if (pirlData->bktTypeMask & BUCKET_TRAFFIC_ARP)
+            {
+                res->bktTypeMask &= ~BUCKET_TRAFFIC_ARP;
+                res->bktTypeMask |= 0x80;
+            }
+
+            if (pirlData->priORpt > 1)
+            {
+                DBG_INFO(("GT_BAD_PARAM rpiORpt\n"));
+                return GT_BAD_PARAM;
+            }
+
+            res->priORpt = pirlData->priORpt;
+
+            if (pirlData->priMask >= (1 << 4))
+            {
+                DBG_INFO(("GT_BAD_PARAM priMask(%#x)\n",pirlData->priMask));
+                return GT_BAD_PARAM;
+            }
+
+            res->priMask = pirlData->priMask;
+
+            break;
+
+        case BUCKET_TYPE_RATE_BASED:
+            res->bktRateType = pirlData->bktRateType;
+               res->bktTypeMask = pirlData->bktTypeMask;
+            res->priORpt = pirlData->priORpt;
+            res->priMask = pirlData->priMask;
+            break;
+
+        default:
+            DBG_INFO(("GT_BAD_PARAM bktRateType(%#x)\n",pirlData->bktRateType));
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->byteTobeCounted)
+    {
+        case GT_PIRL2_COUNT_FRAME:
+        case GT_PIRL2_COUNT_ALL_LAYER1:
+        case GT_PIRL2_COUNT_ALL_LAYER2:
+        case GT_PIRL2_COUNT_ALL_LAYER3:
+            res->byteTobeCounted = pirlData->byteTobeCounted;
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM byteTobeCounted(%#x)\n",pirlData->byteTobeCounted));
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;
+}
+
+/*
+ * convert PIRL Resource structure to PIRL Data structure.
+*/
+static GT_STATUS pirl2ResourceToData
+(
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL2_RESOURCE    *res,
+    OUT GT_PIRL2_DATA        *pirlData
+)
+{
+    GT_U32    rate;
+    GT_U32    factor;
+
+    pirlData->accountQConf = res->accountQConf;
+    pirlData->accountFiltered = res->accountFiltered;
+    pirlData->mgmtNrlEn = res->mgmtNrlEn;
+    pirlData->saNrlEn = res->saNrlEn;
+    pirlData->daNrlEn = res->daNrlEn;
+    pirlData->samplingMode = res->samplingMode;
+    pirlData->ebsLimitAction = res->ebsLimitAction;
+    pirlData->actionMode = res->actionMode;
+    pirlData->fcDeassertMode = res->fcDeassertMode;
+
+    pirlData->customSetup.isValid = GT_FALSE;
+
+    FACTOR_FROM_BUCKET_INCREMENT(dev,res->bktIncrement,factor);
+
+    rate = res->bktRateFactor * factor;
+    if(factor == 128)
+    {
+        pirlData->ingressRate = rate - (rate % 1000);
+    }
+    else if (factor == 0)
+    {
+        pirlData->ingressRate = 0;
+        pirlData->customSetup.isValid = GT_TRUE;
+        pirlData->customSetup.ebsLimit = res->ebsLimit;
+        pirlData->customSetup.cbsLimit = res->cbsLimit;
+        pirlData->customSetup.bktIncrement = res->bktIncrement;
+        pirlData->customSetup.bktRateFactor = res->bktRateFactor;
+    }
+    else
+    {
+        pirlData->ingressRate = rate;
+    }
+
+    pirlData->bktRateType = res->bktRateType;
+    pirlData->bktTypeMask = res->bktTypeMask;
+
+    if (pirlData->bktTypeMask & 0x80)
+    {
+        res->bktTypeMask &= ~0x80;
+        res->bktTypeMask |= BUCKET_TRAFFIC_ARP;
+    }
+
+    pirlData->priORpt = res->priORpt;
+    pirlData->priMask = res->priMask;
+
+    pirlData->byteTobeCounted = res->byteTobeCounted;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* pirl2WriteResource
+*
+* DESCRIPTION:
+*       This function writes IRL Resource to BCM (Bucket Configuration Memory)
+*
+* INPUTS:
+*       irlPort - physical port number.
+*        irlRes  - bucket to be used (0 ~ 4).
+*       res     - IRL Resource data
+*
+* OUTPUTS:
+*       Nont.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirl2WriteResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN  GT_PIRL2_RESOURCE    *res
+)
+{
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA     opData;
+    int                i;
+
+    op = PIRL_WRITE_RESOURCE;
+
+    /* reg0 data */
+    data[0] = (GT_U16)((res->bktRateType << 15) |    /* Bit[15] : Bucket Rate Type */
+                      (res->bktTypeMask << 0 ));         /* Bit[14:0] : Traffic Type   */
+
+    /* reg1 data */
+    data[1] = (GT_U16)res->bktIncrement;    /* Bit[11:0] : Bucket Increment */
+
+    /* reg2 data */
+    data[2] = (GT_U16)res->bktRateFactor;    /* Bit[15:0] : Bucket Rate Factor */
+
+    /* reg3 data */
+    data[3] = (GT_U16)((res->cbsLimit & 0xFFF) << 4)|    /* Bit[15:4] : CBS Limit[11:0] */
+                    (res->byteTobeCounted << 2);        /* Bit[3:0] : Bytes to be counted */
+
+    /* reg4 data */
+    data[4] = (GT_U16)(res->cbsLimit >> 12);        /* Bit[11:0] : CBS Limit[23:12] */
+
+    /* reg5 data */
+    data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);        /* Bit[15:0] : EBS Limit[15:0] */
+
+    /* reg6 data */
+    data[6] = (GT_U16)((res->ebsLimit >> 16)    |    /* Bit[7:0] : EBS Limit[23:16] */
+                    (res->samplingMode << 11)    |    /* Bit[11] : Sampling Mode */
+                    (res->ebsLimitAction << 12)    |    /* Bit[12] : EBS Limit Action */
+                    (res->actionMode << 13)        |    /* Bit[13] : Action Mode */
+                    (res->fcDeassertMode << 14));    /* Bit[14] : Flow control mode */
+
+    /* reg7 data */
+    data[7] = (GT_U16)((res->daNrlEn)            |    /* Bit[0]  : DA Nrl En */
+                    (res->saNrlEn << 1)            |    /* Bit[1]  : SA Nrl En */
+                    (res->mgmtNrlEn << 2)         |    /* Bit[2]  : MGMT Nrl En */
+                    (res->priMask << 8)         |    /* Bit[11:8] : Priority Queue Mask */
+                    (res->priORpt << 12)         |    /* Bit[12] : Priority OR PacketType */
+                    (res->accountFiltered << 14)|    /* Bit[14] : Account Filtered */
+                    (res->accountQConf << 15));        /* Bit[15] : Account QConf */
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = data[i];
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* pirl2ReadResource
+*
+* DESCRIPTION:
+*       This function reads IRL Resource from BCM (Bucket Configuration Memory)
+*
+* INPUTS:
+*       irlPort  - physical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*
+* OUTPUTS:
+*       res - IRL Resource data
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirl2ReadResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    OUT GT_PIRL2_RESOURCE    *res
+)
+{
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+    int                i;
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+
+
+    /* reg0 data */
+    res->bktRateType = (data[0] >> 15) & 0x1;
+    res->bktTypeMask = (data[0] >> 0) & 0x7FFF;
+
+    /* reg1 data */
+    res->bktIncrement = data[1] & 0xFFF;
+
+    /* reg2 data */
+    res->bktRateFactor = data[2] & 0xFFFF;
+
+    /* reg3,4 data */
+    res->byteTobeCounted = (data[3] >> 2) & 0x3;
+    res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xFFF) << 12);
+
+    /* reg5,6 data */
+    res->ebsLimit = data[5] | ((data[6] & 0xFF) << 16);
+
+    /* reg6 data */
+    res->samplingMode = (data[6] >> 11) & 0x1;
+    res->ebsLimitAction = (data[6] >> 12) & 0x1;
+    res->actionMode = (data[6] >> 13) & 0x1;
+    res->fcDeassertMode = (data[6] >> 14) & 0x1;
+
+    /* reg7 data */
+    res->daNrlEn = (data[7] >> 0) & 0x1;
+    res->saNrlEn = (data[7] >> 1) & 0x1;
+    res->mgmtNrlEn = (data[7] >> 2) & 0x1;
+    res->priMask = (data[7] >> 8) & 0xF;
+    res->priORpt = (data[7] >> 12) & 0x1;
+    res->accountFiltered = (data[7] >> 14) & 0x1;
+    res->accountQConf = (data[7] >> 15) & 0x1;
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* pirl2WriteTSMResource
+*
+* DESCRIPTION:
+*         This function writes IRL Resource to BCM (Bucket Configuration Memory)
+*        in Time Slot Metering Mode.
+*
+* INPUTS:
+*        irlPort - physical port number.
+*        irlRes  - bucket to be used (0 ~ 1).
+*        res     - IRL Resource data
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK on success,
+*        GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirl2WriteTSMResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN  GT_PIRL2_TSM_RESOURCE    *res
+)
+{
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA     opData;
+    int                i;
+
+    op = PIRL_WRITE_RESOURCE;
+
+    /* reg0 data */
+    data[0] = 0;
+
+    /* reg1 data */
+    data[1] = 0;
+
+    /* reg2 data */
+    data[2] = 0;
+
+    /* reg3 data */
+    data[3] = (GT_U16)(((res->cbsLimit & 0xFFF) << 4)|    /* Bit[15:4] : CBS Limit[11:0] */
+                    (0x2 << 2));                            /* Bit[3:0] : Bytes to be counted */
+
+    /* reg4 data */
+    data[4] = (GT_U16)(res->cbsLimit >> 12);        /* Bit[11:0] : CBS Limit[23:12] */
+
+    /* reg5 data */
+    data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);        /* Bit[15:0] : EBS Limit[15:0] */
+
+    /* reg6 data */
+    data[6] = (GT_U16)(res->actionMode << 13);        /* Bit[13] : Action Mode */
+
+    /* reg7 data */
+    data[7] = (GT_U16)((res->tsmMode << 7)        |    /* Bit[7]  : TSM Mode */
+                    (res->mgmtNrlEn << 2)         |    /* Bit[2]  : MGMT Nrl En */
+                    (res->priMask << 8)         |    /* Bit[11:8] : Priority Queue Mask */
+                    (res->ctsIntv << 4));            /* Bit[5:4] : Class Timer Slot Interval */
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = data[i];
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* pirl2ReadTSMResource
+*
+* DESCRIPTION:
+*        This function reads IRL Resource from BCM (Bucket Configuration Memory)
+*        in Time Slot Metering Mode.
+*
+* INPUTS:
+*        irlPort  - physical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*
+* OUTPUTS:
+*        res - IRL Resource data
+*
+* RETURNS:
+*         GT_OK on success,
+*         GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS pirl2ReadTSMResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    OUT GT_PIRL2_TSM_RESOURCE    *res
+)
+{
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+    int                i;
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+
+    res->tsmMode = data[7] & (1<<7);
+
+    if(res->tsmMode == GT_FALSE)
+    {
+        /* TMS mode is not set */
+        res->cbsLimit = 0;
+        res->ebsLimit = 0;
+        res->actionMode = 0;
+        res->mgmtNrlEn = 0;
+        res->priMask = 0;
+        res->ctsIntv = 0;
+
+        return GT_OK;
+    }
+
+    /* reg3,4 data */
+    res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xF) << 12);
+
+    /* reg5,6 data */
+    res->ebsLimit = data[5];
+
+    /* reg6 data */
+    res->actionMode = (data[6] >> 13) & 0x1;
+
+    /* reg7 data */
+    res->mgmtNrlEn = (data[7] >> 2) & 0x1;
+    res->priMask = (data[7] >> 8) & 0xF;
+    res->ctsIntv = (data[7] >> 4) & 0x3;
+
+    return GT_OK;
+}
+
+#define PIRL2_DEBUG
+#ifdef PIRL2_DEBUG
+/*******************************************************************************
+* pirl2DumpResource
+*
+* DESCRIPTION:
+*       This function dumps IRL Resource register values.
+*
+* INPUTS:
+*       irlPort  - physical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*        dataLen  - data size.
+*
+* OUTPUTS:
+*       data - IRL Resource data
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS pirl2DumpResource
+(
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN    GT_U32                dataLen,
+    OUT GT_U16                *data
+)
+{
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+    GT_U32                i;
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<dataLen; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+
+    return GT_OK;
+}
+#endif /* PIRL2_DEBUG */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPTP.c
@@ -0,0 +1,5361 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtPTP.c
+*
+* DESCRIPTION:
+*       API definitions for Precise Time Protocol logic
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+#ifdef CONFIG_AVB_FPGA
+
+#undef USE_SINGLE_READ
+
+#define AVB_SMI_ADDR        0xC
+
+#define QD_REG_PTP_INT_OFFSET        0
+#define QD_REG_PTP_INTEN_OFFSET        1
+#define QD_REG_PTP_FREQ_OFFSET        4
+#define QD_REG_PTP_PHASE_OFFSET        6
+#define QD_REG_PTP_CLK_CTRL_OFFSET    4
+#define QD_REG_PTP_CYCLE_INTERVAL_OFFSET        5
+#define QD_REG_PTP_CYCLE_ADJ_OFFSET                6
+#define QD_REG_PTP_PLL_CTRL_OFFSET    7
+#define QD_REG_PTP_CLK_SRC_OFFSET    0x9
+#define QD_REG_PTP_P9_MODE_OFFSET    0xA
+#define QD_REG_PTP_RESET_OFFSET        0xB
+
+#define GT_PTP_MERGE_32BIT(_high16,_low16)    (((_high16)<<16)|(_low16))
+#define GT_PTP_GET_HIGH16(_data)    ((_data) >> 16) & 0xFFFF
+#define GT_PTP_GET_LOW16(_data)        (_data) & 0xFFFF
+
+#if 0
+
+#define AVB_FPGA_READ_REG       gprtGetPhyReg
+#define AVB_FPGA_WRITE_REG      gprtSetPhyReg
+unsigned int (*avbFpgaReadReg)(void* unused, unsigned int port, unsigned int reg, unsigned int* data);
+unsigned int (*avbFpgaWriteReg)(void* unused, unsigned int port, unsigned int reg, unsigned int data);
+#else
+
+/* for RMGMT access  and can be controlled by <sw_apps -rmgmt 0/1> */
+unsigned int (*avbFpgaReadReg)(void* unused, unsigned int port, unsigned int reg, GT_U32* data)=gprtGetPhyReg;
+unsigned int (*avbFpgaWriteReg)(void* unused, unsigned int port, unsigned int reg, GT_U32 data)=gprtSetPhyReg;
+#define AVB_FPGA_READ_REG       avbFpgaReadReg
+#define AVB_FPGA_WRITE_REG      avbFpgaWriteReg
+
+#endif /* 0 */
+
+#endif
+
+#if 0
+#define GT_PTP_BUILD_TIME(_time1, _time2)    (((_time1) << 16) | (_time2))
+#define GT_PTP_L16_TIME(_time1)    ((_time1) & 0xFFFF)
+#define GT_PTP_H16_TIME(_time1)    (((_time1) >> 16) & 0xFFFF)
+#endif
+
+
+/****************************************************************************/
+/* PTP operation function declaration.                                    */
+/****************************************************************************/
+extern GT_STATUS ptpOperationPerform
+(
+    IN   GT_QD_DEV             *dev,
+    IN   GT_PTP_OPERATION    ptpOp,
+    INOUT GT_PTP_OP_DATA     *opData
+);
+
+
+/*******************************************************************************
+* gptpSetConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
+    GT_PTP_PORT_CONFIG    ptpPortData;
+
+    DBG_INFO(("gptpSetConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
+
+    /* setting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    opData.ptpData = ptpData->ptpEType;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = ptpData->msgIdTSEn;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = ptpData->tsArrPtr;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+#endif
+    {
+        ptpPortData.transSpec = ptpData->transSpec;
+        ptpPortData.disTSpec = 1;    /* default value */
+        ptpPortData.disTSOverwrite = ptpData->disTSOverwrite;
+        ptpPortData.ipJump = 2;        /* default value */
+        ptpPortData.etJump = 12;    /* default value */
+
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            ptpPortData.ptpArrIntEn = (ptpData->ptpArrIntEn & (1 << port))? GT_TRUE : GT_FALSE;
+            ptpPortData.ptpDepIntEn = (ptpData->ptpDepIntEn & (1 << port))? GT_TRUE : GT_FALSE;
+          if((retVal = gptpSetPortConfig(dev, port, &ptpPortData)) != GT_OK)
+          {
+                DBG_INFO(("Failed gptpSetPortConfig.\n"));
+                return GT_FAIL;
+          }
+          if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+      {
+            if(!((ptpData->ptpPortConfig[port].arrTSMode==GT_PTP_TS_MODE_IN_REG)||(ptpData->ptpPortConfig[port].arrTSMode==GT_PTP_TS_MODE_IN_RESERVED_2)||(ptpData->ptpPortConfig[port].arrTSMode==GT_PTP_TS_MODE_IN_FRAME_END)))
+              ptpData->ptpPortConfig[port].arrTSMode=GT_PTP_TS_MODE_IN_REG;
+            if((retVal = gptpSetPortTsMode(dev, port, ptpData->ptpPortConfig[port].arrTSMode)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpSetPortConfig.\n"));
+                return GT_FAIL;
+            }
+      }
+        }
+
+        return GT_OK;
+    }
+
+    /* old PTP block */
+    /* setting PTPArrIntEn, offset 3 */
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_LPORTVEC_2_PORTVEC(ptpData->ptpArrIntEn);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPArrIntEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting PTPDepIntEn, offset 4 */
+    opData.ptpAddr = 4;
+    opData.ptpData = GT_LPORTVEC_2_PORTVEC(ptpData->ptpDepIntEn);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPDepIntEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* TransSpec, MsgIDStartBit, DisTSOverwrite bit, offset 5 */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+#ifdef CONFIG_AVB_FPGA
+    opData.ptpData = ((ptpData->transSpec&0xF) << 12) | ((ptpData->msgIdStartBit&0x7) << 9) |
+                    (opData.ptpData & 0x1) | ((ptpData->disTSOverwrite?1:0) << 1);
+#else
+    opData.ptpData = ((ptpData->transSpec&0xF) << 12) | (opData.ptpData & 0x1) | ((ptpData->disTSOverwrite?1:0) << 1);
+#endif
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDStartBit & DisTSOverwrite.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpGetConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
+    GT_PTP_PORT_CONFIG    ptpPortData;
+
+    DBG_INFO(("gptpGetConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->ptpEType = opData.ptpData;
+
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->msgIdTSEn = opData.ptpData;
+
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->tsArrPtr = opData.ptpData;
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+#endif
+    {
+        ptpData->ptpArrIntEn = 0;
+        ptpData->ptpDepIntEn = 0;
+
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if((retVal = gptpGetPortConfig(dev, port, &ptpPortData)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpGetPortConfig.\n"));
+                return GT_FAIL;
+            }
+
+            ptpData->ptpArrIntEn |= (ptpPortData.ptpArrIntEn ? (1 << port) : 0);
+            ptpData->ptpDepIntEn |= (ptpPortData.ptpDepIntEn ? (1 << port) : 0);
+            ptpData->ptpPortConfig[port].ptpArrIntEn = ptpPortData.ptpArrIntEn;
+            ptpData->ptpPortConfig[port].ptpDepIntEn = ptpPortData.ptpDepIntEn;
+
+
+          if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+      {
+            ptpData->ptpPortConfig[port].transSpec = ptpPortData.transSpec;
+        ptpData->ptpPortConfig[port].disTSOverwrite = ptpPortData.disTSOverwrite;
+            if((retVal = gptpGetPortTsMode(dev, port, &ptpData->ptpPortConfig[port].arrTSMode)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpGetPortConfig.\n"));
+                return GT_FAIL;
+            }
+      }
+        }
+
+        ptpData->transSpec = ptpPortData.transSpec;
+        ptpData->disTSOverwrite = ptpPortData.disTSOverwrite;
+
+        ptpData->msgIdStartBit = 4;
+
+        return GT_OK;
+    }
+
+    /* old PTP block */
+    /* getting PTPArrIntEn, offset 3 */
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPArrIntEn.\n"));
+        return GT_FAIL;
+    }
+    opData.ptpData &= dev->validPortVec;
+    ptpData->ptpArrIntEn = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+
+
+    /* getting PTPDepIntEn, offset 4 */
+    opData.ptpAddr = 4;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPDepIntEn.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= dev->validPortVec;
+    ptpData->ptpDepIntEn = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+
+    /* MsgIDStartBit, DisTSOverwrite bit, offset 5 */
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->transSpec = (opData.ptpData >> 12) & 0xF;
+#ifdef CONFIG_AVB_FPGA
+    ptpData->msgIdStartBit = (opData.ptpData >> 9) & 0x7;
+#else
+    ptpData->msgIdStartBit = 0;
+#endif
+    ptpData->disTSOverwrite = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetGlobalConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP global configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP global configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetGlobalConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_GLOBAL_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpSetGlobalConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
+
+    /* setting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    opData.ptpData = ptpData->ptpEType;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = ptpData->msgIdTSEn;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = ptpData->tsArrPtr;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGlobalGetConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP global configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP global configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetGlobalConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_GLOBAL_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetGlobalConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->ptpEType = opData.ptpData;
+
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->msgIdTSEn = opData.ptpData;
+
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->tsArrPtr = opData.ptpData;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetPortConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP port configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP port configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_PORT_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gptpSetPortConfig Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    if (ptpData->transSpec > 0xF)    /* 4 bits */
+        return GT_BAD_PARAM;
+
+    if (ptpData->etJump > 0x1F)    /* 5 bits */
+        return GT_BAD_PARAM;
+
+    if (ptpData->ipJump > 0x3F)    /* 6 bits */
+        return GT_BAD_PARAM;
+
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = hwPort;
+
+    /* TransSpec, DisTSpecCheck, DisTSOverwrite bit, offset 0 */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+    opData.ptpData = (ptpData->transSpec << 12) | (opData.ptpData & 0x1) |
+                    ((ptpData->disTSpec?1:0) << 11) |
+                    ((ptpData->disTSOverwrite?1:0) << 1);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TransSpec,DisTSpecCheck,DisTSOverwrite.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting etJump and ipJump, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = (ptpData->ipJump << 8) | ptpData->etJump;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting Int, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = (ptpData->ptpArrIntEn?1:0) |
+                    ((ptpData->ptpDepIntEn?1:0) << 1);
+    if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+    {
+       opData.ptpData |= ((ptpData->arrTSMode&0xff) << 8);  /* from Agate to set ArrTSMode */
+    }
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetPortConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP configuration parameters for a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP port configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_PORT_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gptpGetPortConfig Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = hwPort;
+    op = PTP_READ_DATA;
+
+    /* TransSpec, DisTSpecCheck, DisTSOverwrite bit, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->transSpec = opData.ptpData >> 12;
+    ptpData->disTSpec = ((opData.ptpData >> 11) & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->disTSOverwrite = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->ipJump = (opData.ptpData >> 8) & 0x3F;
+    ptpData->etJump = opData.ptpData & 0x1F;
+
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->ptpDepIntEn = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->ptpArrIntEn = (opData.ptpData & 0x1) ? GT_TRUE : GT_FALSE;
+    if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+    {
+      ptpData->arrTSMode = (opData.ptpData &0xff00) >> 8;  /* from Agate to get ArrTSMode */
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetPTPEn
+*
+* DESCRIPTION:
+*       This routine enables or disables PTP.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
+
+    DBG_INFO(("gptpSetPTPEn Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+#endif
+    {
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if((retVal = gptpSetPortPTPEn(dev, port, en)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpSetPortPTPEn.\n"));
+                return GT_FAIL;
+            }
+        }
+
+        return GT_OK;
+    }
+
+    /* old PTP block */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+    opData.ptpData &= ~0x1;
+    opData.ptpData |= (en ? 0 : 1);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDStartBit & DisTSOverwrite.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetPTPEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetPTPEn Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+#endif
+    {
+        if((retVal = gptpGetPortPTPEn(dev, 0, en)) != GT_OK)
+        {
+               DBG_INFO(("Failed gptpGetPortPTPEn.\n"));
+            return GT_FAIL;
+        }
+
+        return GT_OK;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *en = (opData.ptpData & 0x1) ? GT_FALSE : GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetPortPTPEn
+*
+* DESCRIPTION:
+*       This routine enables or disables PTP on a port.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gptpSetPortPTPEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpAddr = 0;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    if (en)
+        opData.ptpData &= ~0x1;
+    else
+        opData.ptpData |= 0x1;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TransSpec,DisTSpecCheck,DisTSOverwrite.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpGetPortPTPEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP is enabled on a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gptpGetPortPTPEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpAddr = 0;
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *en = (opData.ptpData & 0x1) ? GT_FALSE : GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetPortTsMode
+*
+* DESCRIPTION:
+*       This routine set PTP arrive 0 TS mode on a port.
+*
+* INPUTS:
+*        tsMod - GT_PTP_TS_MODE_IN_REG
+*                GT_PTP_TS_MODE_IN_RESERVED_2
+*                GT_PTP_TS_MODE_IN_FRAME_END
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortTsMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_TS_MODE  tsMode
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gptpSetPortTsMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    if (!(IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpAddr = 2;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TsMode.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= 0xff;
+    switch (tsMode)
+    {
+      case GT_PTP_TS_MODE_IN_REG:
+        break;
+      case GT_PTP_TS_MODE_IN_RESERVED_2:
+        opData.ptpData |= (PTP_TS_LOC_RESERVED_2<<8); /* set TS in reserved 1 */
+        break;
+      case GT_PTP_TS_MODE_IN_FRAME_END:
+        opData.ptpData |= (PTP_FRAME_SIZE<<8); /* set TS in end of PTP frame */
+        break;
+      default:
+        DBG_INFO(("GT_NOT_SUPPORTED the TS mode\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Ts Mode.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpGetPortTsMode
+*
+* DESCRIPTION:
+*       This routine get PTP arrive 0 TS mode on a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        tsMod - GT_PTP_TS_MODE_IN_REG
+*                GT_PTP_TS_MODE_IN_RESERVED_2
+*                GT_PTP_TS_MODE_IN_FRAME_END
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortTsMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_TS_MODE  *tsMode
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+    GT_U16            tmpData;
+
+    DBG_INFO(("gptpGetPortTsMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    if (!(IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpAddr = 2;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TsMode.\n"));
+        return GT_FAIL;
+    }
+
+    tmpData = qdLong2Short(opData.ptpData >>8);
+    if (tmpData>=PTP_FRAME_SIZE)
+      *tsMode = GT_PTP_TS_MODE_IN_FRAME_END;
+    else if (tmpData == PTP_TS_LOC_RESERVED_2)
+      *tsMode = GT_PTP_TS_MODE_IN_RESERVED_2;
+    else
+      *tsMode = GT_PTP_TS_MODE_IN_REG;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpGetPTPInt
+*
+* DESCRIPTION:
+*       This routine gets PTP interrupt status for each port.
+*        The PTP Interrupt bit gets set for a given port when an incoming PTP
+*        frame is time stamped and PTPArrIntEn for that port is set to 0x1.
+*        Similary PTP Interrupt bit gets set for a given port when an outgoing
+*        PTP frame is time stamped and PTPDepIntEn for that port is set to 0x1.
+*        This bit gets cleared upon software reading and clearing the corresponding
+*        time counter valid bits that are valid for that port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt     - interrupt status for each port (bit 0 for port 0, bit 1 for port 1, etc.)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetPTPInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= (1 << dev->maxPorts) - 1;
+
+    *ptpInt = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetPTPGlobalTime
+*
+* DESCRIPTION:
+*       This routine gets the global timer value that is running off of the free
+*        running switch core clock.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpTime    - PTP global time
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPGlobalTime
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpTime
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetPTPGlobalTime Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+#ifndef USE_SINGLE_READ
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:0xF;    /* Global register */
+    op = PTP_READ_MULTIPLE_DATA;
+    opData.ptpAddr = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:9;
+    opData.nData = 2;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *ptpTime = GT_PTP_BUILD_TIME(opData.ptpMultiData[1],opData.ptpMultiData[0]);
+#else
+    {
+    GT_U32 data[2];
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:9;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    data[0] = opData.ptpData;
+
+    op = PTP_READ_DATA;
+    opData.ptpAddr++;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    data[1] = opData.ptpData;
+
+    *ptpTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+    }
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetTimeStamped
+*
+* DESCRIPTION:
+*        This routine retrieves the PTP port status that includes time stamp value
+*        and sequce Id that are captured by PTP logic for a PTP frame that needs
+*        to be time stamped.
+*
+* INPUTS:
+*       port         - logical port number.
+*       timeToRead    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*
+* OUTPUTS:
+*        ptpStatus    - PTP port status
+*
+* RETURNS:
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetTimeStamped
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToRead,
+    OUT GT_PTP_TS_STATUS    *ptpStatus
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                baseReg;
+
+    DBG_INFO(("gptpGetTimeStamped Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("Invalid port number\n"));
+        return GT_BAD_PARAM;
+    }
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+        baseReg = 8;
+    else
+        baseReg = 0;
+#else
+    baseReg = 8;
+#endif
+
+    switch (timeToRead)
+    {
+        case PTP_ARR0_TIME:
+            opData.ptpAddr = baseReg + 0;
+            break;
+        case PTP_ARR1_TIME:
+            opData.ptpAddr = baseReg + 4;
+            break;
+        case PTP_DEP_TIME:
+            opData.ptpAddr = baseReg + 8;
+            break;
+        default:
+            DBG_INFO(("Invalid time to be read\n"));
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpPort = hwPort;
+    opData.ptpBlock = 0;
+
+#ifndef USE_SINGLE_READ
+    op = PTP_READ_TIMESTAMP_DATA;
+    opData.nData = 4;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    ptpStatus->isValid = (opData.ptpMultiData[0] & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpStatus->status = (GT_PTP_INT_STATUS)((opData.ptpMultiData[0] >> 1) & 0x3);
+    ptpStatus->timeStamped = GT_PTP_BUILD_TIME(opData.ptpMultiData[2],opData.ptpMultiData[1]);
+    ptpStatus->ptpSeqId = opData.ptpMultiData[3];
+#else
+    {
+    GT_U32 data[4], i;
+
+    op = PTP_READ_DATA;
+
+    for (i=0; i<4; i++)
+    {
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed reading DisPTP.\n"));
+            return GT_FAIL;
+        }
+
+        data[i] = opData.ptpData;
+        opData.ptpAddr++;
+    }
+
+    ptpStatus->isValid = (data[0] & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpStatus->status = (GT_PTP_INT_STATUS)((data[0] >> 1) & 0x3);
+    ptpStatus->timeStamped = GT_PTP_BUILD_TIME(data[2],data[1]);
+    ptpStatus->ptpSeqId = data[3];
+
+    }
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpResetTimeStamp
+*
+* DESCRIPTION:
+*        This routine resets PTP Time valid bit so that PTP logic can time stamp
+*        a next PTP frame that needs to be time stamped.
+*
+* INPUTS:
+*       port         - logical port number.
+*       timeToReset    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpResetTimeStamp
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToReset
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                baseReg;
+
+    DBG_INFO(("gptpResetTimeStamp Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("Invalid port number\n"));
+        return GT_BAD_PARAM;
+    }
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+        baseReg = 8;
+    else
+        baseReg = 0;
+#else
+    baseReg = 8;
+#endif
+
+    switch (timeToReset)
+    {
+        case PTP_ARR0_TIME:
+            opData.ptpAddr = baseReg + 0;
+            break;
+        case PTP_ARR1_TIME:
+            opData.ptpAddr = baseReg + 4;
+            break;
+        case PTP_DEP_TIME:
+            opData.ptpAddr = baseReg + 8;
+            break;
+        default:
+            DBG_INFO(("Invalid time to reset\n"));
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpPort = hwPort;
+    opData.ptpData = 0;
+    opData.ptpBlock = 0;
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Port Status.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetReg
+*
+* DESCRIPTION:
+*       This routine reads PTP register.
+*
+* INPUTS:
+*       port         - logical port number.
+*       regOffset    - register to read
+*
+* OUTPUTS:
+*        data        - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    OUT GT_U32        *data
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetReg Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    hwPort = (GT_U32)port;
+
+    if (regOffset > 0x1F)
+    {
+        DBG_INFO(("Invalid reg offset\n"));
+        return GT_BAD_PARAM;
+    }
+
+    op = PTP_READ_DATA;
+    opData.ptpPort = hwPort;
+    opData.ptpAddr = regOffset;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *data = opData.ptpData;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetReg
+*
+* DESCRIPTION:
+*       This routine writes data to PTP register.
+*
+* INPUTS:
+*       port         - logical port number
+*       regOffset    - register to be written
+*        data        - data to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    IN  GT_U32        data
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpSetReg Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    hwPort = (GT_U32)port;
+
+    if ((regOffset > 0x1F) || (data > 0xFFFF))
+    {
+        DBG_INFO(("Invalid reg offset/data\n"));
+        return GT_BAD_PARAM;
+    }
+
+    op = PTP_WRITE_DATA;
+    opData.ptpPort = hwPort;
+    opData.ptpAddr = regOffset;
+    opData.ptpData = data;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/* TAI functions */
+/*******************************************************************************
+* gtaiSetEventConfig
+*
+* DESCRIPTION:
+*       This routine sets TAI Event Capture configuration parameters.
+*
+* INPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetEventConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_EVENT_CONFIG    *eventData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetEventConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~((3<<14)|(1<<8));
+    if (eventData->intEn)
+        opData.ptpData |= (1 << 8);
+    if (eventData->eventOverwrite)
+        opData.ptpData |= (1 << 15);
+    if (eventData->eventCtrStart)
+        opData.ptpData |= (1 << 14);
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      opData.ptpData &= ~(1<<13);
+      if (eventData->eventPhase)
+        opData.ptpData |= (1 << 13);
+    }
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN)) /* after 6320 */
+    {
+	}
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+	if(IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN))
+	{
+     /* getting Capture trigger, offset 9 */
+      op = PTP_READ_DATA;
+      opData.ptpAddr = 9;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      opData.ptpData &= ~(1<<14);
+      opData.ptpData |= (eventData->captTrigEvent==GT_TRUE)?0x4000:0x0;
+
+      op = PTP_WRITE_DATA;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+	  }
+	}
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiGetEventConfig
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_CONFIG    *eventData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetEventConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    eventData->intEn = (opData.ptpData & (1<<8))?GT_TRUE:GT_FALSE;
+    eventData->eventOverwrite = (opData.ptpData & (1<<15))?GT_TRUE:GT_FALSE;
+    eventData->eventCtrStart = (opData.ptpData & (1<<14))?GT_TRUE:GT_FALSE;
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      eventData->eventPhase = (opData.ptpData & (1<<13))?GT_TRUE:GT_FALSE;
+    }
+
+	if(IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN))
+	{
+     /* getting Capture trigger, offset 9 */
+      op = PTP_READ_DATA;
+      opData.ptpAddr = 9;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      eventData->captTrigEvent = (opData.ptpData & (1<<14))?GT_TRUE:GT_FALSE;
+	}
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetEventStatus
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_STATUS    *status
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
+
+    DBG_INFO(("gtaiGetEventStatus Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 9;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    status->isValid = (opData.ptpData & (1<<8))?GT_TRUE:GT_FALSE;
+    status->eventCtr = opData.ptpData & 0xFF;
+    status->eventErr = (opData.ptpData & (1<<9))?GT_TRUE:GT_FALSE;
+
+    if (status->isValid == GT_FALSE)
+    {
+        return GT_OK;
+    }
+
+    opData.ptpAddr = 10;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
+
+    opData.ptpAddr = 11;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
+
+    status->eventTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiGetEventInt
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus     - interrupt status for TAI Event capture
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetEventInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 9;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *intStatus = (opData.ptpData & 0x8000)?GT_TRUE:GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gtaiClearEventInt
+*
+* DESCRIPTION:
+*       This routine clear TAI Event Capture Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiClearEventInt
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiClearEventInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 9;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading eventInt.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= 0x7EFF;
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing eventInt.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gtaiSetClockSelect
+*
+* DESCRIPTION:
+*       This routine sets several clock select in TAI.
+*
+* INPUTS:
+*        clkSelect  - TAI clock select configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_CLOCK_SELECT    *clkSelect
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetClockSelect Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting Tai clock select, offset 8 */
+    opData.ptpAddr = 8;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(0x4077);
+    opData.ptpData |= (((clkSelect->priRecClkSel)&7) << 0);
+    opData.ptpData |= (((clkSelect->syncRecClkSel)&7) << 4);
+    opData.ptpData |= (((clkSelect->ptpExtClk)&1) << 14);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 8;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetClockSelect
+*
+* DESCRIPTION:
+*       This routine gets several clock select in TAI.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       clkSelect  - TAI clock select configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_TAI_CLOCK_SELECT    *clkSelect
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA      opData;
+
+    DBG_INFO(("gtaiGetClockSelect Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting Tai clock select, offset 8 */
+    opData.ptpAddr = 8;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    clkSelect->priRecClkSel = qdLong2Char(opData.ptpData&7);
+    clkSelect->syncRecClkSel = qdLong2Char((opData.ptpData >> 4) & 7);
+    clkSelect->ptpExtClk = (opData.ptpData>> 14) & 1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetTrigInt
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus     - interrupt status for TAI Trigger
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTrigInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *intStatus = (opData.ptpData & 0x8000)?GT_TRUE:GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiClearTrigInt
+*
+* DESCRIPTION:
+*       This routine clear TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiClearTrigInt
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiClearTrigInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= 0x7fff;
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetTrigConfig
+*
+* DESCRIPTION:
+*       This routine sets TAI Trigger configuration parameters.
+*
+* INPUTS:
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTrigConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     trigEn,
+    IN  GT_TAI_TRIGGER_CONFIG    *trigData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTrigConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      if (trigData->trigPhase)
+        opData.ptpData |= (1 << 12);
+    }
+
+    opData.ptpData &= ~(3|(1<<9));
+
+    if (trigEn == GT_FALSE)
+    {
+        op = PTP_WRITE_DATA;
+
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing PTPEType.\n"));
+            return GT_FAIL;
+        }
+
+        return GT_OK;
+    }
+
+    opData.ptpData |= 1;
+
+    if (trigData->intEn)
+        opData.ptpData |= (1 << 9);
+
+    if (trigData->mode == GT_TAI_TRIG_ON_GIVEN_TIME)
+        opData.ptpData |= (1 << 1);
+
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 2;
+    opData.ptpData = GT_PTP_L16_TIME(trigData->trigGenAmt);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_PTP_H16_TIME(trigData->trigGenAmt);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    if (trigData->mode == GT_TAI_TRIG_ON_GIVEN_TIME)
+    {
+        if ((trigData->pulseWidth >= 0) && (trigData->pulseWidth <= 0xF))
+        {
+            op = PTP_READ_DATA;
+            opData.ptpAddr = 5;        /* PulseWidth */
+
+            if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+            {
+                DBG_INFO(("Failed writing PTPEType.\n"));
+                return GT_FAIL;
+            }
+
+            op = PTP_WRITE_DATA;
+            opData.ptpAddr = 5;        /* PulseWidth */
+            opData.ptpData &= (~0xF000);
+            opData.ptpData |= (GT_U16)(trigData->pulseWidth << 12);
+
+            if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+            {
+                DBG_INFO(("Failed writing PTPEType.\n"));
+                return GT_FAIL;
+            }
+        }
+    }
+    else
+    {
+        op = PTP_WRITE_DATA;
+        opData.ptpAddr = 4;        /* TrigClkComp */
+        opData.ptpData = (GT_U16)trigData->trigClkComp;
+
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing PTPEType.\n"));
+            return GT_FAIL;
+        }
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN)) /* after 6320 */
+    {
+      op = PTP_WRITE_DATA;
+      opData.ptpAddr = 0x10;
+      opData.ptpData = GT_PTP_L16_TIME(trigData->trigGenTime);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x11;
+      opData.ptpData = GT_PTP_H16_TIME(trigData->trigGenTime);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x13;
+      opData.ptpData = GT_PTP_L16_TIME(trigData->trigGenDelay);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x12;
+      opData.ptpData = 0xF & GT_PTP_L16_TIME(trigData->lockCorrect);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x14;
+      opData.ptpData = GT_PTP_L16_TIME(trigData->trigGen2Time);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x15;
+      opData.ptpData = GT_PTP_H16_TIME(trigData->trigGen2Time);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x17;
+      opData.ptpData = GT_PTP_L16_TIME(trigData->trigGen2Delay);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x16;
+      opData.ptpData = 0xF & GT_PTP_L16_TIME(trigData->lockCorrect2);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetTrigConfig
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *trigEn,
+    OUT GT_TAI_TRIGGER_CONFIG    *trigData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
+
+    DBG_INFO(("gtaiGetTrigConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    if (!(opData.ptpData & 1))
+    {
+        *trigEn = GT_FALSE;
+        return GT_OK;
+    }
+
+    if (trigData == NULL)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    *trigEn = GT_TRUE;
+    trigData->mode = (opData.ptpData >> 1) & 1;
+    trigData->intEn = (opData.ptpData >> 9) & 1;
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      trigData->trigPhase = (opData.ptpData >>12) & 1;
+    }
+
+
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
+
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
+
+    trigData->trigGenAmt = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+    opData.ptpAddr = 5;        /* PulseWidth */
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    trigData->pulseWidth = (GT_U32)((opData.ptpData >> 12) & 0xF);
+
+    /* getting TrigClkComp, offset 4 */
+    opData.ptpAddr = 4;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    trigData->trigClkComp = (GT_U32)opData.ptpData;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN)) /* after 6320 */
+    {
+      op = PTP_READ_DATA;
+      opData.ptpAddr = 0x10;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      data[0] = opData.ptpData;
+
+      opData.ptpAddr = 0x11;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      data[1] = opData.ptpData;
+      trigData->trigGenTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+
+	  opData.ptpAddr = 0x13;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      trigData->trigGenDelay = opData.ptpData;
+
+      opData.ptpAddr = 0x12;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      trigData->lockCorrect = 0xF & opData.ptpData;
+
+      opData.ptpAddr = 0x14;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      data[0] = opData.ptpData;
+
+      opData.ptpAddr = 0x15;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      data[1] = opData.ptpData;
+      trigData->trigGen2Time = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+
+	  opData.ptpAddr = 0x17;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      trigData->trigGen2Delay = opData.ptpData;
+
+      opData.ptpAddr = 0x16;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      trigData->lockCorrect2 = 0xF & opData.ptpData;
+
+
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiSetTrigLock
+*
+* DESCRIPTION:
+*       This routine sets TAI Trigger lock.
+*
+* INPUTS:
+*        trigLock       - trigger lock set.
+*        trigLockRange  - trigger lock range.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTrigLock
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL    trigLock,
+    IN  GT_U8      trigLockRange
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTrigLock Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = 0xE;    /* TAI register */
+
+    op = PTP_READ_DATA;
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(0xf<<4);
+
+    opData.ptpData |= (trigLock==GT_TRUE) ?0x80:0;
+    opData.ptpData |= ((trigLockRange&0x7)<<4);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetTrigLock
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger lock and trigger lock range.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        trigLock       - trigger lock set.
+*        trigLockRange  - trigger lock range.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigLock
+(
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_BOOL    *trigLock,
+    OUT  GT_U8      *trigLockRange
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTrigLock Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = 0xE;    /* TAI register */
+
+    op = PTP_READ_DATA;
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    trigLock = (opData.ptpData&0x80)?GT_TRUE:GT_FALSE;
+    trigLockRange = (opData.ptpData&0x70)>>4;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiGetTSClkPer
+*
+* DESCRIPTION:
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP
+*        Global Time Counter.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        clk        - time stamping clock period
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTSClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *clk
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTSClkPer Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 1;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *clk = (GT_U32)opData.ptpData;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetTSClkPer
+*
+* DESCRIPTION:
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP
+*        Global Time Counter.
+*
+* INPUTS:
+*        clk        - time stamping clock period
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTSClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        clk
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTSClkPer Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 1;
+
+    opData.ptpData = (GT_U16)clk;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetMultiPTPSync
+*
+* DESCRIPTION:
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
+*
+* INPUTS:
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
+*
+*******************************************************************************/
+GT_STATUS gtaiSetMultiPTPSync
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     multiEn,
+    IN  GT_32        syncTime
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetMultiPTPSync Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_MULTI_PTP_SYNC))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(1 << 2);
+
+    if (multiEn == GT_FALSE)
+    {
+        op = PTP_WRITE_DATA;
+
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing TAI register.\n"));
+            return GT_FAIL;
+        }
+
+        return GT_OK;
+    }
+
+    opData.ptpData |= (1 << 2);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 2;
+    opData.ptpData = GT_PTP_L16_TIME(syncTime);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_PTP_H16_TIME(syncTime);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiGetMultiPTPSync
+*
+* DESCRIPTION:
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
+*
+*******************************************************************************/
+GT_STATUS gtaiGetMultiPTPSync
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *multiEn,
+    OUT GT_32        *syncTime
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
+
+    DBG_INFO(("gtaiGetMultiPTPSync Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_MULTI_PTP_SYNC))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    if(!(opData.ptpData & (1 << 2)))
+    {
+        *multiEn = GT_FALSE;
+        *syncTime = 0;
+        return GT_OK;
+    }
+
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
+
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
+
+    *syncTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiGetTimeIncDec
+*
+* DESCRIPTION:
+*         This routine retrieves Time increment/decrement setup.
+*        This amount specifies the number of units of PTP Global Time that need to be
+*        incremented or decremented. This is used for adjusting the PTP Global Time
+*        counter value by a certain amount.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        expired    - GT_TRUE if inc/dec occurred, GT_FALSE otherwise
+*        inc        - GT_TRUE if increment, GT_FALSE if decrement
+*        amount    - increment/decrement amount
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         Time increment or decrement will be excuted once.
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTimeIncDec
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *expired,
+    OUT GT_BOOL        *inc,
+    OUT GT_U32        *amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTimeIncDec Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *inc = (opData.ptpData & 0x800)?GT_FALSE:GT_TRUE;
+    *amount = (GT_U32)(opData.ptpData & 0x7FF);
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *expired = (opData.ptpData & 0x8)?GT_FALSE:GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetTimeInc
+*
+* DESCRIPTION:
+*         This routine enables time increment by the specifed time increment amount.
+*        The amount specifies the number of units of PTP Global Time that need to be
+*        incremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Increment occurs just once.
+*
+* INPUTS:
+*        amount    - time increment amount (0 ~ 0x7FF)
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTimeInc
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTimeInc Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* set TimeIncAmt */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= 0xF000;
+    opData.ptpData |= amount;
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    /* set TimeIncEn */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData |= 0x8;
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetTimeDec
+*
+* DESCRIPTION:
+*         This routine enables time decrement by the specifed time decrement amount.
+*        The amount specifies the number of units of PTP Global Time that need to be
+*        decremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Decrement occurs just once.
+*
+* INPUTS:
+*        amount    - time decrement amount (0 ~ 0x7FF)
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTimeDec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTimeInc Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* set TimeIncAmt */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= 0xF000;
+    opData.ptpData |= amount;
+    opData.ptpData |= 0x800;    /* decrement */
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    /* set TimeIncEn */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData |= 0x8;
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/****************************************************************************/
+/* Internal functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* ptpOperationPerform
+*
+* DESCRIPTION:
+*       This function accesses PTP Command Register and Data Register.
+*
+* INPUTS:
+*       ptpOp      - The stats operation bits to be written into the stats
+*                    operation register.
+*
+* OUTPUTS:
+*       ptpData    - points to the data storage that the operation requires.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS ptpOperationPerform
+(
+    IN    GT_QD_DEV             *dev,
+    IN    GT_PTP_OPERATION        ptpOp,
+    INOUT GT_PTP_OP_DATA        *opData
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U32             i;
+
+#ifdef CONFIG_AVB_FPGA
+    GT_U32             tmpData;
+#endif
+
+
+    gtSemTake(dev,dev->ptpRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the ptp in ready. */
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    {
+    GT_U16 data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data = 1;
+    while(data == 1)
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+        data = (GT_U16)tmpData;
+        data = (data >> 15) & 0x1;
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif
+
+    /* Set the PTP Operation register */
+    switch (ptpOp)
+    {
+        case PTP_WRITE_DATA:
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 2;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[0].data = (GT_U16)opData->ptpData;
+              regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+            }
+#else
+    {
+    GT_U16 data;
+            data = (GT_U16)opData->ptpData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)opData->ptpData;
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
+#endif
+            break;
+
+        case PTP_READ_DATA:
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 3;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+#ifndef CONFIG_AVB_FPGA
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+#else
+              regAccess.rw_reg_list[0].addr = AVB_SMI_ADDR;
+#endif
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
+#ifndef CONFIG_AVB_FPGA
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+#else
+              regAccess.rw_reg_list[1].addr = AVB_SMI_ADDR;
+#endif
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+#ifndef CONFIG_AVB_FPGA
+              regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+#else
+              regAccess.rw_reg_list[2].addr = AVB_SMI_ADDR;
+#endif
+              regAccess.rw_reg_list[2].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[2].data = 0;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              opData->ptpData = (GT_U32)    regAccess.rw_reg_list[2].data;
+            }
+#else
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+            opData->ptpData = (GT_U32)data;
+    }
+#endif
+#else /*CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+            data = (GT_U32)tmpData;
+            opData->ptpData = (GT_U32)data;
+    }
+#endif
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+
+        case PTP_READ_MULTIPLE_DATA:
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              for(i=0; i<opData->nData; i++)
+              {
+                regAccess.rw_reg_list[2+i].cmd = HW_REG_READ;
+                regAccess.rw_reg_list[2+i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+                regAccess.rw_reg_list[2+i].reg = QD_REG_PTP_DATA;
+                regAccess.rw_reg_list[2+i].data = 0;
+              }
+              regAccess.entries = 2+i;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              for(i=0; i<opData->nData; i++)
+              {
+                opData->ptpMultiData[i] = (GT_U32)    regAccess.rw_reg_list[2+i].data;
+              }
+            }
+#else
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            for(i=0; i<opData->nData; i++)
+            {
+                retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            for(i=0; i<opData->nData; i++)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+                data = (GT_U32)tmpData;
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+    }
+#endif
+
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+
+        case PTP_READ_TIMESTAMP_DATA:
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 3;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+              regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[2].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[2].data = 0;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              opData->ptpMultiData[0] = (GT_U32)    regAccess.rw_reg_list[2].data;
+
+              if (!(opData->ptpMultiData[0] & 0x1))
+              {
+                /* valid bit is not set */
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+              }
+
+              for(i=0; i<(opData->nData-1); i++)
+              {
+                regAccess.rw_reg_list[i].cmd = HW_REG_READ;
+                regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+                regAccess.rw_reg_list[i].reg = QD_REG_PTP_DATA;
+                regAccess.rw_reg_list[i].data = 0;
+              }
+              regAccess.entries = i;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              for(i=0; i<(opData->nData-1); i++)
+              {
+                opData->ptpMultiData[i+1] = (GT_U32)    regAccess.rw_reg_list[i].data;
+              }
+
+
+              regAccess.entries = 2;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[0].data = (GT_U16)0;
+              regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+            }
+#else
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+            opData->ptpMultiData[0] = (GT_U32)data;
+            if(retVal != GT_OK)
+               {
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            if (!(data & 0x1))
+            {
+                /* valid bit is not set */
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            for(i=1; i<opData->nData; i++)
+            {
+                retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_DATA,0);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+            data = (GT_U32)tmpData;
+            opData->ptpMultiData[0] = (GT_U32)data;
+            if(retVal != GT_OK)
+               {
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            if (!(data & 0x1))
+            {
+                /* valid bit is not set */
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            for(i=1; i<opData->nData; i++)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+                data = (GT_U32)tmpData;
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,0);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
+#endif
+            gtSemGive(dev,dev->ptpRegsSem);
+            break;
+
+        default:
+
+            gtSemGive(dev,dev->ptpRegsSem);
+            return GT_FAIL;
+    }
+
+    /* Wait until the ptp is ready. */
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    {
+    GT_U16 data;
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+    data = 1;
+    while(data == 1)
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+        data = (GT_U16)tmpData;
+        data = (data >> 15) & 0x1;
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif
+
+    gtSemGive(dev,dev->ptpRegsSem);
+    return retVal;
+}
+
+
+#ifdef CONFIG_AVB_FPGA
+
+/*******************************************************************************
+* gptpGetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine gets interrupt status of PTP logic.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt    - PTP Int Status
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetPTPIntStatus Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INT_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *ptpInt = (GT_U32)data & 0x1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine sets interrupt status of PTP logic.
+*
+* INPUTS:
+*    ptpInt    - PTP Int Status
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32    ptpInt
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpSetPTPIntStatus Called.\n"));
+
+    data = ptpInt?1:0;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INT_OFFSET,ptpInt);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpSetFPGAIntEn
+*
+* DESCRIPTION:
+*       This routine enables PTP interrupt.
+*
+* INPUTS:
+*        ptpInt    - PTP Int Status (1 to enable, 0 to disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        ptpInt
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetPTPIntEn Called.\n"));
+
+    data = (ptpInt == 0)?0:1;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INTEN_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpGetClockSource
+*
+* DESCRIPTION:
+*       This routine gets PTP Clock source setup.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetClockSource Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_SRC_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *clkSrc = (GT_PTP_CLOCK_SRC)(data & 0x1);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetClockSource
+*
+* DESCRIPTION:
+*       This routine sets PTP Clock source setup.
+*
+* INPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpSetClockSource Called.\n"));
+
+    data = (GT_U32)clkSrc;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_SRC_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpGetP9Mode
+*
+* DESCRIPTION:
+*       This routine gets Port 9 Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetP9Mode Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_P9_MODE_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    if (data & 0x1)
+    {
+        switch (data & 0x6)
+        {
+            case 0:
+                *mode = PTP_P9_MODE_GMII;
+                break;
+            case 2:
+                *mode = PTP_P9_MODE_MII;
+                break;
+            case 4:
+                *mode = PTP_P9_MODE_MII_CONNECTOR;
+                break;
+            default:
+                return GT_BAD_PARAM;
+        }
+    }
+    else
+    {
+        *mode = PTP_P9_MODE_JUMPER;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetP9Mode
+*
+* DESCRIPTION:
+*       This routine sets Port 9 Mode.
+*
+* INPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpSetP9Mode Called.\n"));
+
+    switch (mode)
+    {
+        case PTP_P9_MODE_GMII:
+            data = 1;
+            break;
+        case PTP_P9_MODE_MII:
+            data = 3;
+            break;
+        case PTP_P9_MODE_MII_CONNECTOR:
+            data = 5;
+            break;
+        case PTP_P9_MODE_JUMPER:
+            data = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_P9_MODE_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpReset
+*
+* DESCRIPTION:
+*       This routine performs software reset for PTP logic.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpReset
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpReset Called.\n"));
+
+    data = 1;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_RESET_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetCycleAdjustEn Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *adjEn = (data & 0x2)?GT_TRUE:GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PTP Duty Cycle Adjustment.
+*
+* INPUTS:
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetCycleAdjustEn Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    if (adjEn == GT_FALSE)
+        data &= ~0x3;    /* clear both Enable bit and Valid bit */
+    else
+        data |= 0x2;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine gets clock duty cycle adjustment value.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT    *adj
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetCycleAdjust Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    adj->adjSign = (data & 0x4)?GT_PTP_SIGN_PLUS:GT_PTP_SIGN_NEGATIVE;
+    adj->cycleStep = (data >> 3) & 0x7;
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_INTERVAL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    adj->cycleInterval = data;
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_ADJ_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    adj->cycleAdjust = data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine sets clock duty cycle adjustment value.
+*
+* INPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT    *adj
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+    GT_U32                data1;
+
+    DBG_INFO(("gptpSetCycleAdjust Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    data &= ~0x1;    /* clear Valid bit */
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Setup the Cycle Interval */
+    data1 = adj->cycleInterval & 0xFFFF;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_INTERVAL_OFFSET,data1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Setup the Cycle Adjustment */
+    data1 = adj->cycleAdjust & 0xFFFF;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_ADJ_OFFSET,data1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* clear Sign bit and Cycle Step bits on QD_REG_PTP_CLK_CTRL_OFFSET value */
+    data &= ~0x3C;
+
+    switch (adj->adjSign)
+    {
+        case GT_PTP_SIGN_PLUS:
+            data |= 0x4;
+            break;
+
+        case GT_PTP_SIGN_NEGATIVE:
+            break;
+
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    data |= ((adj->cycleStep & 0x7) << 3);    /* setup Step bits */
+    data |= 0x1;                            /* set Valid bit */
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetPLLEn
+*
+* DESCRIPTION:
+*       This routine checks if PLL is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpGetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetPLLEn Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *en = (data & 0x1)?GT_TRUE:GT_FALSE;
+
+    *freqSel = (data >> 1) & 0x7;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetPLLEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpSetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpSetPPLEn Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    if(en == GT_FALSE)
+    {
+        data |= 0x1;
+    }
+    else
+    {
+        data &= ~0x1;
+        data |= (freqSel & 0x7) << 1;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetDDSReg
+*
+* DESCRIPTION:
+*       This routine gets DDS register data.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*
+* OUTPUTS:
+*    ddsData    - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    OUT GT_U32    *ddsData
+)
+{
+    GT_STATUS           retVal;
+        GT_U32                  data;
+        GT_U32                  timeout = 0x100000;
+
+    DBG_INFO(("gptpGetDDSReg Called.\n"));
+
+    if (ddsReg > 0x3f)
+        return GT_BAD_PARAM;
+    do
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+        if (retVal != GT_OK)
+            return retVal;
+        timeout--;
+        if (timeout == 0)
+            return GT_FAIL;
+    } while (data & 0x8000);
+
+    data = 0x8000 | 0x4000 | (ddsReg << 8);
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+    if (retVal != GT_OK)
+        return retVal;
+
+    *ddsData = data & 0xFF;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpSetDDSReg
+*
+* DESCRIPTION:
+*       This routine sets DDS register data.
+*    DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*    ddsData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    IN  GT_U32    ddsData
+)
+{
+    GT_STATUS           retVal;
+        GT_U32                  data;
+        GT_U32                  timeout = 0x100000;
+
+    DBG_INFO(("gptpSetDDSReg Called.\n"));
+
+    if ((ddsReg > 0x3f) || (ddsData > 0xff))
+        return GT_BAD_PARAM;
+
+    do
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+        if (retVal != GT_OK)
+            return retVal;
+        timeout--;
+        if (timeout == 0)
+            return GT_FAIL;
+    } while (data & 0x8000);
+
+    data = 0x8000 | (ddsReg << 8) | (ddsData);
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpUpdateDDSReg
+*
+* DESCRIPTION:
+*       This routine updates DDS register data.
+*    DDS register data written by gptpSetDDSReg are not affected until this API is called.
+*
+* INPUTS:
+*    none
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpUpdateDDSReg
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+
+    DBG_INFO(("gptpUpdateDDSReg Called.\n"));
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,13,0x0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,13,0x1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpSetADFReg
+*
+* DESCRIPTION:
+*       This routine sets ADF4156 register data.
+*
+* INPUTS:
+*    adfData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetADFReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    adfData
+)
+{
+    GT_STATUS           retVal;
+
+    DBG_INFO(("gptpSetADFReg Called.\n"));
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,14,(adfData & 0xFFFF));
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,15,((adfData>>16) & 0xFFFF));
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+#endif  /*  CONFIG_AVB_FPGA */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPTP.c.orig
@@ -0,0 +1,5296 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtPTP.c
+*
+* DESCRIPTION:
+*       API definitions for Precise Time Protocol logic
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+#ifdef CONFIG_AVB_FPGA
+
+#undef USE_SINGLE_READ
+
+#define AVB_SMI_ADDR        0xC
+
+#define QD_REG_PTP_INT_OFFSET        0
+#define QD_REG_PTP_INTEN_OFFSET        1
+#define QD_REG_PTP_FREQ_OFFSET        4
+#define QD_REG_PTP_PHASE_OFFSET        6
+#define QD_REG_PTP_CLK_CTRL_OFFSET    4
+#define QD_REG_PTP_CYCLE_INTERVAL_OFFSET        5
+#define QD_REG_PTP_CYCLE_ADJ_OFFSET                6
+#define QD_REG_PTP_PLL_CTRL_OFFSET    7
+#define QD_REG_PTP_CLK_SRC_OFFSET    0x9
+#define QD_REG_PTP_P9_MODE_OFFSET    0xA
+#define QD_REG_PTP_RESET_OFFSET        0xB
+
+#define GT_PTP_MERGE_32BIT(_high16,_low16)    (((_high16)<<16)|(_low16))
+#define GT_PTP_GET_HIGH16(_data)    ((_data) >> 16) & 0xFFFF
+#define GT_PTP_GET_LOW16(_data)        (_data) & 0xFFFF
+
+#if 0
+
+#define AVB_FPGA_READ_REG       gprtGetPhyReg
+#define AVB_FPGA_WRITE_REG      gprtSetPhyReg
+unsigned int (*avbFpgaReadReg)(void* unused, unsigned int port, unsigned int reg, unsigned int* data);
+unsigned int (*avbFpgaWriteReg)(void* unused, unsigned int port, unsigned int reg, unsigned int data);
+#else
+
+/* for RMGMT access  and can be controlled by <sw_apps -rmgmt 0/1> */
+unsigned int (*avbFpgaReadReg)(void* unused, unsigned int port, unsigned int reg, GT_U32* data)=gprtGetPhyReg;
+unsigned int (*avbFpgaWriteReg)(void* unused, unsigned int port, unsigned int reg, GT_U32 data)=gprtSetPhyReg;
+#define AVB_FPGA_READ_REG       avbFpgaReadReg
+#define AVB_FPGA_WRITE_REG      avbFpgaWriteReg
+
+#endif /* 0 */
+
+#endif
+
+#if 0
+#define GT_PTP_BUILD_TIME(_time1, _time2)    (((_time1) << 16) | (_time2))
+#define GT_PTP_L16_TIME(_time1)    ((_time1) & 0xFFFF)
+#define GT_PTP_H16_TIME(_time1)    (((_time1) >> 16) & 0xFFFF)
+#endif
+
+
+/****************************************************************************/
+/* PTP operation function declaration.                                    */
+/****************************************************************************/
+extern GT_STATUS ptpOperationPerform
+(
+    IN   GT_QD_DEV             *dev,
+    IN   GT_PTP_OPERATION    ptpOp,
+    INOUT GT_PTP_OP_DATA     *opData
+);
+
+
+/*******************************************************************************
+* gptpSetConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
+    GT_PTP_PORT_CONFIG    ptpPortData;
+
+    DBG_INFO(("gptpSetConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
+
+    /* setting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    opData.ptpData = ptpData->ptpEType;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = ptpData->msgIdTSEn;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = ptpData->tsArrPtr;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+#endif
+    {
+        ptpPortData.transSpec = ptpData->transSpec;
+        ptpPortData.disTSpec = 1;    /* default value */
+        ptpPortData.disTSOverwrite = ptpData->disTSOverwrite;
+        ptpPortData.ipJump = 2;        /* default value */
+        ptpPortData.etJump = 12;    /* default value */
+
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            ptpPortData.ptpArrIntEn = (ptpData->ptpArrIntEn & (1 << port))? GT_TRUE : GT_FALSE;
+            ptpPortData.ptpDepIntEn = (ptpData->ptpDepIntEn & (1 << port))? GT_TRUE : GT_FALSE;
+          if((retVal = gptpSetPortConfig(dev, port, &ptpPortData)) != GT_OK)
+          {
+                DBG_INFO(("Failed gptpSetPortConfig.\n"));
+                return GT_FAIL;
+          }
+          if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+      {
+            if(!((ptpData->ptpPortConfig[port].arrTSMode==GT_PTP_TS_MODE_IN_REG)||(ptpData->ptpPortConfig[port].arrTSMode==GT_PTP_TS_MODE_IN_RESERVED_2)||(ptpData->ptpPortConfig[port].arrTSMode==GT_PTP_TS_MODE_IN_FRAME_END)))
+              ptpData->ptpPortConfig[port].arrTSMode=GT_PTP_TS_MODE_IN_REG;
+            if((retVal = gptpSetPortTsMode(dev, port, ptpData->ptpPortConfig[port].arrTSMode)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpSetPortConfig.\n"));
+                return GT_FAIL;
+            }
+      }
+        }
+
+        return GT_OK;
+    }
+
+    /* old PTP block */
+    /* setting PTPArrIntEn, offset 3 */
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_LPORTVEC_2_PORTVEC(ptpData->ptpArrIntEn);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPArrIntEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting PTPDepIntEn, offset 4 */
+    opData.ptpAddr = 4;
+    opData.ptpData = GT_LPORTVEC_2_PORTVEC(ptpData->ptpDepIntEn);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPDepIntEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* TransSpec, MsgIDStartBit, DisTSOverwrite bit, offset 5 */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+#ifdef CONFIG_AVB_FPGA
+    opData.ptpData = ((ptpData->transSpec&0xF) << 12) | ((ptpData->msgIdStartBit&0x7) << 9) |
+                    (opData.ptpData & 0x1) | ((ptpData->disTSOverwrite?1:0) << 1);
+#else
+    opData.ptpData = ((ptpData->transSpec&0xF) << 12) | (opData.ptpData & 0x1) | ((ptpData->disTSOverwrite?1:0) << 1);
+#endif
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDStartBit & DisTSOverwrite.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpGetConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
+    GT_PTP_PORT_CONFIG    ptpPortData;
+
+    DBG_INFO(("gptpGetConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->ptpEType = opData.ptpData;
+
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->msgIdTSEn = opData.ptpData;
+
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->tsArrPtr = opData.ptpData;
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+#endif
+    {
+        ptpData->ptpArrIntEn = 0;
+        ptpData->ptpDepIntEn = 0;
+
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if((retVal = gptpGetPortConfig(dev, port, &ptpPortData)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpGetPortConfig.\n"));
+                return GT_FAIL;
+            }
+
+            ptpData->ptpArrIntEn |= (ptpPortData.ptpArrIntEn ? (1 << port) : 0);
+            ptpData->ptpDepIntEn |= (ptpPortData.ptpDepIntEn ? (1 << port) : 0);
+            ptpData->ptpPortConfig[port].ptpArrIntEn = ptpPortData.ptpArrIntEn;
+            ptpData->ptpPortConfig[port].ptpDepIntEn = ptpPortData.ptpDepIntEn;
+
+
+          if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+      {
+            ptpData->ptpPortConfig[port].transSpec = ptpPortData.transSpec;
+        ptpData->ptpPortConfig[port].disTSOverwrite = ptpPortData.disTSOverwrite;
+            if((retVal = gptpGetPortTsMode(dev, port, &ptpData->ptpPortConfig[port].arrTSMode)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpGetPortConfig.\n"));
+                return GT_FAIL;
+            }
+      }
+        }
+
+        ptpData->transSpec = ptpPortData.transSpec;
+        ptpData->disTSOverwrite = ptpPortData.disTSOverwrite;
+
+        ptpData->msgIdStartBit = 4;
+
+        return GT_OK;
+    }
+
+    /* old PTP block */
+    /* getting PTPArrIntEn, offset 3 */
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPArrIntEn.\n"));
+        return GT_FAIL;
+    }
+    opData.ptpData &= dev->validPortVec;
+    ptpData->ptpArrIntEn = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+
+
+    /* getting PTPDepIntEn, offset 4 */
+    opData.ptpAddr = 4;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPDepIntEn.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= dev->validPortVec;
+    ptpData->ptpDepIntEn = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+
+    /* MsgIDStartBit, DisTSOverwrite bit, offset 5 */
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->transSpec = (opData.ptpData >> 12) & 0xF;
+#ifdef CONFIG_AVB_FPGA
+    ptpData->msgIdStartBit = (opData.ptpData >> 9) & 0x7;
+#else
+    ptpData->msgIdStartBit = 0;
+#endif
+    ptpData->disTSOverwrite = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetGlobalConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP global configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP global configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetGlobalConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_GLOBAL_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpSetGlobalConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
+
+    /* setting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    opData.ptpData = ptpData->ptpEType;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = ptpData->msgIdTSEn;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = ptpData->tsArrPtr;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGlobalGetConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP global configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP global configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetGlobalConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_GLOBAL_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetGlobalConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->ptpEType = opData.ptpData;
+
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->msgIdTSEn = opData.ptpData;
+
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->tsArrPtr = opData.ptpData;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetPortConfig
+*
+* DESCRIPTION:
+*       This routine writes PTP port configuration parameters.
+*
+* INPUTS:
+*        ptpData  - PTP port configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_PORT_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gptpSetPortConfig Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    if (ptpData->transSpec > 0xF)    /* 4 bits */
+        return GT_BAD_PARAM;
+
+    if (ptpData->etJump > 0x1F)    /* 5 bits */
+        return GT_BAD_PARAM;
+
+    if (ptpData->ipJump > 0x3F)    /* 6 bits */
+        return GT_BAD_PARAM;
+
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = hwPort;
+
+    /* TransSpec, DisTSpecCheck, DisTSOverwrite bit, offset 0 */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+    opData.ptpData = (ptpData->transSpec << 12) | (opData.ptpData & 0x1) |
+                    ((ptpData->disTSpec?1:0) << 11) |
+                    ((ptpData->disTSOverwrite?1:0) << 1);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TransSpec,DisTSpecCheck,DisTSOverwrite.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting etJump and ipJump, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = (ptpData->ipJump << 8) | ptpData->etJump;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    /* setting Int, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = (ptpData->ptpArrIntEn?1:0) |
+                    ((ptpData->ptpDepIntEn?1:0) << 1);
+    if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+    {
+       opData.ptpData |= ((ptpData->arrTSMode&0xff) << 8);  /* from Agate to set ArrTSMode */
+    }
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetPortConfig
+*
+* DESCRIPTION:
+*       This routine reads PTP configuration parameters for a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpData  - PTP port configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_PORT_CONFIG    *ptpData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gptpGetPortConfig Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = hwPort;
+    op = PTP_READ_DATA;
+
+    /* TransSpec, DisTSpecCheck, DisTSOverwrite bit, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->transSpec = opData.ptpData >> 12;
+    ptpData->disTSpec = ((opData.ptpData >> 11) & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->disTSOverwrite = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading MsgIDTSEn.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->ipJump = (opData.ptpData >> 8) & 0x3F;
+    ptpData->etJump = opData.ptpData & 0x1F;
+
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    ptpData->ptpDepIntEn = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->ptpArrIntEn = (opData.ptpData & 0x1) ? GT_TRUE : GT_FALSE;
+    if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+    {
+      ptpData->arrTSMode = (opData.ptpData &0xff00) >> 8;  /* from Agate to get ArrTSMode */
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetPTPEn
+*
+* DESCRIPTION:
+*       This routine enables or disables PTP.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
+
+    DBG_INFO(("gptpSetPTPEn Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+#endif
+    {
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if((retVal = gptpSetPortPTPEn(dev, port, en)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpSetPortPTPEn.\n"));
+                return GT_FAIL;
+            }
+        }
+
+        return GT_OK;
+    }
+
+    /* old PTP block */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+    opData.ptpData &= ~0x1;
+    opData.ptpData |= (en ? 0 : 1);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing MsgIDStartBit & DisTSOverwrite.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetPTPEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetPTPEn Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+#endif
+    {
+        if((retVal = gptpGetPortPTPEn(dev, 0, en)) != GT_OK)
+        {
+               DBG_INFO(("Failed gptpGetPortPTPEn.\n"));
+            return GT_FAIL;
+        }
+
+        return GT_OK;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *en = (opData.ptpData & 0x1) ? GT_FALSE : GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetPortPTPEn
+*
+* DESCRIPTION:
+*       This routine enables or disables PTP on a port.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gptpSetPortPTPEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpAddr = 0;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    if (en)
+        opData.ptpData &= ~0x1;
+    else
+        opData.ptpData |= 0x1;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TransSpec,DisTSpecCheck,DisTSOverwrite.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpGetPortPTPEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP is enabled on a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortPTPEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gptpGetPortPTPEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpAddr = 0;
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *en = (opData.ptpData & 0x1) ? GT_FALSE : GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetPortTsMode
+*
+* DESCRIPTION:
+*       This routine set PTP arrive 0 TS mode on a port.
+*
+* INPUTS:
+*        tsMod - GT_PTP_TS_MODE_IN_REG
+*                GT_PTP_TS_MODE_IN_RESERVED_2
+*                GT_PTP_TS_MODE_IN_FRAME_END
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetPortTsMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_TS_MODE  tsMode
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gptpSetPortTsMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    if (!(IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpAddr = 2;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TsMode.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData &= 0xff;
+    switch (tsMode)
+    {
+      case GT_PTP_TS_MODE_IN_REG:
+        break;
+      case GT_PTP_TS_MODE_IN_RESERVED_2:
+        opData.ptpData |= (PTP_TS_LOC_RESERVED_2<<8); /* set TS in reserved 1 */
+        break;
+      case GT_PTP_TS_MODE_IN_FRAME_END:
+        opData.ptpData |= (PTP_FRAME_SIZE<<8); /* set TS in end of PTP frame */
+        break;
+      default:
+        DBG_INFO(("GT_NOT_SUPPORTED the TS mode\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Ts Mode.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpGetPortTsMode
+*
+* DESCRIPTION:
+*       This routine get PTP arrive 0 TS mode on a port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        tsMod - GT_PTP_TS_MODE_IN_REG
+*                GT_PTP_TS_MODE_IN_RESERVED_2
+*                GT_PTP_TS_MODE_IN_FRAME_END
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPortTsMode
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_TS_MODE  *tsMode
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+    GT_U16            tmpData;
+
+    DBG_INFO(("gptpGetPortTsMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    if (!(IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpAddr = 2;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TsMode.\n"));
+        return GT_FAIL;
+    }
+
+    tmpData = qdLong2Short(opData.ptpData >>8);
+    if (tmpData>=PTP_FRAME_SIZE)
+      *tsMode = GT_PTP_TS_MODE_IN_FRAME_END;
+    else if (tmpData == PTP_TS_LOC_RESERVED_2)
+      *tsMode = GT_PTP_TS_MODE_IN_RESERVED_2;
+    else
+      *tsMode = GT_PTP_TS_MODE_IN_REG;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpGetPTPInt
+*
+* DESCRIPTION:
+*       This routine gets PTP interrupt status for each port.
+*        The PTP Interrupt bit gets set for a given port when an incoming PTP
+*        frame is time stamped and PTPArrIntEn for that port is set to 0x1.
+*        Similary PTP Interrupt bit gets set for a given port when an outgoing
+*        PTP frame is time stamped and PTPDepIntEn for that port is set to 0x1.
+*        This bit gets cleared upon software reading and clearing the corresponding
+*        time counter valid bits that are valid for that port.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt     - interrupt status for each port (bit 0 for port 0, bit 1 for port 1, etc.)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetPTPInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= (1 << dev->maxPorts) - 1;
+
+    *ptpInt = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetPTPGlobalTime
+*
+* DESCRIPTION:
+*       This routine gets the global timer value that is running off of the free
+*        running switch core clock.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpTime    - PTP global time
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetPTPGlobalTime
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpTime
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetPTPGlobalTime Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+#ifndef USE_SINGLE_READ
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:0xF;    /* Global register */
+    op = PTP_READ_MULTIPLE_DATA;
+    opData.ptpAddr = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:9;
+    opData.nData = 2;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *ptpTime = GT_PTP_BUILD_TIME(opData.ptpMultiData[1],opData.ptpMultiData[0]);
+#else
+    {
+    GT_U32 data[2];
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:9;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    data[0] = opData.ptpData;
+
+    op = PTP_READ_DATA;
+    opData.ptpAddr++;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    data[1] = opData.ptpData;
+
+    *ptpTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+    }
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetTimeStamped
+*
+* DESCRIPTION:
+*        This routine retrieves the PTP port status that includes time stamp value
+*        and sequce Id that are captured by PTP logic for a PTP frame that needs
+*        to be time stamped.
+*
+* INPUTS:
+*       port         - logical port number.
+*       timeToRead    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*
+* OUTPUTS:
+*        ptpStatus    - PTP port status
+*
+* RETURNS:
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetTimeStamped
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToRead,
+    OUT GT_PTP_TS_STATUS    *ptpStatus
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                baseReg;
+
+    DBG_INFO(("gptpGetTimeStamped Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("Invalid port number\n"));
+        return GT_BAD_PARAM;
+    }
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+        baseReg = 8;
+    else
+        baseReg = 0;
+#else
+    baseReg = 8;
+#endif
+
+    switch (timeToRead)
+    {
+        case PTP_ARR0_TIME:
+            opData.ptpAddr = baseReg + 0;
+            break;
+        case PTP_ARR1_TIME:
+            opData.ptpAddr = baseReg + 4;
+            break;
+        case PTP_DEP_TIME:
+            opData.ptpAddr = baseReg + 8;
+            break;
+        default:
+            DBG_INFO(("Invalid time to be read\n"));
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpPort = hwPort;
+    opData.ptpBlock = 0;
+
+#ifndef USE_SINGLE_READ
+    op = PTP_READ_TIMESTAMP_DATA;
+    opData.nData = 4;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    ptpStatus->isValid = (opData.ptpMultiData[0] & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpStatus->status = (GT_PTP_INT_STATUS)((opData.ptpMultiData[0] >> 1) & 0x3);
+    ptpStatus->timeStamped = GT_PTP_BUILD_TIME(opData.ptpMultiData[2],opData.ptpMultiData[1]);
+    ptpStatus->ptpSeqId = opData.ptpMultiData[3];
+#else
+    {
+    GT_U32 data[4], i;
+
+    op = PTP_READ_DATA;
+
+    for (i=0; i<4; i++)
+    {
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed reading DisPTP.\n"));
+            return GT_FAIL;
+        }
+
+        data[i] = opData.ptpData;
+        opData.ptpAddr++;
+    }
+
+    ptpStatus->isValid = (data[0] & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpStatus->status = (GT_PTP_INT_STATUS)((data[0] >> 1) & 0x3);
+    ptpStatus->timeStamped = GT_PTP_BUILD_TIME(data[2],data[1]);
+    ptpStatus->ptpSeqId = data[3];
+
+    }
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpResetTimeStamp
+*
+* DESCRIPTION:
+*        This routine resets PTP Time valid bit so that PTP logic can time stamp
+*        a next PTP frame that needs to be time stamped.
+*
+* INPUTS:
+*       port         - logical port number.
+*       timeToReset    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpResetTimeStamp
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToReset
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                baseReg;
+
+    DBG_INFO(("gptpResetTimeStamp Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("Invalid port number\n"));
+        return GT_BAD_PARAM;
+    }
+
+#ifndef CONFIG_AVB_FPGA
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+        baseReg = 8;
+    else
+        baseReg = 0;
+#else
+    baseReg = 8;
+#endif
+
+    switch (timeToReset)
+    {
+        case PTP_ARR0_TIME:
+            opData.ptpAddr = baseReg + 0;
+            break;
+        case PTP_ARR1_TIME:
+            opData.ptpAddr = baseReg + 4;
+            break;
+        case PTP_DEP_TIME:
+            opData.ptpAddr = baseReg + 8;
+            break;
+        default:
+            DBG_INFO(("Invalid time to reset\n"));
+            return GT_BAD_PARAM;
+    }
+
+    opData.ptpPort = hwPort;
+    opData.ptpData = 0;
+    opData.ptpBlock = 0;
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Port Status.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetReg
+*
+* DESCRIPTION:
+*       This routine reads PTP register.
+*
+* INPUTS:
+*       port         - logical port number.
+*       regOffset    - register to read
+*
+* OUTPUTS:
+*        data        - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    OUT GT_U32        *data
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpGetReg Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    hwPort = (GT_U32)port;
+
+    if (regOffset > 0x1F)
+    {
+        DBG_INFO(("Invalid reg offset\n"));
+        return GT_BAD_PARAM;
+    }
+
+    op = PTP_READ_DATA;
+    opData.ptpPort = hwPort;
+    opData.ptpAddr = regOffset;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *data = opData.ptpData;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetReg
+*
+* DESCRIPTION:
+*       This routine writes data to PTP register.
+*
+* INPUTS:
+*       port         - logical port number
+*       regOffset    - register to be written
+*        data        - data to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    IN  GT_U32        data
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gptpSetReg Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    hwPort = (GT_U32)port;
+
+    if ((regOffset > 0x1F) || (data > 0xFFFF))
+    {
+        DBG_INFO(("Invalid reg offset/data\n"));
+        return GT_BAD_PARAM;
+    }
+
+    op = PTP_WRITE_DATA;
+    opData.ptpPort = hwPort;
+    opData.ptpAddr = regOffset;
+    opData.ptpData = data;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/* TAI functions */
+/*******************************************************************************
+* gtaiSetEventConfig
+*
+* DESCRIPTION:
+*       This routine sets TAI Event Capture configuration parameters.
+*
+* INPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetEventConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_EVENT_CONFIG    *eventData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetEventConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~((3<<14)|(1<<8));
+    if (eventData->intEn)
+        opData.ptpData |= (1 << 8);
+    if (eventData->eventOverwrite)
+        opData.ptpData |= (1 << 15);
+    if (eventData->eventCtrStart)
+        opData.ptpData |= (1 << 14);
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      opData.ptpData &= ~(1<<13);
+      if (eventData->eventPhase)
+        opData.ptpData |= (1 << 13);
+    }
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN)) /* after 6320 */
+    {
+	}
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+	if(IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN))
+	{
+     /* getting Capture trigger, offset 9 */
+      op = PTP_READ_DATA;
+      opData.ptpAddr = 9;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      opData.ptpData &= ~(1<<14);
+      opData.ptpData |= (eventData->captTrigEvent==GT_TRUE)?0x4000:0x0;
+
+      op = PTP_WRITE_DATA;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+	  }
+	}
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiGetEventConfig
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_CONFIG    *eventData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetEventConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    eventData->intEn = (opData.ptpData & (1<<8))?GT_TRUE:GT_FALSE;
+    eventData->eventOverwrite = (opData.ptpData & (1<<15))?GT_TRUE:GT_FALSE;
+    eventData->eventCtrStart = (opData.ptpData & (1<<14))?GT_TRUE:GT_FALSE;
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      eventData->eventPhase = (opData.ptpData & (1<<13))?GT_TRUE:GT_FALSE;
+    }
+
+	if(IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN))
+	{
+     /* getting Capture trigger, offset 9 */
+      op = PTP_READ_DATA;
+      opData.ptpAddr = 9;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      eventData->captTrigEvent = (opData.ptpData & (1<<14))?GT_TRUE:GT_FALSE;
+	}
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetEventStatus
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        eventData  - TAI Event Capture configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_STATUS    *status
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
+
+    DBG_INFO(("gtaiGetEventStatus Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 9;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    status->isValid = (opData.ptpData & (1<<8))?GT_TRUE:GT_FALSE;
+    status->eventCtr = opData.ptpData & 0xFF;
+    status->eventErr = (opData.ptpData & (1<<9))?GT_TRUE:GT_FALSE;
+
+    if (status->isValid == GT_FALSE)
+    {
+        return GT_OK;
+    }
+
+    opData.ptpAddr = 10;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
+
+    opData.ptpAddr = 11;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
+
+    status->eventTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiGetEventInt
+*
+* DESCRIPTION:
+*       This routine gets TAI Event Capture Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus     - interrupt status for TAI Event capture
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetEventInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetEventInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 9;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *intStatus = (opData.ptpData & 0x8000)?GT_TRUE:GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gtaiSetClockSelect
+*
+* DESCRIPTION:
+*       This routine sets several clock select in TAI.
+*
+* INPUTS:
+*        clkSelect  - TAI clock select configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_CLOCK_SELECT    *clkSelect
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetClockSelect Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting Tai clock select, offset 8 */
+    opData.ptpAddr = 8;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(0x4077);
+    opData.ptpData |= (((clkSelect->priRecClkSel)&7) << 0);
+    opData.ptpData |= (((clkSelect->syncRecClkSel)&7) << 4);
+    opData.ptpData |= (((clkSelect->ptpExtClk)&1) << 14);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 8;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetClockSelect
+*
+* DESCRIPTION:
+*       This routine gets several clock select in TAI.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       clkSelect  - TAI clock select configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_TAI_CLOCK_SELECT    *clkSelect
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA      opData;
+
+    DBG_INFO(("gtaiGetClockSelect Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting Tai clock select, offset 8 */
+    opData.ptpAddr = 8;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    clkSelect->priRecClkSel = qdLong2Char(opData.ptpData&7);
+    clkSelect->syncRecClkSel = qdLong2Char((opData.ptpData >> 4) & 7);
+    clkSelect->ptpExtClk = (opData.ptpData>> 14) & 1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetTrigInt
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        intStatus     - interrupt status for TAI Trigger
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigInt
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTrigInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *intStatus = (opData.ptpData & 0x8000)?GT_TRUE:GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiClearTrigInt
+*
+* DESCRIPTION:
+*       This routine clear TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiClearTrigInt
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiClearTrigInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= 0x7fff;
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetTrigConfig
+*
+* DESCRIPTION:
+*       This routine sets TAI Trigger configuration parameters.
+*
+* INPUTS:
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTrigConfig
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     trigEn,
+    IN  GT_TAI_TRIGGER_CONFIG    *trigData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTrigConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      if (trigData->trigPhase)
+        opData.ptpData |= (1 << 12);
+    }
+
+    opData.ptpData &= ~(3|(1<<9));
+
+    if (trigEn == GT_FALSE)
+    {
+        op = PTP_WRITE_DATA;
+
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing PTPEType.\n"));
+            return GT_FAIL;
+        }
+
+        return GT_OK;
+    }
+
+    opData.ptpData |= 1;
+
+    if (trigData->intEn)
+        opData.ptpData |= (1 << 9);
+
+    if (trigData->mode == GT_TAI_TRIG_ON_GIVEN_TIME)
+        opData.ptpData |= (1 << 1);
+
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 2;
+    opData.ptpData = GT_PTP_L16_TIME(trigData->trigGenAmt);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_PTP_H16_TIME(trigData->trigGenAmt);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    if (trigData->mode == GT_TAI_TRIG_ON_GIVEN_TIME)
+    {
+        if ((trigData->pulseWidth >= 0) && (trigData->pulseWidth <= 0xF))
+        {
+            op = PTP_READ_DATA;
+            opData.ptpAddr = 5;        /* PulseWidth */
+
+            if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+            {
+                DBG_INFO(("Failed writing PTPEType.\n"));
+                return GT_FAIL;
+            }
+
+            op = PTP_WRITE_DATA;
+            opData.ptpAddr = 5;        /* PulseWidth */
+            opData.ptpData &= (~0xF000);
+            opData.ptpData |= (GT_U16)(trigData->pulseWidth << 12);
+
+            if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+            {
+                DBG_INFO(("Failed writing PTPEType.\n"));
+                return GT_FAIL;
+            }
+        }
+    }
+    else
+    {
+        op = PTP_WRITE_DATA;
+        opData.ptpAddr = 4;        /* TrigClkComp */
+        opData.ptpData = (GT_U16)trigData->trigClkComp;
+
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing PTPEType.\n"));
+            return GT_FAIL;
+        }
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN)) /* after 6320 */
+    {
+      op = PTP_WRITE_DATA;
+      opData.ptpAddr = 0x10;
+      opData.ptpData = GT_PTP_L16_TIME(trigData->trigGenTime);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x11;
+      opData.ptpData = GT_PTP_H16_TIME(trigData->trigGenTime);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x13;
+      opData.ptpData = GT_PTP_L16_TIME(trigData->trigGenDelay);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x12;
+      opData.ptpData = 0xF & GT_PTP_L16_TIME(trigData->lockCorrect);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x14;
+      opData.ptpData = GT_PTP_L16_TIME(trigData->trigGen2Time);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x15;
+      opData.ptpData = GT_PTP_H16_TIME(trigData->trigGen2Time);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x17;
+      opData.ptpData = GT_PTP_L16_TIME(trigData->trigGen2Delay);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+      opData.ptpAddr = 0x16;
+      opData.ptpData = 0xF & GT_PTP_L16_TIME(trigData->lockCorrect2);
+
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetTrigConfig
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger configuration parameters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigConfig
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *trigEn,
+    OUT GT_TAI_TRIGGER_CONFIG    *trigData
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
+
+    DBG_INFO(("gtaiGetTrigConfig Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    if (!(opData.ptpData & 1))
+    {
+        *trigEn = GT_FALSE;
+        return GT_OK;
+    }
+
+    if (trigData == NULL)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    *trigEn = GT_TRUE;
+    trigData->mode = (opData.ptpData >> 1) & 1;
+    trigData->intEn = (opData.ptpData >> 9) & 1;
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      trigData->trigPhase = (opData.ptpData >>12) & 1;
+    }
+
+
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
+
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
+
+    trigData->trigGenAmt = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+    opData.ptpAddr = 5;        /* PulseWidth */
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    trigData->pulseWidth = (GT_U32)((opData.ptpData >> 12) & 0xF);
+
+    /* getting TrigClkComp, offset 4 */
+    opData.ptpAddr = 4;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    trigData->trigClkComp = (GT_U32)opData.ptpData;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN)) /* after 6320 */
+    {
+      op = PTP_READ_DATA;
+      opData.ptpAddr = 0x10;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      data[0] = opData.ptpData;
+
+      opData.ptpAddr = 0x11;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      data[1] = opData.ptpData;
+      trigData->trigGenTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+
+	  opData.ptpAddr = 0x13;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      trigData->trigGenDelay = opData.ptpData;
+
+      opData.ptpAddr = 0x12;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      trigData->lockCorrect = 0xF & opData.ptpData;
+
+      opData.ptpAddr = 0x14;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      data[0] = opData.ptpData;
+
+      opData.ptpAddr = 0x15;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      data[1] = opData.ptpData;
+      trigData->trigGen2Time = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+
+	  opData.ptpAddr = 0x17;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      trigData->trigGen2Delay = opData.ptpData;
+
+      opData.ptpAddr = 0x16;
+      if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+	  {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+	  }
+      trigData->lockCorrect2 = 0xF & opData.ptpData;
+
+
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiSetTrigLock
+*
+* DESCRIPTION:
+*       This routine sets TAI Trigger lock.
+*
+* INPUTS:
+*        trigLock       - trigger lock set.
+*        trigLockRange  - trigger lock range.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTrigLock
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL    trigLock,
+    IN  GT_U8      trigLockRange
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTrigLock Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = 0xE;    /* TAI register */
+
+    op = PTP_READ_DATA;
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(0xf<<4);
+
+    opData.ptpData |= (trigLock==GT_TRUE) ?0x80:0;
+    opData.ptpData |= ((trigLockRange&0x7)<<4);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtaiGetTrigLock
+*
+* DESCRIPTION:
+*       This routine gets TAI Trigger lock and trigger lock range.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        trigLock       - trigger lock set.
+*        trigLockRange  - trigger lock range.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTrigLock
+(
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_BOOL    *trigLock,
+    OUT  GT_U8      *trigLockRange
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTrigLock Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_TRIG_GEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = 0xE;    /* TAI register */
+
+    op = PTP_READ_DATA;
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    trigLock = (opData.ptpData&0x80)?GT_TRUE:GT_FALSE;
+    trigLockRange = (opData.ptpData&0x70)>>4;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiGetTSClkPer
+*
+* DESCRIPTION:
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP
+*        Global Time Counter.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        clk        - time stamping clock period
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTSClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *clk
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTSClkPer Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 1;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *clk = (GT_U32)opData.ptpData;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetTSClkPer
+*
+* DESCRIPTION:
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP
+*        Global Time Counter.
+*
+* INPUTS:
+*        clk        - time stamping clock period
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTSClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        clk
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTSClkPer Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 1;
+
+    opData.ptpData = (GT_U16)clk;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetMultiPTPSync
+*
+* DESCRIPTION:
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
+*
+* INPUTS:
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
+*
+*******************************************************************************/
+GT_STATUS gtaiSetMultiPTPSync
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     multiEn,
+    IN  GT_32        syncTime
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetMultiPTPSync Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_MULTI_PTP_SYNC))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= ~(1 << 2);
+
+    if (multiEn == GT_FALSE)
+    {
+        op = PTP_WRITE_DATA;
+
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing TAI register.\n"));
+            return GT_FAIL;
+        }
+
+        return GT_OK;
+    }
+
+    opData.ptpData |= (1 << 2);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 2;
+    opData.ptpData = GT_PTP_L16_TIME(syncTime);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_PTP_H16_TIME(syncTime);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiGetMultiPTPSync
+*
+* DESCRIPTION:
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
+*
+*******************************************************************************/
+GT_STATUS gtaiGetMultiPTPSync
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *multiEn,
+    OUT GT_32        *syncTime
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
+
+    DBG_INFO(("gtaiGetMultiPTPSync Called.\n"));
+
+    /* check if device supports this feature */
+#ifndef CONFIG_AVB_FPGA
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_MULTI_PTP_SYNC))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    if(!(opData.ptpData & (1 << 2)))
+    {
+        *multiEn = GT_FALSE;
+        *syncTime = 0;
+        return GT_OK;
+    }
+
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
+
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
+
+    *syncTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtaiGetTimeIncDec
+*
+* DESCRIPTION:
+*         This routine retrieves Time increment/decrement setup.
+*        This amount specifies the number of units of PTP Global Time that need to be
+*        incremented or decremented. This is used for adjusting the PTP Global Time
+*        counter value by a certain amount.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        expired    - GT_TRUE if inc/dec occurred, GT_FALSE otherwise
+*        inc        - GT_TRUE if increment, GT_FALSE if decrement
+*        amount    - increment/decrement amount
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         Time increment or decrement will be excuted once.
+*
+*******************************************************************************/
+GT_STATUS gtaiGetTimeIncDec
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *expired,
+    OUT GT_BOOL        *inc,
+    OUT GT_U32        *amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTimeIncDec Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *inc = (opData.ptpData & 0x800)?GT_FALSE:GT_TRUE;
+    *amount = (GT_U32)(opData.ptpData & 0x7FF);
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    *expired = (opData.ptpData & 0x8)?GT_FALSE:GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetTimeInc
+*
+* DESCRIPTION:
+*         This routine enables time increment by the specifed time increment amount.
+*        The amount specifies the number of units of PTP Global Time that need to be
+*        incremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Increment occurs just once.
+*
+* INPUTS:
+*        amount    - time increment amount (0 ~ 0x7FF)
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTimeInc
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTimeInc Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* set TimeIncAmt */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= 0xF000;
+    opData.ptpData |= amount;
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    /* set TimeIncEn */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData |= 0x8;
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetTimeDec
+*
+* DESCRIPTION:
+*         This routine enables time decrement by the specifed time decrement amount.
+*        The amount specifies the number of units of PTP Global Time that need to be
+*        decremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Decrement occurs just once.
+*
+* INPUTS:
+*        amount    - time decrement amount (0 ~ 0x7FF)
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetTimeDec
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetTimeInc Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    /* set TimeIncAmt */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 5;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData &= 0xF000;
+    opData.ptpData |= amount;
+    opData.ptpData |= 0x800;    /* decrement */
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    /* set TimeIncEn */
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    opData.ptpData |= 0x8;
+
+    op = PTP_WRITE_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/****************************************************************************/
+/* Internal functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* ptpOperationPerform
+*
+* DESCRIPTION:
+*       This function accesses PTP Command Register and Data Register.
+*
+* INPUTS:
+*       ptpOp      - The stats operation bits to be written into the stats
+*                    operation register.
+*
+* OUTPUTS:
+*       ptpData    - points to the data storage that the operation requires.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS ptpOperationPerform
+(
+    IN    GT_QD_DEV             *dev,
+    IN    GT_PTP_OPERATION        ptpOp,
+    INOUT GT_PTP_OP_DATA        *opData
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U32             i;
+
+#ifdef CONFIG_AVB_FPGA
+    GT_U32             tmpData;
+#endif
+
+
+    gtSemTake(dev,dev->ptpRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the ptp in ready. */
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    {
+    GT_U16 data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data = 1;
+    while(data == 1)
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+        data = (GT_U16)tmpData;
+        data = (data >> 15) & 0x1;
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif
+
+    /* Set the PTP Operation register */
+    switch (ptpOp)
+    {
+        case PTP_WRITE_DATA:
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 2;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[0].data = (GT_U16)opData->ptpData;
+              regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+            }
+#else
+    {
+    GT_U16 data;
+            data = (GT_U16)opData->ptpData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)opData->ptpData;
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
+#endif
+            break;
+
+        case PTP_READ_DATA:
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 3;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+#ifndef CONFIG_AVB_FPGA
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+#else
+              regAccess.rw_reg_list[0].addr = AVB_SMI_ADDR;
+#endif
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
+#ifndef CONFIG_AVB_FPGA
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+#else
+              regAccess.rw_reg_list[1].addr = AVB_SMI_ADDR;
+#endif
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+#ifndef CONFIG_AVB_FPGA
+              regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+#else
+              regAccess.rw_reg_list[2].addr = AVB_SMI_ADDR;
+#endif
+              regAccess.rw_reg_list[2].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[2].data = 0;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              opData->ptpData = (GT_U32)    regAccess.rw_reg_list[2].data;
+            }
+#else
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+            opData->ptpData = (GT_U32)data;
+    }
+#endif
+#else /*CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+            data = (GT_U32)tmpData;
+            opData->ptpData = (GT_U32)data;
+    }
+#endif
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+
+        case PTP_READ_MULTIPLE_DATA:
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              for(i=0; i<opData->nData; i++)
+              {
+                regAccess.rw_reg_list[2+i].cmd = HW_REG_READ;
+                regAccess.rw_reg_list[2+i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+                regAccess.rw_reg_list[2+i].reg = QD_REG_PTP_DATA;
+                regAccess.rw_reg_list[2+i].data = 0;
+              }
+              regAccess.entries = 2+i;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              for(i=0; i<opData->nData; i++)
+              {
+                opData->ptpMultiData[i] = (GT_U32)    regAccess.rw_reg_list[2+i].data;
+              }
+            }
+#else
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            for(i=0; i<opData->nData; i++)
+            {
+                retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            for(i=0; i<opData->nData; i++)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+                data = (GT_U32)tmpData;
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+    }
+#endif
+
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+
+        case PTP_READ_TIMESTAMP_DATA:
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 3;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+              regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[2].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[2].data = 0;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              opData->ptpMultiData[0] = (GT_U32)    regAccess.rw_reg_list[2].data;
+
+              if (!(opData->ptpMultiData[0] & 0x1))
+              {
+                /* valid bit is not set */
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+              }
+
+              for(i=0; i<(opData->nData-1); i++)
+              {
+                regAccess.rw_reg_list[i].cmd = HW_REG_READ;
+                regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+                regAccess.rw_reg_list[i].reg = QD_REG_PTP_DATA;
+                regAccess.rw_reg_list[i].data = 0;
+              }
+              regAccess.entries = i;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              for(i=0; i<(opData->nData-1); i++)
+              {
+                opData->ptpMultiData[i+1] = (GT_U32)    regAccess.rw_reg_list[i].data;
+              }
+
+
+              regAccess.entries = 2;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[0].data = (GT_U16)0;
+              regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+            }
+#else
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+            opData->ptpMultiData[0] = (GT_U32)data;
+            if(retVal != GT_OK)
+               {
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            if (!(data & 0x1))
+            {
+                /* valid bit is not set */
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            for(i=1; i<opData->nData; i++)
+            {
+                retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_DATA,0);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+            data = (GT_U32)tmpData;
+            opData->ptpMultiData[0] = (GT_U32)data;
+            if(retVal != GT_OK)
+               {
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            if (!(data & 0x1))
+            {
+                /* valid bit is not set */
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            for(i=1; i<opData->nData; i++)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+                data = (GT_U32)tmpData;
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,0);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
+#endif
+            gtSemGive(dev,dev->ptpRegsSem);
+            break;
+
+        default:
+
+            gtSemGive(dev,dev->ptpRegsSem);
+            return GT_FAIL;
+    }
+
+    /* Wait until the ptp is ready. */
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    {
+    GT_U16 data;
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+    data = 1;
+    while(data == 1)
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+        data = (GT_U16)tmpData;
+        data = (data >> 15) & 0x1;
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif
+
+    gtSemGive(dev,dev->ptpRegsSem);
+    return retVal;
+}
+
+
+#ifdef CONFIG_AVB_FPGA
+
+/*******************************************************************************
+* gptpGetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine gets interrupt status of PTP logic.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt    - PTP Int Status
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetPTPIntStatus Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INT_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *ptpInt = (GT_U32)data & 0x1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine sets interrupt status of PTP logic.
+*
+* INPUTS:
+*    ptpInt    - PTP Int Status
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32    ptpInt
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpSetPTPIntStatus Called.\n"));
+
+    data = ptpInt?1:0;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INT_OFFSET,ptpInt);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpSetFPGAIntEn
+*
+* DESCRIPTION:
+*       This routine enables PTP interrupt.
+*
+* INPUTS:
+*        ptpInt    - PTP Int Status (1 to enable, 0 to disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        ptpInt
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetPTPIntEn Called.\n"));
+
+    data = (ptpInt == 0)?0:1;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INTEN_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpGetClockSource
+*
+* DESCRIPTION:
+*       This routine gets PTP Clock source setup.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetClockSource Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_SRC_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *clkSrc = (GT_PTP_CLOCK_SRC)(data & 0x1);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetClockSource
+*
+* DESCRIPTION:
+*       This routine sets PTP Clock source setup.
+*
+* INPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpSetClockSource Called.\n"));
+
+    data = (GT_U32)clkSrc;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_SRC_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpGetP9Mode
+*
+* DESCRIPTION:
+*       This routine gets Port 9 Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetP9Mode Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_P9_MODE_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    if (data & 0x1)
+    {
+        switch (data & 0x6)
+        {
+            case 0:
+                *mode = PTP_P9_MODE_GMII;
+                break;
+            case 2:
+                *mode = PTP_P9_MODE_MII;
+                break;
+            case 4:
+                *mode = PTP_P9_MODE_MII_CONNECTOR;
+                break;
+            default:
+                return GT_BAD_PARAM;
+        }
+    }
+    else
+    {
+        *mode = PTP_P9_MODE_JUMPER;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetP9Mode
+*
+* DESCRIPTION:
+*       This routine sets Port 9 Mode.
+*
+* INPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpSetP9Mode Called.\n"));
+
+    switch (mode)
+    {
+        case PTP_P9_MODE_GMII:
+            data = 1;
+            break;
+        case PTP_P9_MODE_MII:
+            data = 3;
+            break;
+        case PTP_P9_MODE_MII_CONNECTOR:
+            data = 5;
+            break;
+        case PTP_P9_MODE_JUMPER:
+            data = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_P9_MODE_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpReset
+*
+* DESCRIPTION:
+*       This routine performs software reset for PTP logic.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpReset
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpReset Called.\n"));
+
+    data = 1;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_RESET_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetCycleAdjustEn Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *adjEn = (data & 0x2)?GT_TRUE:GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PTP Duty Cycle Adjustment.
+*
+* INPUTS:
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetCycleAdjustEn Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    if (adjEn == GT_FALSE)
+        data &= ~0x3;    /* clear both Enable bit and Valid bit */
+    else
+        data |= 0x2;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine gets clock duty cycle adjustment value.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT    *adj
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetCycleAdjust Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    adj->adjSign = (data & 0x4)?GT_PTP_SIGN_PLUS:GT_PTP_SIGN_NEGATIVE;
+    adj->cycleStep = (data >> 3) & 0x7;
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_INTERVAL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    adj->cycleInterval = data;
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_ADJ_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    adj->cycleAdjust = data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gptpSetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine sets clock duty cycle adjustment value.
+*
+* INPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT    *adj
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+    GT_U32                data1;
+
+    DBG_INFO(("gptpSetCycleAdjust Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    data &= ~0x1;    /* clear Valid bit */
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Setup the Cycle Interval */
+    data1 = adj->cycleInterval & 0xFFFF;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_INTERVAL_OFFSET,data1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Setup the Cycle Adjustment */
+    data1 = adj->cycleAdjust & 0xFFFF;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_ADJ_OFFSET,data1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* clear Sign bit and Cycle Step bits on QD_REG_PTP_CLK_CTRL_OFFSET value */
+    data &= ~0x3C;
+
+    switch (adj->adjSign)
+    {
+        case GT_PTP_SIGN_PLUS:
+            data |= 0x4;
+            break;
+
+        case GT_PTP_SIGN_NEGATIVE:
+            break;
+
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    data |= ((adj->cycleStep & 0x7) << 3);    /* setup Step bits */
+    data |= 0x1;                            /* set Valid bit */
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetPLLEn
+*
+* DESCRIPTION:
+*       This routine checks if PLL is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpGetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpGetPLLEn Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *en = (data & 0x1)?GT_TRUE:GT_FALSE;
+
+    *freqSel = (data >> 1) & 0x7;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpSetPLLEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpSetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
+)
+{
+    GT_STATUS           retVal;
+    GT_U32                data;
+
+    DBG_INFO(("gptpSetPPLEn Called.\n"));
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    if(en == GT_FALSE)
+    {
+        data |= 0x1;
+    }
+    else
+    {
+        data &= ~0x1;
+        data |= (freqSel & 0x7) << 1;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gptpGetDDSReg
+*
+* DESCRIPTION:
+*       This routine gets DDS register data.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*
+* OUTPUTS:
+*    ddsData    - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    OUT GT_U32    *ddsData
+)
+{
+    GT_STATUS           retVal;
+        GT_U32                  data;
+        GT_U32                  timeout = 0x100000;
+
+    DBG_INFO(("gptpGetDDSReg Called.\n"));
+
+    if (ddsReg > 0x3f)
+        return GT_BAD_PARAM;
+    do
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+        if (retVal != GT_OK)
+            return retVal;
+        timeout--;
+        if (timeout == 0)
+            return GT_FAIL;
+    } while (data & 0x8000);
+
+    data = 0x8000 | 0x4000 | (ddsReg << 8);
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+    if (retVal != GT_OK)
+        return retVal;
+
+    *ddsData = data & 0xFF;
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpSetDDSReg
+*
+* DESCRIPTION:
+*       This routine sets DDS register data.
+*    DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*    ddsData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    IN  GT_U32    ddsData
+)
+{
+    GT_STATUS           retVal;
+        GT_U32                  data;
+        GT_U32                  timeout = 0x100000;
+
+    DBG_INFO(("gptpSetDDSReg Called.\n"));
+
+    if ((ddsReg > 0x3f) || (ddsData > 0xff))
+        return GT_BAD_PARAM;
+
+    do
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+        if (retVal != GT_OK)
+            return retVal;
+        timeout--;
+        if (timeout == 0)
+            return GT_FAIL;
+    } while (data & 0x8000);
+
+    data = 0x8000 | (ddsReg << 8) | (ddsData);
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpUpdateDDSReg
+*
+* DESCRIPTION:
+*       This routine updates DDS register data.
+*    DDS register data written by gptpSetDDSReg are not affected until this API is called.
+*
+* INPUTS:
+*    none
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpUpdateDDSReg
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+
+    DBG_INFO(("gptpUpdateDDSReg Called.\n"));
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,13,0x0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,13,0x1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gptpSetADFReg
+*
+* DESCRIPTION:
+*       This routine sets ADF4156 register data.
+*
+* INPUTS:
+*    adfData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetADFReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    adfData
+)
+{
+    GT_STATUS           retVal;
+
+    DBG_INFO(("gptpSetADFReg Called.\n"));
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,14,(adfData & 0xFFFF));
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,15,((adfData>>16) & 0xFFFF));
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+#endif  /*  CONFIG_AVB_FPGA */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPTPHidden.c
@@ -0,0 +1,269 @@
+/* Hidden APIs */
+
+
+/*******************************************************************************
+* gtaiGetSocClkPer
+*
+* DESCRIPTION:
+*         SoC clock period
+*        This specifies clock period for the clock that gets generated from the
+*        PTP block to the reset of the SoC. The period is specified in TSClkPer
+*        increments
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        clkPer    - clock period
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetSocClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *clkPer
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTimeIncAmt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 6;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    *clkPer = (GT_U32)(opData.ptpData & 0x1FF);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetSocClkPer
+*
+* DESCRIPTION:
+*         SoC clock period
+*        This specifies clock period for the clock that gets generated from the
+*        PTP block to the reset of the SoC. The period is specified in TSClkPer
+*        increments
+*
+* INPUTS:
+*        clkPer    - clock period
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetSocClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        clkPer
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetSocClkPer Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 6;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+    opData.ptpData &= ~0x1FF;
+    opData.ptpData |= (clkPer & 0x1FF);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiGetSocClkComp
+*
+* DESCRIPTION:
+*        Soc clock compensation amount in pico seconds.
+*        This field specifies the remainder amount for when the clock is being
+*        generated with a period specifed by the clkPer. The hardware logic keeps
+*        track of the remainder for every clock tick generation and compensates for it.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        amount    - clock compensation amount in pico seconds
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetSocClkComp
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetSocClkComp Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 7;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    *amount = (GT_U32)opData.ptpData;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetSocClkComp
+*
+* DESCRIPTION:
+*        Soc clock compensation amount in pico seconds.
+*        This field specifies the remainder amount for when the clock is being
+*        generated with a period specifed by the clkPer. The hardware logic keeps
+*        track of the remainder for every clock tick generation and compensates for it.
+*
+* INPUTS:
+*        amount    - clock compensation amount in pico seconds
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetSocClkComp
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetSocClkComp Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 7;
+
+    opData.ptpData = (GT_U16)amount;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPage2Access.c
@@ -0,0 +1,1175 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtPage2Access.c
+*
+* DESCRIPTION:
+*       API definitions for Page 2 access
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/* Set to enable/disable Page 2 rester list */
+/*******************************************************************************
+* gtP2SetAccessRMUPage2
+*
+* DESCRIPTION:
+*        This routine sets to access registers of page 2(RMU).
+*
+* INPUTS:
+*        access  - TRUE or FALSE
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gtP2SetAccessRMUPage2
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL      access
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gtP2SetAccessRMUPage2 Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMU_PAGE2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    data = (access==GT_TRUE) ? 1 : 0; /* bit location? */
+
+    /* Set Page 2 access.            */
+    retVal = hwWritePortReg(dev,0x17, 0x1a,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gtP2GetAccessRMUPage2
+*
+* DESCRIPTION:
+*        This routine gets to access registers of page 2(RMU).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        access  - TRUE or FALSE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gtP2GetAccessRMUPage2
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_BOOL     *access
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gtP2GetAccessRMUPage2 Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMU_PAGE2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+
+    /* Get Page 2 access state.            */
+    retVal = hwReadPortReg(dev,0x17, 0x1a,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    *access = (data==1) ? GT_TRUE : GT_FALSE; /* bit location? */
+    return retVal;
+}
+
+/* Page 2 stats APIs */
+
+/****************************************************************************/
+/* STATS operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS statsOperationPerform
+(
+    IN   GT_QD_DEV            *dev,
+    IN   GT_STATS_OPERATION   statsOp,
+    IN   GT_U8                port,
+    IN   GT_STATS_COUNTERS_PAGE2    counter,
+    OUT  GT_VOID              *statsData
+);
+
+static GT_STATUS statsCapture
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_U8             bank,
+    IN GT_U8      port
+);
+
+static GT_STATUS statsCaptureClear
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_U8             bank,
+    IN GT_U8      port
+);
+
+static GT_STATUS statsReadCounter
+(
+    IN   GT_QD_DEV        *dev,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
+);
+
+static GT_STATUS statsReadRealtimeCounter
+(
+    IN   GT_QD_DEV      *dev,
+    IN   GT_U8             port,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
+);
+
+
+
+/*******************************************************************************
+* gstatsPg2GetPortCounter
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsPg2GetPortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS_PAGE2    counter,
+    OUT GT_U32            *statsData
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsPg2GetPortCounter Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Gigabit Switch does not support this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+	/* Enter Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_TRUE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	/* Exit Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_FALSE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsPg2GetPortCounterClear
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port and clear.
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsPg2GetPortCounterClear
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS_PAGE2    counter,
+    OUT GT_U32            *statsData
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsPg2GetPortCounterClear Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Gigabit Switch does not support this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+	/* Enter Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_TRUE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_COUNTER_CLEAR,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	/* Exit Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_FALSE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsPg2GetPortAllCounters
+*
+* DESCRIPTION:
+*       This routine gets all counters of the given port
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       statsCounterSet - points to GT_STATS_COUNTER_SET_PAGE2 for the MIB counters
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsPg2GetPortAllCounters
+(
+    IN  GT_QD_DEV               *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET_PAGE2    *statsCounterSet
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsPg2GetPortAllCounters Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Gigabit Switch does not support this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+	/* Enter Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_TRUE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	/* Exit Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_FALSE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsPg2GetPortAllCountersClear
+*
+* DESCRIPTION:
+*       This routine gets all counters of the given port and clear
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       statsCounterSet - points to GT_STATS_COUNTER_SET_PAGE2 for the MIB counters
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsPg2GetPortAllCountersClear
+(
+    IN  GT_QD_DEV               *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET_PAGE2    *statsCounterSet
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsPg2GetPortAllCountersClear Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Gigabit Switch does not support this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+	/* Enter Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_TRUE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_ALL_CLEAR,hwPort,0,(GT_VOID*)statsCounterSet);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	/* Exit Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_FALSE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsPg2GetRealtimePortCounter
+*
+* DESCRIPTION:
+*        This routine gets a specific realtime counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstatsPg2GetRealtimePortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS_PAGE2   counter,
+    OUT GT_U32            *statsData
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsPg2GetRealtimePortCounter Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+	/* Enter Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_TRUE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_REALTIME_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	/* Exit Page2 access */
+    retVal = gtP2SetAccessRMUPage2(dev, GT_FALSE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (gtP2SetAccessRMUPage2 returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* statsOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all stats control functions, and is responsible
+*       to write the required operation into the stats registers.
+*
+* INPUTS:
+*       statsOp       - The stats operation bits to be written into the stats
+*                     operation register.
+*       port        - port number
+*       counter     - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       statsData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static GT_STATUS statsOperationPerform
+(
+    IN   GT_QD_DEV            *dev,
+    IN   GT_STATS_OPERATION   statsOp,
+    IN   GT_U8                port,
+    IN   GT_STATS_COUNTERS_PAGE2    counter,
+    OUT  GT_VOID              *statsData
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data; /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U32 statsCounter;
+    GT_U32 lastCounter;
+    GT_U16            portNum;
+	GT_U8 bank;
+
+    gtSemTake(dev,dev->statsRegsSem,OS_WAIT_FOREVER);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
+    {
+        portNum = (port + 1) << 5;
+    }
+    else
+    {
+        portNum = (GT_U16)port;
+    }
+
+    /* Wait until the stats in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->statsRegsSem);
+        return retVal;
+      }
+      histoData = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->statsRegsSem);
+            return retVal;
+        }
+    }
+
+#endif
+
+    /* Set the STAT Operation register */
+    switch (statsOp)
+    {
+        case STATS_READ_COUNTER:
+			bank = (counter&GT_PAGE2_BANK1)?1:0;
+            retVal = statsCapture(dev, bank, port);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            retVal = statsReadCounter(dev,counter,(GT_U32*)statsData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+            break;
+
+        case STATS_READ_COUNTER_CLEAR:
+			bank = (counter&GT_PAGE2_BANK1)?1:0;
+            retVal = statsCaptureClear(dev, bank, port);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            retVal = statsReadCounter(dev,counter,(GT_U32*)statsData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+            break;
+
+        case STATS_READ_REALTIME_COUNTER:
+            retVal = statsReadRealtimeCounter(dev,port,counter,(GT_U32*)statsData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            break;
+
+        case STATS_READ_ALL:
+          for(bank=0; bank<2; bank++)
+		  {
+            retVal = statsCapture(dev, bank, port);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            lastCounter = (bank==0)?(GT_U32)STATS_PG2_Late : (GT_U32)STATS_PG2_OutMGMT;
+
+            for(statsCounter=0; statsCounter<=lastCounter; statsCounter++)
+            {
+                retVal = statsReadCounter(dev,statsCounter,((GT_U32*)statsData + statsCounter));
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->statsRegsSem);
+                    return retVal;
+                }
+            }
+		  }
+            break;
+
+        case STATS_READ_ALL_CLEAR:
+          for(bank=0; bank<2; bank++)
+		  {
+            retVal = statsCaptureClear(dev,bank, port);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            lastCounter = (bank==0)?(GT_U32)STATS_PG2_Late : (GT_U32)STATS_PG2_OutMGMT;
+
+            for(statsCounter=0; statsCounter<=lastCounter; statsCounter++)
+            {
+                retVal = statsReadCounter(dev,statsCounter,((GT_U32*)statsData + statsCounter));
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->statsRegsSem);
+                    return retVal;
+                }
+            }
+		  }
+            break;
+
+        default:
+
+            gtSemGive(dev,dev->statsRegsSem);
+            return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->statsRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* statsCapture
+*
+* DESCRIPTION:
+*       This function is used to capture all counters of a port.
+*
+* INPUTS:
+*       port        - port number
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*        If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsCapture
+(
+    IN GT_QD_DEV            *dev,
+    IN GT_U8             bank,
+    IN GT_U8             port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U16            portNum;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
+    {
+        portNum = (port + 1) << 5;
+    }
+    else
+    {
+        portNum = (GT_U16)port;
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+    data = (1 << 15) | (GT_STATS_CAPTURE_PORT << 12) | portNum | (bank<<9);
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* statsCaptureClear
+*
+* DESCRIPTION:
+*       This function is used to capture all counters of a port and clear.
+*
+* INPUTS:
+*       port        - port number
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*        If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsCaptureClear
+(
+    IN GT_QD_DEV            *dev,
+    IN GT_U8             bank,
+    IN GT_U8             port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;/* Data to be set into the      */
+                                    /* register.                    */
+    GT_U16            portNum;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
+    {
+        portNum = (port + 1) << 5;
+    }
+    else
+    {
+        portNum = (GT_U16)port;
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+    data = (1 << 15) | (GT_STATS_CAPTURE_PORT_CLEAR << 12) | portNum | (bank<<9);
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* statsReadCounter
+*
+* DESCRIPTION:
+*       This function is used to read a captured counter.
+*
+* INPUTS:
+*       counter     - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       statsData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*        If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsReadCounter
+(
+    IN   GT_QD_DEV      *dev,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
+)
+{
+    GT_STATUS   retVal;         /* Functions return value.            */
+    GT_U16      data;/* Data to be set into the  register. */
+	GT_U8       bank;
+#ifndef GT_RMGMT_ACCESS
+    GT_U16    counter3_2;     /* Counter Register Bytes 3 & 2       */
+    GT_U16    counter1_0;     /* Counter Register Bytes 1 & 0       */
+#endif
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+	bank = (counter&GT_PAGE2_BANK1)?1:0;
+    data = (GT_U16)((1 << 15) | (GT_STATS_READ_COUNTER << 12) | counter | (bank<<9));
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_STATS_COUNTER3_2;
+      regAccess.rw_reg_list[1].data = 0;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_STATS_COUNTER1_0;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+      *statsData = (regAccess.rw_reg_list[1].data << 16) | regAccess.rw_reg_list[2].data;
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *statsData = (counter3_2 << 16) | counter1_0;
+#endif
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* statsReadRealtimeCounter
+*
+* DESCRIPTION:
+*       This function is used to read a realtime counter.
+*
+* INPUTS:
+*       port     - port to be accessed
+*       counter  - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       statsData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*        If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsReadRealtimeCounter
+(
+    IN   GT_QD_DEV      *dev,
+    IN   GT_U8             port,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
+)
+{
+    GT_STATUS   retVal;         /* Functions return value.            */
+    GT_U16      data, histoData;/* Data to be set into the  register. */
+    GT_U16    counter3_2;     /* Counter Register Bytes 3 & 2       */
+    GT_U16    counter1_0;     /* Counter Register Bytes 1 & 0       */
+    GT_U8  bank;
+
+    /* Get the Histogram mode bit.                */
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    histoData &= 0xC00;
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+	bank = (counter&GT_PAGE2_BANK1)?1:0;
+    data = (GT_U16)((1 << 15) | (GT_STATS_READ_COUNTER << 12) | ((port+1) << 5) | counter | (bank<<9));
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *statsData = (counter3_2 << 16) | counter1_0;
+
+    return GT_OK;
+
+}
+
+/* Page 2 ATU APIs */
+
+
+/* Page 2 SMI APIs */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl.c
@@ -0,0 +1,3005 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPhyCtrl.h
+*
+* DESCRIPTION:
+* API definitions for PHY control facility.
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 10 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtVct.h>
+#include <gtSem.h>
+#ifdef GT_USE_MAD
+#include <gtMad.h>
+#endif
+
+#ifdef GT_USE_MAD
+#include "gtPhyCtrl_mad.c"
+#endif
+/*
+ * This routine set Auto-Negotiation Ad Register for Fast Ethernet Phy
+*/
+static
+GT_STATUS feSetAutoMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8      hwPort,
+    IN GT_PHY_INFO     *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+    GT_U16             u16Data;
+
+    GT_UNUSED_PARAM(phyInfo);
+
+    DBG_INFO(("feSetAutoMode Called.\n"));
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+           return GT_FAIL;
+    }
+
+    /* Mask out all auto mode related bits. */
+    u16Data &= ~QD_PHY_MODE_AUTO_AUTO;
+
+    switch(mode)
+    {
+        case SPEED_AUTO_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_AUTO_AUTO;
+                break;
+        case SPEED_100_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_100_AUTO;
+                break;
+        case SPEED_10_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_10_AUTO;
+                break;
+        case SPEED_AUTO_DUPLEX_FULL:
+                u16Data |= QD_PHY_MODE_AUTO_FULL;
+                break;
+        case SPEED_AUTO_DUPLEX_HALF:
+                u16Data |= QD_PHY_MODE_AUTO_HALF;
+                break;
+        case SPEED_100_DUPLEX_FULL:
+                u16Data |= QD_PHY_100_FULL;
+                break;
+        case SPEED_100_DUPLEX_HALF:
+                u16Data |= QD_PHY_100_HALF;
+                break;
+        case SPEED_10_DUPLEX_FULL:
+                u16Data |= QD_PHY_10_FULL;
+                break;
+        case SPEED_10_DUPLEX_HALF:
+                u16Data |= QD_PHY_10_HALF;
+                break;
+        default:
+                 DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+                return GT_BAD_PARAM;
+    }
+
+    /* Write to Phy AutoNegotiation Advertisement Register.  */
+    if(hwWritePhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+           return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+/*
+ * This routine set Auto-Negotiation Ad Register for Copper
+*/
+static
+GT_STATUS gigCopperSetAutoMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8 hwPort,
+    IN GT_PHY_INFO     *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+    GT_U16             u16Data,u16Data1;
+
+    DBG_INFO(("gigCopperSetAutoMode Called.\n"));
+
+    if(hwReadPagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+           return GT_FAIL;
+    }
+
+    /* Mask out all auto mode related bits. */
+    u16Data &= ~QD_PHY_MODE_AUTO_AUTO;
+
+    if(hwReadPagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_1000AD_REG,phyInfo->anyPage,&u16Data1) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+           return GT_FAIL;
+    }
+
+    /* Mask out all auto mode related bits. */
+    u16Data1 &= ~(QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF);
+
+    switch(mode)
+    {
+        case SPEED_AUTO_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_AUTO_AUTO;
+        case SPEED_1000_DUPLEX_AUTO:
+                u16Data1 |= QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF;
+                break;
+        case SPEED_AUTO_DUPLEX_FULL:
+                u16Data  |= QD_PHY_MODE_AUTO_FULL;
+                u16Data1 |= QD_GIGPHY_1000T_FULL;
+                break;
+        case SPEED_1000_DUPLEX_FULL:
+                u16Data1 |= QD_GIGPHY_1000T_FULL;
+                break;
+        case SPEED_1000_DUPLEX_HALF:
+                u16Data1 |= QD_GIGPHY_1000T_HALF;
+                break;
+        case SPEED_AUTO_DUPLEX_HALF:
+                u16Data  |= QD_PHY_MODE_AUTO_HALF;
+                u16Data1 |= QD_GIGPHY_1000T_HALF;
+                break;
+        case SPEED_100_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_100_AUTO;
+                break;
+        case SPEED_10_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_10_AUTO;
+                break;
+        case SPEED_100_DUPLEX_FULL:
+                u16Data |= QD_PHY_100_FULL;
+                break;
+        case SPEED_100_DUPLEX_HALF:
+                u16Data |= QD_PHY_100_HALF;
+                break;
+        case SPEED_10_DUPLEX_FULL:
+                u16Data |= QD_PHY_10_FULL;
+                break;
+        case SPEED_10_DUPLEX_HALF:
+                u16Data |= QD_PHY_10_HALF;
+                break;
+        default:
+                DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+                return GT_BAD_PARAM;
+    }
+
+    /* Write to Phy AutoNegotiation Advertisement Register.  */
+    if(hwWritePagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+           return GT_FAIL;
+    }
+
+    /* Write to Phy AutoNegotiation 1000B Advertisement Register.  */
+    if(hwWritePagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_1000AD_REG,phyInfo->anyPage,u16Data1) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+           return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+/*
+ * This routine set Auto-Negotiation Ad Register for Fiber
+*/
+static
+GT_STATUS gigFiberSetAutoMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8 hwPort,
+    IN GT_PHY_INFO     *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+    GT_U16             u16Data;
+
+    DBG_INFO(("gigPhySetAutoMode Called.\n"));
+
+    if(hwReadPagedPhyReg(dev,hwPort,1,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+           return GT_FAIL;
+    }
+
+    /* Mask out all auto mode related bits. */
+    u16Data &= ~(QD_GIGPHY_1000X_FULL|QD_GIGPHY_1000X_HALF);
+
+    switch(mode)
+    {
+        case SPEED_AUTO_DUPLEX_AUTO:
+        case SPEED_1000_DUPLEX_AUTO:
+                u16Data |= QD_GIGPHY_1000X_FULL|QD_GIGPHY_1000X_HALF;
+                break;
+        case SPEED_AUTO_DUPLEX_FULL:
+        case SPEED_1000_DUPLEX_FULL:
+                u16Data |= QD_GIGPHY_1000X_FULL;
+                break;
+        case SPEED_AUTO_DUPLEX_HALF:
+        case SPEED_1000_DUPLEX_HALF:
+                u16Data |= QD_GIGPHY_1000X_HALF;
+                break;
+        default:
+                    DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+                return GT_BAD_PARAM;
+    }
+
+    /* Write to Phy AutoNegotiation Advertisement Register.  */
+    if(hwWritePagedPhyReg(dev,hwPort,1,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+           return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+/*
+ * This routine sets Auto Mode and Reset the phy
+*/
+static
+GT_STATUS phySetAutoMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8 hwPort,
+    IN GT_PHY_INFO *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+    GT_U16         u16Data;
+    GT_STATUS    status;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+    DBG_INFO(("phySetAutoMode Called.\n"));
+
+    if (!(phyInfo->flag & GT_PHY_GIGABIT))
+    {
+        if((status=feSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
+        {
+               return status;
+        }
+
+        u16Data = QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+
+        DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+                  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+        /* soft reset */
+        return hwPhyReset(dev,hwPort,u16Data);
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo->pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        return GT_FAIL;
+    }
+
+    if(phyInfo->flag & GT_PHY_COPPER)
+    {
+        if((status=gigCopperSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
+        {
+               return status;
+        }
+
+        u16Data = QD_PHY_AUTONEGO;
+
+        DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+                  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+        /* Write to Phy Control Register.  */
+        if(hwWritePagedPhyReg(dev,hwPort,0,QD_PHY_CONTROL_REG,phyInfo->anyPage,u16Data) != GT_OK)
+            return GT_FAIL;
+    }
+    else if(phyInfo->flag & GT_PHY_FIBER)
+    {
+        if((status=gigFiberSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
+        {
+               return status;
+        }
+        u16Data = QD_PHY_AUTONEGO;
+
+        DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+                  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+        /* Write to Phy Control Register.  */
+        if(hwWritePagedPhyReg(dev,hwPort,1,QD_PHY_CONTROL_REG,phyInfo->anyPage,u16Data) != GT_OK)
+            return GT_FAIL;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo->pageType,autoOn,pageReg) != GT_OK)
+    {
+        return GT_FAIL;
+    }
+
+    return hwPhyReset(dev,hwPort,0xFF);
+}
+
+
+/*******************************************************************************
+* gprtPhyReset
+*
+* DESCRIPTION:
+*       This routine preforms PHY reset.
+*        After reset, phy will be in Autonegotiation mode.
+*
+* INPUTS:
+* port - The logical port number, unless SERDES device is accessed
+*        The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 0.15 - Reset
+* data sheet register 0.13 - Speed
+* data sheet register 0.12 - Autonegotiation
+* data sheet register 0.8  - Duplex Mode
+*******************************************************************************/
+
+GT_STATUS gprtPhyReset
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtPhyReset_mad(dev, port);
+#endif
+
+    DBG_INFO(("gprtPhyReset Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* set Auto Negotiation AD Register */
+    retVal = phySetAutoMode(dev,hwPort,&phyInfo,SPEED_AUTO_DUPLEX_AUTO);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortLoopback
+*
+* DESCRIPTION:
+* Enable/Disable Internal Port Loopback.
+* For 10/100 Fast Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled, this routine disables Auto-Negotiation and
+*   forces speed to be 10Mbps.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   Disabling Loopback simply clears bit 14 of control register(0.14). Therefore,
+*   it is recommended to call gprtSetPortAutoMode for PHY configuration after
+*   Loopback test.
+* For 10/100/1000 Gigagbit Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled and Link is active, the current speed is used.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   All other cases, default MAC Interface speed is used. Please refer to the data
+*   sheet for the information of the default MAC Interface speed.
+*
+*
+* INPUTS:
+* port - The logical port number, unless SERDES device is accessed
+*        The physical address, if SERDES device is accessed
+* enable - If GT_TRUE, enable loopback mode
+* If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortLoopback
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   enable
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetPortLoopback_mad(dev, port, enable);
+#endif
+
+    DBG_INFO(("gprtSetPortLoopback Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* is this Fast Ethernet Phy? */
+    if (!(phyInfo.flag & GT_PHY_GIGABIT))
+    {
+        if(enable)
+        {
+            if(u16Data & QD_PHY_AUTONEGO)
+            {
+                /* disable Auto-Neg and force speed to be 10Mbps */
+                u16Data = u16Data & QD_PHY_DUPLEX;
+
+                if((retVal=hwPhyReset(dev,hwPort,u16Data)) != GT_OK)
+                {
+                    DBG_INFO(("Softreset failed.\n"));
+                    gtSemGive(dev,dev->phyRegsSem);
+                    return retVal;
+                }
+            }
+        }
+    }
+
+    BOOL_2_BIT(enable,u16Data);
+
+    /* Write to Phy Control Register.  */
+    retVal = hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,14,1,u16Data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortSpeed
+*
+* DESCRIPTION:
+*         Sets speed for a specific logical port. This function will keep the duplex
+*        mode and loopback mode to the previous value, but disable others, such as
+*        Autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*        speed - port speed.
+*                PHY_SPEED_10_MBPS for 10Mbps
+*                PHY_SPEED_100_MBPS for 100Mbps
+*                PHY_SPEED_1000_MBPS for 1000Mbps
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.13 - Speed Selection (LSB)
+* data sheet register 0.6  - Speed Selection (MSB)
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortSpeed
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_SPEED speed
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_PHY_INFO        phyInfo;
+    GT_STATUS        retVal;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetPortSpeed_mad(dev, port, speed);
+#endif
+
+    DBG_INFO(("gprtSetPortSpeed Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    switch(speed)
+    {
+        case PHY_SPEED_10_MBPS:
+            if ((phyInfo.flag & GT_PHY_GIGABIT) && !(phyInfo.flag & GT_PHY_COPPER))
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+            }
+            u16Data = u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX);
+            break;
+        case PHY_SPEED_100_MBPS:
+            u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX)) | QD_PHY_SPEED;
+            break;
+        case PHY_SPEED_1000_MBPS:
+            if (!(phyInfo.flag & GT_PHY_GIGABIT))
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+            }
+            u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX)) | QD_PHY_SPEED_MSB;
+            break;
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+    }
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    retVal = hwPhyReset(dev,hwPort,u16Data);
+      gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtPortAutoNegEnable
+*
+* DESCRIPTION:
+*         Enable/disable an Auto-Negotiation.
+*        This routine simply sets Auto Negotiation bit (bit 12) of Control
+*        Register and reset the phy.
+*        For Speed and Duplex selection, please use gprtSetPortAutoMode.
+*
+* INPUTS:
+*        port -  The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         state - GT_TRUE for enable Auto-Negotiation,
+*                GT_FALSE otherwise
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*
+*******************************************************************************/
+GT_STATUS gprtPortAutoNegEnable
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtPortAutoNegEnable_mad(dev, port, state);
+#endif
+
+    DBG_INFO(("gprtPortAutoNegEnable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(state)
+    {
+        u16Data = (u16Data & (QD_PHY_SPEED | QD_PHY_DUPLEX)) | QD_PHY_AUTONEGO;
+    }
+    else
+    {
+        u16Data = u16Data & (QD_PHY_SPEED | QD_PHY_DUPLEX);
+    }
+
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    retVal = hwPhyReset(dev,hwPort,u16Data);
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtPortPowerDown
+*
+* DESCRIPTION:
+*         Enable/disable (power down) on specific logical port.
+*        Phy configuration remains unchanged after Power down.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         state -    GT_TRUE: power down
+*                 GT_FALSE: normal operation
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortPowerDown
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   state
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtPortPowerDown_mad(dev, port, state);
+#endif
+
+    DBG_INFO(("gprtPortPowerDown Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state,u16Data);
+
+    if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,11,1,u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtPortRestartAutoNeg
+*
+* DESCRIPTION:
+*         Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable
+*        it. Loopback and Power Down will be disabled by this routine.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.9 - Restart Auto-Negotiation
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortRestartAutoNeg
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port
+)
+{
+    GT_STATUS       retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtPortRestartAutoNeg_mad(dev, port);
+#endif
+
+    DBG_INFO(("gprtPortRestartAutoNeg Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    u16Data &= (QD_PHY_DUPLEX | QD_PHY_SPEED);
+    u16Data |= (QD_PHY_RESTART_AUTONEGO | QD_PHY_AUTONEGO);
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+    gtSemGive(dev,dev->phyRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetPortDuplexMode
+*
+* DESCRIPTION:
+*         Sets duplex mode for a specific logical port. This function will keep
+*        the speed and loopback mode to the previous value, but disable others,
+*        such as Autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         dMode    - dulpex mode
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.8 - Duplex Mode
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortDuplexMode
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   dMode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetPortDuplexMode_mad(dev, port, dMode);
+#endif
+
+    DBG_INFO(("gprtSetPortDuplexMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(dMode)
+    {
+        u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB)) | QD_PHY_DUPLEX;
+    }
+    else
+    {
+        u16Data = u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB);
+    }
+
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwPhyReset(dev,hwPort,u16Data);
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortAutoMode
+*
+* DESCRIPTION:
+*         This routine sets up the port with given Auto Mode.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         mode - Auto Mode to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - on device without copper
+*
+* COMMENTS:
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+
+GT_STATUS gprtSetPortAutoMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetPortAutoMode_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtSetPortAutoMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    retVal = GT_NOT_SUPPORTED;
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    retVal = phySetAutoMode(dev,hwPort,&phyInfo,mode);
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+
+}
+
+
+/*******************************************************************************
+* gprtSetPause
+*
+* DESCRIPTION:
+*       This routine will set the pause bit in Autonegotiation Advertisement
+*        Register. And restart the autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*        state - GT_PHY_PAUSE_MODE enum value.
+*                GT_PHY_NO_PAUSE        - disable pause
+*                 GT_PHY_PAUSE        - support pause
+*                GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*                GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+
+GT_STATUS gprtSetPause
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_PAUSE_MODE state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data,regStart;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetPause_mad(dev, port, state);
+#endif
+
+    DBG_INFO(("phySetPause Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    regStart = 10;
+
+    if(state & GT_PHY_ASYMMETRIC_PAUSE)
+    {
+        if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+        {
+            DBG_INFO(("Unknown PHY device.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if (!(phyInfo.flag & GT_PHY_GIGABIT))
+        {
+            DBG_INFO(("Not Supported\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_BAD_PARAM;
+        }
+
+        if(!(phyInfo.flag & GT_PHY_COPPER))
+        {
+            regStart = 7;
+        }
+
+    }
+
+    u16Data = state;
+
+    /* Write to Phy AutoNegotiation Advertisement Register.  */
+    if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,(GT_U8)regStart,2,u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* Restart Auto Negotiation */
+    if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,9,1,1)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+static
+GT_STATUS dteWorkAround_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort
+)
+{
+    GT_STATUS status = GT_OK;
+    GT_U32 threshold[] = {0x000B,0x0000,0x8780,0x0000,0x8F80,0x0000,
+                          0x9780,0x0000,0x9F80,0x0000,0xA780,0x0000,
+                          0xAF80,0x0000,0xB780,0x0000,0xBF80,0x0000,
+                          0xC780,0x0000,0xCF80,0x0000,0xD780,0x0000,
+                          0xDF80,0x0000,0xE780,0x0000,0xEF80,0x0000,
+                          0xF780,0x0000,0xFF80,0x0000};
+    int i, thresholdSize;
+
+    /* force r125 clock */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x807f)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* write thresholds */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000B)) != GT_OK)
+    {
+        return status;
+    }
+
+    thresholdSize = sizeof(threshold)/sizeof(GT_U32);
+
+    for(i=0; i<thresholdSize; i++)
+    {
+        if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    /* setting adc Masking */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0001)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4000)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* setting noise level */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0005)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0xA000)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*
+        offseting cable length measurement by 6.72m(2*4*0.84m)
+        set 30_10.14:11 to 0x1001 for cable length measure.
+    */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000a)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4840)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* release force r125 clock */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x0000)) != GT_OK)
+    {
+        return status;
+    }
+
+
+    return status;
+}
+
+static
+GT_STATUS dteWorkAround_Phy1000M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort
+)
+{
+    GT_STATUS status = GT_OK;
+    GT_U32 threshold[] = {0x0000,0x8780,0x0000,0x8F80,0x0000,0x9780,
+                          0x0000,0x9F80,0x0000,0xA780,0x0000,0xAF80,
+                          0x0000,0xB780,0x0000,0xBF80,0x0000,0xC780,
+                          0x0000,0xCF80,0x0000,0xD780,0x0000,0xDF80,
+                          0x0000,0xE780,0x0000,0xEF80,0x0000,0xF780,
+                          0x0000,0xFF80,0x0000};
+    int i, thresholdSize;
+
+    /*  */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001B)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x43FF)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*  */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001C)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x9999)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*  */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001F)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0xE00C)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*  */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0018)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0xFFA1)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* write thresholds */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0010)) != GT_OK)
+    {
+        return status;
+    }
+
+    thresholdSize = sizeof(threshold)/sizeof(GT_U32);
+
+    for(i=0; i<thresholdSize; i++)
+    {
+        if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    return status;
+}
+
+static
+GT_STATUS feSetDTE
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort,
+    IN  GT_BOOL   state
+)
+{
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+
+    if((retVal = hwReadPhyReg(dev,hwPort,0x10,&u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    u16Data = state?(u16Data|0x8000):(u16Data&(~0x8000));
+
+    if((retVal = hwWritePhyReg(dev,hwPort,0x10,u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* soft reset */
+    if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    return retVal;
+}
+
+static
+GT_STATUS gigSetDTE
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort,
+    IN  GT_BOOL   state
+)
+{
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+
+    if((retVal = hwReadPhyReg(dev,hwPort,20,&u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    u16Data = state?(u16Data|0x4):(u16Data&(~0x4));
+
+    if((retVal = hwWritePhyReg(dev,hwPort,20,u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* soft reset */
+    if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    return retVal;
+}
+
+static
+GT_STATUS gigMPSetDTE
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort,
+    IN  GT_BOOL   state
+)
+{
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+
+    if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,0,&u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    u16Data = state?(u16Data|0x100):(u16Data&(~0x100));
+
+    if((retVal = hwWritePagedPhyReg(dev,hwPort,0,26,0,u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* soft reset */
+    if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetDTEDetect
+*
+* DESCRIPTION:
+*       This routine enables/disables DTE.
+*
+* INPUTS:
+*         port - The logical port number
+*         mode - either GT_TRUE(for enable) or GT_FALSE(for disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetect
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetDTEDetect_mad(dev, port, state);
+#endif
+
+    DBG_INFO(("phySetDTE Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch(phyInfo.dteType)
+    {
+        case GT_PHY_DTE_TYPE1:
+            /* FE Phy needs work-around */
+            if((retVal = feSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            if(state == GT_FALSE)
+                break;
+
+            if((retVal = dteWorkAround_Phy100M(dev,hwPort)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            break;
+        case GT_PHY_DTE_TYPE3:
+            /* Gigabit Phy with work-around required */
+            if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            if(state == GT_FALSE)
+                break;
+
+            if((retVal = dteWorkAround_Phy1000M(dev,hwPort)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            break;
+
+        case GT_PHY_DTE_TYPE2:
+            /* no workaround required */
+            if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            break;
+        case GT_PHY_DTE_TYPE4:
+            /* no workaround required */
+            if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            if((retVal = gigMPSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+            break;
+        case GT_PHY_DTE_TYPE5:
+            /* FE Phy */
+            if((retVal = feSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            break;
+
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectStatus
+*
+* DESCRIPTION:
+*       This routine gets DTE status.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       status - GT_TRUE, if link partner needs DTE power.
+*                 GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectStatus
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data,pageReg;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetDTEDetectStatus_mad(dev, port, state);
+#endif
+
+    DBG_INFO(("gprtGetDTEStatus Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch(phyInfo.dteType)
+    {
+        case GT_PHY_DTE_TYPE1:
+            /* FE Phy needs work-around */
+            if((retVal = hwReadPhyReg(dev,hwPort,17,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            *state = (u16Data & 0x8000)?GT_TRUE:GT_FALSE;
+
+            break;
+        case GT_PHY_DTE_TYPE2:
+        case GT_PHY_DTE_TYPE3:
+            if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            *state = (u16Data & 0x10)?GT_TRUE:GT_FALSE;
+
+            break;
+        case GT_PHY_DTE_TYPE4:
+            if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            if((retVal = hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            *state = (u16Data & 0x4)?GT_TRUE:GT_FALSE;
+
+            if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            break;
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDTEDetectDropWait
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*        will wait a period of time before clearing the power over Ethernet
+*        detection status bit. The wait time is 5 seconds multiplied by the
+*        given value.
+*
+* INPUTS:
+*         port - The logical port number
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetectDropWait
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_U16    waitTime
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetDTEDetectDropWait_mad(dev, port, waitTime);
+#endif
+
+    DBG_INFO(("gprtSetDTEDropWait Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch(phyInfo.dteType)
+    {
+        case GT_PHY_DTE_TYPE1:
+            if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data & ~(0xF<<12)) | ((waitTime & 0xF) << 12);
+
+            if((retVal = hwWritePhyReg(dev,hwPort,22,u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            break;
+        case GT_PHY_DTE_TYPE2:
+        case GT_PHY_DTE_TYPE3:
+            if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data & ~(0xF<<5)) | ((waitTime & 0xF) << 5);
+
+            if((retVal = hwWritePhyReg(dev,hwPort,27,u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            break;
+        case GT_PHY_DTE_TYPE4:
+            if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data & ~(0xF<<4)) | ((waitTime & 0xF) << 4);
+            if((retVal = hwWritePagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            break;
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectDropWait
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*        will wait a period of time before clearing the power over Ethernet
+*        detection status bit. The wait time is 5 seconds multiplied by the
+*        returned value.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectDropWait
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_U16    *waitTime
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetDTEDetectDropWait_mad(dev, port, waitTime);
+#endif
+
+    DBG_INFO(("gprtSetDTEDropWait Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch(phyInfo.dteType)
+    {
+        case GT_PHY_DTE_TYPE1:
+            if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data >> 12) & 0xF;
+
+            break;
+        case GT_PHY_DTE_TYPE2:
+        case GT_PHY_DTE_TYPE3:
+            if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data >> 5) & 0xF;
+
+            break;
+        case GT_PHY_DTE_TYPE4:
+            if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data >> 4) & 0xF;
+
+            if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+            break;
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_NOT_SUPPORTED;
+    }
+
+    *waitTime = u16Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetEnergyDetect
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*         mode - GT_EDETECT_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetEnergyDetect
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetEnergyDetect_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtSetEnergyDetect Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (phyInfo.flag & GT_PHY_SERDES_CORE)
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+    else if (phyInfo.flag & GT_PHY_GIGABIT)
+    {
+        /* check if the mode is valid */
+        switch (mode)
+        {
+            case GT_EDETECT_OFF:
+                u16Data = 0;
+                break;
+            case GT_EDETECT_SENSE_PULSE:
+                u16Data = 3;
+                break;
+            case GT_EDETECT_SENSE:
+                u16Data = 2;
+                break;
+            default:
+                DBG_INFO(("Invalid paramerter.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+        }
+
+        if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if((retVal = hwSetPagedPhyRegField(dev,hwPort,0,0x10,8,2,phyInfo.anyPage,u16Data)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+
+        if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+
+        if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+    }
+    else    /* it's a Fast Ethernet device */
+    {
+        /* check if the mode is valid */
+        switch (mode)
+        {
+            case GT_EDETECT_OFF:
+                u16Data = 0;
+                break;
+            case GT_EDETECT_SENSE_PULSE:
+                u16Data = 1;
+                break;
+            case GT_EDETECT_SENSE:
+            default:
+                DBG_INFO(("Invalid paramerter.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+        }
+
+        if((retVal = hwSetPhyRegField(dev,hwPort,0x10,14,1,u16Data)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetEnergyDetect
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       mode - GT_EDETECT_MODE type
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetEnergyDetect
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetEnergyDetect_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtGetEnergyDetect Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (phyInfo.flag & GT_PHY_SERDES_CORE)
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+    else if (phyInfo.flag & GT_PHY_GIGABIT)
+    {
+        /* read the mode */
+
+        if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if((retVal = hwGetPagedPhyRegField(dev,hwPort,0,0x10,8,2,phyInfo.anyPage,&u16Data)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+
+        if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        switch (u16Data)
+        {
+            case 0:
+            case 1:
+                *mode = GT_EDETECT_OFF;
+                break;
+            case 2:
+                *mode = GT_EDETECT_SENSE;
+                break;
+            case 3:
+                *mode = GT_EDETECT_SENSE_PULSE;
+                break;
+            default:
+                DBG_INFO(("Unknown value (shouldn't happen).\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+        }
+
+    }
+    else    /* it's a Fast Ethernet device */
+    {
+        /* read the mode */
+        if((retVal = hwGetPhyRegField(dev,hwPort,0x10,14,1,&u16Data)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+
+        switch (u16Data)
+        {
+            case 0:
+                *mode = GT_EDETECT_OFF;
+                break;
+            case 1:
+                *mode = GT_EDETECT_SENSE_PULSE;
+                break;
+            default:
+                DBG_INFO(("Unknown value (shouldn't happen).\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+        }
+
+    }
+
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSet1000TMasterMode
+*
+* DESCRIPTION:
+*       This routine sets the ports 1000Base-T Master mode and restart the Auto
+*        negotiation.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_1000T_MASTER_SLAVE   *mode
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8            hwPort;         /* the physical port number     */
+    GT_U16        data;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSet1000TMasterMode_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtSet1000TMasterMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mode->autoConfig == GT_TRUE)
+    {
+        if(mode->masterPrefer == GT_TRUE)
+        {
+            data = 0x1;
+        }
+        else
+        {
+            data = 0x0;
+        }
+    }
+    else
+    {
+        if(mode->masterPrefer == GT_TRUE)
+        {
+            data = 0x6;
+        }
+        else
+        {
+            data = 0x4;
+        }
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* Set the Master Mode.    */
+    retVal = hwSetPagedPhyRegField(dev,hwPort,0,9,10,3,phyInfo.anyPage,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* Restart Auto Negotiation */
+    if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,9,1,1)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_CONTROL_REG,1));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGet1000TMasterMode
+*
+* DESCRIPTION:
+*       This routine retrieves 1000Base-T Master Mode
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_1000T_MASTER_SLAVE   *mode
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8            hwPort;         /* the physical port number     */
+    GT_U16        data;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGet1000TMasterMode_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtGet1000TMasterMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* Set the Master Mode.    */
+    retVal = hwGetPagedPhyRegField(dev,hwPort,0,9,10,3,phyInfo.anyPage,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(data & 0x4)    /* Manual Mode */
+    {
+        mode->autoConfig = GT_FALSE;
+
+        if(data & 0x2)
+        {
+            mode->masterPrefer = GT_TRUE;
+        }
+        else
+        {
+            mode->masterPrefer = GT_FALSE;
+        }
+    }
+    else    /* Auto Mode */
+    {
+        mode->autoConfig = GT_TRUE;
+
+        if(data & 0x1)
+        {
+            mode->masterPrefer = GT_TRUE;
+        }
+        else
+        {
+            mode->masterPrefer = GT_FALSE;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPhyLinkStatus
+*
+* DESCRIPTION:
+*       This routine retrieves the Link status.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       linkStatus - GT_FALSE if link is not established,
+*                     GT_TRUE if link is established.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyLinkStatus
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetPhyLinkStatus_mad(dev, port, linkStatus);
+#endif
+
+    DBG_INFO(("gprtGetPhyLinkStatus Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+         return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal=hwGetPhyRegField(dev,hwPort,17,10,1,&u16Data)) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+
+    BIT_2_BOOL(u16Data,*linkStatus);
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPktGenEnable
+*
+* DESCRIPTION:
+*       This routine enables or disables Packet Generator.
+*       Link should be established first prior to enabling the packet generator,
+*       and generator will generate packets at the speed of the established link.
+*        When enables packet generator, the following information should be
+*       provided:
+*           Payload Type:  either Random or 5AA55AA5
+*           Packet Length: either 64 or 1514 bytes
+*           Error Packet:  either Error packet or normal packet
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*       en      - GT_TRUE to enable, GT_FALSE to disable
+*       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
+*                 ignored, if en is GT_FALSE
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPktGenEnable
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   en,
+    IN GT_PG     *pktInfo
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             data;
+    GT_BOOL            link;
+    GT_PHY_INFO        phyInfo;
+    GT_U8            page,reg, offset, len;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetPktGenEnable_mad(dev, port, en, pktInfo);
+#endif
+
+    DBG_INFO(("gprtSetPktGenEnable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(!(phyInfo.flag & GT_PHY_PKT_GENERATOR))
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (phyInfo.pktGenType)
+    {
+        case GT_PHY_PKTGEN_TYPE1:    /* 30_18.5:2 */
+                page = 18;
+                reg = 30;
+                offset = 2;
+                break;
+        case GT_PHY_PKTGEN_TYPE2:    /* 16_6.3:0 */
+                page = 6;
+                reg = 16;
+                offset = 0;
+                break;
+        case GT_PHY_PKTGEN_TYPE3:    /* 25.3:0 */
+                page = 0;
+                reg = 25;
+                offset = 0;
+                break;
+        default:
+                DBG_INFO(("Unknown PKTGEN Type.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+    }
+
+    if (en)
+    {
+        if((retVal = gprtGetPhyLinkStatus(dev,port,&link)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if (link == GT_FALSE)
+        {
+            DBG_INFO(("Link should be on to run Packet Generator.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        data = 0x8;
+
+        if (pktInfo->payload == GT_PG_PAYLOAD_5AA5)
+            data |= 0x4;
+
+        if (pktInfo->length == GT_PG_LENGTH_1514)
+            data |= 0x2;
+
+        if (pktInfo->tx == GT_PG_TX_ERROR)
+            data |= 0x1;
+
+        len = 4;
+    }
+    else
+    {
+        data = 0;
+        len = 1;
+        offset += 3;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if((retVal=hwSetPagedPhyRegField(dev,hwPort,
+                page,reg,offset,len,phyInfo.anyPage,data)) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetPhyReg
+*
+* DESCRIPTION:
+*       This routine reads Phy Registers.
+*
+* INPUTS:
+*       port -    The logical port number,
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetPhyReg_mad(dev, port, regAddr, data);
+#endif
+
+    DBG_INFO(("gprtGetPhyReg Called.\n"));
+
+/*    hwPort = GT_LPORT_2_PHY(port); */
+    hwPort = qdLong2Char(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Get Phy Register. */
+    if(hwReadPhyReg(dev,hwPort,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *data = u16Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPhyReg
+*
+* DESCRIPTION:
+*       This routine writes Phy Registers.
+*
+* INPUTS:
+*       port -    The logical port number,
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPhyReg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    IN  GT_U32           regAddr,
+    IN  GT_U16           data
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetPhyReg_mad(dev, port, regAddr, data);
+#endif
+
+    DBG_INFO(("gprtSetPhyReg Called.\n"));
+
+/*    hwPort = GT_LPORT_2_PHY(port); */
+    hwPort = qdLong2Char(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Write to Phy Register */
+    if(hwWritePhyReg(dev,hwPort,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*
+* OUTPUTS:
+*        data    - value of the read register
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtGetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
+    OUT GT_U16* data
+)
+{
+    GT_PHY_INFO        phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+    GT_U8            hwPort;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetPagedPhyReg_mad(dev, port, regAddr, page, data);
+#endif
+
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(hwReadPagedPhyReg(dev,hwPort,(GT_U8)page,
+                                (GT_U8)regAddr,0,data) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*        data    - value of the read register
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtSetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
+    IN  GT_U16 data
+)
+{
+    GT_PHY_INFO        phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+    GT_U8            hwPort;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetPagedPhyReg_mad(dev, port, regAddr, page, data);
+#endif
+
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(hwWritePagedPhyReg(dev,hwPort,(GT_U8)page,
+                                (GT_U8)regAddr,0,data) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyCtrl_mad.c
@@ -0,0 +1,2045 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPhyCtrl.h
+*
+* DESCRIPTION:
+* API definitions for PHY control facility.
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 10 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtVct.h>
+#include <gtSem.h>
+
+
+#ifdef GT_USE_MAD
+#include "madApi.h"
+#include "madHwCntl.h"
+#endif
+
+
+/*
+ * This routine set Auto-Negotiation Ad Register for Copper
+*/
+static
+GT_STATUS translateAutoMode
+(
+    IN    GT_PHY_INFO  *phyInfo,
+    IN    GT_PHY_AUTO_MODE mode,
+    OUT      MAD_BOOL       *autoEn,
+    OUT   MAD_U32      *autoMode
+)
+{
+  MAD_BOOL        autoNegoEn;
+  MAD_SPEED_MODE    speedMode;
+  MAD_DUPLEX_MODE duplexMode;
+
+    switch(mode)
+    {
+        case SPEED_AUTO_DUPLEX_AUTO:
+          autoNegoEn = MAD_TRUE;
+          speedMode  = MAD_SPEED_AUTO;
+          duplexMode = MAD_AUTO_DUPLEX;
+        case SPEED_1000_DUPLEX_AUTO:
+          autoNegoEn = MAD_TRUE;
+          speedMode  = MAD_SPEED_1000M;
+          duplexMode = MAD_AUTO_DUPLEX;
+          break;
+        case SPEED_AUTO_DUPLEX_FULL:
+          autoNegoEn = MAD_TRUE;
+          speedMode  = MAD_SPEED_AUTO;
+          duplexMode = MAD_FULL_DUPLEX;
+          break;
+        case SPEED_1000_DUPLEX_FULL:
+          autoNegoEn = MAD_FALSE;
+          speedMode  = MAD_SPEED_1000M;
+          duplexMode = MAD_FULL_DUPLEX;
+          break;
+        case SPEED_1000_DUPLEX_HALF:
+          autoNegoEn = MAD_FALSE;
+          speedMode  = MAD_SPEED_1000M;
+          duplexMode = MAD_HALF_DUPLEX;
+          break;
+        case SPEED_AUTO_DUPLEX_HALF:
+          autoNegoEn = MAD_TRUE;
+          speedMode  = MAD_SPEED_AUTO;
+          duplexMode = MAD_HALF_DUPLEX;
+          break;
+        case SPEED_100_DUPLEX_AUTO:
+          autoNegoEn = MAD_FALSE;
+          speedMode  = MAD_SPEED_100M;
+          duplexMode = MAD_FULL_DUPLEX;
+          break;
+        case SPEED_10_DUPLEX_AUTO:
+          autoNegoEn = MAD_TRUE;
+          speedMode  = MAD_SPEED_10M;
+          duplexMode = MAD_AUTO_DUPLEX;
+          break;
+        case SPEED_100_DUPLEX_FULL:
+          autoNegoEn = MAD_FALSE;
+          speedMode  = MAD_SPEED_100M;
+          duplexMode = MAD_FULL_DUPLEX;
+          break;
+        case SPEED_100_DUPLEX_HALF:
+          autoNegoEn = MAD_FALSE;
+          speedMode  = MAD_SPEED_100M;
+          duplexMode = MAD_HALF_DUPLEX;
+          break;
+        case SPEED_10_DUPLEX_FULL:
+          autoNegoEn = MAD_FALSE;
+          speedMode  = MAD_SPEED_10M;
+          duplexMode = MAD_FULL_DUPLEX;
+          break;
+        case SPEED_10_DUPLEX_HALF:
+          autoNegoEn = MAD_FALSE;
+          speedMode  = MAD_SPEED_10M;
+          duplexMode = MAD_HALF_DUPLEX;
+          break;
+        default:
+          DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+          return GT_BAD_PARAM;
+    }
+
+    *autoEn = autoNegoEn;
+    if (mdGetAutoNegoMode(autoNegoEn, speedMode, duplexMode, autoMode) != MAD_OK)
+      return GT_FAIL;
+
+
+    return GT_OK;
+}
+
+/*
+ * This routine sets Auto Mode and Reset the phy
+*/
+static
+GT_STATUS phySetAutoMode_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8 hwPort,
+    IN GT_PHY_INFO *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+    MAD_STATUS    status;
+    MAD_U32 autoMode;
+    MAD_BOOL  autoEn;
+
+    DBG_INFO(("phySetAutoMode_mad Called.\n"));
+
+    status = translateAutoMode(phyInfo,mode, &autoEn, &autoMode);
+    if(status != GT_OK)
+    {
+       return status;
+    }
+
+
+    if(phyInfo->flag & GT_PHY_COPPER)
+    {
+        if((mdCopperSetAutoNeg(&(dev->mad_dev),hwPort,autoEn, autoMode)) != MAD_OK)
+        {
+               return GT_FAIL;
+        }
+
+    }
+    else if(phyInfo->flag & GT_PHY_FIBER)
+    {
+        if((mdFiberSetAutoNeg(&(dev->mad_dev),hwPort,autoEn, autoMode)) != MAD_OK)
+        {
+               return GT_FAIL;
+        }
+
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtPhyReset_mad
+*
+* DESCRIPTION:
+*       This routine preforms PHY reset.
+*        After reset, phy will be in Autonegotiation mode.
+*
+* INPUTS:
+* port - The logical port number, unless SERDES device is accessed
+*        The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 0.15 - Reset
+* data sheet register 0.13 - Speed
+* data sheet register 0.12 - Autonegotiation
+* data sheet register 0.8  - Duplex Mode
+*******************************************************************************/
+
+GT_STATUS gprtPhyReset_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+
+    DBG_INFO(("gprtPhyReset Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* set Auto Negotiation AD Register */
+    retVal = phySetAutoMode_mad(dev,hwPort,&phyInfo,SPEED_AUTO_DUPLEX_AUTO);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortLoopback_mad
+*
+* DESCRIPTION:
+* Enable/Disable Internal Port Loopback.
+* For 10/100 Fast Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled, this routine disables Auto-Negotiation and
+*   forces speed to be 10Mbps.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   Disabling Loopback simply clears bit 14 of control register(0.14). Therefore,
+*   it is recommended to call gprtSetPortAutoMode for PHY configuration after
+*   Loopback test.
+* For 10/100/1000 Gigagbit Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled and Link is active, the current speed is used.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   All other cases, default MAC Interface speed is used. Please refer to the data
+*   sheet for the information of the default MAC Interface speed.
+*
+*
+* INPUTS:
+* port - The logical port number, unless SERDES device is accessed
+*        The physical address, if SERDES device is accessed
+* enable - If GT_TRUE, enable loopback mode
+* If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortLoopback_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   enable
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    MAD_STATUS status;
+
+    DBG_INFO(("gprtSetPortLoopback_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if((status = mdDiagSetLineLoopback(&(dev->mad_dev),port,enable)) != MAD_OK)
+    {
+		if(status==MAD_API_LINK_DOWN)
+          return GT_OK;
+        DBG_INFO(("mdDiagSetLineLoopback failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPortSpeed_mad
+*
+* DESCRIPTION:
+*         Sets speed for a specific logical port. This function will keep the duplex
+*        mode and loopback mode to the previous value, but disable others, such as
+*        Autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*        speed - port speed.
+*                PHY_SPEED_10_MBPS for 10Mbps
+*                PHY_SPEED_100_MBPS for 100Mbps
+*                PHY_SPEED_1000_MBPS for 1000Mbps
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.13 - Speed Selection (LSB)
+* data sheet register 0.6  - Speed Selection (MSB)
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortSpeed_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_SPEED speed
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    MAD_STATUS status;
+    MAD_U32 mspeed;
+    MAD_DUPLEX_MODE mDuplexmod;
+
+    DBG_INFO(("gprtSetPortSpeed_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+    switch (speed)
+    {
+      case PHY_SPEED_10_MBPS:
+        mspeed = 10;
+        break;
+      case PHY_SPEED_100_MBPS:
+        mspeed = 100;
+        break;
+      case PHY_SPEED_1000_MBPS:
+      default:
+        mspeed = 1000;
+        break;
+    }
+
+    if((status = mdGetDuplexStatus(&(dev->mad_dev),port,&mDuplexmod)) != MAD_OK)
+    {
+        DBG_INFO(("mdGetDuplexStatus failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+
+    if((status = mdCopperSetSpeedDuplex(&(dev->mad_dev),port,mspeed,((mDuplexmod)?MAD_TRUE:MAD_FALSE))) != MAD_OK)
+    {
+        DBG_INFO(("mdCopperSetSpeedDuplex failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtPortAutoNegEnable_mad
+*
+* DESCRIPTION:
+*         Enable/disable an Auto-Negotiation.
+*        This routine simply sets Auto Negotiation bit (bit 12) of Control
+*        Register and reset the phy.
+*        For Speed and Duplex selection, please use gprtSetPortAutoMode.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         state - GT_TRUE for enable Auto-Negotiation,
+*                GT_FALSE otherwise
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*
+*******************************************************************************/
+GT_STATUS gprtPortAutoNegEnable_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_STATUS retVal;
+    MAD_SPEED_MODE speedMode;
+    MAD_DUPLEX_MODE duplexMode;
+    MAD_BOOL autoNegoEn;
+    MAD_U32            autoMode;
+
+    DBG_INFO(("gprtPortAutoNegEnable_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if ((retVal=mdGetSpeedStatus(&(dev->mad_dev), hwPort, &speedMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdGetSpeedStatus Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+     if ((retVal=mdGetDuplexStatus(&(dev->mad_dev), hwPort, &duplexMode))!=MAD_OK)
+    {
+       DBG_INFO(("mdGetDuplexStatus Failed.\n"));
+       gtSemGive(dev,dev->phyRegsSem);
+       return GT_FAIL;
+    }
+
+    autoNegoEn = (state==GT_TRUE)?MAD_TRUE:MAD_FALSE;
+
+    if ((mdGetAutoNegoMode(autoNegoEn, speedMode, duplexMode, &autoMode)) != MAD_OK)
+    {
+        DBG_INFO(("mdGetAutoNegoMode Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+     if ((retVal=mdCopperSetAutoNeg(&(dev->mad_dev), hwPort, autoNegoEn, autoMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdCopperSetAutoNeg Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtPortPowerDown_mad
+*
+* DESCRIPTION:
+*         Enable/disable (power down) on specific logical port.
+*        Phy configuration remains unchanged after Power down.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         state -    GT_TRUE: power down
+*                 GT_FALSE: normal operation
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortPowerDown_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_STATUS retVal;
+    MAD_BOOL pwMode
+
+    DBG_INFO(("gprtPortPowerDown_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (state==GT_TRUE)
+      pwMode = MAD_TRUE;
+    else
+      pwMode = MAD_FALSE;
+
+     if ((retVal=mdSysSetPhyEnable(&(dev->mad_dev), hwPort, pwMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdSysSetPhyEnable Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtPortRestartAutoNeg_mad
+*
+* DESCRIPTION:
+*         Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable
+*        it. Loopback and Power Down will be disabled by this routine.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.9 - Restart Auto-Negotiation
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortRestartAutoNeg_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port
+)
+{
+    GT_STATUS       retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          u16Data;
+    MAD_U32         u32Data;
+
+    DBG_INFO(("gprtPortRestartAutoNeg_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal=mdSysGetPhyReg(&(dev->mad_dev),hwPort,QD_PHY_CONTROL_REG,&u32Data)) != MAD_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    u16Data = u32Data;
+    u16Data &= (QD_PHY_DUPLEX | QD_PHY_SPEED);
+    u16Data |= (QD_PHY_RESTART_AUTONEGO | QD_PHY_AUTONEGO);
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    if((retVal=madHwPagedSetCtrlPara(&(dev->mad_dev),hwPort,0,u16Data)) != MAD_OK)
+    {
+        DBG_INFO(("CallmadHwPagedSetCtrlPara failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+
+    if(retVal != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPortDuplexMode_mad
+*
+* DESCRIPTION:
+*         Sets duplex mode for a specific logical port. This function will keep
+*        the speed and loopback mode to the previous value, but disable others,
+*        such as Autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         dMode    - dulpex mode
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.8 - Duplex Mode
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortDuplexMode_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   dMode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal;
+    MAD_U32         u32Data;
+
+    DBG_INFO(("gprtSetPortDuplexMode_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal=mdSysGetPhyReg(&(dev->mad_dev),hwPort,QD_PHY_CONTROL_REG,&u32Data)) != MAD_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    u16Data = u32Data;
+
+    if(dMode)
+    {
+        u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB)) | QD_PHY_DUPLEX;
+    }
+    else
+    {
+        u16Data = u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB);
+    }
+
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    if((retVal=madHwPagedSetCtrlPara(&(dev->mad_dev),hwPort,0,u16Data)) != MAD_OK)
+    {
+        DBG_INFO(("CallmadHwPagedSetCtrlPara failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetPortAutoMode_mad
+*
+* DESCRIPTION:
+*         This routine sets up the port with given Auto Mode.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         mode - Auto Mode to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - on device without copper
+*
+* COMMENTS:
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+
+GT_STATUS gprtSetPortAutoMode_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+
+    DBG_INFO(("gprtSetPortAutoMode_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    retVal = GT_NOT_SUPPORTED;
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    retVal = phySetAutoMode_mad(dev,hwPort,&phyInfo,mode);
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+
+}
+
+
+/*******************************************************************************
+* gprtSetPause_mad
+*
+* DESCRIPTION:
+*       This routine will set the pause bit in Autonegotiation Advertisement
+*        Register. And restart the autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*        state - GT_PHY_PAUSE_MODE enum value.
+*                GT_PHY_NO_PAUSE        - disable pause
+*                 GT_PHY_PAUSE        - support pause
+*                GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*                GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+
+GT_STATUS gprtSetPause_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_PAUSE_MODE state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    MAD_STATUS retVal;
+    MAD_BOOL autoNegoEn;
+    MAD_U32            autoMode
+
+    DBG_INFO(("phySetPause_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(state & GT_PHY_ASYMMETRIC_PAUSE)
+    {
+        if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+        {
+            DBG_INFO(("Unknown PHY device.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if (!(phyInfo.flag & GT_PHY_GIGABIT))
+        {
+            DBG_INFO(("Not Supported\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_BAD_PARAM;
+        }
+
+    }
+
+     if ((retVal=mdCopperGetAutoNeg(&(dev->mad_dev), hwPort, &autoNegoEn, &autoMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdCopperSetAutoNeg Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (state==GT_TRUE)
+      autoMode |= MAD_AUTO_AD_ASYM_PAUSE;
+    else
+      autoMode &= ~MAD_AUTO_AD_ASYM_PAUSE;
+
+
+     if ((retVal=mdCopperSetAutoNeg(&(dev->mad_dev), hwPort, autoNegoEn, autoMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdCopperSetAutoNeg Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetDTEDetect_mad
+*
+* DESCRIPTION:
+*       This routine enables/disables DTE.
+*
+* INPUTS:
+*         port - The logical port number
+*         mode - either GT_TRUE(for enable) or GT_FALSE(for disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetect_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    MAD_BOOL            en;
+
+    DBG_INFO(("phySetDTE_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (state==GT_TRUE)
+      en = MAD_TRUE;
+    else
+      en = MAD_FALSE;
+
+    if(mdCopperSetDTEDetectEnable(&(dev->mad_dev),hwPort,en,0) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectStatus_mad
+*
+* DESCRIPTION:
+*       This routine gets DTE status.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       status - GT_TRUE, if link partner needs DTE power.
+*                 GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectStatus_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    MAD_BOOL    en;
+    MAD_U16     dropHys;
+
+    DBG_INFO(("gprtGetDTEStatus_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGetDTEDetectEnable(&(dev->mad_dev),hwPort,&en,&dropHys) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+
+     if (en==MAD_TRUE)
+      *state = GT_TRUE;
+    else
+      *state = GT_FALSE;
+
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDTEDetectDropWait_mad
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*        will wait a period of time before clearing the power over Ethernet
+*        detection status bit. The wait time is 5 seconds multiplied by the
+*        given value.
+*
+* INPUTS:
+*         port - The logical port number
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetectDropWait_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_U16    waitTime
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    MAD_BOOL    en;
+    MAD_U16     dropHys;
+
+
+    DBG_INFO(("gprtSetDTEDropWait_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGetDTEDetectEnable(&(dev->mad_dev),hwPort,&en,&dropHys) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    dropHys = waitTime;
+    if(mdCopperSetDTEDetectEnable(&(dev->mad_dev),hwPort,en,dropHys) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectDropWait_mad
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*        will wait a period of time before clearing the power over Ethernet
+*        detection status bit. The wait time is 5 seconds multiplied by the
+*        returned value.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectDropWait_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_U16    *waitTime
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    MAD_BOOL    en;
+    MAD_U16     dropHys;
+
+    DBG_INFO(("gprtSetDTEDropWait_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGetDTEDetectEnable(&(dev->mad_dev),hwPort,&en,&dropHys) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *waitTime = dropHys;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetEnergyDetect_mad
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*       mode - GT_EDETECT_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetEnergyDetect_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gprtSetEnergyDetect_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (phyInfo.flag & GT_PHY_SERDES_CORE)
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+    else if (phyInfo.flag & GT_PHY_GIGABIT)
+    {
+        /* check if the mode is valid */
+        switch (mode)
+        {
+            case GT_EDETECT_OFF:
+                u16Data = 0;
+                break;
+            case GT_EDETECT_SENSE_PULSE:
+                u16Data = 3;
+                break;
+            case GT_EDETECT_SENSE:
+                u16Data = 2;
+                break;
+            default:
+                DBG_INFO(("Invalid paramerter.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+        }
+    }
+    else    /* it's a Fast Ethernet device */
+    {
+        /* check if the mode is valid */
+        switch (mode)
+        {
+            case GT_EDETECT_OFF:
+                u16Data = 0;
+                break;
+            case GT_EDETECT_SENSE_PULSE:
+                u16Data = 1;
+                break;
+            case GT_EDETECT_SENSE:
+            default:
+                DBG_INFO(("Invalid paramerter.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+        }
+
+    }
+
+    if(mdSysSetDetectPowerDownMode(&(dev->mad_dev),hwPort,u16Data) != MAD_OK)
+    {
+        DBG_INFO(("Call mdSysSetDetectPowerDownMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetEnergyDetect_mad
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       mode - GT_EDETECT_MODE type
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetEnergyDetect_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gprtGetEnergyDetect_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(mdSysGetDetectPowerDownMode(&(dev->mad_dev),hwPort,&u16Data) != MAD_OK)
+    {
+        DBG_INFO(("Call mdSysSetDetectPowerDownMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (phyInfo.flag & GT_PHY_SERDES_CORE)
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+    else if (phyInfo.flag & GT_PHY_GIGABIT)
+    {
+        /* read the mode */
+
+        switch (u16Data)
+        {
+            case 0:
+            case 1:
+                *mode = GT_EDETECT_OFF;
+                break;
+            case 2:
+                *mode = GT_EDETECT_SENSE;
+                break;
+            case 3:
+                *mode = GT_EDETECT_SENSE_PULSE;
+                break;
+            default:
+                DBG_INFO(("Unknown value (should not happen).\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+        }
+
+    }
+    else    /* it's a Fast Ethernet device */
+    {
+        switch (u16Data)
+        {
+            case 0:
+                *mode = GT_EDETECT_OFF;
+                break;
+            case 1:
+                *mode = GT_EDETECT_SENSE_PULSE;
+                break;
+            default:
+                DBG_INFO(("Unknown value (shouldn not happen).\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+        }
+
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSet1000TMasterMode_mad
+*
+* DESCRIPTION:
+*       This routine sets the ports 1000Base-T Master mode and restart the Auto
+*        negotiation.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode_mad
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_1000T_MASTER_SLAVE   *mode
+)
+{
+    GT_U8            hwPort;         /* the physical port number     */
+    GT_PHY_INFO    phyInfo;
+    MAD_1000T_MASTER_SLAVE    msmode
+
+    DBG_INFO(("gprtSet1000TMasterMode_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    msmode.autoConfig = mode->autoConfig;
+    msmode.masterPrefer = mode->masterPrefer;
+
+    if(mdCopperSet1000TMasterMode(&(dev->mad_dev),hwPort,&msmode) != MAD_OK)
+    {
+        DBG_INFO(("Call mdSysSetDetectPowerDownMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGet1000TMasterMode_mad
+*
+* DESCRIPTION:
+*       This routine retrieves 1000Base-T Master Mode
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode_mad
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_1000T_MASTER_SLAVE   *mode
+)
+{
+    GT_U8            hwPort;         /* the physical port number     */
+    GT_PHY_INFO    phyInfo;
+    MAD_1000T_MASTER_SLAVE    msmode
+
+    DBG_INFO(("gprtGet1000TMasterMode_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGet1000TMasterMode(&(dev->mad_dev),hwPort,&msmode) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperGet1000TMasterMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+    mode->autoConfig = msmode.autoConfig;
+    mode->masterPrefer = msmode.masterPrefer;
+
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtGetPhyLinkStatus_mad
+*
+* DESCRIPTION:
+*       This routine retrieves the Link status.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       linkStatus - GT_FALSE if link is not established,
+*                     GT_TRUE if link is established.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyLinkStatus_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
+)
+{
+
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    OUT MAD_BOOL    linkOn;
+
+    DBG_INFO(("gprtGetPhyLinkStatus_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+         return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGetLinkStatus(&(dev->mad_dev),hwPort,&linkOn) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperGetLinkStatus failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *linkStatus = (linkOn==MAD_TRUE)?GT_TRUE:GT_FAIL;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetPktGenEnable_mad
+*
+* DESCRIPTION:
+*       This routine enables or disables Packet Generator.
+*       Link should be established first prior to enabling the packet generator,
+*       and generator will generate packets at the speed of the established link.
+*        When enables packet generator, the following information should be
+*       provided:
+*           Payload Type:  either Random or 5AA55AA5
+*           Packet Length: either 64 or 1514 bytes
+*           Error Packet:  either Error packet or normal packet
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*       en      - GT_TRUE to enable, GT_FALSE to disable
+*       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
+*                 ignored, if en is GT_FALSE
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPktGenEnable_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   en,
+    IN GT_PG     *pktInfo
+)
+{
+
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    MAD_U32   men;
+    MAD_PG    mpktInfo;
+
+    DBG_INFO(("gprtSetPktGenEnable_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(!(phyInfo.flag & GT_PHY_PKT_GENERATOR))
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    mpktInfo.payload = pktInfo->payload;
+    mpktInfo.length = pktInfo->length;
+    mpktInfo.tx = pktInfo->tx;
+    if (en==GT_TRUE)
+    {
+      men =1;
+      mpktInfo.en_type = MAD_PG_EN_COPPER;
+    }
+    else
+    {
+      men =0;
+      mpktInfo.en_type = MAD_PG_DISABLE;
+    }
+
+    if(mdDiagSetPktGenEnable(&(dev->mad_dev),hwPort, men, &mpktInfo) != MAD_OK)
+    {
+        DBG_INFO(("Call mdSysSetDetectPowerDownMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPhyReg_mad
+*
+* DESCRIPTION:
+*       This routine reads Phy Registers.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyReg_mad
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+)
+{
+    MAD_U32          u32Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPhyReg_mad Called.\n"));
+
+    hwPort = GT_LPORT_2_PHY(port);
+    /* hwPort = port; */
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Get Phy Register. */
+    if(mdSysGetPhyReg(&(dev->mad_dev),hwPort,regAddr,&u32Data) != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *data = u32Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPhyReg_mad
+*
+* DESCRIPTION:
+*       This routine writes Phy Registers.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPhyReg_mad
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            inData
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_U32        data = inData;
+
+    DBG_INFO(("gprtSetPhyReg_mad Called.\n"));
+
+    hwPort = GT_LPORT_2_PHY(port);
+    /* hwPort = port;  */
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Write to Phy Register */
+    if(mdSysSetPhyReg(&(dev->mad_dev),hwPort,regAddr,data) != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPagedPhyReg_mad
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*
+* OUTPUTS:
+*        data    - value of the read register
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtGetPagedPhyReg_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
+    OUT GT_U16* data
+)
+{
+    GT_PHY_INFO        phyInfo;
+    GT_U8            hwPort;
+    MAD_U32        u32Data;
+
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(mdSysGetPagedPhyReg(&(dev->mad_dev),hwPort,page, regAddr,&u32Data) != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *data = u32Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPagedPhyReg_mad
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*        data    - value of the read register
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtSetPagedPhyReg_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
+    IN  GT_U16 inData
+)
+{
+    GT_PHY_INFO        phyInfo;
+    GT_U8            hwPort;
+    MAD_U32 data = inData;
+
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(mdSysSetPagedPhyReg(&(dev->mad_dev),hwPort,page, regAddr, data) != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyInt.c
@@ -0,0 +1,301 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPhyInt.h
+*
+* DESCRIPTION:
+* API definitions for PHY interrupt handling
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 10 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+#include <gtDrvConfig.h>
+
+#ifdef GT_USE_MAD
+#include <gtMad.h>
+#endif
+
+#ifdef GT_USE_MAD
+#include "gtPhyInt_mad.c"
+#endif
+/*******************************************************************************
+* gprtPhyIntEnable
+*
+* DESCRIPTION:
+* Enable/Disable one PHY Interrupt
+* This register determines whether the INT# pin is asserted when an interrupt
+* event occurs. When an interrupt occurs, the corresponding bit is set and
+* remains set until register 19 is read via the SMI. When interrupt enable
+* bits are not set in register 18, interrupt status bits in register 19 are
+* still set when the corresponding interrupt events occur. However, the INT#
+* is not asserted.
+*
+* INPUTS:
+* port -   The logical port number, unless SERDES device is accessed
+*          The physical address, if SERDES device is accessed
+* intType - the type of interrupt to enable/disable. any combination of
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,    ( Copper only )
+*            GT_DOWNSHIFT_DETECT,    ( for 1000M Copper only )
+*            GT_ENERGY_DETECT,        ( for 1000M Copper only )
+*            GT_POLARITY_CHANGED, and ( Copper only )
+*            GT_JABBER                (Copper only )
+*
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* For 88E6131, 88E6122, and 88E6108 devices, Serdes port can be accessed using
+* logical port number.
+* For 88E6161 88E6165 and 88E6352 devices, Serdes port 5 (address 0xD/0xF) can be accessed
+* using logical port number, but not port 4 (since port 4 could be an internal
+* PHY.)
+*******************************************************************************/
+
+
+GT_STATUS gprtPhyIntEnable
+(
+IN GT_QD_DEV    *dev,
+IN GT_LPORT    port,
+IN GT_U16    intType
+)
+{
+    GT_STATUS       retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+
+/*
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtPhyIntEnable_mad(dev, port, intType);
+#endif
+*/
+    DBG_INFO(("gprtPhyIntEnable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
+    {
+        if(!(dev->validSerdesVec & (1 << hwPort)))
+        {
+            if(!((IS_IN_DEV_GROUP(dev,DEV_SERDES_ACCESS_CONFIG)) && (hwPort == 4)))
+                GT_GET_SERDES_PORT(dev,&hwPort);
+        }
+        if(hwPort >= dev->maxPhyNum)
+        {
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwWritePhyReg(dev,hwPort, QD_PHY_INT_ENABLE_REG, intType);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+
+}
+
+/*******************************************************************************
+* gprtGetPhyIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of interrupt occured
+*
+* INPUTS:
+* port -   The logical port number, unless SERDES device is accessed
+*          The physical address, if SERDES device is accessed
+* intType - the type of interrupt which causes an interrupt.
+*            any combination of
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,    ( Copper only )
+*            GT_DOWNSHIFT_DETECT,    ( for 1000M Copper only )
+*            GT_ENERGY_DETECT,        ( for 1000M Copper only )
+*            GT_POLARITY_CHANGED, and ( Copper only )
+*            GT_JABBER                (Copper only )
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* For 88E6131, 88E6122, and 88E6108 devices, Serdes port can be accessed using
+* logical port number.
+* For 88E6161 88E6165 and 88E6352 devices, Serdes port 5 (address 0xD/0xF) can be accessed
+* using logical port number, but not port 4 (since port 4 could be an internal
+* PHY.)
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntStatus
+(
+IN   GT_QD_DEV  *dev,
+IN   GT_LPORT   port,
+OUT  GT_U16*    intType
+)
+{
+    GT_STATUS       retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetPhyIntStatus_mad(dev, port, intType);
+#endif
+
+    DBG_INFO(("gprtGetPhyIntStatus Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+    if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
+    {
+        if(!(dev->validSerdesVec & (1 << hwPort)))
+        {
+            if(!((IS_IN_DEV_GROUP(dev,DEV_SERDES_ACCESS_CONFIG)) && (hwPort == 4)))
+                GT_GET_SERDES_PORT(dev,&hwPort);
+        }
+        if(hwPort >= dev->maxPhyNum)
+        {
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_STATUS_REG, intType);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPhyIntPortSummary
+*
+* DESCRIPTION:
+* Lists the ports that have active interrupts. It provides a quick way to
+* isolate the interrupt so that the MAC or switch does not have to poll the
+* interrupt status register (19) for all ports. Reading this register does not
+* de-assert the INT# pin
+*
+* INPUTS:
+* none
+*
+* OUTPUTS:
+* GT_U8 *intPortMask - bit Mask with the bits set for the corresponding
+* phys with active interrupt. E.g., the bit number 0 and 2 are set when
+* port number 0 and 2 have active interrupt
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 20
+* For 88E6165, 88E6375 devices, geventGetDevIntStatus should be used instead.
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntPortSummary
+(
+IN  GT_QD_DEV  *dev,
+OUT GT_U16     *intPortMask
+)
+{
+    GT_STATUS       retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16            portVec;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetPhyIntPortSummary_mad(dev, intPortMask);
+#endif
+
+    DBG_INFO(("gprtGetPhyIntPortSummary Called.\n"));
+
+    /* translate LPORT 0 to hardware port */
+    hwPort = GT_LPORT_2_PORT(0);
+
+    *intPortMask=0;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DEV_PHY_INTERRUPT))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_INTERNAL_GPHY))
+    {
+        /* get the interrupt port summary from global register */
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PHYINT_SOURCE,0,dev->maxPorts,&portVec);
+        GT_GIG_PHY_INT_MASK(dev,portVec);
+        *intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
+    }
+    else
+    {
+        /* get the interrupt port summary from phy */
+        retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_PORT_SUMMARY_REG, &portVec);
+        *intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPhyInt_mad.c
@@ -0,0 +1,272 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPhyInt.h
+*
+* DESCRIPTION:
+* API definitions for PHY interrupt handling
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 10 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+#include <gtDrvConfig.h>
+#include "madApi.h"
+
+/*******************************************************************************
+* gprtPhyIntEnable_mad
+*
+* DESCRIPTION:
+* Enable/Disable one PHY Interrupt
+* This register determines whether the INT# pin is asserted when an interrupt
+* event occurs. When an interrupt occurs, the corresponding bit is set and
+* remains set until register 19 is read via the SMI. When interrupt enable
+* bits are not set in register 18, interrupt status bits in register 19 are
+* still set when the corresponding interrupt events occur. However, the INT#
+* is not asserted.
+*
+* INPUTS:
+* port -   The logical port number, unless SERDES device is accessed
+*          The physical address, if SERDES device is accessed
+* intType - the type of interrupt to enable/disable. any combination of
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,    ( Copper only )
+*            GT_DOWNSHIFT_DETECT,    ( for 1000M Copper only )
+*            GT_ENERGY_DETECT,        ( for 1000M Copper only )
+*            GT_POLARITY_CHANGED, and ( Copper only )
+*            GT_JABBER                (Copper only )
+*
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* For 88E6131, 88E6122, and 88E6108 devices, Serdes port can be accessed using
+* logical port number.
+* For 88E6161 88E6165 and 88E6352 devices, Serdes port 5 (address 0xD/0xF) can be accessed
+* using logical port number, but not port 4 (since port 4 could be an internal
+* PHY.)
+*******************************************************************************/
+
+
+GT_STATUS gprtPhyIntEnable_mad
+(
+IN GT_QD_DEV    *dev,
+IN GT_LPORT    port,
+IN GT_U16    intType
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_INT_TYPE    mintType;
+
+    DBG_INFO(("gprtPhyIntEnable_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
+    {
+        if(!(dev->validSerdesVec & (1 << hwPort)))
+        {
+            if(!((IS_IN_DEV_GROUP(dev,DEV_SERDES_ACCESS_CONFIG)) && (hwPort == 4)))
+                GT_GET_SERDES_PORT(dev,&hwPort);
+        }
+        if(hwPort >= dev->maxPhyNum)
+        {
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    mintType.intGroup0 = 0;
+    mintType.intGroup1 = 0;
+    mintType.intGroup0 = intType;
+    if(mdIntSetEnable(&(dev->mad_dev),hwPort,&mintType) != MAD_OK)
+    {
+        DBG_INFO(("Call mdIntSetEnable failed.\n"));
+        return GT_FAIL;
+    }
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gprtGetPhyIntStatus_mad
+*
+* DESCRIPTION:
+* Check to see if a specific type of interrupt occured
+*
+* INPUTS:
+* port -   The logical port number, unless SERDES device is accessed
+*          The physical address, if SERDES device is accessed
+* intType - the type of interrupt which causes an interrupt.
+*            any combination of
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,    ( Copper only )
+*            GT_DOWNSHIFT_DETECT,    ( for 1000M Copper only )
+*            GT_ENERGY_DETECT,        ( for 1000M Copper only )
+*            GT_POLARITY_CHANGED, and ( Copper only )
+*            GT_JABBER                (Copper only )
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* For 88E6131, 88E6122, and 88E6108 devices, Serdes port can be accessed using
+* logical port number.
+* For 88E6161 88E6165 and 88E6352 devices, Serdes port 5 (address 0xD/0xF) can be accessed
+* using logical port number, but not port 4 (since port 4 could be an internal
+* PHY.)
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntStatus_mad
+(
+IN   GT_QD_DEV  *dev,
+IN   GT_LPORT   port,
+OUT  GT_U16*    intType
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_INT_TYPE    mintType;
+
+    DBG_INFO(("gprtGetPhyIntStatus_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+    if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
+    {
+        if(!(dev->validSerdesVec & (1 << hwPort)))
+        {
+            if(!((IS_IN_DEV_GROUP(dev,DEV_SERDES_ACCESS_CONFIG)) && (hwPort == 4)))
+                GT_GET_SERDES_PORT(dev,&hwPort);
+        }
+        if(hwPort >= dev->maxPhyNum)
+        {
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdIntGetStatus(&(dev->mad_dev),hwPort,&mintType) != MAD_OK)
+    {
+        DBG_INFO(("Call mdIntGetStatus failed.\n"));
+        return GT_FAIL;
+    }
+
+    *intType = mintType.intGroup0;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtGetPhyIntPortSummary_mad
+*
+* DESCRIPTION:
+* Lists the ports that have active interrupts. It provides a quick way to
+* isolate the interrupt so that the MAC or switch does not have to poll the
+* interrupt status register (19) for all ports. Reading this register does not
+* de-assert the INT# pin
+*
+* INPUTS:
+* none
+*
+* OUTPUTS:
+* GT_U8 *intPortMask - bit Mask with the bits set for the corresponding
+* phys with active interrupt. E.g., the bit number 0 and 2 are set when
+* port number 0 and 2 have active interrupt
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 20
+* For 88E6165, 88E6375 devices, geventGetDevIntStatus should be used instead.
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntPortSummary_mad
+(
+IN  GT_QD_DEV  *dev,
+OUT GT_U16     *intPortMask
+)
+{
+    GT_STATUS       retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          portVec;
+    MAD_U32         mportVec;
+
+    DBG_INFO(("gprtGetPhyIntPortSummary_mad Called.\n"));
+
+    /* translate LPORT 0 to hardware port */
+    hwPort = GT_LPORT_2_PORT(0);
+
+    *intPortMask=0;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DEV_PHY_INTERRUPT))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_INTERNAL_GPHY))
+    {
+        /* get the interrupt port summary from global register */
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PHYINT_SOURCE,0,dev->maxPorts,&portVec);
+        GT_GIG_PHY_INT_MASK(dev,portVec);
+        *intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
+    }
+    else
+    {
+        /* get the interrupt port summary from phy */
+      if(mdIntGetPortSummary(&(dev->mad_dev), &mportVec) != MAD_OK)
+      {
+        DBG_INFO(("Call mdIntGetPortSummary failed.\n"));
+        return GT_FAIL;
+      }
+      portVec = mportVec;
+      *intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
+    }
+
+    return GT_OK;
+
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPolicy.c
@@ -0,0 +1,279 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPolicy.c
+*
+* DESCRIPTION:
+*       API definitions to handle Policy Mapping
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gprtSetPolicy
+*
+* DESCRIPTION:
+*       This routine sets the Policy for ports.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*
+* INPUTS:
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*       policy     - policy (GT_FRAME_POLICY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*       GT_BAD_PARAM     - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    IN    GT_FRAME_POLICY    policy
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* Physical port.               */
+    GT_U8            offset;
+
+    DBG_INFO(("gprtSetPolicy Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (policy)
+    {
+        case FRAME_POLICY_NONE:
+        case FRAME_POLICY_MIRROR:
+        case FRAME_POLICY_TRAP:
+        case FRAME_POLICY_DISCARD:
+            break;
+        default:
+            DBG_INFO(("Bad Policy\n"));
+            return GT_BAD_PARAM;
+    }
+
+    switch (type)
+    {
+        case POLICY_TYPE_DA:
+            offset = 14;
+            break;
+        case POLICY_TYPE_SA:
+            offset = 12;
+            break;
+        case POLICY_TYPE_VTU:
+            offset = 10;
+            break;
+        case POLICY_TYPE_ETYPE:
+            offset = 8;
+            break;
+        case POLICY_TYPE_PPPoE:
+            offset = 6;
+            break;
+        case POLICY_TYPE_VBAS:
+            offset = 4;
+            break;
+        case POLICY_TYPE_OPT82:
+            if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+            {
+              DBG_INFO(("GT_NOT_SUPPORTED\n"));
+              return GT_NOT_SUPPORTED;
+            }
+            else
+              offset = 2;
+            break;
+        case POLICY_TYPE_UDP:
+            offset = 0;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_POLICY_CONTROL, offset, 2, (GT_U16)policy);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGetPolicy
+*
+* DESCRIPTION:
+*       This routine gets the Policy of the given policy type.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*
+* INPUTS:
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*
+* OUTPUTS:
+*       policy     - policy (GT_FRAME_POLICY)
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*       GT_BAD_PARAM     - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPolicy
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    OUT GT_FRAME_POLICY    *policy
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* Physical port.               */
+    GT_U8            offset;
+    GT_U16            data;
+
+    DBG_INFO(("gprtGetPolicy Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (type)
+    {
+        case POLICY_TYPE_DA:
+            offset = 14;
+            break;
+        case POLICY_TYPE_SA:
+            offset = 12;
+            break;
+        case POLICY_TYPE_VTU:
+            offset = 10;
+            break;
+        case POLICY_TYPE_ETYPE:
+            offset = 8;
+            break;
+        case POLICY_TYPE_PPPoE:
+            offset = 6;
+            break;
+        case POLICY_TYPE_VBAS:
+            offset = 4;
+            break;
+        case POLICY_TYPE_OPT82:
+            offset = 2;
+            break;
+        case POLICY_TYPE_UDP:
+            offset = 0;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_POLICY_CONTROL, offset, 2, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *policy = (GT_FRAME_POLICY)data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortCtrl.c
@@ -0,0 +1,7195 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPortCtrl.c
+*
+* DESCRIPTION:
+*       API implementation for switch port control.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+#include <gtSem.h>
+
+/*******************************************************************************
+* gprtSetForceFc
+*
+* DESCRIPTION:
+*       This routine set the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetForceFc
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    force
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PORT_STP_STATE  state;
+
+    DBG_INFO(("gprtSetForceFc Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        if(force)
+            data = 3;
+        else
+            data = 0;
+
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+        }
+        else
+        {
+            DBG_INFO(("OK.\n"));
+        }
+        return retVal;
+    }
+
+    /* Port should be disabled before Set Force Flow Control bit */
+    retVal = gstpGetPortState(dev,port, &state);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("gstpGetPortState failed.\n"));
+        return retVal;
+    }
+
+    retVal = gstpSetPortState(dev,port, GT_PORT_DISABLE);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("gstpSetPortState failed.\n"));
+        return retVal;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(force, data);
+
+    /* Set the force flow control bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* Restore original stp state. */
+    if(gstpSetPortState(dev,port, state) != GT_OK)
+    {
+        DBG_INFO(("gstpSetPortState failed.\n"));
+        return GT_FAIL;
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetForceFc
+*
+* DESCRIPTION:
+*       This routine get the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetForceFc
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *force
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetForceFc Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+        }
+        else
+        {
+            DBG_INFO(("OK.\n"));
+        }
+
+        if(data & 0x1)
+            *force = GT_TRUE;
+        else
+            *force = GT_FALSE;
+
+        return retVal;
+    }
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *force);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetUseCoreTag
+*
+* DESCRIPTION:
+*        This routine set the UseCoreTag bit in Port Control Register.
+*        When this bit is cleared to a zero, ingressing frames are considered
+*        Tagged if the 16-bits following the frame's Source Address is 0x8100.
+*        When this bit is set to a one, ingressing frames are considered Tagged
+*        if the 16-bits following the frame's Source Address is equal to the
+*        CoreTag register value.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetUseCoreTag
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    force
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetUseCoreTag Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(force, data);
+
+    /* Set the UseCoreTag bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetUseCoreTag
+*
+* DESCRIPTION:
+*       This routine get the Use Core Tag state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetUseCoreTag
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *force
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetUseCoreTag Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the UseCoreTag bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *force);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetTrailerMode
+*
+* DESCRIPTION:
+*       This routine set the egress trailer mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetTrailerMode
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetTrailerMode Called.\n"));
+
+    /* check if device supports this feature */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRAILER)) ||
+          (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+          (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if(hwPort < 4)
+    {
+        /* check if device supports this feature for this port */
+        if ((IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5)))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+    else if(hwPort == 4)
+    {
+        /* check if device supports this feature for this port*/
+        if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* Set the trailer mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetTrailerMode
+*
+* DESCRIPTION:
+*       This routine get the egress trailer mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTrailerMode
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetTrailerMode Called.\n"));
+
+    /* check if device supports this feature */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRAILER)) ||
+          (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+          (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if(hwPort < 4)
+    {
+        /* check if device supports this feature for this port */
+        if ((IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5)))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+    else if(hwPort == 4)
+    {
+        /* check if device supports this feature for this port */
+        if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* Get the Trailer mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gprtSetIngressMode
+*
+* DESCRIPTION:
+*       This routine set the ingress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIngressMode
+(
+    IN  GT_QD_DEV      *dev,
+    IN GT_LPORT        port,
+    IN GT_INGRESS_MODE mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIngressMode Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Gigabit Switch does not support this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if device supports this feature */
+    switch (mode)
+    {
+        case (GT_UNMODIFY_INGRESS):
+            break;
+
+        case (GT_TRAILER_INGRESS):
+            if (!((IS_IN_DEV_GROUP(dev,DEV_TRAILER)) ||
+                  (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+                  (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5))))
+     {
+                DBG_INFO(("Given ingress mode is not supported by this device\n"));
+                return GT_NOT_SUPPORTED;
+            }
+            break;
+
+        case (GT_UNTAGGED_INGRESS):
+            if(!(IS_IN_DEV_GROUP(dev,DEV_TAGGING)))
+            {
+                DBG_INFO(("Given ingress mode is not supported by this device\n"));
+                return GT_NOT_SUPPORTED;
+            }
+            break;
+
+        case (GT_CPUPORT_INGRESS):
+            if(!(IS_IN_DEV_GROUP(dev,DEV_IGMP_SNOOPING)))
+            {
+                DBG_INFO(("Given ingress mode is not supported by this device\n"));
+                return GT_NOT_SUPPORTED;
+            }
+
+            if(hwPort != GT_LPORT_2_PORT(dev->cpuPortNum))
+            {
+                DBG_INFO(("Given ingress mode is supported by CPU port only\n"));
+                return GT_NOT_SUPPORTED;
+            }
+
+            break;
+
+        default:
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+    }
+
+    /* Set the Ingress Mode.        */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,2,(GT_U16)mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetIngressMode
+*
+* DESCRIPTION:
+*       This routine get the ingress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the ingress mode.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIngressMode
+(
+    IN  GT_QD_DEV      *dev,
+    IN  GT_LPORT        port,
+    OUT GT_INGRESS_MODE *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIngressMode Called.\n"));
+
+    /* Gigabit Switch does not support this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the Ingress Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 2,&data);
+    *mode = data;
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine set the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMcRateLimit
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_MC_RATE   rate
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetMcRateLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* this feature only exits in 6051, 6052, and 6012. It is replace with
+     * Rate Cotrol Register in the future products, starting from clippership
+     */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MC_RATE_PERCENT)) != GT_OK)
+        return retVal;
+
+    /* Set the multicast rate limit.    */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,2,(GT_U16)rate);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine Get the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMcRateLimit
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_MC_RATE  *rate
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read data        */
+
+    DBG_INFO(("gprtGetMcRateLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* this feature only exits in 6051, 6052, and 6012. It is replace with
+     * Rate Cotrol Register in the future products, starting from clippership
+     */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MC_RATE_PERCENT)) != GT_OK)
+        return retVal;
+
+    /* Get the multicast rate limit.    */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 2, 2,&data);
+    *rate = data;
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/* the following two APIs are added to support fullsail and clippership */
+
+/*******************************************************************************
+* gprtSetIGMPSnoop
+*
+* DESCRIPTION:
+*         This routine set the IGMP Snoop. When set to one and this port receives
+*        IGMP frame, the frame is switched to the CPU port, overriding all other
+*        switching decisions, with exception for CPU's Trailer.
+*        CPU port is determined by the Ingress Mode bits. A port is considered
+*        the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or
+*        GT_CPUPORT_INGRESS.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIGMPSnoop
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIGMPSnoop Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_IGMP_SNOOPING)) != GT_OK)
+      return retVal;
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the IGMP Snooping mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,10,1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetIGMPSnoop
+*
+* DESCRIPTION:
+*       This routine get the IGMP Snoop mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: IGMP Snoop enabled
+*           GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIGMPSnoop
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIGMPSnoop Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_IGMP_SNOOPING)) != GT_OK)
+      return retVal;
+
+    /* Get the Ingress Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 10, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/* the following two APIs are added to support clippership */
+
+/*******************************************************************************
+* gprtSetHeaderMode
+*
+* DESCRIPTION:
+*       This routine set ingress and egress header mode of a switch port.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for header mode  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetHeaderMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetHeaderMode Called.\n"));
+
+    /* only devices beyond quarterdeck (6052) has this feature */
+    /* Fullsail (DEV_QD_88E6502) is an exception, and does not support this feature */
+    if(IS_VALID_API_CALL(dev,port, DEV_HEADER|DEV_HEADER_P5|DEV_HEADER_P4P5) != GT_OK)
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if(hwPort < 4)
+    {
+        if ((IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5)))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+    else if(hwPort == 4)
+    {
+        if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* Set the header mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,11,1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetHeaderMode
+*
+* DESCRIPTION:
+*       This routine gets ingress and egress header mode of a switch port.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: header mode enabled
+*           GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHeaderMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetHeaderMode Called.\n"));
+
+    /* only devices beyond quarterdeck (6052) has this feature */
+    /* Fullsail (DEV_QD_88E602) is an exception, and does not support this feature */
+    if(IS_VALID_API_CALL(dev,port, DEV_HEADER|DEV_HEADER_P5|DEV_HEADER_P4P5) != GT_OK)
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if(hwPort < 4)
+    {
+        if ((IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5)))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+    else if(hwPort == 4)
+    {
+        if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* Get the Header Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 11, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/* the following four APIs are added to support Octane */
+
+/*******************************************************************************
+* gprtSetProtectedMode
+*
+* DESCRIPTION:
+*       This routine set protected mode of a switch port.
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetProtectedMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetProtectedMode Called.\n"));
+
+    /* Check if this feature is supported */
+    if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the protected mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,3,1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetProtectedMode
+*
+* DESCRIPTION:
+*       This routine gets protected mode of a switch port.
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: header mode enabled
+*           GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetProtectedMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetProtectedMode Called.\n"));
+
+    if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the protected Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetForwardUnknown
+*
+* DESCRIPTION:
+*       This routine set Forward Unknown mode of a switch port.
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetForwardUnknown
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetForwardUnknown Called.\n"));
+
+    if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY|DEV_EGRESS_FLOOD) != GT_OK)
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the forward unknown mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetForwardUnknown
+*
+* DESCRIPTION:
+*       This routine gets Forward Unknown mode of a switch port.
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: header mode enabled
+*           GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetForwardUnknown
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetForwardUnknown Called.\n"));
+
+    if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY|DEV_EGRESS_FLOOD) != GT_OK)
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the forward unknown Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 2, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDropOnLock
+*
+* DESCRIPTION:
+*        This routine set the Drop on Lock. When set to one, Ingress frames will
+*        be discarded if their SA field is not in the ATU's address database.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDropOnLock
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDropOnLock Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the DropOnLock mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetDropOnLock
+*
+* DESCRIPTION:
+*        This routine gets DropOnLock mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: DropOnLock enabled,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDropOnLock
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDropOnLock Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DropOnLock Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 14, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetDoubleTag
+*
+* DESCRIPTION:
+*        This routine set the Ingress Double Tag Mode. When set to one,
+*        ingressing frames are examined to see if they contain an 802.3ac tag.
+*        If they do, the tag is removed and then the frame is processed from
+*        there (i.e., removed tag is ignored). Essentially, untagged frames
+*        remain untagged, single tagged frames become untagged and double tagged
+*        frames become single tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDoubleTag
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDoubleTag Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the DoubleTag mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,9,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetDoubleTag
+*
+* DESCRIPTION:
+*        This routine gets DoubleTag mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: DoubleTag enabled,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDoubleTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDoubleTag Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DoubleTag Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 9, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetInterswitchPort
+*
+* DESCRIPTION:
+*        This routine set Interswitch Port. When set to one,
+*        it indicates this port is a interswitch port used to communicated with
+*        CPU or to cascade with another switch device.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetInterswitchPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetInterswitchPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the InterswitchPort.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetInterswithPort
+*
+* DESCRIPTION:
+*        This routine gets InterswitchPort.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: This port is interswitch port,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetInterswitchPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetInterswitchPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the InterswitchPort Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetLearnDisable
+*
+* DESCRIPTION:
+*        This routine enables/disables automatic learning of new source MAC
+*        addresses on the given port ingress
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for disable or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLearnDisable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetLearnDisable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the LearnDisable mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,11,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetLearnDisable
+*
+* DESCRIPTION:
+*        This routine gets LearnDisable setup
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: Learning disabled on the given port ingress frames,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLearnDisable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetLearnDisable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the LearnDisable Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 11, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetIgnoreFCS
+*
+* DESCRIPTION:
+*        This routine sets FCS Ignore mode. When this bit is set to a one,
+*        the last four bytes of frames received on this port are overwritten with
+*        a good CRC and the frames will be accepted by the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreFCS
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL         mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIgnoreFCS Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!(IS_IN_DEV_GROUP(dev, DEV_IGNORE_FCS)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the IgnoreFCS mode.            */
+    if ((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,data );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,10,1,data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetIgnoreFCS
+*
+* DESCRIPTION:
+*        This routine gets Ignore FCS setup
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreFCS
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIgnoreFCS Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_IGNORE_FCS)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IgnoreFCS Mode.            */
+    if ((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+    {
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 1, &data);
+    }
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetVTUPriOverride
+*
+* DESCRIPTION:
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtSetVTUPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_PRI_OVERRIDE        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetVTUPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (mode)
+    {
+        case PRI_OVERRIDE_NONE:
+            data = 0;
+            break;
+        case PRI_OVERRIDE_FRAME_QUEUE:
+            if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                data = 3;
+            }
+            else
+            {
+                data = 1;
+            }
+            break;
+        case PRI_OVERRIDE_FRAME:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 1;
+            break;
+        case PRI_OVERRIDE_QUEUE:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 2;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    /* Set the VTUPri Override mode.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,10,2,data);
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetVTUPriOverride
+*
+* DESCRIPTION:
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtGetVTUPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PRI_OVERRIDE        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetVTUPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the VTUPriOverride Mode.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,10,2,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 14, 1, &data);
+        if(data == 1)
+            data = 3;
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    switch (data)
+    {
+        case 0:
+            *mode = PRI_OVERRIDE_NONE;
+            break;
+        case 3:
+            *mode = PRI_OVERRIDE_FRAME_QUEUE;
+            break;
+        case 1:
+            *mode = PRI_OVERRIDE_FRAME;
+            break;
+        case 2:
+            *mode = PRI_OVERRIDE_QUEUE;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetSAPriOverride
+*
+* DESCRIPTION:
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtSetSAPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetSAPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (mode)
+    {
+        case PRI_OVERRIDE_NONE:
+            data = 0;
+            break;
+        case PRI_OVERRIDE_FRAME_QUEUE:
+            if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                data = 3;
+            }
+            else
+            {
+                data = 1;
+            }
+            break;
+        case PRI_OVERRIDE_FRAME:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 1;
+            break;
+        case PRI_OVERRIDE_QUEUE:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 2;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    /* Set the SAPriOverride mode.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,12,2,data);
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetSAPriOverride
+*
+* DESCRIPTION:
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtGetSAPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetSAPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SAPriOverride Mode.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,12,2,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 13, 1, &data);
+        if(data == 1)
+            data = 3;
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    switch (data)
+    {
+        case 0:
+            *mode = PRI_OVERRIDE_NONE;
+            break;
+        case 3:
+            *mode = PRI_OVERRIDE_FRAME_QUEUE;
+            break;
+        case 1:
+            *mode = PRI_OVERRIDE_FRAME;
+            break;
+        case 2:
+            *mode = PRI_OVERRIDE_QUEUE;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetDAPriOverride
+*
+* DESCRIPTION:
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtSetDAPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PRI_OVERRIDE        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDAPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (mode)
+    {
+        case PRI_OVERRIDE_NONE:
+            data = 0;
+            break;
+        case PRI_OVERRIDE_FRAME_QUEUE:
+            if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                data = 3;
+            }
+            else
+            {
+                data = 1;
+            }
+            break;
+        case PRI_OVERRIDE_FRAME:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 1;
+            break;
+        case PRI_OVERRIDE_QUEUE:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 2;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    /* Set the DAPriOverride mode.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,14,2,data);
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDAPriOverride
+*
+* DESCRIPTION:
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_PRI_OVERRIDE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
+*******************************************************************************/
+GT_STATUS gprtGetDAPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDAPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DAPriOverride Mode.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,14,2,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 12, 1, &data);
+        if(data == 1)
+            data = 3;
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    switch (data)
+    {
+        case 0:
+            *mode = PRI_OVERRIDE_NONE;
+            break;
+        case 3:
+            *mode = PRI_OVERRIDE_FRAME_QUEUE;
+            break;
+        case 1:
+            *mode = PRI_OVERRIDE_FRAME;
+            break;
+        case 2:
+            *mode = PRI_OVERRIDE_QUEUE;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetCPUPort
+*
+* DESCRIPTION:
+*        This routine sets CPU Port number. When Snooping is enabled on this port
+*        or when this port is configured as an Interswitch Port and it receives a
+*        To_CPU frame, the switch needs to know what port on this device the frame
+*        should egress.
+*
+* INPUTS:
+*        port - the logical port number.
+*        cpuPort - CPU Port number or interswitch port where CPU Port is connected
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetCPUPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_LPORT     cpuPort
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetCPUPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    data = (GT_U16)GT_LPORT_2_PORT(cpuPort);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set the CPU Port.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,0,4,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetCPUPort
+*
+* DESCRIPTION:
+*        This routine gets CPU Logical Port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        cpuPort - CPU Port's logical number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetCPUPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_LPORT     *cpuLPort
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetCPUPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the CPUPort.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 0, 4, &data);
+
+    *cpuLPort = GT_PORT_2_LPORT((GT_U8)data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetLockedPort
+*
+* DESCRIPTION:
+*        This routine sets LockedPort. When it's set to one, CPU directed
+*        learning for 802.1x MAC authentication is enabled on this port. In this
+*        mode, an ATU Miss Violation interrupt will occur when a new SA address
+*        is received in a frame on this port. Automatically SA learning and
+*        refreshing is disabled in this mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLockedPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetLockedPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_LOCKED_PORT)) )
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Locked Port.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 13, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetLockedPort
+*
+* DESCRIPTION:
+*        This routine gets Locked Port mode for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLockedPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetLockedPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_LOCKED_PORT)) )
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the LockedPort. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 13, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetIgnoreWrongData
+*
+* DESCRIPTION:
+*        This routine sets Ignore Wrong Data. If the frame's SA address is found
+*        in the database and if the entry is 'static' or if the port is 'locked'
+*        the source port's bit is checked to insure the SA has been assigned to
+*        this port. If the SA is NOT assigned to this port, it is considered an
+*        ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+*        Member Violation interrupt will be generated. If it's set to GT_TRUE,
+*        the ATU Member Violation error will be masked and ignored.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreWrongData
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIgnoreWrongData Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_IGNORE_WRONG_DAT)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set IgnoreWrongData.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 12, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetIgnoreWrongData
+*
+* DESCRIPTION:
+*        This routine gets Ignore Wrong Data mode for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreWrongData
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIgnoreWrongData Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_IGNORE_WRONG_DAT)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IgnoreWrongData. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 12, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDiscardTagged
+*
+* DESCRIPTION:
+*        When this bit is set to a one, all non-MGMT frames that are processed as
+*        Tagged will be discarded as they enter this switch port. Priority only
+*        tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardTagged
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDiscardTagged Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_DISCARD_TAGGED)) )
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set DiscardTagged. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 9, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDiscardTagged
+*
+* DESCRIPTION:
+*        This routine gets DiscardTagged bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardTagged
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDiscardTagged Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_DISCARD_TAGGED)) )
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DiscardTagged. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 9, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDiscardUntagged
+*
+* DESCRIPTION:
+*        When this bit is set to a one, all non-MGMT frames that are processed as
+*        Untagged will be discarded as they enter this switch port. Priority only
+*        tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardUntagged
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDiscardUntagged Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_DISCARD_TAGGED)) )
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set DiscardUnTagged. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 8, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDiscardUntagged
+*
+* DESCRIPTION:
+*        This routine gets DiscardUntagged bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardUntagged
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDiscardUnTagged Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_DISCARD_TAGGED)) )
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DiscardUnTagged. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 8, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetMapDA
+*
+* DESCRIPTION:
+*        When this bit is set to a one, normal switch operation will occur where a
+*        frame's DA address is used to direct the frame out the correct port.
+*        When this be is cleared to a zero, the frame will be sent out the port(s)
+*        defined by ForwardUnknown bits or the DefaultForward bits even if the DA
+*        is ound in the address database.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMapDA
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetMapDA Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_MAP_DA)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set MapDA. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 7, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetMapDA
+*
+* DESCRIPTION:
+*        This routine gets MapDA bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMapDA
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetMapDA Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_MAP_DA)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the MapDA. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 7, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDefaultForward
+*
+* DESCRIPTION:
+*        When this bit is set to a one, normal switch operation will occurs and
+*        multicast frames with unknown DA addresses are allowed to egress out this
+*        port (assuming the VLAN settings allow the frame to egress this port too).
+*        When this bit is cleared to a zero, multicast frames with unknown DA
+*        addresses will not egress out this port.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDefaultForward
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDefaultForward Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set DefaultForward. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, data);
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDefaultForward
+*
+* DESCRIPTION:
+*        This routine gets DefaultForward bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDefaultForward
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDefaultForward Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DefaultForward. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, &data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, &data);
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetEgressMonitorSource
+*
+* DESCRIPTION:
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressMonitorSource
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetEgressMonitorSource Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set EgressMonitorSource. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 5, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetEgressMonitorSource
+*
+* DESCRIPTION:
+*        This routine gets EgressMonitorSource bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressMonitorSource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetEgressMonitorSource Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the EgressMonitorSource. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 5, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetIngressMonitorSource
+*
+* DESCRIPTION:
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIngressMonitorSource
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIngressMonitorSource Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set IngressMonitorSource. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 4, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetIngressMonitorSource
+*
+* DESCRIPTION:
+*        This routine gets IngressMonitorSource bit for the given port
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIngressMonitorSource
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIngressMonitorSource Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IngressMonitorSource. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 4, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetMessagePort
+*
+* DESCRIPTION:
+*        When the Learn2All bit is set to one, learning message frames are
+*        generated. These frames will be sent out all ports whose Message Port is
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports,
+*        except for the CPU's port, have their MessagePort bit set to one.
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMessagePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetMessagePort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set IngressMonitorSource. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 15, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetMessagePort
+*
+* DESCRIPTION:
+*        When the Learn2All bit is set to one, learning message frames are
+*        generated. These frames will be sent out all ports whose Message Port is
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports,
+*        except for the CPU's port, have their MessagePort bit set to one.
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMessagePort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetMessagePort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IngressMonitorSource. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 15, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetTrunkPort
+*
+* DESCRIPTION:
+*        This function enables/disables and sets the trunk ID.
+*
+* INPUTS:
+*        port - the logical port number.
+*        en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+*             GT_FALSE, otherwise.
+*        trunkId - valid ID is 0 ~ 15.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetTrunkPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL         en,
+    IN GT_U32        trunkId
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetTrunkPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(en, data);
+
+    if(en == GT_TRUE)
+    {
+        /* need to enable trunk. so check the trunkId */
+        if (!IS_TRUNK_ID_VALID(dev, trunkId))
+        {
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+        }
+
+        /* Set TrunkId. */
+        if (IS_IN_DEV_GROUP(dev,DEV_TRUNK_NEW_ID_LOCATION))
+        {
+            retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 8, 4, (GT_U16)trunkId);
+        }
+        else
+        {
+            retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, (GT_U16)trunkId);
+        }
+
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+    }
+    else
+    {
+        /*
+           Need to reset trunkId for 88E6095 rev0.
+        */
+        if (IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) &&
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            trunkId = 0;
+
+            /* Set TrunkId. */
+            retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, (GT_U16)trunkId);
+            if(retVal != GT_OK)
+            {
+                   DBG_INFO(("Failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    /* Set TrunkPort bit. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 14, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetTrunkPort
+*
+* DESCRIPTION:
+*        This function returns trunk state of the port.
+*        When trunk is disabled, trunkId field won't have valid value.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        en - GT_TRUE, if the port is a member of a trunk,
+*             GT_FALSE, otherwise.
+*        trunkId - 0 ~ 15, valid only if en is GT_TRUE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTrunkPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    OUT GT_BOOL     *en,
+    OUT GT_U32        *trunkId
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetTrunkPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    data = 0;
+
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 14, 1, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TRUNK_NEW_ID_LOCATION))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 8, 4, &data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, &data);
+    }
+
+    *trunkId = (GT_U32)data;
+
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDiscardBCastMode
+*
+* DESCRIPTION:
+*       This routine gets the Discard Broadcast Mode. If the mode is enabled,
+*        all the broadcast frames to the given port will be discarded.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardBCastMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetDiscardBCastMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_DROP_BCAST))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    data = 0;
+
+    retVal = hwGetPortRegField(dev,hwPort, 0x15, 6, 1, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetDiscardBCastMode
+*
+* DESCRIPTION:
+*       This routine sets the Discard Broadcast mode.
+*        If the mode is enabled, all the broadcast frames to the given port will
+*        be discarded.
+*
+* INPUTS:
+*       port - logical port number
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardBCastMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      en
+)
+{
+    GT_U16          data;           /* Used to poll the data */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDiscardBCastMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_DROP_BCAST))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(en, data);
+
+    retVal = hwSetPortRegField(dev,hwPort, 0x15, 6, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtGetFCOnRateLimitMode
+*
+* DESCRIPTION:
+*       This routine returns mode that tells if ingress rate limiting uses Flow
+*        Control. When this mode is enabled and the port receives frames over the
+*        limit, Ingress Rate Limiting will be performed by stalling the
+*        link partner using flow control, instead of discarding frames.
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        en - GT_TRUE, if the mode is enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        In order for this mode to work, Flow Control and Rate Limiting
+*        should be configured properly.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFCOnRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetFCOnRateLimitMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+    }
+
+    data = 0;
+
+    retVal = hwGetPortRegField(dev,hwPort, 0x15, 4, 2, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if (data == 0x3)
+        *en = GT_TRUE;
+    else
+        *en = GT_FALSE;
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetFCOnRateLimitMode
+*
+* DESCRIPTION:
+*       This routine sets the mode that tells if ingress rate limiting uses Flow
+*        Control. When this mode is enabled and the port receives frames over the
+*        limit, Ingress Rate Limiting will be performed by stalling the
+*        link partner using flow control, instead of discarding frames.
+*
+* INPUTS:
+*       port - logical port number
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       This routine won't configure Flow Control or Rate Limiting.
+*        In order for this mode to work, Flow Control and Rate Limiting
+*        should be configured properly.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetFCOnRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetFCOnRateLimitMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    if (en)
+        data = 0x3;
+    else
+        data = 0;
+
+    retVal = hwSetPortRegField(dev,hwPort, 0x15, 4, 2, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetSAFiltering
+*
+* DESCRIPTION:
+*        This routine set the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOCK :
+*                discard if SA field is in the ATU's address database as Static
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU :
+*                Ingressing frames will be mapped to the CPU Port if their SA
+*                field is in the ATU's address database as Static entry with a
+*                PortVec of all zeros. Otherwise, the frames will be discarded
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_SA_FILTERING structure
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS gprtSetSAFiltering
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_SA_FILTERING    mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16            data;
+
+    DBG_INFO(("gprtSetSAFiltering Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SA_FILTERING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    data = (GT_U16) mode;
+
+    /* Set the SA Filtering bits.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetSAFiltering
+*
+* DESCRIPTION:
+*        This routine gets the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOCK :
+*                discard if SA field is in the ATU's address database as Static
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU :
+*                Ingressing frames will be mapped to the CPU Port if their SA
+*                field is in the ATU's address database as Static entry with a
+*                PortVec of all zeros. Otherwise, the frames will be discarded
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_SA_FILTERING structure
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS gprtGetSAFiltering
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_SA_FILTERING    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16            data;
+
+    DBG_INFO(("gprtSetSAFiltering Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SA_FILTERING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SA Filtering bits.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *mode = (GT_SA_FILTERING)data;
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetARPtoCPU
+*
+* DESCRIPTION:
+*        When ARPtoCPU (or ARP Mirror) is set to GT_TRUE, ARP frames are mirrored
+*        to the CPU port.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE, to map ARP frames to CPU Port,
+*               GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS gprtSetARPtoCPU
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    mode
+)
+{
+    GT_U16            data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetARPtoCPU Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_TO_CPU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the ARPtoCPU bits.  */
+    if (IS_IN_DEV_GROUP(dev,DEV_FASTETH_SWITCH))
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,data);
+    else
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,6,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetARPtoCPU
+*
+* DESCRIPTION:
+*        When ARPtoCPU (or ARP Mirror) is set to GT_TRUE, ARP frames are mirrored
+*        to the CPU port.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE, to map ARP frames to CPU Port,
+*               GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS gprtGetARPtoCPU
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *mode
+)
+{
+    GT_U16            data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetARPtoCPU Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports the feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_TO_CPU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the ARPtoCPU bits.  */
+    if (IS_IN_DEV_GROUP(dev,DEV_FASTETH_SWITCH))
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,&data);
+    else
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,6,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetEgressFlood
+*
+* DESCRIPTION:
+*       This routine set Egress Flooding Mode.
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_EGRESS_FLOOD type
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressFlood
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_EGRESS_FLOOD      mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16            data;
+
+    DBG_INFO(("gprtSetEgressFlood Called.\n"));
+
+    /* check if device supports the feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    data = (GT_U16) mode;
+
+    /* Set the Egress Flood mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,2,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetEgressFlood
+*
+* DESCRIPTION:
+*       This routine gets Egress Flooding Mode.
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_EGRESS_FLOOD type
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressFlood
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_EGRESS_FLOOD      *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetEgressFlood Called.\n"));
+
+    /* check if device supports the feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* get the Egress Flood mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,2,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *mode = (GT_EGRESS_FLOOD) data;
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortSched
+*
+* DESCRIPTION:
+*        This routine sets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_PORT_SCHED_MODE enum type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortSched
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PORT_SCHED_MODE        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetPortSched Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!((IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
+    {
+        switch(mode)
+        {
+            case GT_PORT_SCHED_WEIGHTED_RRB:
+                data = 0;
+                break;
+            case GT_PORT_SCHED_STRICT_PRI:
+                data = 3;
+                break;
+            case GT_PORT_SCHED_STRICT_PRI3:
+                data = 1;
+                break;
+            case GT_PORT_SCHED_STRICT_PRI2_3:
+                data = 2;
+                break;
+            default:
+                return GT_BAD_PARAM;
+        }
+
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_RATE_CTRL, 12,2,data);
+
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+        }
+        else
+        {
+            DBG_INFO(("OK.\n"));
+        }
+        return retVal;
+
+    }
+
+
+    data = mode;
+
+    /* Set the gprtSetPortSched mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,14,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPortSched
+*
+* DESCRIPTION:
+*        This routine gets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_PORT_SCHED_MODE enum type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortSched
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PORT_SCHED_MODE        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPortSched Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!((IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_RATE_CTRL, 12,2,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        switch(data)
+        {
+            case 0:
+                *mode = GT_PORT_SCHED_WEIGHTED_RRB;
+                break;
+            case 1:
+                *mode = GT_PORT_SCHED_STRICT_PRI3;
+                break;
+            case 2:
+                *mode = GT_PORT_SCHED_STRICT_PRI2_3;
+                break;
+            case 3:
+                *mode = GT_PORT_SCHED_STRICT_PRI;
+                break;
+            default:
+                return GT_BAD_PARAM;
+        }
+
+        return GT_OK;
+
+    }
+
+    /* Get the gprtGetPortSched mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,14,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *mode = (GT_PORT_SCHED_MODE)data;
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetProviderTag
+*
+* DESCRIPTION:
+*        This routine sets Provider Tag which indicates the provider tag (Ether
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
+*
+* INPUTS:
+*        port - the logical port number
+*        tag  - Provider Tag (Ether Type)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetProviderTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        tag
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetProviderTag Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PROVIDER_TAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set Provider Tag.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PROVIDER_TAG, 0, 16, tag);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetProviderTag
+*
+* DESCRIPTION:
+*        This routine gets Provider Tag which indicates the provider tag (Ether
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        tag  - Provider Tag (Ether Type)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetProviderTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *tag
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetProviderTag Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PROVIDER_TAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get Provider Tag.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PROVIDER_TAG, 0, 16, tag);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPauseLimitOut
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
+*
+* INPUTS:
+*        port - the logical port number
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPauseLimitOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        limit
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetPauseLimitOut Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (limit > 0xFF)
+    {
+        DBG_INFO(("Bad Parameter\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Set Pause Limit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_LIMIT_PAUSE_CONTROL, 8, 8, limit);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPauseLimitOut
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPauseLimitOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *limit
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPauseLimitOut Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get Pause Limit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_LIMIT_PAUSE_CONTROL, 8, 8, limit);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPauseLimitIn
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that
+*        the limit was reached on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPauseLimitIn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        limit
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetPauseLimitIn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (limit > 0xFF)
+    {
+        DBG_INFO(("Bad Parameter\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Set Pause Limit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_LIMIT_PAUSE_CONTROL, 0, 8, limit);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPauseLimitIn
+*
+* DESCRIPTION:
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that
+*        the limit was reached on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPauseLimitIn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *limit
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPauseLimitIn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get Pause Limit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_LIMIT_PAUSE_CONTROL, 0, 8, limit);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetFrameMode
+*
+* DESCRIPTION:
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to
+*                be used on ports that connect to a CPU.
+*
+* INPUTS:
+*        port - the logical port number
+*        mode - GT_FRAME_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is unknown
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetFrameMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_FRAME_MODE    mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetFrameMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (mode)
+    {
+        case GT_FRAME_MODE_NORMAL:
+        case GT_FRAME_MODE_DSA:
+        case GT_FRAME_MODE_PROVIDER:
+        case GT_FRAME_MODE_ETHER_TYPE_DSA:
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
+
+    /* Set Frame Mode.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 2, (GT_U16)mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetFrameMode
+*
+* DESCRIPTION:
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to
+*                be used on ports that connect to a CPU.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_FRAME_MODE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFrameMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_FRAME_MODE    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetFrameMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get Pause Limit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 2, &data);
+    *mode = data;
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetHoldAt1
+*
+* DESCRIPTION:
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetHoldAt1
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetHoldAt1 Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_HOLD))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set HoldAt1 */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 15, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetHoldAt1
+*
+* DESCRIPTION:
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHoldAt1
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetHoldAt1 Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_HOLD))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get HoldAt1 */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 15, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetIntOnAgeOut
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable AgeOutViloation interrupt
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIntOnAgeOut
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIntOnAgeOut Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Age Out Interrupt Enable Mode. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 14, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetIntOnAgeOut
+*
+* DESCRIPTION:
+*        Interrupt on Age Out. When aging is enabled, all non-static address
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this
+*        port is aged out, an AgeOutViolation will be captured for that entry.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable AgeOutViloation interrupt
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIntOnAgeOut
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIntOnAgeOut Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get IntOnAgeOut */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 14, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetRefreshLocked
+*
+* DESCRIPTION:
+*        Auto Refresh known addresses when port is Locked. Already known addresses
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetRefreshLocked
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetRefreshLocked Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AUTO_REFRESH_LOCKED))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set RefreshLocked */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 11, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetRefreshLocked
+*
+* DESCRIPTION:
+*        Auto Refresh known addresses when port is Locked. Already known addresses
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetRefreshLocked
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetRefreshLocked Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AUTO_REFRESH_LOCKED))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get RefreshLocked */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 11, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortEType
+*
+* DESCRIPTION:
+*        This routine sets the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*
+* INPUTS:
+*        port  - the logical port number
+*        etype - port's special ether type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortEType
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_ETYPE        etype
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetPortEType Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_ETYPE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    data = (GT_U16)etype;
+
+    /* Set the EtherType.            */
+    retVal = hwWritePortReg(dev,hwPort, QD_REG_PORT_ETH_TYPE,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetPortEType
+*
+* DESCRIPTION:
+*        This routine retrieves the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*
+* INPUTS:
+*        port  - the logical port number
+*
+* OUTPUTS:
+*        etype - port's special ether type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortEType
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_ETYPE    *etype
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPortEType Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_ETYPE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the EtherType.            */
+    retVal = hwReadPortReg(dev,hwPort, QD_REG_PORT_ETH_TYPE,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *etype = (GT_ETYPE) data;
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gsysSetJumboMode
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed to be received and transmitted
+*        from or to a given port.
+*
+* INPUTS:
+*        port - the logical port number
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gsysSetJumboMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_JUMBO_MODE   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetJumboMode Called.\n"));
+
+    if (mode > GT_JUMBO_MODE_10240)
+    {
+        DBG_INFO(("Bad Parameter\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the Jumbo Fram Size bit.               */
+    retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,12,2,(GT_U16)mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetJumboMode
+*
+* DESCRIPTION:
+*       This routine gets the max frame size allowed to be received and transmitted
+*        from or to a given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gsysGetJumboMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_JUMBO_MODE   *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gsysGetJumboMode Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get Jumbo Frame Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,12,2,&data );
+
+    *mode = (GT_JUMBO_MODE)data;
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGet200Base
+*
+* DESCRIPTION:
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*        0 = 25MHz Px_GTXCLK
+*        1 = 50MHz Px_GTXCLK
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - 0 for 100Mbps, 1 for 200Mbps
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        C_Mode should be set to 0x2 in order for this API to work
+*
+*******************************************************************************/
+GT_STATUS gprtGet200Base
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_U32      *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16        data;
+
+    DBG_INFO(("gprtGet200Base Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_200BASE_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the high error rate bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *mode = data;
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSet200Base
+*
+* DESCRIPTION:
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*        0 = 25MHz Px_GTXCLK
+*        1 = 50MHz Px_GTXCLK
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - 0 for 100Mbps, 1 for 200Mbps
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        C_Mode should be set to 0x2 in order for this API to work
+*
+*******************************************************************************/
+GT_STATUS gprtSet200Base
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32      mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSet200Base Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_200BASE_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the high error rate bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,(GT_U16)mode&0x1);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetSwitchReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSwitchReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetSwitchReg Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get Phy Register. */
+    if(hwReadPortReg(dev,hwPort,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    *data = u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetSwitchReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetSwitchReg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetSwitchReg Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the Scheduling bit.              */
+    if(hwWritePortReg(dev,hwPort,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGetGlobalReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobalReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+
+    DBG_INFO(("gprtGetGlobalReg Called.\n"));
+
+    /* Get Phy Register. */
+    if(hwReadGlobalReg(dev,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    *data = u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetGlobalReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobalReg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
+)
+{
+    DBG_INFO(("gprtSetGlobalReg Called.\n"));
+
+    /* Get the Scheduling bit.              */
+    if(hwWriteGlobalReg(dev,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtGetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global 2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobal2Reg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+
+    DBG_INFO(("gprtGetGlobal2Reg Called.\n"));
+
+    /* Get Phy Register. */
+    if(hwReadGlobal2Reg(dev,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    *data = u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobal2Reg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
+)
+{
+    DBG_INFO(("gprtSetGlobal2Reg Called.\n"));
+
+    /* Get the Scheduling bit.              */
+    if(hwWriteGlobal2Reg(dev,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+/*******************************************************************************
+* gprtGetGlobal3Reg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global 3 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobal3Reg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+
+    DBG_INFO(("gprtGetGlobal3Reg Called.\n"));
+
+    /* Get Phy Register. */
+    if(hwReadGlobal3Reg(dev,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    *data = u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetGlobal3Reg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global3 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobal3Reg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
+)
+{
+    DBG_INFO(("gprtSetGlobal3Reg Called.\n"));
+
+    /* Get the Scheduling bit.              */
+    if(hwWriteGlobal3Reg(dev,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    return GT_OK;
+}
+
+/* New functions in 88E6320 or later */
+/*******************************************************************************
+* gprtSetQueueCtrl
+*
+* DESCRIPTION:
+*        Set port queue control data to the Port Queue Control register.
+*        The registers of Port Queue control are.
+*         Hard Queue Limits register space
+*         Reserved for future Hard Queue Limits use
+*
+* INPUTS:
+*        port  - logical port number
+*        point - Pointer to the Port Queue Control register.
+*        data  - Port Queue Control data written to the register
+*                pointed to by the point above.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtSetQueueCtrl
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    IN  GT_U32           point,
+    IN  GT_U8            data
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    IN  GT_U16            tmpData;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_QUEUE_CONTROL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (point > 0x80)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (data &0xffffff00)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+
+    /* Wait until the Port Queue Control is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, PORT_ACCESS);
+      regAccess.rw_reg_list[0].reg = 0x1d;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
+       tmpData = 1;
+    while(tmpData == 1)
+       {
+        retVal = hwGetPortRegField(dev,hwPort, 0x1d,15,1,&tmpData);
+           if(retVal != GT_OK)
+           {
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+           }
+    }
+#endif
+
+    tmpData =  (GT_U16)((1 << 15) | (point << 8) | data);
+
+    retVal = hwWritePortReg(dev,hwPort, 0x1d, tmpData);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+       return retVal;
+
+}
+
+
+/*******************************************************************************
+* gprtGetQueueCtrl
+*
+* DESCRIPTION:
+*        Get port queue control data from the Port Queue Control register.
+*        The registers of Port Queue control are.
+*         Hard Queue Limits register space
+*         Reserved for future Hard Queue Limits use
+*
+* INPUTS:
+*        port  - logical port number
+*        point - Pointer to the Port Queue Control register.
+*
+* OUTPUTS:
+*        data  - Port Queue Control data written to the register
+*                pointed to by the point above.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtGetQueueCtrl
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    IN  GT_U32           point,
+    OUT GT_U8            *data
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    OUT  GT_U16            tmpData;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_QUEUE_CONTROL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (point > 0x80)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Port Queue Control is ready. */
+
+    do {
+        retVal = hwGetPortRegField(dev,hwPort, 0x1d,15,1,&tmpData);
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+    } while (tmpData&0x8000);
+
+    *data = tmpData&0xff;
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetDebugCounter
+*
+* DESCRIPTION:
+*        Get Port Debug Counter, bad counter and good counter.
+*
+* INPUTS:
+*        port  - logical port number
+*
+* OUTPUTS:
+*        badCounter  - When CtrMode is cleared to a zero (Global 1 offset 0x1C) this
+*  counter increments each time a frame enters this port that was an error on the
+*  wire. It does not matter if the frames CRC is fixed by ForceGoodFCS (Port
+*  offset 0x08) being set to a one, this counter will still increment. A CRC error
+*  frame is one that is 64 bytes to MaxFrameSize (Global 1, offset 0x04) with a
+*  bad CRC (including alignment errors but not dribbles). Fragments and
+*  properly formed frames are not counted. The RxBadFrames counter counts
+*  frames that are counted in the MIB counters as InUndersize, InOversize,
+*  InJabber, InRxErr and InFCSErr.
+*  When CtrMode is set to a one this counter increments each time a transmit
+*  collision occurs on this port.
+*        goodCounter  - When CtrMode is cleared to a zero (Global 1 offset 0x1C) this
+*  counter increments each time a frame enters this port that was not an error
+*  frame on the wire. It does not matter if the frame was filtered or discarded,
+*  only that the frame was received as good on the wire (i.e., its wire size is in the
+*  range of 64 bytes to MaxFrameSize (Global 1, offset 0x04) and its CRC was
+*  good. The RxGoodFrames counter counts frames that are not counted
+*  above as long as they are not being counted in the MIB counters as
+*  InFragments.
+*  When CtrMode is set to a one this counter increments each time a frame is
+*  transmitted out this port.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtGetDebugCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    OUT  GT_U8            *badCounter,
+    OUT  GT_U8            *goodCounter
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    OUT  GT_U16            tmpData;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_DEBUG_COUNTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_BAD_PARAM;
+    }
+
+    retVal = hwReadPortReg(dev,hwPort, 0x1e, &tmpData);
+    if(retVal != GT_OK)
+    {
+      DBG_INFO(("Failed.\n"));
+      return retVal;
+    }
+
+    *goodCounter = tmpData&0xff;
+    *badCounter = (tmpData>>8)&0xff;
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetCutThrough
+*
+* DESCRIPTION:
+*        Set port Cut Through configuration.
+*
+* INPUTS:
+*        port  - logical port number
+*        cutThru - Cut through configuration.
+*                    enableSelect;     Port Enable Select.
+*                    enable;           Cut Through enable.
+*                    cutThruQueue;     Cut Through Queues.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtSetCutThrough
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    IN  GT_CUT_THROUGH   *cutThru
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    OUT  GT_U16            tmpData;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_CUT_THROUGH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_BAD_PARAM;
+    }
+
+    tmpData = (cutThru->enableSelect<<12)|(cutThru->enable<<8)|cutThru->cutThruQueue;
+    retVal = hwWritePortReg(dev,hwPort, 0x1f, tmpData);
+    if(retVal != GT_OK)
+    {
+      DBG_INFO(("Failed.\n"));
+      return retVal;
+    }
+
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetCutThrough
+*
+* DESCRIPTION:
+*        Get port Cut Through configuration.
+*
+* INPUTS:
+*        port  - logical port number
+*
+* OUTPUTS:
+*        cutThru - Cut through configuration.
+*                    enableSelect;     Port Enable Select.
+*                    enable;           Cut Through enable.
+*                    cutThruQueue;     Cut Through Queues.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtGetCutThrough
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT         port,
+    OUT GT_CUT_THROUGH   *cutThru
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    OUT  GT_U16            tmpData;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_CUT_THROUGH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_BAD_PARAM;
+    }
+
+    retVal = hwReadPortReg(dev,hwPort, 0x1f, &tmpData);
+    if(retVal != GT_OK)
+    {
+      DBG_INFO(("Failed.\n"));
+      return retVal;
+    }
+
+    cutThru->enableSelect = (tmpData>>12)&0xf;
+    cutThru->enable = (tmpData&0x100)?1:0;
+    cutThru->cutThruQueue =tmpData&0xff;
+
+    return retVal;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortLed.c
@@ -0,0 +1,840 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPortLed.c
+*
+* DESCRIPTION:
+*       API definitions for LED Control
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+static GT_STATUS convertLED2APP
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value,
+    OUT GT_U32        *data
+);
+
+
+static GT_STATUS convertAPP2LED
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value,
+    OUT GT_U32        *data
+);
+
+
+/*******************************************************************************
+* gprtSetLED
+*
+* DESCRIPTION:
+*        This API allows to configure 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
+*
+* INPUTS:
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
+*        value     - value to be configured
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtSetLED
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+    GT_U32        ptr, conv, mask;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetLED Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort >= 5)
+        return GT_BAD_PARAM;
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_LED_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (cfg)
+    {
+        case GT_LED_CFG_LED0:
+            ptr = 0;
+            mask = 0xF;
+            break;
+        case GT_LED_CFG_LED1:
+            ptr = 0;
+            mask = 0xF0;
+            break;
+        case GT_LED_CFG_LED2:
+            ptr = 1;
+            mask = 0xF;
+            break;
+        case GT_LED_CFG_LED3:
+            ptr = 1;
+            mask = 0xF0;
+            break;
+        case GT_LED_CFG_PULSE_STRETCH:
+            ptr = 6;
+            mask = 0x70;
+            break;
+        case GT_LED_CFG_BLINK_RATE:
+            ptr = 6;
+            mask = 0x7;
+            break;
+        case GT_LED_CFG_SPECIAL_CONTROL:
+            ptr = 7;
+            mask = (1 << dev->maxPorts) - 1;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+    conv = 0;
+    retVal = convertAPP2LED(dev,port,cfg,value,&conv);
+    if (retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_LED_CONTROL;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_LED_CONTROL,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+    } while(data == 1);
+#endif
+
+    /* read the current data */
+    data = (GT_U16)(ptr << 12);
+
+    retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
+    if(retVal != GT_OK)
+      {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = hwGetPortRegField(dev, hwPort, QD_REG_LED_CONTROL,0,11,&data);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    /* overwrite the data */
+    data = (GT_U16)((1 << 15) | (ptr << 12) | (conv | (data & ~mask)));
+
+    retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
+    if(retVal != GT_OK)
+      {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGetLED
+*
+* DESCRIPTION:
+*        This API allows to retrieve 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
+*
+* INPUTS:
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
+*
+* OUTPUTS:
+*        value     - value to be configured
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gprtGetLED
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    OUT GT_U32        *value
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+    GT_U32        ptr;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetLED Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort >= 5)
+        return GT_BAD_PARAM;
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_LED_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (cfg)
+    {
+        case GT_LED_CFG_LED0:
+            ptr = 0;
+            break;
+        case GT_LED_CFG_LED1:
+            ptr = 0;
+            break;
+        case GT_LED_CFG_LED2:
+            ptr = 1;
+            break;
+        case GT_LED_CFG_LED3:
+            ptr = 1;
+            break;
+        case GT_LED_CFG_PULSE_STRETCH:
+            ptr = 6;
+            break;
+        case GT_LED_CFG_BLINK_RATE:
+            ptr = 6;
+            break;
+        case GT_LED_CFG_SPECIAL_CONTROL:
+            ptr = 7;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_LED_CONTROL;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_LED_CONTROL,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+    } while(data == 1);
+#endif
+
+    /* read the current data */
+    data = (GT_U16)(ptr << 12);
+
+    retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
+    if(retVal != GT_OK)
+      {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = hwGetPortRegField(dev, hwPort, QD_REG_LED_CONTROL,0,11,&data);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = convertLED2APP(dev,port,cfg,data,value);
+    if (retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
+}
+
+
+static GT_STATUS convertAPP2LED
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value,
+    OUT GT_U32        *data
+)
+{
+    GT_STATUS    retVal = GT_OK;
+
+    switch (cfg)
+    {
+        case GT_LED_CFG_LED0:
+            switch (value)
+            {
+                case GT_LED_LINK_ACT:
+                    *data = 3;
+                    break;
+                case GT_LED_LINK:
+                    *data = 8;
+                    break;
+                case GT_LED_10_LINK_ACT:
+                    *data = 10;
+                    break;
+                case GT_LED_10_LINK:
+                    *data = 9;
+                    break;
+                case GT_LED_1000_LINK_ACT:
+                    *data = 2;
+                    break;
+                case GT_LED_100_1000_LINK_ACT:
+                    *data = 1;
+                    break;
+                case GT_LED_100_1000_LINK:
+                    *data = 11;
+                    break;
+                case GT_LED_SPECIAL:
+                    *data = 7;
+                    break;
+                case GT_LED_DUPLEX_COL:
+                    *data = 6;
+                    break;
+                case GT_LED_PTP_ACT:
+                    *data = 0;
+                    break;
+                case GT_LED_FORCE_BLINK:
+                    *data = 13;
+                    break;
+                case GT_LED_FORCE_OFF:
+                    *data = 14;
+                    break;
+                case GT_LED_FORCE_ON:
+                    *data = 15;
+                    break;
+                default:
+                    retVal = GT_BAD_PARAM;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED1:
+            switch (value)
+            {
+                case GT_LED_LINK_ACT_SPEED:
+                    *data = 0;
+                    break;
+                case GT_LED_100_LINK_ACT:
+                    *data = 10;
+                    break;
+                case GT_LED_100_LINK:
+                    *data = 9;
+                    break;
+                case GT_LED_1000_LINK:
+                    *data = 3;
+                    break;
+                case GT_LED_10_100_LINK_ACT:
+                    *data = 1;
+                    break;
+                case GT_LED_10_100_LINK:
+                    *data = 11;
+                    break;
+                case GT_LED_SPECIAL:
+                    *data = 6;
+                    break;
+                case GT_LED_DUPLEX_COL:
+                    *data = 7;
+                    break;
+                case GT_LED_ACTIVITY:
+                    *data = 8;
+                    break;
+                case GT_LED_PTP_ACT:
+                    *data = 12;
+                    break;
+                case GT_LED_FORCE_BLINK:
+                    *data = 13;
+                    break;
+                case GT_LED_FORCE_OFF:
+                    *data = 14;
+                    break;
+                case GT_LED_FORCE_ON:
+                    *data = 15;
+                    break;
+                default:
+                    retVal = GT_BAD_PARAM;
+                    break;
+            }
+            *data <<= 4;
+            break;
+
+        case GT_LED_CFG_LED2:
+            switch (value)
+            {
+                case GT_LED_10_LINK_ACT:
+                    *data = 6;
+                    break;
+                case GT_LED_100_LINK:
+                    *data = 8;
+                    break;
+                case GT_LED_1000_LINK_ACT:
+                    *data = 10;
+                    break;
+                case GT_LED_1000_LINK:
+                    *data = 9;
+                    break;
+                case GT_LED_10_1000_LINK_ACT:
+                    *data = 1;
+                    break;
+                case GT_LED_10_1000_LINK:
+                    *data = 11;
+                    break;
+                case GT_LED_100_1000_LINK_ACT:
+                    *data = 7;
+                    break;
+                case GT_LED_100_1000_LINK:
+                    *data = 3;
+                    break;
+                case GT_LED_SPECIAL:
+                    *data = 2;
+                    break;
+                case GT_LED_DUPLEX_COL:
+                    *data = 0;
+                    break;
+                case GT_LED_PTP_ACT:
+                    *data = 12;
+                    break;
+                case GT_LED_FORCE_BLINK:
+                    *data = 13;
+                    break;
+                case GT_LED_FORCE_OFF:
+                    *data = 14;
+                    break;
+                case GT_LED_FORCE_ON:
+                    *data = 15;
+                    break;
+                default:
+                    retVal = GT_BAD_PARAM;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED3:
+            switch (value)
+            {
+                case GT_LED_LINK_ACT:
+                    *data = 10;
+                    break;
+                case GT_LED_LINK:
+                    *data = 9;
+                    break;
+                case GT_LED_10_LINK:
+                    *data = 8;
+                    break;
+                case GT_LED_100_LINK_ACT:
+                    *data = 6;
+                    break;
+                case GT_LED_10_1000_LINK_ACT:
+                    *data = 7;
+                    break;
+                case GT_LED_SPECIAL:
+                    *data = 0;
+                    break;
+                case GT_LED_DUPLEX_COL:
+                    *data = 1;
+                    break;
+                case GT_LED_ACTIVITY:
+                    *data = 11;
+                    break;
+                case GT_LED_PTP_ACT:
+                    *data = 12;
+                    break;
+                case GT_LED_FORCE_BLINK:
+                    *data = 13;
+                    break;
+                case GT_LED_FORCE_OFF:
+                    *data = 14;
+                    break;
+                case GT_LED_FORCE_ON:
+                    *data = 15;
+                    break;
+                default:
+                    retVal = GT_BAD_PARAM;
+                    break;
+            }
+            *data <<= 4;
+            break;
+
+        case GT_LED_CFG_PULSE_STRETCH:
+            if (value > 0x4)
+                retVal = GT_BAD_PARAM;
+            *data = value << 4;
+            break;
+        case GT_LED_CFG_BLINK_RATE:
+            if (value > 0x5)
+                retVal = GT_BAD_PARAM;
+            *data = value;
+            break;
+
+        case GT_LED_CFG_SPECIAL_CONTROL:
+            if (value >= (GT_U32)(1 << dev->maxPorts))
+                retVal = GT_BAD_PARAM;
+            *data = value;
+            break;
+
+        default:
+            retVal = GT_BAD_PARAM;
+            break;
+    }
+
+    return retVal;
+
+}
+
+
+static GT_STATUS convertLED2APP
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value,
+    OUT GT_U32        *data
+)
+{
+    GT_STATUS retVal = GT_OK;
+
+    switch (cfg)
+    {
+        case GT_LED_CFG_LED0:
+            value &= 0xF;
+            switch (value)
+            {
+                case 0:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 1:
+                    *data = GT_LED_100_1000_LINK_ACT;
+                    break;
+                case 2:
+                    *data = GT_LED_1000_LINK_ACT;
+                    break;
+                case 3:
+                    *data = GT_LED_LINK_ACT;
+                    break;
+                case 4:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 5:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 6:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 7:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 8:
+                    *data = GT_LED_LINK;
+                    break;
+                case 9:
+                    *data = GT_LED_10_LINK;
+                    break;
+                case 10:
+                    *data = GT_LED_10_LINK_ACT;
+                    break;
+                case 11:
+                    *data = GT_LED_100_1000_LINK;
+                    break;
+                case 12:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 13:
+                    *data = GT_LED_FORCE_BLINK;
+                    break;
+                case 14:
+                    *data = GT_LED_FORCE_OFF;
+                    break;
+                case 15:
+                    *data = GT_LED_FORCE_ON;
+                    break;
+                default:
+                    retVal = GT_FAIL;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED1:
+            value >>= 4;
+            value &= 0xF;
+            switch (value)
+            {
+                case 0:
+                    *data = GT_LED_LINK_ACT_SPEED;
+                    break;
+                case 1:
+                    *data = GT_LED_10_100_LINK_ACT;
+                    break;
+                case 2:
+                    *data = GT_LED_10_100_LINK_ACT;
+                    break;
+                case 3:
+                    *data = GT_LED_1000_LINK;
+                    break;
+                case 4:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 5:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 6:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 7:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 8:
+                    *data = GT_LED_ACTIVITY;
+                    break;
+                case 9:
+                    *data = GT_LED_100_LINK;
+                    break;
+                case 10:
+                    *data = GT_LED_100_LINK_ACT;
+                    break;
+                case 11:
+                    *data = GT_LED_10_100_LINK;
+                    break;
+                case 12:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 13:
+                    *data = GT_LED_FORCE_BLINK;
+                    break;
+                case 14:
+                    *data = GT_LED_FORCE_OFF;
+                    break;
+                case 15:
+                    *data = GT_LED_FORCE_ON;
+                    break;
+                default:
+                    retVal = GT_FAIL;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED2:
+            value &= 0xF;
+            switch (value)
+            {
+                case 0:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 1:
+                    *data = GT_LED_10_1000_LINK_ACT;
+                    break;
+                case 2:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 3:
+                    *data = GT_LED_100_1000_LINK;
+                    break;
+                case 4:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 5:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 6:
+                    *data = GT_LED_10_LINK_ACT;
+                    break;
+                case 7:
+                    *data = GT_LED_100_1000_LINK_ACT;
+                    break;
+                case 8:
+                    *data = GT_LED_100_LINK;
+                    break;
+                case 9:
+                    *data = GT_LED_1000_LINK;
+                    break;
+                case 10:
+                    *data = GT_LED_1000_LINK_ACT;
+                    break;
+                case 11:
+                    *data = GT_LED_10_1000_LINK;
+                    break;
+                case 12:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 13:
+                    *data = GT_LED_FORCE_BLINK;
+                    break;
+                case 14:
+                    *data = GT_LED_FORCE_OFF;
+                    break;
+                case 15:
+                    *data = GT_LED_FORCE_ON;
+                    break;
+                default:
+                    retVal = GT_FAIL;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED3:
+            value >>= 4;
+            value &= 0xF;
+            switch (value)
+            {
+                case 0:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 1:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 2:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 3:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 4:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 5:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 6:
+                    *data = GT_LED_100_LINK_ACT;
+                    break;
+                case 7:
+                    *data = GT_LED_10_1000_LINK_ACT;
+                    break;
+                case 8:
+                    *data = GT_LED_10_LINK;
+                    break;
+                case 9:
+                    *data = GT_LED_LINK;
+                    break;
+                case 10:
+                    *data = GT_LED_LINK_ACT;
+                    break;
+                case 11:
+                    *data = GT_LED_ACTIVITY;
+                    break;
+                case 12:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 13:
+                    *data = GT_LED_FORCE_BLINK;
+                    break;
+                case 14:
+                    *data = GT_LED_FORCE_OFF;
+                    break;
+                case 15:
+                    *data = GT_LED_FORCE_ON;
+                    break;
+                default:
+                    retVal = GT_FAIL;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_PULSE_STRETCH:
+            *data = (value >> 4) & 0x7;
+            break;
+
+        case GT_LED_CFG_BLINK_RATE:
+            *data = value & 0x7;
+            break;
+
+        case GT_LED_CFG_SPECIAL_CONTROL:
+            *data = value & ((1 << dev->maxPorts) - 1);
+            break;
+
+        default:
+            retVal = GT_BAD_PARAM;
+            break;
+    }
+
+    return retVal;
+
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortPav.c
@@ -0,0 +1,269 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPortPav.c
+*
+* DESCRIPTION:
+*       API definitions to handle Port Association Vector (0xB).
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gpavSetPAV
+*
+* DESCRIPTION:
+*       This routine sets the Port Association Vector
+*
+* INPUTS:
+*       port    - logical port number.
+*       pav     - Port Association Vector
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpavSetPAV
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT     port,
+    IN GT_U16     pav
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U16            hwPav;
+
+    DBG_INFO(("gpavSetPAV Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK )
+      return retVal;
+
+    /*
+     * translate Logical Port Vector to Physical Port Vector.
+     */
+    hwPav = (GT_U16)GT_LPORTVEC_2_PORTVEC(pav);
+
+    if(hwPav == (GT_U16)GT_INVALID_PORT_VEC)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    /* there are 7 ports in the switch */
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,0,dev->maxPorts,hwPav);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gpavGetPAV
+*
+* DESCRIPTION:
+*       This routine gets the Port Association Vector
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       pav     - Port Association Vector
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpavGetPAV
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U16   *pav
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gpavGetPAV Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK )
+      return retVal;
+
+    if(pav == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,(GT_U8)QD_REG_PORT_ASSOCIATION,0,dev->maxPorts,&data );
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /*
+     * translate Physical Port Vector to Logical Port Vector.
+     */
+    *pav = (GT_U16)GT_PORTVEC_2_LPORTVEC(data);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gpavSetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine sets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled
+*              GT_TRUE:  Ingress Monitor disabled
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpavSetIngressMonitor
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gpavSetIngressMonitorCalled.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    BOOL_2_BIT(mode,data);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENABLE_MONITORING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,15,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gpavGetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine gets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled
+*              GT_TRUE:  Ingress Monitor disabled
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpavGetIngressMonitor
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetIngressMonitor Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENABLE_MONITORING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortRateCtrl.c
@@ -0,0 +1,2818 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPortRateCtrl.c
+*
+* DESCRIPTION:
+*       API definitions to handle port rate control registers (0xA).
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/*
+ Convert given hw Rate Limit to sw defined Rate Limit.
+ This routine is only for Gigabit Managed Switch Device.
+ If the given device is not an accepted device, it'll simply copy the hw limit
+ to sw limit.
+*/
+static GT_STATUS cRateLimit(GT_QD_DEV *dev, GT_U32 hwLimit, GT_U32* swLimit)
+{
+    GT_U32 sLimit, hLimit, startLimit, endLimit, i;
+
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+    {
+        *swLimit = hwLimit;
+        return GT_OK;
+    }
+
+    if(hwLimit == 0)
+    {
+        *swLimit = GT_NO_LIMIT;
+        return GT_OK;
+    }
+
+    sLimit = 1000;
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+        hLimit = GT_GET_RATE_LIMIT3(sLimit);
+    else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+        hLimit = GT_GET_RATE_LIMIT2(sLimit);
+    else
+        hLimit = GT_GET_RATE_LIMIT(sLimit);
+    if(hLimit == hwLimit)
+    {
+        *swLimit = GT_1M;
+        return GT_OK;
+    }
+
+    if(hLimit > hwLimit)
+    {
+        startLimit = 2000;
+        endLimit = 256000;
+        *swLimit = GT_2M;
+    }
+    else
+    {
+        startLimit = 128;
+        endLimit = 512;
+        *swLimit = GT_128K;
+    }
+
+    i = 0;
+    for(sLimit=startLimit;sLimit<=endLimit;sLimit *= 2, i++)
+    {
+        if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+            hLimit = GT_GET_RATE_LIMIT3(sLimit);
+        else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+            hLimit = GT_GET_RATE_LIMIT2(sLimit);
+        else
+            hLimit = GT_GET_RATE_LIMIT(sLimit);
+
+        if(hLimit == 0)
+            hLimit = 1;
+
+        if(hLimit == hwLimit)
+        {
+            *swLimit += i;
+            return GT_OK;
+        }
+
+        if(hLimit < hwLimit)
+            break;
+    }
+
+    *swLimit = hwLimit;
+    return GT_OK;
+}
+
+
+/*
+ Convert given sw defined Burst Rate to meaningful number.
+*/
+static GT_STATUS cBurstEnum2Number(GT_QD_DEV *dev, GT_BURST_RATE rate, GT_U32 *rLimit)
+{
+    GT_U32 rateLimit;
+
+    GT_UNUSED_PARAM(dev);
+
+    switch(rate)
+    {
+        case GT_BURST_NO_LIMIT :
+                rateLimit = 0; /* MAX_RATE_LIMIT; */
+                break;
+        case GT_BURST_64K :
+                rateLimit = 64;
+                break;
+        case GT_BURST_128K :
+                rateLimit = 128;
+                break;
+        case GT_BURST_256K :
+                rateLimit = 256;
+                break;
+        case GT_BURST_384K :
+                rateLimit = 384;
+                break;
+        case GT_BURST_512K :
+                rateLimit = 512;
+                break;
+        case GT_BURST_640K :
+                rateLimit = 640;
+                break;
+        case GT_BURST_768K :
+                rateLimit = 768;
+                break;
+        case GT_BURST_896K :
+                rateLimit = 896;
+                break;
+        case GT_BURST_1M :
+                rateLimit = 1000;
+                break;
+        case GT_BURST_1500K :
+                rateLimit = 1500;
+                break;
+        case GT_BURST_2M :
+                rateLimit = 2000;
+                break;
+        case GT_BURST_4M :
+                rateLimit = 4000;
+                break;
+        case GT_BURST_8M :
+                rateLimit = 8000;
+                break;
+        case GT_BURST_16M :
+                rateLimit = 16000;
+                break;
+        case GT_BURST_32M :
+                rateLimit = 32000;
+                break;
+        case GT_BURST_64M :
+                rateLimit = 64000;
+                break;
+        case GT_BURST_128M :
+                rateLimit = 128000;
+                break;
+        case GT_BURST_256M :
+                rateLimit = 256000;
+                break;
+        default :
+                return GT_BAD_PARAM;
+    }
+
+    *rLimit = rateLimit;
+    return GT_OK;
+}
+
+
+/*
+ Convert given hw Burst Rate Limit to sw defined Burst Rate Limit.
+*/
+static GT_STATUS cBurstRateLimit(GT_QD_DEV *dev, GT_U32 burstSize, GT_U32 hwLimit, GT_BURST_RATE* swLimit)
+{
+    GT_BURST_RATE sLimit, startLimit, endLimit;
+    GT_U32 rLimit, tmpLimit;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    if(hwLimit == 0)
+    {
+        *swLimit = GT_BURST_NO_LIMIT;
+        return GT_OK;
+    }
+
+    startLimit = GT_BURST_64K;
+    endLimit = GT_BURST_256M;
+
+    for(sLimit=startLimit;sLimit<=endLimit;sLimit++)
+    {
+        if((retVal = cBurstEnum2Number(dev, sLimit, &rLimit)) != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+
+        tmpLimit = GT_GET_BURST_RATE_LIMIT(burstSize,rLimit);
+
+        if(hwLimit == tmpLimit)
+        {
+            *swLimit = sLimit;
+            return GT_OK;
+        }
+    }
+
+    return GT_FAIL;
+}
+
+
+/*
+ Convert given sw defined Burst Rate to meaningful number.
+*/
+static GT_STATUS cTCPBurstRate(GT_QD_DEV *dev, GT_BURST_RATE rate, GT_U32 *data)
+{
+    GT_UNUSED_PARAM(dev);
+
+    switch(rate)
+    {
+        case GT_BURST_NO_LIMIT :
+                *data = 0; /* MAX_RATE_LIMIT; */
+                break;
+        case GT_BURST_64K :
+                *data = 0x1D00;
+                break;
+        case GT_BURST_128K :
+                *data = 0x3FFF;
+                break;
+        case GT_BURST_256K :
+                *data = 0x7FFF;
+                break;
+        case GT_BURST_384K :
+                *data = 0x7DE0;
+                break;
+        case GT_BURST_512K :
+                *data = 0x76F0;
+                break;
+        case GT_BURST_640K :
+                *data = 0x7660;
+                break;
+        case GT_BURST_768K :
+                *data = 0x7600;
+                break;
+        case GT_BURST_896K :
+                *data = 0x74EF;
+                break;
+        case GT_BURST_1M :
+                *data = 0x7340;
+                break;
+        case GT_BURST_1500K :
+                *data = 0x7300;
+                break;
+        default :
+                return GT_BAD_PARAM;
+    }
+
+    return GT_OK;
+}
+
+static GT_STATUS setEnhancedERate(GT_QD_DEV *dev, GT_LPORT port, GT_ERATE_TYPE *rateType)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+    GT_U32        rate, eDec;
+    GT_PIRL_ELIMIT_MODE        mode;
+    GT_U8        phyPort;        /* Physical port.               */
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    if((retVal = grcGetELimitMode(dev,port,&mode)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    if (mode == GT_PIRL_ELIMIT_FRAME)
+    {
+        /* Count Per Frame */
+        rate = rateType->fRate;
+
+        if (rate == 0) /* disable egress rate limit */
+        {
+            eDec = 0;
+            data = 0;
+        }
+        else if((rate < 7600)  || (rate > 1488000))
+        {
+            return GT_BAD_PARAM;
+        }
+        else
+        {
+            eDec = 1;
+            data = (GT_U16)GT_GET_RATE_LIMIT_PER_FRAME(rate,eDec);
+        }
+    }
+    else
+    {
+        /* Count Per Byte */
+        rate = rateType->kbRate;
+
+        if(rate == 0)
+        {
+            eDec = 0;
+        }
+        else if(rate < 1000)    /* less than 1Mbps */
+        {
+            /* it should be divided by 64 */
+            if(rate % 64)
+                return GT_BAD_PARAM;
+            eDec = rate/64;
+        }
+        else if(rate <= 100000)    /* less than or equal to 100Mbps */
+        {
+            /* it should be divided by 1000 */
+            if(rate % 1000)
+                return GT_BAD_PARAM;
+            eDec = rate/1000;
+        }
+        else if(rate <= 1000000)    /* less than or equal to 1000Mbps */
+        {
+            /* it should be divided by 10000 */
+            if(rate % 10000)
+                return GT_BAD_PARAM;
+            eDec = rate/10000;
+        }
+        else
+            return GT_BAD_PARAM;
+
+        if(rate == 0)
+        {
+            data = 0;
+        }
+        else
+        {
+            data = (GT_U16)GT_GET_RATE_LIMIT_PER_BYTE(rate,eDec);
+        }
+    }
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL0,0,7,(GT_U16)eDec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16)data );
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+static GT_STATUS getEnhancedERate(GT_QD_DEV *dev, GT_LPORT port, GT_ERATE_TYPE *rateType)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        rate, eDec;
+    GT_PIRL_ELIMIT_MODE        mode;
+    GT_U8        phyPort;        /* Physical port.               */
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    if((retVal = grcGetELimitMode(dev,port,&mode)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL0,0,7,&eDec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,&rate );
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    if (mode == GT_PIRL_ELIMIT_FRAME)
+    {
+        rateType->fRate = GT_GET_RATE_LIMIT_PER_FRAME(rate,eDec);
+    }
+    else
+    {
+        /* Count Per Byte */
+        rateType->kbRate = GT_GET_RATE_LIMIT_PER_BYTE(rate,eDec);
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetLimitMode
+*
+* DESCRIPTION:
+*       This routine sets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port    - logical port number.
+*       mode     - rate control ingress limit mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetLimitMode
+(
+    IN GT_QD_DEV             *dev,
+    IN GT_LPORT          port,
+    IN GT_RATE_LIMIT_MODE    mode
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetLimitMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK )
+      return retVal;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,(GT_U16)mode );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,(GT_U16)mode );
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetLimitMode
+*
+* DESCRIPTION:
+*       This routine gets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       mode     - rate control ingress limit mode.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetLimitMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_RATE_LIMIT_MODE    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetLimitMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK )
+      return retVal;
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,&data );
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetPri3Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetPri3Rate
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetPri3Rate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK )
+      return retVal;
+
+    BOOL_2_BIT(mode,data);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,data );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,data);
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetPri3Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetPri3Rate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetPri3Rate Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK )
+      return retVal;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,&data);
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetPri2Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetPri2Rate
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetPri2Rate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK )
+      return retVal;
+
+    BOOL_2_BIT(mode,data);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,data );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,data);
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetPri2Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetPri2Rate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetPri2Rate Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK )
+      return retVal;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,&data);
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetPri1Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetPri1Rate
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetPri1Rate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK )
+      return retVal;
+
+    BOOL_2_BIT(mode,data);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,data );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,data);
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetPri1Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetPri1Rate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetPri1Rate Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK )
+      return retVal;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,&data);
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetPri0Rate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port    - logical port number.
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*             will be discarded after the ingress rate selected is reached
+*             or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetPri0Rate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_PRI0_RATE    rate
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U32            rateLimit, tmpLimit;
+
+    DBG_INFO(("grcSetPri0Rate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK )
+      return retVal;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        dev->devStorage &= ~(GT_RATE_ENUM_NOT_USED);
+        switch(rate)
+        {
+            case GT_NO_LIMIT :
+                    rateLimit = 0; /* MAX_RATE_LIMIT; */
+                    break;
+            case GT_128K :
+                    rateLimit = 128;
+                    break;
+            case GT_256K :
+                    rateLimit = 256;
+                    break;
+            case GT_512K :
+                    rateLimit = 512;
+                    break;
+            case GT_1M :
+                    rateLimit = 1000;
+                    break;
+            case GT_2M :
+                    rateLimit = 2000;
+                    break;
+            case GT_4M :
+                    rateLimit = 4000;
+                    break;
+            case GT_8M :
+                    rateLimit = 8000;
+                    break;
+            case GT_16M :
+                    rateLimit = 16000;
+                    break;
+            case GT_32M :
+                    rateLimit = 32000;
+                    break;
+            case GT_64M :
+                    rateLimit = 64000;
+                    break;
+            case GT_128M :
+                    rateLimit = 128000;
+                    break;
+            case GT_256M :
+                    rateLimit = 256000;
+                    break;
+            default :
+                    rateLimit = (GT_U32)rate;
+                    dev->devStorage |= GT_RATE_ENUM_NOT_USED;
+                    break;
+        }
+
+        if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+            tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
+        else
+            tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
+
+        if((tmpLimit == 0) && (rateLimit != 0))
+            rateLimit = 1;
+        else
+            rateLimit = tmpLimit;
+
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+    else
+    {
+        switch(rate)
+        {
+            case GT_NO_LIMIT :
+            case GT_128K :
+            case GT_256K :
+            case GT_512K :
+            case GT_1M :
+            case GT_2M :
+            case GT_4M :
+            case GT_8M :
+                    break;
+            default :
+                    return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,(GT_U16)rate );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetPri0Rate
+*
+* DESCRIPTION:
+*       This routine gets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*             will be discarded after the ingress rate selected is reached
+*             or exceeded.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetPri0Rate
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_PRI0_RATE    *rate
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U32            tmpLimit;
+
+    DBG_INFO(("grcGetPri0Rate Called.\n"));
+
+    if(rate == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK )
+      return retVal;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,&data);
+        tmpLimit = (GT_U32)data;
+
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if(dev->devStorage & GT_RATE_ENUM_NOT_USED)
+        {
+            if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+                *rate = GT_GET_RATE_LIMIT2(tmpLimit);
+            else
+                *rate = GT_GET_RATE_LIMIT(tmpLimit);
+        }
+        else
+        {
+            cRateLimit(dev, tmpLimit, (GT_U32*)rate);
+        }
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,&data );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+        *rate = data;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetBytesCount
+*
+* DESCRIPTION:
+*       This routine sets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port      - logical port number to set.
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetBytesCount
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      limitMGMT,
+    IN GT_BOOL      countIFG,
+    IN GT_BOOL      countPre
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U16          data;           /* data for bytes count         */
+
+    DBG_INFO(("grcSetBytesCount Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK )
+      return retVal;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        BOOL_2_BIT(limitMGMT,data);
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,data );
+        if (retVal != GT_OK)
+            return retVal;
+
+        data = 0;
+        if( countIFG == GT_TRUE ) data |= 2;
+        if( countPre == GT_TRUE ) data |= 1;
+
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,data );
+    }
+    else
+    {
+        data = 0;
+        if(    limitMGMT == GT_TRUE ) data |=4;
+        if(     countIFG == GT_TRUE ) data |=2;
+        if(     countPre == GT_TRUE ) data |=1;
+
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,data );
+    }
+
+       if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetBytesCount
+*
+* DESCRIPTION:
+*       This routine gets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port    - logical port number
+*
+* OUTPUTS:
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetBytesCount
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *limitMGMT,
+    IN GT_BOOL      *countIFG,
+    IN GT_BOOL      *countPre
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetBytesCount Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK )
+      return retVal;
+
+    if (limitMGMT == NULL || countIFG == NULL || countPre == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+       *limitMGMT = *countIFG = *countPre = GT_FALSE;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,&data );
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        BIT_2_BOOL(data,*limitMGMT);
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,&data );
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if( data & 0x2 ) *countIFG = GT_TRUE;
+        if( data & 0x1 ) *countPre = GT_TRUE;
+
+    }
+    else
+    {
+
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,&data );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if ( data & 4 ) *limitMGMT = GT_TRUE;
+        if ( data & 2 ) *countIFG  = GT_TRUE;
+        if ( data & 1 ) *countPre  = GT_TRUE;
+
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetEgressRate
+*
+* DESCRIPTION:
+*       This routine sets the port's egress data limit.
+*
+*
+* INPUTS:
+*       port      - logical port number.
+*       rateType  - egress data rate limit (GT_ERATE_TYPE union type).
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061,
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+GT_STATUS grcSetEgressRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_ERATE_TYPE   *rateType
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U32            rateLimit, tmpLimit;
+    GT_EGRESS_RATE  rate;
+
+    DBG_INFO(("grcSetEgressRate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_EGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK )
+      return retVal;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    {
+        return setEnhancedERate(dev,port,rateType);
+    }
+
+    rate = rateType->definedRate;
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        dev->devStorage &= ~(GT_RATE_ENUM_NOT_USED);
+        switch(rate)
+        {
+            case GT_NO_LIMIT :
+                    rateLimit = 0; /* MAX_RATE_LIMIT; */
+                    break;
+            case GT_128K :
+                    rateLimit = 128;
+                    break;
+            case GT_256K :
+                    rateLimit = 256;
+                    break;
+            case GT_512K :
+                    rateLimit = 512;
+                    break;
+            case GT_1M :
+                    rateLimit = 1000;
+                    break;
+            case GT_2M :
+                    rateLimit = 2000;
+                    break;
+            case GT_4M :
+                    rateLimit = 4000;
+                    break;
+            case GT_8M :
+                    rateLimit = 8000;
+                    break;
+            case GT_16M :
+                    rateLimit = 16000;
+                    break;
+            case GT_32M :
+                    rateLimit = 32000;
+                    break;
+            case GT_64M :
+                    rateLimit = 64000;
+                    break;
+            case GT_128M :
+                    rateLimit = 128000;
+                    break;
+            case GT_256M :
+                    rateLimit = 256000;
+                    break;
+            default :
+                    rateLimit = (GT_U32)rate;
+                    dev->devStorage |= GT_RATE_ENUM_NOT_USED;
+                    break;
+        }
+
+        if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+            tmpLimit = GT_GET_RATE_LIMIT3(rateLimit);
+        else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+            tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
+        else
+            tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
+
+        if((tmpLimit == 0) && (rateLimit != 0))
+            rateLimit = 1;
+        else
+            rateLimit = tmpLimit;
+
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+    else
+    {
+        switch(rate)
+        {
+            case GT_NO_LIMIT :
+            case GT_128K :
+            case GT_256K :
+            case GT_512K :
+            case GT_1M :
+            case GT_2M :
+            case GT_4M :
+            case GT_8M :
+                    break;
+            default :
+                    return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,(GT_U16)rate );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetEgressRate
+*
+* DESCRIPTION:
+*       This routine gets the port's egress data limit.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       rateType  - egress data rate limit (GT_ERATE_TYPE union type).
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061,
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+GT_STATUS grcGetEgressRate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_ERATE_TYPE  *rateType
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U32            tmpLimit,tmpRate;
+
+    DBG_INFO(("grcGetEgressRate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_EGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK )
+      return retVal;
+
+    if(rateType == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    {
+        return getEnhancedERate(dev,port,rateType);
+    }
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,&data );
+        tmpLimit = (GT_U32)data;
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if(dev->devStorage & GT_RATE_ENUM_NOT_USED)
+        {
+            if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+                (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+                tmpRate = GT_GET_RATE_LIMIT3(tmpLimit);
+            else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+                tmpRate = GT_GET_RATE_LIMIT2(tmpLimit);
+            else
+                tmpRate = GT_GET_RATE_LIMIT(tmpLimit);
+            rateType->kbRate = tmpRate;
+        }
+        else
+        {
+            cRateLimit(dev, tmpLimit, &tmpRate);
+            rateType->definedRate = (GT_EGRESS_RATE)tmpRate;
+        }
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,&data );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        rateType->definedRate = (GT_EGRESS_RATE)data;
+    }
+
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*       bsize    - burst size.
+*       rate    - ingress data rate limit. These frames will be discarded after
+*                the ingress rate selected is reached or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*                                Minimum rate for Burst Size 24K byte is 128Kbps
+*                                Minimum rate for Burst Size 48K byte is 256Kbps
+*                                Minimum rate for Burst Size 96K byte is 512Kbps
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetBurstRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_BURST_SIZE   bsize,
+    IN GT_BURST_RATE   rate
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U32            rateLimit;
+    GT_U32            burstSize =0;
+
+    DBG_INFO(("grcSetBurstRate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    switch (bsize)
+    {
+        case GT_BURST_SIZE_12K:
+            burstSize = 0;
+            break;
+        case GT_BURST_SIZE_24K:
+            if ((rate < GT_BURST_128K) && (rate != GT_BURST_NO_LIMIT))
+                return GT_BAD_PARAM;
+            burstSize = 1;
+            break;
+        case GT_BURST_SIZE_48K:
+            if ((rate < GT_BURST_256K) && (rate != GT_BURST_NO_LIMIT))
+                return GT_BAD_PARAM;
+            burstSize = 3;
+            break;
+        case GT_BURST_SIZE_96K:
+            if ((rate < GT_BURST_512K) && (rate != GT_BURST_NO_LIMIT))
+                return GT_BAD_PARAM;
+            burstSize = 7;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    if((retVal = cBurstEnum2Number(dev, rate, &rateLimit)) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    rateLimit = GT_GET_BURST_RATE_LIMIT(burstSize,rateLimit);
+
+    rateLimit |= (GT_U32)(burstSize << 12);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,15,(GT_U16)rateLimit );
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcGetBurstRate
+*
+* DESCRIPTION:
+*       This routine retrieves the port's ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       bsize    - burst size.
+*       rate    - ingress data rate limit. These frames will be discarded after
+*                the ingress rate selected is reached or exceeded.
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetBurstRate
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BURST_SIZE   *bsize,
+    OUT GT_BURST_RATE   *rate
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U32            rateLimit, burstSize;
+    GT_U16            data;
+
+    DBG_INFO(("grcGetBurstRate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,15,&data);
+    rateLimit = (GT_U32)data;
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    burstSize = rateLimit >> 12;
+    rateLimit &= 0x0FFF;
+
+    retVal = cBurstRateLimit(dev, burstSize, rateLimit, rate);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    switch (burstSize)
+    {
+        case 0:
+            *bsize = GT_BURST_SIZE_12K;
+            break;
+        case 1:
+            *bsize = GT_BURST_SIZE_24K;
+            break;
+        case 3:
+            *bsize = GT_BURST_SIZE_48K;
+            break;
+        case 7:
+            *bsize = GT_BURST_SIZE_96K;
+            break;
+        default:
+            return GT_BAD_VALUE;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetTCPBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's TCP/IP ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*       rate    - ingress data rate limit for TCP/IP packets. These frames will
+*                be discarded after the ingress rate selected is reached or exceeded.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*                                Valid rate is GT_BURST_NO_LIMIT, or between
+*                                64Kbps and 1500Kbps.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetTCPBurstRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_BURST_RATE   rate
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U32            rateLimit;
+
+    DBG_INFO(("grcSetTCPBurstRate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    if((retVal = cTCPBurstRate(dev, rate, &rateLimit)) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,15,(GT_U16)rateLimit );
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetTCPBurstRate
+*
+* DESCRIPTION:
+*       This routine sets the port's TCP/IP ingress data limit based on burst size.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for TCP/IP packets. These frames will
+*                be discarded after the ingress rate selected is reached or exceeded.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_VALUE        - register value is not known
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetTCPBurstRate
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BURST_RATE   *rate
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U32            rateLimit;
+    GT_U32            data;
+    GT_U16            u16Data;
+    GT_BURST_RATE sLimit, startLimit, endLimit;
+
+    DBG_INFO(("grcGetTCPBurstRate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,15,&u16Data);
+    data = (GT_U32)u16Data;
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    if ((data & 0xFFF) == 0)
+    {
+        *rate = GT_BURST_NO_LIMIT;
+        return GT_OK;
+    }
+
+    startLimit = GT_BURST_64K;
+    endLimit = GT_BURST_1500K;
+
+    for(sLimit=startLimit;sLimit<=endLimit;sLimit++)
+    {
+        if((retVal = cTCPBurstRate(dev, sLimit, &rateLimit)) != GT_OK)
+        {
+            break;
+        }
+
+        if(rateLimit == data)
+        {
+            *rate = sLimit;
+            return GT_OK;
+        }
+    }
+
+    DBG_INFO(("Fail to find TCP Rate.\n"));
+    return GT_BAD_VALUE;
+}
+
+
+/*******************************************************************************
+* grcSetVidNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables VID None Rate Limit (NRL).
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetVidNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetVidNrlEn Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the VidNrlEn mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,15,1,data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcGetVidNrlEn
+*
+* DESCRIPTION:
+*       This routine gets VID None Rate Limit (NRL) mode.
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetVidNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetVidNrlEn Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the VidNrlEn mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,15,1,&data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetSaNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables SA None Rate Limit (NRL).
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetSaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetSaNrlEn Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the SaNrlEn mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,14,1,data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcGetSaNrlEn
+*
+* DESCRIPTION:
+*       This routine gets SA None Rate Limit (NRL) mode.
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetSaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetSaNrlEn Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SaNrlEn mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,14,1,&data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetDaNrlEn
+*
+* DESCRIPTION:
+*       This routine enables/disables DA None Rate Limit (NRL).
+*        When DA NRL is enabled and the destination address of a frame results in
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates
+*        Non Rate Limited, then the frame will not be ingress nor egress rate
+*        limited.
+*
+* INPUTS:
+*       port - logical port number.
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetDaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetDaNrlEn Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the DaNrlEn mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,13,1,data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcGetDaNrlEn
+*
+* DESCRIPTION:
+*       This routine gets SA None Rate Limit (NRL) mode.
+*        When DA NRL is enabled and the destination address of a frame results in
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates
+*        Non Rate Limited, then the frame will not be ingress nor egress rate
+*        limited.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetDaNrlEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetDaNrlEn Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DaNrlEn mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,13,1,&data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetELimitMode
+*
+* DESCRIPTION:
+*       This routine sets Egress Rate Limit counting mode.
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*
+* INPUTS:
+*       port - logical port number
+*        mode - GT_PIRL_ELIMIT_MODE enum type
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetELimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_ELIMIT_MODE        mode
+)
+{
+    GT_U16            data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetELimitMode Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    {
+        if(mode == GT_PIRL_ELIMIT_FRAME)
+            return GT_NOT_SUPPORTED;
+    }
+
+    data = (GT_U16)mode & 0x3;
+
+    /* Set the Elimit mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_EGRESS_RATE_CTRL,14,2,data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcGetELimitMode
+*
+* DESCRIPTION:
+*       This routine gets Egress Rate Limit counting mode.
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes:
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*
+* INPUTS:
+*       port - logical port number
+*
+* OUTPUTS:
+*        mode - GT_PIRL_ELIMIT_MODE enum type
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcGetELimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_ELIMIT_MODE        *mode
+)
+{
+    GT_U16            data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetELimitMode Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Elimit mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_EGRESS_RATE_CTRL,14,2,&data);
+    if(retVal != GT_OK)
+       {
+        DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *mode = data;
+
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetRsvdNrlEn
+*
+* DESCRIPTION:
+*       This routine sets Reserved Non Rate Limit.
+*        When this feature is enabled, frames that match the requirements of the
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non
+*        rate limited.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Reserved Non Rate Limit,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS grcSetRsvdNrlEn
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("grcSetRsvdNrlEn Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the RsvdNrl bit.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,4,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcGetRsvdNrlEn
+*
+* DESCRIPTION:
+*       This routine gets Reserved Non Rate Limit.
+*        When this feature is enabled, frames that match the requirements of the
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non
+*        rate limited.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Reserved Non Rate Limit,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS grcGetRsvdNrlEn
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("grcGetRsvdNrlEn Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the RsvdNrl bit.            */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,4,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetFrameOverhead
+*
+* DESCRIPTION:
+*       Egress rate frame overhead adjustment.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
+*
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
+*
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
+*
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
+*
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
+*
+* INPUTS:
+*       port     - logical port number.
+*       overhead - Frame overhead (0 ~ 15)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS grcSetFrameOverhead
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT            port,
+    IN GT_32            overhead
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetFrameOverhead Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (overhead > 15)
+    {
+        DBG_INFO(("GT_BAD_PARAM \n"));
+        return GT_BAD_PARAM;
+    }
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL0,8,4,(GT_U16)overhead );
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetFrameOverhead
+*
+* DESCRIPTION:
+*       Egress rate frame overhead adjustment.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
+*
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
+*
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
+*
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
+*
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       overhead - Frame overhead (0 ~ 15)
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+*******************************************************************************/
+GT_STATUS grcGetFrameOverhead
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_32    *overhead
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetFrameOverhead Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL0,8,4,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *overhead = (GT_U32)data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortRmon.c
@@ -0,0 +1,1244 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtPortCounter.c
+*
+* DESCRIPTION:
+*       API definitions for RMON counters
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* STATS operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS statsOperationPerform
+(
+    IN   GT_QD_DEV            *dev,
+    IN   GT_STATS_OPERATION   statsOp,
+    IN   GT_U8                port,
+    IN   GT_STATS_COUNTERS    counter,
+    OUT  GT_VOID              *statsData
+);
+
+static GT_STATUS statsCapture
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_U8      port
+);
+
+static GT_STATUS statsReadCounter
+(
+    IN   GT_QD_DEV        *dev,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
+);
+
+static GT_STATUS statsReadRealtimeCounter
+(
+    IN   GT_QD_DEV      *dev,
+    IN   GT_U8             port,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
+);
+
+
+/*******************************************************************************
+* gstatsFlushAll
+*
+* DESCRIPTION:
+*       Flush All counters for all ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushAll
+(
+        IN GT_QD_DEV  *dev
+)
+{
+    GT_STATUS           retVal;
+
+    DBG_INFO(("gstatsFlushAll Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_FLUSH_ALL,0,0,NULL);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsFlushPort
+*
+* DESCRIPTION:
+*       Flush All counters for a given port.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushPort
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT      port
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsFlushPort Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_FLUSH_PORT,hwPort,0,NULL);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsGetPortCounter
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS    counter,
+    OUT GT_U32            *statsData
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsGetPortCounter Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Gigabit Switch does not support this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters
+*
+* DESCRIPTION:
+*       This routine gets all counters of the given port
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters
+(
+    IN  GT_QD_DEV               *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET    *statsCounterSet
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsGetPortAllCounters Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Gigabit Switch does not support this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsGetPortCounter2
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter2
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS2    counter,
+    OUT GT_U32            *statsData
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsGetPortCounters2 Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters2
+*
+* DESCRIPTION:
+*        This routine gets all counters of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters2
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET2    *statsCounterSet
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsGetPortAllCounters2 Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsGetPortCounter3
+*
+* DESCRIPTION:
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch and Spinnaker family
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter3
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT GT_U32            *statsData
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsGetPortCounters3 Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Only 88E6093 Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters3
+*
+* DESCRIPTION:
+*        This routine gets all counters of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        This function supports Gigabit Switch and Spinnaker family
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters3
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET3    *statsCounterSet
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsGetPortAllCounters3 Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsGetHistogramMode
+*
+* DESCRIPTION:
+*        This routine gets the Histogram Counters Mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY,
+*                    and GT_COUNT_RX_TX)
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetHistogramMode
+(
+    IN  GT_QD_DEV                *dev,
+    OUT GT_HISTOGRAM_MODE    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gstatsGetHistogramMode Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the Histogram mode bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,10,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *mode = data - 1; /* Software definition starts from 0 ~ 2,
+                        while hardware supports the values from 1 to 3 */
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gstatsSetHistogramMode
+*
+* DESCRIPTION:
+*        This routine sets the Histogram Counters Mode.
+*
+* INPUTS:
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY,
+*                    and GT_COUNT_RX_TX)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstatsSetHistogramMode
+(
+    IN GT_QD_DEV                 *dev,
+    IN GT_HISTOGRAM_MODE        mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gstatsSetHistogramMode Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (mode)
+    {
+        case GT_COUNT_RX_ONLY:
+        case GT_COUNT_TX_ONLY:
+        case GT_COUNT_RX_TX:
+            break;
+        default:
+            DBG_INFO(("Failed.\n"));
+            return GT_BAD_PARAM;
+    }
+
+    data = (GT_U16)mode + 1;
+
+    /* Set the Histogram mode bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_STATS_OPERATION,10,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gstatsGetRealtimePortCounter
+*
+* DESCRIPTION:
+*        This routine gets a specific realtime counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetRealtimePortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT GT_U32            *statsData
+)
+{
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
+
+    DBG_INFO(("gstatsGetRealtimePortCounter Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = statsOperationPerform(dev,STATS_READ_REALTIME_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* statsOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all stats control functions, and is responsible
+*       to write the required operation into the stats registers.
+*
+* INPUTS:
+*       statsOp       - The stats operation bits to be written into the stats
+*                     operation register.
+*       port        - port number
+*       counter     - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       statsData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static GT_STATUS statsOperationPerform
+(
+    IN   GT_QD_DEV            *dev,
+    IN   GT_STATS_OPERATION   statsOp,
+    IN   GT_U8                port,
+    IN   GT_STATS_COUNTERS    counter,
+    OUT  GT_VOID              *statsData
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data,histoData; /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U32 statsCounter;
+    GT_U32 lastCounter;
+    GT_U16            portNum;
+
+    gtSemTake(dev,dev->statsRegsSem,OS_WAIT_FOREVER);
+
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))))
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+        lastCounter = (GT_U32)STATS2_Late;
+      else
+        lastCounter = (GT_U32)STATS_OutDiscards;
+    }
+    else
+    {
+        lastCounter = (GT_U32)STATS3_Late;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
+    {
+        portNum = (port + 1) << 5;
+    }
+    else
+    {
+        portNum = (GT_U16)port;
+    }
+
+    /* Wait until the stats in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->statsRegsSem);
+        return retVal;
+      }
+      histoData = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->statsRegsSem);
+            return retVal;
+        }
+    }
+
+    /* Get the Histogram mode bit.                */
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->statsRegsSem);
+        return retVal;
+    }
+
+#endif
+    histoData &= 0xC00;
+
+    /* Set the STAT Operation register */
+    switch (statsOp)
+    {
+        case STATS_FLUSH_ALL:
+            data = (1 << 15) | (GT_STATS_FLUSH_ALL << 12) | histoData;
+            retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+            gtSemGive(dev,dev->statsRegsSem);
+            return retVal;
+
+        case STATS_FLUSH_PORT:
+            data = (1 << 15) | (GT_STATS_FLUSH_PORT << 12) | portNum | histoData;
+            retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+            gtSemGive(dev,dev->statsRegsSem);
+            return retVal;
+
+        case STATS_READ_COUNTER:
+            retVal = statsCapture(dev,port);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            retVal = statsReadCounter(dev,counter,(GT_U32*)statsData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+            break;
+
+        case STATS_READ_REALTIME_COUNTER:
+            retVal = statsReadRealtimeCounter(dev,port,counter,(GT_U32*)statsData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            break;
+
+        case STATS_READ_ALL:
+            retVal = statsCapture(dev,port);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            for(statsCounter=0; statsCounter<=lastCounter; statsCounter++)
+            {
+                retVal = statsReadCounter(dev,statsCounter,((GT_U32*)statsData + statsCounter));
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->statsRegsSem);
+                    return retVal;
+                }
+            }
+            break;
+
+        default:
+
+            gtSemGive(dev,dev->statsRegsSem);
+            return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->statsRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* statsCapture
+*
+* DESCRIPTION:
+*       This function is used to capture all counters of a port.
+*
+* INPUTS:
+*       port        - port number
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*        If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsCapture
+(
+    IN GT_QD_DEV            *dev,
+    IN GT_U8             port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data, histoData;/* Data to be set into the      */
+                                    /* register.                    */
+    GT_U16            portNum;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
+    {
+        portNum = (port + 1) << 5;
+    }
+    else
+    {
+        portNum = (GT_U16)port;
+    }
+
+    /* Get the Histogram mode bit.                */
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    histoData &= 0xC00;
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+    data = (1 << 15) | (GT_STATS_CAPTURE_PORT << 12) | portNum | histoData;
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* statsReadCounter
+*
+* DESCRIPTION:
+*       This function is used to read a captured counter.
+*
+* INPUTS:
+*       counter     - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       statsData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*        If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsReadCounter
+(
+    IN   GT_QD_DEV      *dev,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
+)
+{
+    GT_STATUS   retVal;         /* Functions return value.            */
+    GT_U16      data, histoData;/* Data to be set into the  register. */
+#ifndef GT_RMGMT_ACCESS
+    GT_U16    counter3_2;     /* Counter Register Bytes 3 & 2       */
+    GT_U16    counter1_0;     /* Counter Register Bytes 1 & 0       */
+#endif
+
+    /* Get the Histogram mode bit.                */
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    histoData &= 0xC00;
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+    data = (GT_U16)((1 << 15) | (GT_STATS_READ_COUNTER << 12) | counter | histoData);
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_STATS_COUNTER3_2;
+      regAccess.rw_reg_list[1].data = 0;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_STATS_COUNTER1_0;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+      *statsData = (regAccess.rw_reg_list[1].data << 16) | regAccess.rw_reg_list[2].data;
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *statsData = (counter3_2 << 16) | counter1_0;
+#endif
+
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* statsReadRealtimeCounter
+*
+* DESCRIPTION:
+*       This function is used to read a realtime counter.
+*
+* INPUTS:
+*       port     - port to be accessed
+*       counter  - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       statsData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*        If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsReadRealtimeCounter
+(
+    IN   GT_QD_DEV      *dev,
+    IN   GT_U8             port,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
+)
+{
+    GT_STATUS   retVal;         /* Functions return value.            */
+    GT_U16      data, histoData;/* Data to be set into the  register. */
+    GT_U16    counter3_2;     /* Counter Register Bytes 3 & 2       */
+    GT_U16    counter1_0;     /* Counter Register Bytes 1 & 0       */
+
+    /* Get the Histogram mode bit.                */
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    histoData &= 0xC00;
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+    data = (GT_U16)((1 << 15) | (GT_STATS_READ_COUNTER << 12) | ((port+1) << 5) | counter | histoData);
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+       }
+#endif
+
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *statsData = (counter3_2 << 16) | counter1_0;
+
+    return GT_OK;
+
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortStat.c
@@ -0,0 +1,391 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPortStat.c
+*
+* DESCRIPTION:
+*       API implementation for switch port rx/tx counters.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gprtSetCtrMode
+*
+* DESCRIPTION:
+*       This routine sets the port rx/tx counters mode of operation.
+*
+* INPUTS:
+*       mode  - the counter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetCtrMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_CTR_MODE  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gprtSetCtrMode Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,(GT_U16)mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("gprtSetCtrMode Failed .\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("gprtSetCtrMode OK .\n"));
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtClearAllCtr
+*
+* DESCRIPTION:
+*       This routine clears all port rx/tx counters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtClearAllCtr
+(
+    IN GT_QD_DEV    *dev
+)
+{
+    IN GT_STATUS     retVal;         /* Functions return value.      */
+    IN GT_U16        mode;           /* hold counters current mode   */
+
+    DBG_INFO(("gprtClearAllCtr Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* get counter current mode  */
+    if(hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,&mode) != GT_OK)
+    {
+        DBG_INFO(("Failed (Get field).\n"));
+        return GT_FAIL;
+    }
+    /* write opposite value to reset counter */
+    if(hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,(GT_U16)(1 - mode)) != GT_OK)
+    {
+        DBG_INFO(("Failed (Get field).\n"));
+        return GT_FAIL;
+    }
+    /* restore counters mode */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,mode);
+
+    DBG_INFO(("OK.\n"));
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPortCtr
+*
+* DESCRIPTION:
+*       This routine gets the port rx/tx counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortCtr
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT    *ctr
+)
+{
+    GT_U16          count;          /* counters current value       */
+    GT_U8           hwPort;         /* physical port number         */
+
+    DBG_INFO(("gprtGetPortCtr Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(ctr  == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* get rx counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_RX_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read Rx).\n"));
+        return GT_FAIL;
+    }
+    ctr->rxCtr = count;
+    /* get tx counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_TX_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read Tx).\n"));
+        return GT_FAIL;
+    }
+    ctr->txCtr = count;
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        /* get dropped counter value  */
+        if(hwReadPortReg(dev,hwPort, QD_REG_DROPPED_COUNTER, &count) != GT_OK)
+        {
+            DBG_INFO(("Failed (Read Tx).\n"));
+            return GT_FAIL;
+        }
+        ctr->dropped = count;
+    }
+    else
+        ctr->dropped = 0;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGetPortCtr2
+*
+* DESCRIPTION:
+*       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortCtr2
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT2   *ctr
+)
+{
+#ifndef GT_RMGMT_ACCESS
+    GT_U16          count;          /* counters current value       */
+#endif
+    GT_U8           hwPort;         /* physical port number         */
+
+    DBG_INFO(("gprtGetPortCtr2 Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(ctr  == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 4;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INDISCARD_LO_COUNTER;
+      regAccess.rw_reg_list[0].data = 0;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_INDISCARD_HI_COUNTER;
+      regAccess.rw_reg_list[1].data = 0;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_INFILTERED_COUNTER;
+      regAccess.rw_reg_list[2].data = 0;
+      regAccess.rw_reg_list[3].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[3].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[3].reg = QD_REG_OUTFILTERED_COUNTER;
+      regAccess.rw_reg_list[3].data = 0;
+      if(hwAccessMultiRegs(dev, &regAccess) != GT_OK)
+      {
+        return GT_FAIL;
+      }
+        ctr->inDiscardLo = qdLong2Short(regAccess.rw_reg_list[0].data);
+        ctr->inDiscardHi = qdLong2Short(regAccess.rw_reg_list[1].data);
+        ctr->inFiltered = qdLong2Short(regAccess.rw_reg_list[2].data);
+        ctr->outFiltered = qdLong2Short(regAccess.rw_reg_list[3].data);
+    }
+#else
+    /* get InDiscard Low counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_INDISCARD_LO_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read inDiscardLo).\n"));
+        return GT_FAIL;
+    }
+    ctr->inDiscardLo = count;
+    /* get InDiscard High counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_INDISCARD_HI_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read inDiscardHi).\n"));
+        return GT_FAIL;
+    }
+    ctr->inDiscardHi = count;
+
+    /* get InFiltered counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_INFILTERED_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read inFiltered).\n"));
+        return GT_FAIL;
+    }
+    ctr->inFiltered = count;
+
+    /* get OutFiltered counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_OUTFILTERED_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read outFiltered).\n"));
+        return GT_FAIL;
+    }
+    ctr->outFiltered = count;
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+#ifdef DEBUG_FEATURE /* this is a debug feature*/
+/*******************************************************************************
+* gprtGetPortQueueCtr
+*
+* DESCRIPTION:
+*       This routine gets the port queue counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortQueueCtr
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_Q_STAT  *ctr
+)
+{
+    GT_U16          count;          /* counters current value       */
+    GT_U8           hwPort;         /* physical port number         */
+
+    DBG_INFO(("gprtGetPortQueueCtr Called.\n"));
+
+    if(ctr  == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* get queue counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_Q_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read Rx).\n"));
+        return GT_FAIL;
+    }
+
+    /* the fist 5 bits(4:0) are OutQ_Size */
+    ctr->OutQ_Size = count & 0x1F;
+
+    /* the Rsv_Size are bits 15:8 */
+    ctr->Rsv_Size  = count >> 8;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+#endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPortStatus.c
@@ -0,0 +1,2235 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPortCtrl.c
+*
+* DESCRIPTION:
+*       API implementation for switch port status.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+#include <gtDrvConfig.h>
+
+typedef struct _GT_Px_MODE
+{
+    GT_BOOL miiEn;
+    GT_BOOL portMode;
+    GT_BOOL phyMode;
+    GT_PORT_SPEED_MODE speed;
+    GT_BOOL duplex;
+} GT_Px_MODE;
+
+/*******************************************************************************
+* procPx_Mode
+*
+* DESCRIPTION:
+*       This routine retrieves Px_MODE and analize it.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - Px_MODE structure
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+GT_STATUS procPx_Mode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_Px_MODE   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("procPx_Mode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,7,5,&data);
+    if (retVal != GT_OK)
+        return retVal;
+
+    if(data & 0x1)
+    {
+        /* MII Interface Enabled. */
+        mode->miiEn = GT_TRUE;        /* Mii Interface Enabled */
+
+        switch(data >> 1)
+        {
+            case 0:
+            case 1:
+            case 4:
+            case 5:
+                mode->speed = PORT_SPEED_10_MBPS;
+                mode->duplex = GT_FALSE;    /* half duplex */
+                mode->portMode = GT_FALSE;    /* not standard Mii, either SNI or 200 Mii */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 2:
+            case 6:
+                mode->speed = PORT_SPEED_10_MBPS;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_FALSE;    /* not standard Mii, either SNI or 200 Mii */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 3:
+                mode->speed = PORT_SPEED_200_MBPS;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_FALSE;    /* not standard Mii, either SNI or 200 Mii */
+                mode->phyMode = GT_FALSE;    /* MAC Mode */
+                break;
+            case 7:
+                mode->speed = PORT_SPEED_200_MBPS;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_FALSE;    /* not standard Mii, either SNI or 200 Mii */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 8:
+                mode->speed = PORT_SPEED_UNKNOWN;
+                mode->duplex = GT_FALSE;    /* half duplex */
+                mode->portMode = GT_TRUE;    /* Mii Mode */
+                mode->phyMode = GT_FALSE;    /* MAC Mode */
+                break;
+            case 9:
+                mode->speed = PORT_SPEED_UNKNOWN;
+                mode->duplex = GT_FALSE;    /* half duplex */
+                mode->portMode = GT_TRUE;    /* RMii Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 10:
+                mode->speed = PORT_SPEED_UNKNOWN;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_TRUE;    /* Mii Mode */
+                mode->phyMode = GT_FALSE;    /* MAC Mode */
+                break;
+            case 11:
+                mode->speed = PORT_SPEED_UNKNOWN;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_TRUE;    /* RMii Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 12:
+                mode->speed = PORT_SPEED_10_MBPS;
+                mode->duplex = GT_FALSE;    /* half duplex */
+                mode->portMode = GT_TRUE;    /* Mii Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 13:
+                mode->speed = PORT_SPEED_100_MBPS;
+                mode->duplex = GT_FALSE;    /* half duplex */
+                mode->portMode = GT_TRUE;    /* Mii Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 14:
+                mode->speed = PORT_SPEED_10_MBPS;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_TRUE;    /* Mii Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 15:
+                mode->speed = PORT_SPEED_100_MBPS;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_TRUE;    /* Mii Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            default:
+                return GT_FAIL;
+        }
+    }
+    else
+    {
+        /* MII Interface Disabled. */
+        mode->miiEn = GT_FALSE;
+
+        switch((data >> 1) & 0x3)
+        {
+            case 0:
+                mode->speed = PORT_SPEED_10_MBPS;
+                mode->duplex = GT_FALSE;    /* half duplex */
+                mode->portMode = GT_TRUE;    /* MII Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 1:
+                mode->speed = PORT_SPEED_100_MBPS;
+                mode->duplex = GT_FALSE;    /* half duplex */
+                mode->portMode = GT_TRUE;    /* MII Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 2:
+                mode->speed = PORT_SPEED_10_MBPS;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_TRUE;    /* MII Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            case 3:
+                mode->speed = PORT_SPEED_100_MBPS;
+                mode->duplex = GT_TRUE;        /* full duplex */
+                mode->portMode = GT_TRUE;    /* MII Mode */
+                mode->phyMode = GT_TRUE;    /* PHY Mode */
+                break;
+            default:
+                return GT_FAIL;
+        }
+    }
+
+    /* return */
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGetPartnerLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link partner pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPartnerLinkPause
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPartnerLinkPause Called.\n"));
+
+    /* Gigabit Switch does not support this status. gprtGetPauseEn is supported instead. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,15,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPauseEn
+*
+* DESCRIPTION:
+*        This routine retrives the link pause state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        If set MAC Pause (for Full Duplex flow control) is implemented in the
+*        link partner and in MyPause
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPauseEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPauseEn Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,15,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetSelfLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSelfLinkPause
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetSelfLinkPause Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,14,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetResolve
+*
+* DESCRIPTION:
+*       This routine retrives the resolve state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Done  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetResolve
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetResolve Called.\n"));
+
+    /* Gigabit Switch does not support this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,13,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetHdFlow
+*
+* DESCRIPTION:
+*        This routine retrives the half duplex flow control value.
+*        If set, Half Duplex back pressure will be used on this port if this port
+*        is in a half duplex mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHdFlow
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL     *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetHdFlow Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,13,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPHYDetect
+*
+* DESCRIPTION:
+*        This routine retrives the information regarding PHY detection.
+*        If set, An 802.3 PHY is attached to this port.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if connected or GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPHYDetect
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL     *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPHYDetect Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,12,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetPHYDetect
+*
+* DESCRIPTION:
+*        This routine sets PHYDetect bit which make PPU change its polling.
+*        PPU's pool routine uses these bits to determine which port's to poll
+*        PHYs on for Link, Duplex, Speed, and Flow Control.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        This function should not be called if gsysGetPPUState returns
+*        PPU_STATE_ACTIVE.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPHYDetect
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      state
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetPHYDetect Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the PHY Detect bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,12,1,(GT_U16)state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetLinkState
+*
+* DESCRIPTION:
+*       This routine retrives the link state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Up  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLinkState
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U8            bitNumber;
+
+    DBG_INFO(("gprtGetLinkState Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        bitNumber = 11;
+    }
+    else
+    {
+        bitNumber = 12;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,bitNumber,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetPortMode
+*
+* DESCRIPTION:
+*       This routine retrives the port mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII 10/100 or RMII 100,
+*               GT_FALSE for SNI 10 or MII 200
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_Px_MODE        pxMode;
+
+    DBG_INFO(("gprtGetPortMode Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_Px_MODE))
+    {
+        retVal = procPx_Mode(dev,port,&pxMode);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("procPx_Mode return Fail\n"));
+            return retVal;
+        }
+        *mode = pxMode.portMode;
+        return GT_OK;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,11,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPhyMode
+*
+* DESCRIPTION:
+*       This routine retrives the PHY mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII PHY Mode,
+*               GT_FALSE for MII MAC Mode
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_Px_MODE        pxMode;
+
+    DBG_INFO(("gprtGetPhyMode Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_Px_MODE))
+    {
+        retVal = procPx_Mode(dev,port,&pxMode);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("procPx_Mode return Fail\n"));
+            return retVal;
+        }
+        *mode = pxMode.phyMode;
+        return GT_OK;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,10,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetDuplex
+*
+* DESCRIPTION:
+*       This routine retrives the port duplex mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for Full  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDuplex
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U8            bitNumber;
+    GT_Px_MODE        pxMode;
+
+    DBG_INFO(("gprtGetDuplex Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_Px_MODE))
+    {
+        retVal = procPx_Mode(dev,port,&pxMode);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("procPx_Mode return Fail\n"));
+            return retVal;
+        }
+        *mode = pxMode.duplex;
+        return GT_OK;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        bitNumber = 10;
+    }
+    else
+    {
+        bitNumber = 9;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,bitNumber,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetSpeed
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       speed - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for 100Mb/s  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSpeed
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *speed
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_Px_MODE        pxMode;
+
+    DBG_INFO(("gprtGetSpeed Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_Px_MODE))
+    {
+        retVal = procPx_Mode(dev,port,&pxMode);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("procPx_Mode return Fail\n"));
+            return retVal;
+        }
+        *speed = (pxMode.speed==PORT_SPEED_100_MBPS)?GT_TRUE:GT_FALSE;
+        return GT_OK;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *speed);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetSpeedMode
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_PORT_SPEED_MODE type.
+*                (PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, PORT_SPEED_10_MBPS,
+*                etc.)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSpeedMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_PORT_SPEED_MODE   *speed
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_Px_MODE        pxMode;
+
+    DBG_INFO(("gprtGetSpeed Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_Px_MODE))
+    {
+        retVal = procPx_Mode(dev,port,&pxMode);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("procPx_Mode return Fail\n"));
+            return retVal;
+        }
+        *speed = pxMode.speed;
+        return GT_OK;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        /* Get the force flow control bit.  */
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,2,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,1,&data);
+    }
+
+    *speed = (GT_PORT_SPEED_MODE)data;
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtSetDuplex
+*
+* DESCRIPTION:
+*       This routine sets the duplex mode of MII/SNI/RMII ports.
+*
+* INPUTS:
+*       port -     the logical port number.
+*                (for FullSail, it will be port 2, and for ClipperShip,
+*                it could be either port 5 or port 6.)
+*       mode -  GT_TRUE for Full Duplex,
+*                GT_FALSE for Half Duplex.
+*
+* OUTPUTS: None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDuplex
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDuplex Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MII_DUPLEX_CONFIG)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* check if phy is not configurable. */
+    if(IS_CONFIGURABLE_PHY(dev, hwPort))
+    {
+        /*
+         * phy is configurable. this function is not for the port where phy
+         * can be configured.
+         */
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set the duplex mode. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,9,1,(GT_U16)mode);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetHighErrorRate
+*
+* DESCRIPTION:
+*        This routine retrives the PCS High Error Rate.
+*        This routine returns GT_TRUE if the rate of invalid code groups seen by
+*        PCS has exceeded 10 to the power of -11.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHighErrorRate
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetHighErrorRate Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS) || IS_IN_DEV_GROUP(dev,DEV_200BASE_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the high error rate bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetMGMII
+*
+* DESCRIPTION:
+*        SERDES Interface mode. When this bit is cleared to a zero and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be SGMII.  When this bit is set to a one and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be MGMII. When no PHY is detected on this port and the
+*        SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMGMII
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetMGMII Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the high error rate bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,&data);
+
+    /* translate binary to BOOL  */
+    if (IS_IN_DEV_GROUP(dev,DEV_MGMII_REVERSE_STATUS))
+    {
+        BIT_2_BOOL_R(data, *state);
+    }
+    else
+    {
+        BIT_2_BOOL(data, *state);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetMGMII
+*
+* DESCRIPTION:
+*        SERDES Interface mode. When this bit is cleared to a zero and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be MGMII. When no PHY is detected on this port and the
+*        SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*        state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMGMII
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetMGMII Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_MGMII_REVERSE_STATUS))
+    {
+        BOOL_2_BIT_R(state,data);
+    }
+    else
+    {
+        BOOL_2_BIT(state,data);
+    }
+
+    /* Get the high error rate bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetTxPaused
+*
+* DESCRIPTION:
+*        This routine retrives Transmit Pause state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTxPaused
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetTxPaused Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FC_STATUS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the TxPaused bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,5,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetFlowCtrl
+*
+* DESCRIPTION:
+*        This routine retrives Flow control state.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Rx MAC determines that no more data should be
+*                    entering this port.
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFlowCtrl
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetFlowCtrl Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FC_STATUS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the FlowCtrl bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,4,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetFdFlowDis
+*
+* DESCRIPTION:
+*        This routine retrives the read time value of the Full Duplex Flow Disable.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Full Duplex Flow Disable.
+*                   GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFdFlowDis
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetFdFlowDis Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FC_DIS_STATUS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the FdFlowDis bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,3,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetHdFlowDis
+*
+* DESCRIPTION:
+*        This routine retrives the read time value of the Half Duplex Flow Disable.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Half Duplex Flow Disable.
+*                   GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHdFlowDis
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetHdFlowDis Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FC_DIS_STATUS))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the HdFlowDis bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,2,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPxMode
+*
+* DESCRIPTION:
+*        This routine retrives 4 bits of Px_MODE Configuration value.
+*        If speed and duplex modes are forced, the returned mode value would be
+*        different from the configuration pin values.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - Px_MODE configuration value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPxMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_U32      *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPxMode Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_Px_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the Px_Mode bits.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,4,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *mode = (GT_U32) data;
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetMiiInterface
+*
+* DESCRIPTION:
+*        This routine retrives Mii Interface Mode.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if Mii Interface is enabled,
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMiiInterface
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetMiiInterface Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_Px_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the Mii bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,7,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetOutQSize
+*
+* DESCRIPTION:
+*        This routine gets egress queue size counter value.
+*        This counter reflects the current number of Egress buffers switched to
+*        this port. This is the total number of buffers across all four priority
+*        queues.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        count - egress queue size counter value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetOutQSize
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *count
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetOutQSize Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_OUT_Q_SIZE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get OutQ_Size.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_Q_COUNTER_TABLE))
+    {
+        if((retVal = hwWritePortReg(dev,hwPort, QD_REG_Q_COUNTER, 0x8000)) != GT_OK)
+            return retVal;
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,0,9,count);
+    }
+    else if (IS_IN_DEV_GROUP(dev,DEV_OUT_Q_512))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,7,9,count);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,8,8,count);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetBufHigh
+*
+* DESCRIPTION:
+*        Output from QC telling the MAC that it should perform Flow Control.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        bufHigh - GT_TRUE, if Flow control required
+*                  GT_FALSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetBufHigh
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *bufHigh
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16            data;
+
+    DBG_INFO(("gprtGetBufHigh Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FULL_Q_COUNTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get BufHigh.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_Q_COUNTER_TABLE))
+    {
+        if((retVal = hwWritePortReg(dev,hwPort, QD_REG_Q_COUNTER, 0x9000)) != GT_OK)
+            return retVal;
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,1,1,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,6,1,&data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *bufHigh);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetFcEn
+*
+* DESCRIPTION:
+*        Input into the QC telling it that Flow Control is enabled on this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        fcEn - GT_TRUE, if Flow control is enabled
+*               GT_FALSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFcEn
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *fcEn
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16            data;
+
+    DBG_INFO(("gprtGetFcEn Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FULL_Q_COUNTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get FcEn.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_Q_COUNTER_TABLE))
+    {
+        if((retVal = hwWritePortReg(dev,hwPort, QD_REG_Q_COUNTER, 0xa000)) != GT_OK)
+            return retVal;
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,0,1,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,5,1,&data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *fcEn);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetRsvSize
+*
+* DESCRIPTION:
+*        This routine gets Ingress reserved queue size counter.
+*        This counter reflects the current number of reserved ingress buffers
+*        assigned to this port.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        count - reserved ingress queue size counter value
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetRsvSize
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *count
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetRsvSize Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_OUT_Q_SIZE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get Rsv_Size.            */
+    if (IS_IN_DEV_GROUP(dev,DEV_Q_COUNTER_TABLE))
+    {
+        if((retVal = hwWritePortReg(dev,hwPort, QD_REG_Q_COUNTER, 0x9000)) != GT_OK)
+            return retVal;
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,0,9,count);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,0,5,count);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetQSizePerQPri
+*
+* DESCRIPTION:
+*        This routine gets egress queue size for port's each QPri (0 ~ 3).
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        counts - egress queue size per QPri (should be 4 * 16bytes)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetQSizePerQPri
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *counts
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetQSizePerQPri Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_Q_COUNTER_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal = hwWritePortReg(dev,hwPort, QD_REG_Q_COUNTER, 0x800)) != GT_OK)
+        return retVal;
+
+    if((retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,0,9,&counts[0])) != GT_OK)
+        return retVal;
+
+    if((retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,0,9,&counts[1])) != GT_OK)
+        return retVal;
+
+    if((retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,0,9,&counts[2])) != GT_OK)
+        return retVal;
+
+    if((retVal = hwGetPortRegField(dev,hwPort, QD_REG_Q_COUNTER,0,9,&counts[3])) != GT_OK)
+        return retVal;
+
+    DBG_INFO(("OK.\n"));
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetC_Duplex
+*
+* DESCRIPTION:
+*        This routine retrives Port 9's duplex configuration mode determined
+*        at reset.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - GT_TRUE if configured as Full duplex operation
+*                  GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetC_Duplex
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetC_Duplex Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the C_Duplex bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,3,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetC_Mode
+*
+* DESCRIPTION:
+*        This routine retrives port's interface type configuration mode
+*        determined at reset.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        state - one of value in GT_PORT_CONFIG_MODE enum type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetC_Mode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PORT_CONFIG_MODE   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetC_Mode Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the C_Mode bits.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,0,3,&data);
+
+    /* translate binary to BOOL  */
+    *state = (GT_PORT_CONFIG_MODE)data;
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtPriTable.c
@@ -0,0 +1,1110 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPriTable.c
+*
+* DESCRIPTION:
+*       API definitions for Priority Override Table
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gsysSetQPriOverrideTable
+*
+* DESCRIPTION:
+*       Queue Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysSetQPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data,qPri;
+
+    DBG_INFO(("gsysSetQPriOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    if (IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
+    {
+        data = fType << 8;
+
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+        data &= ((1 << 7) | (3 << 4));    /* keep QPriAvb information */
+    }
+    else
+        data = 0;
+
+    if (entry->qPriEn)
+        qPri = (GT_U16)((1 << 3) | (entry->qPriority & 0x3));
+    else
+        qPri = 0;
+
+    data |= (GT_U16)((1 << 15) | (fType << 8) | qPri);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetQPriOverrideTable
+*
+* DESCRIPTION:
+*       Queue Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysGetQPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetQPriOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    data = fType << 8;
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    if (data & (1 << 3))
+    {
+        entry->qPriEn = GT_TRUE;
+        entry->qPriority = data & 0x3;
+    }
+    else
+    {
+        entry->qPriEn = GT_FALSE;
+        entry->qPriority = data & 0x3; /* no meaning, but just in case */
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetFPriOverrideTable
+*
+* DESCRIPTION:
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysSetFPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_FPRI_TBL_ENTRY    *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data,fPri;
+
+    DBG_INFO(("gsysSetFPriOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    if (entry->fPriEn)
+        fPri = (GT_U16)((1 << 3) | (entry->fPriority & 0x7));
+    else
+        fPri = 0;
+
+    data = (GT_U16)((1 << 15) | (fType << 8) | fPri | 0x1000);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetQPriOverrideTable
+*
+* DESCRIPTION:
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_BAD_PARAM     - on unknown frame type
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysGetFPriOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_FPRI_TBL_ENTRY    *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetFPriOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    data = (fType << 8) | 0x1000;
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    if (data & (1 << 3))
+    {
+        entry->fPriEn = GT_TRUE;
+        entry->fPriority = data & 0x7;
+    }
+    else
+    {
+        entry->fPriEn = GT_FALSE;
+        entry->fPriority = data & 0x7; /* no meaning, but just in case */
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetQPriAvbOverrideTable
+*
+* DESCRIPTION:
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysSetQPriAvbOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data,qPri;
+
+    DBG_INFO(("gsysSetQPriAvbOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    data = fType << 8;
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    data &= ((1 << 3) | (3 << 0));    /* keep QPri information */
+
+    if (entry->qPriEn)
+        qPri = (GT_U16)((1 << 7) | ((entry->qPriority & 0x3) << 4));
+    else
+        qPri = 0;
+
+    data |= (GT_U16)((1 << 15) | (fType << 8) | qPri);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetQPriOverrideTable
+*
+* DESCRIPTION:
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
+*
+* INPUTS:
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*
+* OUTPUTS:
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysGetQPriAvbOverrideTable
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetQPriAvbOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    data = fType << 8;
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    if (data & (1 << 7))
+    {
+        entry->qPriEn = GT_TRUE;
+        entry->qPriority = (data >> 4) & 0x3;
+    }
+    else
+    {
+        entry->qPriEn = GT_FALSE;
+        entry->qPriority = (data >> 4) & 0x3; /* no meaning, but just in case */
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtQosMap.c
@@ -0,0 +1,2423 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtQosMap.c
+*
+* DESCRIPTION:
+*       API implementation for qos mapping.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gcosSetPortDefaultTc
+*
+* DESCRIPTION:
+*       Sets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*       trafClass - default traffic class of a port.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
+*        family supports 3 bits (0 ~ 7)
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosSetPortDefaultTc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN GT_U8      trafClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gcosSetPortDefaultTc Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK )
+      return retVal;
+
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        /* Set the default port pri.  */
+        retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,13,3,trafClass);
+    }
+    else
+    {
+        /* Set the default port pri.  */
+        retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,14,2,trafClass);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gcosGetPortDefaultTc
+*
+* DESCRIPTION:
+*       Gets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*
+* OUTPUTS:
+*       trafClass - default traffic class of a port.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
+*        family supports 3 bits (0 ~ 7)
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosGetPortDefaultTc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    OUT GT_U8     *trafClass
+)
+{
+    GT_U16            data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gcosSetPortDefaultTc Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK )
+      return retVal;
+
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        /* Get the default port pri.  */
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,13,3,&data);
+    }
+    else
+    {
+        /* Get the default port pri.  */
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,14,2,&data);
+    }
+
+    *trafClass = (GT_U8)data;
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gqosSetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine sets priority mapping rule.
+*        If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6,
+*        and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are
+*        enabled, then priority selection is made based on this setup.
+*        If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
+*        If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetPrioMapRule
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    mode
+)
+{
+    GT_U16          data;           /* temporary data buffer */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetPrioMapRule Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(mode, data);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK )
+      return retVal;
+
+    /* Set the TagIfBoth.  */
+    retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,6,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gqosGetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine gets priority mapping rule.
+*        If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6,
+*        and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are
+*        enabled, then priority selection is made based on this setup.
+*        If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
+*        If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetPrioMapRule
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetPrioMapRule Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK )
+      return retVal;
+
+    /* get the TagIfBoth.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,6,1,&data);
+    /* translate bool to binary */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gqosIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the IP priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosIpPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    en
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosIpPrioMapEn Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(en, data);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK )
+      return retVal;
+
+    /* Set the useIp.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,5,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gqosGetIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the IP priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetIpPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *en
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetIpPrioMapEn Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK )
+      return retVal;
+
+    /* Get the UseIp.  */
+    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,5,1,&data);
+    /* translate bool to binary */
+    BIT_2_BOOL(data, *en);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gqosUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the user priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosUserPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    en
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosUserPrioMapEn Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(en, data);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK )
+      return retVal;
+
+    /* Set the useTag.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,4,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gqosGetUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the user priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetUserPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *en
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetUserPrioMapEn Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK )
+      return retVal;
+
+    /* Get the UseTag.  */
+    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,4,1,&data);
+    /* translate bool to binary */
+    BIT_2_BOOL(data, *en);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gcosGetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Gets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosGetUserPrio2Tc
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     userPrior,
+    OUT GT_U8     *trClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+    GT_U16          data;           /* store the read data          */
+
+    DBG_INFO(("gcosGetUserPrio2Tc Called.\n"));
+
+    /* check if device supports this feature */
+    if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+        return GT_NOT_SUPPORTED;
+
+    /* calc the bit offset */
+    bitOffset = ((userPrior & 0x7) * 2);
+    /* Get the traffic class for the VPT.  */
+    retVal = hwGetGlobalRegField(dev,QD_REG_IEEE_PRI,bitOffset,2,&data);
+    *trClass = (GT_U8)data;
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gcosSetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Sets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority of a port.
+*       trClass   - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosSetUserPrio2Tc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_U8      userPrior,
+    IN GT_U8      trClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+
+    DBG_INFO(("gcosSetUserPrio2Tc Called.\n"));
+    /* check if device supports this feature */
+    if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+        return GT_NOT_SUPPORTED;
+
+    /* calc the bit offset */
+    bitOffset = ((userPrior & 0x7) * 2);
+    /* Set the traffic class for the VPT.  */
+    retVal = hwSetGlobalRegField(dev,QD_REG_IEEE_PRI, bitOffset,2,trClass);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gcosGetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine retrieves the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to query.
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosGetDscp2Tc
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     dscp,
+    OUT GT_U8     *trClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+    GT_U8           regOffset;      /* the reg offset in the IP tbl */
+    GT_U16          data;           /* store the read data          */
+
+    DBG_INFO(("gcosGetDscp2Tc Called.\n"));
+    /* check if device supports this feature */
+    if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+        return GT_NOT_SUPPORTED;
+
+    /* calc the bit offset */
+    bitOffset = (((dscp & 0x3f) % 8) * 2);
+    regOffset = ((dscp & 0x3f) / 8);
+    /* Get the traffic class for the IP dscp.  */
+    retVal = hwGetGlobalRegField(dev,(GT_U8)(QD_REG_IP_PRI_BASE+regOffset),
+                                 bitOffset, 2, &data);
+    *trClass = (GT_U8)data;
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gcosSetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine sets the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to map.
+*       trClass - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosSetDscp2Tc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_U8      dscp,
+    IN GT_U8      trClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+    GT_U8           regOffset;      /* the reg offset in the IP tbl */
+
+    DBG_INFO(("gcosSetDscp2Tc Called.\n"));
+    /* check if device supports this feature */
+    if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+        return GT_NOT_SUPPORTED;
+
+    /* calc the bit offset */
+    bitOffset = (((dscp & 0x3f) % 8) * 2);
+    regOffset = ((dscp & 0x3f) / 8);
+    /* Set the traffic class for the IP dscp.  */
+    retVal = hwSetGlobalRegField(dev,(GT_U8)(QD_REG_IP_PRI_BASE+regOffset),
+                                 bitOffset, 2, trClass);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gqosGetTagRemap
+*
+* DESCRIPTION:
+*        Gets the remapped priority value for a specific 802.1p priority on a
+*        given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*        pri   - 802.1p priority
+*
+* OUTPUTS:
+*        remappedPri - remapped Priority
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetTagRemap
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U8        pri,
+    OUT GT_U8       *remappedPri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* store the read data          */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U8           regAddr;        /* register address.            */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+
+    DBG_INFO(("gqosGetTagRemap Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    if (pri <= 3)
+    {
+        regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
+    }
+    else
+    {
+        regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
+    }
+
+    /* calc the bit offset */
+    bitOffset = 4 * (pri % 4);
+
+    retVal = hwGetPortRegField(dev,phyPort,regAddr,bitOffset,3,&data );
+
+    *remappedPri = (GT_U8)data;
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetTagRemap
+*
+* DESCRIPTION:
+*        Sets the remapped priority value for a specific 802.1p priority on a
+*        given port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*        pri   - 802.1p priority
+*        remappedPri - remapped Priority
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetTagRemap
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_U8        pri,
+    IN GT_U8        remappedPri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U8           regAddr;        /* register address.            */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+
+    DBG_INFO(("gqosSetTagRemap Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    if (pri <= 3)
+    {
+        regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
+    }
+    else
+    {
+        regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
+    }
+
+    /* calc the bit offset */
+    bitOffset = 4 * (pri % 4);
+
+    retVal = hwSetPortRegField(dev,phyPort,regAddr,bitOffset,3,remappedPri);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetQPriValue
+*
+* DESCRIPTION:
+*       This routine sets Queue priority value to used when forced.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
+*
+* INPUTS:
+*       port - the logical port number.
+*       pri  - Queue priority value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 3
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosSetQPriValue
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_U8      pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetQPriValue Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (pri > 3)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    /* Set the QPriValue.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 2, (GT_U16)pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosGetQPriValue
+*
+* DESCRIPTION:
+*       This routine gets Queue priority value to used when forced.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       pri  - Queue priority value
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosGetQPriValue
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_U8      *pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16            data;
+
+    DBG_INFO(("gqosGetQPriValue Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the QPriValue.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 2, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *pri = (GT_U8)data;
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetForceQPri
+*
+* DESCRIPTION:
+*       This routine enables/disables forcing Queue priority.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE, to force Queue Priority,
+*               GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosSetForceQPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_BOOL    en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetQPriValue Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(en, data);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set the ForceQPri.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 9, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosGetForceQPri
+*
+* DESCRIPTION:
+*       This routine checks if forcing Queue priority is enabled.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       en   - GT_TRUE, to force Queue Priority,
+*               GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosGetForceQPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *en
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetQPriValue Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the ForceQPri.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 9, 1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetDefFPri
+*
+* DESCRIPTION:
+*       This routine sets the default frame priority (0 ~ 7).
+*        This priority is used as the default frame priority (FPri) to use when
+*        no other priority information is available.
+*
+* INPUTS:
+*       port - the logical port number
+*       pri  - default frame priority
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 7
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosSetDefFPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_U8      pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetDefFPri Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (pri > 7)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    /* Set the DefFPri.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PVID, 13, 3, (GT_U16)pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosGetDefFPri
+*
+* DESCRIPTION:
+*       This routine gets the default frame priority (0 ~ 7).
+*        This priority is used as the default frame priority (FPri) to use when
+*        no other priority information is available.
+*
+* INPUTS:
+*       port - the logical port number
+*
+* OUTPUTS:
+*       pri  - default frame priority
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gqosGetDefFPri
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_U8      *pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16            data;
+
+    DBG_INFO(("gqosGetDefFPri Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DefFPri.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PVID, 13, 3, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *pri = (GT_U8)data;
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetVIDFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetVIDFPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetVIDFPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the VIDFPriOverride mode.            */
+       retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosGetVIDFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetVIDFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetVIDFPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the VIDFPriOverride mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetSAFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Source Address(SA) Frame Priority Override.
+*        When this feature is enabled, SA Frame priority overrides can occur on
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetSAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetSAFPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the SAFPriOverride mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosGetSAFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Source Address(SA) Frame Priority Override.
+*        When this feature is enabled, SA Frame priority overrides can occur on
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetSAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetSAFPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SAFPriOverride mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosSetDAFPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Frame Priority Override.
+*        When this feature is enabled, DA Frame priority overrides can occur on
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetDAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetDAFPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the DAFPriOverride mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosGetDAFPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Destination Address(DA) Frame Priority Override.
+*        When this feature is enabled, DA Frame priority overrides can occur on
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined frame
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetDAFPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetDAFPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DAFPriOverride mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetVIDQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetVIDQPriOverride
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetVIDQPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the VIDQPriOverride mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,3,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosGetVIDQPriOverride
+*
+* DESCRIPTION:
+*        This routine gets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the
+*        VTU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetVIDQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetVIDQPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the VIDQPriOverride mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,3,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetSAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Source Address(SA) Queue Priority Override.
+*        When this feature is enabled, SA Queue priority overrides can occur on
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetSAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetSAQPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the SAQPriOverride mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,2,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosGetSAQPriOverride
+*
+* DESCRIPTION:
+*        This routine gets Source Address(SA) Queue Priority Override.
+*        When this feature is enabled, SA Queue priority overrides can occur on
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetSAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetSAQPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SAQPriOverride mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,2,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosSetDAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Queue Priority Override.
+*        When this feature is enabled, DA Queue priority overrides can occur on
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetDAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetDAQPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the DAQPriOverride mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,1,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosGetDAQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets Destination Address(DA) Queue Priority Override.
+*        When this feature is enabled, DA Queue priority overrides can occur on
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetDAQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetDAQPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DAQPriOverride mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,1,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosSetARPQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets ARP Queue Priority Override.
+*        When this feature is enabled, ARP Queue priority overrides can occur on
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetARPQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetARPQPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the ARPQPriOverride mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,0,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
+
+/*******************************************************************************
+* gqosGetARPQPriOverride
+*
+* DESCRIPTION:
+*        This routine sets ARP Queue Priority Override.
+*        When this feature is enabled, ARP Queue priority overrides can occur on
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetARPQPriOverride
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetARPQPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the ARPQPriOverride mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,0,1,&data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    BIT_2_BOOL(data, *mode);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetArpQPri
+*
+* DESCRIPTION:
+*       This routine sets ARP queue Priority to use for ARP QPri Overridden
+*        frames. When a ARP frame is received on a por tthat has its ARP
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
+*
+* INPUTS:
+*       pri - ARP Queue Priority (0 ~ 3)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 3
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gqosSetArpQPri
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gqosSetArpQPri Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (pri > 3)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    data = (GT_U16)pri;
+
+    /* Set the ArpQPri bit.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,6,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gqosGetArpQPri
+*
+* DESCRIPTION:
+*       This routine gets ARP queue Priority to use for ARP QPri Overridden
+*        frames. When a ARP frame is received on a por tthat has its ARP
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       pri - ARP Queue Priority (0 ~ 3)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gqosGetArpQPri
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_U8     *pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gqosGetArpQPri Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the ArpQPri bit.            */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,6,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *pri = (GT_U8)data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSerdesCtrl.c
@@ -0,0 +1,287 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtSerdesCtrl.h
+*
+* DESCRIPTION:
+* API definitions for Phy Serdes control facility.
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 10 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtVct.h>
+#include <gtSem.h>
+
+
+/*******************************************************************************
+* gprtGetSerdesMode
+*
+* DESCRIPTION:
+*       This routine reads Serdes Interface Mode.
+*
+* INPUTS:
+*        port -  The physical SERDES device address(4/5)
+*
+* OUTPUTS:
+*       mode    - Serdes Interface Mode
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       logical port number is supported only for the devices made production
+*       before 2009.
+*  (Serdes devices: 88E6131, 88E6122, 88E6108, 88E6161, 88E6165 and 88E352 family)
+*
+*******************************************************************************/
+GT_STATUS gprtGetSerdesMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE *mode
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+
+
+    DBG_INFO(("gprtGetSerdesMode Called.\n"));
+
+    if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if input is logical port number */
+    hwPort = GT_LPORT_2_PORT(port);
+    GT_GET_SERDES_PORT(dev,&hwPort);
+
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Get Phy Register. */
+    if(hwGetPhyRegField(dev,hwPort,16,0,2,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *mode = u16Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetSerdesMode
+*
+* DESCRIPTION:
+*       This routine sets Serdes Interface Mode.
+*
+* INPUTS:
+*       port -  The physical SERDES device address(4/5)
+*       mode    - Serdes Interface Mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       logical port number is supported only for the devices made production
+*       before 2009.
+*  (Serdes devices: 88E6131, 88E6122, 88E6108, 88E6161, 88E6165 and 88E352 family)
+*
+*******************************************************************************/
+GT_STATUS gprtSetSerdesMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE mode
+)
+{
+    GT_U16          u16Data;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS    retVal;
+
+    DBG_INFO(("gprtSetSerdesMode Called.\n"));
+
+    if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if input is logical port number */
+    hwPort = GT_LPORT_2_PORT(port);
+    GT_GET_SERDES_PORT(dev,&hwPort);
+
+    u16Data = mode;
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Set Phy Register. */
+    if(hwSetPhyRegField(dev,hwPort,16,0,2,u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    retVal = hwPhyReset(dev,hwPort,0xFF);
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+
+#if 0
+/*******************************************************************************
+* gprtGetSerdesReg
+*
+* DESCRIPTION:
+*       This routine reads Phy Serdes Registers.
+*
+* INPUTS:
+*       port -    The logical port number.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSerdesReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtGetSerdesReg_mad(dev, port, regAddr, data);
+#endif
+
+    DBG_INFO(("gprtGetSerdesReg Called.\n"));
+
+    if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if input is logical port number */
+    hwPort = GT_LPORT_2_PORT(port);
+    GT_GET_SERDES_PORT(dev,&hwPort);
+
+    if(hwPort > dev->maxPhyNum)
+    {
+        /* check if input is physical serdes address */
+        if(dev->validSerdesVec & (1<<port))
+        {
+            hwPort = (GT_U8)port;
+        }
+        else
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Get Phy Register. */
+    if(hwGetPhyRegField(dev,hwPort,16,0,2,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *mode = u16Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gprtSetSerdesReg
+*
+* DESCRIPTION:
+*       This routine writes Phy Serdes Registers.
+*
+* INPUTS:
+*       port -    The logical port number.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetSerdesReg
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+        return gprtSetSerdesReg_mad(dev, port, regAddr, data);
+#endif
+
+    DBG_INFO(("gprtSetSerdesReg Called.\n"));
+
+/*    hwPort = GT_LPORT_2_PHY(port); */
+    hwPort = qdLong2Char(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Write to Phy Register */
+    if(hwWritePhyReg(dev,hwPort,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+#endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysConfig.c
@@ -0,0 +1,1301 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtSysConfig.c
+*
+* DESCRIPTION:
+*       API definitions for system configuration, and enabling.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 4 $
+*
+*******************************************************************************/
+
+#include <msApi.h>
+#include <msApiPrototype.h>
+#include <gtDrvConfig.h>
+#include <gtSem.h>
+#include <platformDeps.h>
+#ifdef GT_USE_MAD
+#include "madApi.h"
+#include "madApiDefs.h"
+#endif
+#include <gtHwCntl.h>
+
+extern GT_U8 lport2port(IN GT_U16 portVec, IN GT_LPORT  port);
+extern GT_LPORT port2lport(IN GT_U16 portVec, IN GT_U8  hwPort);
+extern GT_U32 lportvec2portvec(IN GT_U16 portVec, IN GT_U32  lVec);
+extern GT_U32 portvec2lportvec(IN GT_U16 portVec, IN GT_U32  pVec);
+static GT_BOOL gtRegister(GT_QD_DEV *qd_dev, BSP_FUNCTIONS* pBSPFunctions);
+
+#ifdef GT_USE_MAD
+static MAD_BOOL madSMIRead(MAD_DEV* dev, unsigned int smiAddr,
+              unsigned int reg, unsigned int* value)
+{
+  GT_STATUS  status;
+  GT_U16 data;
+  status =     hwReadPhyReg((GT_QD_DEV *)(dev->swDev), smiAddr, reg, &data);
+
+  if(status == GT_OK)
+  {
+    *value = data;
+    return MAD_TRUE;
+  }
+  else
+    return MAD_FALSE;
+}
+
+static MAD_BOOL madSMIWrite(MAD_DEV* dev, unsigned int smiAddr,
+              unsigned int reg, unsigned int value)
+{
+  GT_STATUS  status;
+  GT_U16 data;
+
+  data = value;
+  status =     hwWritePhyReg((GT_QD_DEV *)(dev->swDev), smiAddr, reg, data);
+
+  if(status == GT_OK)
+    return MAD_TRUE;
+  else
+    return MAD_FALSE;
+}
+
+static char * madGetDeviceName ( MAD_DEVICE_ID deviceId)
+{
+
+    switch (deviceId)
+    {
+        case MAD_88E10X0: return ("MAD_88E10X0 ");
+        case MAD_88E10X0S: return ("MAD_88E10X0S ");
+        case MAD_88E1011: return ("MAD_88E1011 ");
+        case MAD_88E104X: return ("MAD_88E104X ");
+        case MAD_88E1111: return ("MAD_88E1111/MAD_88E1115 ");
+        case MAD_88E1112: return ("MAD_88E1112 ");
+        case MAD_88E1116: return ("MAD_88E1116/MAD_88E1116R ");
+        case MAD_88E114X: return ("MAD_88E114X ");
+        case MAD_88E1149: return ("MAD_88E1149 ");
+        case MAD_88E1149R: return ("MAD_88E1149R ");
+        case MAD_SWG65G : return ("MAD_SWG65G ");
+        case MAD_88E1181: return ("MAD_88E1181 ");
+        case MAD_88E3016: return ("MAD_88E3015/MAD_88E3016/MAD_88E3018/MAD_88E3019 ");
+/*        case MAD_88E3019: return ("MAD_88E3019 "); */
+        case MAD_88E1121: return ("MAD_88E1121/MAD_88E1121R ");
+        case MAD_88E3082: return ("MAD_88E3082/MAD_88E3083 ");
+        case MAD_88E1240: return ("MAD_88E1240 ");
+        case MAD_88E1340S: return ("MAD_88E1340S ");
+        case MAD_88E1340: return ("MAD_88E1340 ");
+        case MAD_88E1340M: return ("MAD_88E1340M ");
+        case MAD_88E1119R: return ("MAD_88E1119R ");
+        case MAD_88E1310:  return ("MAD_88E1310 ");
+        case MAD_MELODY:  return ("MAD_MELODY_PHY ");
+        case MAD_88E1540:  return ("MAD_88E1540 ");
+        case MAD_88E3183:  return ("MAD_88E3183 ");
+        case MAD_88E3061:  return ("MAD_88E3061 ");
+        case MAD_88E1510:  return ("MAD_88E1510 ");
+        case MAD_88E1548:  return ("MAD_88E1548 ");
+        default : return (" No-name ");
+    }
+} ;
+
+
+static MAD_STATUS madStart(GT_QD_DEV* qd_dev,  int smiPair)
+{
+	int port;
+    MAD_STATUS status = MAD_FAIL;
+    MAD_DEV* dev = (MAD_DEV*)&(qd_dev->mad_dev);
+    MAD_SYS_CONFIG   cfg;
+    cfg.BSPFunctions.readMii   = (FMAD_READ_MII )madSMIRead;
+    cfg.BSPFunctions.writeMii  = (FMAD_WRITE_MII )madSMIWrite;
+    cfg.BSPFunctions.semCreate = NULL;
+    cfg.BSPFunctions.semDelete = NULL;
+    cfg.BSPFunctions.semTake   = NULL;
+    cfg.BSPFunctions.semGive   = NULL;
+
+    dev->swDev = (void *)qd_dev;
+	cfg.smiBaseAddr = smiPair;  /* Set SMI Address */
+	cfg.switchType = MAD_SYS_SW_TYPE_NO;
+	if((qd_dev->deviceId==GT_88E6320)||
+	   (qd_dev->deviceId==GT_88E6310)||
+	   (qd_dev->deviceId==GT_88E6310)||
+	   (qd_dev->deviceId==GT_88E6310))
+	{
+	  cfg.switchType = MAD_SYS_SW_TYPE_1;
+	}
+
+    if((status=mdLoadDriver(&cfg, dev)) != MAD_OK)
+    {
+        return status;
+    }
+    dev->phyInfo.swPhyType = 1;  /* The Phy is part of switch*/
+
+	/* to set parameters to ports of phy ports added in switch*/
+	for (port=dev->numOfPorts; port < qd_dev->maxPhyNum; port++)
+      dev->phyInfo.hwMode[port] = dev->phyInfo.hwMode[0];
+    dev->numOfPorts = qd_dev->maxPhyNum;
+/*    dev->numOfPorts = qd_dev->numOfPorts; */
+
+    DBG_INFO(("Device Name   : %s\n", madGetDeviceName(dev->deviceId)));
+    DBG_INFO(("Device ID     : 0x%x\n",dev->deviceId));
+    DBG_INFO(("Revision      : 0x%x\n",dev->revision));
+    DBG_INFO(("Base Reg Addr : 0x%x\n",dev->baseRegAddr));
+/*    DBG_INFO(("No of Ports   : %d\n",dev->numOfPorts)); */
+    DBG_INFO(("No of Ports   : %d\n",qd_dev->maxPhyNum));
+    DBG_INFO(("QD dev        : %x\n",dev->swDev));
+
+    DBG_INFO(("MAD has been started.\n"));
+
+    qd_dev->use_mad = GT_TRUE;
+    return MAD_OK;
+}
+
+/*
+static void madClose(MAD_DEV* dev)
+{
+    if (dev->devEnabled)
+        mdUnloadDriver(dev);
+}
+*/
+
+ GT_STATUS qd_madInit(GT_QD_DEV    *dev, int phyAddr)
+{
+  MAD_STATUS    status;
+
+
+  status = madStart(dev, phyAddr);
+  if (MAD_OK != status)
+  {
+        DBG_INFO(("sMAD Initialization Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+  }
+
+  return GT_OK;
+}
+
+#endif /* GT_USE_MAD */
+
+/*******************************************************************************
+* qdLoadDriver
+*
+* DESCRIPTION:
+*       QuarterDeck Driver Initialization Routine.
+*       This is the first routine that needs be called by system software.
+*       It takes *cfg from system software, and retures a pointer (*dev)
+*       to a data structure which includes infomation related to this QuarterDeck
+*       device. This pointer (*dev) is then used for all the API functions.
+*
+* INPUTS:
+*       cfg  - Holds device configuration parameters provided by system software.
+*
+* OUTPUTS:
+*       dev  - Holds device information to be used for each API call.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_ALREADY_EXIST    - if device already started
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*     qdUnloadDriver is also provided to do driver cleanup.
+*
+*******************************************************************************/
+GT_STATUS qdLoadDriver
+(
+    IN  GT_SYS_CONFIG   *cfg,
+    OUT GT_QD_DEV    *dev
+)
+{
+    GT_STATUS   retVal;
+    GT_LPORT    port;
+
+    DBG_INFO(("qdLoadDriver Called.\n"));
+
+    /* Check for parameters validity        */
+    if(dev == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Check for parameters validity        */
+    if(cfg == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* The initialization was already done. */
+    if(dev->devEnabled)
+    {
+        DBG_INFO(("QuarterDeck already started.\n"));
+        return GT_ALREADY_EXIST;
+    }
+
+#ifdef GT_PORT_MAP_IN_DEV
+    /* Modified to add port mapping functions into device ssystem configuration. */
+
+    if (dev->lport2port == NULL) {
+      dev->lport2port = lport2port;
+    }
+
+    if (dev->port2lport == NULL) {
+      dev->port2lport = port2lport;
+    }
+
+    if (dev->lportvec2portvec == NULL) {
+      dev->lportvec2portvec = lportvec2portvec;
+    }
+
+    if (dev->portvec2lportvec == NULL) {
+      dev->portvec2lportvec = portvec2lportvec;
+    }
+#endif
+
+    if(gtRegister(dev,&(cfg->BSPFunctions)) != GT_TRUE)
+    {
+       DBG_INFO(("gtRegister Failed.\n"));
+       return GT_FAIL;
+    }
+    dev->accessMode = (GT_U8)cfg->mode.scanMode;
+    if (dev->accessMode == SMI_MULTI_ADDR_MODE)
+    {
+        dev->baseRegAddr = 0;
+        dev->phyAddr = (GT_U8)cfg->mode.baseAddr;
+    }
+    else
+    {
+        dev->baseRegAddr = (GT_U8)cfg->mode.baseAddr;
+        dev->phyAddr = 0;
+    }
+
+
+    /* Initialize the driver    */
+    retVal = driverConfig(dev);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("driverConfig Failed.\n"));
+        return retVal;
+    }
+
+    /* Initialize dev fields.         */
+    dev->cpuPortNum = cfg->cpuPortNum;
+    dev->maxPhyNum = 5;
+    dev->devGroup = 0;
+    dev->devStorage = 0;
+    /* Assign Device Name */
+    dev->devName = 0;
+    dev->devName1 = 0;
+
+    dev->validSerdesVec = 0;
+
+    if((dev->deviceId&0xfff8)==GT_88EC000) /* device id 0xc00 - 0xc07 are GT_88EC0XX */
+      dev->deviceId=GT_88EC000;
+
+    switch(dev->deviceId)
+    {
+        case GT_88E6021:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 3;
+                dev->maxPhyNum = 2;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6021;
+                break;
+
+        case GT_88E6051:
+                dev->numOfPorts = 5;
+                dev->maxPorts = 5;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6051;
+                break;
+
+        case GT_88E6052:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6052;
+                break;
+
+        case GT_88E6060:
+                if((dev->cpuPortNum != 4)&&(dev->cpuPortNum != 5))
+                {
+                    return GT_FAIL;
+                }
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6060;
+                break;
+
+        case GT_88E6031:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 3;
+                dev->validPortVec = 0x31;    /* port 0, 4, and 5 */
+                dev->validPhyVec = 0x31;    /* port 0, 4, and 5 */
+                dev->devName = DEV_88E6061;
+                break;
+
+        case GT_88E6061:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6061;
+                break;
+
+        case GT_88E6035:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 3;
+                dev->validPortVec = 0x31;    /* port 0, 4, and 5 */
+                dev->validPhyVec = 0x31;    /* port 0, 4, and 5 */
+                dev->devName = DEV_88E6065;
+                break;
+
+        case GT_88E6055:
+                dev->numOfPorts = 5;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = 0x2F;    /* port 0,1,2,3, and 5 */
+                dev->validPhyVec = 0x2F;    /* port 0,1,2,3, and 5 */
+                dev->devName = DEV_88E6065;
+                break;
+
+        case GT_88E6065:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6065;
+                break;
+
+        case GT_88E6063:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6063;
+                break;
+
+        case GT_FH_VPN:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_FH_VPN;
+                break;
+
+        case GT_FF_EG:
+                if(dev->cpuPortNum != 5)
+                {
+                    return GT_FAIL;
+                }
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_FF_EG;
+                break;
+
+        case GT_FF_HG:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_FF_HG;
+                break;
+
+        case GT_88E6083:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 10;
+                dev->maxPhyNum = 8;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6083;
+                break;
+
+        case GT_88E6153:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6183;
+                break;
+
+        case GT_88E6181:
+                dev->numOfPorts = 8;
+                dev->maxPorts = 8;
+                dev->maxPhyNum = 8;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6181;
+                break;
+
+        case GT_88E6183:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 10;
+                dev->maxPhyNum = 10;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6183;
+                break;
+
+        case GT_88E6093:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6093;
+                break;
+
+        case GT_88E6092:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6092;
+                break;
+
+        case GT_88E6095:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6095;
+                break;
+
+        case GT_88E6045:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = 0x60F;
+                dev->validPhyVec = 0x60F;
+                dev->devName = DEV_88E6095;
+                break;
+
+        case GT_88E6097:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6097;
+                break;
+
+        case GT_88E6096:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6096;
+                break;
+
+        case GT_88E6047:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = 0x60F;
+                dev->validPhyVec = 0x60F;
+                dev->devName = DEV_88E6097;
+                break;
+
+        case GT_88E6046:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = 0x60F;
+                dev->validPhyVec = 0x60F;
+                dev->devName = DEV_88E6096;
+                break;
+
+        case GT_88E6085:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = 0x6FF;
+                dev->validPhyVec = 0x6FF;
+                dev->devName = DEV_88E6096;
+                break;
+
+        case GT_88E6152:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = 0x28F;
+                dev->validPhyVec = 0x28F;
+                dev->devName = DEV_88E6182;
+                break;
+
+        case GT_88E6155:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = 0x28F;
+                dev->validPhyVec = 0x28F;
+                dev->devName = DEV_88E6185;
+                break;
+
+        case GT_88E6182:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 10;
+                dev->maxPhyNum = 10;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6182;
+                break;
+
+        case GT_88E6185:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 10;
+                dev->maxPhyNum = 10;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6185;
+                break;
+
+        case GT_88E6121:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 8;
+                dev->maxPhyNum = 3;
+                dev->validPortVec = 0xE;    /* port 1, 2, and 3 */
+                dev->validPhyVec = 0xE;        /* port 1, 2, and 3 */
+                dev->devName = DEV_88E6108;
+                break;
+
+        case GT_88E6122:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 8;
+                dev->maxPhyNum = 16;
+                dev->validPortVec = 0x7E;    /* port 1 ~ 6 */
+                dev->validPhyVec = 0xF07E;    /* port 1 ~ 6, 12 ~ 15 (serdes) */
+                dev->validSerdesVec = 0xF000;
+                dev->devName = DEV_88E6108;
+                break;
+
+        case GT_88E6131:
+        case GT_88E6108:
+                dev->numOfPorts = 8;
+                dev->maxPorts = 8;
+                dev->maxPhyNum = 16;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->validSerdesVec = 0xF000;
+                dev->devName = DEV_88E6108;
+                break;
+
+        case GT_88E6123:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 14;
+                dev->validPortVec = 0x23;
+                dev->validPhyVec = 0x303F;
+                dev->validSerdesVec = 0x3000;
+                dev->devName = DEV_88E6161;
+                break;
+
+        case GT_88E6140:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 14;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x303F;
+                dev->validSerdesVec = 0x3000;
+                dev->devName = DEV_88E6165;
+                break;
+
+        case GT_88E6161:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 14;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x303F;
+                dev->validSerdesVec = 0x3000;
+                dev->devName = DEV_88E6161;
+                break;
+
+        case GT_88E6165:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 14;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x303F;
+                dev->validSerdesVec = 0x3000;
+                dev->devName = DEV_88E6165;
+                break;
+
+        case GT_88E6351:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName = DEV_88E6351;
+                break;
+
+        case GT_88E6175:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName1 = DEV_88E6175; /* test device group 1 */
+                break;
+
+        case GT_88E6124 :
+                dev->numOfPorts = 4;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPortVec &= ~(0x7);
+                dev->validPhyVec = 0x78;
+                dev->devName = DEV_88E6171;
+                break;
+
+        case GT_88E6171 :
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName = DEV_88E6171;
+                break;
+
+        case GT_88E6321 :
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPortVec &= ~(0x7);
+                dev->validPhyVec = 0x1F;
+                dev->devName = DEV_88E6371;
+                break;
+
+        case GT_88E6350 :
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName = DEV_88E6371;
+                break;
+
+        case GT_88EC000 :
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName1 = DEV_88EC000;
+                break;
+        case GT_88E3020:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName1 = DEV_88E3020;
+                break;
+        case GT_88E6020:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName1 = DEV_88E3020;
+                break;
+        case GT_88E6070:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName1 = DEV_88E3020;
+                break;
+        case GT_88E6071:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName1 = DEV_88E3020;
+                break;
+        case GT_88E6220:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName1 = DEV_88E3020;
+                break;
+        case GT_88E6250:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->devName1 = DEV_88E3020;
+                break;
+        case GT_88E6172:
+                dev->numOfPorts = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->validSerdesVec = 0x8000;
+                dev->devName = DEV_88E6172;
+                break;
+
+        case GT_88E6176:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x5F;
+                dev->validSerdesVec = 0x8000;
+                dev->devName = DEV_88E6176;
+                break;
+
+        case GT_88E6240:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->validSerdesVec = 0x8000;
+                dev->devName = DEV_88E6240;
+                break;
+
+        case GT_88E6352:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x1F;
+                dev->validSerdesVec = 0x8000;
+                dev->devName = DEV_88E6352;
+                break;
+
+        case GT_88E6115:
+                dev->numOfPorts = 5;
+                dev->maxPorts = 5;
+                dev->maxPhyNum = 4;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x18;
+                dev->validSerdesVec = 0x0003;
+                dev->devName1 = DEV_88E6115;
+                break;
+
+        case GT_88E6125:
+                dev->numOfPorts = 5;
+                dev->maxPorts = 5;
+                dev->maxPhyNum = 4;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x18;
+                dev->validSerdesVec = 0x0003;
+                dev->devName1 = DEV_88E6125;
+                break;
+
+        case GT_88E6310:
+                dev->numOfPorts = 5;
+                dev->maxPorts = 5;
+                dev->maxPhyNum = 4;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x18;
+                dev->validSerdesVec = 0x0003;
+                dev->devName1 = DEV_88E6310;
+                break;
+
+        case GT_88E6320:
+                dev->numOfPorts = 5;
+                dev->maxPorts = 5;
+                dev->maxPhyNum = 4;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x18;
+                dev->validSerdesVec = 0x0003;
+                dev->devName1 = DEV_88E6320;
+                break;
+
+
+        default:
+                DBG_INFO(("Unknown Device. Initialization failed\n"));
+                return GT_FAIL;
+    }
+
+    dev->cpuPortNum = GT_PORT_2_LPORT(cfg->cpuPortNum);
+
+    if(dev->cpuPortNum == GT_INVALID_PORT)
+    {
+        if(GT_LPORT_2_PORT((GT_LPORT)cfg->cpuPortNum) != GT_INVALID_PORT)
+        {
+            dev->cpuPortNum = cfg->cpuPortNum;
+        }
+        else
+        {
+            return GT_BAD_CPU_PORT;
+        }
+    }
+
+    /* Initialize the MultiAddress Register Access semaphore.    */
+    if((dev->multiAddrSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the ATU semaphore.    */
+    if((dev->atuRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the VTU semaphore.    */
+    if((dev->vtuRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the STATS semaphore.    */
+    if((dev->statsRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the PIRL semaphore.    */
+    if((dev->pirlRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the PTP semaphore.    */
+    if((dev->ptpRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the Table semaphore.    */
+    if((dev->tblRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the EEPROM Configuration semaphore.    */
+    if((dev->eepromRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the PHY Device Register Access semaphore.    */
+    if((dev->phyRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the Remote management Register Access semaphore.    */
+    if((dev->hwAccessRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the ports states to forwarding mode. */
+    if(cfg->initPorts == GT_TRUE)
+    {
+        for (port=0; port<dev->numOfPorts; port++)
+        {
+            if((retVal = gstpSetPortState(dev,port,GT_PORT_FORWARDING)) != GT_OK)
+               {
+                DBG_INFO(("Failed.\n"));
+                qdUnloadDriver(dev);
+                   return retVal;
+            }
+        }
+    }
+
+    dev->use_mad = GT_FALSE;
+#ifdef GT_USE_MAD
+	{
+	  int portPhyAddr=0;
+	  unsigned int validPhyVec = dev->validPhyVec;
+	  while((validPhyVec&1)==0)
+	  {
+        validPhyVec >>= 1;
+	    portPhyAddr++;
+	  }
+      DBG_INFO(("@@@@@@@@@@ qd_madInit\n"));
+      if((retVal = qd_madInit(dev, portPhyAddr)) != GT_OK)
+      {
+        DBG_INFO(("Initialize MAD failed.\n"));
+        qdUnloadDriver(dev);
+        return retVal;
+      }
+	}
+#endif
+
+    if(cfg->skipInitSetup == GT_SKIP_INIT_SETUP)
+    {
+        dev->devEnabled = 1;
+        dev->devNum = cfg->devNum;
+
+        DBG_INFO(("OK.\n"));
+        return GT_OK;
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_ENHANCED_CPU_PORT))
+    {
+        if((retVal = gsysSetRsvd2CpuEnables(dev,0)) != GT_OK)
+        {
+            DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+            qdUnloadDriver(dev);
+            return retVal;
+        }
+
+        if((retVal = gsysSetRsvd2Cpu(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+            qdUnloadDriver(dev);
+            return retVal;
+        }
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
+    {
+        for (port=0; port<dev->numOfPorts; port++)
+        {
+            retVal = gprtSetCPUPort(dev,port,dev->cpuPortNum);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("Failed.\n"));
+                qdUnloadDriver(dev);
+                   return retVal;
+            }
+        }
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
+    {
+        retVal = gsysSetCPUPort(dev,dev->cpuPortNum);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+            qdUnloadDriver(dev);
+               return retVal;
+        }
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    {
+        retVal = gsysSetCPUDest(dev,dev->cpuPortNum);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+            qdUnloadDriver(dev);
+               return retVal;
+        }
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
+    {
+        if((retVal = gsysSetRsvd2Cpu(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+            qdUnloadDriver(dev);
+            return retVal;
+        }
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        retVal = gpirlInitialize(dev);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+            qdUnloadDriver(dev);
+               return retVal;
+        }
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        retVal = gpirl2Initialize(dev);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+            qdUnloadDriver(dev);
+               return retVal;
+        }
+    }
+
+    dev->devEnabled = 1;
+    dev->devNum = cfg->devNum;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* sysEnable
+*
+* DESCRIPTION:
+*       This function enables the system for full operation.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       1.  This function should be called only after successful execution of
+*           qdLoadDriver().
+*
+*******************************************************************************/
+GT_STATUS sysEnable( GT_QD_DEV *dev)
+{
+    DBG_INFO(("sysEnable Called.\n"));
+    DBG_INFO(("OK.\n"));
+    return driverEnable(dev);
+}
+
+
+/*******************************************************************************
+* qdUnloadDriver
+*
+* DESCRIPTION:
+*       This function unloads the QuaterDeck Driver.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       1.  This function should be called only after successful execution of
+*           qdLoadDriver().
+*
+*******************************************************************************/
+GT_STATUS qdUnloadDriver
+(
+    IN GT_QD_DEV* dev
+)
+{
+    DBG_INFO(("qdUnloadDriver Called.\n"));
+
+    /* Delete the MultiAddress mode reagister access semaphore.    */
+    if(gtSemDelete(dev,dev->multiAddrSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the ATU semaphore.    */
+    if(gtSemDelete(dev,dev->atuRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the VTU semaphore.    */
+    if(gtSemDelete(dev,dev->vtuRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the STATS semaphore.    */
+    if(gtSemDelete(dev,dev->statsRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the PIRL semaphore.    */
+    if(gtSemDelete(dev,dev->pirlRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the PTP semaphore.    */
+    if(gtSemDelete(dev,dev->ptpRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the Table semaphore.    */
+    if(gtSemDelete(dev,dev->tblRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the EEPROM Configuration semaphore.    */
+    if(gtSemDelete(dev,dev->eepromRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the PHY Device semaphore.    */
+    if(gtSemDelete(dev,dev->phyRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+    /* Delete the Remote management Register Access semaphore.    */
+    if(gtSemDelete(dev,dev->hwAccessRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    gtMemSet(dev,0,sizeof(GT_QD_DEV));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtRegister
+*
+* DESCRIPTION:
+*       BSP should register the following functions:
+*        1) MII Read - (Input, must provide)
+*            allows QuarterDeck driver to read QuarterDeck device registers.
+*        2) MII Write - (Input, must provice)
+*            allows QuarterDeck driver to write QuarterDeck device registers.
+*        3) Semaphore Create - (Input, optional)
+*            OS specific Semaphore Creat function.
+*        4) Semaphore Delete - (Input, optional)
+*            OS specific Semaphore Delete function.
+*        5) Semaphore Take - (Input, optional)
+*            OS specific Semaphore Take function.
+*        6) Semaphore Give - (Input, optional)
+*            OS specific Semaphore Give function.
+*        Notes: 3) ~ 6) should be provided all or should not be provided at all.
+*
+* INPUTS:
+*        pBSPFunctions - pointer to the structure for above functions.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_TRUE, if input is valid. GT_FALSE, otherwise.
+*
+* COMMENTS:
+*       This function should be called only once.
+*
+*******************************************************************************/
+static GT_BOOL gtRegister(GT_QD_DEV *dev, BSP_FUNCTIONS* pBSPFunctions)
+{
+    dev->fgtReadMii =  pBSPFunctions->readMii;
+    dev->fgtWriteMii = pBSPFunctions->writeMii;
+#ifdef GT_RMGMT_ACCESS
+    dev->fgtHwAccessMod =  pBSPFunctions->hwAccessMod;
+    dev->fgtHwAccess = pBSPFunctions->hwAccess;
+#endif
+
+    dev->semCreate = pBSPFunctions->semCreate;
+    dev->semDelete = pBSPFunctions->semDelete;
+    dev->semTake   = pBSPFunctions->semTake  ;
+    dev->semGive   = pBSPFunctions->semGive  ;
+
+    return GT_TRUE;
+}
+
+static GT_U8 qd32_2_8[256] = {
+0,1,2,3,4,5,6,7,8,9,
+10,11,12,13,14,15,16,17,18,19,
+20,21,22,23,24,25,26,27,28,29,
+30,31,32,33,34,35,36,37,38,39,
+40,41,42,43,44,45,46,47,48,49,
+50,51,52,53,54,55,56,57,58,59,
+60,61,62,63,64,65,66,67,68,69,
+70,71,72,73,74,75,76,77,78,79,
+80,81,82,83,84,85,86,87,88,89,
+90,91,92,93,94,95,96,97,98,99,
+100,101,102,103,104,105,106,107,108,109,
+110,111,112,113,114,115,116,117,118,119,
+120,121,122,123,124,125,126,127,128,129,
+130,131,132,133,134,135,136,137,138,139,
+140,141,142,143,144,145,146,147,148,149,
+150,151,152,153,154,155,156,157,158,159,
+160,161,162,163,164,165,166,167,168,169,
+170,171,172,173,174,175,176,177,178,179,
+180,181,182,183,184,185,186,187,188,189,
+190,191,192,193,194,195,196,197,198,199,
+200,201,202,203,204,205,206,207,208,209,
+210,211,212,213,214,215,216,217,218,219,
+220,221,222,223,224,225,226,227,228,229,
+230,231,232,233,234,235,236,237,238,239,
+240,241,242,243,244,245,246,247,248,249,
+250,251,252,253,254,255};
+
+
+
+GT_U8 qdLong2Char(GT_U32 data)
+{
+    return qd32_2_8[data&0xff];
+}
+
+GT_U8 qdShort2Char(GT_U16 data)
+{
+    GT_U32 dataL = data;
+    return qd32_2_8[dataL&0xff];
+}
+
+GT_U16 qdLong2Short(GT_U32 data)
+{
+  GT_U32 data1= 1;
+  if( *((GT_U16 *)&data1) )
+    return *((GT_U16 *)&data);
+  else
+    return *((GT_U16 *)&data + 1);
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysCtrl.c
@@ -0,0 +1,9236 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtSysCtrl.c
+*
+* DESCRIPTION:
+*       API definitions for system global control.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+#include <gtSem.h>
+
+static GT_STATUS writeSwitchMacWolReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        baseid,
+    IN GT_ETHERADDR *mac
+);
+static GT_STATUS readSwitchMacWolReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN GT_U8        baseid,
+    OUT GT_ETHERADDR *mac
+);
+static GT_STATUS writeDiffMACWoL
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        baseid,
+    IN GT_U16       diffAddr
+);
+static GT_STATUS readDiffMACWoL
+(
+    IN  GT_QD_DEV    *dev,
+    IN GT_U8        baseid,
+    OUT GT_U16        *diffAddr
+);
+static GT_STATUS writeSwMacWolWofReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        pointer,
+    IN GT_U8        data
+);
+static GT_STATUS readSwMacWolWofReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        pointer,
+    OUT GT_U8       *data
+);
+
+static GT_STATUS writeSwitchMacReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+);
+
+static GT_STATUS readSwitchMacReg
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+);
+
+static GT_STATUS writeDiffMAC
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        diffAddr
+);
+
+static GT_STATUS readDiffMAC
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16        *diffAddr
+);
+/*******************************************************************************
+* gsysSwReset
+*
+* DESCRIPTION:
+*       This routine preforms switch software reset.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSwReset
+(
+    IN  GT_QD_DEV *dev
+)
+{
+#ifndef GT_RMGMT_ACCESS
+    GT_U16          data;           /* Used to poll the SWReset bit */
+#endif
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8            regOffset;
+
+    DBG_INFO(("gsysSwReset Called.\n"));
+
+    /* Set the Software reset bit.                  */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        regOffset = QD_REG_GLOBAL_CONTROL;
+    }
+    else
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+        regOffset = QD_REG_GLOBAL_CONTROL;
+      else
+        regOffset = QD_REG_ATU_CONTROL;
+    }
+
+    retVal = hwSetGlobalRegField(dev,regOffset,15,1,1);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = regOffset;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    /* Make sure the reset operation is completed.  */
+    data = 1;
+    while(data != 0)
+    {
+           retVal = hwGetGlobalRegField(dev,regOffset,15,1,&data);
+
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetPPUEn
+*
+* DESCRIPTION:
+*        This routine enables/disables Phy Polling Unit.
+*
+* INPUTS:
+*        en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPPUEn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                /* register.                    */
+    DBG_INFO(("gsysSetPPUEn Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the PPUEn bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetPPUEn
+*
+* DESCRIPTION:
+*        This routine get the PPU state.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPPUEn
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetPPUEn Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the GetPPUEn bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine set the Discard Excessive state.
+*
+* INPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDiscardExcessive
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetDiscardExcessive Called.\n"));
+    BOOL_2_BIT(en,data);
+
+    /* Set the Discard Exissive bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,13,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine get the Discard Excessive state.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDiscardExcessive
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL    *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetDiscardExcessive Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the Discard Exissive bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine set the Scheduling Mode.
+*
+* INPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetSchedulingMode
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL    mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetSchedulingMode Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(mode,data);
+    data = 1 - data;
+
+    /* Set the Schecduling bit.             */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,11,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine get the Scheduling Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSchedulingMode
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetSchedulingMode Called.\n"));
+    if (IS_IN_DEV_GROUP(dev, DEV_PORT_MIXED_SCHEDULE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* Get the Scheduling bit.              */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(1 - data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed.
+*
+* INPUTS:
+*       mode - GT_TRUE max size 1522,
+*               GT_FALSE max size 1535, 1632, or 2048.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Please refer to the device spec. to get the max frame size.
+*       88E6095 device supports upto 1632.
+*       88E6065/88E6061 devices support upto 2048.
+*
+*******************************************************************************/
+GT_STATUS gsysSetMaxFrameSize
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetMaxFrameSize Called.\n"));
+
+    if (IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(mode,data);
+    data = 1 - data;
+
+    /* Set the Max Fram Size bit.               */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,10,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Get the max frame size allowed.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE max size 1522,
+*               GT_FALSE max size 1535, 1632, or 2048.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Please refer to the device spec. to get the max frame size.
+*       88E6095 device supports upto 1632.
+*       88E6065/88E6061 devices support upto 2048.
+*
+*******************************************************************************/
+GT_STATUS gsysGetMaxFrameSize
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetMaxFrameSize Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Max Frame Size bit.          */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,10,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(1 - data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysReLoad
+*
+* DESCRIPTION:
+*       This routine cause to the switch to reload the EEPROM.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysReLoad
+(
+    IN  GT_QD_DEV *dev
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysReLoad Called.\n"));
+    /* Set the Reload bit.                  */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,9,1,1);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Should a check for reload completion. */
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetWatchDog
+*
+* DESCRIPTION:
+*       This routine Set the the watch dog mode.
+*
+* INPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetWatchDog
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetWatchDog Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the WatchDog bit.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,7,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetWatchDog
+*
+* DESCRIPTION:
+*       This routine Get the the watch dog mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetWatchDog
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetWatchDog Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the WatchDog bit.            */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,7,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets the full duplex pause src Mac Address.
+*        MAC address should be an Unicast address.
+*        For different MAC Addresses per port operation,
+*        use gsysSetPerPortDuplexPauseMac API.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetDuplexPauseMac
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetDuplexPauseMac Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    {
+        return writeSwitchMacReg(dev,mac);
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_MACADDR_01;
+  /* Set the first Mac register with diffAddr bit reset.  */
+      data = (((*mac).arEther[0] & 0xFE) << 8) | (*mac).arEther[1];
+      regAccess.rw_reg_list[0].data = data;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_MACADDR_23;
+  /* Set the Mac23 address register.   */
+      data = ((*mac).arEther[2] << 8) | (*mac).arEther[3];
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_MACADDR_45;
+  /* Set the Mac45 address register.   */
+      data = ((*mac).arEther[4] << 8) | (*mac).arEther[5];
+      regAccess.rw_reg_list[2].data = data;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    /* Set the first Mac register with diffAddr bit reset.  */
+    data = (((*mac).arEther[0] & 0xFE) << 8) | (*mac).arEther[1];
+    retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_01,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Set the Mac23 address register.   */
+    data = ((*mac).arEther[2] << 8) | (*mac).arEther[3];
+    retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_23,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Set the Mac45 address register.   */
+    data = ((*mac).arEther[4] << 8) | (*mac).arEther[5];
+    retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_45,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets the full duplex pause src Mac Address.
+*        For different MAC Addresses per port operation,
+*        use gsysGetPerPortDuplexPauseMac API.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetDuplexPauseMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+#ifndef GT_RMGMT_ACCESS
+    GT_U16          data;           /* Data to read from register.  */
+#endif
+
+    DBG_INFO(("gsysGetDuplexPauseMac Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    {
+        return readSwitchMacReg(dev,mac);
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_MACADDR_01;
+      regAccess.rw_reg_list[0].data = 0;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_MACADDR_23;
+      regAccess.rw_reg_list[1].data = 0;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_MACADDR_45;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      (*mac).arEther[0] = qdLong2Char((regAccess.rw_reg_list[0].data >> 8)) & ~0x01;
+      (*mac).arEther[1] = qdLong2Char(regAccess.rw_reg_list[0].data & 0xFF);
+      (*mac).arEther[2] = qdLong2Char(regAccess.rw_reg_list[1].data >> 8);
+      (*mac).arEther[3] = qdLong2Char(regAccess.rw_reg_list[1].data & 0xFF);
+      (*mac).arEther[4] = qdLong2Char(regAccess.rw_reg_list[2].data >> 8);
+      (*mac).arEther[5] = qdLong2Char(regAccess.rw_reg_list[2].data & 0xFF);
+    }
+#else
+    /* Get the Mac01 register.      */
+    retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_01,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    (*mac).arEther[0] = (data >> 8) & ~0x01;
+    (*mac).arEther[1] = data & 0xFF;
+    /* Get the Mac23 register.      */
+    retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_23,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    (*mac).arEther[2] = data >> 8;
+    (*mac).arEther[3] = data & 0xFF;
+
+    /* Get the Mac45 register.      */
+    retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_45,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    (*mac).arEther[4] = data >> 8;
+    (*mac).arEther[5] = data & 0xFF;
+#endif
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPerPortDuplexPauseMac
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL      en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetPerPortDuplexPauseMac Called.\n"));
+    BOOL_2_BIT(en,data);
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    {
+        retVal = writeDiffMAC(dev,data);
+    }
+    else
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+        retVal = writeDiffMAC(dev,data);
+      else
+        retVal = hwSetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPerPortDuplexPauseMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetPerPortDuplexPauseMac Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    {
+        retVal = readDiffMAC(dev,&data);
+    }
+    else
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+        retVal = readDiffMAC(dev,&data);
+      else
+        retVal = hwGetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,&data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetPortWakeonFrameEn
+*
+* DESCRIPTION:
+*       This routine sets port interrupt for wake on frame.
+*
+* INPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPortWakeonFrameEn
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        portVec
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetPortWakeonFrame Called.\n"));
+
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    retVal = writeSwMacWolWofReg(dev, 0x0e, portVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetPortWakeonFrameEn
+*
+* DESCRIPTION:
+*       This routine gets port interrupt enable for wake on frame.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPortWakeonFrameEn
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_U8       *portVec
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysGetPortWakeonFrameEn Called.\n"));
+
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    retVal = readSwMacWolWofReg(dev, 0x0e, portVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetPortWakeonFrameEnSt
+*
+* DESCRIPTION:
+*       This routine gets port interrupt status for wake on frame.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPortWakeonFrameEnSt
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_U8       *portVec
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysGetPortWakeonFrameEnSt Called.\n"));
+
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    retVal = readSwMacWolWofReg(dev, 0x0c, portVec);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetWoLMac
+*
+* DESCRIPTION:
+*       This routine sets the Wake on Lan Mac Address.
+*        MAC address should be an Unicast address.
+*        For different MAC Addresses per port operation,
+*        use gsysSetPerPortDuplexPauseMac API.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetWoLMac
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+)
+{
+    DBG_INFO(("gsysSetWoLMac Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    return writeSwitchMacWolReg(dev, 0x10, mac);
+
+}
+
+/*******************************************************************************
+* gsysGetWoLMac
+*
+* DESCRIPTION:
+*       This routine Gets the Wake on Lan Mac Address.
+*        For different MAC Addresses per port operation,
+*        use gsysGetPerPortDuplexPauseMac API.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetWoLMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+)
+{
+    DBG_INFO(("gsysGetWoLMac Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    return readSwitchMacWolReg(dev, 0x10, mac);
+}
+
+/*******************************************************************************
+* gsysSetPerPortWoLMac
+*
+* DESCRIPTION:
+*       This routine sets whether the Wake on Lan Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPerPortWoLMac
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL      en
+)
+{
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetPerPortWoLMac Called.\n"));
+    BOOL_2_BIT(en,data);
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    return writeDiffMACWoL(dev, 0x10, data);
+}
+
+/*******************************************************************************
+* gsysGetPerPortWoLMac
+*
+* DESCRIPTION:
+*       This routine Gets whether the Wake on Lanc Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPerPortWoLMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetPerPortWoLMac Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+
+    retVal = readDiffMACWoL(dev, 0x10, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetWoLPass
+*
+* DESCRIPTION:
+*       This routine sets the Wake on Lan Password Mac Address.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetWoLPass
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+)
+{
+    DBG_INFO(("gsysSetWoLPass Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    return writeSwitchMacWolReg(dev, 0x16, mac);
+
+}
+
+/*******************************************************************************
+* gsysGetWoLPass
+*
+* DESCRIPTION:
+*       This routine Gets the Wake on Lan password Mac Address.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetWoLPass
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+)
+{
+    DBG_INFO(("gsysGetWoLPass Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    return readSwitchMacWolReg(dev, 0x16, mac);
+}
+
+
+/*******************************************************************************
+* gsysReadMiiReg
+*
+* DESCRIPTION:
+*       This routine reads QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know which phy address(0 ~ 0x1F) will be read.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysReadMiiReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         phyAddr,
+    IN  GT_U32         regAddr,
+    OUT GT_U32         *data
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          u16Data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysReadMiiRegister Called.\n"));
+
+    /* Get the register data */
+    retVal = hwReadMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,&u16Data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *data = (GT_U32)u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysWriteMiiReg
+*
+* DESCRIPTION:
+*       This routine writes QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know which phy address(0 ~ 0x1F) will be read.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysWriteMiiReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         phyAddr,
+    IN  GT_U32         regAddr,
+    IN  GT_U16         data
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysWriteMiiRegister Called.\n"));
+
+    /* Set the register data */
+    retVal = hwWriteMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    return GT_OK;
+}
+#ifdef GT_RMGMT_ACCESS
+/*******************************************************************************
+* gsysAccessMultiRegs
+*
+* DESCRIPTION:
+*       This function accesses switch's registers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1
+*     addr - SMI Address
+*     reg  - Register offset
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysAccessMultiRegs
+(
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysAccessMultiReg Called.\n"));
+    /* Set the register data */
+    retVal = hwAccessMultiRegs(dev,regList);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    return GT_OK;
+}
+#endif
+
+/*******************************************************************************
+* gsysSetRetransmitMode
+*
+* DESCRIPTION:
+*       This routine set the Retransmit Mode.
+*
+* INPUTS:
+*       en - GT_TRUE Retransimt Mode is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRetransmitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetRetransmitMode Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    BOOL_2_BIT(en,data);
+
+    /* Set the Retransmit Mode bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetRetransmitMode
+*
+* DESCRIPTION:
+*       This routine get the Retransmit Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Retransmit Mode is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRetransmitMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRetransmitMode Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetLimitBackoff
+*
+* DESCRIPTION:
+*       This routine set the Limit Backoff bit.
+*
+* INPUTS:
+*       en - GT_TRUE:  uses QoS half duplex backoff operation
+*            GT_FALSE: uses normal half duplex backoff operation
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetLimitBackoff
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetLimitBackoff Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    BOOL_2_BIT(en,data);
+
+    /* Set the bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetLimitBackoff
+*
+* DESCRIPTION:
+*       This routine set the Limit Backoff bit.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE:  uses QoS half duplex backoff operation
+*            GT_FALSE: uses normal half duplex backoff operation
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetLimitBackoff
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetLimitBackoff Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRsvReqPri
+*
+* DESCRIPTION:
+*       This routine set the Reserved Queue's Requesting Priority
+*
+* INPUTS:
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvReqPri
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetRsvReqPri Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    BOOL_2_BIT(en,data);
+
+    /* Set the bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetRsvReqPri
+*
+* DESCRIPTION:
+*       This routine get the Reserved Queue's Requesting Priority
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvReqPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRsvReqPri Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* Only Gigabit Switch supports this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetCascadePort
+*
+* DESCRIPTION:
+*        This routine sets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
+*
+*        Use Cascade Port = 0xE to indicate this chip has no Cascade port.
+*        Use Cascade Port = 0xF to use Routing table (gsysGetDevRoutingTable).
+*
+* INPUTS:
+*        port - Cascade Port
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetCascadePort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysSetCascadePort Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    if((port == 0xE) || (port == 0xF))
+        data = (GT_U16)port;
+    else
+    {
+        data = (GT_U16)(GT_LPORT_2_PORT(port));
+        if (data == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
+
+    /* Set the Cascade port.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetCascadePort
+*
+* DESCRIPTION:
+*        This routine gets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
+*
+*        Use Cascade Port = 0xE to indicate this chip has no Cascade port.
+*        Use Cascade Port = 0xF to use Routing table (gsysGetDevRoutingTable).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - Cascade Port
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetCascadePort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysSetCascadePort Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Cascade port.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if((data == 0xE) || (data == 0xF))
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetDeviceNumber
+*
+* DESCRIPTION:
+*        This routine sets Device Number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip. From CPU frames whose Dev_Num
+*        fieldmatches these bits have reachedtheir destination chip and are sent
+*        out this chip using the port number indicated in the frame's Trg_Port
+*        field.
+*
+* INPUTS:
+*        devNum - Device Number (0 ~ 31)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDeviceNumber
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          devNum
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysSetDeviceNumber Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    data = ((GT_U16)devNum) & 0x1F; /* only 5 bits are valid */
+
+    /* Set the Device Number.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetDeviceNumber
+*
+* DESCRIPTION:
+*        This routine gets Device Number.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        devNum - Device Number (0 ~ 31)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDeviceNumber
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32      *devNum
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetDeviceNumber Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Device Number.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *devNum = (GT_U32)data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetCoreTagType
+*
+* DESCRIPTION:
+*        This routine sets Ether Core Tag Type.
+*        This Ether Type is added to frames that egress the switch as Double Tagged
+*        frames. It is also the Ether Type expected during Ingress to determine if
+*        a frame is Tagged or not on ports configured as UseCoreTag mode.
+*
+* INPUTS:
+*        etherType - Core Tag Type (2 bytes)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetCoreTagType
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16          etherType
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetCoreTagType Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set the Ether Type */
+    retVal = hwWriteGlobalReg(dev,QD_REG_CORETAG_TYPE,etherType);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetCoreTagType
+*
+* DESCRIPTION:
+*        This routine gets CoreTagType
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        etherType - Core Tag Type (2 bytes)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetCoreTagType
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *etherType
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetCoreTagType Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Device Number.                */
+    retVal = hwReadGlobalReg(dev,QD_REG_CORETAG_TYPE,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *etherType = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetIngressMonitorDest
+*
+* DESCRIPTION:
+*        This routine sets Ingress Monitor Destination Port. Frames that are
+*        targeted toward an Ingress Monitor Destination go out the port number
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Ingress Monitor type, and frames received on a Network port that
+*        is enabled to be the Ingress Monitor Source Port.
+*        If the Ingress Monitor Destination Port resides in this device these bits
+*        should point to the Network port where these frames are to egress. If the
+*        Ingress Monitor Destination Port resides in another device these bits
+*        should point to the Marvell Tag port in this device that is used to get
+*        to the device that contains the Ingress Monitor Destination Port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetIngressMonitorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetIngressMonitorDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)GT_LPORT_2_PORT(port);
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
+
+    /* Set the Ether Type */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, (GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetIngressMonitorDest
+*
+* DESCRIPTION:
+*        This routine gets Ingress Monitor Destination Port.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetIngressMonitorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetIngressMonitorDest Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IngressMonitorDest. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetEgressMonitorDest
+*
+* DESCRIPTION:
+*        This routine sets Egress Monitor Destination Port. Frames that are
+*        targeted toward an Egress Monitor Destination go out the port number
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Egress Monitor type, and frames transmitted on a Network port that
+*        is enabled to be the Egress Monitor Source Port.
+*        If the Egress Monitor Destination Port resides in this device these bits
+*        should point to the Network port where these frames are to egress. If the
+*        Egress Monitor Destination Port resides in another device these bits
+*        should point to the Marvell Tag port in this device that is used to get
+*        to the device that contains the Egress Monitor Destination Port.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetEgressMonitorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetEgressMonitorDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)GT_LPORT_2_PORT(port);
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
+
+    /* Set EgressMonitorDest */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, (GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetEgressMonitorDest
+*
+* DESCRIPTION:
+*        This routine gets Egress Monitor Destination Port.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetEgressMonitorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetEgressMonitorDest Called.\n"));
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the EgressMonitorDest. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetARPDest
+*
+* DESCRIPTION:
+*        This routine sets ARP Monitor Destination Port. Tagged or untagged
+*        frames ingress Network ports that have the Broadcast Destination Address
+*        with an Ethertype of 0x0806 are mirrored to this port. The ARPDest
+*        should point to the port that directs these frames to the switch's CPU
+*        that will process ARPs. This target port should be a Marvell Tag port so
+*        that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
+*        To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell
+*        Tag port will be sent to the port number defineded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP
+*        frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetARPDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetARPDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_DEST_SUPPORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
+
+    /* Set related bit */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, (GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetARPDest
+*
+* DESCRIPTION:
+*        This routine gets ARP Monitor Destination Port. Tagged or untagged
+*        frames ingress Network ports that have the Broadcast Destination Address
+*        with an Ethertype of 0x0806 are mirrored to this port. The ARPDest
+*        should point to the port that directs these frames to the switch's CPU
+*        that will process ARPs. This target port should be a Marvell Tag port so
+*        that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
+*        To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell
+*        Tag port will be sent to the port number defineded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP
+*        frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetARPDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetARPDest Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_DEST_SUPPORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*        Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one,
+*        the 16 reserved multicast DA addresses, whose bit in this register are
+*        also set to a one, are treadted as MGMT frames. All the reserved DA's
+*        take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is
+*        tested. When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2CpuEnables
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        enBits
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetRsvd2CpuEnables Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_MGMT_ENABLE, (GT_U16)enBits);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*        Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one,
+*        the 16 reserved multicast DA addresses, whose bit in this register are
+*        also set to a one, are treadted as MGMT frames. All the reserved DA's
+*        take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is
+*        tested. When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2CpuEnables
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *enBits
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysGetRsvd2CpuEnables Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related register */
+    retVal = hwReadGlobal2Reg(dev, QD_REG_MGMT_ENABLE, enBits);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRsvd2Cpu
+*
+* DESCRIPTION:
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN
+*        membership, will be considered MGMT frames and sent to the CPU Port.
+*        If device supports Rsvd2CpuEnable (gsysSetRsvd2CpuEnable function),
+*        the frame will be considered MGMT frame when the associated Rsvd2CpuEnable
+*        bit for the frames's DA is also set to a one.
+*
+* INPUTS:
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2Cpu
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetRsvd2Cpu Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    if (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
+    {
+        retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,3,1, data);
+    }
+    else
+    {
+        retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 3, 1, data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRsvd2Cpu
+*
+* DESCRIPTION:
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN
+*        membership, will be considered MGMT frames and sent to the CPU Port.
+*        If device supports Rsvd2CpuEnable (gsysSetRsvd2CpuEnable function),
+*        the frame will be considered MGMT frame when the associated Rsvd2CpuEnable
+*        bit for the frames's DA is also set to a one.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2Cpu
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetRsvd2Cpu Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    if (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,3,1,&data);
+    }
+    else
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,3,1,&data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetMGMTPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetMGMTPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetMGMTPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (pri > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 0, 3, pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetMGMTPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMGMTPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    DBG_INFO(("gsysGetMGMTPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,0,3,pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetUseDoubleTagData
+*
+* DESCRIPTION:
+*        This bit is used to determine if Double Tag data that is removed from a
+*        Double Tag frame is used or ignored when making switching decisions on
+*        the frame.
+*
+* INPUTS:
+*        en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetUseDoubleTagData
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetUseDoubleTagData Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 15, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetUseDoubleTagData
+*
+* DESCRIPTION:
+*        This bit is used to determine if Double Tag data that is removed from a
+*        Double Tag frame is used or ignored when making switching decisions on
+*        the frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetUseDoubleTagData
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetUseDoubleTagData Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetPreventLoops
+*
+* DESCRIPTION:
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev
+*        field equals this device's Device Number, the following action will be
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original
+*                        source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetPreventLoops
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetPreventLoops Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 14, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetPreventLoops
+*
+* DESCRIPTION:
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev
+*        field equals this device's Device Number, the following action will be
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original
+*                        source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPreventLoops
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetPreventLoops Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetFlowControlMessage
+*
+* DESCRIPTION:
+*        When this bit is set to one, Marvell Tag Flow Control messages will be
+*        generated when an output queue becomes congested and received Marvell Tag
+*        Flow Control messages will pause MACs inside this device. When this bit
+*        is cleared to a zero Marvell Tag Flow Control messages will not be
+*        generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFlowControlMessage
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetFlowControlMessage Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 13, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFlowControlMessage
+*
+* DESCRIPTION:
+*        When this bit is set to one, Marvell Tag Flow Control messages will be
+*        generated when an output queue becomes congested and received Marvell Tag
+*        Flow Control messages will pause MACs inside this device. When this bit
+*        is cleared to a zero Marvell Tag Flow Control messages will not be
+*        generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowControlMessage
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetFlowControlMessage Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetForceFlowControlPri
+*
+* DESCRIPTION:
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag
+*        Flow Control frames will be set to the value of the FC Pri bits (set by
+*        gsysSetFCPri function call). When this bit is cleared to a zero generated
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the
+*        frames that caused the congestion. This bit will have no effect if the
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is
+*        cleared to a zero.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetForceFlowControlPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetForceFlowControlPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 7, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetForceFlowControlPri
+*
+* DESCRIPTION:
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag
+*        Flow Control frames will be set to the value of the FC Pri bits (set by
+*        gsysSetFCPri function call). When this bit is cleared to a zero generated
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the
+*        frames that caused the congestion. This bit will have no effect if the
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is
+*        cleared to a zero.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetForceFlowControlPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetForceFlowControlPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,7,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetFCPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFCPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetFCPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (pri > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 4, 3, pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFCPri
+*
+* DESCRIPTION:
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFCPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    DBG_INFO(("gsysGetFCPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,4,3,pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetFlowCtrlDelay
+*
+* DESCRIPTION:
+*        This function sets Flow control delay time for 10Mbps, 100Mbps, and
+*        1000Mbps.
+*
+* INPUTS:
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*        delayTime - delay time.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*    Actual delay time will be delayTime x 2.048uS (or x 8.192uS) depending on
+*    switch device. Please refer to the device datasheet for detailed information.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFlowCtrlDelay
+(
+    IN GT_QD_DEV            *dev,
+    IN GT_PORT_SPEED_MODE    sp,
+    IN GT_U32                delayTime
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetFlowCtrlDelay Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_FLOWCTRL_DELAY;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    switch(sp)
+    {
+        case PORT_SPEED_10_MBPS:
+                data = 0;
+                break;
+        case PORT_SPEED_100_MBPS:
+                data = 1 << 13;
+                break;
+        case PORT_SPEED_1000_MBPS:
+                data = 2 << 13;
+                break;
+        default:
+                DBG_INFO(("GT_BAD_PARAM (sp)\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+                return GT_BAD_PARAM;
+    }
+
+    if (delayTime > 0x1FFF)
+    {
+        DBG_INFO(("GT_BAD_PARAM (delayTime)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    data |= (GT_U16)(0x8000 | delayTime);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFlowCtrlDelay
+*
+* DESCRIPTION:
+*        This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+*        1000Mbps.
+*
+* INPUTS:
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*
+* OUTPUTS:
+*        delayTime - delay time
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*    Actual delay time will be delayTime x 2.048uS (or x 8.192uS) depending on
+*    switch device. Please refer to the device datasheet for detailed information.
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowCtrlDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_PORT_SPEED_MODE    sp,
+    OUT GT_U32        *delayTime
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetFlowCtrlDelay Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_FLOWCTRL_DELAY;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    switch(sp)
+    {
+        case PORT_SPEED_10_MBPS:
+                data = 0;
+                break;
+        case PORT_SPEED_100_MBPS:
+                data = 1 << 13;
+                break;
+        case PORT_SPEED_1000_MBPS:
+                data = 2 << 13;
+                break;
+        default:
+                DBG_INFO(("GT_BAD_PARAM (sp)\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+                return GT_BAD_PARAM;
+    }
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *delayTime = (GT_U32)(data & 0x1FFF);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetDevRoutingTable
+*
+* DESCRIPTION:
+*        This function sets Device to Port mapping (which device is connected to
+*        which port of this device).
+*
+* INPUTS:
+*        devNum - target device number.
+*        portNum - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDevRoutingTable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          devNum,
+    IN GT_LPORT     port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetDevRoutingTable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    if(devNum > 0x1F)
+    {
+        DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_ROUTING_TBL;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_ROUTING_TBL;
+      /* translate LPORT to hardware port */
+      if(port >= dev->numOfPorts)
+      {
+        hwPort = 0xF;
+      }
+      else
+      {
+        hwPort = GT_LPORT_2_PORT(port);
+      }
+      data = (GT_U16)(0x8000 | (devNum << 8) | hwPort);
+      regAccess.rw_reg_list[1].data = data;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+
+    /* translate LPORT to hardware port */
+    if(port >= dev->numOfPorts)
+    {
+        hwPort = 0xF;
+    }
+    else
+    {
+        hwPort = GT_LPORT_2_PORT(port);
+    }
+
+    data = (GT_U16)(0x8000 | (devNum << 8) | hwPort);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
+#endif
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetDevRoutingTable
+*
+* DESCRIPTION:
+*        This function gets Device to Port mapping (which device is connected to
+*        which port of this device).
+*
+* INPUTS:
+*        devNum - target device number.
+*
+* OUTPUTS:
+*        portNum - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDevRoutingTable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         devNum,
+    OUT GT_LPORT     *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetDevRoutingTable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    if(devNum > 0x1F)
+    {
+        DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_ROUTING_TBL;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_ROUTING_TBL;
+      data = (GT_U16)(devNum << 8);
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_ROUTING_TBL;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+
+    data = (GT_U16)(devNum << 8);
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+
+#endif
+    gtSemGive(dev,dev->tblRegsSem);
+
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *port = GT_PORT_2_LPORT((GT_U8)(data & 0xF));
+    if(*port == GT_INVALID_PORT)
+    {
+        *port = 0xF;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetTrunkMaskTable
+*
+* DESCRIPTION:
+*        This function sets Trunk Mask for the given Trunk Number.
+*
+* INPUTS:
+*        trunkNum - Trunk Number.
+*        trunkMask - Trunk mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7 for 88E6095 and 88E6183 family and
+*                       if trunkNum > 0x3 for 88E6065 family.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkMaskTable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          trunkNum,
+    IN GT_U32        trunkMask
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U32            mask;
+
+    DBG_INFO(("gsysSetTrunkMaskTable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRUNK)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TRUNK_MASK_TBL;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_TRUNK_MASK_TBL;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    data &= 0x0800;
+
+    if(trunkNum > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    if((trunkNum > 0x3) && IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    mask = (1 << dev->numOfPorts) - 1;
+
+    if(trunkMask > mask)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkMask)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    mask = GT_LPORTVEC_2_PORTVEC(trunkMask);
+
+    data = (GT_U16)(0x8000 | data | (trunkNum << 12) | mask);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetTrunkMaskTable
+*
+* DESCRIPTION:
+*        This function gets Trunk Mask for the given Trunk Number.
+*
+* INPUTS:
+*        trunkNum - Trunk Number.
+*
+* OUTPUTS:
+*        trunkMask - Trunk mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7 for 88E6095 and 88E6183 family and
+*                       if trunkNum > 0x3 for 88E6065 family.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkMaskTable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         trunkNum,
+    OUT GT_U32        *trunkMask
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U32            mask;
+
+    DBG_INFO(("gsysGetTrunkMaskTable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRUNK)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TRUNK_MASK_TBL;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_TRUNK_MASK_TBL;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    data &= 0x0800;
+
+    if(trunkNum > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    if((trunkNum > 0x3) && IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    data = (GT_U16)(data | (trunkNum << 12));
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    mask = (1 << dev->maxPorts) - 1;
+
+    *trunkMask = GT_PORTVEC_2_LPORTVEC(data & mask);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetHashTrunk
+*
+* DESCRIPTION:
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks.
+*        When this bit is set to a one the hashed computed for address table
+*        lookups is used for the TrunkMask selection. When this bit is cleared to
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to
+*        select the TrunkMask to use.
+*
+* INPUTS:
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetHashTrunk
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetHashTrunk Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRUNK)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL, 11, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetHashTrunk
+*
+* DESCRIPTION:
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks.
+*        When this bit is set to a one the hashed computed for address table
+*        lookups is used for the TrunkMask selection. When this bit is cleared to
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to
+*        select the TrunkMask to use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetHashTrunk
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetHashTrunk Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRUNK)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetTrunkRouting
+*
+* DESCRIPTION:
+*        This function sets routing information for the given Trunk ID.
+*
+* INPUTS:
+*        trunkId - Trunk ID.
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkRouting
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          trunkId,
+    IN GT_U32        trunkRoute
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U32            mask;
+    GT_U32            maxTrunk;
+
+    DBG_INFO(("gsysSetTrunkRouting Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TRUNK_ROUTING;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
+        maxTrunk = 8;
+    else
+        maxTrunk = 16;
+
+    if(trunkId >= maxTrunk)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    mask = (1 << dev->numOfPorts) - 1;
+
+    if(trunkRoute > mask)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkRoute)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    mask = GT_LPORTVEC_2_PORTVEC(trunkRoute);
+
+    data = (GT_U16)(0x8000 | (trunkId << 11) | mask);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetTrunkRouting
+*
+* DESCRIPTION:
+*        This function retrieves routing information for the given Trunk ID.
+*
+* INPUTS:
+*        trunkId - Trunk ID.
+*
+* OUTPUTS:
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkRouting
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         trunkId,
+    OUT GT_U32        *trunkRoute
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U32            mask;
+    GT_U32            maxTrunk;
+
+    DBG_INFO(("gsysGetTrunkRouting Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
+        maxTrunk = 8;
+    else
+        maxTrunk = 16;
+
+    if(trunkId >= maxTrunk)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TRUNK_ROUTING;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_TRUNK_ROUTING;
+      data = (GT_U16)(trunkId << 11);
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_TRUNK_ROUTING;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+
+    data = (GT_U16)(trunkId << 11);
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+#endif
+    gtSemGive(dev,dev->tblRegsSem);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    mask = (1 << dev->maxPorts) - 1;
+
+    *trunkRoute = GT_PORTVEC_2_LPORTVEC(data & mask);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRateLimitMode
+*
+* DESCRIPTION:
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine sets which mode to use.
+*
+* INPUTS:
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid mode is used.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRateLimitMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_INGRESS_RATE_MODE mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetRateLimitMode Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_2))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    switch (mode)
+    {
+        case GT_RATE_PRI_BASE:
+            data = 0;
+            break;
+        case GT_RATE_BURST_BASE:
+            data = 1;
+            break;
+        default:
+            DBG_INFO(("Not supported mode %i\n",mode));
+            return GT_BAD_PARAM;
+    }
+
+    hwPort = 7;
+
+    /* Set related bit */
+    retVal = hwSetPortRegField(dev,hwPort, 0x1A, 15, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRateLimitMode
+*
+* DESCRIPTION:
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine gets which mode is being used.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRateLimitMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_INGRESS_RATE_MODE *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysGetRateLimitMode Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_2))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    hwPort = 7;
+    data = 0;
+
+    /* Get related bit */
+    retVal = hwGetPortRegField(dev,hwPort, 0x1A, 15, 1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if (data == 0)
+        *mode = GT_RATE_PRI_BASE;
+    else
+        *mode = GT_RATE_BURST_BASE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetAgeInt
+*
+* DESCRIPTION:
+*        Enable/Disable Age Refresh Interrupt. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*
+*        If the device supports Refresh Locked feature (gprtSetRefreshLocked API),
+*        the feature must not be enabled for this Miss Violation to occur.
+*
+* INPUTS:
+*        en - GT_TRUE, to enable,
+*             GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetAgeInt
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetAgeInt Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_INTERRUPT))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_2))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    BOOL_2_BIT(en, data);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_AGE_INT_GLOBAL2))
+    {
+        retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 10, 1, data);
+    }
+    else
+    {
+        hwPort = 7;
+        /* Set related bit */
+        retVal = hwSetPortRegField(dev,hwPort, 0x1A, 14, 1, data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetAgeInt
+*
+* DESCRIPTION:
+*        Get state of Age Refresh Interrupt mode. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*
+*        If the device supports Refresh Locked feature (gprtSetRefreshLocked API),
+*        the feature must not be enabled for this Miss Violation to occur.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetAgeInt
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysGetAgeInt Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_INTERRUPT))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) ||
+            ((GT_DEVICE_REV)dev->revision < GT_REV_2))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    data = 0;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_AGE_INT_GLOBAL2))
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT, 10, 1, &data);
+    }
+    else
+    {
+        hwPort = 7;
+        /* Get related bit */
+        retVal = hwGetPortRegField(dev,hwPort, 0x1A, 14, 1, &data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetForceSnoopPri
+*
+* DESCRIPTION:
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*       Priority is enabled. When it's disabled, the priority on these frames
+*        is not modified.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetForceSnoopPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetForceSnoopPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE, 7, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetForceSnoopPri
+*
+* DESCRIPTION:
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*       Priority is enabled. When it's disabled, the priority on these frames
+*        is not modified.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetForceSnoopPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetForceSnoopPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,7,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetSnoopPri
+*
+* DESCRIPTION:
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetSnoopPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetSnoopPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (pri > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE, 4, 3, pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetSnoopPri
+*
+* DESCRIPTION:
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSnoopPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    DBG_INFO(("gsysGetSnoopPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,4,3,pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetForceARPPri
+*
+* DESCRIPTION:
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri
+*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's
+*       disabled, the priority on these frames is not modified.
+*
+* INPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetForceARPPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetForceARPPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE, 3, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetForceARPPri
+*
+* DESCRIPTION:
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri
+*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's
+*       disabled, the priority on these frames is not modified.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetForceARPPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetForceARPPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,3,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetARPPri
+*
+* DESCRIPTION:
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on ARP frames.
+*
+* INPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetARPPri
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetARPPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (pri > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE, 0, 3, pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetARPPri
+*
+* DESCRIPTION:
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on ARP frames.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetARPPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    DBG_INFO(("gsysGetARPPri Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,0,3,pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetUsePortSchedule
+*
+* DESCRIPTION:
+*       This routine sets per port scheduling mode
+*
+* INPUTS:
+*       en - GT_TRUE enables per port scheduling,
+*             GT_FALSE disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetUsePortSchedule
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetWatchDog Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the UsePortSchedule bit.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetUsePortSchedule
+*
+* DESCRIPTION:
+*       This routine gets per port scheduling mode
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE enables per port scheduling,
+*             GT_FALSE disable.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetUsePortSchedule
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetWatchDog Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the UsePortSchedule bit.            */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetOldHader
+*
+* DESCRIPTION:
+*       This routine sets Egress Old Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header,
+*        the format of the Header is slightly modified to be backwards compatible
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
+*
+* INPUTS:
+*       en - GT_TRUE to enable Old Header Mode,
+*             GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetOldHader
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetArpQPri Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_OLD_HEADER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the OldHader bit.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,5,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetOldHader
+*
+* DESCRIPTION:
+*       This routine gets Egress Old Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header,
+*        the format of the Header is slightly modified to be backwards compatible
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE to enable Old Header Mode,
+*             GT_FALSE to disable
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetOldHader
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetArpQPri Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_OLD_HEADER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the OldHader bit.            */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,5,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRecursiveStrippingDisable
+*
+* DESCRIPTION:
+*       This routine determines if recursive tag stripping feature needs to be
+*        disabled.
+*
+* INPUTS:
+*       en - GT_TRUE to disable Recursive Tag Stripping,
+*             GT_FALSE to enable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRecursiveStrippingDisable
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetRecursiveStrippingDisable Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_RECURSIVE_TAG_STRIP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the RecursiveStrippingDisable bit.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,15,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetRecursiveStrippingDisable
+*
+* DESCRIPTION:
+*       This routine checks if recursive tag stripping feature is disabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE, if Recursive Tag Stripping is disabled,
+*             GT_FALSE, otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRecursiveStrippingDisable
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetRecursiveStrippingDisable Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_RECURSIVE_TAG_STRIP))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the RecursiveStrippingDisable bit.            */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data, *en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetCPUPort
+*
+* DESCRIPTION:
+*       This routine sets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped
+*        frames are destined.
+*
+* INPUTS:
+*       cpuPort - CPU Port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetCPUPort
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  cpuPort
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetCPUPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(cpuPort);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (cpuPort >= dev->numOfPorts)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    /* Set the CPU Port.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,0,3,(GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetCPUPort
+*
+* DESCRIPTION:
+*       This routine gets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped
+*        frames are destined.
+*
+* INPUTS:
+*       cpuPort - CPU Port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetCPUPort
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_LPORT  *cpuPort
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysGetCPUPort Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the CPU Port.            */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,0,3,&hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* translate hardware port to LPORT */
+    *cpuPort = (GT_LPORT)GT_PORT_2_LPORT((GT_U8)hwPort);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetCPUDest
+*
+* DESCRIPTION:
+*        This routine sets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria
+*        are mapped to the CPU Destination port, overriding where the frame would
+*        normally go. In the case of ARP, the frame will be mapped normally and it
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring
+*        will occur and ingressing To_CPU frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetCPUDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetCPUDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
+
+    /* Set related bit */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, (GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetCPUDest
+*
+* DESCRIPTION:
+*        This routine gets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria
+*        are mapped to the CPU Destination port, overriding where the frame would
+*        normally go. In the case of ARP, the frame will be mapped normally and it
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring
+*        will occur and ingressing To_CPU frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetCPUDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetCPUDest Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetMirrorDest
+*
+* DESCRIPTION:
+*        This routine sets Mirror Destination Port. Frames that ingress a port
+*        that trigger a policy mirror are mapped (copied) to this port as long as
+*        the frame is not filtered or discarded.
+*        The Mirror Destination port should point to the port that directs these
+*        frames to the CPU that will process these frames. This target port should
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU
+*        Policy Mirror frames will be discarded.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetMirrorDest
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetMirrorDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MIRROR_DEST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
+
+    /* Set related bit */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 0, 4, (GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetMirrorDest
+*
+* DESCRIPTION:
+*        This routine gets Mirror Destination Port. Frames that ingress a port
+*        that trigger a policy mirror are mapped (copied) to this port as long as
+*        the frame is not filtered or discarded.
+*        The Mirror Destination port should point to the port that directs these
+*        frames to the CPU that will process these frames. This target port should
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU
+*        Policy Mirror frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetMirrorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetMirrorDest Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 0, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetRMPort
+*
+* DESCRIPTION:
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047
+*        device allows logical port 4 and 5.
+*
+* INPUTS:
+*        port - Remote Management Port
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on unallowable port
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetRMPort Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    switch(GT_LPORT_2_PORT(port))
+    {
+        case 9:
+                data = 0;
+                break;
+        case 10:
+                data = 1;
+                break;
+        default:
+                DBG_INFO(("Not Allowed Port.\n"));
+                return GT_BAD_PARAM;
+    }
+
+    /* Set the F2R port. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,13,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRMPort
+*
+* DESCRIPTION:
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047
+*        device allows logical port 4 and 5.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - Remote Management Port
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMPort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRMPort Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the F2R port.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 1)
+    {
+        *port = GT_PORT_2_LPORT(10);
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT(9);
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRMDACheck
+*
+* DESCRIPTION:
+*        Check the DA on Remote Management frames.
+*        When DA Check is enabled, the DA of Remote Management frames must be
+*        contained in this device's address database (ATU) as a Static entry
+*        (either unicast or multicast). If the DA of the frame is not contained
+*        in this device's address database, the frame will be not be processed as
+*        a Remote Management frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not
+*        validated before processing the frame.
+*
+* INPUTS:
+*        en - GT_TRUE to enable DA Check,
+*             GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMDACheck
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetRMDACheck Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_DA_CHECK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DA_CHECK_1))
+    {
+      /* Set the DA Check bit. */
+      retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,11,1,data);
+    }
+    else
+    {
+      /* Set the DA Check bit. */
+      retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,1,data);
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRMDACheck
+*
+* DESCRIPTION:
+*        Check the DA on Remote Management frames.
+*        When DA Check is enabled, the DA of Remote Management frames must be
+*        contained in this device's address database (ATU) as a Static entry
+*        (either unicast or multicast). If the DA of the frame is not contained
+*        in this device's address database, the frame will be not be processed as
+*        a Frame-to-Regter frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not
+*        validated before processing the frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if DA Check is enabled,
+*             GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMDACheck
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRMDACheck Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_DA_CHECK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DA Check bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetHeaderType
+*
+* DESCRIPTION:
+*   To set Header Type. These bits are used to configure the bits that are placed
+*   into the Egress Header when it is enabled on a port (Port offset 0x04)
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*
+* INPUTS:
+*        hdType
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetHeaderType
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       hdType
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetHeaderType Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_HEADER_TYPE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    data = hdType&0x3;
+    /* Set the DA Check bit. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetHeaderType
+*
+* DESCRIPTION:
+*   To get Header Type. These bits are used to configure the bits that are placed
+*   into the Egress Header when it is enabled on a port (Port offset 0x04)
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        hdType
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetHeaderType
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16     *hdType
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetHeaderType Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_HEADER_TYPE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DA Check bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *hdType = data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRMEnable
+*
+* DESCRIPTION:
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*
+* INPUTS:
+*        en - GT_TRUE to enable Remote Management feature,
+*             GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMEnable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetRMEnable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the F2R En bit. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRMEnable
+*
+* DESCRIPTION:
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Remote Management feature is enabled,
+*             GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMEnable
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRMEnable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the F2R En bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRMUMode
+*
+* DESCRIPTION:
+*        Set Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10,
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote
+*        Management Response frame will be generated and sent out.
+*
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*
+* INPUTS:
+*        rmu - GT_RMU structure
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMUMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_RMU        *rmu
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U16          port;
+
+    DBG_INFO(("gsysSetRMUMode Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
+    {
+        if (rmu->rmuEn == GT_TRUE)
+        {
+            port = GT_LPORT_2_PORT(rmu->port);
+            if (port == GT_INVALID_PORT)
+                return GT_BAD_PARAM;
+
+            switch(port)
+            {
+                case 4:
+                    data = 1;
+                    break;
+                case 5:
+                    data = 2;
+                    break;
+                 case 6:
+                    if (IS_IN_DEV_GROUP(dev,DEV_88E6352_FAMILY))
+                    {
+                      data = 3;
+                      break;
+                    }
+                    return GT_BAD_PARAM;
+               default:
+                    return GT_BAD_PARAM;
+            }
+        }
+        else
+        {
+            data = 0;
+        }
+    }
+    else
+    {
+        if (rmu->rmuEn)
+        {
+            port = GT_LPORT_2_PORT(rmu->port);
+            if (port == GT_INVALID_PORT)
+                return GT_BAD_PARAM;
+
+            switch(port)
+            {
+                case 9:
+                    data = 1;
+                    break;
+                case 10:
+                    data = 3;
+                    break;
+                default:
+                    return GT_BAD_PARAM;
+            }
+        }
+        else
+        {
+            data = 0;
+        }
+    }
+
+    /* Set the RMUMode bit. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRMUMode
+*
+* DESCRIPTION:
+*        Get Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10,
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote
+*        Management Response frame will be generated and sent out.
+*
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        rmu - GT_RMU structure
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMUMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_RMU        *rmu
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRMUMode Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the RMUMode bit. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
+    {
+        switch (data)
+        {
+            case 0:
+                    rmu->rmuEn = GT_FALSE;
+                    break;
+
+            case 1:
+                    rmu->rmuEn = GT_TRUE;
+                    rmu->port = GT_PORT_2_LPORT(4);
+                    break;
+
+            case 2:
+                    rmu->rmuEn = GT_TRUE;
+                    rmu->port = GT_PORT_2_LPORT(5);
+                    break;
+            case 3:
+                    if (IS_IN_DEV_GROUP(dev,DEV_88E6352_FAMILY))
+                    {
+                      rmu->rmuEn = GT_TRUE;
+                      rmu->port = GT_PORT_2_LPORT(6);
+                      break;
+                    }
+                    return GT_FAIL;
+            default:
+                    return GT_FAIL;
+        }
+    }
+    else
+    {
+        switch (data)
+        {
+            case 0:
+                    rmu->rmuEn = GT_FALSE;
+                    break;
+
+            case 1:
+                    rmu->rmuEn = GT_TRUE;
+                    rmu->port = GT_PORT_2_LPORT(9);
+                    break;
+
+            case 3:
+                    rmu->rmuEn = GT_TRUE;
+                    rmu->port = GT_PORT_2_LPORT(10);
+                    break;
+
+            default:
+                    rmu->rmuEn = GT_FALSE;
+                    break;
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetCtrMode
+*
+* DESCRIPTION:
+*        Set Counter Modes. These bits control the operating modes of the two of
+*        the Ports MIB counters.
+*
+* INPUTS:
+*        ctrMode - Counter mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetCtrMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       ctrMode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetCtrMode Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_COUNTER_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6352_FAMILY))
+    {
+      data = ctrMode&0x3;
+      /* Set the Counter Mode. */
+      retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,5,2,data);
+    }
+    else
+    {
+      data = ctrMode&0x1;
+      /* Set the Counter Mode. */
+      retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,1,data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetCtrMode
+*
+* DESCRIPTION:
+*        Get Counter Modes. These bits control the operating modes of the two of
+*        the Ports MIB counters.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        ctrMode - Counter mode
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetCtrMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16       *ctrMode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetCtrMode Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_COUNTER_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_COUNTER_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6352_FAMILY))
+    {
+      /* Set the Counter Mode. */
+      retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,5,2, &data);
+    }
+    else
+    {
+      /* Set the Counter Mode. */
+      retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,1, &data);
+    }
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *ctrMode = data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRsvd2CpuEnables2X
+*
+* DESCRIPTION:
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved
+*        multicast DA addresses, whose bit in this register are also set to a one,
+*        are treadted as MGMT frames. All the reserved DA's take the form
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested.
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2CpuEnables2X
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        enBits
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetRsvd2CpuEnables2X Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST_2X))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_MGMT_ENABLE_2X, (GT_U16)enBits);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRsvd2CpuEnables2X
+*
+* DESCRIPTION:
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved
+*        multicast DA addresses, whose bit in this register are also set to a one,
+*        are treadted as MGMT frames. All the reserved DA's take the form
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested.
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will
+*        be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        enBits - bit vector of enabled Reserved Multicast.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2CpuEnables2X
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *enBits
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysGetRsvd2CpuEnables2X Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST_2X))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related register */
+    retVal = hwReadGlobal2Reg(dev, QD_REG_MGMT_ENABLE_2X, enBits);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetLoopbackFilter
+*
+* DESCRIPTION:
+*        Loopback Filter.
+*        When Loopback Filter is enabled,Forward DSA frames that ingress a DSA port
+*        that came from the same Src_Dev will be filtered to the same Src_Port,
+*        i.e., the frame will not be allowed to egress the source port on the
+*        source device as indicated in the DSA Forward's Tag.
+*
+* INPUTS:
+*        en - GT_TRUE to enable LoopbackFilter, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetLoopbackFilter
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetLoopbackFilter Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_LOOPBACK_FILTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 15, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetLoopbackFilter
+*
+* DESCRIPTION:
+*        Loopback Filter.
+*        When Loopback Filter is enabled,Forward DSA frames that ingress a DSA port
+*        that came from the same Src_Dev will be filtered to the same Src_Port,
+*        i.e., the frame will not be allowed to egress the source port on the
+*        source device as indicated in the DSA Forward's Tag.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if LoopbackFilter is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetLoopbackFilter
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetLoopbackFilter Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_LOOPBACK_FILTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetFloodBC
+*
+* DESCRIPTION:
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and
+*        other switch policy still applies to these Broadcast frames.
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's
+*        Egress Floods mode.
+*
+* INPUTS:
+*        en - GT_TRUE to enable Flood Broadcast, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFloodBC
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetFloodBC Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FLOOD_BROADCAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 12, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFloodBC
+*
+* DESCRIPTION:
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and
+*        other switch policy still applies to these Broadcast frames.
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's
+*        Egress Floods mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Flood Broadcast is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetFloodBC
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetFloodBC Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FLOOD_BROADCAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,12,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRemove1PTag
+*
+* DESCRIPTION:
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be
+*        performed. Only the first Provider Tag found on the frame will be
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive
+*        Provider Tag stripping will be performed. The first Provider Tag's data
+*        will be extracted and used for switching, and then all subsequent Provider
+*        Tags found in the frame will also be removed. This will only occur if the
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*
+* INPUTS:
+*        en - GT_TRUE to enable Remove One Provider Tag, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRemove1PTag
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetRemove1PTag Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RM_ONE_PTAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 11, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetRemove1PTag
+*
+* DESCRIPTION:
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be
+*        performed. Only the first Provider Tag found on the frame will be
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive
+*        Provider Tag stripping will be performed. The first Provider Tag's data
+*        will be extracted and used for switching, and then all subsequent Provider
+*        Tags found in the frame will also be removed. This will only occur if the
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Remove One Provider Tag is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRemove1PTag
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetRemove1PTag Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RM_ONE_PTAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT, 11, 1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetTagFlowControl
+*
+* DESCRIPTION:
+*        Use and generate source port Flow Control status for Cross-Chip Flow
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is
+*        defined to be Src_FC and it is added to these frames when generated and
+*        it is inspected on these frames when received. The QC will use the Src_FC
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to
+*        be Reserved and it will be zero on these frames when generated and it
+*        will not be used on these frames when received (this is a backwards
+*        compatibility mode).
+*
+* INPUTS:
+*        en - GT_TRUE to enable Tag Flow Control, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetTagFlowControl
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetTagFlowControl Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAG_FLOW_CONTROL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 9, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetTagFlowControl
+*
+* DESCRIPTION:
+*        Use and generate source port Flow Control status for Cross-Chip Flow
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is
+*        defined to be Src_FC and it is added to these frames when generated and
+*        it is inspected on these frames when received. The QC will use the Src_FC
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to
+*        be Reserved and it will be zero on these frames when generated and it
+*        will not be used on these frames when received (this is a backwards
+*        compatibility mode).
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if Tag Flow Control is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetTagFlowControl
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetTagFlowControl Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAG_FLOW_CONTROL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,9,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetAlwaysUseVTU
+*
+* DESCRIPTION:
+*        Always use VTU.
+*        When this feature is enabled, VTU hit data will be used to map frames
+*        even if 802.1Q is Disabled on the port.
+*        When it's disabled, data will be ignored when mapping frames on ports
+*        where 802.1Q is Disabled.
+*
+* INPUTS:
+*        en - GT_TRUE to use VTU always, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetAlwaysUseVTU
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetAlwaysUseVTU Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ALWAYS_USE_VTU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 8, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetAlwaysUseVTU
+*
+* DESCRIPTION:
+*        Always use VTU.
+*        When this feature is enabled, VTU hit data will be used to map frames
+*        even if 802.1Q is Disabled on the port.
+*        When it's disabled, data will be ignored when mapping frames on ports
+*        where 802.1Q is Disabled.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if VTU is always used, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetAlwaysUseVTU
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetAlwaysUseVTU Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ALWAYS_USE_VTU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,8,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetQVlansOnly
+*
+* DESCRIPTION:
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is
+*        limited by the frame's VID (using the MemberTag data found in the VTU)
+*        together with the port based VLANs (using the source port's PortVLANTable,
+*        gvlnSetPortVlanPorts API). The two methods are always used together in
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
+*
+* INPUTS:
+*        en - GT_TRUE to use 802.1Q Vlan Only feature, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetQVlansOnly
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetQVlansOnly Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QVLAN_ONLY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY, 15, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetQVlansOnly
+*
+* DESCRIPTION:
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is
+*        limited by the frame's VID (using the MemberTag data found in the VTU)
+*        together with the port based VLANs (using the source port's PortVLANTable,
+*        gvlnSetPortVlanPorts API). The two methods are always used together in
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 802.1Q Vlan Only feature is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetQVlansOnly
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetQVlansOnly Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QVLAN_ONLY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSet5BitPort
+*
+* DESCRIPTION:
+*        Use 5 bits for Port data in the Port VLAN Table (PVT).
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
+*
+* INPUTS:
+*        en - GT_TRUE to use 5 bit as a Source port in PVT, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSet5BitPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSet5BitPort Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_5BIT_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY, 14, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGet5BitPort
+*
+* DESCRIPTION:
+*        Use 5 bits for Port data in the Port VLAN Table (PVT).
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 5 bit is used as a Source Port in PVT, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGet5BitPort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGet5BitPort Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_5BIT_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetSDETPolarity
+*
+* DESCRIPTION:
+*        SDET (Signal Detect) Polarity select bits for each port.
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help
+*        determine link on fiber ports. This bit affects the active level of a
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other
+*        port modes the SDET pins are ignored and these bits have no effect.
+*
+* INPUTS:
+*        sdetVec - SDET Polarity for each port in Vector format
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sdetVec is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetSDETPolarity
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          sdetVec
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetSDETPolarity Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SDET_POLARITY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if ((GT_U16)sdetVec > ((1 << dev->numOfPorts) - 1))
+    {
+        DBG_INFO(("GT_BAD_PARAM \n"));
+        return GT_BAD_PARAM;
+    }
+
+    data = (GT_U16)GT_LPORTVEC_2_PORTVEC(sdetVec);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_LIMITED_SDET))
+    {
+        if (data & (~0x30))    /* only port 4 and 5 of this device support SDET */
+        {
+            DBG_INFO(("GT_BAD_PARAM \n"));
+            return GT_BAD_PARAM;
+        }
+    }
+
+    /* Set the related bits. */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY,0,dev->maxPorts,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetSDETPolarity
+*
+* DESCRIPTION:
+*        SDET (Signal Detect) Polarity select bits for each port.
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help
+*        determine link on fiber ports. This bit affects the active level of a
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other
+*        port modes the SDET pins are ignored and these bits have no effect.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        sdetVec - SDET Polarity for each port in Vector format
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetSDETPolarity
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32      *sdetVec
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetSDETPolarity Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SDET_POLARITY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the related bits. */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,0,dev->maxPorts,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_LIMITED_SDET))
+    {
+        data &= 0x30;
+    }
+
+    *sdetVec = GT_PORTVEC_2_LPORTVEC(data);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetARPwoBC
+*
+* DESCRIPTION:
+*       ARP detection without Broadcast checking. When enabled the switch core
+*       does not check for a Btoadcast MAC address as part of the ARP frame
+*       detection. It only checkes the Ether Type (0x0806).
+*
+* INPUTS:
+*       en - GT_TRUE to enable, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetARPwoBC
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL     en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                /* register.                    */
+    DBG_INFO(("sysSetARPwoBC Called.\n"));
+    BOOL_2_BIT(en,data);
+
+    /* Set the Discard Exissive bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetARPwoBC
+*
+* DESCRIPTION:
+*       ARP detection without Broadcast checking. When enabled the switch core
+*       does not check for a Btoadcast MAC address as part of the ARP frame
+*       detection. It only checkes the Ether Type (0x0806).
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE if enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetARPwoBC
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetARPwoBC Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the bit. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetCLK125En
+*
+* DESCRIPTION:
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
+*
+* INPUTS:
+*        en - GT_TRUE to enable 125 MHz clock, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetCLK125En
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetCLK125En Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CLK_125))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY, 11, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetCLK125En
+*
+* DESCRIPTION:
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE if 125MHz clock is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetCLK125En
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetCLK125En Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CLK_125))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysPort2Lport
+*
+* DESCRIPTION:
+*        This routine converts physical port number to logical port number.
+*
+* INPUTS:
+*        port - physical port number
+*
+* OUTPUTS:
+*        lport - logical port number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysPort2Lport
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         port,
+    OUT GT_LPORT    *lport
+)
+{
+    DBG_INFO(("gsysPort2Lport Called.\n"));
+
+    if (port > 0xFF)
+    {
+        return GT_FAIL;
+    }
+
+    *lport = GT_PORT_2_LPORT((GT_U8)port);
+
+    if (*lport == GT_INVALID_PORT)
+    {
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysLport2Port
+*
+* DESCRIPTION:
+*        This routine converts logical port number to physical port number.
+*
+* INPUTS:
+*        lport - logical port number
+*
+* OUTPUTS:
+*        port - physical port number
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysLport2Port
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    lport,
+    OUT GT_U32         *port
+)
+{
+    DBG_INFO(("gsysLport2Port Called.\n"));
+
+    *port = (GT_U32)GT_LPORT_2_PORT(lport);
+
+    if (*port == GT_INVALID_PORT)
+    {
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysPortvec2Lportvec
+*
+* DESCRIPTION:
+*        This routine converts physical port vector to logical port vector.
+*
+* INPUTS:
+*        portvec - physical port vector
+*
+* OUTPUTS:
+*        lportvec - logical port vector
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysPortvec2Lportvec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        portvec,
+    OUT GT_U32         *lportvec
+)
+{
+    DBG_INFO(("gsysPortvec2Lportvec Called.\n"));
+
+    if (portvec & (~((GT_U32)dev->validPortVec)))
+    {
+        return GT_FAIL;
+    }
+
+    *lportvec = GT_PORTVEC_2_LPORTVEC(portvec);
+
+    if (*lportvec == GT_INVALID_PORT_VEC)
+    {
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysLportvec2Portvec
+*
+* DESCRIPTION:
+*        This routine converts logical port vector to physical port vector.
+*
+* INPUTS:
+*        lportvec - logical port vector
+*
+* OUTPUTS:
+*        portvec - physical port vector
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysLportvec2Portvec
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        lportvec,
+    OUT GT_U32         *portvec
+)
+{
+    DBG_INFO(("gsysLportvec2Portvec Called.\n"));
+
+    *portvec = GT_LPORTVEC_2_PORTVEC(lportvec);
+
+    if (*portvec == GT_INVALID_PORT_VEC)
+    {
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/****************************************************************************/
+/* Internal functions.                                                  */
+/****************************************************************************/
+
+/*
+ * Write to Switch MAC/Wol MAC Register
+ */
+static GT_STATUS writeSwitchMacWolReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        baseid,
+    IN GT_ETHERADDR *mac
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+    GT_U16            i;
+
+    for (i=0; i<GT_ETHERNET_HEADER_SIZE; i++)
+    {
+        /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+        }
+#endif
+
+        data = (1 << 15) | ((i+baseid) << 8) | mac->arEther[i];
+
+        retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+    }
+
+    return GT_OK;
+}
+
+/*
+ * Read from Switch MAC/WoL MAC Register
+ */
+static GT_STATUS readSwitchMacWolReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN GT_U8        baseid,
+    OUT GT_ETHERADDR *mac
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+    GT_U16            i;
+
+    /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+           retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
+           if(retVal != GT_OK)
+        {
+               return retVal;
+        }
+       }
+#endif
+
+    for (i=0; i<GT_ETHERNET_HEADER_SIZE; i++)
+    {
+        data = (i+baseid) << 8;
+
+        retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+
+        if ((baseid != 0x16) && (i == 0))  /* base id = 0x16 is Wol Password,and it has nor diffAddr */
+            mac->arEther[i] = data & 0xFE;    /* bit 0 is for diffAddr */
+        else
+            mac->arEther[i] = data & 0xFF;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ * Write to Different MAC Address per port bit in Switch MAC/WoL Register
+ */
+static GT_STATUS writeDiffMACWoL
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        baseid,
+    IN GT_U16       diffAddr
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+
+    /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_SWITCH_MAC;
+      data = baseid<<8;
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+       retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
+          if(retVal != GT_OK)
+        {
+               return retVal;
+        }
+    }
+    data = baseid<<8;
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* Read Swith MAC Reg */
+    retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+#endif
+
+    data = (1 << 15) | (baseid<<8) | (data & 0xFE) | (diffAddr & 0x1);
+
+    /* Write back to Swith MAC Reg with updated diffAddr */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    return GT_OK;
+}
+
+/*
+ * Read Different MAC Address per port bit in Switch MAC/WoL Register
+ */
+static GT_STATUS readDiffMACWoL
+(
+    IN  GT_QD_DEV    *dev,
+    IN GT_U8        baseid,
+    OUT GT_U16        *diffAddr
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+
+    /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_SWITCH_MAC;
+      data = baseid<<8;
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
+    data = 1;
+       while(data == 1)
+    {
+           retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
+           if(retVal != GT_OK)
+        {
+               return retVal;
+        }
+       }
+
+    /* Write to Swith MAC Reg for reading operation */
+    data = baseid<<8;
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+#endif
+    *diffAddr = data & 0x1;
+
+    return GT_OK;
+}
+
+/*
+ * Write to Switch MAC/WoL/WoF Register
+ */
+static GT_STATUS writeSwMacWolWofReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        pointer,
+    IN GT_U8        data
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          tmpData;     /* temporary Data storage */
+    {
+        /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+        tmpData = 1;
+        while(tmpData == 1)
+        {
+            retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&tmpData);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+        }
+#endif
+
+        tmpData = (1 << 15) | (pointer << 8) | data;
+
+        retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC, tmpData);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+    }
+
+    return GT_OK;
+}
+
+/*
+ * Read from Switch MAC/WoL/WoF Register
+ */
+static GT_STATUS readSwMacWolWofReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        pointer,
+    OUT GT_U8       *data
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          tmpData;     /* temporary Data storage */
+
+    /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    tmpData = 1;
+       while(tmpData == 1)
+    {
+           retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&tmpData);
+           if(retVal != GT_OK)
+        {
+               return retVal;
+        }
+       }
+#endif
+
+    {
+        tmpData = pointer << 8;
+
+        retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,tmpData);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&tmpData);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+
+        *data = tmpData & 0xFF;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ * Write to Switch MAC Register
+ */
+static GT_STATUS writeSwitchMacReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+)
+{
+    return writeSwitchMacWolReg(dev, 0, mac);
+}
+
+/*
+ * Read from Switch MAC Register
+ */
+static GT_STATUS readSwitchMacReg
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+)
+{
+    return readSwitchMacWolReg(dev, 0, mac);
+}
+
+
+/*
+ * Write to Different MAC Address per port bit in Switch MAC Register
+ */
+static GT_STATUS writeDiffMAC
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       diffAddr
+)
+{
+    return writeDiffMACWoL(dev, 0, diffAddr);
+}
+
+/*
+ * Read Different MAC Address per port bit in Switch MAC Register
+ */
+static GT_STATUS readDiffMAC
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16        *diffAddr
+)
+{
+    return readDiffMACWoL(dev, 0, diffAddr);
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysStatus.c
@@ -0,0 +1,262 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtSysStatus.c
+*
+* DESCRIPTION:
+*       API definitions for system global status.
+*     Added for fullsail
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 5 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gsysGetPPUState
+*
+* DESCRIPTION:
+*        This routine get the PPU State. These two bits return
+*        the current value of the PPU.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        mode - GT_PPU_STATE
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPPUState
+(
+    IN  GT_QD_DEV       *dev,
+    OUT GT_PPU_STATE    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetPPUState Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("Not Supported.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,14,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        data |= 0x4000;
+    }
+
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetSW_Mode
+*
+* DESCRIPTION:
+*       This routine get the Switch mode. These two bits returen
+*       the current value of the SW_MODE[1:0] pins.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSW_Mode
+(
+    IN  GT_QD_DEV  *dev,
+    OUT GT_SW_MODE *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetSW_Mode Called.\n"));
+
+    /* check if device supports this feature */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_MODE)) )
+    {
+        DBG_INFO(("Not Supported.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,12,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetInitReady
+*
+* DESCRIPTION:
+*       This routine get the InitReady bit. This bit is set to a one when the ATU,
+*       the Queue Controller and the Statistics Controller are done with their
+*       initialization and are ready to accept frames.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetInitReady
+(
+    IN  GT_QD_DEV  *dev,
+    OUT GT_BOOL    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetInitReady Called.\n"));
+
+    /* check if device supports this feature */
+    if (!(IS_IN_DEV_GROUP(dev,DEV_INIT_READY)) )
+    {
+        DBG_INFO(("Not Supported.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFreeQSize
+*
+* DESCRIPTION:
+*       This routine gets Free Queue Counter. This counter reflects the
+*        current number of unalllocated buffers available for all the ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       count - Free Queue Counter
+*
+* RETURNS:
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFreeQSize
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16         *count
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysGetFreeQSize Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_OUT_Q_SIZE))
+    {
+        DBG_INFO(("Not Supported.\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* get the counter */
+    retVal = hwGetGlobalRegField(dev,QD_REG_TOTAL_FREE_COUNTER,0,9,count);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtTCAM.c
@@ -0,0 +1,1226 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtTCAM.c
+*
+* DESCRIPTION:
+*       API definitions for control of Ternary Content Addressable Memory
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+GT_STATUS tcamReadGlobal3Reg
+(
+  IN GT_QD_DEV *dev,
+  IN  GT_U8    regAddr,
+  OUT GT_U16   *data
+)
+{
+  GT_STATUS           retVal;
+  retVal = hwReadGlobal3Reg(dev, regAddr, data);
+  if(retVal != GT_OK)
+  {
+    return retVal;
+  }
+
+  return GT_OK;
+}
+
+GT_STATUS tcamWriteGlobal3Reg
+(
+  IN  GT_QD_DEV *dev,
+  IN  GT_U8    regAddr,
+  IN  GT_U16   data
+)
+{
+  GT_STATUS           retVal;
+
+  retVal = hwWriteGlobal3Reg(dev, regAddr, data);
+  if(retVal != GT_OK)
+  {
+    return retVal;
+  }
+  return GT_OK;
+}
+
+/****************************************************************************/
+/* TCAM operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS tcamOperationPerform
+(
+    IN   GT_QD_DEV             *dev,
+    IN   GT_TCAM_OPERATION    tcamOp,
+    INOUT GT_TCAM_OP_DATA    *opData
+);
+
+/*******************************************************************************
+* gtcamFlushAll
+*
+* DESCRIPTION:
+*       This routine is to flush all entries. A Flush All command will initialize
+*       TCAM Pages 0 and 1, offsets 0x02 to 0x1B to 0x0000, and TCAM Page 2 offset
+*       0x02 to 0x05 to 0x0000 for all TCAM entries with the exception that TCAM
+*       Page 0 offset 0x02 will be initialized to 0x00FF.
+*
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamFlushAll
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamFlushAll Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_FLUSH_ALL;
+    tcamOpData.tcamEntry = 0xFF;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtcamFlushEntry
+*
+* DESCRIPTION:
+*       This routine is to flush a single entry. A Flush a single TCAM entry command
+*       will write the same values to a TCAM entry as a Flush All command, but it is
+*       done to the selected single TCAM entry only.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamFlushEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamFlushEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if (tcamPointer > 0xFE)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_FLUSH_ALL;
+    tcamOpData.tcamEntry = tcamPointer;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtcamLoadEntry
+*
+* DESCRIPTION:
+*       This routine loads a TCAM entry.
+*       The load sequence of TCAM entry is critical. Each TCAM entry is made up of
+*       3 pages of data. All 3 pages need to loaded in a particular order for the TCAM
+*       to operate correctly while frames are flowing through the switch.
+*       If the entry is currently valid, it must first be flushed. Then page 2 needs
+*       to be loaded first, followed by page 1 and then finally page 0.
+*       Each page load requires its own write TCAMOp with these TCAM page bits set
+*       accordingly.
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamLoadEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamLoadEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if ((tcamPointer > 0xFE)||(tcamData==NULL))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_LOAD_ENTRY;
+    tcamOpData.tcamPage = 0; /* useless */
+    tcamOpData.tcamEntry = tcamPointer;
+    tcamOpData.tcamDataP = tcamData;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtcamPurgyEntry
+*
+* DESCRIPTION:
+*       This routine Purgy a TCAM entry.
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamPurgyEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamPurgyEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if ((tcamPointer > 0xFE)||(tcamData==NULL))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_PURGE_ENTRY;
+    tcamOpData.tcamPage = 0; /* useless */
+    tcamOpData.tcamEntry = tcamPointer;
+    tcamOpData.tcamDataP = tcamData;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtcamReadTCAMData
+*
+* DESCRIPTION:
+*       This routine loads the global 3 offsets 0x02 to 0x1B registers with
+*       the data found in the TCAM entry and its TCAM page pointed to by the TCAM
+*       entry and TCAM page bits of this register (bits 7:0 and 11:10 respectively.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*
+* OUTPUTS:
+*        tcamData    - Tcam entry Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamReadTCAMData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamReadTCAMData Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if ((tcamPointer > 0xFE)||(tcamData==NULL))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_READ_ENTRY;
+    tcamOpData.tcamPage = 0; /* useless */
+    tcamOpData.tcamEntry = tcamPointer;
+    tcamOpData.tcamDataP = tcamData;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtcamGetNextTCAMData
+*
+* DESCRIPTION:
+*       This routine  finds the next higher TCAM Entry number that is valid (i.e.,
+*       any entry whose Page 0 offset 0x02 is not equal to 0x00FF). The TCAM Entry
+*       register (bits 7:0) is used as the TCAM entry to start from. To find
+*       the lowest number TCAM Entry that is valid, start the Get Next operation
+*       with TCAM Entry set to 0xFF.
+*
+*
+* INPUTS:
+*        tcamPointer - start pointer entry of TCAM (0 ~ 255)
+*
+* OUTPUTS:
+*        tcamPointer - next pointer entry of TCAM (0 ~ 255)
+*        tcamData    - Tcam entry Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamGetNextTCAMData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        *tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamGetNextTCAMData Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if ((*tcamPointer > 0xFF)||(tcamData==NULL))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_GET_NEXT_ENTRY;
+    tcamOpData.tcamPage = 0; /* useless */
+    tcamOpData.tcamEntry = *tcamPointer;
+    tcamOpData.tcamDataP = tcamData;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    *tcamPointer = tcamOpData.tcamEntry;
+    tcamData->rawFrmData[0].frame0.paraFrm.pg0Op = qdLong2Short(tcamOpData.tcamEntry);
+    tcamData->rawFrmData[0].frame0.paraFrm.pg0Op &= 0xff;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+#if 0
+/*******************************************************************************
+* gtcamAddEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in TCAM.
+*
+* INPUTS:
+*       tcamEntry    - TCAM entry to insert to the TCAM.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK          - on success
+*       GT_FAIL        - on error
+*       GT_BAD_PARAM   - on invalid port vector
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gtcamAddEntry
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ATU_ENTRY *tcamEntry
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gtcamAddEntry Called.\n"));
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gtcamDelEntry
+*
+* DESCRIPTION:
+*       Deletes TCAM entry.
+*
+* INPUTS:
+*       tcamEntry - TCAM entry.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gtcamDelEntry
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR  *tcamEntry
+)
+{
+    GT_STATUS retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gtcamDelEntry Called.\n"));
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+#endif
+
+/****************************************************************************/
+/* Internal functions.                                                  */
+/****************************************************************************/
+static GT_STATUS tcamSetPage0Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP, GT_U8 extFrame)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  int i, startLoc, endReg;
+
+
+  tcamDataP->rawFrmData[extFrame].frame0.paraFrm.maskType=tcamDataP->frameTypeMask;
+  if(extFrame==1)
+  {
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.frame0Type=0;
+  }
+  else
+  {
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.frame0Type=tcamDataP->frameType;
+  }
+  {
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.type0Res=0;
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.spvRes=0;
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.spvMask=tcamDataP->spvMask;
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.spv=tcamDataP->spv;
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.ppri0Mask=tcamDataP->ppriMask;
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.ppri0=tcamDataP->ppri;
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.pvid0MaskHi=(tcamDataP->pvidMask>>8);
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.pvid0Hi=(tcamDataP->pvid>>8);
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.pvidMask0Low=tcamDataP->pvidMask&0xff;
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.pvid0Low=tcamDataP->pvid&0xff;
+  }
+
+  if(extFrame==1)
+    startLoc =48;
+  else
+    startLoc = 0;
+  for(i=0; i<(22); i++)
+  {
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.frame0[i].struc.mask=tcamDataP->frameOctetMask[i+startLoc];
+    tcamDataP->rawFrmData[extFrame].frame0.paraFrm.frame0[i].struc.oct=tcamDataP->frameOctet[i+startLoc];
+  }
+
+  if(extFrame==0)
+    endReg =0x1c;
+  else
+    endReg = 3;
+
+  for(i=2; i<endReg; i++)
+  {
+    retVal = tcamWriteGlobal3Reg(dev,i, tcamDataP->rawFrmData[extFrame].frame0.frame[i]);
+    if(retVal != GT_OK)
+    {
+      return retVal;
+    }
+  }
+
+  return GT_OK;
+}
+static GT_STATUS tcamSetPage1Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP, GT_U8 extFrame)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  int i, startLoc;
+
+  if(extFrame==1)
+    startLoc =48;
+  else
+    startLoc = 0;
+  for(i=0; i<(26); i++)
+  {
+    tcamDataP->rawFrmData[extFrame].frame1.paraFrm.frame1[i].struc.mask=tcamDataP->frameOctetMask[i+23+startLoc];
+    tcamDataP->rawFrmData[extFrame].frame1.paraFrm.frame1[i].struc.mask=tcamDataP->frameOctet[i+23+startLoc];
+  }
+  for(i=2; i<0x1c; i++)
+  {
+    retVal = tcamWriteGlobal3Reg(dev, i,tcamDataP->rawFrmData[extFrame].frame1.frame[i]);
+    if(retVal != GT_OK)
+    {
+     return retVal;
+    }
+  }
+
+  return GT_OK;
+}
+
+static GT_STATUS tcamSetPage2Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP, GT_U8 extFrame)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+  int i, endReg;
+
+  tcamDataP->continu = 0;
+  if((extFrame!=1)&&(tcamDataP->is96Frame==1))
+      tcamDataP->continu = 1;
+
+  tcamDataP->rawFrmData[extFrame].frame2.paraFrm.continu=tcamDataP->continu;
+  if(extFrame==0)
+  {
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.interrupt=tcamDataP->interrupt;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.IncTcamCtr=tcamDataP->IncTcamCtr;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm. pg2res1=0;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.vidData=tcamDataP->vidData&0x07ff;
+
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.nextId=tcamDataP->nextId;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.pg2res2=0;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.qpriData=tcamDataP->qpriData;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.pg2res3=0;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.fpriData=tcamDataP->fpriData;
+
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.pg2res4=0;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.qpriAvbData=tcamDataP->qpriAvbData;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.pg2res5=0;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.dpvData=tcamDataP->dpvData;
+
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.pg2res6=0;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.factionData=tcamDataP->factionData;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.pg2res7=0;
+    tcamDataP->rawFrmData[extFrame].frame2.paraFrm.ldBalanceData=tcamDataP->ldBalanceData;
+  }
+
+  if(extFrame==0)
+    endReg = 6;
+  else
+    endReg = 3;
+
+  for(i=2; i<endReg; i++)
+  {
+    retVal = tcamWriteGlobal3Reg(dev, i,tcamDataP->rawFrmData[extFrame].frame2.frame[i]);
+    if(retVal != GT_OK)
+    {
+     return retVal;
+    }
+  }
+
+  if(extFrame==0)
+  {
+    data = (tcamDataP->debugPort );
+    retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_P2_DEBUG_PORT,data);
+    if(retVal != GT_OK)
+    {
+       return retVal;
+    }
+    data = ((tcamDataP->highHit<<8) | (tcamDataP->lowHit<<0)  );
+    retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_P2_ALL_HIT,data);
+    if(retVal != GT_OK)
+    {
+      return retVal;
+    }
+  }
+  return GT_OK;
+}
+
+
+static GT_STATUS tcamGetPage0Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP, GT_U8 extFrame)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  int i, startLoc, endReg;
+
+  if(extFrame==0)
+    endReg =0x1c;
+  else
+    endReg = 3;
+
+  for(i=2; i<endReg; i++)
+  {
+    retVal = tcamReadGlobal3Reg(dev, i, &tcamDataP->rawFrmData[extFrame].frame0.frame[i]);
+    if(retVal != GT_OK)
+    {
+      return retVal;
+    }
+  }
+
+  if(extFrame==0)
+  {
+  tcamDataP->frameTypeMask=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame0.paraFrm.maskType);
+  tcamDataP->frameType=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame0.paraFrm.frame0Type);
+
+  tcamDataP->spvMask=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame0.paraFrm.spvMask);
+  tcamDataP->spv=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame0.paraFrm.spv);
+  tcamDataP->ppriMask=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame0.paraFrm.ppri0Mask);
+  tcamDataP->pvidMask=tcamDataP->rawFrmData[extFrame].frame0.paraFrm.pvid0MaskHi;
+  tcamDataP->pvidMask <<=8;
+  tcamDataP->ppri=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame0.paraFrm.ppri0);
+  tcamDataP->pvid=tcamDataP->rawFrmData[extFrame].frame0.paraFrm.pvid0Hi;
+  tcamDataP->pvid <<=8;
+  tcamDataP->pvidMask |= tcamDataP->rawFrmData[extFrame].frame0.paraFrm.pvidMask0Low;
+  tcamDataP->pvid |= tcamDataP->rawFrmData[extFrame].frame0.paraFrm.pvid0Low;
+  }
+
+  if(extFrame==1)
+    startLoc =48;
+  else
+    startLoc = 0;
+  for(i=0; i<(22); i++)
+  {
+    tcamDataP->frameOctetMask[i+startLoc]=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame0.paraFrm.frame0[i].struc.mask);
+    tcamDataP->frameOctet[i+startLoc]=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame0.paraFrm.frame0[i].struc.oct);
+  }
+
+  return GT_OK;
+}
+static GT_STATUS tcamGetPage1Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP, GT_U8 extFrame)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  int i, startLoc;
+
+  for(i=2; i<0x1c; i++)
+  {
+    retVal = tcamReadGlobal3Reg(dev,i,&tcamDataP->rawFrmData[extFrame].frame1.frame[i]);
+    if(retVal != GT_OK)
+    {
+     return retVal;
+    }
+  }
+  if(extFrame==1)
+    startLoc =48;
+  else
+    startLoc = 0;
+  for(i=0; i<(26); i++)
+  {
+    tcamDataP->frameOctetMask[i+23+startLoc]=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame1.paraFrm.frame1[i].struc.mask);
+    tcamDataP->frameOctet[i+23+startLoc]=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame1.paraFrm.frame1[i].struc.mask);
+  }
+
+  return GT_OK;
+}
+
+static GT_STATUS tcamGetPage2Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP, GT_U8 extFrame)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+  int i, endReg;
+
+/*  if(extFrame!=0)
+    return GT_OK;
+*/
+
+  if(extFrame==0)
+    endReg = 6;
+  else
+    endReg = 3;
+
+  for(i=2; i<endReg; i++)
+  {
+    retVal = tcamReadGlobal3Reg(dev, i, &tcamDataP->rawFrmData[extFrame].frame2.frame[i]);
+    if(retVal != GT_OK)
+    {
+     return retVal;
+    }
+  }
+  if(extFrame==0)
+  {
+
+    tcamDataP->continu=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame2.paraFrm.continu);
+    tcamDataP->interrupt=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame2.paraFrm.IncTcamCtr);
+    tcamDataP->vidData=tcamDataP->rawFrmData[extFrame].frame2.paraFrm.vidData;
+    tcamDataP->nextId=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame2.paraFrm.nextId);
+    tcamDataP->qpriData=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame2.paraFrm.qpriData);
+    tcamDataP->fpriData=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame2.paraFrm.fpriData);
+    tcamDataP->qpriAvbData=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame2.paraFrm.qpriAvbData);
+    tcamDataP->dpvData=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame2.paraFrm.dpvData);
+    tcamDataP->factionData=tcamDataP->rawFrmData[extFrame].frame2.paraFrm.factionData;
+    tcamDataP->ldBalanceData=qdShort2Char(tcamDataP->rawFrmData[extFrame].frame2.paraFrm.ldBalanceData);
+
+    i = QD_REG_TCAM_P2_DEBUG_PORT;
+    retVal = tcamReadGlobal3Reg(dev,QD_REG_TCAM_P2_DEBUG_PORT,&data);
+    if(retVal != GT_OK)
+    {
+       return retVal;
+    }
+    tcamDataP->rawFrmData[extFrame].frame2.frame[i] = data;
+    tcamDataP->debugPort = (data)&0xf;
+    i = QD_REG_TCAM_P2_ALL_HIT;
+    retVal = tcamReadGlobal3Reg(dev,QD_REG_TCAM_P2_ALL_HIT,&data);
+    if(retVal != GT_OK)
+    {
+       return retVal;
+    }
+    tcamDataP->rawFrmData[extFrame].frame2.frame[i] = data;
+    tcamDataP->highHit = (data>>8)&0xff;
+    tcamDataP->lowHit = data&0xff;
+  }
+  return GT_OK;
+}
+
+static GT_STATUS waitTcamReady(GT_QD_DEV           *dev)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TCAM_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    GT_U16          data;     /* temporary Data storage */
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal3RegField(dev,QD_REG_TCAM_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* tcamOperationPerform
+*
+* DESCRIPTION:
+*       This function accesses TCAM Table
+*
+* INPUTS:
+*       tcamOp   - The tcam operation
+*       tcamData - address and data to be written into TCAM
+*
+* OUTPUTS:
+*       tcamData - data read from TCAM pointed by address
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS tcamOperationPerform
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_TCAM_OPERATION   tcamOp,
+    INOUT GT_TCAM_OP_DATA     *opData
+)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+
+  gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+  /* Wait until the tcam in ready. */
+  retVal = waitTcamReady(dev);
+  if(retVal != GT_OK)
+  {
+    gtSemGive(dev,dev->tblRegsSem);
+    return retVal;
+  }
+
+  /* Set the TCAM Operation register */
+  switch (tcamOp)
+  {
+    case TCAM_FLUSH_ALL:
+      data = 0;
+      data = (1 << 15) | (tcamOp << 12);
+      retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      break;
+
+    case TCAM_FLUSH_ENTRY:
+    {
+      int i, extFrame;
+      if(opData->tcamDataP->is96Frame==1)
+        extFrame = 2;
+      else
+        extFrame = 1;
+      for(i=0; i<extFrame; i++)
+      {
+        data = 0;
+        data = qdLong2Short((1 << 15) | (tcamOp << 12) | (opData->tcamEntry+i)) ;
+        retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+      }
+    }
+      break;
+
+    case TCAM_LOAD_ENTRY:
+    case TCAM_PURGE_ENTRY:
+    {
+      int i, extFrame;
+      if((opData->tcamDataP->is96Frame==1)&&(tcamOp!=TCAM_PURGE_ENTRY))
+        extFrame = 2;
+      else
+        extFrame = 1;
+
+      for(i=0; i<extFrame; i++)
+      {
+        if(tcamOp!=TCAM_PURGE_ENTRY)
+        {
+          retVal = tcamSetPage2Data(dev, opData->tcamDataP, i);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+
+          data = 0;
+          data = qdLong2Short((1 << 15) | (TCAM_LOAD_ENTRY << 12) | (2 << 10) | (opData->tcamEntry+i));
+          retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+          retVal = waitTcamReady(dev);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+
+          retVal = tcamSetPage1Data(dev, opData->tcamDataP, i);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+          data = 0;
+          data = qdLong2Short((1 << 15) | (TCAM_LOAD_ENTRY << 12) | (1 << 10) | (opData->tcamEntry+i)) ;
+          retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+
+          retVal = waitTcamReady(dev);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+
+        }
+        retVal = tcamSetPage0Data(dev,  opData->tcamDataP, i);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+        if(tcamOp==TCAM_PURGE_ENTRY)
+        {
+          data = 0xffff ;
+          retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_1,data);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+#if 0
+          retVal = tcamReadGlobal3Reg(dev, QD_REG_TCAM_P0_KEYS_1, &data);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+#endif
+        }
+        data = 0;
+        data = qdLong2Short((1 << 15) | (TCAM_LOAD_ENTRY << 12) | (0 << 10) | (opData->tcamEntry+i));
+        retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+        retVal = waitTcamReady(dev);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+
+#if 0 /* Test read back */
+          retVal = tcamReadGlobal3Reg(dev, QD_REG_TCAM_P0_KEYS_1, &data);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+
+        data = 0;
+        data = (1 << 15) | (TCAM_READ_ENTRY << 12) | (0 << 10) | (opData->tcamEntry+i);
+        retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+        retVal = waitTcamReady(dev);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+{
+  int j;
+  for(j=0; j<0x1c; j++)
+  {
+/*          retVal = tcamReadGlobal3Reg(dev, QD_REG_TCAM_P0_KEYS_1, &data); */
+          retVal = tcamReadGlobal3Reg(dev, j, &data);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+  }
+}
+
+#endif
+      }
+  }
+    break;
+
+    case TCAM_GET_NEXT_ENTRY:
+    {
+      data = 0;
+      data = qdLong2Short((1 << 15) | (tcamOp << 12) | (opData->tcamEntry)) ;
+      retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      /* Wait until the tcam in ready. */
+      retVal = waitTcamReady(dev);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+
+      retVal = tcamReadGlobal3Reg(dev,QD_REG_TCAM_OPERATION, &data);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+
+/*      if(opData->tcamEntry == 0xff)   If ask to find the lowest entry*/
+      {
+        if ((data&0xff)==0xff)
+        {
+          retVal = tcamReadGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_1, &data);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+          if(data==0x00ff)
+          {
+            /* No higher valid TCAM entry */
+            return GT_OK;
+          }
+          else
+          {
+            /* The highest valid TCAM entry found*/
+          }
+        }
+      }
+
+      /* Get next entry and read the entry */
+      opData->tcamEntry = data&0xff;
+    }
+    case TCAM_READ_ENTRY:
+    {
+      int i, extFrame;
+      if(opData->tcamDataP->is96Frame==1)
+        extFrame = 2;
+      else
+        extFrame = 1;
+      for(i=0; i<extFrame; i++)
+      {
+        data = 0;
+        /* Read page 0 */
+        data = qdLong2Short((1 << 15) | (tcamOp << 12) | (0 << 10) | (opData->tcamEntry+i)) ;
+        opData->tcamDataP->rawFrmData[i].frame0.frame[0] = data;
+        retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+        /* Wait until the tcam in ready. */
+        retVal = waitTcamReady(dev);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+
+        retVal = tcamGetPage0Data(dev, opData->tcamDataP, i);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+
+        data = 0;
+        /* Read page 1 */
+        data = qdLong2Short((1 << 15) | (tcamOp << 12) | (1 << 10) | (opData->tcamEntry+i)) ;
+        retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+        /* Wait until the tcam in ready. */
+        retVal = waitTcamReady(dev);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+
+        retVal = tcamGetPage1Data(dev, opData->tcamDataP, i);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+
+        data = 0;
+        /* Read page 2 */
+        data = qdLong2Short((1 << 15) | (tcamOp << 12) | (2 << 10) | (opData->tcamEntry+i)) ;
+        retVal = tcamWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+        /* Wait until the tcam in ready. */
+        retVal = waitTcamReady(dev);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+
+        retVal = tcamGetPage2Data(dev, opData->tcamDataP, i);
+        if(retVal != GT_OK)
+        {
+          gtSemGive(dev,dev->tblRegsSem);
+          return retVal;
+        }
+      }
+    }
+    break;
+
+    default:
+      gtSemGive(dev,dev->tblRegsSem);
+      return GT_FAIL;
+}
+
+  gtSemGive(dev,dev->tblRegsSem);
+  return retVal;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtUtils.c
@@ -0,0 +1,209 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtUtils.c
+*
+* DESCRIPTION:
+*       Collection of Utility functions
+*
+* DEPENDENCIES:
+*       None
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+
+#include <msApi.h>
+
+/*******************************************************************************
+* gtMemSet
+*
+* DESCRIPTION:
+*       Set a block of memory
+*
+* INPUTS:
+*       start  - start address of memory block for setting
+*       simbol - character to store, converted to an unsigned char
+*       size   - size of block to be set
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to set memory block
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemSet
+(
+    IN void * start,
+    IN int    symbol,
+    IN GT_U32 size
+)
+{
+    GT_U32 i;
+    char* buf;
+
+    buf = (char*)start;
+
+    for(i=0; i<size; i++)
+    {
+        *buf++ = (char)symbol;
+    }
+
+    return start;
+}
+
+/*******************************************************************************
+* gtMemCpy
+*
+* DESCRIPTION:
+*       Copies 'size' characters from the object pointed to by 'source' into
+*       the object pointed to by 'destination'. If copying takes place between
+*       objects that overlap, the behavior is undefined.
+*
+* INPUTS:
+*       destination - destination of copy
+*       source      - source of copy
+*       size        - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to destination
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemCpy
+(
+    IN void *       destination,
+    IN const void * source,
+    IN GT_U32       size
+)
+{
+    GT_U32 i;
+    char* buf;
+    char* src;
+
+    buf = (char*)destination;
+    src = (char*)source;
+
+    for(i=0; i<size; i++)
+    {
+        *buf++ = *src++;
+    }
+
+    return destination;
+}
+
+/*******************************************************************************
+* gtMemCmp
+*
+* DESCRIPTION:
+*       Compares given memories.
+*
+* INPUTS:
+*       src1 - source 1
+*       src2 - source 2
+*       size - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0, if equal.
+*        negative number, if src1 < src2.
+*        positive number, if src1 > src2.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int gtMemCmp
+(
+    IN char src1[],
+    IN char src2[],
+    IN GT_U32 size
+)
+{
+    GT_U32 i;
+    int value;
+
+    for(i=0; i<size; i++)
+    {
+        if((value = (int)(src1[i] - src2[i])) != 0)
+            return value;
+    }
+
+    return 0;
+}
+
+/*******************************************************************************
+* gtStrlen
+*
+* DESCRIPTION:
+*       Determine the length of a string
+* INPUTS:
+*       source  - string
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       size    - number of characters in string, not including EOS.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_U32 gtStrlen
+(
+    IN const void * source
+)
+{
+    GT_U32 i = 0;
+    char* src;
+
+    src = (char*)source;
+
+    while(*src++) i++;
+
+    return i;
+}
+
+
+/*******************************************************************************
+* gtDelay
+*
+* DESCRIPTION:
+*       Wait for the given uSec and return.
+*        Current Switch devices with Gigabit Ethernet Support require 250 uSec
+*        of delay time for PPU to be disabled.
+*        Since this function is System and/or OS dependent, it should be provided
+*        by each DSDT user.
+*
+* INPUTS:
+*       delayTime - delay in uSec.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void gtDelay
+(
+    IN const unsigned int delayTime
+)
+{
+
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtVct.c
@@ -0,0 +1,1248 @@
+#include <Copyright.h>
+/*******************************************************************************
+* gtVct.c
+*
+* DESCRIPTION:
+*       API for Marvell Virtual Cable Tester.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+#include <msApi.h>
+#include <gtVct.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtSem.h>
+
+#ifdef GT_USE_MAD
+#include <gtMad.h>
+#endif
+
+#ifdef GT_USE_MAD
+#include "gtVct_mad.c"
+#endif
+
+/*******************************************************************************
+* analizePhy100MVCTResult
+*
+* DESCRIPTION:
+*       This routine analize the virtual cable test result for 10/100M Phy
+*
+* INPUTS:
+*       regValue - test result
+*
+* OUTPUTS:
+*       cableStatus - analized test result.
+*       cableLen    - cable length or the distance where problem occurs.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static
+GT_STATUS analizePhy100MVCTResult
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U16 regValue,
+    OUT GT_TEST_STATUS *cableStatus,
+    OUT GT_CABLE_LEN *cableLen
+)
+{
+    int len;
+
+    GT_UNUSED_PARAM(dev);
+
+    switch((regValue & 0x6000) >> 13)
+    {
+        case 0:
+            /* test passed. No problem found. */
+            /* check if there is impedance mismatch */
+            if ((regValue & 0xFF) == 0xFF)
+            {
+                *cableStatus = GT_NORMAL_CABLE;
+                cableLen->normCableLen = GT_UNKNOWN_LEN;
+            }
+            else
+            {
+                *cableStatus = GT_IMPEDANCE_MISMATCH;
+                len = (int)FORMULA_PHY100M(regValue & 0xFF);
+                if(len <= 0)
+                    cableLen->errCableLen = 0;
+                else
+                    cableLen->errCableLen = (GT_U8)len;
+            }
+
+            break;
+        case 1:
+            /* test passed. Cable is short. */
+            *cableStatus = GT_SHORT_CABLE;
+            len = (int)FORMULA_PHY100M(regValue & 0xFF);
+            if(len <= 0)
+                cableLen->errCableLen = 0;
+            else
+                cableLen->errCableLen = (GT_U8)len;
+            break;
+        case 2:
+            /* test passed. Cable is open. */
+            *cableStatus = GT_OPEN_CABLE;
+            len = (int)FORMULA_PHY100M(regValue & 0xFF);
+            if(len <= 0)
+                cableLen->errCableLen = 0;
+            else
+                cableLen->errCableLen = (GT_U8)len;
+            break;
+        case 3:
+        default:
+            /* test failed. No result is valid. */
+            *cableStatus = GT_TEST_FAIL;
+            break;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* getCableStatus_Phy100M
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the 10/100Mbps phy,
+*       and returns the the status per Rx/Tx pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static
+GT_STATUS getCableStatus_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status;
+    GT_U16 reg26, reg27;
+
+    DBG_INFO(("getCableStatus_100Phy Called.\n"));
+
+
+    /* Wait until the Table is ready. */
+    /*
+     *     phy should be in 100 Full Duplex.
+     */
+    if((status= hwWritePhyReg(dev,hwPort,0,QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*
+     * start Virtual Cable Tester
+     */
+    if((status= hwWritePhyReg(dev,hwPort,26,0x8000)) != GT_OK)
+    {
+        return status;
+    }
+
+    do
+    {
+        if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
+        {
+            return status;
+        }
+
+    } while(reg26 & 0x8000);
+
+    /*
+     * read the test result for RX Pair
+     */
+    if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*
+     * read the test result for TX Pair
+     */
+    if((status= hwReadPhyReg(dev,hwPort,27,&reg27)) != GT_OK)
+    {
+        return status;
+    }
+
+    cableStatus->phyType = PHY_100M;
+
+    /*
+     * analyze the test result for RX Pair
+     */
+    analizePhy100MVCTResult(dev, reg26, &cableStatus->cableStatus[MDI_RX_PAIR],
+                            &cableStatus->cableLen[MDI_RX_PAIR]);
+
+    /*
+     * analyze the test result for TX Pair
+     */
+    analizePhy100MVCTResult(dev, reg27, &cableStatus->cableStatus[MDI_TX_PAIR],
+                            &cableStatus->cableLen[MDI_TX_PAIR]);
+
+    return status;
+}
+
+static
+GT_STATUS  enable1stWorkAround_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort
+)
+{
+    GT_U16      value;
+    GT_STATUS   status;
+
+    /* enable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 3)) != GT_OK)
+       return status;
+
+    value = 0x6440;
+    if ((status = hwWritePhyReg(dev, hwPort, 30, value)) != GT_OK)
+       return status;
+
+    return GT_OK;
+}
+
+static
+GT_STATUS  disable1stWorkAround_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort
+)
+{
+    GT_STATUS status;
+
+    /* disable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 3)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0)) != GT_OK)
+       return status;
+
+    return GT_OK;
+}
+
+static
+GT_STATUS workAround_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status = GT_OK;
+
+    /*
+     * If Cable Status is OPEN and the length is less than 15m,
+     * then apply Work Around.
+     */
+
+    if((cableStatus->cableStatus[MDI_RX_PAIR] == GT_OPEN_CABLE) ||
+        (cableStatus->cableStatus[MDI_TX_PAIR] == GT_OPEN_CABLE))
+    {
+        /* must be disabled first and then enable again */
+        disable1stWorkAround_Phy100M(dev,hwPort);
+
+        enable1stWorkAround_Phy100M(dev,hwPort);
+
+        if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
+        {
+            return status;
+        }
+        if((status= hwWritePhyReg(dev,hwPort,30,0x0002)) != GT_OK)
+        {
+            return status;
+        }
+
+        if((status = getCableStatus_Phy100M(dev,hwPort,cableStatus)) != GT_OK)
+        {
+            return status;
+        }
+
+        if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
+        {
+            return status;
+        }
+        if((status= hwWritePhyReg(dev,hwPort,30,0x0000)) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    return status;
+}
+
+
+static
+GT_STATUS  enable1stWorkAround_Phy1000M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort
+)
+{
+    GT_STATUS   status;
+
+    /* enable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 0x0018)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00ca)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
+       return status;
+    return GT_OK;
+}
+
+static
+GT_STATUS  disable1stWorkAround_Phy1000M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort
+)
+{
+    GT_STATUS status;
+
+    /* disable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 0x0018)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x0042)) != GT_OK)
+       return status;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* analizePhy1000MVCTResult
+*
+* DESCRIPTION:
+*       This routine analize the virtual cable test result for a Gigabit Phy
+*
+* INPUTS:
+*       reg17 - original value of register 17
+*       regValue - test result
+*
+* OUTPUTS:
+*       cableStatus - analized test result.
+*       cableLen    - cable length or the distance where problem occurs.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static
+GT_STATUS analizePhy1000MVCTResult
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U16 reg17,
+    IN  GT_U16 regValue,
+    OUT GT_TEST_STATUS *cableStatus,
+    OUT GT_CABLE_LEN *cableLen
+)
+{
+    GT_U16 u16Data;
+    int len;
+
+    GT_UNUSED_PARAM(dev);
+
+    switch((regValue & 0x6000) >> 13)
+    {
+        case 0:
+
+            /* Check Impedance Mismatch */
+            if ((regValue & 0xFF) < 0xFF)
+            {
+                /*  if the reflected amplitude is low it is good cable too.
+                    for this registers values it is a good cable:
+                    0xE23, 0xE24, 0xE25, 0xE26, 0xE27 */
+                if ((regValue < 0xE23) || (regValue > 0xE27))
+                {
+                    *cableStatus = GT_IMPEDANCE_MISMATCH;
+                    len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+                    if(len <= 0)
+                        cableLen->errCableLen = 0;
+                    else
+                        cableLen->errCableLen = (GT_U8)len;
+                    break;
+                }
+            }
+
+            /* test passed. No problem found. */
+            *cableStatus = GT_NORMAL_CABLE;
+
+            u16Data = reg17;
+
+            /* To get Cable Length, Link should be on and Speed should be 100M or 1000M */
+            if(!(u16Data & 0x0400))
+            {
+                cableLen->normCableLen = GT_UNKNOWN_LEN;
+                break;
+            }
+
+            if((u16Data & 0xC000) != 0x8000)
+            {
+                cableLen->normCableLen = GT_UNKNOWN_LEN;
+                break;
+            }
+
+            /*
+             * read the test result for the selected MDI Pair
+             */
+
+            u16Data = ((u16Data >> 7) & 0x7);
+
+            switch(u16Data)
+            {
+                case 0:
+                    cableLen->normCableLen = GT_LESS_THAN_50M;
+                    break;
+                case 1:
+                    cableLen->normCableLen = GT_50M_80M;
+                    break;
+                case 2:
+                    cableLen->normCableLen = GT_80M_110M;
+                    break;
+                case 3:
+                    cableLen->normCableLen = GT_110M_140M;
+                    break;
+                case 4:
+                    cableLen->normCableLen = GT_MORE_THAN_140;
+                    break;
+                default:
+                    cableLen->normCableLen = GT_UNKNOWN_LEN;
+                    break;
+            }
+            break;
+        case 1:
+            /* test passed. Cable is short. */
+            *cableStatus = GT_SHORT_CABLE;
+            len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+            if(len <= 0)
+                cableLen->errCableLen = 0;
+            else
+                cableLen->errCableLen = (GT_U8)len;
+            break;
+        case 2:
+            /* test passed. Cable is open. */
+            *cableStatus = GT_OPEN_CABLE;
+            len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+            if(len <= 0)
+                cableLen->errCableLen = 0;
+            else
+                cableLen->errCableLen = (GT_U8)len;
+            break;
+        case 3:
+        default:
+            /* test failed. No result is valid. */
+            *cableStatus = GT_TEST_FAIL;
+            break;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* getCableStatus_Phy1000M
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the 10/100Mbps phy,
+*       and returns the the status per Rx/Tx pair.
+*
+* INPUTS:
+*       port - logical port number.
+*        reg17 - original value of reg17.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static
+GT_STATUS getCableStatus_Phy1000M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort,
+    IN  GT_U16             reg17,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status;
+    GT_U16 reg28;
+    int i;
+
+    DBG_INFO(("getCableStatus_Phy1000M Called.\n"));
+
+    /*
+     * start Virtual Cable Tester
+     */
+    if((status= hwWritePagedPhyReg(dev,hwPort,0,28,0,0x8000)) != GT_OK)
+    {
+        return status;
+    }
+
+    do
+    {
+        if((status= hwReadPhyReg(dev,hwPort,28,&reg28)) != GT_OK)
+        {
+            return status;
+        }
+
+    } while(reg28 & 0x8000);
+
+    cableStatus->phyType = PHY_1000M;
+
+    DBG_INFO(("Reg28 after test : %0#x.\n", reg28));
+
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        /*
+         * read the test result for the selected MDI Pair
+         */
+        if((status= hwReadPagedPhyReg(dev,hwPort,(GT_U8)i,28,0,&reg28)) != GT_OK)
+        {
+            return status;
+        }
+
+        /*
+         * analyze the test result for RX Pair
+         */
+        if((status = analizePhy1000MVCTResult(dev, reg17, reg28,
+                                &cableStatus->cableStatus[i],
+                                &cableStatus->cableLen[i])) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    return GT_OK;
+}
+
+static
+GT_STATUS workAround_Phy1000M
+(
+  GT_QD_DEV *dev,
+  GT_U8 hwPort
+)
+{
+    GT_STATUS status;
+
+    DBG_INFO(("workAround for Gigabit Phy Called.\n"));
+
+    /* enable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 0x0018)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
+       return status;
+
+    if((status = hwWritePhyReg(dev,hwPort,29,0x1e)) != GT_OK)
+    {
+        return status;
+    }
+
+    if((status = hwWritePhyReg(dev,hwPort,30,0xcc00)) != GT_OK)
+    {
+        return status;
+    }
+
+    if((status = hwWritePhyReg(dev,hwPort,30,0xc800)) != GT_OK)
+    {
+        return status;
+    }
+    if((status = hwWritePhyReg(dev,hwPort,30,0xc400)) != GT_OK)
+    {
+        return status;
+    }
+    if((status = hwWritePhyReg(dev,hwPort,30,0xc000)) != GT_OK)
+    {
+        return status;
+    }
+    if((status = hwWritePhyReg(dev,hwPort,30,0xc100)) != GT_OK)
+    {
+        return status;
+    }
+
+    DBG_INFO(("workAround for Gigabit Phy completed.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* getCableStatus_Phy1000MPage
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the 10/100Mbps phy with
+*       multiple page mode and returns the the status per MDIP/N.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static
+GT_STATUS getCableStatus_Phy1000MPage
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort,
+    IN  GT_PHY_INFO        *phyInfo,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status;
+    GT_U16 u16Data;
+    GT_U16 reg17 = 0;
+    int i;
+
+    DBG_INFO(("getCableStatus_Phy1000M Called.\n"));
+
+    /*
+     * If Fiber is used, simply return with test fail.
+     */
+    if(phyInfo->flag & GT_PHY_FIBER)
+    {
+        if((status= hwReadPagedPhyReg(dev,hwPort,1,17,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+
+        if(u16Data & 0x400)
+        {
+            for (i=0; i<GT_MDI_PAIR_NUM; i++)
+            {
+                cableStatus->cableStatus[i] = GT_TEST_FAIL;
+            }
+            return GT_OK;
+        }
+    }
+
+    /*
+     * If Copper is used and Link is on, get DSP Distance and put it in the
+     * old reg17 format.(bit9:7 with DSP Distance)
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        return status;
+    }
+
+    if(u16Data & 0x400)
+    {
+        reg17 = (u16Data & 0xC000) | 0x400;
+
+        if((status= hwReadPagedPhyReg(dev,hwPort,5,26,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+        reg17 |= ((u16Data & 0x7) << 7);
+    }
+
+    /*
+     * start Virtual Cable Tester
+     */
+    if((status= hwWritePagedPhyReg(dev,hwPort,5,16,phyInfo->anyPage,0x8000)) != GT_OK)
+    {
+        return status;
+    }
+
+    do
+    {
+        if((status= hwReadPagedPhyReg(dev,hwPort,5,16,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+
+    } while(u16Data & 0x8000);
+
+    cableStatus->phyType = PHY_1000M;
+
+    DBG_INFO(("Page 5 of Reg16 after test : %0#x.\n", u16Data));
+
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        /*
+         * read the test result for the selected MDI Pair
+         */
+        if((status= hwReadPagedPhyReg(dev,hwPort,5,(GT_U8)(16+i),phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+
+        /*
+         * analyze the test result for RX Pair
+         */
+        if((status = analizePhy1000MVCTResult(dev, reg17, u16Data,
+                                &cableStatus->cableStatus[i],
+                                &cableStatus->cableLen[i])) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvctGetCableStatus
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the requested port,
+*       and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvCableDiag
+*        API can be used, instead.
+*
+*******************************************************************************/
+GT_STATUS gvctGetCableDiag
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status;
+    GT_U8 hwPort;
+    GT_U16 orgReg0, orgReg17;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+    if (dev->use_mad==GT_TRUE)
+    {
+        return gvctGetCableDiag_mad(dev, port, cableStatus);
+    }
+#endif
+
+    DBG_INFO(("gvctGetCableDiag Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_VCT_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /*
+     * save original register 17 value, which will be used later depending on
+     * test result.
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&orgReg17)) != GT_OK)
+    {
+        DBG_INFO(("Not able to reset the Phy.\n"));
+        goto cableDiagCleanup;
+    }
+
+    /*
+     * save Config Register data
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,&orgReg0)) != GT_OK)
+    {
+        DBG_INFO(("Not able to reset the Phy.\n"));
+        goto cableDiagCleanup;
+    }
+    switch(phyInfo.vctType)
+    {
+        case GT_PHY_VCT_TYPE1:
+            enable1stWorkAround_Phy100M(dev,hwPort);
+            status = getCableStatus_Phy100M(dev,hwPort,cableStatus);
+            /* every fast ethernet phy requires this work-around */
+            workAround_Phy100M(dev,hwPort,cableStatus);
+            disable1stWorkAround_Phy100M(dev,hwPort);
+            break;
+        case GT_PHY_VCT_TYPE2:
+            enable1stWorkAround_Phy1000M(dev,hwPort);
+            status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
+            disable1stWorkAround_Phy1000M(dev,hwPort);
+            break;
+        case GT_PHY_VCT_TYPE3:
+            enable1stWorkAround_Phy1000M(dev,hwPort);
+            workAround_Phy1000M(dev,hwPort);
+            status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
+            disable1stWorkAround_Phy1000M(dev,hwPort);
+            break;
+        case GT_PHY_VCT_TYPE4:
+            status = getCableStatus_Phy1000MPage(dev,hwPort,&phyInfo,cableStatus);
+            break;
+        default:
+            status = GT_FAIL;
+            break;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT))
+    {
+        if((status = hwPhyReset(dev,hwPort,orgReg0)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+    }
+    else
+    {
+        /*
+         * restore Config Register Data
+         */
+        if((status= hwWritePagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,orgReg0)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+
+        /* soft reset */
+        if((status = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+    }
+
+cableDiagCleanup:
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;
+}
+
+
+/*******************************************************************************
+* getExStatus1000M
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*        for 1000M phy
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static GT_STATUS getExStatus1000M
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8           hwPort,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS status;
+    GT_U16 u16Data, i;
+
+    /*
+     * get data from 28_5 register
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,5,28,0,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read a Phy register.\n"));
+        return status;
+    }
+
+    /* if bit 6 is not set, it's not valid. */
+    if (!(u16Data & 0x0040))
+    {
+        DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+        extendedStatus->isValid = GT_FALSE;
+        return GT_OK;
+    }
+
+    extendedStatus->isValid = GT_TRUE;
+
+    /* get Pair Polarity */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        switch((u16Data >> i) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairPolarity[i] = GT_POSITIVE;
+                break;
+            default:
+                extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+                break;
+        }
+    }
+
+    /* get Pair Swap */
+    for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
+    {
+        switch((u16Data >> (i+4)) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
+                break;
+            default:
+                extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
+                break;
+        }
+    }
+
+    /*
+     * get data from 28_4 register
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,4,28,0,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read a Phy register.\n"));
+        return status;
+    }
+
+    /* get Pair Skew */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* getExStatus1000MPage
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*        for 1000M phy with multiple page mode
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static GT_STATUS getExStatus1000MPage
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            hwPort,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS status;
+    GT_U16 u16Data, i;
+
+    /*
+     * get data from 21_5 register for pair swap
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,5,21,0,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read a paged Phy register.\n"));
+        return status;
+    }
+
+    /* if bit 6 is not set, it's not valid. */
+    if (!(u16Data & 0x0040))
+    {
+        DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+        extendedStatus->isValid = GT_FALSE;
+        return GT_OK;
+    }
+
+    extendedStatus->isValid = GT_TRUE;
+
+    /* get Pair Polarity */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        switch((u16Data >> i) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairPolarity[i] = GT_POSITIVE;
+                break;
+            default:
+                extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+                break;
+        }
+    }
+
+    /* get Pair Swap */
+    for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
+    {
+        switch((u16Data >> (i+4)) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
+                break;
+            default:
+                extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
+                break;
+        }
+    }
+
+    /*
+     * get data from 20_5 register for pair skew
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,5,20,0,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read a paged Phy register.\n"));
+        return status;
+    }
+
+    /* get Pair Skew */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvctGet1000BTExtendedStatus
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvExtendedStatus
+*        API can be used, instead.
+*
+*******************************************************************************/
+GT_STATUS gvctGet1000BTExtendedStatus
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS status;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+    DBG_INFO(("gvctGetCableDiag Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    switch(phyInfo.vctType)
+    {
+        case GT_PHY_VCT_TYPE2:
+            status = getExStatus1000M(dev,hwPort,extendedStatus);
+            break;
+        case GT_PHY_VCT_TYPE4:
+            status = getExStatus1000MPage(dev,hwPort,extendedStatus);
+            break;
+        default:
+               DBG_INFO(("Device is not supporting Extended Cable Status.\n"));
+            status = GT_NOT_SUPPORTED;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtVct_mad.c
@@ -0,0 +1,224 @@
+#include <Copyright.h>
+/*******************************************************************************
+* gtVct.c
+*
+* DESCRIPTION:
+*       API for Marvell Virtual Cable Tester.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+#include <msApi.h>
+#include <gtVct.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtSem.h>
+
+#include <madApi.h>
+
+
+/*******************************************************************************
+* gvctGetCableStatus_mad
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the requested port,
+*       and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvCableDiag
+*        API can be used, instead.
+*
+*******************************************************************************/
+GT_STATUS gvctGetCableDiag_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status=GT_OK;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gvctGetCableDiag_mad Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_VCT_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+
+    if ( mdDiagGetCableStatus(&(dev->mad_dev),port, (MAD_CABLE_STATUS*)cableStatus) != MAD_OK)
+    {
+      DBG_INFO(("Failed to run mdDiagGetCableStatus.\n"));
+      gtSemGive(dev,dev->phyRegsSem);
+      return GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;
+}
+
+
+
+/*******************************************************************************
+* gvctGet1000BTExtendedStatus_mad
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvExtendedStatus
+*        API can be used, instead.
+*
+*******************************************************************************/
+GT_STATUS gvctGet1000BTExtendedStatus_mad
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS status=GT_OK;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gvctGetCableDiag_mad Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+
+    if ( mdDiagGet1000BTExtendedStatus(&(dev->mad_dev),port,(MAD_1000BT_EXTENDED_STATUS*)extendedStatus) != MAD_OK)
+    {
+      DBG_INFO(("Failed to run mdDiagGet1000BTExtendedStatus.\n"));
+      gtSemGive(dev,dev->phyRegsSem);
+      return GT_FALSE;
+    }
+
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtVersion.c
@@ -0,0 +1,59 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtVersion.h
+*
+* DESCRIPTION:
+*       Includes software version information for the QuarterDeck software
+*       suite.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*
+*******************************************************************************/
+
+#include <msApi.h>
+
+char msApiCopyright[] = MSAPI_COPYRIGHT;
+char msApiVersion[] = MSAPI_VERSION;
+
+/*******************************************************************************
+* gtVersion
+*
+* DESCRIPTION:
+*       This function returns the version of the QuarterDeck SW suite.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       version     - QuarterDeck software version.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_BAD_PARAM on bad parameters,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gtVersion
+(
+    OUT GT_VERSION   *version
+)
+{
+    if(version == NULL)
+        return GT_BAD_PARAM;
+
+    if(gtStrlen(msApiVersion) > VERSION_MAX_LEN)
+    {
+        return GT_FAIL;
+    }
+
+    gtMemCpy(version->version,msApiVersion,gtStrlen(msApiVersion));
+    version->version[gtStrlen(msApiVersion)] = '\0';
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtWeight.c
@@ -0,0 +1,479 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtWeight.c
+*
+* DESCRIPTION:
+*       API definitions for Round Robin Weight table access
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gsysSetQoSWeight
+*
+* DESCRIPTION:
+*       Programmable Round Robin Weights.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and
+*        Queue 0 has the lowest priority. When a scheduling mode of port is
+*        configured as Weighted Round Robin queuing mode, the access sequece of the
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This sequence can be configured with this API.
+*
+* INPUTS:
+*       weight - access sequence of the queue
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysSetQoSWeight
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_QoS_WEIGHT    *weight
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+    GT_U32        len, i;
+
+    DBG_INFO(("gsysSetQoSWeight Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_WEIGHT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (weight->len > 128)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    len = weight->len/4;
+
+    /* program QoS Weight Table, 4 sequences at a time */
+
+    for(i=0; i<len; i++)
+    {
+        /* Wait until the QoS Weight Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+      data =  (GT_U16)((1 << 15) | (i << 8) |
+            (weight->queue[i*4] & 0x3) |
+            ((weight->queue[i*4+1] & 0x3) << 2) |
+            ((weight->queue[i*4+2] & 0x3) << 4) |
+            ((weight->queue[i*4+3] & 0x3) << 6));
+      regAccess.rw_reg_list[1].data = data;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+            gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+        }
+
+        data =  (GT_U16)((1 << 15) | (i << 8) |
+                (weight->queue[i*4] & 0x3) |
+                ((weight->queue[i*4+1] & 0x3) << 2) |
+                ((weight->queue[i*4+2] & 0x3) << 4) |
+                ((weight->queue[i*4+3] & 0x3) << 6));
+
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+#endif
+    }
+
+    /* program remaining sequences if any */
+    i = weight->len % 4;
+    if (i)
+    {
+        /* Wait until the QoS Weight Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 2;
+
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+          regAccess.rw_reg_list[0].data = 15;
+          regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+          regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+          regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+          data =  (GT_U16)((1 << 15) | (len << 8));
+          switch (i)
+          {
+            case 3:
+                data |= ((weight->queue[len*4+2] & 0x3) << 4);
+            case 2:
+                data |= ((weight->queue[len*4+1] & 0x3) << 2);
+            case 1:
+                data |= ((weight->queue[len*4+0] & 0x3) << 0);
+            break;
+            default:
+                DBG_INFO(("Should not come to this point.\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+            return GT_FALSE;
+          }
+          regAccess.rw_reg_list[1].data = data;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+          }
+        }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+        }
+
+        data =  (GT_U16)((1 << 15) | (len << 8));
+
+        switch (i)
+        {
+            case 3:
+                data |= ((weight->queue[len*4+2] & 0x3) << 4);
+            case 2:
+                data |= ((weight->queue[len*4+1] & 0x3) << 2);
+            case 1:
+                data |= ((weight->queue[len*4+0] & 0x3) << 0);
+                break;
+            default:
+                   DBG_INFO(("Should not come to this point.\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+                return GT_FALSE;
+        }
+
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+#endif
+    }
+
+    /* Write the lengh of the sequence */
+
+    /* Wait until the QoS Weight Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+      data =  (GT_U16)((1 << 15) | (0x20 << 8) | weight->len);
+      regAccess.rw_reg_list[1].data = data;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+    }
+#else
+       data = 1;
+    while(data == 1)
+       {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
+           if(retVal != GT_OK)
+           {
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+           }
+    }
+
+    data =  (GT_U16)((1 << 15) | (0x20 << 8) | weight->len);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+#endif
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetQoSWeight
+*
+* DESCRIPTION:
+*       Programmable Round Robin Weights.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and
+*        Queue 0 has the lowest priority. When a scheduling mode of port is
+*        configured as Weighted Round Robin queuing mode, the access sequece of the
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This routine retrieves the access sequence of the Queue.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       weight - access sequence of the queue
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gsysGetQoSWeight
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_QoS_WEIGHT    *weight
+)
+{
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data, i;
+    GT_U32        len;
+
+    DBG_INFO(("gsysGetQoSWeight Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_WEIGHT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Read the lengh of the sequence */
+
+    /* Wait until the QoS Weight Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+      data = (0x20 << 8);
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
+       data = 1;
+    while(data == 1)
+       {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
+           if(retVal != GT_OK)
+           {
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+           }
+    }
+
+    data = (0x20 << 8);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
+#endif
+    if(retVal != GT_OK)
+       {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    weight->len = data & 0xFF;
+
+    len = weight->len/4;
+
+    /* read QoS Weight Table, 4 sequences at a time */
+
+    for(i=0; i<len; i++)
+    {
+        data = i << 8;
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[0].data = data;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      data = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
+#endif
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+
+        weight->queue[i*4] = data & 0x3;
+        weight->queue[i*4+1] = (data >> 2) & 0x3;
+        weight->queue[i*4+2] = (data >> 4) & 0x3;
+        weight->queue[i*4+3] = (data >> 6) & 0x3;
+
+    }
+
+    /* read remaining sequences if any */
+    i = (GT_U16) (weight->len % 4);
+    if (i)
+    {
+        data = (GT_U16)(len << 8);
+
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 2;
+
+          regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+          regAccess.rw_reg_list[0].data = data;
+          regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+          regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+          regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+          regAccess.rw_reg_list[1].data = 0;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          data = qdLong2Short(regAccess.rw_reg_list[1].data);
+        }
+#else
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
+#endif
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+
+        switch (i)
+        {
+            case 3:
+                weight->queue[len*4+2] = (data >> 4) & 0x3;
+            case 2:
+                weight->queue[len*4+1] = (data >> 2) & 0x3;
+            case 1:
+                weight->queue[len*4] = data & 0x3;
+                break;
+            default:
+                   DBG_INFO(("Should not come to this point.\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+                return GT_FALSE;
+        }
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/makefile
@@ -0,0 +1,49 @@
+# Source files in this directory
+TARGET =
+CSOURCES	= gtBrgFdb.c gtBrgStp.c gtBrgVlan.c \
+			gtEvents.c \
+			gtPortCtrl.c gtPortStat.c gtPortStatus.c \
+			gtQosMap.c gtPIRL.c	\
+			gtPhyCtrl.c gtPhyInt.c \
+			gtSysConfig.c gtSysCtrl.c gtVersion.c gtUtils.c \
+			gtBrgVtu.c gtPortRmon.c gtSysStatus.c \
+			gtPortRateCtrl.c gtPortPav.c gtVct.c gtAdvVct.c gtPCSCtrl.c \
+			gtBrgStu.c gtCCPVT.c gtPIRL2.c gtPolicy.c \
+			gtTCAM.c \
+			gtPriTable.c gtWeight.c gtAVB.c gtPTP.c gtPortLed.c gtMisc.c
+
+ASOURCES	=
+
+# Include common variable definitions
+ifeq ($(OS_RUN),VXWORKS)
+include $(DSDT_TOOL_DIR)\make.defs
+endif
+ifeq ($(OS_RUN),WIN32)
+include $(DSDT_TOOL_DIR)\makewce.defs
+endif
+ifeq ($(OS_RUN),LINUX)
+include $(DSDT_TOOL_DIR)/makelnx.defs
+endif
+
+# Add in extra stuffs
+EXTRA_INCLUDE	+=
+EXTRA_DEFINE	+=
+ADDED_CFLAGS	+=
+
+ifeq ($(DSDT_USE_MAD),TRUE)
+#CSOURCES	+= gtPhyCtrl_mad.c gtPhyInt_mad.c gtVct_mad.c gtAdvVct_mad.c
+ADDED_CFLAGS	+= -DGT_USE_MAD
+endif
+
+# Include common build rules
+ifeq ($(OS_RUN),VXWORKS)
+include $(DSDT_TOOL_DIR)\make.rules
+endif
+ifeq ($(OS_RUN),WIN32)
+include $(DSDT_TOOL_DIR)\makewce.rules
+endif
+ifeq ($(OS_RUN),LINUX)
+include $(DSDT_TOOL_DIR)/makelnx.rules
+endif
+
+# end of file
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtDebug.c
@@ -0,0 +1,78 @@
+#include <Copyright.h>
+/********************************************************************************
+* debug.c
+*
+* DESCRIPTION:
+*       Debug message display routine
+*
+* DEPENDENCIES:
+*       OS Dependent
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+#include <msApi.h>
+
+#ifdef DEBUG_QD
+#ifdef _VXWORKS
+#include "vxWorks.h"
+#include "logLib.h"
+#include "stdarg.h"
+#elif defined(WIN32)
+#include "windows.h"
+/* #include "wdm.h" */
+#elif defined(LINUX)
+#include "stdarg.h"
+#endif
+
+/*******************************************************************************
+* gtDbgPrint
+*
+* DESCRIPTION:
+*       .
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+#if defined(_VXWORKS) || defined(WIN32) || defined(LINUX)
+void gtDbgPrint(char* format, ...)
+{
+    va_list argP;
+    char dbgStr[1000] = "";
+
+    va_start(argP, format);
+
+    vsprintf(dbgStr, format, argP);
+
+#ifdef _VXWORKS
+    printf("%s",dbgStr);
+/*    logMsg(dbgStr,0,1,2,3,4,5); */
+#elif defined(WIN32)
+    printf("%s",dbgStr);
+/*    DbgPrint(dbgStr);*/
+#elif defined(LINUX)
+    printk("%s",dbgStr);
+#endif
+    return;
+}
+#else
+void gtDbgPrint(char* format, ...)
+{
+    GT_UNUSED_PARAM(format);
+}
+#endif
+#else /* DEBUG_QD not defined */
+void gtDbgPrint(char* format, ...)
+{
+    GT_UNUSED_PARAM(format);
+}
+#endif /* DEBUG_QD */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtMiiSmiIf.c
@@ -0,0 +1,833 @@
+#include <Copyright.h>
+/********************************************************************************
+* gtMiiSmiIf.c
+*
+* DESCRIPTION:
+*       Includes functions prototypes for initializing and accessing the
+*       MII / SMI interface.
+*       This is the only file to be included from upper layers.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*
+*******************************************************************************/
+
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtMiiSmiIf.h>
+#include <platformDeps.h>
+#include <gtSem.h>
+
+/* Local sub-functions */
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MIIReg,
+                        unsigned int* value);
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MIIReg,
+                       unsigned int value);
+static GT_BOOL fgtReadMii(GT_QD_DEV*dev, unsigned int phyAddr, unsigned int miiReg, unsigned int* value);
+static GT_BOOL fgtWriteMii(GT_QD_DEV*dev, unsigned int phyAddr, unsigned int miiReg, unsigned int value);
+
+#ifdef GT_RMGMT_ACCESS
+static GT_BOOL fgtAccessRegs(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList);
+static GT_BOOL qdMultiAddrAccess(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList);
+#endif
+
+/*******************************************************************************
+* miiSmiIfInit
+*
+* DESCRIPTION:
+*       This function initializes the MII / SMI interface.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       highSmiDevAddr - Indicates whether to use the high device register
+*                     addresses when accessing switch's registers (of all kinds)
+*                     i.e, the devices registers range is 0x10 to 0x1F, or to
+*                     use the low device register addresses (range 0x0 to 0xF).
+*                       GT_TRUE     - use high addresses (0x10 to 0x1F).
+*                       GT_FALSE    - use low addresses (0x0 to 0xF).
+*
+* RETURNS:
+*       DEVICE_ID       - on success
+*       0    - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U16 miiSmiIfInit
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL * highSmiDevAddr
+)
+{
+    GT_STATUS status;
+    GT_U16 data, data1;
+
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR,QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
+
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+1,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+    {
+        return 0;
+    }
+
+    switch(data & 0xFF00)
+    {
+        case 0x0200:
+        case 0x0300:
+        case 0x0500:
+        case 0x0600:
+        case 0x1500:
+        case 0xC000:        /* Melody */
+        case 0x0700:        /* Spinnaker */
+        case 0x2200:        /* Spinnaker */
+        case 0x2500:        /* Spinnaker */
+        case 0xF500:
+        case 0xF900:
+            if (data == data1)
+            {
+                *highSmiDevAddr = GT_FALSE;
+                return data;
+            }
+            break;
+        default:
+            break;
+    }
+
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x10,QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
+
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x11,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+    {
+        return 0;
+    }
+
+    switch(data & 0xFF00)
+    {
+        case 0x0200:
+        case 0x0300:
+        case 0x0500:
+        case 0x0600:
+        case 0x1500:
+        case 0xC000:        /* Melody */
+        case 0x0700:        /* Spinnaker */
+        case 0x2200:        /* Spinnaker */
+        case 0x2500:        /* Spinnaker */
+        case 0xF500:
+        case 0xF900:
+            if (data == data1)
+            {
+                *highSmiDevAddr = GT_TRUE;
+                return data;
+            }
+            break;
+        default:
+            break;
+    }
+
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR_8PORT,QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
+
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR_8PORT+1,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+    {
+        return 0;
+    }
+
+    switch(data & 0xFF00)
+    {
+        case 0x0800:
+        case 0x1A00:
+        case 0x1000:
+        case 0x0900:
+        case 0x0400:
+        case 0x1200:
+        case 0x1400:
+        case 0x1600:
+        case 0x1700:
+        case 0x3200:
+        case 0x3700:
+        case 0x2400:    /* Agate */
+        case 0x3500:    /* Agate */
+        case 0x1100:    /* Pearl */
+        case 0x3100:    /* Pearl */
+            if (data == data1)
+            {
+                *highSmiDevAddr = GT_FALSE;
+                return data;
+            }
+            break;
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+
+/*******************************************************************************
+* miiSmiManualIfInit
+*
+* DESCRIPTION:
+*       This function returns Device ID from the given base address
+*
+* INPUTS:
+*       baseAddr - either 0x0 or 0x10. Indicates whether to use the low device
+*                    register address or high device register address.
+*                    The device register range is from 0x0 to 0xF or from 0x10
+*                    to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port
+*                    switchs.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       DEVICE_ID       - on success
+*       0    - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U16 miiSmiManualIfInit
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_U32        baseAddr
+)
+{
+    GT_STATUS status;
+    GT_U16 data;
+
+
+    if((status = miiSmiIfReadRegister(dev,(GT_U8)(PORT_REGS_START_ADDR+baseAddr),QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
+
+    switch(data & 0xFF00)
+    {
+        case 0x0200:
+        case 0x0300:
+        case 0x0500:
+        case 0x0600:
+        case 0x1500:
+        case 0xF500:
+        case 0xF900:
+        case 0x0700:        /* Spinnaker */
+        case 0x2200:        /* Spinnaker */
+        case 0x2500:        /* Spinnaker */
+            return data;
+        case 0xC000:        /* Melody, Now it could be 0xc00 - 0xc07 */
+            return data&0xFF0F;
+        default:
+            break;
+    }
+    if(baseAddr != 0)
+        return 0;
+
+    if((status = miiSmiIfReadRegister(dev,(GT_U8)(PORT_REGS_START_ADDR_8PORT+baseAddr),QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
+
+    switch(data & 0xFF00)
+    {
+        case 0x0800:
+        case 0x1A00:
+        case 0x1000:
+        case 0x0900:
+        case 0x0400:
+        case 0x1200:
+        case 0x1400:
+        case 0x1600:
+        case 0x3200:
+        case 0x1700:
+        case 0x3700:
+        case 0x2400:    /* Agate */
+        case 0x3500:    /* Agate */
+        case 0x1100:    /* Pearl */
+        case 0x3100:    /* Pearl */
+            return data;
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+/*******************************************************************************
+* Following functions are internal APIs between Driver layer and Platform layer
+********************************************************************************/
+
+/*******************************************************************************
+* miiSmiIfReadRegister
+*
+* DESCRIPTION:
+*       This function reads a register throw the SMI / MII interface, to be used
+*       by upper layers.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*
+* OUTPUTS:
+*       data        - The register's data.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS miiSmiIfReadRegister
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U8        phyAddr,
+    IN  GT_U8        regAddr,
+    OUT GT_U16       *data
+)
+{
+    unsigned int tmpData;
+#ifdef GT_RMGMT_ACCESS
+    if((dev->accessMode == SMI_MULTI_ADDR_MODE) &&
+       (dev->fgtHwAccessMod == HW_ACCESS_MODE_SMI))
+#else
+    if(dev->accessMode == SMI_MULTI_ADDR_MODE)
+#endif
+    {
+         if(qdMultiAddrRead(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
+        {
+            return GT_FAIL;
+        }
+    }
+    else
+    {
+         if(fgtReadMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
+        {
+            return GT_FAIL;
+        }
+    }
+    *data = (GT_U16)tmpData;
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* miiSmiIfWriteRegister
+*
+* DESCRIPTION:
+*       This function writes to a register throw the SMI / MII interface, to be
+*       used by upper layers.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       data        - The data to be written to the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS miiSmiIfWriteRegister
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U8        phyAddr,
+    IN  GT_U8        regAddr,
+    IN  GT_U16       data
+)
+{
+#ifdef GT_RMGMT_ACCESS
+    if((dev->accessMode == SMI_MULTI_ADDR_MODE) &&
+       (dev->fgtHwAccessMod == HW_ACCESS_MODE_SMI))
+#else
+    if(dev->accessMode == SMI_MULTI_ADDR_MODE)
+#endif
+    {
+         if(qdMultiAddrWrite(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
+        {
+            return GT_FAIL;
+        }
+    }
+    else
+    {
+        if(fgtWriteMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
+        {
+            return GT_FAIL;
+        }
+    }
+    return GT_OK;
+}
+
+#ifdef GT_RMGMT_ACCESS
+
+/*******************************************************************************
+* qdAccessRegs
+*
+* DESCRIPTION:
+*       This function access registers through device interface
+*        (like Marvell F2R on ethernet) by user, to be used by upper layers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG includes:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1
+*     addr - SMI Address
+*     reg  - Register offset
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS qdAccessRegs
+(
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+)
+{
+  if((dev->accessMode == SMI_MULTI_ADDR_MODE) &&
+     (dev->fgtHwAccessMod == HW_ACCESS_MODE_SMI))
+  {
+      if(qdMultiAddrAccess(dev, regList) != GT_TRUE)
+      {
+        return GT_FAIL;
+      }
+  }
+  else
+  {
+    if ((IS_IN_DEV_GROUP(dev,DEV_RMGMT)) &&
+        (dev->fgtHwAccess != NULL) &&
+        (dev->fgtHwAccessMod == HW_ACCESS_MODE_F2R) )
+    {
+      if(dev->fgtHwAccess(dev, regList) != GT_TRUE)
+      {
+        if(fgtAccessRegs(dev, regList) != GT_TRUE)
+        {
+          return GT_FAIL;
+        }
+      }
+    }
+    else
+    {
+      if(fgtAccessRegs(dev, regList) != GT_TRUE)
+      {
+        return GT_FAIL;
+      }
+    }
+  }
+  return GT_OK;
+
+}
+#endif
+
+
+/* Local sub-functions */
+
+/*****************************************************************************
+* qdMultiAddrRead
+*
+* DESCRIPTION:
+*       This function reads data from a device in the secondary MII bus.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The storage where register date to be saved.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int* value)
+{
+    unsigned int smiReg;
+    volatile unsigned int timeOut; /* in 100MS units */
+    volatile int i;
+
+    /* first check that it is not busy */
+    if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+
+    if(smiReg & QD_SMI_BUSY)
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+        do
+        {
+            if(timeOut-- < 1 )
+            {
+                return GT_FALSE;
+            }
+            if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+            {
+                return GT_FALSE;
+            }
+        } while (smiReg & QD_SMI_BUSY);
+    }
+
+    smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) |
+            (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+    if(fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+    if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+
+    if(smiReg & QD_SMI_BUSY)
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+        do
+        {
+            if(timeOut-- < 1 )
+            {
+                return GT_FALSE;
+            }
+            if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+            {
+                return GT_FALSE;
+            }
+        } while (smiReg & QD_SMI_BUSY);
+    }
+    if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, &smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    *value = smiReg;
+
+    return GT_TRUE;
+}
+
+/*****************************************************************************
+* qdMultiAddrWrite
+*
+* DESCRIPTION:
+*       This function writes data to the device in the secondary MII bus.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The data to be written into the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int value)
+{
+    unsigned int smiReg;
+    volatile unsigned int timeOut; /* in 100MS units */
+    volatile int i;
+
+    /* first check that it is not busy */
+    if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+
+    if(smiReg & QD_SMI_BUSY)
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+        do
+        {
+            if(timeOut-- < 1 )
+            {
+                return GT_FALSE;
+            }
+            if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+            {
+                return GT_FALSE;
+            }
+        } while (smiReg & QD_SMI_BUSY);
+    }
+
+    if(fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, value) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) |
+            (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+    if(fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+
+    return GT_TRUE;
+}
+
+
+static GT_BOOL fgtReadMii(GT_QD_DEV*dev, unsigned int phyAddr, unsigned int reg, unsigned int* value)
+{
+  GT_BOOL retVal;
+  retVal =  dev->fgtReadMii(dev, phyAddr, reg, value);
+  return  retVal;
+}
+
+
+static GT_BOOL fgtWriteMii(GT_QD_DEV*dev, unsigned int phyAddr, unsigned int reg, unsigned int value)
+{
+  GT_BOOL retVal;
+  retVal = dev->fgtWriteMii(dev, phyAddr, reg, value);
+  return  retVal;
+}
+
+#ifdef GT_RMGMT_ACCESS
+
+static GT_BOOL fgtAccessRegs(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList)
+{
+  int i;
+  GT_BOOL retVal = GT_TRUE;
+  unsigned short data, mask;
+  unsigned int tmpData;
+  for (i=0; i<regList->entries; i++)
+  {
+    switch (regList->rw_reg_list[i].cmd)
+    {
+      case HW_REG_READ:
+        retVal=dev->fgtReadMii(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&(regList->rw_reg_list[i].data));
+        break;
+      case HW_REG_WRITE:
+        retVal=dev->fgtWriteMii(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, regList->rw_reg_list[i].data);
+        break;
+      case HW_REG_WAIT_TILL_0:
+      {
+        mask = (1<<regList->rw_reg_list[i].data);
+        do
+        {
+          retVal=dev->fgtReadMii(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&tmpData);
+          if(retVal != GT_TRUE)
+          {
+            return retVal;
+          }
+          data = tmpData;
+        } while(data & mask);
+      }
+        break;
+      case HW_REG_WAIT_TILL_1:
+      {
+        mask = (1<<regList->rw_reg_list[i].data);
+        do
+        {
+          retVal=dev->fgtReadMii(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&tmpData);
+          if(retVal != GT_TRUE)
+          {
+            return retVal;
+          }
+          data = tmpData;
+        } while(!(data & mask));
+      }
+        break;
+
+      default:
+        return GT_FALSE;
+    }
+  }
+    return retVal;
+}
+
+GT_BOOL qdAccessMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int* value)
+{
+  GT_U16 smiReg;
+
+  HW_DEV_REG_ACCESS regAccess;
+
+  regAccess.entries = 4;
+
+  regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[0].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[0].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[0].data = 15;
+  smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) | (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+  regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[1].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[1].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[1].data = smiReg;
+
+  regAccess.rw_reg_list[2].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[2].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[2].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[2].data = 15;
+
+  regAccess.rw_reg_list[3].cmd = HW_REG_READ;
+  regAccess.rw_reg_list[3].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[3].reg = QD_REG_SMI_DATA;
+  regAccess.rw_reg_list[3].data = 0;
+  if(dev->fgtHwAccess(dev, &regAccess) != GT_TRUE)
+  {
+    return GT_FALSE;
+  }
+  *value = (unsigned short)regAccess.rw_reg_list[3].data;
+
+  return GT_TRUE;
+}
+GT_BOOL qdAccessMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int value)
+{
+  GT_U16 smiReg;
+
+  HW_DEV_REG_ACCESS regAccess;
+
+  regAccess.entries = 3;
+
+  regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[0].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[0].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[0].data = 15;
+
+  regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[1].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[1].reg = QD_REG_SMI_DATA;
+  regAccess.rw_reg_list[1].data = value;
+
+  smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) | (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+  regAccess.rw_reg_list[2].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[2].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[2].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[2].data = smiReg;
+
+  if(dev->fgtHwAccess(dev, &regAccess) != GT_TRUE)
+  {
+    return GT_FALSE;
+  }
+
+  return GT_TRUE;
+}
+
+/*****************************************************************************
+* qdMultiAddrAccess
+*
+* DESCRIPTION:
+*       This function access data to the device in the secondary MII bus.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG includes:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1
+*     addr - SMI Address
+*     reg  - Register offset
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+
+static GT_BOOL qdMultiAddrAccess(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList)
+{
+  int i;
+  GT_BOOL retVal = GT_TRUE;
+  unsigned short data, mask;
+  unsigned int tmpData;
+
+  for (i=0; i<regList->entries; i++)
+  {
+    switch (regList->rw_reg_list[i].cmd)
+    {
+      case HW_REG_READ:
+        retVal=qdAccessMultiAddrRead(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&(regList->rw_reg_list[i].data));
+        break;
+      case HW_REG_WRITE:
+        retVal=qdAccessMultiAddrWrite(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, regList->rw_reg_list[i].data);
+        break;
+      case HW_REG_WAIT_TILL_0:
+      {
+        mask = (1<<regList->rw_reg_list[i].data);
+        do
+        {
+          retVal=qdAccessMultiAddrRead(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&tmpData);
+          if(retVal != GT_TRUE)
+          {
+            return retVal;
+          }
+          data = tmpData;
+        } while(data & mask);
+      }
+        break;
+      case HW_REG_WAIT_TILL_1:
+      {
+        mask = (1<<regList->rw_reg_list[i].data);
+        do
+        {
+          retVal=qdAccessMultiAddrRead(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&tmpData);
+          if(retVal != GT_TRUE)
+          {
+            return retVal;
+          }
+          data = tmpData;
+        } while(!(data & mask));
+      }
+        break;
+
+      default:
+        return GT_FALSE;
+    }
+  }
+    return retVal;
+}
+
+#endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtSem.c
@@ -0,0 +1,148 @@
+#include <Copyright.h>
+/********************************************************************************
+* gtOs.c
+*
+* DESCRIPTION:
+*       Semaphore related routines
+*
+* DEPENDENCIES:
+*       OS Dependent.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 3 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+
+
+/*******************************************************************************
+* gtSemCreate
+*
+* DESCRIPTION:
+*       Create semaphore.
+*
+* INPUTS:
+*        state - beginning state of the semaphore, either GT_SEM_EMPTY or GT_SEM_FULL
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_SEM if success. Otherwise, NULL
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_SEM gtSemCreate
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM_BEGIN_STATE state
+)
+{
+    if(dev->semCreate)
+        return dev->semCreate(state);
+
+    return 1; /* should return any value other than 0 to let it keep going */
+}
+
+/*******************************************************************************
+* gtSemDelete
+*
+* DESCRIPTION:
+*       Delete semaphore.
+*
+* INPUTS:
+*       smid - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemDelete
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM smid
+)
+{
+    if((dev->semDelete) && (smid))
+        return dev->semDelete(smid);
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtSemTake
+*
+* DESCRIPTION:
+*       Wait for semaphore.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*       timeOut - time out in miliseconds or 0 to wait forever
+*
+* OUTPUTS:
+*       None
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       OS_TIMEOUT - on time out
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemTake
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM smid,
+    IN GT_U32 timeOut
+)
+{
+    if(dev->semTake)
+        return dev->semTake(smid, timeOut);
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtSemGive
+*
+* DESCRIPTION:
+*       release the semaphore which was taken previously.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemGive
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM       smid
+)
+{
+    if(dev->semGive)
+        return dev->semGive(smid);
+
+    return GT_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/makefile
@@ -0,0 +1,33 @@
+# Source files in this directory
+TARGET =
+CSOURCES	= gtMiiSmiIf.c platformDeps.c gtSem.c gtDebug.c
+ASOURCES	=
+
+# Include common variable definitions
+ifeq ($(OS_RUN),VXWORKS)
+include $(DSDT_TOOL_DIR)\make.defs
+endif
+ifeq ($(OS_RUN),WIN32)
+include $(DSDT_TOOL_DIR)\makewce.defs
+endif
+ifeq ($(OS_RUN),LINUX)
+include $(DSDT_TOOL_DIR)/makelnx.defs
+endif
+
+# Add in extra stuffs
+EXTRA_INCLUDE	+=
+EXTRA_DEFINE	+=
+ADDED_CFLAGS	+=
+
+# Include common build rules
+ifeq ($(OS_RUN),VXWORKS)
+include $(DSDT_TOOL_DIR)\make.rules
+endif
+ifeq ($(OS_RUN),WIN32)
+include $(DSDT_TOOL_DIR)\makewce.rules
+endif
+ifeq ($(OS_RUN),LINUX)
+include $(DSDT_TOOL_DIR)/makelnx.rules
+endif
+
+# end of file
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/platformDeps.c
@@ -0,0 +1,90 @@
+#include <Copyright.h>
+/********************************************************************************
+* platformDeps.c
+*
+* DESCRIPTION:
+*       platform dependent functions
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtDrvEvents.h>
+#include <gtHwCntl.h>
+#include <platformDeps.h>
+
+#if 0
+/*******************************************************************************
+* gtAssignFunctions
+*
+* DESCRIPTION:
+*       Exchange MII access functions and QuarterDeck Int Handler.
+*        MII access functions will be called by QuarterDeck driver and
+*        QD Int Handler should be called by BSP when BSP sees an interrupt which is related to
+*        QD (This interrupt has to be initialized by BSP, since QD has no idea which
+*        interrupt is assigned to QD)
+*
+* INPUTS:
+*       fReadMii     - function to read MII registers
+*        fWriteMii    - functino to write MII registers
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_TRUE, if input is valid. GT_FALSE, otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL gtAssignFunctions
+(
+   GT_QD_DEV      *dev,
+   FGT_READ_MII   fReadMii,
+   FGT_WRITE_MII fWriteMii
+)
+{
+    if((fReadMii == NULL) || (fWriteMii == NULL))
+        return GT_FALSE;
+
+    dev->fgtReadMii = fReadMii;
+    dev->fgtWriteMii = fWriteMii;
+
+    return GT_TRUE;
+}
+
+#endif
+
+GT_BOOL defaultMiiRead (unsigned int portNumber , unsigned int miiReg, unsigned int* value)
+{
+    GT_UNUSED_PARAM(miiReg);
+
+    if (portNumber > GLOBAL_REGS_START_ADDR)
+        portNumber -= GLOBAL_REGS_START_ADDR;
+
+    if (portNumber > GLOBAL_REGS_START_ADDR)
+        return GT_FALSE;
+
+    *value = 0;
+
+    return GT_TRUE;
+}
+
+GT_BOOL defaultMiiWrite (unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+    GT_UNUSED_PARAM(miiReg);
+
+    if (portNumber > GLOBAL_REGS_START_ADDR)
+        portNumber -= GLOBAL_REGS_START_ADDR;
+
+    if (portNumber > GLOBAL_REGS_START_ADDR)
+        return GT_FALSE;
+
+    value = value;
+
+    return GT_TRUE;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/make.defs
@@ -0,0 +1,105 @@
+# make.defs - common variable definitions
+#
+# modification history
+# --------------------
+# 04-12-02,mj	created
+#
+
+DEPENDENCIES=makedeps
+
+ifeq ($(TARGET_CPU),MIPS)
+
+CPU_TOOL=mips
+
+ifeq ($(TOR_VER),2.1)
+CPU=MIPS64
+CC_ARCH_SPEC1= -mips4 -G 0 -B$(VX_ROOT)/host/x86-win32/lib/gcc-lib/ -mno-branch-likely -fno-builtin -funroll-loops -Wall
+else
+CPU=R4000
+CC_ARCH_SPEC1= -mcpu=r4000 -mips3 -mgp32 -mfp32 -G 0 -B$(VX_ROOT)/host/x86-win32/lib/gcc-lib/
+endif
+
+ifeq ($(ENDIAN),EL)
+CC_ARCH_SPEC = -EL $(CC_ARCH_SPEC1)
+else
+CC_ARCH_SPEC = -EB $(CC_ARCH_SPEC1)
+endif
+
+# ARM CPU
+else
+
+CPU_TOOL=arm
+CPU		= ARMARCH4
+CC_ARCH_SPEC1 = -march=armv4 -mapcs-32
+
+ifeq ($(ENDIAN),LE)
+CC_ARCH_SPEC = $(CC_ARCH_SPEC1) -mlittle-endian
+else
+CC_ARCH_SPEC = $(CC_ARCH_SPEC1)
+endif
+
+endif
+
+TOOL       = gnu
+
+SW_ROOT = $(subst \,/,$(DSDT_USER_BASE))
+SRC_BASE_PATH = $(SW_ROOT)/src
+QD_INCLUDE_PATH = $(SW_ROOT)/Include/h
+
+VX_ROOT = $(subst \,/,$(WIND_BASE))
+OS_INCLUDE_PATH = $(VX_ROOT)/target/h
+
+LIB_DIR = $(SW_ROOT)/library
+OBJDIR = obj
+
+CC      =cc$(CPU_TOOL)
+LD      =ld$(CPU_TOOL)
+MAKE    =make
+CD		=cd
+RM      =del
+ECHO	=echo
+
+CFLAGS = $(CFLAGS1) $(CFLAGS2) $(INCLUDE_PATH) $(CDEBUG_DEFINES)
+
+CFLAGS1 = -DCPU=$(CPU) -D_$(OS_RUN) $(CC_ARCH_SPEC) -g $(DEBUG_TYPE)
+CFLAGS2 = $(CC_OPTIM) $(CC_COMPILER) $(CC_WARNINGS_ALL)
+
+CC_OPTIM = $(CC_OPTIM_TARGET)
+
+ifeq ($(TARGET_CPU),MIPS)
+#CC_COMPILER	=  -ansi -nostdinc
+CC_COMPILER	=  -ansi
+else
+CC_COMPILER	=  -ansi -fdollars-in-identifiers -mno-sched-prolog -fvolatile
+endif
+
+CC_OPTIM_TARGET	= -O2 -funroll-loops -fno-for-scope -fno-builtin
+CC_WARNINGS_ALL	= -Wall
+
+ifeq ($(RELEASE),NO)
+CDEBUG_DEFINES=-DDEBUG=1 -DDEBUG_QD
+else
+CDEBUG_DEFINES=
+endif
+
+ifeq ($(TARGET_CPU),MIPS)
+LDFLAGS1 = -nostdlib -r -X -N
+ARFLAGS =  crus
+else
+#LDFLAGS	= -nostdlib -X -EL -r
+LDFLAGS1	= -nostdlib -X -N -r
+endif
+
+ifeq ($(ENDIAN),EL)
+LDFLAGS = $(LDFLAGS1) -EL
+else
+LDFLAGS = $(LDFLAGS1)
+endif
+
+
+INCLUDE_PATH = -I. \
+               -I$(QD_INCLUDE_PATH)/driver \
+               -I$(QD_INCLUDE_PATH)/msApi \
+               -I$(QD_INCLUDE_PATH)/platform \
+               -I$(SW_ROOT)/include \
+               -I$(OS_INCLUDE_PATH)
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/make.rules
@@ -0,0 +1,54 @@
+# make.rules - common build rules
+#
+# modification history
+# --------------------
+# 04-15-02,mj	created
+#
+########################################################################
+ifeq ($(TARGET),)
+TARGET	= $(notdir $(subst \,/,$(shell cd)))
+endif
+default : $(TARGET).o
+
+# Set searching directories for target and dependencies
+vpath %.o    $(OBJDIR)
+
+# Include RULES file if it exists
+ifeq ($(shell if exist $(DEPENDENCIES) $(ECHO) 1),1)
+include $(DEPENDENCIES)
+endif
+
+# Accumulate source files specified in each directory makefile
+COBJECTS  	= $(CSOURCES:.c=.o)
+AOBJECTS  	= $(ASOURCES:.s=.o)
+ifeq ($(OBJECTS),)
+OBJECTS  	= $(COBJECTS) $(AOBJECTS)
+endif
+
+$(TARGET).o : $(OBJECTS) deps
+	@ $(ECHO) 'Building $@'
+	$(LD) $(LDFLAGS) -Map $(OBJDIR)/$(TARGET).map -o $(OBJDIR)/$(TARGET).o $(addprefix $(OBJDIR)/,$(notdir $(OBJECTS)))
+
+$(OBJECTS) : %.o : %.c
+.c.o :
+	@if not exist $(OBJDIR) mkdir $(OBJDIR)
+	$(CC) $(CFLAGS) $(EXTRA_DEFINE) $(EXTRA_INCLUDE) $(ADDED_CFLAGS) -c $< -o $(OBJDIR)/$(notdir $@)
+
+deps : $(CSOURCES)
+	@$(ECHO) '##' > $(DEPENDENCIES)
+	@$(ECHO) '## This file is generated by "make"!' >> $(DEPENDENCIES)
+	@$(ECHO) '##' >> $(DEPENDENCIES)
+	@for %x in ($^) do \
+	    @$(ECHO) '  %x' & \
+	     $(CC) -M -MG $(CFLAGS) %x >> $(DEPENDENCIES) & \
+	     @$(ECHO) '##' >> $(DEPENDENCIES)
+
+.PHONY: clean
+clean:
+	$(RM) $(DEPENDENCIES)
+	- ($(CD) $(OBJDIR)) && $(RM) *.o
+	- ($(CD) $(OBJDIR)) && $(RM) *.map
+
+FORCE :
+
+# end of file
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/makelnx.defs
@@ -0,0 +1,62 @@
+# make.defs - common variable definitions
+#
+# modification history
+# --------------------
+# 04-12-02,mj	created
+#
+SHELL=/bin/sh -e
+
+#CC_ARCH_SPEC=  -march=i386 -mcpu=i686
+
+SW_ROOT = $(DSDT_USER_BASE)
+SRC_BASE_PATH = $(SW_ROOT)/src
+QD_INCLUDE_PATH = $(SW_ROOT)/Include/h
+
+LIB_DIR = $(SW_ROOT)/Library
+OBJDIR = $(DSDT_PROJ_NAME)_obj
+
+ifeq ($(CC),)
+CC      =cc
+LD      =ld
+endif
+
+MAKE    =make
+CD      =pwd
+RM      =rm -f
+ECHO    =echo
+
+DEPENDENCIES= makedeps
+
+#CFLAGS = $(CFLAGS1) $(CFLAGS2) $(INCLUDE_PATH) $(CDEBUG_DEFINES)
+CFLAGS = -DLINUX $(CFLAGS1) $(CFLAGS2) $(INCLUDE_PATH) $(CDEBUG_DEFINES)
+
+CFLAGS1 = $(CC_ARCH_SPEC) $(DEBUG_TYPE)
+CFLAGS2 = $(CC_OPTIM) $(CC_COMPILER) $(CC_WARNINGS_ALL)
+
+CC_OPTIM = $(CC_OPTIM_TARGET)
+CC_OPTIM_DRIVER	= -O
+CC_OPTIM_TARGET	= -O2
+CC_COMPILER = -ansi -nostdinc
+CC_WARNINGS_ALL	= -Wall
+
+ifeq ($(RELEASE),NO)
+CDEBUG_DEFINES=-DDEBUG=1 -DDEBUG_QD
+else
+CDEBUG_DEFINES=
+endif
+
+LDFLAGS = -nostdlib -r -X -N
+ARFLAGS = crus
+
+INCLUDE_PATH = -I. \
+               -I$(QD_INCLUDE_PATH)/driver \
+               -I$(QD_INCLUDE_PATH)/msApi \
+               -I$(QD_INCLUDE_PATH)/platform \
+               -I$(SW_ROOT)/Include
+ifeq ($(DSDT_USE_MAD),TRUE)
+MAD_INCLUDE_PATH = $(SW_ROOT)/../phy/Include
+INCLUDE_PATH += -I$(MAD_INCLUDE_PATH)
+INCLUDE_PATH += -I$(MAD_INCLUDE_PATH)/h/driver
+INCLUDE_PATH += -I$(MAD_INCLUDE_PATH)/h/madApi
+INCLUDE_PATH += -I$(MAD_INCLUDE_PATH)/h/platform
+endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/makelnx.rules
@@ -0,0 +1,57 @@
+# make.rules - common build rules
+#
+# modification history
+# --------------------
+# 04-15-02,mj	created
+#
+########################################################################
+
+ifeq ($(TARGET),)
+TARGET	= $(notdir $(shell $(CD)))
+endif
+default : $(TARGET).o
+
+# Set searching directories for target and dependencies
+vpath %.o $(OBJDIR)
+
+# Include DEPENDENCIES file if it exists
+ifeq ($(shell if [ -a $(DEPENDENCIES) ]; then $(ECHO) 1; fi),1)
+include $(DEPENDENCIES)
+endif
+
+# Accumulate source files specified in each directory makefile
+COBJECTS  = $(CSOURCES:.c=.o)
+AOBJECTS  = $(ASOURCES:.s=.o)
+ifeq ($(OBJECTS),)
+OBJECTS  = $(COBJECTS) $(AOBJECTS)
+endif
+
+$(TARGET).o : $(OBJECTS) deps
+	@ $(ECHO) 'Building $@'
+	$(LD) $(LDFLAGS) -Map $(OBJDIR)/$(TARGET).map -o $(OBJDIR)/$(TARGET).o $(addprefix $(OBJDIR)/,$(notdir $(OBJECTS)))
+
+$(OBJECTS): %.o: %.c
+.c.o :
+	@if ! [ -a $(OBJDIR) ]; then mkdir $(OBJDIR); fi
+	$(CC) $(CFLAGS) $(EXTRA_DEFINE) $(EXTRA_INCLUDE) $(ADDED_CFLAGS) -c $< -o $(OBJDIR)/$(notdir $@)
+
+deps : $(CSOURCES)
+	@ $(ECHO) '##' > $(DEPENDENCIES)
+	@ $(ECHO) '## This file is generated by "make"!' >> $(DEPENDENCIES)
+	@ $(ECHO) '##' >> $(DEPENDENCIES)
+	@for i in $^ ; do \
+		$(ECHO) "  $$i"; \
+		$(CC) -M -MG $(CFLAGS) $$i >> $(DEPENDENCIES);  \
+		$(ECHO) '##' >> $(DEPENDENCIES);	\
+	done
+
+.PHONY: clean
+clean:
+#	cd $(OBJDIR); $(RM) *.o
+#	cd $(OBJDIR); $(RM) *.map
+	$(RM) -f -r $(OBJDIR)
+	$(RM) $(DEPENDENCIES)
+
+FORCE :
+
+# end of file
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/makewce.defs
@@ -0,0 +1,94 @@
+# makewce.defs - common variable definitions for wce
+#
+# modification history
+# --------------------
+# 04-24-02,mj	created
+#
+#######################################################################
+
+ifeq ($(TARGET),)
+TARGET	= $(notdir $(subst \,/,$(shell cd)))
+endif
+default : $(TARGET).lib
+
+SW_ROOT = $(subst \,/,$(DSDT_USER_BASE))
+SRC_BASE_PATH = $(SW_ROOT)/src
+#INCLUDE_PATH = $(subst ;, -I,$(INCLUDE))
+
+LIB_DIR = $(SW_ROOT)/library
+OBJDIR = obj
+
+QD_INCLUDE_PATH = -I$(DSDT_USER_BASE)\Include\h\driver \
+                  -I$(DSDT_USER_BASE)\Include\h\msApi \
+                  -I$(DSDT_USER_BASE)\Include\h\platform \
+                  -I$(DSDT_USER_BASE)\Include
+
+MAKE    =make
+CD		=cd
+RM      =del
+ECHO	=echo
+LD      =lib
+
+ifeq ($(TARGETCPU),MIPSIV)
+CC      =clmips
+
+TGTCPUFAMILY=MIPS
+TGTCPUDEFINES=-D$(TGTCPUFAMILY) -D_MIPS_ -DR4000
+
+ifeq ($(RELEASE),NO)
+CDEBUG_DEFINES=-DDEBUG=1 -DDEBUG_QD
+CDEBUG_FLAGS=-Od
+else
+CDEBUG_DEFINES=
+CDEBUG_FLAGS=
+endif
+
+
+CDEFINES1=-DUNDER_CE -D_WIN32_WCE=400
+CDEFINES=-DWIN32 -DSTRICT $(TGTCPUDEFINES) $(CDEBUG_DEFINES) $(CDEFINES1)
+
+#CINCLUDES=-I. -I$(INCLUDE_PATH) -I$(QD_INCLUDE_PATH)
+CINCLUDES=-I. $(QD_INCLUDE_PATH)
+
+CFLAGS1= -W3 -c -QMFPE -nologo -QMmips2 -Gy
+#CFLAGS1= -W3 -Og -Oi -Os -Ob1 -YX -Gs8192 -c
+#CFLAGS2= -FAsc -Fa$(@R).cod -WX
+
+CFLAGS= $(CFLAGS1) $(CINCLUDES) $(CDEBUG_FLAGS) $(CDEFINES)
+
+LINKER_SUBSYSTEM=-subsystem:windowsce,4.00
+MACHINEOPTION=-machine:MIPS
+
+LDFLAGS = -nologo -nodefaultlib $(LINKER_SUBSYSTEM) $(TARGETOBJFILES) $(SOURCELIBS) $(MACHINEOPTION)
+
+else
+CC      =cl
+
+TGTCPUFAMILY=x86
+TGTCPUDEFINES=-D$(TGTCPUFAMILY) -D_X86_
+
+ifeq ($(RELEASE),NO)
+CDEBUG_DEFINES=-DDEBUG=1 -DDEBUG_QD
+CDEBUG_FLAGS=-Od
+else
+CDEBUG_DEFINES=
+CDEBUG_FLAGS=-Og
+endif
+
+CDEFINES1=-DUNDER_CE -D_WIN32_WCE=400
+CDEFINES=-DWIN32 -DSTRICT $(TGTCPUDEFINES) $(CDEBUG_DEFINES) $(CDEFINES1)
+
+#CINCLUDES=-I. -I$(INCLUDE_PATH) -I$(QD_INCLUDE_PATH)
+CINCLUDES=-I. $(QD_INCLUDE_PATH)
+
+CFLAGS1= -W3 -Oi -Os -Ob1 -YX -Gs8192 -c
+#CFLAGS2= -FAsc -Fa$(@R).cod -WX
+
+CFLAGS= $(CFLAGS1) $(CINCLUDES) $(CDEBUG_FLAGS) $(CDEFINES)
+
+LINKER_SUBSYSTEM=-subsystem:windowsce,4.00
+MACHINEOPTION=-machine:IX86
+
+LDFLAGS = -nologo -nodefaultlib $(LINKER_SUBSYSTEM) $(TARGETOBJFILES) $(SOURCELIBS) $(MACHINEOPTION)
+
+endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/makewce.rules
@@ -0,0 +1,49 @@
+# makewce.rules - common build rules for wce
+#
+# modification history
+# --------------------
+# 04-25-02,mj	created
+#
+########################################################################
+
+# Set searching directories for target and dependencies
+vpath %.obj    $(OBJDIR)
+
+# Include RULES file if it exists
+#ifeq ($(shell if exist RULES $(ECHO) 1),1)
+#include RULES
+#endif
+
+# Accumulate source files specified in each directory makefile
+COBJECTS  	= $(CSOURCES:.c=.obj)
+AOBJECTS  	= $(ASOURCES:.s=.obj)
+ifeq ($(OBJECTS),)
+OBJECTS  	= $(COBJECTS) $(AOBJECTS)
+endif
+
+$(TARGET).lib : $(OBJECTS) $(CSOURCES)
+	@ $(ECHO) 'Building $@'
+	$(LD) $(LDFLAGS) -ignore:4001 -out:$(OBJDIR)\$(TARGET).lib $(addprefix $(OBJDIR)\,$(notdir $(OBJECTS)))
+
+$(OBJECTS) : %.obj : %.c
+	@if not exist $(OBJDIR) mkdir $(OBJDIR)
+	$(CC) $(CFLAGS) $(EXTRA_DEFINE) $(EXTRA_INCLUDE) $(ADDED_CFLAGS) -c $< -Fo$(OBJDIR)\$(notdir $@)
+
+#deps : $(CSOURCES)
+#	@$(ECHO) '##' >> RULES
+#	@$(ECHO) '## This file is generated by \"make\" - DO NOT EDIT !' >> RULES
+#	@$(ECHO) '## $(shell $(DATE))' >> RULES
+#	@$(ECHO) '##' >> RULES
+#	@for %x in ($^) do \
+#	    @$(ECHO) "  %x" & \
+#	     $(CC) -M -MG $(CFLAGS) %x >> RULES & \
+#	     $(ECHO) >> RULES
+
+.PHONY: clean
+clean:
+	- ($(CD) $(OBJDIR)) && $(RM) *.obj
+	- ($(CD) $(OBJDIR)) && $(RM) *.lib
+
+FORCE :
+
+# end of file
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/setenv
@@ -0,0 +1,14 @@
+declare -x DSDT_USER_BASE=/home/xudy/dsdt/DSDT_3.2_internal/switch
+declare -x DSDT_PROJ_NAME=qdDrv
+declare -x DSDT_TOOL_DIR=$DSDT_USER_BASE/tools
+declare -x RELEASE=YES
+declare -x OS_RUN=LINUX
+declare -x MAD_USER_BASE=$DSDT_USER_BASE/../phy
+declare -x MAD_PROJ_NAME=madDrv
+declare -x MAD_TOOL_DIR=$MAD_USER_BASE/tools
+declare -x USER_API_NAME=
+declare -x USER_NAME=
+declare -x DSP_VCT=FALSE
+declare -x VCT_PENDING=FALSE
+#declare -x DSDT_USE_MAD=FALSE
+declare -x DSDT_USE_MAD=TRUE
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/tools/setenv.bat
@@ -0,0 +1,55 @@
+@echo off
+set REQ_OS=%1
+
+if "%REQ_OS%"==""        set OS_RUN=VXWORKS
+if "%REQ_OS%"=="VXWORKS" set OS_RUN=VXWORKS
+if "%REQ_OS%"=="vxworks" set OS_RUN=VXWORKS
+if "%REQ_OS%"=="vxWorks" set OS_RUN=VXWORKS
+if "%REQ_OS%"=="win32"   set OS_RUN=WIN32
+if "%REQ_OS%"=="WIN32"   set OS_RUN=WIN32
+if "%REQ_OS%"=="wince"   set OS_RUN=WIN32
+if "%REQ_OS%"=="WINCE"   set OS_RUN=WIN32
+
+set DSDT_USER_BASE=C:\DSDT_2.8pre_4
+set DSDT_PROJ_NAME=qdDrv
+set DSDT_USE_MAD=FALSE
+set DSDT_TOOL_DIR=%DSDT_USER_BASE%\tools
+set RELEASE=YES
+set TARGET_CPU=ARM
+rem set TARGET_CPU=MIPS
+
+if "%OS_RUN%"=="VXWORKS" goto VXWORKS_ENV
+if "%OS_RUN%"=="WIN32" goto WIN32_ENV
+
+echo Unknown Target OS!
+echo Supported Target OS is vxworks and wince.
+echo Assumes VxWorks as a Target OS.
+
+:VXWORKS_ENV
+
+set TOR_VER=2.1
+set ENDIAN=EL
+set WIND_BASE=C:\Tornado.arm
+rem set WIND_BASE=C:\Tornado2.1
+set WIND_HOST_TYPE=x86-win32
+
+set PATH=%WIND_BASE%\host\%WIND_HOST_TYPE%\bin;%PATH%
+
+echo Environment Variable for VxWorks has been set.
+
+goto DONE
+
+:WIN32_ENV
+
+set TARGETCPU=MIPSIV
+rem set TARGETCPU=x86
+set WCEROOT=C:\WINCE400
+
+set INCLUDE=%WCEROOT%\public\common\oak\inc;%WCEROOT%\public\common\sdk\inc;%WCEROOT%\public\common\ddk\inc;%INCLUDE%
+set PATH=%WCEROOT%\sdk\bin\i386;%WCEROOT%\public\common\oak\bin\i386;%DSDT_USER_BASE%\tools;%path%
+
+echo Environment Variable for WinCE has been set.
+goto DONE
+
+:DONE
+cd %DSDT_USER_BASE%\src
