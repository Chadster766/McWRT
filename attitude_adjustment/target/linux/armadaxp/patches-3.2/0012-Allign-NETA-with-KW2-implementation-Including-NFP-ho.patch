From 2f1851b2b763a2d50c9059db631d731fea5692b1 Mon Sep 17 00:00:00 2001
From: Seif Mazareeb <seif@marvell.com>
Date: Wed, 4 Sep 2013 16:26:32 -0700
Subject: [PATCH 012/609] Allign NETA with KW2 implementation Including NFP
 hooks

Signed-off-by: Seif Mazareeb <seif@marvell.com>
---
 arch/arm/configs/armada_xp_defconfig               |  228 ++-
 arch/arm/include/asm/setup.h                       |    6 +-
 arch/arm/mach-armadaxp/Makefile                    |  121 +-
 arch/arm/mach-armadaxp/config/mvRules.mk           |    1 +
 arch/arm/mach-armadaxp/config/mvSysEthConfig.h     |   67 +-
 arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c       |   40 +-
 arch/arm/plat-armada/common/mv802_3.h              |   14 +-
 arch/arm/plat-armada/common/mvCommon.h             |   24 +-
 arch/arm/plat-armada/common/mvTypes.h              |   26 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig |  725 ++++----
 .../mv_drivers_lsp/mv_neta/bm/bm_sysfs.c           |   25 +-
 .../mv_drivers_lsp/mv_neta/bm/mv_eth_bm.c          |  186 ++
 .../mv_drivers_lsp/mv_neta/hwf/hwf_bm.c            |  126 +-
 .../mv_drivers_lsp/mv_neta/hwf/hwf_sysfs.c         |    5 +
 .../mv_drivers_lsp/mv_neta/net_dev/Makefile        |   17 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_proc.c   |  520 ------
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_proc.h   |  126 --
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c |  178 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c  |   53 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c   |   24 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c   |   83 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     | 1781 +++++++++++++++-----
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h     |  121 +-
 .../mv_drivers_lsp/mv_neta/nfp_mgr/mv_nfp_mgr_if.h |   40 +
 .../mv_drivers_lsp/mv_neta/pmt/pmt_sysfs.c         |  258 ++-
 arch/arm/plat-armada/mv_hal/neta/bm/mvBm.c         |    7 +-
 arch/arm/plat-armada/mv_hal/neta/bm/mvBm.h         |    3 -
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.c      |   45 +-
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.h      |   92 +-
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h  |   69 +-
 arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h   |  113 +-
 arch/arm/plat-armada/mv_hal/neta/pmt/mvPmt.c       |  551 +++++-
 arch/arm/plat-armada/mv_hal/neta/pmt/mvPmt.h       |  191 ++-
 arch/arm/plat-armada/mv_hal/neta/pnc/mvPnc.c       |  218 +--
 arch/arm/plat-armada/mv_hal/neta/pnc/mvPnc.h       |   82 +-
 arch/arm/plat-armada/mv_hal/neta/pnc/mvPncAging.c  |  279 +++
 arch/arm/plat-armada/mv_hal/neta/pnc/mvPncWol.c    |    8 +-
 drivers/net/ppp/ppp_generic.c                      |    9 +-
 drivers/net/ppp/pppoe.c                            |   18 +
 include/linux/netdevice.h                          |   20 +
 include/linux/netfilter/ipt_NFP.h                  |  126 ++
 include/net/ip6_fib.h                              |    5 +
 include/net/neighbour.h                            |    3 +
 include/net/netfilter/nf_conntrack.h               |   24 +
 include/net/netfilter/nf_conntrack_tuple.h         |    9 +
 include/net/route.h                                |    4 +
 net/8021q/vlan.c                                   |   35 +
 net/bridge/br_fdb.c                                |   91 +-
 net/bridge/br_if.c                                 |   18 +
 net/bridge/br_private.h                            |    4 +
 net/core/neighbour.c                               |   88 +-
 net/ipv4/netfilter/Kconfig                         |    7 +
 net/ipv4/netfilter/Makefile                        |    1 +
 .../netfilter/nf_conntrack_l3proto_ipv4_compat.c   |   13 +
 net/ipv4/route.c                                   |   83 +-
 net/ipv6/ip6_fib.c                                 |   80 +
 net/ipv6/netfilter/Kconfig                         |    8 +
 net/ipv6/netfilter/Makefile                        |    1 +
 net/ipv6/route.c                                   |    8 +
 net/netfilter/Kconfig                              |   21 +
 net/netfilter/Makefile                             |    1 -
 net/netfilter/nf_conntrack_core.c                  |  195 +++
 net/netfilter/nf_conntrack_proto_tcp.c             |   16 +-
 net/netfilter/nf_conntrack_standalone.c            |   19 +
 net/netfilter/regexp/regexp.c                      | 1197 -------------
 net/netfilter/regexp/regexp.h                      |   41 -
 net/netfilter/regexp/regmagic.h                    |    5 -
 net/netfilter/regexp/regsub.c                      |   95 --
 net/netfilter/xt_layer7.c                          |  700 --------
 69 files changed, 5187 insertions(+), 4211 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/bm/mv_eth_bm.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_proc.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_proc.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/nfp_mgr/mv_nfp_mgr_if.h
 create mode 100644 arch/arm/plat-armada/mv_hal/neta/pnc/mvPncAging.c
 create mode 100644 include/linux/netfilter/ipt_NFP.h
 delete mode 100644 net/netfilter/regexp/regexp.c
 delete mode 100644 net/netfilter/regexp/regexp.h
 delete mode 100644 net/netfilter/regexp/regmagic.h
 delete mode 100644 net/netfilter/regexp/regsub.c
 delete mode 100644 net/netfilter/xt_layer7.c

--- a/arch/arm/configs/armada_xp_defconfig
+++ b/arch/arm/configs/armada_xp_defconfig
@@ -332,25 +332,45 @@ CONFIG_MV_ETH_RXQ=8
 CONFIG_MV_ETH_TXQ=8
 CONFIG_MV_ETH_TSO=y
 CONFIG_MV_ETH_TOOL=y
-CONFIG_MV_ETH_PROC=y
 # CONFIG_MV_LINUX_COUNTERS_DISABLE is not set
 CONFIG_NET_SKB_HEADROOM=96
 CONFIG_NET_SKB_RECYCLE=y
 CONFIG_NET_SKB_RECYCLE_DEF=1
-# CONFIG_MV_ETH_NFP is not set
-CONFIG_MV_ETH_MTU_PKT_MULT=3
+CONFIG_MV_ETH_NFP=y
+CONFIG_MV_ETH_NFP_DEF=0
+CONFIG_MV_ETH_NFP_FIB=y
+CONFIG_MV_ETH_NFP_NAT=y
+# CONFIG_MV_ETH_NFP_SEC is not set
 
 #
 # BM configuration
 #
 CONFIG_MV_ETH_BM=y
 CONFIG_MV_ETH_BM_CPU=y
-CONFIG_MV_ETH_SHORT_PKT_SIZE=256
-CONFIG_MV_ETH_SHORT_PKT_MULT=5
-CONFIG_MV_ETH_POOL_PREDEFINED=y
-CONFIG_MV_ETH_POOL_0_MTU=1500
-CONFIG_MV_ETH_POOL_1_MTU=4096
-CONFIG_MV_ETH_POOL_2_MTU=9192
+CONFIG_MV_ETH_BM_0_PKT_SIZE=1600
+CONFIG_MV_ETH_BM_1_PKT_SIZE=4160
+CONFIG_MV_ETH_BM_2_PKT_SIZE=9120
+CONFIG_MV_ETH_BM_3_PKT_SIZE=256
+CONFIG_MV_ETH_BM_PORT_0=y
+CONFIG_MV_ETH_BM_PORT_0_LONG_POOL=-1
+CONFIG_MV_ETH_BM_PORT_0_SHORT_POOL=3
+CONFIG_MV_ETH_BM_PORT_0_LONG_BUF_NUM=2048
+CONFIG_MV_ETH_BM_PORT_0_SHORT_BUF_NUM=4096
+CONFIG_MV_ETH_BM_PORT_1=y
+CONFIG_MV_ETH_BM_PORT_1_LONG_POOL=-1
+CONFIG_MV_ETH_BM_PORT_1_SHORT_POOL=3
+CONFIG_MV_ETH_BM_PORT_1_LONG_BUF_NUM=2048
+CONFIG_MV_ETH_BM_PORT_1_SHORT_BUF_NUM=4096
+CONFIG_MV_ETH_BM_PORT_2=y
+CONFIG_MV_ETH_BM_PORT_2_LONG_POOL=-1
+CONFIG_MV_ETH_BM_PORT_2_SHORT_POOL=3
+CONFIG_MV_ETH_BM_PORT_2_LONG_BUF_NUM=2048
+CONFIG_MV_ETH_BM_PORT_2_SHORT_BUF_NUM=4096
+CONFIG_MV_ETH_BM_PORT_3=y
+CONFIG_MV_ETH_BM_PORT_3_LONG_POOL=-1
+CONFIG_MV_ETH_BM_PORT_3_SHORT_POOL=3
+CONFIG_MV_ETH_BM_PORT_3_LONG_BUF_NUM=2048
+CONFIG_MV_ETH_BM_PORT_3_SHORT_BUF_NUM=4096
 CONFIG_MV_ETH_LEGACY_PARSER=y
 # CONFIG_MV_ETH_PNC is not set
 # CONFIG_MV_ETH_PMT is not set
@@ -398,8 +418,9 @@ CONFIG_MV_ETH_RX_COAL_PKTS=32
 CONFIG_MV_ETH_RX_COAL_USEC=100
 CONFIG_MV_ETH_RX_DESC_PREFETCH=y
 CONFIG_MV_ETH_RX_PKT_PREFETCH=y
-# CONFIG_MV_ETH_IGMP is not set
+CONFIG_MV_ETH_NAPI_GROUPS=1
 # CONFIG_MV_ETH_TX_SPECIAL is not set
+# CONFIG_MV_ETH_L2FW is not set
 CONFIG_MV_ETH_RX_POLL_WEIGHT=64
 CONFIG_MV_ETH_EXTRA_BUF_SIZE=120
 CONFIG_MV_ETH_EXTRA_BUF_NUM=532
@@ -407,6 +428,24 @@ CONFIG_MV_ETH_EXTRA_BUF_NUM=532
 #
 # NFP support
 #
+# CONFIG_MV_ETH_NFP_LIB is not set
+# CONFIG_MV_ETH_NFP_EXT is not set
+CONFIG_MV_ETH_NFP_BRIDGE=y
+CONFIG_MV_ETH_NFP_BRIDGE_LEARN=y
+CONFIG_MV_ETH_NFP_BRIDGE_LEARN_DEF=0
+# CONFIG_MV_ETH_NFP_BRIDGE_STATIC is not set
+CONFIG_MV_ETH_NFP_VLAN=y
+CONFIG_MV_ETH_NFP_VLAN_LEARN=y
+CONFIG_MV_ETH_NFP_VLAN_LEARN_DEF=0
+CONFIG_MV_ETH_NFP_FIB_LEARN=y
+CONFIG_MV_ETH_NFP_FIB_LEARN_DEF=0
+CONFIG_MV_ETH_NFP_CT=y
+CONFIG_MV_ETH_NFP_CT_LEARN=y
+CONFIG_MV_ETH_NFP_CT_LEARN_DEF=0
+# CONFIG_MV_ETH_NFP_LIMIT is not set
+CONFIG_MV_ETH_NFP_CLASSIFY=y
+CONFIG_MV_ETH_NFP_STATS=y
+CONFIG_MV_ETH_NFP_DEBUG=y
 
 #
 # PON support for Network driver
@@ -415,7 +454,7 @@ CONFIG_MV_ETH_EXTRA_BUF_NUM=532
 #
 # Switch support
 #
-CONFIG_ARMADA_XP_ERRATA_SMI_1=y
+CONFIG_MV_ETH_ERRATA_SMI_ACCESS=y
 
 #
 # Cesa options
@@ -647,10 +686,170 @@ CONFIG_INET_TCP_DIAG=y
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
 # CONFIG_NETWORK_SECMARK is not set
 # CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-# CONFIG_NETFILTER is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+CONFIG_NF_CONNTRACK_FTP=y
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+# CONFIG_NETFILTER_XT_MARK is not set
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_FILTER is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+CONFIG_IP_NF_TARGET_NFP=y
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+CONFIG_NF_NAT_FTP=y
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_LOG is not set
+# CONFIG_IP6_NF_FILTER is not set
+# CONFIG_IP6_NF_MANGLE is not set
+# CONFIG_IP6_NF_RAW is not set
+CONFIG_IP6_NF_TARGET_NFP=y
+# CONFIG_BRIDGE_NF_EBTABLES is not set
 # CONFIG_IP_DCCP is not set
 # CONFIG_IP_SCTP is not set
 # CONFIG_RDS is not set
@@ -661,7 +860,8 @@ CONFIG_STP=y
 CONFIG_BRIDGE=y
 CONFIG_BRIDGE_IGMP_SNOOPING=y
 # CONFIG_NET_DSA is not set
-# CONFIG_VLAN_8021Q is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
 # CONFIG_DECNET is not set
 CONFIG_LLC=y
 # CONFIG_LLC2 is not set
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -145,14 +145,14 @@ struct tag_memclk {
 
 /* Marvell uboot parameters */
 #define ATAG_MV_UBOOT   0x41000403
-#define MV_ARRAY_SIZE	4
+#define MV_UBOOT_ETH_PORTS	4
 struct tag_mv_uboot {
         __u32 uboot_version;
         __u32 tclk;
         __u32 sysclk;
         __u32 isUsbHost;
-        __u8  macAddr[MV_ARRAY_SIZE][6];
-	__u16 mtu[MV_ARRAY_SIZE];
+        __u8  macAddr[MV_UBOOT_ETH_PORTS][6];
+	__u16 mtu[MV_UBOOT_ETH_PORTS];
 	__u32 nand_ecc;
 	__u32 rgmii0Src;
 	__u32 feGeSrc;
--- a/arch/arm/mach-armadaxp/Makefile
+++ b/arch/arm/mach-armadaxp/Makefile
@@ -1,20 +1,86 @@
 #*******************************************************************************
 # Marvell GPL License Option
 #
-# If you received this File from Marvell, you may opt to use, redistribute and/or 
-# modify this File in accordance with the terms and conditions of the General 
-# Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-# available along with the File in the license.txt file or by writing to the Free 
-# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-# on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+# If you received this File from Marvell, you may opt to use, redistribute and/or
+# modify this File in accordance with the terms and conditions of the General
+# Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+# available along with the File in the license.txt file or by writing to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+# on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 #
-# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-# DISCLAIMED.  The GPL License provides additional details about this warranty 
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+# DISCLAIMED.  The GPL License provides additional details about this warranty
 # disclaimer.
 #*******************************************************************************/
 include 	  $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
 
+ifdef CONFIG_MV_ETH_NFP
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o $(LSP_NFP_MGR_DIR)/nfp_sysfs.o  $(LSP_NFP_MGR_DIR)/mv_nfp_hooks.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_FIB
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_fib_arp_sysfs.o
+ifdef CONFIG_IPV6
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/ipv6_parsing.o $(LSP_NFP_MGR_DIR)/nfp_fib6_arp_sysfs.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CT
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ct_sysfs.o
+ifdef CONFIG_IPV6
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ct6_sysfs.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CLASSIFY
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_classification_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_BRIDGE
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_bridge_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_VLAN
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_vlan_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_PPP
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ppp_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_SEC
+	NFPOBJS += $(LSP_NFP_MGR_DIR)/mv_nfp_sec.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfp.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CT
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpCt.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_BRIDGE
+ifdef CONFIG_MV_ETH_NFP_BRIDGE_LEARN
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
+else
+	NFPOBJS    += $(HAL_ETH_NFP_DIR)/mvNfpBridge.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_FIB
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpFib.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_SEC
+	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpSec.o
+endif
+
+ifdef NFPLIB
+	armadaxp-y := $(NFPOBJS)
+	obj-y   				+=  armadaxp.o
+else
 # Objects list
 COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o
 
@@ -32,7 +98,7 @@ KW_FAM_OBJS	= $(BOARD_ENV_DIR)/mvBoardEn
 		  $(BOARD_ENV_DIR)/mvBoardEnvLib.o $(SOC_ENV_DIR)/mvCtrlEnvAddrDec.o 	\
 		  $(SOC_SYS_DIR)/mvAhbToMbus.o $(SOC_SYS_DIR)/mvCpuIf.o 		\
 		  $(SOC_CPU_DIR)/mvCpu.o $(SOC_DEVICE_DIR)/mvDevice.o
-                  
+
 QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrvEvents.o \
                   $(HAL_QD_DIR)/src/driver/gtHwCntl.o $(HAL_QD_DIR)/src/platform/gtMiiSmiIf.o	\
                   $(HAL_QD_DIR)/src/platform/platformDeps.o $(HAL_QD_DIR)/src/platform/gtSem.o	\
@@ -66,14 +132,18 @@ armadaxp-$(CONFIG_MV_INCLUDE_USB) 	+= $(
 					   $(HAL_IF_DIR)/mvSysUsb.o
 armadaxp-y				+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
 
+ifndef CONFIG_MV_ETH_NFP_LIB
+	armadaxp-y += $(NFPOBJS)
+endif
+
 # Legacy Giga driver
-ifeq ($(CONFIG_MV_ETH_LEGACY),y) 
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
 armadaxp-$(CONFIG_MV_ETH_LEGACY)	+= $(HAL_ETH_GBE_DIR)/mvEth.o $(HAL_ETH_GBE_DIR)/mvEthDebug.o \
 					   $(HAL_ETH_GBE_DIR)/mvEthAddrDec.o $(HAL_IF_DIR)/mvSysEth.o
-armadaxp-$(CONFIG_MV_ETH_NFP)           += $(HAL_ETH_NFP_DIR)/mvNfp.o 
+armadaxp-$(CONFIG_MV_ETH_NFP)           += $(HAL_ETH_NFP_DIR)/mvNfp.o
 armadaxp-$(CONFIG_MV_ETH_NFP_NAT) 	+= $(HAL_ETH_NFP_DIR)/mvNfpNat.o
-armadaxp-$(CONFIG_MV_ETH_NFP_FDB) 	+= $(HAL_ETH_NFP_DIR)/mvNfpFdb.o  
-armadaxp-$(CONFIG_MV_ETH_NFP_PPP) 	+= $(HAL_ETH_NFP_DIR)/mvNfpPpp.o  
+armadaxp-$(CONFIG_MV_ETH_NFP_FDB) 	+= $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
+armadaxp-$(CONFIG_MV_ETH_NFP_PPP) 	+= $(HAL_ETH_NFP_DIR)/mvNfpPpp.o
 armadaxp-$(CONFIG_MV_ETH_NFP_SEC)	+= $(HAL_ETH_NFP_DIR)/mvNfpSec.o
 
 endif
@@ -82,17 +152,12 @@ endif
 ifeq ($(CONFIG_MV_ETH_NETA),y)
 armadaxp-$(CONFIG_MV_ETH_NETA)	        += $(HAL_ETH_GBE_DIR)/mvNeta.o $(HAL_ETH_GBE_DIR)/mvNetaDebug.o \
 					   $(HAL_ETH_GBE_DIR)/mvNetaAddrDec.o $(HAL_IF_DIR)/mvSysNeta.o
-armadaxp-$(CONFIG_MV_ETH_PNC)    	+= $(HAL_ETH_PNC_DIR)/mvTcam.o
-armadaxp-$(CONFIG_MV_ETH_PNC_PARSER)	+= $(HAL_ETH_PNC_DIR)/mvPnc.o 
+armadaxp-$(CONFIG_MV_ETH_PNC)    	+= $(HAL_ETH_PNC_DIR)/mvTcam.o  $(HAL_ETH_PNC_DIR)/mvPncAging.o \
+					$(HAL_ETH_PNC_DIR)/mvPnc.o
 armadaxp-$(CONFIG_MV_ETH_PNC_WOL)       += $(HAL_ETH_PNC_DIR)/mvPncWol.o
 armadaxp-$(CONFIG_MV_ETH_BM) 	        += $(HAL_ETH_BM_DIR)/mvBm.o
-armadaxp-$(CONFIG_MV_ETH_PMT)	        += $(HAL_ETH_PMT_DIR)/mvPmt.o 
+armadaxp-$(CONFIG_MV_ETH_PMT)	        += $(HAL_ETH_PMT_DIR)/mvPmt.o
 armadaxp-$(CONFIG_MV_ETH_HWF)           += $(HAL_ETH_GBE_DIR)/mvHwf.o
-armadaxp-$(CONFIG_MV_ETH_NFP)		+= $(HAL_ETH_NFP_DIR)/mvNfp.o
-armadaxp-$(CONFIG_MV_ETH_NFP_NAT) 	+= $(HAL_ETH_NFP_DIR)/mvNfpNat.o
-armadaxp-$(CONFIG_MV_ETH_NFP_SWF) 	+= $(HAL_ETH_NFP_DIR)/mvNfpSwf.o
-armadaxp-$(CONFIG_MV_ETH_NFP_FIB) 	+= $(HAL_ETH_NFP_DIR)/mvNfpFib.o
-armadaxp-$(CONFIG_MV_ETH_NFP_PNC) 	+= $(HAL_ETH_NFP_DIR)/mvNfpPnc.o    
 endif
 
 armadaxp-$(CONFIG_MV_INCLUDE_CESA) 	+= $(HAL_CESA_DIR)/mvCesa.o $(HAL_CESA_DIR)/mvCesaDebug.o 	\
@@ -120,17 +185,19 @@ obj-$(CONFIG_MV_INCLUDE_SWITCH) 	+= $(QD
 # drivers part
 # Legacy Giga driver
 ifeq ($(CONFIG_MV_ETH_LEGACY),y)
-obj-$(CONFIG_MV_ETH_NFP) 	        += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o
+obj-$(CONFIG_MV_ETH_NFP) 	        += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o $(LSP_NFP_MGR_DIR)/mv_nfp_hooks.o
 obj-$(CONFIG_MV_ETH_NFP_SEC)            += $(LSP_NFP_MGR_DIR)/mv_nfp_sec.o
 endif
 
 ifeq ($(CONFIG_MV_ETH_NETA),y)
-obj-$(CONFIG_MV_ETH_NFP)	        += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o $(LSP_NFP_MGR_DIR)/nfp_sysfs.o
 obj-$(CONFIG_MV_ETH_PNC)                += $(LSP_PNC_DIR)/pnc_sysfs.o
-obj-$(CONFIG_MV_ETH_BM)                 += $(LSP_BM_DIR)/bm_sysfs.o
+obj-$(CONFIG_MV_ETH_BM)                 += $(LSP_BM_DIR)/bm_sysfs.o  $(LSP_BM_DIR)/mv_eth_bm.o
 obj-$(CONFIG_MV_ETH_PNC_WOL)            += $(LSP_PNC_DIR)/wol_sysfs.o
 obj-$(CONFIG_MV_ETH_PMT)		+= $(LSP_PMT_DIR)/pmt_sysfs.o
-obj-$(CONFIG_MV_ETH_HWF)        	+= $(LSP_HWF_DIR)/hwf_sysfs.o $(LSP_HWF_DIR)/hwf_bm.o
+obj-$(CONFIG_MV_ETH_HWF)        	+= $(LSP_HWF_DIR)/hwf_sysfs.o
+ifndef CONFIG_MV_ETH_BM_CPU
+obj-$(CONFIG_MV_ETH_HWF)		+=  $(LSP_HWF_DIR)/hwf_bm.o
+endif
 obj-$(CONFIG_MV_ETH_L2FW)               += $(LSP_L2FW_DIR)/l2fw_sysfs.o $(LSP_L2FW_DIR)/mv_eth_l2fw.o
 endif
 
@@ -154,3 +221,5 @@ armadaxp-$(CONFIG_PROC_FS)		+= dump_cp15
 obj-$(CONFIG_FB_DOVE_CLCD)		+= clcd.o
 obj-$(CONFIG_PM)			+= pm.o
 
+endif
+
--- a/arch/arm/mach-armadaxp/config/mvRules.mk
+++ b/arch/arm/mach-armadaxp/config/mvRules.mk
@@ -48,6 +48,7 @@ HAL_ETH_GBE_DIR   = $(HAL_DIR)/neta/gbe
 HAL_ETH_NFP_DIR   = $(HAL_DIR)/neta/nfp
 HAL_ETH_PNC_DIR   = $(HAL_DIR)/neta/pnc
 HAL_ETH_BM_DIR    = $(HAL_DIR)/neta/bm
+HAL_ETH_PMT_DIR   = $(HAL_DIR)/neta/pmt
 LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_neta
 LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/net_dev
 LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
--- a/arch/arm/mach-armadaxp/config/mvSysEthConfig.h
+++ b/arch/arm/mach-armadaxp/config/mvSysEthConfig.h
@@ -1,22 +1,67 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
+
 /*******************************************************************************
 * mvSysEthConfig.h - Marvell Ethernet unit specific configurations
 *
@@ -38,6 +83,7 @@ disclaimer.
 ** Base address for ethernet registers.
 */
 #ifdef CONFIG_MV_PON
+#define MV_PON_PORT_ID_GET()	MV_PON_PORT_ID
 #define MV_PON_PORT(p)		((p) == MV_PON_PORT_ID)
 #define MV_PON_REG_BASE         MV_PON_REGS_OFFSET
 #define MV_ETH_REGS_BASE(p)	(MV_PON_PORT(p) ? MV_PON_REGS_OFFSET : MV_ETH_REGS_OFFSET(p))
@@ -48,7 +94,8 @@ disclaimer.
 
 #define MV_BM_REG_BASE		MV_BM_REGS_OFFSET
 #define MV_PNC_REG_BASE         MV_PNC_REGS_OFFSET
-#define MV_ETH_COMPLEX_BASE	(MV_ETH_COMPLEX_OFFSET)
+#define MV_ETH_COMPLEX_BASE		(MV_ETH_COMPLEX_OFFSET)
+#define MV_ETH_ONLY_REGS_BASE		(MV_ETH_ONLY_REGS_OFFSET)
 
 #if defined(CONFIG_MV_INCLUDE_GIG_ETH)
 
--- a/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c
@@ -39,15 +39,15 @@ Redistribution and use in source and bin
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
+	this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
 
     *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
@@ -93,11 +93,11 @@ void 	mvSysNetaInit(void)
 
 	memset(&halData, 0, sizeof(halData));
 	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
-	if(status != MV_OK)
+	if (status != MV_OK)
 		return;
 
-	for(i = 0; i < MAX_TARGETS; i++) {
-		if(addrWinMap[i].enable == MV_FALSE)
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (addrWinMap[i].enable == MV_FALSE)
 			continue;
 
 #ifdef CONFIG_MV_SUPPORT_L2_DEPOSIT
@@ -108,10 +108,9 @@ void 	mvSysNetaInit(void)
 			addrWinMap[i].attrib |= 0x30;
 		}
 #endif
-
-		printk("%d - Base 0x%08x , Size = 0x%08x.\n", i,
-				addrWinMap[i].addrWin.baseLow,
-				addrWinMap[i].addrWin.size);
+		mvOsPrintf("%d - Base 0x%08x , Size = 0x%08x.\n", i,
+                                addrWinMap[i].addrWin.baseLow,
+                                addrWinMap[i].addrWin.size);
 	}
 	halData.maxPort = mvCtrlEthMaxPortGet();
 	halData.pClk = mvCpuPclkGet();
@@ -121,23 +120,22 @@ void 	mvSysNetaInit(void)
 
 #ifdef CONFIG_MV_ETH_BM
 	halData.bmPhysBase = PNC_BM_PHYS_BASE;
-	halData.bmVirtBase = (MV_U8*)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+	halData.bmVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
 #endif /* CONFIG_MV_ETH_BM */
 
 #ifdef CONFIG_MV_ETH_PNC
-        halData.pncPhysBase = PNC_BM_PHYS_BASE;
-        halData.pncVirtBase = (MV_U8*)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+	halData.pncPhysBase = PNC_BM_PHYS_BASE;
+	halData.pncVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
 #endif /* CONFIG_MV_ETH_PNC */
 
-	for (port=0; port<halData.maxPort; port++) {
-		if(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE) {
+	for (port = 0; port < halData.maxPort; port++) {
+		if (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE)
 			continue;
-		}
-        	mvNetaPortPowerUp(port, mvBoardIsPortInSgmii(port), mvBoardIsPortInGmii(port));
+
+		mvNetaPortPowerUp(port, mvBoardIsPortInSgmii(port), !mvBoardIsPortInGmii(port));
 		status = mvNetaWinInit(port, addrWinMap);
-		if(status != MV_OK) {
+		if (status != MV_OK)
 			continue;
-		}
 	}
 	mvNetaHalInit(&halData);
 
--- a/arch/arm/plat-armada/common/mv802_3.h
+++ b/arch/arm/plat-armada/common/mv802_3.h
@@ -74,13 +74,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 /* 802.3 types */
 #define MV_IP_TYPE                  0x0800
 #define MV_IP_ARP_TYPE              0x0806
-#define MV_IP6_TYPE					0x86dd
+#define MV_IP6_TYPE                 0x86dd
 #define MV_APPLE_TALK_ARP_TYPE      0x80F3
 #define MV_NOVELL_IPX_TYPE          0x8137
-#define MV_EAPOL_TYPE				0x888e
-#define MV_VLAN_TYPE				0x8100
-#define MV_PPPOE_TYPE				0x8864
-
+#define MV_EAPOL_TYPE               0x888e
+#define MV_VLAN_TYPE                0x8100
+#define MV_PPPOE_TYPE               0x8864
+
+/* PPPoE protocol type */
+#define MV_IP_PPP  0x0021
+#define MV_IP6_PPP 0x0057
 /* Encapsulation header for RFC1042 and Ethernet_tunnel */
 
 #define MV_RFC1042_SNAP_HEADER     {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00}
@@ -194,7 +197,10 @@ typedef struct {
 	int    ipOffset;
 	int    ipHdrLen;
 	MV_U16 ipLen;
+	MV_U8  ipProto;
+	MV_U8  reserved;
 	union {
+		char          *l3;
 		MV_IP_HEADER  *ip4;
 		MV_IP6_HEADER *ip6;
 	} ip_hdr;
--- a/arch/arm/plat-armada/common/mvCommon.h
+++ b/arch/arm/plat-armada/common/mvCommon.h
@@ -65,6 +65,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #ifndef __INCmvCommonh
 #define __INCmvCommonh
 
+#ifdef __cplusplus
+extern "C" {
+#endif	/* __cplusplus */
+
 #include "mvTypes.h"
 #include "mvDeviceId.h"
 #ifndef MV_ASMLANGUAGE
@@ -72,9 +76,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "mvVideo.h"
 #endif
 
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
 /* Swap tool */
 
 /* 16bit nibble swap. For example 0x1234 -> 0x2143                          */
@@ -93,10 +94,10 @@ extern "C" {
 					((X&0xf000000) << 4) | \
 					((X&0xf0000000) >> 4))
 
-/* 16bit byte swap. For example 0x1122 -> 0x2211                            */
+/* 16bit byte swap. For example 0x1234->0x3412                             */
 #define MV_BYTE_SWAP_16BIT(X) ((((X)&0xff)<<8) | (((X)&0xff00)>>8))
 
-/* 32bit byte swap. For example 0x11223344 -> 0x44332211                    */
+/* 32bit byte swap. For example 0x12345678->0x78563412                    */
 #define MV_BYTE_SWAP_32BIT(X)  ((((X)&0xff)<<24) |                       \
 				(((X)&0xff00)<<8) |                      \
 				(((X)&0xff0000)>>8) |                    \
@@ -320,10 +321,11 @@ extern "C" {
 	((unsigned char *)addr)[4], \
 	((unsigned char *)addr)[5]
 
-#define MV_IPQUAD_FMT "%u.%u.%u.%u"
-#define MV_IPQUAD(ip)	(ip&0xFF), ((ip>>8)&0xFF), ((ip>>16)&0xFF), ((ip>>24)&0xFF)
-#define MV_IP_QUAD(ipAddr)	(((ipAddr >> 24) & 0xFF), ((ipAddr >> 16) & 0xFF), \
-				((ipAddr >> 8) & 0xFF), ((ipAddr >> 0) & 0xFF))
+#define MV_IPQUAD_FMT         "%u.%u.%u.%u"
+#define MV_IPQUAD(ip)         ip[0], ip[1], ip[2], ip[3]
+
+#define MV_IP_QUAD(ipAddr)    ((ipAddr >> 24) & 0xFF), ((ipAddr >> 16) & 0xFF), \
+				((ipAddr >> 8) & 0xFF), ((ipAddr >> 0) & 0xFF)
 
 #define MV_IP6_FMT		"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x"
 #define MV_IP6_ARG(L3)		L3[0], L3[1], L3[2], L3[3],	\
@@ -337,6 +339,8 @@ extern "C" {
 
 #define MV_SET_BIT(word, bitNum, bitVal) (((word) & ~(1 << (bitNum))) | (bitVal << bitNum))
 
+#define MV_ARRAY_SIZE(a)                    ((sizeof(a)) / (sizeof(a[0])))
+
 #ifndef MV_ASMLANGUAGE
 /* mvCommon API list */
 
@@ -361,6 +365,6 @@ MV_STATUS mvWinWithinWinTest(MV_ADDR_WIN
 
 #ifdef __cplusplus
 }
-#endif /* __cplusplus */
+#endif	/* __cplusplus */
 
 #endif /* __INCmvCommonh */
--- a/arch/arm/plat-armada/common/mvTypes.h
+++ b/arch/arm/plat-armada/common/mvTypes.h
@@ -68,17 +68,17 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 /* Defines */
 
 /* The following is a list of Marvell status    */
-#define MV_ERROR	    (-1)
-#define MV_OK		    (0)		/* Operation succeeded                   */
-#define MV_FAIL		    (1)		/* Operation failed                      */
-#define MV_BAD_VALUE        (2)		/* Illegal value (general)               */
-#define MV_OUT_OF_RANGE     (3)		/* The value is out of range             */
-#define MV_BAD_PARAM        (4)		/* Illegal parameter in function called  */
-#define MV_BAD_PTR          (5)		/* Illegal pointer value                 */
-#define MV_BAD_SIZE         (6)		/* Illegal size                          */
-#define MV_BAD_STATE        (7)		/* Illegal state of state machine        */
-#define MV_SET_ERROR        (8)		/* Set operation failed                  */
-#define MV_GET_ERROR        (9)		/* Get operation failed                  */
+#define MV_ERROR		    (-1)
+#define MV_OK			    (0)	/* Operation succeeded                   */
+#define MV_FAIL			    (1)	/* Operation failed                      */
+#define MV_BAD_VALUE        (2)	/* Illegal value (general)               */
+#define MV_OUT_OF_RANGE     (3)	/* The value is out of range             */
+#define MV_BAD_PARAM        (4)	/* Illegal parameter in function called  */
+#define MV_BAD_PTR          (5)	/* Illegal pointer value                 */
+#define MV_BAD_SIZE         (6)	/* Illegal size                          */
+#define MV_BAD_STATE        (7)	/* Illegal state of state machine        */
+#define MV_SET_ERROR        (8)	/* Set operation failed                  */
+#define MV_GET_ERROR        (9)	/* Get operation failed                  */
 #define MV_CREATE_ERROR     (10)	/* Fail while creating an item           */
 #define MV_NOT_FOUND        (11)	/* Item not found                        */
 #define MV_NO_MORE          (12)	/* No more items found                   */
@@ -106,7 +106,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #define MV_WRITE_PROTECT    (34)	/* Write protected                       */
 #define MV_DROPPED          (35)	/* Packet dropped                        */
 #define MV_STOLEN           (36)	/* Packet stolen */
-#define MV_RETRY		    (37)	/* Operation failed need retry           */
+#define MV_CONTINUE         (37)        /* Continue */
+#define MV_RETRY		    (38)	/* Operation failed need retry           */
 
 #define MV_INVALID  (int)(-1)
 
@@ -144,7 +145,6 @@ typedef int MV_STATUS;
 typedef int MV_BOOL;
 typedef void MV_VOID;
 typedef float MV_FLOAT;
-/*typedef _Bool MV_STD_BOOL;*/
 
 typedef int (*MV_FUNCPTR) (void);	/* ptr to function returning int   */
 typedef void (*MV_VOIDFUNCPTR) (void);	/* ptr to function returning void  */
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig
@@ -1,286 +1,289 @@
 config MV_ETH_PORTS_NUM
 	int "Number of Marvell GbE ports"
 	depends on MV_ETH_NETA
-	default 1 
-
-config MV_ETH_MTU_PKT_MULT
-        int "Multiplier for number of buffers of MTU size pool"
-        default 3
-        ---help---
-        Number of buffers allocated for MTU size pool for each port calculated as:
-        MV_ETH_RXQ * MV_ETH_RXQ_DESC * MV_ETH_MTU_PKT_MULT
+	default 1
+	---help---
+	Number of Marvell GbE ports supported by NETA driver
 
 menu "BM configuration"
 
 config MV_ETH_BM
 	depends on MV_ETH_NETA
-        bool "Buffer Management support (BM)"
+	bool "Buffer Management support (BM)"
 	default y
         ---help---
 
 config MV_ETH_BM_CPU
-        depends on MV_ETH_BM
-        bool "Use BM for CPU processed traffic"
-        default y
-        ---help---
+	depends on MV_ETH_BM
+	bool "Use BM for CPU processed traffic"
+	default y
+	---help---
 	BM pools is used for traffic processed by CPU and HWF both
 
-config MV_ETH_SHORT_PKT_SIZE    
+config MV_ETH_BM_0_PKT_SIZE
 	depends on MV_ETH_BM
-	int "Buffer size for short packets pool"
-	default 256
+	int "Packet size [bytes] can use buffers from pool #0"
+	default 0
 	---help---
-	Size of buffers allocated for short packets pool
+	0 - means that packet size for the pool will be defined accordingly
+        with MTU of the port that use this pool.
 
-config MV_ETH_SHORT_PKT_MULT
-        depends on MV_ETH_BM
-        int "Multiplier for number of buffers of short size pool"
-        default 5
+config MV_ETH_BM_1_PKT_SIZE
+	depends on MV_ETH_BM
+	int "Packet size [bytes] can use buffers from pool #1"
+	default 0
         ---help---
-        Number of buffers allocated for short size pool for each port calculated as:
-	MV_ETH_RXQ * MV_ETH_RXQ_DESC * MV_ETH_SHORT_PKT_MULT
+        0 - means that packet size for the pool will be defined accordingly
+        with MTU of the port that use this pool.
 
-config MV_ETH_POOL_PREDEFINED
+config MV_ETH_BM_2_PKT_SIZE
 	depends on MV_ETH_BM
-	bool "Use predefined MTU size values for long pools"
-	default n
+	int "Packet size [bytes] can use buffers from pool #2"
+	default 0
 	---help---
+        0 - means that packet size for the pool will be defined accordingly
+        with MTU of the port that use this pool.
 
-config MV_ETH_POOL_0_MTU
-        depends on MV_ETH_POOL_PREDEFINED
-        int "MTU value match for buffers in pool #0"
-        default 1500
-        ---help---
-	Giga port with MTU less or equal to MV_ETH_POOL_0_MTU can use pool0
-	as its long packets pool
+config MV_ETH_BM_3_PKT_SIZE
+	depends on MV_ETH_BM
+	int "Packet size [bytes] can use buffers from pool #3"
+	default 256
+	---help---
+        0 - means that packet size for the pool will be defined accordingly
+        with MTU of the port that use this pool.
 
-config MV_ETH_POOL_1_MTU
-        depends on MV_ETH_POOL_PREDEFINED
-        int "MTU value match for buffers in pool #1"
-        default 4096
-        ---help---
-        Giga port with MTU less or equal to MV_ETH_POOL_1_MTU can use pool1
-        as its long packets pool
-	
-config MV_ETH_POOL_2_MTU
-        depends on MV_ETH_POOL_PREDEFINED
-        int "MTU value match for buffers in pool #2"
-        default 9192
+menuconfig  MV_ETH_BM_PORT_0
+        depends on (MV_ETH_BM && (MV_ETH_PORTS_NUM != 0))
+        bool "BM configuration for GbE #0"
+        default y
         ---help---
-        Giga port with MTU less or equal to MV_ETH_POOL_2_MTU can use pool2
-        as its long packets pool
 
-endmenu
-
-config MV_ETH_LEGACY_PARSER
-	depends on !MV_ETH_PNC
-	bool "Use legacy parser for incoming traffic"
-	default y
+config  MV_ETH_BM_PORT_0_LONG_POOL
+	int "Long BM pool for GbE #0"
+	depends on MV_ETH_BM_PORT_0
+	range -1 3 if MV_ETH_BM_CPU
+	range 0 3 if !MV_ETH_BM_CPU
+	default 0
 	---help---
+	BM pool to be used for GbE #0 port to process long packets
+	-1 means that port will choose BM pool closest to required buffers size.
 
-menuconfig MV_ETH_PNC
-        depends on MV_ETH_NETA
-        bool "PnC support "
-	default y
-        ---help---
+config  MV_ETH_BM_PORT_0_SHORT_POOL
+        int "Short BM pool for GbE #0"
+        depends on MV_ETH_BM_PORT_0
+        range 0 3
+        default 3
+	---help---
+	BM pool to be used for GbE #0 port to process short packets
 
-config MV_PNC_TCAM_LINES
-        depends on MV_ETH_PNC
-        int "Number of TCAM lines supported by PNC"
-        default 512
+config  MV_ETH_BM_PORT_0_LONG_BUF_NUM
+        int "Number of buffers for Long pool of GbE #0"
+        depends on MV_ETH_BM_PORT_0
+        range 128 16384
+        default 2048
         ---help---
+	Number of long buffers allocated for this port.
 
-config MV_ETH_PNC_PARSER
-	depends on MV_ETH_PNC
-	bool "Use PnC as parser for incoming traffic"
-	default y
+config  MV_ETH_BM_PORT_0_SHORT_BUF_NUM
+        int "Number of buffers for Short pool of GbE #0"
+        depends on MV_ETH_BM_PORT_0 && (MV_ETH_BM_PORT_0_LONG_POOL != MV_ETH_BM_PORT_0_SHORT_POOL)
+        range 128 16384
+        default 4096
 	---help---
+        Number of short buffers allocated for this port.
 
-config MV_ETH_PNC_MCAST_NUM
-        depends on MV_ETH_PNC_PARSER
-        int "Use PnC for Multicast MAC addresses filtering"
-        default 8
+menuconfig  MV_ETH_BM_PORT_1
+        depends on (MV_ETH_BM && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1))
+        bool "BM configuration for GbE #1"
+        default y
         ---help---
-	Number of Multicast addresses can be matched and accepted 
-	for all ports
 
-config MV_ETH_PNC_VLAN_PRIO
-        depends on MV_ETH_PNC_PARSER
-        int "Use PnC for VLAN priority mapping"
+config  MV_ETH_BM_PORT_1_LONG_POOL
+        int "Long BM pool for GbE #1"
+        depends on MV_ETH_BM_PORT_1
+	range -1 3 if MV_ETH_BM_CPU
+	range 0 3 if !MV_ETH_BM_CPU
         default 1
         ---help---
-	Number of VLAN priorities can be mapped to different RXQs.
-	Valid range from 1 to 8.
+        BM pool to be used for GbE #1 port to process long packets.
+	-1 means that port will choose BM pool closest to required buffers size.
 
-config MV_ETH_PNC_SNAP
-        depends on MV_ETH_PNC_PARSER
-        bool "Use PnC for SNAP packets detection"
-        default n
+config  MV_ETH_BM_PORT_1_SHORT_POOL
+        int "Short BM pool for GbE #1"
+        depends on MV_ETH_BM_PORT_1
+        range 0 3
+        default 3
         ---help---
+        BM pool to be used for GbE #1 port to process short packets.
 
-config MV_ETH_PNC_ETYPE
-        depends on MV_ETH_PNC_PARSER
-        int "Use PnC for extra ETYPE detection"
-        default 0
+config  MV_ETH_BM_PORT_1_LONG_BUF_NUM
+        int "Number of buffers for Long pool of GbE #1"
+        depends on MV_ETH_BM_PORT_1
+        range 128 16384
+        default 2048
         ---help---
-        Number of extra ETYPEs can be detected in addition to 
-	ARP, IPv4, IPv6, PPPoE are detected by default.
+	Number of long buffers allocated for this port.
 
-config MV_ETH_PNC_DSCP_PRIO
-        depends on MV_ETH_PNC_PARSER
-        int "Use PnC for DSCP priority mapping"
-        default 4
+config  MV_ETH_BM_PORT_1_SHORT_BUF_NUM
+        int "Number of buffers for Short pool of GbE #1"
+        depends on MV_ETH_BM_PORT_1 && (MV_ETH_BM_PORT_1_LONG_POOL != MV_ETH_BM_PORT_1_SHORT_POOL)
+        range 128 16384
+        default 4096
         ---help---
-        Number of DSCP priorities can be mapped to different RXQs.
-        Valid range from 1 to 8.
-
-config MV_ETH_PNC_WOL
-	depends on MV_ETH_PNC_PARSER
-	bool "Use PNC for Wake On LAN support"
-	default n
-	---help---
-	Use PNC rules for TCAM filtering for Wake on LAN support.
-	When enabled, MV_ETH_NFP_PNC will be disabled.
+	Number of short buffers allocated for this port.
 
-menuconfig MV_ETH_HWF
-	depends on (MV_ETH_PNC && MV_ETH_BM)
-        bool "Hardware Forwarding support (HWF)"
+menuconfig  MV_ETH_BM_PORT_2
+        depends on (MV_ETH_BM && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) &&  (MV_ETH_PORTS_NUM != 2))
+        bool "BM configuration for GbE #2"
         default y
         ---help---
 
-menuconfig  MV_ETH_HWF_0_BM
-	depends on (MV_ETH_HWF && !MV_ETH_BM_CPU && (MV_ETH_PORTS_NUM != 0))
-	bool "BM configuration for GbE #0"
-	default y
-	---help---
-
-config  MV_ETH_HWF_0_BM_LONG_POOL
-        int "Long BM pool for GbE #0"
-        depends on MV_ETH_HWF_0_BM
-        range 0 3
-        default 0
+config  MV_ETH_BM_PORT_2_LONG_POOL
+        int "Long BM pool for GbE #2"
+        depends on MV_ETH_BM_PORT_2
+        range -1 3 if MV_ETH_BM_CPU
+        range 0 3 if !MV_ETH_BM_CPU
+        default 2
         ---help---
-	BM pool to be used for GbE #0 port to process long packets via HWF only
+        BM pool to be used for GbE #2 port to process long packets.
+	-1 means that port will choose BM pool closest to required buffers size.
 
-config  MV_ETH_HWF_0_BM_SHORT_POOL
-        int "Short BM pool for GbE #0"
-        depends on MV_ETH_HWF_0_BM
+config  MV_ETH_BM_PORT_2_SHORT_POOL
+        int "Short BM pool for GbE #2"
+        depends on MV_ETH_BM_PORT_2
         range 0 3
-        default 1
+        default 3
         ---help---
-	BM pool to be used for GbE #0 port to process short packets via HWF only
-	If BM pool for short packets set to the same as pool for long packets 
-	only one (long) pool will be used for this port
+	BM pool to be used for GbE #2 port to process short packets.
 
-config  MV_ETH_HWF_0_BM_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #0"
-        depends on MV_ETH_HWF_0_BM
+config  MV_ETH_BM_PORT_2_LONG_BUF_NUM
+        int "Number of buffers for Long pool of GbE #2"
+        depends on MV_ETH_BM_PORT_2
         range 128 16384
         default 2048
         ---help---
+        Number of long buffers allocated for this port.
 
-config  MV_ETH_HWF_0_BM_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #0"
-        depends on MV_ETH_HWF_0_BM && (MV_ETH_HWF_0_BM_SHORT_POOL != MV_ETH_HWF_0_BM_LONG_POOL)
+config  MV_ETH_BM_PORT_2_SHORT_BUF_NUM
+        int "Number of buffers for Short pool of GbE #2"
+        depends on MV_ETH_BM_PORT_2 && (MV_ETH_BM_PORT_2_LONG_POOL != MV_ETH_BM_PORT_2_SHORT_POOL)
         range 128 16384
         default 4096
         ---help---
+        Number of short buffers allocated for this port.
 
-config  MV_ETH_HWF_0_BM_SHORT_BUF_SIZE
-        int "Size of buffers for Short pool of GbE #0"
-        depends on MV_ETH_HWF_0_BM && (MV_ETH_HWF_0_BM_SHORT_POOL != MV_ETH_HWF_0_BM_LONG_POOL)
-        range 128 1024
-        default 256
-        ---help---
-
-menuconfig  MV_ETH_HWF_1_BM
-        depends on (MV_ETH_HWF && !MV_ETH_BM_CPU && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1))
-        bool "BM configuration for GbE #1"
+menuconfig  MV_ETH_BM_PORT_3
+        depends on (MV_ETH_BM && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) && (MV_ETH_PORTS_NUM != 2) && (MV_ETH_PORTS_NUM != 3))
+        bool "BM configuration for GbE #3"
         default y
         ---help---
 
-config  MV_ETH_HWF_1_BM_LONG_POOL
-	depends on MV_ETH_HWF_1_BM
-        int "Long BM pool for GbE #1"
-        range 0 3
-        default 0
+config  MV_ETH_BM_PORT_3_LONG_POOL
+        int "Long BM pool for GbE #3"
+        depends on MV_ETH_BM_PORT_3
+        range -1 3 if MV_ETH_BM_CPU
+        range 0 3 if !MV_ETH_BM_CPU
+        default 3
         ---help---
-        BM pool to be used for GbE #1 port to process long packets via HWF only
+        BM pool to be used for GbE #3 port to process long packets.
+	-1 means that port will choose BM pool closest to required buffers size.
 
-config  MV_ETH_HWF_1_BM_SHORT_POOL
-	depends on MV_ETH_HWF_1_BM
-        int "Short BM pool for GbE #1"
+config  MV_ETH_BM_PORT_3_SHORT_POOL
+        int "Short BM pool for GbE #3"
+        depends on MV_ETH_BM_PORT_3
         range 0 3
-        default 1
+        default 3
         ---help---
-        BM pool to be used for GbE #1 port to process short packets via HWF only
-        If BM pool for short packets set to the same as pool for long packets
-        only one (long) pool will be used for this port
+	BM pool to be used for GbE #3 port to process short packets.
 
-config  MV_ETH_HWF_1_BM_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #1"
-        depends on MV_ETH_HWF_1_BM
+config  MV_ETH_BM_PORT_3_LONG_BUF_NUM
+        int "Number of buffers for Long pool of GbE #3"
+        depends on MV_ETH_BM_PORT_3
         range 128 16384
         default 2048
         ---help---
+        Number of long buffers allocated for this port.
 
-config  MV_ETH_HWF_1_BM_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #1"
-        depends on MV_ETH_HWF_1_BM && (MV_ETH_HWF_1_BM_SHORT_POOL != MV_ETH_HWF_1_BM_LONG_POOL)
+config  MV_ETH_BM_PORT_3_SHORT_BUF_NUM
+        int "Number of buffers for Short pool of GbE #3"
+        depends on MV_ETH_BM_PORT_3 && (MV_ETH_BM_PORT_3_LONG_POOL != MV_ETH_BM_PORT_3_SHORT_POOL)
         range 128 16384
         default 4096
         ---help---
+        Number of short buffers allocated for this port.
+
+endmenu
+
+config MV_ETH_LEGACY_PARSER
+	depends on !MV_ETH_PNC
+	bool "Use legacy parser for incoming traffic"
+	default y
+	---help---
 
-config  MV_ETH_HWF_1_BM_SHORT_BUF_SIZE
-        int "Size of buffers for Short pool of GbE #1"
-        depends on MV_ETH_HWF_1_BM && (MV_ETH_HWF_1_BM_SHORT_POOL != MV_ETH_HWF_1_BM_LONG_POOL)
-        range 128 1024
-        default 256
+menuconfig MV_ETH_PNC
+        depends on MV_ETH_NETA
+        bool "PnC support"
+	default y
         ---help---
 
-menuconfig  MV_ETH_HWF_2_BM
-        depends on (MV_ETH_HWF && !MV_ETH_BM_CPU && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) && (MV_ETH_PORTS_NUM != 2))
-        bool "BM configuration for GbE #2"
-        default y
+config MV_PNC_TCAM_LINES
+        depends on MV_ETH_PNC
+        int "Number of TCAM lines supported by PNC"
+        default 512
         ---help---
 
-config  MV_ETH_HWF_2_BM_LONG_POOL
-        depends on MV_ETH_HWF_2_BM
-        int "Long BM pool for GbE #2"
-        range 0 3
-        default 2
+config MV_ETH_PNC_MCAST_NUM
+        depends on MV_ETH_PNC
+        int "Use PnC for Multicast MAC addresses filtering"
+        default 8
         ---help---
-        BM pool to be used for GbE #2 port to process long packets via HWF only
+	Number of Multicast addresses can be matched and accepted
+	for all ports
 
-config  MV_ETH_HWF_2_BM_SHORT_POOL
-        depends on MV_ETH_HWF_2_BM
-        int "Short BM pool for GbE #2"
-        range 0 3
-        default 3
+config MV_ETH_PNC_VLAN_PRIO
+        depends on MV_ETH_PNC
+        bool "Use PnC for VLAN priority mapping"
+        default n
         ---help---
-        BM pool to be used for GbE #2 port to process short packets via HWF only
-        If BM pool for short packets set to the same as pool for long packets
-        only one (long) pool will be used for this port
+	Enable using PNC to map packets with different VLAN priorities to different RXQs.
+	When enabled, 7 PnC rules will be allocated for this purpose
 
-config  MV_ETH_HWF_2_BM_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #2"
-        depends on MV_ETH_HWF_2_BM
-        range 128 16384
-        default 2048
+config MV_ETH_PNC_ETYPE
+        depends on MV_ETH_PNC
+        int "Use PnC for extra ETYPE detection"
+        default 0
         ---help---
+        Number of extra ETYPEs can be detected in addition to
+	ARP, IPv4, IPv6, PPPoE are detected by default.
 
-config  MV_ETH_HWF_2_BM_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #2"
-        depends on MV_ETH_HWF_2_BM && (MV_ETH_HWF_2_BM_SHORT_POOL != MV_ETH_HWF_2_BM_LONG_POOL)
-        range 128 16384
-        default 4096
+config MV_ETH_PNC_DSCP_PRIO
+        depends on MV_ETH_PNC
+        int "Use PnC for DSCP priority mapping"
+        default 4
+        ---help---
+        Number of DSCP priorities can be mapped to different RXQs.
+        Valid range from 1 to 8.
+
+config MV_ETH_PNC_L3_FLOW
+	depends on MV_ETH_PNC
+        bool "Use PNC for L3 Flows detection"
+        default n
         ---help---
+        Use PNC rules for IPv4 and IPv6 Flows processing.
+        When enabled, MV_ETH_PNC_WOL will be disabled.
+
+config MV_ETH_PNC_WOL
+	depends on MV_ETH_PNC
+	bool "Use PNC for Wake On LAN support"
+	default n
+	---help---
+	Use PNC rules for TCAM filtering for Wake on LAN support.
+	When enabled, MV_ETH_NFP_PNC will be disabled.
 
-config  MV_ETH_HWF_2_BM_SHORT_BUF_SIZE
-        int "Size of buffers for Short pool of GbE #2"
-        depends on MV_ETH_HWF_2_BM && (MV_ETH_HWF_2_BM_SHORT_POOL != MV_ETH_HWF_2_BM_LONG_POOL)
-        range 128 1024
-        default 256
+menuconfig MV_ETH_HWF
+	depends on (MV_ETH_PNC && MV_ETH_BM)
+        bool "Hardware Forwarding support (HWF)"
+        default y
         ---help---
 
 config MV_ETH_HWF_TXQ_DROP
@@ -298,9 +301,27 @@ config MV_ETH_HWF_TXQ_DROP_RND
 config MV_ETH_PMT
         depends on MV_ETH_NETA
         bool "Packet Modification Table (PMT)"
-        default y
+        default n
         ---help---
 
+config MV_ETH_PMT_FLOWS
+	int "Number of different flows can be set to PMT"
+	depends on MV_ETH_PMT
+	default 256
+	---help---
+	Depend on total number of PMT entries and
+	number of PMT entires reserved for each flow.
+	MV_ETH_PMT_SIZE >= (MV_ETH_PMT_FLOWS * (MV_ETH_PMT_CMD_PER_FLOW + 1))
+
+config MV_ETH_PMT_CMD_PER_FLOW
+        int "Number of PMT entries reserved for each flow"
+        depends on MV_ETH_PMT
+        default 12
+        ---help---
+        Depend on total number of PMT entries and
+        number of flows to be supported.
+	MV_ETH_PMT_SIZE >= (MV_ETH_PMT_FLOWS * (MV_ETH_PMT_CMD_PER_FLOW + 1))
+
 menu "Network Interface configuration"
 
 config  MV_ETH_0_MTU
@@ -315,7 +336,7 @@ config  MV_ETH_0_MACADDR
         depends on (MV_ETH_PORTS_NUM != 0)
         default "00:00:00:00:00:80"
         ---help---
-        Default MAC address for Marvell GbE port #0 
+        Default MAC address for Marvell GbE port #0
 
 config  MV_ETH_1_MTU
         int "Giga port #1 MTU value"
@@ -434,14 +455,14 @@ config  MV_ETH_GRO
 	default y
         ---help---
         Marvell network driver compiled with GRO (Generic Receive Offload) support.
-		
+
 config  MV_ETH_GRO_DEF
 	depends on MV_ETH_GRO
         bool "Default value for GRO feature: enable/disable"
 	default y
         ---help---
         Can be changed in run-time using ethtool
-		
+
 config  MV_ETH_TSO
         bool "TSO Support for Marvell network interface"
 	default y
@@ -459,12 +480,6 @@ endmenu
 
 menu "Control and Statistics"
 
-config  MV_ETH_PROC
-	bool "Support procfs"
-	default y
-	---help---
-	  Use mv_eth_tool to control Marvell network interface driver through procfs.
-
 config  MV_ETH_DEBUG_CODE
 	bool "Add run-time debug code"
 	default n
@@ -475,22 +490,22 @@ config  MV_ETH_STAT_ERR
         bool "Collect error statistics"
         default y
 	---help---
-	Marvell network interface driver collect minimal number of statistics. 
+	Marvell network interface driver collect minimal number of statistics.
 	Only for error conditions. Can be displayed using mv_eth_tool.
 
 config  MV_ETH_STAT_INF
         bool "Collect event statistics"
         default y
         ---help---
-	Marvell network interface driver collect event statistics. 
-	Provide more information about driver functionality and almost doesn't 
+	Marvell network interface driver collect event statistics.
+	Provide more information about driver functionality and almost doesn't
 	effect performance. Can be displayed using mv_eth_tool.
 
 config  MV_ETH_STAT_DBG
         bool "Collect debug statistics"
         default n
         ---help---
-	Marvell network interface driver collect a lot of statistics. 
+	Marvell network interface driver collect a lot of statistics.
 	Used for Debug mode. Decrease performance. Can be displayed using mv_eth_tool.
 
 config  MV_ETH_STAT_DIST
@@ -506,11 +521,11 @@ config  MV_LINUX_COUNTERS_DISABLE
 	---help---
 	Disable collection of SNMP statistics and Netfilter Contract statistics to improve performance.
 
-config  MV_ETH_TOOL	
+config  MV_ETH_TOOL
 	bool "Support ethtool controls"
 	default y
 	---help---
-	Support kernel's SIOCETHTOOL for ethtool utility	
+	Support kernel's SIOCETHTOOL for ethtool utility
 endmenu
 
 menu "Advanced Features"
@@ -560,20 +575,20 @@ config  MV_ETH_TXDONE_COAL_PKTS
 	int "Threshold for TX_DONE event trigger"
 	default 16
 	---help---
-	Number of packets will be sent before TX_DONE event will be triggered	
+	Number of packets will be sent before TX_DONE event will be triggered
 	by interrupt or polling.
 
 config  MV_ETH_RX_COAL_PKTS
         int "Threshold [number of packets] for RX interrupt"
-        default 64
+        default 32
         ---help---
         Number of packets will be received before RX interrupt will be generated by HW.
 
 config  MV_ETH_RX_COAL_USEC
         int "Threshold [usec] for RX interrupt"
-        default 200
+        default 100
         ---help---
-        Time delay in usec before RX interrupt will be generated by HW if number of 
+        Time delay in usec before RX interrupt will be generated by HW if number of
 	received packets larger than 0 but smaller than MV_ETH_RX_COAL_PKTS
 
 config  MV_ETH_RX_DESC_PREFETCH
@@ -588,10 +603,13 @@ config  MV_ETH_RX_PKT_PREFETCH
         ---help---
         Use pld instruction to prefetch first two cache lines of received packet data
 
-config  MV_ETH_IGMP
-        bool "IGMP special processing support"
-        default n
+config  MV_ETH_NAPI_GROUPS
+        int "Number of NAPI instanses can be used per port"
+	range 1 NR_CPUS if SMP
+	range 1 1 if !SMP
+        default 1
         ---help---
+	Different RXQs and TXQs can be processed by different CPU using different NAPI instances
 
 config MV_ETH_RX_SPECIAL
 	depends on MV_ETH_PNC
@@ -608,8 +626,6 @@ config MV_ETH_TX_SPECIAL
 
 config MV_ETH_L2FW
 	bool "L2 Forwarding support"
-	select MV_ETH_NFP_SEC
-	depends on !MV_CESA_TOOL && !MV_CESA_TEST && !MV_CESA_OCF && MV_INCLUDE_XOR
 	default n
 	---help---
 	Enable L2 Forwarding support for received packets.
@@ -622,13 +638,13 @@ config MV_ETH_L2FW_DEBUG
 	default n
 	---help---
 	Enable L2FW run-time enable/disable enter debug code blocks
-	
+
 config MV_ETH_RX_POLL_WEIGHT
 	int "poll weight for the RX poll() function"
 	default 64
 	range 1 255
 	---help---
-	poll weight for the RX poll() function; must be less or equal to 255 	
+	poll weight for the RX poll() function; must be less or equal to 255
 
 config MV_ETH_EXTRA_BUF_SIZE
 	int "Extra buffer size in bytes"
@@ -642,7 +658,7 @@ config MV_ETH_EXTRA_BUF_NUM
         int "Number of extra buffers allocated for each port"
         default MV_ETH_TXQ_DESC
 	---help---
-	Number of extra buffers allocated for each port 
+	Number of extra buffers allocated for each port
 endmenu
 
 menu "NFP support"
@@ -653,86 +669,191 @@ config  MV_ETH_NFP
         ---help---
         Choosing this option will enable Network Fast Processing.
 
+config MV_ETH_NFP_LIB
+        bool "build a library (nfplib.a) for Network Fast Processing (NFP)"
+		select MV_ETH_NFP
+		select MV_ETH_NFP_CT
+		select MV_ETH_NFP_CT_LEARN
+		select MV_ETH_NFP_BRIDGE
+		select MV_ETH_NFP_BRIDGE_LEARN
+		select MV_ETH_NFP_VLAN
+		select MV_ETH_NFP_VLAN_LEARN
+		select MV_ETH_NFP_FIB
+		select MV_ETH_NFP_FIB_LEARN
+		select MV_ETH_NFP_CLASSIFY
+		select MV_ETH_NFP_PPP
+		select MV_ETH_NFP_PPP_LEARN
+		select MV_ETH_NFP_NAT
+		select MV_ETH_NFP_STATS
+		select MV_ETH_NFP_DEBUG
+		default n
+        ---help---
+        Choosing this option will enable building nfplib.a for NFP.
+
 config MV_ETH_NFP_DEF
         depends on MV_ETH_NFP
-        int "Default value for NFP:  0 - disable, 1 - enable"
+        int "Default value for NFP:  0 - Disable, 1 - Enable in 2 tuple mode, 2 - Enable in 5 tuple mode"
         default 0
+	range 0 0 if MV_ETH_NFP_LIB
         ---help---
 
+config  MV_ETH_NFP_EXT
+        bool "Support NFP for External (non GBE) network interfaces"
+        depends on MV_ETH_NFP && !MV_ETH_NFP_LIB
+        default n
+         ---help---
+        Choosing this option will enable NFP for non-GBE network interfaces.
+
+config  MV_ETH_NFP_EXT_NUM
+        int "Maximum number of External (non-Gbe) interfaces"
+        depends on MV_ETH_NFP_EXT
+        default 1
+	range 1 4
+         ---help---
+
 config MV_ETH_NFP_BRIDGE
-        bool "Support NFP bridging"
+        bool "Support NFP Bridging"
         default y
         depends on MV_ETH_NFP
         ---help---
         Choosing this option will enable NFP bridging support.
 
+choice
+        prompt "NFP Bridging Mode"
+        depends on MV_ETH_NFP_BRIDGE
+        default MV_ETH_NFP_BRIDGE_LEARN
+
+config	MV_ETH_NFP_BRIDGE_LEARN
+	bool "FDB"
+	---help---
+	  enable NFP bridging dynamic learning via NFP hooks
+
+config MV_ETH_NFP_BRIDGE_LEARN_DEF
+        depends on MV_ETH_NFP_BRIDGE_LEARN
+        int "Default value for NFP BRIDGE Dynamic Learning:  0 - disable, 1 - enable"
+        default 0
+	range 0 0 if MV_ETH_NFP_LIB
+        ---help---
+
+config  MV_ETH_NFP_BRIDGE_STATIC
+	bool "BRIDGE"
+	---help---
+	  enable NFP bridging in static mode
+
+endchoice
+
+config MV_ETH_NFP_VLAN
+        bool "Support NFP VLANs processing"
+        default y
+        depends on MV_ETH_NFP
+        ---help---
+        Choosing this option will enable NFP VLANs support.
+
+config MV_ETH_NFP_VLAN_LEARN
+        depends on MV_ETH_NFP_VLAN
+        bool "Support NFP VLAN Dynamic Learning"
+        default y
+        ---help---
+        Choosing this option will enable NFP VLAN dynamic learning via NFP hooks
+	in Linux Network stack.
+
+config MV_ETH_NFP_VLAN_LEARN_DEF
+        depends on MV_ETH_NFP_VLAN_LEARN
+        int "Default value for NFP VLAN Dynamic Learning:  0 - disable, 1 - enable"
+        default 0
+	range 0 0 if MV_ETH_NFP_LIB
+        ---help---
+
 config MV_ETH_NFP_FIB
-        bool "Support NFP routing"
+        bool "Support NFP Routing"
 	default y
         depends on MV_ETH_NFP
         ---help---
         Choosing this option will enable NFP routing support.
 
+config MV_ETH_NFP_FIB_LEARN
+        depends on MV_ETH_NFP_FIB
+        bool "Support NFP Routing Dynamic Learning"
+        default y
+        ---help---
+        Choosing this option will enable NFP Routing dynamic learning via NFP hooks
+	in Linux Network stack.
+
+config MV_ETH_NFP_FIB_LEARN_DEF
+        depends on MV_ETH_NFP_FIB_LEARN
+        int "Default value for NFP Routing Dynamic Learning:  0 - disable, 1 - enable"
+        default 0
+	range 0 0 if MV_ETH_NFP_LIB
+        ---help---
+
+config MV_ETH_NFP_CT
+        bool "Support NFP 5 Tuple Rules"
+        depends on MV_ETH_NFP_FIB && NF_CONNTRACK
+	default y
+        ---help---
+        Choosing this option will enable NFP 5 Tuple Rules support.
+
+config MV_ETH_NFP_CT_LEARN
+        depends on MV_ETH_NFP_CT
+        bool "Support NFP 5 Tuple Dynamic Learning"
+        default y
+        ---help---
+        Choosing this option will enable NFP 5 Tuple dynamic learning via NFP hooks
+	in Linux Network stack.
+
+config MV_ETH_NFP_CT_LEARN_DEF
+        depends on MV_ETH_NFP_CT_LEARN
+        int "Default value for NFP 5 Tuple Dynamic Learning:  0 - disable, 1 - enable"
+        default 0
+	range 0 0 if MV_ETH_NFP_LIB
+        ---help---
+
 config MV_ETH_NFP_NAT
         bool "Support NFP NAT"
-        depends on MV_ETH_NFP_FIB && NF_CONNTRACK
+        depends on MV_ETH_NFP_CT
 	default y
         ---help---
         Choosing this option will enable NFP NAT support.
 
+config MV_ETH_NFP_LIMIT
+        bool "Support NFP Ingress Rate Limiting"
+        depends on MV_ETH_NFP_CT && !MV_ETH_NFP_LIB
+	default n
+        ---help---
+        Choosing this option will enable NFP rate limitation support based on 5 tuple rule.
+
+config  MV_ETH_NFP_CLASSIFY
+	bool "Support NFP Classification rules"
+	depends on MV_ETH_NFP_CT || MV_ETH_NFP_BRIDGE
+	default y
+	---help---
+	Choosing this option will enable NFP classification rules (DSCP and VLAN modification and Tx queue selection)
+
 config  MV_ETH_NFP_PPP
 	bool "Support NFP PPPoE"
-	depends on MV_ETH_NFP_FIB && PPPOE
+	depends on MV_ETH_NFP_FIB && PPPOE && MV_ETH_PNC
 	default n
 	 ---help---
 	Choosing this option will enable NFP PPPoE protocol.
 
-config MV_ETH_NFP_PNC
-	bool "Support NFP forwarding with PnC"
-	depends on MV_ETH_NFP && MV_ETH_PNC_PARSER && !MV_ETH_PNC_WOL
-	default y 
-	---help---
-	Choosing this option will add PNC(TCAM) assistance to NFP.
-
-config MV_ETH_NFP_PMT
-        bool "Use PMT for NFP forwarding with PNC"
-	depends on MV_ETH_PMT && MV_ETH_NFP_PNC
-        default n
-        ---help---
-
-config MV_ETH_PMT_FLOWS
-	int "Number of different flows can be set to PMT"
-	depends on MV_ETH_NFP_PMT
-	default 256
-	---help---
-	Depend on total number of PMT entries and 
-	number of PMT entires reserved for each flow.
-	MV_ETH_PMT_SIZE >= (MV_ETH_PMT_FLOWS * (MV_ETH_PMT_CMD_PER_FLOW + 1))
-
-config MV_ETH_PMT_CMD_PER_FLOW
-        int "Number of PMT entries reserved for each flow"
-        depends on MV_ETH_NFP_PMT
-        default 12
+config MV_ETH_NFP_PPP_LEARN
+        depends on MV_ETH_NFP_PPP
+        bool "Support NFP PPPoE Dynamic Learning"
+        default y
         ---help---
-        Depend on total number of PMT entries and
-        number of flows to be supported.
-	MV_ETH_PMT_SIZE >= (MV_ETH_PMT_FLOWS * (MV_ETH_PMT_CMD_PER_FLOW + 1))
+        Choosing this option will enable NFP PPPoE dynamic learning via NFP hooks
+	in Linux Network stack.
 
-config MV_ETH_NFP_HWF
-        bool "Use HWF for NFP forwarding with PNC and PMT"
-        depends on MV_ETH_HWF && MV_ETH_NFP_PNC && MV_ETH_NFP_PMT
-        default n
+config MV_ETH_NFP_PPP_LEARN_DEF
+        depends on MV_ETH_NFP_PPP_LEARN
+        int "Default value for NFP PPPoE Dynamic Learning:  0 - disable, 1 - enable"
+        default 0
+	range 0 0 if MV_ETH_NFP_LIB
         ---help---
 
-config MV_ETH_NFP_SWF
-	bool "Support NFP SW Forwarding (simulate HWF)"
-	depends on MV_ETH_NFP && MV_ETH_PNC
-	default n
-	---help---
-	Choosing this option will enable NFP SW Forwarding.
 
 config  MV_ETH_NFP_STATS
-        bool "Collect NFP statistics"
+        bool "Collect NFP Statistics"
 	depends on MV_ETH_NFP
         default n
         ---help---
@@ -740,17 +861,18 @@ config  MV_ETH_NFP_STATS
 
 config  MV_ETH_NFP_DEBUG
 	bool "Add NFP debug code"
-	depends on MV_ETH_NFP	
+	depends on MV_ETH_NFP
 	default n
         ---help---
-	Add NFP sanity check code	
-	
+	Add NFP sanity check code
+
 config MV_ETH_NFP_SEC
 	bool "Support NFP IPSec"
-	depends on MV_ETH_NFP 
+	depends on MV_ETH_NFP && !MV_ETH_NFP_LIB
 	default n
 	---help---
 	Choosing this option will IPSec support in NFP.
+
 endmenu
 
 menu "PON support for Network driver"
@@ -781,7 +903,7 @@ config MV_ETH_SWITCH
         bool "Switch support"
 	depends on MV_INCLUDE_SWITCH
         ---help---
-	Choose this option to support Gigabit Ethernet Controller connected to 
+	Choose this option to support Gigabit Ethernet Controller connected to
         on-board QuarterDeck switch family
 
 config  MV_ETH_SWITCH_NETDEV_NUM
@@ -791,14 +913,23 @@ config  MV_ETH_SWITCH_NETDEV_NUM
 	---help---
 	Valid range range from 1 to BOARD_ETH_SWITCH_PORT_NUM
 
-config  MV_ETH_SWITCH_NETCONFIG
-	string "Switch network configuration"
+config  MV_ETH_SWITCH_NETCONFIG_0
+	string "Switch network configuration for GbE port 0"
 	depends on MV_ETH_SWITCH
 	default "3,(00:11:66:11:66:11,0)(00:22:77:22:77:22,1:2:3:4),mtu=1500"
 	---help---
-	 Set the network configuration when giga port connected to switch. 
-         For each interface, define the interface 
-	 name, MAC address and participating ports. 
+	 Set the network configuration when giga port connected to switch.
+         For each interface, define the interface
+	 name, MAC address and participating ports.
+
+config  MV_ETH_SWITCH_NETCONFIG_1
+	string "Switch network configuration for GbE port 1"
+	depends on MV_ETH_SWITCH
+	default "0"
+	---help---
+	 Set the network configuration when giga port connected to switch.
+         For each interface, define the interface
+	 name, MAC address and participating ports.
 
 config  MV_ETH_SWITCH_LINK
 	bool "Link status change indications"
@@ -808,12 +939,32 @@ config  MV_ETH_SWITCH_LINK
 	  Support Phy link status change indications.
 endmenu
 
-config ARMADA_XP_ERRATA_SMI_1
-	bool "use SMI port 1 instead of SMI port 0"
-	        ---help---
-	Using SMI port 1 instead of SMI port 0 prevents the 
-	link up/link down on a different port than the port on which 
-	an action such as changing speed or starting autonegotiation is done.
-	(NetA BTS #313, DSMP LSP #42, ARMADA XP Z1).
-	
+menu "ERRATA / WA"
 
+config MV_ETH_ERRATA_SMI_ACCESS
+        bool "use SMI port 1 instead of SMI port 0"
+        depends on ARMADA_XP_REV_Z1
+        default y
+        ---help---
+        Using SMI port 1 instead of SMI port 0 prevents the
+        link up/link down on a different port than the port on which
+        an action such as changing speed or starting autonegotiation is done.
+        (NetA BTS #313, DSMP LSP #42, ARMADA XP Z1).
+
+config MV_ETH_REDUCE_BURST_SIZE_WA
+        bool "Limit burst size of RX and TX transactions to 16B in IOCC mode"
+        depends on AURORA_IO_CACHE_COHERENCY
+        default y
+        ---help---
+        To avoid CPU make invalidate which might cause hang, force partial
+        read/write by limiting the burst size to 16B since it is less than the
+        size of a cache line.
+
+config MV_ETH_BE_WA
+        bool "WA for RX and TX descriptors swap in HW issue"
+        depends on CPU_ENDIAN_BE32
+        default n
+        ---help---
+        If set swap of RX and TX descriptors in BE mode will be done by driver
+
+endmenu
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/bm/bm_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/bm/bm_sysfs.c
@@ -42,7 +42,9 @@ static ssize_t bm_help(char *buf)
 
 	off += sprintf(buf+off, "cat                regs         - show BM registers\n");
 	off += sprintf(buf+off, "cat                stat         - show BM status\n");
+	off += sprintf(buf+off, "cat                config       - show compile-time BM configuration\n");
 	off += sprintf(buf+off, "echo p v           > dump       - dump BM pool <p>. v=0-brief, v=1-full\n");
+	off += sprintf(buf+off, "echo p s           > size       - set packet size <s> to BM pool <p>\n");
 
 	return off;
 }
@@ -62,29 +64,32 @@ static ssize_t bm_show(struct device *de
 		mvBmRegs();
 	else if (!strcmp(name, "stat"))
 		mvBmStatus();
+	else if (!strcmp(name, "config"))
+		mv_eth_bm_config_print();
 	else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
 	}
-
 	return err;
 }
 static ssize_t bm_store(struct device *dev,
 				   struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char    *name = attr->attr.name;
-	unsigned int  err = 0, pool = 0, mode = 0;
+	unsigned int  err = 0, pool = 0, val = 0;
 	unsigned long flags;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	sscanf(buf, "%d %d", &pool, &mode);
+	sscanf(buf, "%d %d", &pool, &val);
 
 	local_irq_save(flags);
 
 	if (!strcmp(name, "dump")) {
-		mvBmPoolDump(pool, mode);
+		mvBmPoolDump(pool, val);
+	} else if (!strcmp(name, "size")) {
+		err = mv_eth_ctrl_pool_size_set(pool, val);
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -94,13 +99,17 @@ static ssize_t bm_store(struct device *d
 	return err ? -EINVAL : len;
 }
 
-static DEVICE_ATTR(dump,  S_IWUSR, NULL, bm_store);
-static DEVICE_ATTR(stat,  S_IRUSR, bm_show, NULL);
-static DEVICE_ATTR(regs,  S_IRUSR, bm_show, NULL);
-static DEVICE_ATTR(help,  S_IRUSR, bm_show, NULL);
+static DEVICE_ATTR(size,   S_IWUSR, NULL, bm_store);
+static DEVICE_ATTR(dump,   S_IWUSR, NULL, bm_store);
+static DEVICE_ATTR(config, S_IRUSR, bm_show, NULL);
+static DEVICE_ATTR(stat,   S_IRUSR, bm_show, NULL);
+static DEVICE_ATTR(regs,   S_IRUSR, bm_show, NULL);
+static DEVICE_ATTR(help,   S_IRUSR, bm_show, NULL);
 
 static struct attribute *bm_attrs[] = {
+	&dev_attr_size.attr,
 	&dev_attr_dump.attr,
+	&dev_attr_config.attr,
 	&dev_attr_regs.attr,
 	&dev_attr_stat.attr,
 	&dev_attr_help.attr,
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/bm/mv_eth_bm.c
@@ -0,0 +1,186 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include "gbe/mvNeta.h"
+#include "bm/mvBm.h"
+
+#include "net_dev/mv_netdev.h"
+
+typedef struct {
+	int             pool_pkt_size[MV_BM_POOLS];
+	MV_BM_CONFIG	port_config[CONFIG_MV_ETH_PORTS_NUM];
+} MV_ETH_BM_CONFIG;
+
+static MV_ETH_BM_CONFIG mv_eth_bm_config;
+
+int mv_eth_bm_config_pkt_size_get(int pool)
+{
+	if (mvNetaMaxCheck(pool, MV_BM_POOLS))
+		return -EINVAL;
+
+	return mv_eth_bm_config.pool_pkt_size[pool];
+}
+
+int mv_eth_bm_config_pkt_size_set(int pool, int pkt_size)
+{
+	if (mvNetaMaxCheck(pool, MV_BM_POOLS))
+		return -EINVAL;
+
+	mv_eth_bm_config.pool_pkt_size[pool] = pkt_size;
+	return 0;
+}
+
+int mv_eth_bm_config_long_pool_get(int port)
+{
+	if (mvNetaPortCheck(port))
+		return -EINVAL;
+
+	return mv_eth_bm_config.port_config[port].longPool;
+}
+
+int mv_eth_bm_config_long_buf_num_get(int port)
+{
+	if (mvNetaPortCheck(port))
+		return -EINVAL;
+
+	return mv_eth_bm_config.port_config[port].longBufNum;
+}
+
+int mv_eth_bm_config_short_pool_get(int port)
+{
+	if (mvNetaPortCheck(port))
+		return -EINVAL;
+
+	return mv_eth_bm_config.port_config[port].shortPool;
+}
+
+int mv_eth_bm_config_short_buf_num_get(int port)
+{
+	if (mvNetaPortCheck(port))
+		return -EINVAL;
+
+	return mv_eth_bm_config.port_config[port].shortBufNum;
+}
+
+/* Once time call: init configuration structure accordingly with compile time parameters */
+MV_STATUS mv_eth_bm_config_get(void)
+{
+	MV_BM_CONFIG *bmConfig;
+	int           port;
+
+	mv_eth_bm_config.pool_pkt_size[0] = CONFIG_MV_ETH_BM_0_PKT_SIZE;
+	mv_eth_bm_config.pool_pkt_size[1] = CONFIG_MV_ETH_BM_1_PKT_SIZE;
+	mv_eth_bm_config.pool_pkt_size[2] = CONFIG_MV_ETH_BM_2_PKT_SIZE;
+	mv_eth_bm_config.pool_pkt_size[3] = CONFIG_MV_ETH_BM_3_PKT_SIZE;
+
+#ifdef CONFIG_MV_ETH_BM_PORT_0
+	port = 0;
+	bmConfig = &mv_eth_bm_config.port_config[port];
+	memset(bmConfig, 0, sizeof(MV_BM_CONFIG));
+	bmConfig->valid = 1;
+	bmConfig->longPool = CONFIG_MV_ETH_BM_PORT_0_LONG_POOL;
+	bmConfig->shortPool = CONFIG_MV_ETH_BM_PORT_0_SHORT_POOL;
+	bmConfig->longBufNum = CONFIG_MV_ETH_BM_PORT_0_LONG_BUF_NUM;
+
+#if (CONFIG_MV_ETH_BM_PORT_0_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_0_LONG_POOL)
+	bmConfig->shortBufNum = CONFIG_MV_ETH_BM_PORT_0_SHORT_BUF_NUM;
+#endif /* CONFIG_MV_ETH_BM_PORT_0_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_0_LONG_POOL */
+#endif /* CONFIG_MV_ETH_BM_PORT_0 */
+
+#ifdef CONFIG_MV_ETH_BM_PORT_1
+	port = 1;
+	bmConfig = &mv_eth_bm_config.port_config[port];
+	memset(bmConfig, 0, sizeof(MV_BM_CONFIG));
+	bmConfig->valid = 1;
+	bmConfig->longPool = CONFIG_MV_ETH_BM_PORT_1_LONG_POOL;
+	bmConfig->shortPool = CONFIG_MV_ETH_BM_PORT_1_SHORT_POOL;
+	bmConfig->longBufNum = CONFIG_MV_ETH_BM_PORT_1_LONG_BUF_NUM;
+
+#if (CONFIG_MV_ETH_BM_PORT_1_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_1_LONG_POOL)
+	bmConfig->shortBufNum = CONFIG_MV_ETH_BM_PORT_1_SHORT_BUF_NUM;
+#endif /* CONFIG_MV_ETH_BM_PORT_1_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_1_LONG_POOL */
+#endif /* CONFIG_MV_ETH_BM_PORT_1 */
+
+#ifdef CONFIG_MV_ETH_BM_PORT_2
+	port = 2;
+	bmConfig = &mv_eth_bm_config.port_config[port];
+	memset(bmConfig, 0, sizeof(MV_BM_CONFIG));
+	bmConfig->valid = 1;
+	bmConfig->longPool = CONFIG_MV_ETH_BM_PORT_2_LONG_POOL;
+	bmConfig->shortPool = CONFIG_MV_ETH_BM_PORT_2_SHORT_POOL;
+	bmConfig->longBufNum = CONFIG_MV_ETH_BM_PORT_2_LONG_BUF_NUM;
+
+#if (CONFIG_MV_ETH_BM_PORT_2_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_2_LONG_POOL)
+	bmConfig->shortBufNum = CONFIG_MV_ETH_BM_PORT_2_SHORT_BUF_NUM;
+#endif /* CONFIG_MV_ETH_BM_PORT_2_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_2_LONG_POOL */
+#endif /* CONFIG_MV_ETH_BM_PORT_2 */
+
+	#ifdef CONFIG_MV_ETH_BM_PORT_3
+	port = 3;
+	bmConfig = &mv_eth_bm_config.port_config[port];
+	memset(bmConfig, 0, sizeof(MV_BM_CONFIG));
+	bmConfig->valid = 1;
+	bmConfig->longPool = CONFIG_MV_ETH_BM_PORT_3_LONG_POOL;
+	bmConfig->shortPool = CONFIG_MV_ETH_BM_PORT_3_SHORT_POOL;
+	bmConfig->longBufNum = CONFIG_MV_ETH_BM_PORT_3_LONG_BUF_NUM;
+
+#if (CONFIG_MV_ETH_BM_PORT_3_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_3_LONG_POOL)
+	bmConfig->shortBufNum = CONFIG_MV_ETH_BM_PORT_3_SHORT_BUF_NUM;
+#endif /* CONFIG_MV_ETH_BM_PORT_3_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_3_LONG_POOL */
+#endif /* CONFIG_MV_ETH_BM_PORT_3 */
+
+	return MV_OK;
+}
+
+void mv_eth_bm_config_print(void)
+{
+	int           i;
+	MV_BM_CONFIG *bmConfig;
+
+	mvOsPrintf("BM compile time configuration\n");
+	for (i = 0; i < MV_BM_POOLS; i++)
+		mvOsPrintf("pool %d: pkt_size = %d bytes\n", i, mv_eth_bm_config.pool_pkt_size[i]);
+
+	mvOsPrintf("\n");
+	mvOsPrintf("port:  longPool  shortPool  longBufNum  shortBufNum\n");
+	for (i = 0; i < CONFIG_MV_ETH_PORTS_NUM; i++) {
+		bmConfig = &mv_eth_bm_config.port_config[i];
+		if (bmConfig->valid)
+			mvOsPrintf("  %2d:   %4d       %4d        %4d         %4d\n",
+				i, bmConfig->longPool, bmConfig->shortPool,
+				bmConfig->longBufNum, bmConfig->shortBufNum);
+	}
+	mvOsPrintf("\n");
+}
+
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/hwf/hwf_bm.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/hwf/hwf_bm.c
@@ -38,64 +38,7 @@ disclaimer.
 #include "net_dev/mv_netdev.h"
 
 static MV_BM_POOL	hwfBmPool[MV_BM_POOLS];
-static MV_BM_CONFIG	hwfBmConfig[CONFIG_MV_ETH_PORTS_NUM];
 
-static MV_STATUS mv_hwf_bm_config_get(int port, MV_BM_CONFIG *bmConfig)
-{
-	switch (port) {
-
-#ifdef CONFIG_MV_ETH_HWF_0_BM
-	case 0:
-		bmConfig->valid = 1;
-		bmConfig->longPool = CONFIG_MV_ETH_HWF_0_BM_LONG_POOL;
-		bmConfig->shortPool = CONFIG_MV_ETH_HWF_0_BM_SHORT_POOL;
-		bmConfig->longBufNum = CONFIG_MV_ETH_HWF_0_BM_LONG_BUF_NUM;
-
-#if (CONFIG_MV_ETH_HWF_0_BM_SHORT_POOL != CONFIG_MV_ETH_HWF_0_BM_LONG_POOL)
-		bmConfig->shortBufNum = CONFIG_MV_ETH_HWF_0_BM_SHORT_BUF_NUM;
-		bmConfig->shortBufSize = CONFIG_MV_ETH_HWF_0_BM_SHORT_BUF_SIZE;
-#endif /* CONFIG_MV_ETH_HWF_0_BM_SHORT_POOL != CONFIG_MV_ETH_HWF_0_BM_LONG_POOL */
-
-		break;
-#endif /* CONFIG_MV_ETH_HWF_0_BM */
-
-#ifdef CONFIG_MV_ETH_HWF_1_BM
-	case 1:
-		bmConfig->valid = 1;
-		bmConfig->longPool = CONFIG_MV_ETH_HWF_1_BM_LONG_POOL;
-		bmConfig->shortPool = CONFIG_MV_ETH_HWF_1_BM_SHORT_POOL;
-		bmConfig->longBufNum = CONFIG_MV_ETH_HWF_1_BM_LONG_BUF_NUM;
-
-#if (CONFIG_MV_ETH_HWF_1_BM_SHORT_POOL != CONFIG_MV_ETH_HWF_1_BM_LONG_POOL)
-		bmConfig->shortBufNum = CONFIG_MV_ETH_HWF_1_BM_SHORT_BUF_NUM;
-		bmConfig->shortBufSize = CONFIG_MV_ETH_HWF_1_BM_SHORT_BUF_SIZE;
-#endif /* CONFIG_MV_ETH_HWF_1_BM_SHORT_POOL != CONFIG_MV_ETH_HWF_1_BM_LONG_POOL */
-
-		break;
-#endif /* CONFIG_MV_ETH_HWF_1_BM */
-
-#ifdef CONFIG_MV_ETH_HWF_2_BM
-	case 2:
-		bmConfig->valid = 1;
-		bmConfig->longPool = CONFIG_MV_ETH_HWF_2_BM_LONG_POOL;
-		bmConfig->shortPool = CONFIG_MV_ETH_HWF_2_BM_SHORT_POOL;
-		bmConfig->longBufNum = CONFIG_MV_ETH_HWF_2_BM_LONG_BUF_NUM;
-
-#if (CONFIG_MV_ETH_HWF_2_BM_SHORT_POOL != CONFIG_MV_ETH_HWF_2_BM_LONG_POOL)
-		bmConfig->shortBufNum = CONFIG_MV_ETH_HWF_2_BM_SHORT_BUF_NUM;
-		bmConfig->shortBufSize = CONFIG_MV_ETH_HWF_2_BM_SHORT_BUF_SIZE;
-#endif /* CONFIG_MV_ETH_HWF_2_BM_SHORT_POOL != CONFIG_MV_ETH_HWF_2_BM_LONG_POOL */
-
-		break;
-#endif /* CONFIG_MV_ETH_HWF_2_BM */
-
-	default:
-		mvOsPrintf("%s: port = %d is out of range\n", __func__, port);
-		return MV_OUT_OF_RANGE;
-	}
-
-	return MV_OK;
-}
 
 static int mv_eth_hwf_pool_add(MV_BM_POOL *pBmPool, int bufNum)
 {
@@ -131,7 +74,7 @@ static int mv_eth_hwf_pool_add(MV_BM_POO
 }
 
 /*******************************************************************************
- * mvNetaHwfBmPoolsCfg - create BM pools used by the port for HWF only
+ * mv_eth_hwf_bm_create - create BM pools used by the port for HWF only
  *
  * INPUT:
  *       int        port	- port number
@@ -144,7 +87,8 @@ MV_STATUS mv_eth_hwf_bm_create(int port,
 {
 	static bool		isFirst = true;
 	MV_BM_POOL		*pBmPool;
-	MV_BM_CONFIG	*pBmConfig;
+	int				long_pool, short_pool;
+	int				long_buf_size, short_buf_size;
 
 	/* Check validity of the parameters */
 	if (mvNetaPortCheck(port))
@@ -153,94 +97,84 @@ MV_STATUS mv_eth_hwf_bm_create(int port,
 	/* For the first time - clean hwfBmPool array */
 	if (isFirst == true) {
 		memset(&hwfBmPool, 0, sizeof(hwfBmPool));
-		memset(&hwfBmConfig, 0, sizeof(hwfBmConfig));
-		mvBmControl(MV_START);
 		isFirst = false;
 	}
 
-	pBmConfig = &hwfBmConfig[port];
-	/* Get compile time BM pools configuration for this port */
-	if (mv_hwf_bm_config_get(port, pBmConfig) != MV_OK)
+	long_pool = mv_eth_bm_config_long_pool_get(port);
+	/* Check validity of the parameters */
+	if (mvNetaMaxCheck(long_pool,  MV_BM_POOLS))
 		return MV_FAIL;
 
 	/* For HWF Packet offset in the packet is 8 bytes */
-	pBmConfig->longBufSize = mtuPktSize + 8;
+	long_buf_size = mv_eth_bm_config_pkt_size_get(long_pool);
+	if (long_buf_size == 0)
+		long_buf_size = mtuPktSize + 8;
 
 	/* Check validity of the parameters */
-	if (mvNetaMaxCheck(pBmConfig->longPool,  MV_BM_POOLS))
+	if (long_buf_size < (mtuPktSize + 8))
 		return MV_FAIL;
 
 	/* Create long pool */
-	pBmPool = &hwfBmPool[pBmConfig->longPool];
+	pBmPool = &hwfBmPool[long_pool];
 	if (pBmPool->pVirt == NULL) {
 		/* Allocate new pool */
-		pBmPool->pVirt = mv_eth_bm_pool_create(pBmConfig->longPool, MV_BM_POOL_CAP_MAX, &pBmPool->physAddr);
+		pBmPool->pVirt = mv_eth_bm_pool_create(long_pool, MV_BM_POOL_CAP_MAX, &pBmPool->physAddr);
 		if (pBmPool->pVirt == NULL) {
 			mvOsPrintf("%s: Can't allocate %d bytes for Long pool #%d of port #%d\n",
-					__func__, MV_BM_POOL_CAP_MAX * sizeof(MV_U32), pBmConfig->longPool, port);
+					__func__, MV_BM_POOL_CAP_MAX * sizeof(MV_U32), long_pool, port);
 			return MV_OUT_OF_CPU_MEM;
 		}
-		pBmPool->pool = pBmConfig->longPool;
+		pBmPool->pool = long_pool;
 		pBmPool->capacity = MV_BM_POOL_CAP_MAX;
-		pBmPool->bufSize = pBmConfig->longBufSize;
+		pBmPool->bufSize = long_buf_size;
 	} else {
 		/* Share pool with other port - check buffer size */
-		if (pBmConfig->longBufSize > pBmPool->bufSize) {
+		if (long_buf_size > pBmPool->bufSize) {
 			/* The BM pool doesn't match the mtuPktSize */
 			mvOsPrintf("%s: longBufSize=%d is too match for the pool #%d (%d bytes)\n",
-						__func__, pBmConfig->longBufSize, pBmPool->pool, pBmPool->bufSize);
+						__func__, long_buf_size, pBmPool->pool, pBmPool->bufSize);
 			return MV_FAIL;
 		}
 	}
-	mv_eth_hwf_pool_add(pBmPool, pBmConfig->longBufNum);
+	mv_eth_hwf_pool_add(pBmPool, mv_eth_bm_config_long_buf_num_get(port));
 
 	/* Create short pool */
-	if (pBmConfig->shortPool != pBmConfig->longPool) {
-		pBmPool = &hwfBmPool[pBmConfig->shortPool];
+	short_pool = mv_eth_bm_config_short_pool_get(port);
+	short_buf_size = mv_eth_bm_config_pkt_size_get(short_pool);
+	if (short_pool != long_pool) {
+		pBmPool = &hwfBmPool[short_pool];
 		if (pBmPool->pVirt == NULL) {
 			/* Allocate new pool */
-			pBmPool->pVirt = mv_eth_bm_pool_create(pBmConfig->shortPool, MV_BM_POOL_CAP_MAX, &pBmPool->physAddr);
+			pBmPool->pVirt = mv_eth_bm_pool_create(short_pool, MV_BM_POOL_CAP_MAX, &pBmPool->physAddr);
 			if (pBmPool->pVirt == NULL) {
 				mvOsPrintf("%s: Can't allocate %d bytes for Short pool #%d of port #%d\n",
-						__func__, MV_BM_POOL_CAP_MAX * sizeof(MV_U32), pBmConfig->shortPool, port);
+						__func__, MV_BM_POOL_CAP_MAX * sizeof(MV_U32), short_pool, port);
 				return MV_OUT_OF_CPU_MEM;
 			}
-			pBmPool->pool = pBmConfig->shortPool;
+			pBmPool->pool = short_pool;
 			pBmPool->capacity = MV_BM_POOL_CAP_MAX;
-			pBmPool->bufSize = pBmConfig->shortBufSize;
+			pBmPool->bufSize = short_buf_size;
 		} else {
 			/* Share pool with other port - check buffer size */
-			if (pBmConfig->shortBufSize > pBmPool->bufSize) {
+			if (short_buf_size > pBmPool->bufSize) {
 				/* The BM pool doesn't match the mtuPktSize */
 				mvOsPrintf("%s: shortBufSize=%d is too match for the pool #%d (%d bytes)\n",
-							__func__, pBmConfig->shortBufSize, pBmPool->pool, pBmPool->bufSize);
+							__func__, short_buf_size, pBmPool->pool, pBmPool->bufSize);
 				return MV_FAIL;
 			}
 		}
 		/* Add buffers to short pool */
-		mv_eth_hwf_pool_add(pBmPool, pBmConfig->shortBufNum);
+		mv_eth_hwf_pool_add(pBmPool, mv_eth_bm_config_short_buf_num_get(port));
 	}
-	mvNetaHwfBmPoolsSet(port, pBmConfig->shortPool, pBmConfig->longPool);
+	mvNetaHwfBmPoolsSet(port, short_pool, long_pool);
 	return MV_OK;
 }
 
 void mv_hwf_bm_dump(void)
 {
 	int          i;
-	MV_BM_CONFIG *bmConfig;
 	MV_BM_POOL   *bmPool;
 
-	mvOsPrintf("HWF BM Ports compile time configuration\n");
-	mvOsPrintf("port:  longPool  shortPool  longBufNum  longBufSize  shortBufNum  shortBufSize\n");
-	for (i = 0; i < CONFIG_MV_ETH_PORTS_NUM; i++) {
-		bmConfig = &hwfBmConfig[i];
-		if (bmConfig->valid)
-			mvOsPrintf("  %2d:   %4d       %4d        %4d        %4d        %4d         %4d\n",
-					i, bmConfig->longPool, bmConfig->shortPool, bmConfig->longBufNum, bmConfig->longBufSize,
-					bmConfig->shortBufNum, bmConfig->shortBufSize);
-	}
-	mvOsPrintf("\n");
-
 	mvOsPrintf("HWF BM Pools configuration\n");
 	mvOsPrintf("pool:    capacity    bufSize    bufNum      virtPtr       physAddr\n");
 	for (i = 0; i < MV_BM_POOLS; i++) {
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/hwf/hwf_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/hwf/hwf_sysfs.c
@@ -39,7 +39,10 @@ static ssize_t hwf_help(char *buf)
 {
 	int off = 0;
 
+	off += mvOsSPrintf(buf+off, "cat                      help    - print this help\n");
+#ifndef CONFIG_MV_ETH_BM_CPU
 	off += mvOsSPrintf(buf+off, "cat                      bm    - print HWF BM information\n");
+#endif
 	off += mvOsSPrintf(buf+off, "echo rxp p txp         > regs  - print HWF registers of port <p>\n");
 	off += mvOsSPrintf(buf+off, "echo rxp p txp         > cntrs - print HWF counters of port <p>\n");
 	off += mvOsSPrintf(buf+off, "echo rxp p txp txq en  > en    - enable HWF from <rxp> to specific <txq>\n");
@@ -58,8 +61,10 @@ static ssize_t hwf_show(struct device *d
 
 	if (!strcmp(name, "help"))
 		return hwf_help(buf);
+#ifndef CONFIG_MV_ETH_BM_CPU
 	else if (!strcmp(name, "bm"))
 		mv_hwf_bm_dump();
+#endif /* CONFIG_MV_ETH_BM_CPU */
 
 	return 0;
 }
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/Makefile
@@ -9,9 +9,16 @@ ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
 	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
 endif
 
-obj-$(CONFIG_MV_ETHERNET) += mv_netdev.o mv_ethernet.o mv_eth_sysfs.o
-obj-$(CONFIG_MV_ETH_PROC) += mv_eth_proc.o
-obj-$(CONFIG_MV_PON)      += mv_pon_sysfs.o
-obj-$(CONFIG_MV_ETH_SWITCH) +=  mv_eth_switch.o
-obj-$(CONFIG_MV_ETH_TOOL) += mv_eth_tool.o
+ifeq ($(CONFIG_MV_ETH_NFP_LIB),y)
+	obj-$(CONFIG_MV_ETHERNET) += mv_netdev.o mv_ethernet.o mv_eth_sysfs.o
+	obj-$(CONFIG_MV_PON)      += mv_pon_sysfs.o
+	obj-$(CONFIG_MV_ETH_SWITCH) +=  mv_eth_switch.o
+	obj-$(CONFIG_MV_ETH_TOOL) += mv_eth_tool.o
+	obj-y += ../nfplib.a
+else
+	obj-$(CONFIG_MV_ETHERNET) += mv_netdev.o mv_ethernet.o mv_eth_sysfs.o
+	obj-$(CONFIG_MV_PON)      += mv_pon_sysfs.o
+	obj-$(CONFIG_MV_ETH_SWITCH) +=  mv_eth_switch.o
+	obj-$(CONFIG_MV_ETH_TOOL) += mv_eth_tool.o
+endif
 
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_proc.c
+++ /dev/null
@@ -1,520 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/stddef.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/reboot.h>
-#include <linux/pci.h>
-#include <linux/kdev_t.h>
-#include <linux/major.h>
-#include <linux/console.h>
-#include <linux/delay.h>
-#include <linux/ide.h>
-#include <linux/seq_file.h>
-
-#include <asm/system.h>
-#include <asm/dma.h>
-#include <asm/io.h>
-
-#include <linux/netdevice.h>
-#include "ctrlEnv/mvCtrlEnvLib.h"
-
-#include "gbe/mvNeta.h"
-#include "pmt/mvPmt.h"
-
-#ifdef CONFIG_MV_ETH_BM
-#include "bm/mvBm.h"
-#endif
-
-#ifdef CONFIG_MV_ETH_NFP
-#include "nfp_mgr/mv_nfp_mgr.h"
-#endif
-
-#include "mv_switch.h"
-
-#include "mv_eth_proc.h"
-#include "mv_netdev.h"
-
-
-//#define MV_DEBUG
-#ifdef MV_DEBUG
-#define DP printk
-#else
-#define DP(fmt,args...)
-#endif
-
-
-/* global variables from 'regdump' */
-static struct proc_dir_entry *mv_eth_tool;
-
-static unsigned int port = 0, txp=0, q = 0, status = 0;
-static unsigned int command = 0;
-static unsigned int value = 0;
-static char name[20] = {'\0', };
-
-
-#ifndef CONFIG_MV_ETH_PNC
-void run_com_rxq_type(void)
-{
-    void* port_hndl = mvNetaPortHndlGet(port);
-
-    if(port_hndl == NULL)
-        return;
-
-    switch(value) {
-	case PT_BPDU:
-		mvNetaBpduRxq(port, q);
-		break;
-	case PT_ARP:
-		mvNetaArpRxq(port, q);
-		break;
-	case PT_TCP:
-		mvNetaTcpRxq(port, q);
-		break;
-	case PT_UDP:
-		mvNetaUdpRxq(port, q);
-		break;
-	default:
-		printk("eth proc unknown packet type: value=%d\n", value);
-    }
-}
-#endif /* CONFIG_MV_ETH_PNC */
-
-
-void run_com_stats(const char *buffer)
-{
-    int scan_count;
-
-    scan_count = sscanf(buffer, STATUS_CMD_STRING, STATUS_SCANF_LIST);
-    if( scan_count != STATUS_LIST_LEN)
-    {
-	    printk("STATUS_CMD bad format %x != %x\n", scan_count, STATUS_LIST_LEN );
-	    return;
-    }
-	printk("\n\n#########################################################################################\n\n");
-
-	switch(status) {
-		case STS_PORT:
-            mv_eth_status_print();
-            mv_eth_port_status_print(port);
-			mvNetaPortStatus(port);
-			break;
-
-        case STS_PORT_MAC:
-            mv_eth_mac_show(port);
-        	break;
-
-		case STS_PORT_TXQ:
-			mvNetaTxqShow(port, txp, q, value);
-			break;
-
-		case STS_PORT_RXQ:
-			mvNetaRxqShow(port, q, value);
-			break;
-
-		case STS_PORT_TOS_MAP:
-			mv_eth_tos_map_show(port);
-			break;
-
-		case STS_TXP_WRR:
-			mvEthTxpWrrRegs(port, txp);
-			break;
-
-		case STS_PORT_REGS:
-			mvEthRegs(port);
-			mvEthPortRegs(port);
-			break;
-
-        case STS_NETA_REGS:
-			mvNetaPortRegs(port);
-        	break;
-
-#ifdef MV_ETH_GMAC_NEW
-        case STS_GMAC_REGS:
-            mvNetaGmacRegs(port);
-            break;
-#endif /* MV_ETH_GMAC_NEW */
-
-		case STS_TXP_REGS:
-			mvNetaTxpRegs(port, txp);
-			break;
-
-   		case STS_RXQ_REGS:
-			mvNetaRxqRegs(port, q);
-			break;
-
-   		case STS_TXQ_REGS:
-			mvNetaTxqRegs(port, txp, q);
-			break;
-
-#ifdef CONFIG_MV_ETH_PMT
-		case STS_PMT_REGS:
-			mvNetaPmtRegs(port, txp);
-			break;
-#endif /* CONFIG_MV_ETH_PMT */
-
-#ifdef CONFIG_MV_ETH_PNC
-        case STS_PNC_REGS:
-        	mvNetaPncRegs();
-        	break;
-#endif /* CONFIG_MV_ETH_PNC */
-
-#ifdef CONFIG_MV_ETH_HWF
-        case STS_HWF_REGS:
-            mvNetaHwfRxpRegs(port);
-			break;
-#endif /* CONFIG_MV_ETH_HWF */
-
-#ifdef CONFIG_MV_ETH_BM
-        case STS_BM_REGS:
-        	mvBmRegs();
-        	break;
-#endif /* CONFIG_MV_ETH_BM */
-
-		case STS_PORT_MIB:
-	    	mvEthPortCounters(port, txp);
-	    	mvEthPortRmonCounters(port, txp);
-			break;
-
-		case STS_PORT_STATS:
-			printk("  PORT %d: GET ETH PORT STATISTIC\n\n", port);
-			mv_eth_port_stats_print(port);
-            break;
-
-       	case STS_SWITCH_STATS:
-#ifdef CONFIG_MV_ETH_SWITCH
-            mv_eth_switch_status_print(port);
-            printk("\n");
-#endif /* CONFIG_MV_ETH_SWITCH */
-
-#ifdef CONFIG_MV_INCLUDE_SWITCH
-   	    mv_switch_stats_print();
-#endif /* CONFIG_MV_INCLUDE_SWITCH */
-       	    break;
-
-	default:
-			printk(" Unknown status command \n");
-	}
-}
-
-int run_eth_com(const char *buffer) {
-
-    int scan_count;
-
-    scan_count = sscanf(buffer, ETH_CMD_STRING, ETH_SCANF_LIST);
-    if( scan_count != ETH_LIST_LEN) {
-	    printk("eth command bad format %x != %x\n", scan_count, ETH_LIST_LEN );
-	    return 1;
-    }
-    switch(command) {
-
-        case COM_TXDONE_Q:
-            mv_eth_ctrl_txdone(value);
-            break;
-
-#ifdef CONFIG_NET_SKB_RECYCLE
-        case COM_SKB_RECYCLE:
-            mv_eth_ctrl_recycle(value);
-            break;
-#endif /* CONFIG_NET_SKB_RECYCLE */
-
-#ifdef CONFIG_MV_ETH_NFP
-        case COM_NFP_ENABLE:
-            mv_eth_ctrl_nfp(value);
-			nfp_mgr_enable(value);
-            break;
-#endif /* CONFIG_MV_ETH_NFP */
-
-	    default:
-            printk(" Unknown ETH command \n");
-    }
-    return 0;
-}
-
-/* NetDev commands */
-int run_netdev_cmd(const char *buffer) {
-    int 			    scan_count;
-	struct net_device* 	dev;
-
-        scan_count = sscanf(buffer, NETDEV_CMD_STRING, NETDEV_SCANF_LIST);
-
-        if( scan_count != NETDEV_LIST_LEN) {
-                printk("netdev command bad format %x != %x\n", scan_count, NETDEV_LIST_LEN );
-                return 1;
-        }
-
-        switch(command) {
-
-		case COM_TX_NOQUEUE:
-		    dev = dev_get_by_name(&init_net, name);
-                    if(dev != NULL)
-                    {
-			mv_eth_set_noqueue(dev, value);
-			dev_put(dev);
-		    }
-		    break;
-
-                case COM_NETDEV_STS:
-                    dev = dev_get_by_name(&init_net, name);
-                    if(dev != NULL)
-                    {
-			            mv_eth_netdev_print(dev);
-                        dev_put(dev);
-                    }
-                    break;
-
-#ifdef CONFIG_MV_ETH_SWITCH
-
-                case COM_NETDEV_PORT_ADD:
-                        dev = dev_get_by_name(&init_net, name);
-                        if(dev != NULL)
-                        {
-                            mv_eth_switch_port_add(dev, value);
-                            dev_put(dev);
-                        }
-                        break;
-
-                case COM_NETDEV_PORT_DEL:
-			dev = dev_get_by_name(&init_net, name);
-			if(dev != NULL)
-                        {
-                            mv_eth_switch_port_del(dev, value);
-                            dev_put(dev);
-                        }
-                        break;
-
-#endif /* CONFIG_MV_ETH_SWITCH */
-
-                default:
-                        printk(" Unknown netdev command \n");
-        }
-        return 0;
-}
-
-/* Giga Port commands */
-int run_port_com(const char *buffer) {
-
-	int scan_count;
-    void*   port_hndl;
-
-	scan_count = sscanf(buffer, PORT_CMD_STRING, PORT_SCANF_LIST);
-
-	if( scan_count != PORT_LIST_LEN) {
-		printk("eth port command bad format %x != %x\n", scan_count, PORT_LIST_LEN );
-		return 1;
-	}
-    port_hndl = mvNetaPortHndlGet(port);
-    if(port_hndl == NULL)
-        return 1;
-
-    	switch(command) {
-	    case COM_TXP_BW:
-	        mvNetaTxpRateSet(port, txp, value);
-	        break;
-
-/*
-            case COM_EJP_MODE:
-                mvEthEjpModeSet(port, value);
-                break;
-*/
-  	    default:
-	        printk(" Unknown port command \n");
-    	}
-   	return 0;
-}
-
-/* Giga RX Queue commands */
-int run_port_rxq_cmd(const char *buffer) {
-
-	int scan_count;
-
-	scan_count = sscanf(buffer, RXQ_CMD_STRING, RXQ_SCANF_LIST);
-
-	if( scan_count != RXQ_LIST_LEN) {
-		printk("eth RXQ command bad format %x != %x\n", scan_count, RXQ_LIST_LEN );
-		return 1;
-	}
-
-	switch(command) {
-		case COM_RXQ_TOS_MAP:
-			mv_eth_rxq_tos_map_set(port, q, value);
-			break;
-
-		case COM_RXQ_TIME_COAL:
-			mvNetaRxqTimeCoalSet(port, q, value);
-			break;
-
-		case COM_RXQ_PKTS_COAL:
-			mvNetaRxqPktsCoalSet(port, q, value);
-			break;
-
-#ifndef CONFIG_MV_ETH_PNC
-		case COM_RXQ_TYPE:
-			run_com_rxq_type();
-			break;
-#endif /* CONFIG_MV_ETH_PNC */
-
-		default:
-			printk(" Unknown RXQ command \n");
-	}
-	return 0;
-}
-
-/* Giga TX Queue commands */
-int run_port_txq_cmd(const char *buffer) {
-
-    int scan_count;
-
-    scan_count = sscanf(buffer, TXQ_CMD_STRING, TXQ_SCANF_LIST);
-
-    if( scan_count != TXQ_LIST_LEN) {
-            printk("eth TXQ command bad format %x != %x\n", scan_count, TXQ_LIST_LEN );
-            return 1;
-    }
-
-    switch(command)
-    {
-    	case COM_TXQ_COAL:
-        		mvNetaTxDonePktsCoalSet(port, txp, q, value);
-    		break;
-
-        case COM_TXQ_TOS:
-            mv_eth_txq_tos_map_set(port, q, value);
-        	break;
-
-        case COM_TXQ_BW:
-		    mvNetaTxqRateSet(port, txp, q, value);
-		    break;
-
-	    case COM_TXQ_WRR:
-		    if(value == 0)
-			    mvNetaTxqFixPrioSet(port, txp, q);
-		    else
-			    mvNetaTxqWrrPrioSet(port, txp, q, value);
-		    break;
-
-        default:
-            printk(" Unknown TXQ command \n");
-    }
-    return 0;
-}
-
-int mv_eth_tool_write (struct file *file, const char *buffer,
-                      unsigned long count, void *data) {
-
-	sscanf(buffer, "%x", &command);
-
-	switch (command) {
-        case COM_EJP_MODE:
-		case COM_TXP_BW:
-			run_port_com(buffer);
-			break;
-
-		case COM_TXDONE_Q:
-       	case COM_SKB_RECYCLE:
-	    case COM_NFP_ENABLE:
-			run_eth_com(buffer);
-			break;
-
-		case COM_RXQ_TOS_MAP:
-		case COM_RXQ_PKTS_COAL:
-		case COM_RXQ_TIME_COAL:
-		case COM_RXQ_TYPE:
-            run_port_rxq_cmd(buffer);
-			break;
-
-		case COM_TXQ_COAL:
-		case COM_TXQ_TOS:
-		case COM_TXQ_WRR:
-		case COM_TXQ_BW:
-            run_port_txq_cmd(buffer);
-			break;
-
-		case COM_TX_NOQUEUE:
-        case COM_NETDEV_STS:
-		case COM_NETDEV_PORT_ADD:
-		case COM_NETDEV_PORT_DEL:
-            run_netdev_cmd(buffer);
-            break;
-
-   		case COM_STS:
-			run_com_stats(buffer);
-			break;
-
-		default:
-			printk("eth proc unknown command.\n");
-			break;
-	}
-	return count;
-}
-
-static int proc_calc_metrics(char *page, char **start, off_t off,
-                                 int count, int *eof, int len)
-{
-        if (len <= off+count)
-		*eof = 1;
-
-        *start = page + off;
-        len -= off;
-
-        if (len > count)
-		len = count;
-
-        if (len < 0)
-		len = 0;
-
-        return len;
-}
-
-
-
-int mv_eth_tool_read (char *page, char **start, off_t off,
-                            int count, int *eof, void *data) {
-	unsigned int len = 0;
-
-   	return proc_calc_metrics(page, start, off, count, eof, len);
-}
-
-
-
-int __init start_mv_eth_tool(void)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
-     mv_eth_tool = proc_net_create(FILE_NAME , 0666 , NULL);
-#else
-     mv_eth_tool = create_proc_entry(FILE_NAME , 0666 , init_net.proc_net);
-#endif
-  mv_eth_tool->read_proc = mv_eth_tool_read;
-  mv_eth_tool->write_proc = mv_eth_tool_write;
-  mv_eth_tool->nlink = 1;
-  return 0;
-}
-
-module_init(start_mv_eth_tool);
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_proc.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-#ifndef __mv_eth_proc
-#define __mv_eth_proc
-
-#define FILE_NAME	"mv_eth_tool"
-#define FILE_PATH	"/proc/net/"
-#define STS_FILE	"mvethtool.sts"
-
-
-#define ETH_CMD_STRING      "%2x %x"
-#define ETH_PRINTF_LIST     command, value
-#define ETH_SCANF_LIST      &command, &value
-#define ETH_LIST_LEN        2
-
-#define PORT_CMD_STRING     "%2x %2x %2x %x"
-#define PORT_PRINTF_LIST    command, port, txp, value
-#define PORT_SCANF_LIST     &command, &port, &txp, &value
-#define PORT_LIST_LEN       4
-
-#define RXQ_CMD_STRING      "%2x %2x %2x %x"
-#define RXQ_PRINTF_LIST     command, port, q, value
-#define RXQ_SCANF_LIST      &command, &port, &q, &value
-#define RXQ_LIST_LEN        4
-
-#define TXQ_CMD_STRING      "%2x %2x %2x %2x %x"
-#define TXQ_PRINTF_LIST     command, port, txp, q, value
-#define TXQ_SCANF_LIST      &command, &port, &txp, &q, &value
-#define TXQ_LIST_LEN        5
-
-#define STATUS_CMD_STRING   "%2x %2x %2x %2x %2x %x"
-#define STATUS_PRINTF_LIST  command, status, port, txp, q, value
-#define STATUS_SCANF_LIST   &command, &status, &port, &txp, &q, &value
-#define STATUS_LIST_LEN     6
-
-#define NETDEV_CMD_STRING  "%2x %s %d"
-#define NETDEV_PRINTF_LIST command, name, value
-#define NETDEV_SCANF_LIST  &command, name, &value
-#define NETDEV_LIST_LEN    3
-
-typedef enum {
-    COM_RXQ_TYPE = 0,
-    COM_RXQ_MC,
-    COM_RXQ_TIME_COAL,
-    COM_RXQ_PKTS_COAL,
-    COM_TXQ_COAL,
-    COM_TXDONE_Q,
-    COM_SKB_RECYCLE,
-    COM_EJP_MODE,
-    COM_RXQ_TOS_MAP,
-    COM_TX_NOQUEUE,
-    COM_STS,
-    COM_NFP_ENABLE,
-    COM_NETDEV_STS,
-    COM_TXP_BW,
-    COM_TXQ_WRR,
-    COM_TXQ_BW,
-    COM_NETDEV_PORT_ADD,
-    COM_NETDEV_PORT_DEL,
-    COM_TXQ_TOS,
-
-} command_t;
-
-typedef enum {
-	PT_BPDU = 0,
-	PT_ARP,
-	PT_TCP,
-	PT_UDP,
-	PT_NONE
-} packet_t;
-
-typedef enum {
-	STS_PORT = 0,
-	STS_PORT_RXQ,
-	STS_PORT_TXQ,
-	STS_TXP_WRR,
-	STS_PORT_REGS,
-	STS_PORT_MIB,
-	STS_PORT_STATS,
-    STS_PORT_MAC,
-    STS_PORT_TOS_MAP,
-    STS_SWITCH_STATS,
-    STS_NETA_REGS,
-    STS_PNC_REGS,
-    STS_BM_REGS,
-	STS_HWF_REGS,
-	STS_TXP_REGS,
-    STS_GMAC_REGS,
-    STS_RXQ_REGS,
-    STS_TXQ_REGS,
-    STS_PMT_REGS,
-
-} status_t;
-
-typedef enum {
-	DB_ROUTING = 0,
-	DB_NAT,
-} db_type_t;
-
-#endif
-
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c
@@ -47,6 +47,7 @@ disclaimer.
 #ifdef MV_INCLUDE_ETH_COMPLEX
 #include "ctrlEnv/mvCtrlEthCompLib.h"
 #endif /* MV_INCLUDE_ETH_COMPLEX */
+#include "gbe/mvNeta.h"
 
 #include "mv_switch.h"
 #include "mv_netdev.h"
@@ -54,21 +55,32 @@ disclaimer.
 extern int mv_net_devs_num;
 
 /* Example: "mv_net_config=4,(00:99:88:88:99:77,0)(00:55:44:55:66:77,1:2:3:4)(00:11:22:33:44:55,),mtu=1500" */
-static char			*net_config_str = NULL;
-struct mv_eth_switch_config     switch_net_config;
+static char			*net_config_str[CONFIG_MV_ETH_PORTS_NUM] = {NULL};
+struct mv_eth_switch_config     switch_net_config[CONFIG_MV_ETH_PORTS_NUM];
+
 static int                      mv_eth_switch_started = 0;
 unsigned int                    switch_enabled_ports = 0;
 
 /* Required to get the configuration string from the Kernel Command Line */
-int mv_eth_cmdline_config(char *s);
-__setup("mv_net_config=", mv_eth_cmdline_config);
+int mv_eth0_cmdline_config(char *s);
+__setup("mv_net_config=", mv_eth0_cmdline_config);
 
-int mv_eth_cmdline_config(char *s)
+int mv_eth0_cmdline_config(char *s)
 {
-	net_config_str = s;
+	net_config_str[MV_ETH_PORT_0] = s;
 	return 1;
 }
 
+int mv_eth1_cmdline_config(char *s);
+__setup("mv_net_config1=", mv_eth1_cmdline_config);
+
+int mv_eth1_cmdline_config(char *s)
+{
+	net_config_str[MV_ETH_PORT_1] = s;
+	return 1;
+}
+
+
 /* Local function prototypes */
 static int mv_eth_check_open_bracket(char **p_net_config)
 {
@@ -100,7 +112,7 @@ static int mv_eth_check_comma(char **p_n
 	return -EINVAL;
 }
 
-static int mv_eth_netconfig_mac_addr_get(char **p_net_config, int idx)
+static int mv_eth_netconfig_mac_addr_get(char **p_net_config, int idx, int port)
 {
 	int     num;
 	char *config_str = *p_net_config;
@@ -112,7 +124,7 @@ static int mv_eth_netconfig_mac_addr_get
 		&mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
 	if (num == MV_MAC_ADDR_SIZE) {
 		while (--num >= 0)
-			switch_net_config.mac_addr[idx][num] = (mac[num] & 0xFF);
+			switch_net_config[port].mac_addr[idx][num] = (mac[num] & 0xFF);
 
 		(*p_net_config) = config_str + 17;
 		return 0;
@@ -121,13 +133,13 @@ static int mv_eth_netconfig_mac_addr_get
 	return -EINVAL;
 }
 
-static int mv_eth_netconfig_ports_get(char **p_net_config, int idx)
+static int mv_eth_netconfig_ports_get(char **p_net_config, int idx, int port)
 {
 	char ch;
 	char *config_str = *p_net_config;
-	int  port, mask = 0, status = -EINVAL;
+	int  sw_port, mask = 0, status = -EINVAL;
 
-	/* the port list should look like this: */
+	/* the switch port list should look like this: */
 	/* example 0: )         - no ports */
 	/* example 1: 0)        - single port 0 */
 	/* example 2: 1:2:3:4)  - multiple ports */
@@ -140,12 +152,12 @@ static int mv_eth_netconfig_ports_get(ch
 			status = 0;
 			break;
 		}
-		port = mvCharToDigit(ch);
-		if (port < 0)
+		sw_port = mvCharToDigit(ch);
+		if (sw_port < 0)
 			break;
 
-		/* TBD - Check port validity */
-		mask |= (1 << port);
+		/* TBD - Check sw_port validity */
+		mask |= (1 << sw_port);
 
 		if (*config_str == ':')
 			config_str++;
@@ -153,16 +165,16 @@ static int mv_eth_netconfig_ports_get(ch
 	*p_net_config = config_str;
 
 	if (status == 0) {
-		switch_net_config.board_port_map[idx] = mask;
+		switch_net_config[port].board_port_map[idx] = mask;
 		return 0;
 	}
-	printk(KERN_ERR "Syntax error while parsing port mask from command line\n");
+	printk(KERN_ERR "Syntax error while parsing switch port mask from command line\n");
 	return -EINVAL;
 }
 
 /* the mtu value is constructed as follows: */
 /* mtu=value                                */
-static int  mv_eth_netconfig_mtu_get(char **p_net_config)
+static int  mv_eth_netconfig_mtu_get(char **p_net_config, int port)
 {
 	unsigned int mtu;
 
@@ -170,7 +182,7 @@ static int  mv_eth_netconfig_mtu_get(cha
 		*p_net_config += 4;
 		mtu = strtol(*p_net_config, p_net_config, 10);
 		if (mtu > 0) {
-			switch_net_config.mtu = mtu;
+			switch_net_config[port].mtu = mtu;
 			printk(KERN_ERR "      o MTU set to %d.\n", mtu);
 			return 0;
 		}
@@ -178,19 +190,19 @@ static int  mv_eth_netconfig_mtu_get(cha
 		return -EINVAL;
 	}
 
-	switch_net_config.mtu = 1500;
-	printk(KERN_ERR "      o Using default MTU %d\n", switch_net_config.mtu);
+	switch_net_config[port].mtu = 1500;
+	printk(KERN_ERR "      o Using default MTU %d\n", switch_net_config[port].mtu);
 	return 0;
 }
 
-static int mv_eth_netconfig_max_get(char **p_net_config)
+static int mv_eth_netconfig_max_get(char **p_net_config, int port)
 {
 	char num = **p_net_config;
 	int netdev_num;
 
 	netdev_num = mvCharToDigit(num);
 	if (netdev_num >= 0) {
-		switch_net_config.netdev_max = netdev_num;
+		switch_net_config[port].netdev_max = netdev_num;
 		(*p_net_config) += 1;
 		return 0;
 	}
@@ -198,33 +210,51 @@ static int mv_eth_netconfig_max_get(char
 	return -EINVAL;
 }
 
-int mv_eth_switch_config_get(int use_existing_config)
+int mv_eth_switch_config_get(int use_existing_config, int port)
 {
 	char *p_net_config;
 	int i = 0;
 
+	if ((port != MV_ETH_PORT_0) && (port != MV_ETH_PORT_1))	{
+		printk("%s: invalid port number %d\n", __func__, port);
+		return -EINVAL;
+	}
+
 	if (!use_existing_config) {
-		memset(&switch_net_config, 0, sizeof(switch_net_config));
+		memset(&(switch_net_config[port]), 0, sizeof((switch_net_config[port])));
 
-		if (net_config_str != NULL) {
-			printk(KERN_ERR "      o Using UBoot netconfig string\n");
-		} else {
-			printk(KERN_ERR "      o Using default netconfig string from Kconfig\n");
-			net_config_str = CONFIG_MV_ETH_SWITCH_NETCONFIG;
+		if (net_config_str[port] != NULL) {
+			printk(KERN_ERR "      o Using UBoot netconfig string for port %d\n", port);
 		}
-		printk(KERN_ERR "        net_config_str: %s\n", net_config_str);
+		else {
+			printk(KERN_ERR "      o Using default netconfig string from Kconfig for port %d\n", port);
+			if (port == MV_ETH_PORT_0)
+				net_config_str[port] = CONFIG_MV_ETH_SWITCH_NETCONFIG_0;
+			else if (port == MV_ETH_PORT_1)
+				net_config_str[port] = CONFIG_MV_ETH_SWITCH_NETCONFIG_1;
+		}
+		printk(KERN_ERR "        net_config_str[%d]: %s\n", port, net_config_str[port]);
+
+		p_net_config = net_config_str[port];
+		if (mv_eth_netconfig_max_get(&p_net_config, port))
+			return -EINVAL;
 
-		p_net_config = net_config_str;
-		if (mv_eth_netconfig_max_get(&p_net_config))
+		/* check restriction: at least one of the configuration strings must be 0 */
+		if ((net_config_str[MV_ETH_PORT_0] != NULL) &&
+		    (net_config_str[MV_ETH_PORT_1] != NULL) &&
+		    (switch_net_config[MV_ETH_PORT_0].netdev_max != 0) &&
+		    (switch_net_config[MV_ETH_PORT_1].netdev_max != 0)) {
+			printk("%s: cannot have both GbE ports using the Gateway driver, change mv_net_config\n", __func__);
 			return -EINVAL;
+		}
 
-		if (switch_net_config.netdev_max == 0)
+		if (switch_net_config[port].netdev_max == 0)
 			return 1;
 
-		if (switch_net_config.netdev_max > CONFIG_MV_ETH_SWITCH_NETDEV_NUM) {
+		if (switch_net_config[port].netdev_max > CONFIG_MV_ETH_SWITCH_NETDEV_NUM) {
 			printk(KERN_ERR "Too large number of netdevs (%d) in command line: cut to %d\n",
-				switch_net_config.netdev_max, CONFIG_MV_ETH_SWITCH_NETDEV_NUM);
-			switch_net_config.netdev_max = CONFIG_MV_ETH_SWITCH_NETDEV_NUM;
+				switch_net_config[port].netdev_max, CONFIG_MV_ETH_SWITCH_NETDEV_NUM);
+			switch_net_config[port].netdev_max = CONFIG_MV_ETH_SWITCH_NETDEV_NUM;
 		}
 
 		if (mv_eth_check_comma(&p_net_config))
@@ -234,16 +264,16 @@ int mv_eth_switch_config_get(int use_exi
 			if (mv_eth_check_open_bracket(&p_net_config))
 				return -EINVAL;
 
-			if (mv_eth_netconfig_mac_addr_get(&p_net_config, i))
+			if (mv_eth_netconfig_mac_addr_get(&p_net_config, i, port))
 				return -EINVAL;
 
 			if (mv_eth_check_comma(&p_net_config))
 				return -EINVAL;
 
-			if (mv_eth_netconfig_ports_get(&p_net_config, i))
+			if (mv_eth_netconfig_ports_get(&p_net_config, i, port))
 				return -EINVAL;
 
-			switch_net_config.netdev_cfg++;
+			switch_net_config[port].netdev_cfg++;
 
 			/* If we have a comma after the closing bracket, then interface */
 			/* definition is done.                                          */
@@ -260,11 +290,11 @@ int mv_eth_switch_config_get(int use_exi
 				return -EINVAL;
 
 		if (*p_net_config != '\0') {
-			if (mv_eth_netconfig_mtu_get(&p_net_config))
+			if (mv_eth_netconfig_mtu_get(&p_net_config, port))
 				return -EINVAL;
 		} else {
-			switch_net_config.mtu = 1500;
-			printk(KERN_ERR "      o Using default MTU %d\n", switch_net_config.mtu);
+			switch_net_config[port].mtu = 1500;
+			printk(KERN_ERR "      o Using default MTU %d\n", switch_net_config[port].mtu);
 		}
 
 		/* at this point, we have parsed up to CONFIG_MV_ETH_SWITCH_NETDEV_NUM, and the mtu value */
@@ -281,11 +311,11 @@ int mv_eth_switch_config_get(int use_exi
 		/* and mv_eth_switch_netdev_last, as well as mv_net_devs[], are valid.      */
 		for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
 			if (mv_net_devs[i] != NULL)
-				memcpy(switch_net_config.mac_addr[i - mv_eth_switch_netdev_first],
+				memcpy(switch_net_config[port].mac_addr[i - mv_eth_switch_netdev_first],
 					mv_net_devs[i]->dev_addr, MV_MAC_ADDR_SIZE);
 		}
 
-		if (switch_net_config.netdev_max == 0)
+		if (switch_net_config[port].netdev_max == 0)
 			return 1;
 	}
 
@@ -385,18 +415,10 @@ int     mv_eth_switch_change_mtu(struct
 	int i;
 	struct eth_port *priv = MV_ETH_PRIV(dev);
 
-	if (netif_running(dev)) {
-		printk(KERN_ERR "mv_eth_switch does not support changing MTU for active interfaces.\n");
-		return -EPERM;
-	}
-
-	/* check mtu - can't change mtu if there is a gateway interface that */
-	/* is currently up and has a different mtu */
+	/* All gateway interfaces must be down before changing MTU */
 	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL)	 &&
-		    (mv_net_devs[i]->mtu != mtu) &&
-		    (netif_running(mv_net_devs[i]))) {
-			printk(KERN_ERR "All gateway devices must have same MTU\n");
+		if ((mv_net_devs[i] != NULL) && (netif_running(mv_net_devs[i]))) {
+			printk(KERN_ERR "All gateway interfaces must be down before changing MTU. %s is not down\n", mv_net_devs[i]->name);
 			return -EPERM;
 		}
 	}
@@ -404,26 +426,21 @@ int     mv_eth_switch_change_mtu(struct
 	if (dev->mtu != mtu) {
 		int old_mtu = dev->mtu;
 
-		/* stop tx/rx activity, mask all interrupts, relese skb in rings,*/
-		mv_eth_stop_internals(priv);
-
-		if (mv_eth_change_mtu_internals(dev, mtu) == -1)
+		mtu = mv_eth_check_mtu_valid(dev, mtu);
+		if (mtu < 0)
 			return -EPERM;
 
-		/* fill rx buffers, start rx/tx activity, set coalescing */
-		if (mv_eth_start_internals(priv, dev->mtu) != 0) {
-			printk(KERN_ERR "%s: start internals failed\n", dev->name);
+		if (mv_eth_change_mtu_internals(dev, mtu))
 			return -EPERM;
-		}
 
 		printk(KERN_NOTICE "%s: change mtu %d (pkt-size %d) to %d (pkt-size %d)\n",
 			dev->name, old_mtu, RX_PKT_SIZE(old_mtu),
 			dev->mtu, RX_PKT_SIZE(dev->mtu));
 	}
 
-	if (switch_net_config.mtu != mtu) {
+	if (switch_net_config[priv->port].mtu != mtu) {
 		mv_switch_jumbo_mode_set(RX_PKT_SIZE(mtu));
-		switch_net_config.mtu = mtu;
+		switch_net_config[priv->port].mtu = mtu;
 	}
 
 	return 0;
@@ -434,9 +451,9 @@ int    mv_eth_switch_start(struct net_de
 	struct eth_port	*priv = MV_ETH_PRIV(dev);
 	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
 	unsigned char broadcast[MV_MAC_ADDR_SIZE] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	int i, cpu;
+	int i;
 
-	/* check mtu */
+	/* Check that MTU value is identical for all gateway interfaces */
 	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
 		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i]->mtu != dev->mtu)) {
 			printk(KERN_ERR "All gateway devices must have same MTU\n");
@@ -459,21 +476,20 @@ int    mv_eth_switch_start(struct net_de
 #endif /* CONFIG_MV_ETH_SWITCH_LINK */
 
 	if (mv_eth_switch_started == 0)	{
-		/* enable polling on the port, must be used after netif_poll_disable */
-		for_each_possible_cpu(cpu)
-			napi_enable(&priv->napi[cpu]);
-
 		/* fill rx buffers, start rx/tx activity, set coalescing */
 		if (mv_eth_start_internals(priv, dev->mtu) != 0) {
 			printk(KERN_ERR "%s: start internals failed\n", dev->name);
 			goto error;
 		}
 
+		/* enable polling on the port, must be used after netif_poll_disable */
+		napi_enable(priv->napiGroup[CPU_GROUP_DEF]);
+
 		/* connect to port interrupt line */
 		if (request_irq(dev->irq, mv_eth_isr, IRQF_DISABLED|IRQF_SAMPLE_RANDOM, "mv_eth", priv)) {
 			printk(KERN_ERR "cannot request irq %d for %s port %d\n",
 				dev->irq, dev->name, priv->port);
-			dev->irq = 0;
+			napi_disable(priv->napiGroup[CPU_GROUP_DEF]);
 			goto error;
 		}
 
@@ -501,7 +517,6 @@ error:
 
 int     mv_eth_switch_stop(struct net_device *dev)
 {
-	int cpu;
 	struct eth_port *priv = MV_ETH_PRIV(dev);
 	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
 
@@ -527,8 +542,7 @@ int     mv_eth_switch_stop(struct net_de
 		/* first make sure that the port finished its Rx polling - see tg3 */
 		/* otherwise it may cause issue in SMP, one CPU is here and the other is doing the polling */
 		/* and both of it are messing with the descriptors rings!! */
-		for_each_possible_cpu(cpu)
-			napi_disable(&priv->napi[cpu]);
+		napi_disable(priv->napiGroup[CPU_GROUP_DEF]);
 
 		/* stop tx/rx activity, mask all interrupts, relese skb in rings,*/
 		mv_eth_stop_internals(priv);
@@ -648,6 +662,7 @@ void mv_eth_switch_update_link(unsigned
 int     mv_eth_switch_port_add(struct net_device *dev, int port)
 {
 	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
+	struct eth_port	*priv = MV_ETH_PRIV(dev);
 	int i, switch_port, err = 0;
 
 	if (dev_priv == NULL) {
@@ -676,7 +691,7 @@ int     mv_eth_switch_port_add(struct ne
 	dev_priv->port_map |= (1 << switch_port);
 	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
 		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i] == dev))
-			switch_net_config.board_port_map[i - mv_eth_switch_netdev_first] |= (1 << switch_port);
+			switch_net_config[priv->port].board_port_map[i - mv_eth_switch_netdev_first] |= (1 << switch_port);
 	}
 	switch_enabled_ports |= (1 << switch_port);
 	dev_priv->tx_vlan_mh = cpu_to_be16((MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id) << 12) | dev_priv->port_map);
@@ -691,6 +706,7 @@ int     mv_eth_switch_port_add(struct ne
 int     mv_eth_switch_port_del(struct net_device *dev, int port)
 {
 	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
+	struct eth_port	*priv = MV_ETH_PRIV(dev);
 	int i, switch_port, err = 0;
 
 	if (dev_priv == NULL) {
@@ -724,7 +740,7 @@ int     mv_eth_switch_port_del(struct ne
 	dev_priv->port_map &= ~(1 << switch_port);
 	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
 		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i] == dev))
-			switch_net_config.board_port_map[i - mv_eth_switch_netdev_first] &= ~(1 << switch_port);
+			switch_net_config[priv->port].board_port_map[i - mv_eth_switch_netdev_first] &= ~(1 << switch_port);
 	}
 	dev_priv->link_map &= ~(1 << switch_port);
 	switch_enabled_ports &= ~(1 << switch_port);
@@ -747,12 +763,12 @@ void    mv_eth_switch_status_print(int p
 		printk(KERN_ERR "ethPort=%d: mv_eth_switch status - pp=%p, flags=0x%lx\n", port, pp, pp->flags);
 
 		printk(KERN_ERR "mtu=%d, netdev_max=%d, netdev_cfg=%d, first=%d, last=%d\n",
-			switch_net_config.mtu, switch_net_config.netdev_max, switch_net_config.netdev_cfg,
+			switch_net_config[port].mtu, switch_net_config[port].netdev_max, switch_net_config[port].netdev_cfg,
 			mv_eth_switch_netdev_first, mv_eth_switch_netdev_last);
 
-		for (i = 0; i < switch_net_config.netdev_cfg; i++) {
+		for (i = 0; i < switch_net_config[port].netdev_cfg; i++) {
 			printk(KERN_ERR "MAC="MV_MACQUAD_FMT", board_port_map=0x%x\n",
-				MV_MACQUAD(switch_net_config.mac_addr[i]), switch_net_config.board_port_map[i]);
+				MV_MACQUAD(switch_net_config[port].mac_addr[i]), switch_net_config[port].board_port_map[i]);
 		}
 		for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
 			dev = mv_eth_netdev_by_id(i);
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
@@ -41,6 +41,9 @@ static ssize_t mv_eth_help(char *buf)
 	int off = 0;
 
 	off += sprintf(buf+off, "cat                ports           - show all ports info\n");
+#ifdef CONFIG_MV_ETH_PNC
+	off += sprintf(buf+off, "echo {0|1}         > pnc           - enable / disable PNC access\n");
+#endif /* CONFIG_MV_ETH_PNC */
 	off += sprintf(buf+off, "echo {0|1}         > skb           - enable / disable SKB recycle\n");
 	off += sprintf(buf+off, "echo p             > port          - show a port info\n");
 	off += sprintf(buf+off, "echo p             > stats         - show a port statistics\n");
@@ -64,13 +67,12 @@ static ssize_t mv_eth_help(char *buf)
 	off += sprintf(buf+off, "echo p hex         > debug         - bit0:rx, bit1:tx, bit2:isr, bit3:poll, bit4:dump\n");
 	off += sprintf(buf+off, "echo p l s         > buf_num       - set number of long <l> and short <s> buffers allocated for port <p>\n");
 	off += sprintf(buf+off, "echo p rxq tos     > rxq_tos       - set <rxq> for incoming IP packets with <tos>\n");
+	off += sprintf(buf+off, "echo p rxq prio    > rxq_vlan      - set <rxq> for incoming VLAN packets with <prio>\n");
 	off += sprintf(buf+off, "echo p rxq cpus    > rxq_cpus      - set <cpus> enable to process packets incoming to <rxq>\n");
 	off += sprintf(buf+off, "echo p rxq v       > rxq_size      - set number of descriptors <v> for <port/rxq>.\n");
 	off += sprintf(buf+off, "echo p rxq v       > rxq_pkts_coal - set RXQ interrupt coalesing. <v> - number of received packets\n");
 	off += sprintf(buf+off, "echo p rxq v       > rxq_time_coal - set RXQ interrupt coalesing. <v> - time in microseconds\n");
-#ifndef CONFIG_MV_ETH_PNC
 	off += sprintf(buf+off, "echo p rxq t       > rxq_type      - set RXQ for different packet types. t=0-bpdu, 1-arp, 2-tcp, 3-udp\n");
-#endif /* CONFIG_MV_ETH_PNC */
 	off += sprintf(buf+off, "echo p             > rx_reset      - reset RX part of the port <p>\n");
 	off += sprintf(buf+off, "echo p txp         > txp_reset     - reset TX part of the port <p/txp>\n");
 	off += sprintf(buf+off, "echo p txq tos     > txq_tos       - set <txq> for outgoing IP packets with <tos>\n");
@@ -88,7 +90,36 @@ static ssize_t mv_eth_help(char *buf)
 	return off;
 }
 
-#ifndef CONFIG_MV_ETH_PNC
+#ifdef CONFIG_MV_ETH_PNC
+int run_rxq_type(int port, int q, int t)
+{
+	void *port_hndl = mvNetaPortHndlGet(port);
+
+	if (port_hndl == NULL)
+		return 1;
+
+	if (!mv_eth_pnc_ctrl_en) {
+		printk(KERN_ERR "%s: PNC control is not supported\n", __func__);
+		return 1;
+	}
+
+	switch (t) {
+	case 1:
+		pnc_etype_arp(q);
+		break;
+	case 2:
+		pnc_ip4_tcp(q);
+		break;
+	case 3:
+		pnc_ip4_udp(q);
+		break;
+	default:
+		printk(KERN_ERR "unsupported packet type: value=%d\n", t);
+		return 1;
+	}
+	return 0;
+}
+#else
 int run_rxq_type(int port, int q, int t)
 {
 	void *port_hndl = mvNetaPortHndlGet(port);
@@ -192,6 +223,10 @@ static ssize_t mv_eth_port_store(struct
 	} else if (!strcmp(name, "gmac_regs")) {
 		mvNetaGmacRegs(p);
 #endif /* MV_ETH_GMAC_NEW */
+#ifdef CONFIG_MV_ETH_PNC
+	} else if (!strcmp(name, "pnc")) {
+		mv_eth_ctrl_pnc(p);
+#endif /* CONFIG_MV_ETH_PNC */
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -225,6 +260,8 @@ static ssize_t mv_eth_3_hex_store(struct
 		err = mv_eth_txq_tos_map_set(p, i, v);
 	} else if (!strcmp(name, "rxq_tos")) {
 		err = mv_eth_rxq_tos_map_set(p, i, v);
+	} else if (!strcmp(name, "rxq_vlan")) {
+		err = mv_eth_rxq_vlan_prio_set(p, i, v);
 	} else if (!strcmp(name, "rxq_cpus")) {
 		err = mvNetaRxqCpuMaskSet(p, i, v);
 	} else {
@@ -279,10 +316,8 @@ static ssize_t mv_eth_3_store(struct dev
 		err = mv_eth_ctrl_set_poll_rx_weight(p, i);
 	} else if (!strcmp(name, "tx_done")) {
 		mv_eth_ctrl_txdone(p);
-#ifndef CONFIG_MV_ETH_PNC
 	} else if (!strcmp(name, "rxq_type")) {
 		err = run_rxq_type(p, i, v);
-#endif /* CONFIG_MV_ETH_PNC */
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -368,6 +403,7 @@ static DEVICE_ATTR(txp_reset,   S_IWUSR,
 static DEVICE_ATTR(ejp,         S_IWUSR, mv_eth_show, mv_eth_3_store);
 static DEVICE_ATTR(buf_num,     S_IWUSR, mv_eth_show, mv_eth_3_store);
 static DEVICE_ATTR(rxq_tos,     S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
+static DEVICE_ATTR(rxq_vlan,    S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
 static DEVICE_ATTR(rxq_cpus,    S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
 static DEVICE_ATTR(txq_tos,     S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
 static DEVICE_ATTR(mh_en,       S_IWUSR, mv_eth_show, mv_eth_port_store);
@@ -392,6 +428,9 @@ static DEVICE_ATTR(gmac_regs,   S_IWUSR,
 static DEVICE_ATTR(txp_regs,    S_IWUSR, mv_eth_show, mv_eth_4_store);
 static DEVICE_ATTR(rxq_type,    S_IWUSR, mv_eth_show, mv_eth_3_store);
 static DEVICE_ATTR(tx_done,     S_IWUSR, mv_eth_show, mv_eth_3_store);
+#ifdef CONFIG_MV_ETH_PNC
+static DEVICE_ATTR(pnc,         S_IWUSR, NULL, mv_eth_port_store);
+#endif /* CONFIG_MV_ETH_PNC */
 
 static struct attribute *mv_eth_attrs[] = {
 
@@ -414,6 +453,7 @@ static struct attribute *mv_eth_attrs[]
 	&dev_attr_buf_num.attr,
 	&dev_attr_rxq_cpus.attr,
 	&dev_attr_rxq_tos.attr,
+	&dev_attr_rxq_vlan.attr,
 	&dev_attr_txq_tos.attr,
 	&dev_attr_mh_en.attr,
 	&dev_attr_mh_2B.attr,
@@ -437,6 +477,9 @@ static struct attribute *mv_eth_attrs[]
 	&dev_attr_tx_done.attr,
 	&dev_attr_help.attr,
 	&dev_attr_rx_weight.attr,
+#ifdef CONFIG_MV_ETH_PNC
+    &dev_attr_pnc.attr,
+#endif /* CONFIG_MV_ETH_PNC */
 	NULL
 };
 
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
@@ -50,7 +50,6 @@ disclaimer.
 #include "gbe/mvNeta.h"
 #include "bm/mvBm.h"
 #include "pnc/mvPnc.h"
-#include "nfp/mvNfp.h"
 
 #include "mv_switch.h"
 #include "mv_netdev.h"
@@ -60,7 +59,6 @@ disclaimer.
 
 #define MV_ETH_TOOL_AN_TIMEOUT	5000
 
-extern spinlock_t          mv_eth_mii_lock;
 
 static int isSwitch(struct eth_port *priv)
 {
@@ -301,7 +299,7 @@ int mv_eth_tool_get_regs_len(struct net_
 {
 #define MV_ETH_TOOL_REGS_LEN 32
 
-	return MV_ETH_TOOL_REGS_LEN * sizeof(uint32_t);
+	return (MV_ETH_TOOL_REGS_LEN * sizeof(uint32_t));
 }
 
 
@@ -433,7 +431,7 @@ u32 mv_eth_tool_get_link(struct net_devi
 	struct eth_port     *pp = MV_ETH_PRIV(netdev);
 	struct eth_netdev   *dev_priv = MV_DEV_PRIV(netdev);
 
-	if ((pp == NULL) || (MV_PON_PORT(pp->port))) {
+	if (pp == NULL) {
 		printk(KERN_ERR "interface %s is not supported\n", netdev->name);
 		return -EOPNOTSUPP;
 	}
@@ -443,11 +441,12 @@ u32 mv_eth_tool_get_link(struct net_devi
 			return -EOPNOTSUPP;
 		return (dev_priv->link_map != 0);
 	}
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(pp->port))
+		return mv_pon_link_status();
+#endif /* CONFIG_MV_PON */
 
-	if (mvNetaLinkIsUp(pp->port))
-		return 1;
-
-	return 0;
+	return mvNetaLinkIsUp(pp->port);
 }
 /******************************************************************************
 * mv_eth_tool_get_coalesce
@@ -465,7 +464,7 @@ int mv_eth_tool_get_coalesce(struct net_
 			     struct ethtool_coalesce *cmd)
 {
 	struct eth_port *pp = MV_ETH_PRIV(netdev);
-	/* get coal parameters only for rxq=0, txp=txq=0 !!! 
+	/* get coal parameters only for rxq=0, txp=txq=0 !!!
 	   notice that if you use ethtool to set coal, then all queues have the same value */
 	cmd->rx_coalesce_usecs = mvNetaRxqTimeCoalGet(pp->port, 0);
 	cmd->rx_max_coalesced_frames = mvNetaRxqPktsCoalGet(pp->port, 0);
@@ -763,13 +762,6 @@ void mv_eth_tool_get_strings(struct net_
 
 }
 
-/*******************************************************************************/
-int mv_eth_tool_phys_id(struct net_device *netdev, u32 data)
-{
-/*	printk("in %s \n",__FUNCTION__);*/
-	return 0;
-}
-
 /******************************************************************************
 * mv_eth_tool_get_stats_count
 * Description:
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
@@ -29,9 +29,9 @@ disclaimer.
 #include "mvCommon.h"
 #include <linux/kernel.h>
 #include <linux/version.h>
-#include <linux/interrupt.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
+#include <linux/interrupt.h>
 
 #include "mvOs.h"
 #include "dbg-trace.h"
@@ -41,6 +41,7 @@ disclaimer.
 #include "eth-phy/mvEthPhy.h"
 #include "gbe/mvNeta.h"
 #include "pnc/mvPnc.h"
+
 #include "mv_netdev.h"
 
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
@@ -66,16 +67,16 @@ static int mv_eth_start(struct net_devic
 	/* Stop the TX queue - it will be enabled upon PHY status change after link-up interrupt/timer */
 	netif_stop_queue(dev);
 
-	/* enable polling on the port, must be used after netif_poll_disable */
-	if (priv->flags & MV_ETH_F_CONNECT_LINUX) 
-			napi_enable(priv->napiGroup[CPU_GROUP_DEF]);
-
 	/* fill rx buffers, start rx/tx activity, set coalescing */
 	if (mv_eth_start_internals(priv, dev->mtu) != 0) {
 		printk(KERN_ERR "%s: start internals failed\n", dev->name);
 		goto error;
 	}
 
+	/* enable polling on the port, must be used after netif_poll_disable */
+	if (priv->flags & MV_ETH_F_CONNECT_LINUX)
+		napi_enable(priv->napiGroup[CPU_GROUP_DEF]);
+
 	if ((priv->flags & MV_ETH_F_LINK_UP) && !(priv->flags & MV_ETH_F_EXT_SWITCH)) {
 
 		if (mv_eth_ctrl_is_tx_enabled(priv)) {
@@ -97,7 +98,8 @@ static int mv_eth_start(struct net_devic
 		/* connect to port interrupt line */
 		if (request_irq(dev->irq, mv_eth_isr, (IRQF_DISABLED|IRQF_SAMPLE_RANDOM), "mv_eth", priv)) {
 			printk(KERN_ERR "cannot request irq %d for %s port %d\n", dev->irq, dev->name, priv->port);
-			dev->irq = 0;
+			if (priv->flags & MV_ETH_F_CONNECT_LINUX)
+				napi_disable(priv->napiGroup[CPU_GROUP_DEF]);
 			goto error;
 		}
 
@@ -106,13 +108,9 @@ static int mv_eth_start(struct net_devic
 
 		printk(KERN_NOTICE "%s: started\n", dev->name);
 	}
-
 	return 0;
 
 error:
-	if (dev->irq != 0)
-		free_irq(dev->irq, priv);
-
 	printk(KERN_ERR "%s: start failed\n", dev->name);
 	return -1;
 }
@@ -129,7 +127,7 @@ int mv_eth_stop(struct net_device *dev)
 
 	/* first make sure that the port finished its Rx polling - see tg3 */
 	napi_disable(priv->napiGroup[CPU_GROUP_DEF]);
-				
+
 	/* stop upper layer */
 	netif_carrier_off(dev);
 	netif_stop_queue(dev);
@@ -155,10 +153,9 @@ int mv_eth_change_mtu(struct net_device
 {
 	int old_mtu = dev->mtu;
 
-	if (mtu < 64) {
-		printk("MTU must be at least 64, change mtu failed\n");
+	mtu = mv_eth_check_mtu_valid(dev, mtu);
+	if (mtu < 0)
 		return -EINVAL;
-	}
 
 	if (!netif_running(dev)) {
 		if (mv_eth_change_mtu_internals(dev, mtu) == -1)
@@ -170,6 +167,9 @@ int mv_eth_change_mtu(struct net_device
 		return 0;
 	}
 
+	if (mv_eth_check_mtu_internals(dev, mtu))
+		goto error;
+
 	if (mv_eth_stop(dev)) {
 		printk(KERN_ERR "%s: stop interface failed\n", dev->name);
 		goto error;
@@ -205,14 +205,17 @@ static int mv_eth_set_mac_addr_internals
 	u8              *mac = &(((u8 *)addr)[2]);  /* skip on first 2B (ether HW addr type) */
 	int             i;
 
-#ifdef CONFIG_MV_ETH_PNC_PARSER
-	if (pnc_mac_me(priv->port, mac, CONFIG_MV_ETH_RXQ_DEF)) {
-		printk(KERN_ERR "%s: ethSetMacAddr failed\n", dev->name);
+#ifdef CONFIG_MV_ETH_PNC
+	if (mv_eth_pnc_ctrl_en) {
+		if (pnc_mac_me(priv->port, mac, CONFIG_MV_ETH_RXQ_DEF)) {
+			printk(KERN_ERR "%s: ethSetMacAddr failed\n", dev->name);
+			return -1;
+		}
+	} else {
+		printk(KERN_ERR "%s: PNC control is disabled\n", __func__);
 		return -1;
 	}
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
-
-#ifdef CONFIG_MV_ETH_LEGACY_PARSER
+#else
 	/* remove previous address table entry */
 	if (mvNetaMacAddrSet(priv->port, dev->dev_addr, -1) != MV_OK) {
 		printk(KERN_ERR "%s: ethSetMacAddr failed\n", dev->name);
@@ -224,7 +227,7 @@ static int mv_eth_set_mac_addr_internals
 		printk(KERN_ERR "%s: ethSetMacAddr failed\n", dev->name);
 		return -1;
 	}
-#endif /* CONFIG_MV_ETH_LEGACY_PARSER */
+#endif /* CONFIG_MV_ETH_PNC */
 
 	/* set addr in the device */
 	for (i = 0; i < 6; i++)
@@ -235,7 +238,7 @@ static int mv_eth_set_mac_addr_internals
 	return 0;
 }
 
-#ifdef CONFIG_MV_ETH_PNC_PARSER
+#ifdef CONFIG_MV_ETH_PNC
 void mv_eth_set_multicast_list(struct net_device *dev)
 {
 	struct eth_port     *priv = MV_ETH_PRIV(dev);
@@ -244,6 +247,11 @@ void mv_eth_set_multicast_list(struct ne
 	printk("%s - mv_eth_set_multicast_list: flags=0x%x, mc_count=%d\n",
 		dev->name, dev->flags, dev->mc_count);
 */
+	if (!mv_eth_pnc_ctrl_en) {
+		printk(KERN_ERR "%s: PNC control is disabled\n", __func__);
+		return;
+	}
+
 	if (dev->flags & IFF_PROMISC) {
 		/* Accept all */
 		pnc_mac_me(priv->port, NULL, rxq);
@@ -290,15 +298,7 @@ void mv_eth_set_multicast_list(struct ne
 		}
 	}
 }
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
-
-#ifdef CONFIG_MV_ETH_LEGACY_PARSER
-/***********************************************************
- * eth_set_multicast_list --                             *
- *   Add multicast addresses or set promiscuous mode.      *
- *   This function should have been but was not included   *
- *   by Marvell. -bbozarth                                 *
- ***********************************************************/
+#else /* !CONFIG_MV_ETH_PNC - legacy parser */
 void mv_eth_set_multicast_list(struct net_device *dev)
 {
 	struct eth_port    *priv = MV_ETH_PRIV(dev);
@@ -348,7 +348,7 @@ void mv_eth_set_multicast_list(struct ne
 		}
 	}
 }
-#endif /* CONFIG_MV_ETH_LEGACY_PARSER */
+#endif /* CONFIG_MV_ETH_PNC */
 
 
 int     mv_eth_set_mac_addr(struct net_device *dev, void *addr)
@@ -389,19 +389,20 @@ int mv_eth_open(struct net_device *dev)
 	struct eth_port	*priv = MV_ETH_PRIV(dev);
 	int         queue = CONFIG_MV_ETH_RXQ_DEF;
 
-#ifdef CONFIG_MV_ETH_PNC_PARSER
-	if (pnc_mac_me(priv->port, dev->dev_addr, queue)) {
-		printk(KERN_ERR "%s: ethSetMacAddr failed\n", dev->name);
-		return -1;
-	}
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
-
-#ifdef CONFIG_MV_ETH_LEGACY_PARSER
+#ifdef CONFIG_MV_ETH_PNC
+	if (mv_eth_pnc_ctrl_en) {
+		if (pnc_mac_me(priv->port, dev->dev_addr, queue)) {
+			printk(KERN_ERR "%s: ethSetMacAddr failed\n", dev->name);
+			return -1;
+		}
+	} else
+		printk(KERN_ERR "%s: PNC control is disabled\n", __func__);
+#else /* Legacy parser */
 	if (mvNetaMacAddrSet(priv->port, dev->dev_addr, queue) != MV_OK) {
 		printk(KERN_ERR "%s: ethSetMacAddr failed\n", dev->name);
 		return -1;
 	}
-#endif /* CONFIG_MV_ETH_LEGACY_PARSER */
+#endif /* CONFIG_MV_ETH_PNC */
 
 	if (mv_eth_start(dev)) {
 		printk(KERN_ERR "%s: start interface failed\n", dev->name);
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -32,6 +32,7 @@ disclaimer.
 #include <linux/etherdevice.h>
 #include <linux/platform_device.h>
 #include <linux/skbuff.h>
+#include <linux/inetdevice.h>
 #include <net/ip.h>
 #include <net/ipv6.h>
 
@@ -45,22 +46,19 @@ disclaimer.
 #include "mvSysEthPhyApi.h"
 #include "mvSysNetaApi.h"
 
+#include "nfp_mgr/mv_nfp_mgr_if.h"
+#include "nfp/mvNfpDefs.h"
+
 #include "gbe/mvNeta.h"
 #include "bm/mvBm.h"
 #include "pnc/mvPnc.h"
 #include "pnc/mvTcam.h"
 #include "pmt/mvPmt.h"
-#include "nfp/mvNfp.h"
 
 #include "mv_switch.h"
 
-#include "nfp_mgr/mv_nfp_mgr.h"
-
 #include "mv_netdev.h"
 #include "mv_eth_tool.h"
-#ifdef CONFIG_MV_ETH_GRO
-#include <linux/inetdevice.h>
-#endif
 
 #include "cpu/mvCpuCntrs.h"
 
@@ -73,24 +71,49 @@ MV_CPU_CNTRS_EVENT	*event4 = NULL;
 MV_CPU_CNTRS_EVENT	*event5 = NULL;
 #endif /* CONFIG_MV_CPU_PERF_CNTRS */
 
-
 unsigned int ext_switch_port_mask = 0;
-spinlock_t   mv_eth_mii_lock;
+
 
 /* uncomment if you want to debug the SKB recycle feature */
 /* #define ETH_SKB_DEBUG */
 
-#ifdef CONFIG_MV_ETH_NFP
-static int mv_ctrl_nfp = CONFIG_MV_ETH_NFP_DEF;
+#ifdef CONFIG_MV_ETH_PNC
+unsigned int mv_eth_pnc_ctrl_en = 1;
 
-void mv_eth_ctrl_nfp(int en)
+int mv_eth_ctrl_pnc(int en)
 {
-	mv_ctrl_nfp = en;
+	mv_eth_pnc_ctrl_en = en;
+	return 0;
 }
+#endif /* CONFIG_MV_ETH_PNC */
+
+#ifdef CONFIG_MV_ETH_NFP
+extern int nfp_sysfs_init(void);
+
+static INLINE int mv_eth_need_fragment(MV_NFP_RESULT *res);
 
+static MV_STATUS mv_eth_nfp(struct eth_port *pp, int rxq, struct neta_rx_desc *rx_desc,
+						struct eth_pbuf *pkt, struct bm_pool *pool);
 
-static MV_STATUS mv_eth_nfp(struct eth_port *pp, struct neta_rx_desc *rx_desc, struct eth_pbuf *pkt);
-extern void nfp_port_register(int, int);
+static MV_STATUS mv_eth_nfp_tx(struct eth_pbuf *pkt, MV_NFP_RESULT *res);
+
+/* Enable NFP */
+int mv_eth_ctrl_nfp(struct net_device *dev, int en)
+{
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+
+	if (pp == NULL)
+		return 1;
+
+	if (en) {
+		pp->flags |= MV_ETH_F_NFP_EN;
+		printk(KERN_INFO "%s: NFP enabled\n", dev->name);
+	} else {
+		pp->flags &= ~MV_ETH_F_NFP_EN;
+		printk(KERN_INFO "%s: NFP disabled\n", dev->name);
+	}
+	return 0;
+}
 #endif /* CONFIG_MV_ETH_NFP */
 
 #ifdef CONFIG_NET_SKB_RECYCLE
@@ -110,6 +133,7 @@ extern u8 mvMacAddr[CONFIG_MV_ETH_PORTS_
 extern u16 mvMtu[CONFIG_MV_ETH_PORTS_NUM];
 
 extern unsigned int switch_enabled_ports;
+extern int mv_ctrl_nfp_mode;
 
 struct bm_pool mv_eth_pool[MV_ETH_BM_POOLS];
 struct eth_port **mv_eth_ports;
@@ -144,7 +168,6 @@ static void mv_eth_priv_cleanup(struct e
 static int  mv_eth_config_get(struct eth_port *pp, u8 *mac);
 static int  mv_eth_hal_init(struct eth_port *pp);
 struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac);
-void mv_eth_netdev_update(int dev_index, struct eth_port *pp);
 static void mv_eth_netdev_set_features(struct net_device *dev);
 
 static MV_STATUS mv_eth_pool_create(int pool, int capacity);
@@ -401,6 +424,20 @@ inline void mv_eth_tx_desc_flush(struct
 	mvOsCacheLineFlush(NULL, tx_desc);
 }
 
+/* Free pkt + skb pair */
+static inline void mv_eth_pkt_free(struct eth_pbuf *pkt)
+{
+	struct sk_buff *skb = (struct sk_buff *)pkt->osInfo;
+
+#ifdef CONFIG_NET_SKB_RECYCLE
+	skb->skb_recycle = NULL;
+	skb->hw_cookie = NULL;
+#endif /* CONFIG_NET_SKB_RECYCLE */
+
+	dev_kfree_skb_any(skb);
+	mvOsFree(pkt);
+}
+
 void mv_eth_ctrl_txdone(int num)
 {
 	mv_ctrl_txdone = num;
@@ -424,13 +461,9 @@ int mv_eth_ctrl_flag(int port, u32 flag,
 	else
 		clear_bit(bit_flag, &(pp->flags));
 
-	if (flag == MV_ETH_F_MH) {
+	if (flag == MV_ETH_F_MH)
 		mvNetaMhSet(pp->port, val ? MV_NETA_MH : MV_NETA_MH_NONE);
 
-#ifdef CONFIG_MV_ETH_NFP
-		mvNfpPortCapSet(pp->port, NFP_P_MH, val);
-#endif
-	}
 	return 0;
 }
 
@@ -465,6 +498,64 @@ int mv_eth_ctrl_port_buf_num_set(int por
 	return 0;
 }
 
+#ifdef CONFIG_MV_ETH_BM
+/* Set pkt_size for the pool. Check that pool not in use (all ports are stopped) */
+/* Free all buffers from the pool */
+/* Detach the pool from all ports */
+int mv_eth_ctrl_pool_size_set(int pool, int pkt_size)
+{
+#ifdef CONFIG_MV_ETH_BM_CPU
+	int port;
+	struct bm_pool *ppool;
+	struct eth_port *pp;
+
+	if (mvNetaMaxCheck(pool, MV_ETH_BM_POOLS))
+		return -EINVAL;
+
+	ppool = &mv_eth_pool[pool];
+
+	for (port = 0; port < mv_eth_ports_num; port++) {
+		/* Check that all ports using this pool are stopped */
+		if (ppool->port_map & (1 << port)) {
+			pp = mv_eth_port_by_id(port);
+
+			if (pp->flags & MV_ETH_F_STARTED) {
+				printk(KERN_ERR "Port %d use pool #%d and must be stopped before change pkt_size\n",
+					port, pool);
+				return -EINVAL;
+			}
+		}
+	}
+	for (port = 0; port < mv_eth_ports_num; port++) {
+		/* Free all buffers and detach pool */
+		if (ppool->port_map & (1 << port)) {
+			pp = mv_eth_port_by_id(port);
+
+			if (ppool == pp->pool_long) {
+				mv_eth_pool_free(pool, pp->pool_long_num);
+				ppool->port_map &= ~(1 << pp->port);
+				pp->pool_long = NULL;
+			}
+			if (ppool == pp->pool_short) {
+				mv_eth_pool_free(pool, pp->pool_short_num);
+				ppool->port_map &= ~(1 << pp->port);
+				pp->pool_short = NULL;
+			}
+		}
+	}
+	ppool->pkt_size = pkt_size;
+#endif /* CONFIG_MV_ETH_BM_CPU */
+
+	mv_eth_bm_config_pkt_size_set(pool, pkt_size);
+	if (pkt_size == 0)
+		mvBmPoolBufSizeSet(pool, 0);
+	else
+		mvBmPoolBufSizeSet(pool, RX_BUF_SIZE(pkt_size));
+
+	return 0;
+}
+#endif /* CONFIG_MV_ETH_BM */
+
 int mv_eth_ctrl_set_poll_rx_weight(int port, u32 weight)
 {
 	struct eth_port *pp = mv_eth_port_by_id(port);
@@ -696,9 +787,7 @@ static const struct net_device_ops mv_et
 	.ndo_open = mv_eth_open,
 	.ndo_stop = mv_eth_stop,
 	.ndo_start_xmit = mv_eth_tx,
-#if defined(CONFIG_MV_ETH_PNC_PARSER) || defined(CONFIG_MV_ETH_LEGACY_PARSER)
 	.ndo_set_multicast_list = mv_eth_set_multicast_list,
-#endif /* CONFIG_MV_ETH_PNC_PARSER || CONFIG_MV_ETH_LEGACY_PARSER */
 	.ndo_set_mac_address = mv_eth_set_mac_addr,
 	.ndo_change_mtu = mv_eth_change_mtu,
 	.ndo_tx_timeout = mv_eth_tx_timeout,
@@ -739,6 +828,7 @@ static inline struct net_device *mv_eth_
 void mv_eth_switch_priv_update(struct net_device *netdev, int i)
 {
 	struct eth_netdev *dev_priv;
+	struct eth_port *pp = MV_ETH_PRIV(netdev);
 	int print_flag, port, switch_port;
 
 	/* Update dev_priv structure */
@@ -748,7 +838,7 @@ void mv_eth_switch_priv_update(struct ne
 
 	print_flag = 1;
 	for (port = 0; port < BOARD_ETH_SWITCH_PORT_NUM; port++) {
-		if (switch_net_config.board_port_map[i] & (1 << port)) {
+		if (switch_net_config[pp->port].board_port_map[i] & (1 << port)) {
 			if (print_flag) {
 				printk(KERN_CONT ". Interface ports: ");
 				print_flag = 0;
@@ -778,8 +868,8 @@ int mv_eth_switch_netdev_init(struct eth
 
 	switch_enabled_ports = 0;
 
-	for (i = 0; i < switch_net_config.netdev_max; i++) {
-		netdev = mv_eth_netdev_init(pp, switch_net_config.mtu, switch_net_config.mac_addr[i]);
+	for (i = 0; i < switch_net_config[pp->port].netdev_max; i++) {
+		netdev = mv_eth_netdev_init(pp, switch_net_config[pp->port].mtu, switch_net_config[pp->port].mac_addr[i]);
 		if (netdev == NULL) {
 			printk(KERN_ERR "mv_eth_switch_netdev_init: can't create netdevice\n");
 			break;
@@ -799,6 +889,10 @@ void mv_eth_link_status_print(int port)
 	MV_ETH_PORT_STATUS link;
 
 	mvNetaLinkStatus(port, &link);
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(port))
+		link.linkup = mv_pon_link_status();
+#endif /* CONFIG_MV_PON */
 
 	if (link.linkup) {
 		printk(KERN_CONT "link up");
@@ -859,15 +953,17 @@ static void mv_eth_rx_error(struct eth_p
 
 void mv_eth_skb_print(struct sk_buff *skb)
 {
-	printk(KERN_ERR "skb=%p: head=%p data=%p tail=%p end=%p\n", skb, skb->head, skb->data, skb->tail, skb->end);
-	printk(KERN_ERR "\t truesize=%d len=%d, data_len=%d mac_len=%d\n",
+	printk(KERN_ERR "skb=%p: head=%p, data=%p, tail=%p, end=%p\n", skb, skb->head, skb->data, skb->tail, skb->end);
+	printk(KERN_ERR "\t mac=%p, network=%p, transport=%p\n",
+			skb->mac_header, skb->network_header, skb->transport_header);
+	printk(KERN_ERR "\t truesize=%d, len=%d, data_len=%d, mac_len=%d\n",
 		skb->truesize, skb->len, skb->data_len, skb->mac_len);
-	printk(KERN_ERR "\t users=%d dataref=%d nr_frags=%d gso_size=%d gso_segs=%d\n",
+	printk(KERN_ERR "\t users=%d, dataref=%d, nr_frags=%d, gso_size=%d, gso_segs=%d\n",
 	       atomic_read(&skb->users), atomic_read(&skb_shinfo(skb)->dataref),
 	       skb_shinfo(skb)->nr_frags, skb_shinfo(skb)->gso_size, skb_shinfo(skb)->gso_segs);
-	printk(KERN_ERR "\t proto=%d, ip_summed=%d\n", ntohs(skb->protocol), skb->ip_summed);
+	printk(KERN_ERR "\t proto=%d, ip_summed=%d, priority=%d\n", ntohs(skb->protocol), skb->ip_summed, skb->priority);
 #ifdef CONFIG_NET_SKB_RECYCLE
-	printk(KERN_ERR "\t skb_recycle=%p hw_cookie=%p\n", skb->skb_recycle, skb->hw_cookie);
+	printk(KERN_ERR "\t skb_recycle=%p, hw_cookie=%p\n", skb->skb_recycle, skb->hw_cookie);
 #endif /* CONFIG_NET_SKB_RECYCLE */
 }
 
@@ -916,18 +1012,12 @@ void mv_eth_rx_desc_print(struct neta_rx
 		printk(KERN_CONT "DA_BC, ");
 	if (desc->pncInfo & NETA_PNC_DA_UC)
 		printk(KERN_CONT "DA_UC, ");
-	if (desc->pncInfo & NETA_PNC_IGMP)
-		printk(KERN_CONT "IGMP, ");
-	if (desc->pncInfo & NETA_PNC_SNAP)
-		printk(KERN_CONT "SNAP, ");
 	if (desc->pncInfo & NETA_PNC_VLAN)
 		printk(KERN_CONT "VLAN, ");
 	if (desc->pncInfo & NETA_PNC_PPPOE)
 		printk(KERN_CONT "PPPOE, ");
-	if (desc->pncInfo & NETA_PNC_NFP)
-		printk(KERN_CONT "NFP, ");
-	if (desc->pncInfo & NETA_PNC_SWF)
-		printk(KERN_CONT "SWF, ");
+	if (desc->pncInfo & NETA_PNC_RX_SPECIAL)
+		printk(KERN_CONT "RX_SPEC, ");
 #endif /* CONFIG_MV_ETH_PNC */
 
 	printk(KERN_CONT "\n");
@@ -946,14 +1036,13 @@ void mv_eth_tx_desc_print(struct neta_tx
 
 void mv_eth_pkt_print(struct eth_pbuf *pkt)
 {
-	printk(KERN_ERR "pkt: len=%d off=%d cmd=0x%x pool=%d "
-	       "tos=%d gpon=0x%x skb=%p pa=%lx buf=%p\n",
-	       pkt->bytes, pkt->offset, pkt->tx_cmd, pkt->pool,
-	       pkt->tos, pkt->hw_cmd, pkt->osInfo, pkt->physAddr, pkt->pBuf);
-/*
+	printk(KERN_ERR "pkt: len=%d off=%d pool=%d "
+	       "skb=%p pa=%lx buf=%p\n",
+	       pkt->bytes, pkt->offset, pkt->pool,
+	       pkt->osInfo, pkt->physAddr, pkt->pBuf);
+
 	mvDebugMemDump(pkt->pBuf + pkt->offset, 64, 1);
-	mvOsCacheInvalidate(NULL, pkt->pBuf + pkt->offset, pkt->bytes);
-*/
+	mvOsCacheInvalidate(NULL, pkt->pBuf + pkt->offset, 64);
 }
 
 static inline void mv_eth_rx_csum(struct eth_port *pp, struct neta_rx_desc *rx_desc, struct sk_buff *skb)
@@ -983,8 +1072,7 @@ inline int mv_eth_pool_put(struct bm_poo
 		MV_ETH_UNLOCK(&pool->lock, flags);
 
 		/* free pkt+skb */
-		dev_kfree_skb_any((struct sk_buff *)pkt->osInfo);
-		mvOsFree(pkt);
+		mv_eth_pkt_free(pkt);
 		return 1;
 	}
 	mvStackPush(pool->stack, (MV_U32) pkt);
@@ -1131,11 +1219,14 @@ static int mv_eth_skb_recycle(struct sk_
 
 		return 0;
 	}
+
+	/* printk(KERN_ERR "mv_eth_skb_recycle failed: pool=%d, pkt=%p, skb=%p\n", pkt->pool, pkt, skb); */
+
 	mvOsFree(pkt);
 	skb->hw_cookie = NULL;
 
 	STAT_DBG(pool->stats.skb_recycled_err++);
-	/* printk(KERN_ERR "mv_eth_skb_recycle failed: pkt=%p, skb=%p\n", pkt, skb); */
+
 	return 1;
 }
 #endif /* CONFIG_NET_SKB_RECYCLE */
@@ -1157,7 +1248,11 @@ static struct sk_buff *mv_eth_skb_alloc(
 
 #ifdef CONFIG_MV_ETH_BM_CPU
 	/* Save pkt as first 4 bytes in the buffer */
-	*((MV_U32 *) skb->head) = (MV_U32) pkt;
+#if !defined(CONFIG_MV_ETH_BE_WA)
+	*((MV_U32 *) skb->head) = MV_32BIT_LE((MV_U32)pkt);
+#else
+	*((MV_U32 *) skb->head) = (MV_U32)pkt;
+#endif /* !CONFIG_MV_ETH_BE_WA */
 	mvOsCacheLineFlush(NULL, skb->head);
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
@@ -1310,6 +1405,21 @@ static inline int mv_eth_rx(struct eth_p
 		rx_bytes = rx_desc->dataSize - (MV_ETH_CRC_SIZE + MV_ETH_MH_SIZE);
 		dev->stats.rx_bytes += rx_bytes;
 
+#ifndef CONFIG_MV_ETH_PNC
+	/* Update IP offset and IP header len in RX descriptor */
+	if (NETA_RX_L3_IS_IP4(rx_desc->status)) {
+		int ip_offset;
+
+		if ((rx_desc->status & ETH_RX_VLAN_TAGGED_FRAME_MASK))
+			ip_offset = MV_ETH_MH_SIZE + sizeof(MV_802_3_HEADER) + MV_VLAN_HLEN;
+		else
+			ip_offset = MV_ETH_MH_SIZE + sizeof(MV_802_3_HEADER);
+
+		NETA_RX_SET_IPHDR_OFFSET(rx_desc, ip_offset);
+		NETA_RX_SET_IPHDR_HDRLEN(rx_desc, 5);
+	}
+#endif /* !CONFIG_MV_ETH_PNC */
+
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 		if (pp->flags & MV_ETH_F_DBG_RX)
 			mvDebugMemDump(pkt->pBuf + pkt->offset, 64, 1);
@@ -1335,44 +1445,17 @@ static inline int mv_eth_rx(struct eth_p
 #endif /* CONFIG_MV_ETH_PNC && CONFIG_MV_ETH_RX_SPECIAL */
 
 #ifdef CONFIG_MV_ETH_NFP
-		if (mv_ctrl_nfp) {
+		if (pp->flags & MV_ETH_F_NFP_EN) {
 			MV_STATUS status;
 
 			pkt->bytes = rx_bytes + MV_ETH_MH_SIZE;
 			pkt->offset = NET_SKB_PAD;
-			pkt->tx_cmd = NETA_TX_L4_CSUM_NOT;
-			pkt->hw_cmd = 0;
 
-			status = mv_eth_nfp(pp, rx_desc, pkt);
-			if (status == MV_OK) {
-				STAT_DBG(pp->stats.rx_nfp++);
-
-				/* Packet moved to transmit - refill now */
-				if (!mv_eth_pool_bm(pool)) {
-					/* No BM, refill descriptor from rx pool */
-					pkt = mv_eth_pool_get(pool);
-					if (pkt) {
-						STAT_DBG(pp->stats.rxq_fill[rxq]++);
-						mvNetaRxDescFill(rx_desc, pkt->physAddr, (MV_U32)pkt);
-					} else {
-						/* RX resource error - RX descriptor is done but not refilled */
-						/* FIXME: remember to refill later */
-
-						printk(KERN_ERR "Alloc failed - Can't refill\n");
-						rx_filled--;
-						pp->rxq_ctrl[rxq].missed++;
-						mv_eth_add_cleanup_timer(pp);
-						break;
-					}
-				} else {
-					/* BM - no refill */
-					mvOsCacheLineInv(NULL, rx_desc);
-				}
+			status = mv_eth_nfp(pp, rxq, rx_desc, pkt, pool);
+			if (status == MV_OK)
 				continue;
-			} else if (status == MV_DROPPED) {
-				/* Refill the same buffer - ??? reset pkt and skb */
-				STAT_DBG(pp->stats.rx_nfp_drop++);
-				mv_eth_rxq_refill(pp, rxq, pkt, pool, rx_desc);
+			if (status == MV_FAIL) {
+				rx_filled--;
 				continue;
 			}
 			/* MV_TERMINATE - packet returned to slow path */
@@ -1392,8 +1475,6 @@ static inline int mv_eth_rx(struct eth_p
 
 		skb->protocol = eth_type_trans(skb, dev);
 
-		mv_eth_rx_csum(pp, rx_desc, skb);
-
 #ifdef CONFIG_NET_SKB_RECYCLE
 		if (mv_eth_is_recycle()) {
 			skb->skb_recycle = mv_eth_skb_recycle;
@@ -1402,8 +1483,11 @@ static inline int mv_eth_rx(struct eth_p
 		}
 #endif /* CONFIG_NET_SKB_RECYCLE */
 
+		if (skb)
+			mv_eth_rx_csum(pp, rx_desc, skb);
+
 #ifdef CONFIG_MV_ETH_GRO
-		if (dev->features & NETIF_F_GRO) {
+		if (skb && (dev->features & NETIF_F_GRO)) {
 			if (!(rx_status & NETA_RX_IP4_FRAG_MASK) && (NETA_RX_L4_IS_TCP(rx_status))) {
 				struct iphdr *iph = (struct iphdr *)skb->data;
 				if (iph->daddr == mv_eth_dev_ip(dev)) {
@@ -1441,28 +1525,695 @@ static inline int mv_eth_rx(struct eth_p
 	return rx_done;
 }
 
+#ifdef CONFIG_MV_ETH_NFP_EXT
+static void nfp_skb_destructor(struct sk_buff *skb)
+{
+	consume_skb(skb_shinfo(skb)->destructor_arg);
+}
+
+static int nfp_ext_tx_fragment(struct net_device *dev, struct sk_buff *skb, MV_NFP_RESULT *res)
+{
+	unsigned int      dlen, doff, error, flen, fsize, l, max_dlen, max_plen;
+	unsigned int      hdrlen, offset;
+	struct iphdr      *ip, *nip;
+	struct sk_buff    *new;
+	struct page       *page;
+	int               mac_header_len;
+	MV_IP_HEADER_INFO *pIpInfo = &res->ipInfo;
+
+	max_plen = dev->mtu + dev->hard_header_len;
+
+	SKB_LINEAR_ASSERT(skb);
+
+	mac_header_len = (pIpInfo->ipOffset - res->shift);
+	ip = (struct iphdr *)(skb->data + mac_header_len);
+
+	hdrlen = mac_header_len + res->ipInfo.ipHdrLen;
+
+	doff = hdrlen;
+	dlen = skb_headlen(skb) - hdrlen;
+	offset = ntohs(ip->frag_off) & IP_OFFSET;
+	max_dlen = (max_plen - hdrlen) & ~0x07;
+
+	do {
+		new = dev_alloc_skb(hdrlen);
+		if (!new)
+			break;
+
+		/* Setup new packet metadata */
+		new->protocol = IPPROTO_IP;
+		new->ip_summed = CHECKSUM_PARTIAL;
+		skb_set_network_header(new, mac_header_len);
+
+		/* Copy original IP header */
+		memcpy(skb_put(new, hdrlen), skb->data, hdrlen);
+
+		/* Append data portion */
+		fsize = flen = min(max_dlen, dlen);
+
+		skb_get(skb);
+		skb_shinfo(new)->destructor_arg = skb;
+		new->destructor = nfp_skb_destructor;
+
+		while (fsize) {
+			l = PAGE_SIZE - ((unsigned long)(skb->data + doff) & ~PAGE_MASK);
+			if (l > fsize)
+				l = fsize;
+
+			page = virt_to_page(skb->data + doff);
+			get_page(page);
+			skb_add_rx_frag(new, skb_shinfo(new)->nr_frags, page,
+					(unsigned long)(skb->data + doff) &
+								~PAGE_MASK, l);
+			dlen -= l;
+			doff += l;
+			fsize -= l;
+		}
+
+		/* Fixup IP header */
+		nip = ip_hdr(new);
+		nip->tot_len = htons((4 * ip->ihl) + flen);
+		nip->frag_off = htons(offset |
+				(dlen ? IP_MF : (IP_MF & ntohs(ip->frag_off))));
+
+		/* if it was PPPoE, update the PPPoE payload fields
+		adapted from  mv_eth_frag_build_hdr_desc */
+		if ((*((char *)nip - MV_PPPOE_HDR_SIZE - 1) == 0x64) &&
+			(*((char *)nip - MV_PPPOE_HDR_SIZE - 2) == 0x88)) {
+			PPPoE_HEADER *pPPPNew = (PPPoE_HEADER *)((char *)nip - MV_PPPOE_HDR_SIZE);
+			pPPPNew->len = htons(flen + 4*ip->ihl + MV_PPP_HDR_SIZE);
+	    }
+
+		offset += flen / 8;
+
+		/* Recalculate IP checksum */
+		new->ip_summed = CHECKSUM_NONE;
+		nip->check = 0;
+		nip->check = ip_fast_csum(nip, nip->ihl);
+
+		/* TX packet */
+		error = dev->netdev_ops->ndo_start_xmit(new, dev);
+		if (error)
+			break;
+	} while (dlen);
+
+	if (!new)
+		return -ENOMEM;
+
+	if (error) {
+		consume_skb(new);
+		return error;
+	}
+
+	/* We are no longer use original skb */
+	consume_skb(skb);
+	return 0;
+}
+
+static int mv_eth_nfp_ext_tx(struct eth_port *pp, struct eth_pbuf *pkt, MV_NFP_RESULT *res)
+{
+	struct sk_buff *skb;
+	struct net_device *dev = (struct net_device *)res->dev;
+
+	/* prepare SKB for transmit */
+	skb = (struct sk_buff *)(pkt->osInfo);
+
+	skb->data += res->shift;
+	skb->tail = skb->data + pkt->bytes ;
+	skb->len = pkt->bytes;
+
+	skb_reset_mac_header(skb);
+	skb_reset_network_header(skb);
+
+	if (res->flags & MV_NFP_RES_IP_INFO_VALID) {
+
+		if (res->ipInfo.family == MV_INET) {
+			struct iphdr *iph = (struct iphdr *)res->ipInfo.ip_hdr.ip4;
+
+			if (mv_eth_need_fragment(res))
+				return nfp_ext_tx_fragment(dev, skb, res);
+
+			/* Recalculate IP checksum for IPv4 if necessary */
+			skb->ip_summed = CHECKSUM_NONE;
+			iph->check = 0;
+			iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
+		}
+		skb_set_network_header(skb, res->ipInfo.ipOffset - res->shift);
+	}
+
+	if (pp) {
+		/* ingress port is GBE */
+#ifdef ETH_SKB_DEBUG
+		mv_eth_skb_check(skb);
+#endif /* ETH_SKB_DEBUG */
+
+#ifdef CONFIG_NET_SKB_RECYCLE
+		if (mv_eth_is_recycle()) {
+			skb->skb_recycle = mv_eth_skb_recycle;
+			skb->hw_cookie = pkt;
+		}
+#endif /* CONFIG_NET_SKB_RECYCLE */
+	}
+	return dev->netdev_ops->ndo_start_xmit(skb, dev);
+}
+
+
+static MV_STATUS _build_from_pkt_info(MV_EXT_PKT_INFO *pktInfo, struct neta_rx_desc *rxd)
+{
+	if (pktInfo->flags & MV_EXT_VLAN_EXIST_MASK)
+		NETA_RX_SET_VLAN(rxd);
+
+	if (pktInfo->flags & MV_EXT_PPP_EXIST_MASK)
+		NETA_RX_SET_PPPOE(rxd);
+
+	if (pktInfo->l3_type == ETH_P_IP)
+		NETA_RX_L3_SET_IP4(rxd);
+	else if (pktInfo->l3_type == ETH_P_IPV6)
+		NETA_RX_L3_SET_IP6(rxd);
+	else {
+		NETA_RX_L3_SET_UN(rxd);
+		return MV_OK;
+	}
+
+	if (pktInfo->flags & MV_EXT_IP_FRAG_MASK)
+		NETA_RX_IP_SET_FRAG(rxd);
+
+
+	if (!pktInfo->l3_offset || !pktInfo->l3_hdrlen)
+		return -1;
+
+	NETA_RX_SET_IPHDR_OFFSET(rxd, pktInfo->l3_offset + MV_ETH_MH_SIZE);
+	NETA_RX_SET_IPHDR_HDRLEN(rxd, (pktInfo->l3_hdrlen >> 2));
+
+	if ((pktInfo->flags & MV_EXT_L3_VALID_MASK) == 0) {
+		NETA_RX_L3_SET_IP4_ERR(rxd);
+		return MV_OK;
+	}
+
+	switch (pktInfo->l4_proto) {
+	case IPPROTO_TCP:
+		NETA_RX_L4_SET_TCP(rxd);
+		break;
+
+	case IPPROTO_UDP:
+		NETA_RX_L4_SET_UDP(rxd);
+		break;
+
+	default:
+		NETA_RX_L4_SET_OTHER(rxd);
+		break;
+	}
+
+	if (pktInfo->flags & MV_EXT_L4_VALID_MASK)
+		NETA_RX_L4_CSUM_SET_OK(rxd);
+
+	return MV_OK;
+}
+
+
+static MV_STATUS complete_desc_build_ipv4(int ofs, struct iphdr *iph, struct sk_buff *skb, struct neta_rx_desc *rxd)
+{
+	int l4_proto = 0;
+	int hdrlen;
+	int tmp;
+
+	NETA_RX_L3_SET_IP4(rxd);
+	hdrlen = iph->ihl << 2;
+	NETA_RX_SET_IPHDR_HDRLEN(rxd, iph->ihl);
+
+	if (ip_fast_csum((unsigned char *)iph, iph->ihl)) {
+		NETA_RX_L3_SET_IP4_ERR(rxd);
+		return MV_OK;
+	}
+
+	switch ((l4_proto = iph->protocol)) {
+	case IPPROTO_TCP:
+		NETA_RX_L4_SET_TCP(rxd);
+		break;
+	case IPPROTO_UDP:
+		NETA_RX_L4_SET_UDP(rxd);
+		break;
+	default:
+		NETA_RX_L4_SET_OTHER(rxd);
+		l4_proto = 0;
+		break;
+	}
+
+	tmp = ntohs(iph->frag_off);
+	if ((tmp & IP_MF) != 0 || (tmp & IP_OFFSET) != 0) {
+		NETA_RX_IP_SET_FRAG(rxd);
+		return MV_OK; /* cannot checksum fragmented */
+	}
+
+	if (!l4_proto)
+		return MV_OK; /* can't proceed without l4_proto in {UDP, TCP} */
+
+	if (skb->ip_summed == CHECKSUM_UNNECESSARY) {
+		NETA_RX_L4_CSUM_SET_OK(rxd);
+		return MV_OK;
+	}
+
+	if (l4_proto == IPPROTO_UDP) {
+		struct udphdr *uh = (struct udphdr *)((char *)iph + hdrlen);
+
+		if (uh->check == 0)
+			NETA_RX_L4_CSUM_SET_OK(rxd);
+	}
+
+	/* Complete checksum with pseudo header */
+	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+		if (!csum_tcpudp_magic(iph->saddr, iph->daddr, skb->len - hdrlen - ofs,
+			       l4_proto, skb->csum)) {
+			NETA_RX_L4_CSUM_SET_OK(rxd);
+			return MV_OK;
+		}
+	}
+
+	return MV_OK;
+}
+
+static MV_STATUS complete_desc_build_ipv6(int ofs, struct sk_buff *skb, struct neta_rx_desc *rxd)
+{
+	struct ipv6hdr *ip6h;
+	int l4_proto = 0;
+	int hdrlen;
+	__u8 nexthdr;
+
+	NETA_RX_L3_SET_IP6(rxd);
+
+	hdrlen = sizeof(struct ipv6hdr);
+	NETA_RX_SET_IPHDR_HDRLEN(rxd, (hdrlen >> 2));
+
+	ip6h = (struct ipv6hdr *)(skb->data + ofs);
+
+	nexthdr = ip6h->nexthdr;
+
+	/* No support for extension headers. Only TCP or UDP */
+	if (nexthdr == NEXTHDR_TCP) {
+		l4_proto = IPPROTO_TCP;
+		NETA_RX_L4_SET_TCP(rxd);
+	} else if (nexthdr == NEXTHDR_UDP) {
+		l4_proto = IPPROTO_UDP;
+		NETA_RX_L4_SET_UDP(rxd);
+	} else {
+		NETA_RX_L4_SET_OTHER(rxd);
+		return MV_OK;
+	}
+
+	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+		if (!csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr, skb->len,
+				      l4_proto , skb->csum)) {
+			NETA_RX_L4_CSUM_SET_OK(rxd);
+			return MV_OK;
+		}
+	}
+
+	return MV_OK;
+}
+
+
+static MV_STATUS mv_nfp_rx_desc_build(struct sk_buff *skb, MV_EXT_PKT_INFO *pktInfo, struct neta_rx_desc *rxd)
+{
+	struct iphdr *iph;
+	int l3_proto = 0;
+	int ofs = 0;
+	MV_U16 tmp;
+
+	rxd->status = 0;
+	rxd->pncInfo = 0;
+
+	if (pktInfo)
+		return _build_from_pkt_info(pktInfo, rxd);
+
+	tmp = ntohs(skb->protocol);
+ ll:
+	switch (tmp) {
+	case ETH_P_IP:
+	case ETH_P_IPV6:
+		l3_proto = tmp;
+		break;
+
+	case ETH_P_PPP_SES:
+		NETA_RX_SET_PPPOE(rxd);
+		ofs += MV_PPPOE_HDR_SIZE;
+		switch (tmp = ntohs(*((MV_U16 *)&skb->data[ofs - 2]))) {
+		case 0x0021:
+			l3_proto = ETH_P_IP;
+			break;
+		case 0x0057:
+			l3_proto = ETH_P_IPV6;
+			break;
+		default:
+			goto non_ip;
+		}
+		break;
+
+	case ETH_P_8021Q:
+		/* Don't support double VLAN for now */
+		if (NETA_RX_IS_VLAN(rxd))
+			goto non_ip;
+
+		NETA_RX_SET_VLAN(rxd);
+		ofs = MV_VLAN_HLEN;
+
+		tmp = ntohs(*((MV_U16 *)&skb->data[2]));
+			goto ll;
+
+	default:
+	  goto non_ip;
+	}
+
+	NETA_RX_SET_IPHDR_OFFSET(rxd, ETH_HLEN + MV_ETH_MH_SIZE + ofs);
+
+	iph = (struct iphdr *)(skb->data + ofs);
+
+	if (l3_proto == ETH_P_IP)
+		return complete_desc_build_ipv4(ofs, iph, skb, rxd);
+
+	return complete_desc_build_ipv6(ofs, skb, rxd);
+
+non_ip:
+	 NETA_RX_L3_SET_UN(rxd);
+	 return MV_OK;
+}
+
+void mv_eth_ext_pkt_info_print(MV_EXT_PKT_INFO *pktInfo)
+{
+	if (pktInfo == NULL)
+		return;
+
+	if (pktInfo->flags & MV_EXT_VLAN_EXIST_MASK)
+		printk(KERN_INFO "VLAN");
+
+	if (pktInfo->flags & MV_EXT_PPP_EXIST_MASK)
+		printk(KERN_INFO " PPPoE");
+
+	if (pktInfo->l3_type == ETH_P_IP)
+		printk(KERN_INFO " ipv4");
+	else if (pktInfo->l3_type == ETH_P_IPV6)
+		printk(KERN_INFO " ipv6");
+	else
+		printk(KERN_INFO " non-ip");
+
+	if (pktInfo->flags & MV_EXT_IP_FRAG_MASK)
+		printk(KERN_INFO " FRAG");
+
+	if (pktInfo->flags & MV_EXT_L3_VALID_MASK)
+		printk(KERN_INFO " L3CSUM_OK");
+
+	printk(" offset=%d, hdrlen=%d", pktInfo->l3_offset, pktInfo->l3_hdrlen);
+
+	if (pktInfo->l4_proto == IPPROTO_TCP)
+		printk(KERN_INFO " TCP");
+	else if (pktInfo->l4_proto == IPPROTO_UDP)
+		printk(KERN_INFO " UDP");
+
+	if (pktInfo->flags & MV_EXT_L4_VALID_MASK)
+		printk(KERN_INFO " L4CSUM_OK");
+
+	printk(KERN_INFO "\n");
+}
+
+
+/* Return values:   0 - packet successfully processed by NFP (transmitted or dropped) */
+/*                  1 - packet can't be processed by NFP  */
+/*                  2 - skb is not valid for NFP (not enough headroom or nonlinear) */
+/*                  3 - not enough info in pktInfo   */
+int mv_eth_nfp_ext(struct net_device *dev, struct sk_buff *skb, MV_EXT_PKT_INFO *pktInfo)
+{
+	MV_STATUS           status;
+	MV_NFP_RESULT       res;
+	struct neta_rx_desc rx_desc;
+	struct eth_pbuf     pkt;
+	int                 port, err = 1;
+
+#define NEEDED_HEADROOM (MV_PPPOE_HDR_SIZE + MV_VLAN_HLEN)
+
+	/* Check that NFP is eanbled */
+	if (mv_ctrl_nfp_mode == 0)
+		return 1;
+
+	/* Check if external interface is mapped to NFP */
+	status = mvNfpIfMapPortGet(dev->ifindex, &port);
+	if (status != MV_OK)
+	    return 1;
+
+	if (skb_is_nonlinear(skb)) {
+		printk(KERN_ERR "%s: skb=%p is nonlinear\n", __func__, skb);
+		return 2;
+	}
+
+	/* Prepare pkt structure */
+	pkt.offset = skb_headroom(skb) - (ETH_HLEN + MV_ETH_MH_SIZE);
+	if (pkt.offset < NEEDED_HEADROOM) {
+		/* we don't know at this stage if there will be added any of vlans or pppoe or both */
+		printk(KERN_ERR "%s: Possible problem: not enough headroom: %d < %d\n",
+				__func__, pkt.offset, NEEDED_HEADROOM);
+		return 2;
+	}
+
+	pkt.pBuf = skb->head;
+	pkt.bytes = skb->len + ETH_HLEN + MV_ETH_MH_SIZE;
+
+	/* Set invalid pool to prevent BM usage */
+	pkt.pool = MV_ETH_BM_POOLS;
+	pkt.physAddr = mvOsIoVirtToPhys(NULL, skb->head);
+	pkt.osInfo = (void *)skb;
+
+	/* prepare rx_desc structure */
+	status = mv_nfp_rx_desc_build(skb, pktInfo,  &rx_desc);
+	if (status != MV_OK)
+		return 3;
+
+	read_lock(&nfp_lock);
+	status = mvNfpRx(port, &rx_desc, &pkt, &res);
+
+	read_unlock(&nfp_lock);
+
+	if (status == MV_OK) {
+		if  (res.flags & MV_NFP_RES_NETDEV_EXT) {
+			/* EXT RX -> EXT TX */
+			mv_eth_nfp_ext_tx(NULL, &pkt, &res);
+		} else {
+			/* EXT RX -> INT TX */
+			mvOsCacheFlush(NULL, pkt.pBuf + pkt.offset, pkt.bytes);
+			status = mv_eth_nfp_tx(&pkt, &res);
+			if (status != MV_OK)
+				dev_kfree_skb_any(skb);
+		}
+		err = 0;
+	} else if (status == MV_DROPPED) {
+		dev_kfree_skb_any(skb);
+		err = 0;
+	}
+	return err;
+}
+#endif /* CONFIG_MV_ETH_NFP_EXT */
+
 #ifdef CONFIG_MV_ETH_NFP
-static MV_STATUS mv_eth_nfp_tx(struct neta_rx_desc *rx_desc, struct eth_pbuf *pkt)
+static INLINE int mv_eth_need_fragment(MV_NFP_RESULT *res)
+{
+	if (res->flags & MV_NFP_RES_IP_INFO_VALID)
+		return (res->ipInfo.ipLen > res->mtu);
+
+	return 0;
+}
+
+static inline int mv_eth_frag_build_hdr_desc(struct eth_port *priv, struct tx_queue *txq_ctrl,
+					MV_U8 *pktData, int mac_hdr_len, int ip_hdr_len,
+					     int frag_size, int left_len, int frag_offset)
+{
+	struct neta_tx_desc *tx_desc;
+	struct iphdr        *iph;
+	MV_U8               *data;
+	int                 align;
+	MV_U16              frag_ctrl;
+
+	tx_desc = mv_eth_tx_desc_get(txq_ctrl, 1);
+	if (tx_desc == NULL)
+		return -1;
+
+	txq_ctrl->txq_count++;
+
+	data = mv_eth_extra_pool_get(priv);
+	if (data == NULL)
+		return -1;
+
+	tx_desc->command = mvNetaTxqDescCsum(mac_hdr_len, MV_16BIT_BE(MV_IP_TYPE), ip_hdr_len, 0);
+	tx_desc->command |= NETA_TX_F_DESC_MASK;
+	tx_desc->dataSize = mac_hdr_len + ip_hdr_len;
+
+	txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = ((MV_ULONG)data | MV_ETH_SHADOW_EXT);
+	mv_eth_shadow_inc_put(txq_ctrl);
+
+	/* Check for IP header alignment */
+	align = 4 - (mac_hdr_len & 3);
+	data += align;
+	memcpy(data, pktData, mac_hdr_len + ip_hdr_len);
+
+	iph = (struct iphdr *)(data + mac_hdr_len);
+
+	iph->tot_len = htons(frag_size + ip_hdr_len);
+
+	/* update frag_offset and MF flag in IP header - packet can be already fragmented */
+	frag_ctrl = ntohs(iph->frag_off);
+	frag_offset += ((frag_ctrl & IP_OFFSET) << 3);
+	frag_ctrl &= ~IP_OFFSET;
+	frag_ctrl |= ((frag_offset >> 3) & IP_OFFSET);
+
+	if (((frag_ctrl & IP_MF) == 0) && (left_len != frag_size))
+		frag_ctrl |= IP_MF;
+
+	iph->frag_off = htons(frag_ctrl);
+
+	/* if it was PPPoE, update the PPPoE payload fields  */
+	if ((*((char *)iph - MV_PPPOE_HDR_SIZE - 1) == 0x64) &&
+		(*((char *)iph - MV_PPPOE_HDR_SIZE - 2) == 0x88)) {
+		PPPoE_HEADER *pPPPNew = (PPPoE_HEADER *)((char *)iph - MV_PPPOE_HDR_SIZE);
+		pPPPNew->len = htons(frag_size + ip_hdr_len + MV_PPP_HDR_SIZE);
+	}
+	tx_desc->bufPhysAddr = mvOsCacheFlush(NULL, data, tx_desc->dataSize);
+	mv_eth_tx_desc_flush(tx_desc);
+
+	return 0;
+}
+
+static inline int mv_eth_frag_build_data_desc(struct tx_queue *txq_ctrl, MV_U8 *frag_ptr, int frag_size,
+						int data_left, struct eth_pbuf *pkt)
+{
+	struct neta_tx_desc *tx_desc;
+
+	tx_desc = mv_eth_tx_desc_get(txq_ctrl, 1);
+	if (tx_desc == NULL)
+		return -1;
+
+	txq_ctrl->txq_count++;
+	tx_desc->dataSize = frag_size;
+	tx_desc->bufPhysAddr = pkt->physAddr + (frag_ptr - pkt->pBuf);
+	tx_desc->command = (NETA_TX_L_DESC_MASK | NETA_TX_Z_PAD_MASK);
+
+	if (frag_size == data_left)
+		txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = (u32) pkt;
+	else
+		txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = 0;
+
+	mv_eth_shadow_inc_put(txq_ctrl);
+	mv_eth_tx_desc_flush(tx_desc);
+
+	return 0;
+}
+
+static int mv_eth_fragment_tx(struct eth_port *pp, struct net_device *dev, MV_NFP_RESULT* res,
+					   struct tx_queue *txq_ctrl, struct eth_pbuf *pkt)
+{
+	MV_IP_HEADER_INFO *pIpInfo = &res->ipInfo;
+	int   pkt_offset = (pkt->offset + res->shift);
+	int   ip_offset = (pIpInfo->ipOffset - res->shift);
+	int   frag_size = MV_ALIGN_DOWN((res->mtu - res->ipInfo.ipHdrLen), 8);
+	int   data_left = pIpInfo->ipLen - res->ipInfo.ipHdrLen;
+	int   pktNum = (data_left / frag_size) + ((data_left % frag_size) ? 1 : 0);
+	MV_U8 *pData = pkt->pBuf + pkt_offset;
+	MV_U8 *payloadStart = pData + ip_offset + pIpInfo->ipHdrLen;
+	MV_U8 *frag_ptr = payloadStart;
+	int   i, total_bytes = 0;
+	int   save_txq_count = txq_ctrl->txq_count;
+
+	if ((txq_ctrl->txq_count + (pktNum * 2)) >= txq_ctrl->txq_size) {
+/*
+		printk(KERN_ERR "%s: no TX descriptors - txq_count=%d, len=%d, frag_size=%d\n",
+					__func__, txq_ctrl->txq_count, data_left, frag_size);
+*/
+		STAT_ERR(txq_ctrl->stats.txq_err++);
+		goto outNoTxDesc;
+	}
+
+	for (i = 0; i < pktNum; i++) {
+
+		if (mv_eth_frag_build_hdr_desc(pp, txq_ctrl, pData, ip_offset, pIpInfo->ipHdrLen,
+					frag_size, data_left, frag_ptr - payloadStart))
+			goto outNoTxDesc;
+
+		total_bytes += (ip_offset + pIpInfo->ipHdrLen);
+
+		if (mv_eth_frag_build_data_desc(txq_ctrl, frag_ptr, frag_size, data_left, pkt))
+			goto outNoTxDesc;
+
+		total_bytes += frag_size;
+		frag_ptr += frag_size;
+		data_left -= frag_size;
+		frag_size = MV_MIN(frag_size, data_left);
+	}
+	/* Flush + Invalidate cache for MAC + IP header + L4 header */
+	pData = pkt->pBuf + pkt->offset;
+	if (res->shift < 0)
+		pData += res->shift;
+
+	mvOsCacheMultiLineFlushInv(NULL, pData, (res->pWrite - pData));
+
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(pp->port))
+		mvNetaPonTxqBytesAdd(pp->port, txq_ctrl->txp, txq_ctrl->txq, total_bytes);
+#endif /* CONFIG_MV_PON */
+
+	dev->stats.tx_packets += pktNum;
+	dev->stats.tx_bytes += total_bytes;
+	STAT_DBG(txq_ctrl->stats.txq_tx += (pktNum * 2));
+
+	mvNetaTxqPendDescAdd(pp->port, txq_ctrl->txp, txq_ctrl->txq, pktNum * 2);
+
+	return (pktNum * 2);
+
+outNoTxDesc:
+	while (save_txq_count < txq_ctrl->txq_count) {
+		txq_ctrl->txq_count--;
+		mv_eth_shadow_dec_put(txq_ctrl);
+		mvNetaTxqPrevDescGet(txq_ctrl->q);
+	}
+	/* Invalidate cache for MAC + IP header + L4 header */
+	pData = pkt->pBuf + pkt->offset;
+	if (res->shift < 0)
+		pData += res->shift;
+
+	mvOsCacheMultiLineInv(NULL, pData, (res->pWrite - pData));
+
+	return 0;
+}
+
+
+static MV_STATUS mv_eth_nfp_tx(struct eth_pbuf *pkt, MV_NFP_RESULT *res)
 {
-	struct net_device *dev = (struct net_device *)pkt->dev;
+	struct net_device *dev = (struct net_device *)res->dev;
 	struct eth_port *pp = MV_ETH_PRIV(dev);
 	struct neta_tx_desc *tx_desc;
-	u32 tx_cmd;
+	u32 tx_cmd, physAddr;
 	MV_STATUS status = MV_OK;
-#ifndef CONFIG_MV_ETH_TXDONE_ISR
-	u32 tx_done = 0;
-#endif
-	int txq, txp;
 	struct tx_queue *txq_ctrl;
+	int use_bm, pkt_offset, frags = 1;
 
 	read_lock(&pp->rwlock);
 
 	/* Get TxQ to send packet */
-	txq = mv_eth_txq_tos_map_get(pp, pkt->tos);
-	txp = pp->txp;
-	txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
+	/* Check TXQ classification */
+	if ((res->flags & MV_NFP_RES_TXQ_VALID) == 0)
+		res->txq = pp->txq[smp_processor_id()];
+
+	if ((res->flags & MV_NFP_RES_TXP_VALID) == 0)
+		res->txp = pp->txp;
+
+	txq_ctrl = &pp->txq_ctrl[res->txp * CONFIG_MV_ETH_TXQ + res->txq];
 	spin_lock(&txq_ctrl->queue_lock);
 
+	/* Do fragmentation if needed */
+	if (mv_eth_need_fragment(res)) {
+		frags = mv_eth_fragment_tx(pp, dev, res, txq_ctrl, pkt);
+		if (frags == 0) {
+			dev->stats.tx_dropped++;
+			status = MV_DROPPED;
+		}
+		STAT_INFO(pp->stats.tx_fragment++);
+		goto out;
+	}
+
 	/* Get next descriptor for tx, single buffer, so FIRST & LAST */
 	tx_desc = mv_eth_tx_desc_get(txq_ctrl, 1);
 	if (tx_desc == NULL) {
@@ -1472,31 +2223,71 @@ static MV_STATUS mv_eth_nfp_tx(struct ne
 		status = MV_DROPPED;
 		goto out;
 	}
+
+	if (res->flags & MV_NFP_RES_L4_CSUM_NEEDED) {
+		MV_U8 *pData = pkt->pBuf + pkt->offset;
+
+		if (res->shift < 0)
+			pData += res->shift;
+
+		mvOsCacheMultiLineFlushInv(NULL, pData, (res->pWrite - pData));
+	}
+
 	txq_ctrl->txq_count++;
 
 	/* tx_cmd - word accumulated by NFP processing */
-	tx_cmd = pkt->tx_cmd;
+	tx_cmd = res->tx_cmd;
+
+	if (res->ipInfo.family == MV_INET) {
+		tx_cmd |= NETA_TX_L3_IP4 | NETA_TX_IP_CSUM_MASK |
+				((res->ipInfo.ipOffset - res->shift) << NETA_TX_L3_OFFSET_OFFS) |
+				((res->ipInfo.ipHdrLen >> 2) << NETA_TX_IP_HLEN_OFFS);
+	} else {
+		tx_cmd |= NETA_TX_L3_IP6 |
+				((res->ipInfo.ipOffset - res->shift) << NETA_TX_L3_OFFSET_OFFS) |
+				((res->ipInfo.ipHdrLen >> 2) << NETA_TX_IP_HLEN_OFFS);
+	}
 
 #ifdef CONFIG_MV_ETH_BM_CPU
-	tx_cmd |= NETA_TX_BM_ENABLE_MASK | NETA_TX_BM_POOL_ID_MASK(pkt->pool);
-	txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = (u32) NULL;
-	mv_eth_shadow_inc_put(txq_ctrl);
+	use_bm = 1;
 #else
-	/* Remember pkt in separate TxQ shadow */
-	txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = (u32) pkt;
-	mv_eth_shadow_inc_put(txq_ctrl);
+	use_bm = 0;
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
+	pkt_offset = pkt->offset + res->shift;
+	physAddr = pkt->physAddr;
+	if (pkt_offset > NETA_TX_PKT_OFFSET_MAX) {
+		use_bm = 0;
+		physAddr += pkt_offset;
+		pkt_offset = 0;
+	}
+
+	if ((pkt->pool >= 0) && (pkt->pool < MV_ETH_BM_POOLS)) {
+		if (use_bm) {
+			tx_cmd |= NETA_TX_BM_ENABLE_MASK | NETA_TX_BM_POOL_ID_MASK(pkt->pool);
+			txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = (u32) NULL;
+		} else
+			txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = (u32) pkt;
+	} else {
+		/* skb from external interface */
+		txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = ((u32)pkt->osInfo | MV_ETH_SHADOW_SKB);
+	}
+
+	mv_eth_shadow_inc_put(txq_ctrl);
+
+	tx_cmd |= NETA_TX_PKT_OFFSET_MASK(pkt_offset);
+
 	tx_desc->command = tx_cmd | NETA_TX_FLZ_DESC_MASK;
 	tx_desc->dataSize = pkt->bytes;
-	tx_desc->bufPhysAddr = pkt->physAddr;
+	tx_desc->bufPhysAddr = physAddr;
 
 	/* FIXME: PON only? --BK */
-	tx_desc->hw_cmd = pkt->hw_cmd;
+	tx_desc->hw_cmd = pp->hw_cmd;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	if (pp->flags & MV_ETH_F_DBG_TX) {
-		printk(KERN_ERR "\n");
+		printk(KERN_ERR "%s - nfp_tx_%lu: port=%d, txp=%d, txq=%d\n",
+		       dev->name, dev->stats.tx_packets, pp->port, res->txp, res->txq);
 		mv_eth_tx_desc_print(tx_desc);
 		mv_eth_pkt_print(pkt);
 	}
@@ -1504,30 +2295,31 @@ static MV_STATUS mv_eth_nfp_tx(struct ne
 
 	mv_eth_tx_desc_flush(tx_desc);
 
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(pp->port))
+		mvNetaPonTxqBytesAdd(pp->port, res->txp, res->txq, pkt->bytes);
+#endif /* CONFIG_MV_PON */
+
 	/* Enable transmit by update PENDING counter */
-	mvNetaTxqPendDescAdd(pp->port, txp, txq, 1);
+	mvNetaTxqPendDescAdd(pp->port, res->txp, res->txq, 1);
 
 	/* FIXME: stats includes MH --BK */
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += pkt->bytes;
 	STAT_DBG(txq_ctrl->stats.txq_tx++);
 
-#ifdef CONFIG_MV_PON
-	if (MV_PON_PORT(pp->port))
-		mvNetaPonTxqBytesAdd(pp->port, txp, txq, pkt->bytes);
-#endif /* CONFIG_MV_PON */
-
 out:
 #ifndef CONFIG_MV_ETH_TXDONE_ISR
-	if (txq_ctrl->txq_count >= mv_ctrl_txdone)
-		tx_done = mv_eth_txq_done(pp, txq_ctrl);
+	if (txq_ctrl->txq_count >= mv_ctrl_txdone) {
+		u32 tx_done = mv_eth_txq_done(pp, txq_ctrl);
 
-	STAT_DIST(if (tx_done < pp->dist_stats.tx_done_dist_size)
+		STAT_DIST(if (tx_done < pp->dist_stats.tx_done_dist_size)
 			pp->dist_stats.tx_done_dist[tx_done]++);
-
-	/* If after calling mv_eth_txq_done, txq_ctrl->txq_count is 1, we need to set the timer */
-	if ((txq_ctrl->txq_count == 1))
+	}
+	/* If after calling mv_eth_txq_done, txq_ctrl->txq_count equals frags, we need to set the timer */
+	if ((txq_ctrl->txq_count == frags) && (frags > 0))
 		mv_eth_add_tx_done_timer(pp);
+
 #endif /* CONFIG_MV_ETH_TXDONE_ISR */
 
 	spin_unlock(&txq_ctrl->queue_lock);
@@ -1541,9 +2333,12 @@ out:
  *  MV_TERMINATE - packet can't be processed by NFP - pass to Linux processing
  *  MV_DROPPED - packet processed by NFP, but not sent (dropped)
  */
-static MV_STATUS mv_eth_nfp(struct eth_port *pp, struct neta_rx_desc *rx_desc, struct eth_pbuf *pkt)
+static MV_STATUS mv_eth_nfp(struct eth_port *pp, int rxq, struct neta_rx_desc *rx_desc,
+				struct eth_pbuf *pkt, struct bm_pool *pool)
 {
-	MV_STATUS status;
+	MV_STATUS       status;
+	MV_NFP_RESULT   res;
+	bool            tx_external = false;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	if (pp->flags & MV_ETH_F_DBG_RX) {
@@ -1552,26 +2347,71 @@ static MV_STATUS mv_eth_nfp(struct eth_p
 	}
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
-#ifdef CONFIG_MV_ETH_NFP_SWF
-	if (rx_desc->pncInfo & NETA_PNC_SWF) {
-		status = mvNfpSwf(pp->port, rx_desc, pkt);
-		goto tx;
-	}
-#endif /* CONFIG_MV_ETH_NFP_SWF */
-
-#ifdef NFP_PNC
-	if (rx_desc->pncInfo & NETA_PNC_NFP) {
-		status = mvNfpPnC(pp->port, rx_desc, pkt);
-		goto tx;
-	}
-#endif /* NFP_PNC */
-
-	status = mvNfpRx(pp->port, rx_desc, pkt);
-#if defined(CONFIG_MV_ETH_NFP_SWF) || defined(NFP_PNC)
-tx:
-#endif
-	if (status == MV_OK)
-		status = mv_eth_nfp_tx(rx_desc, pkt);
+	read_lock(&nfp_lock);
+
+	status = mvNfpRx(pp->port, rx_desc, pkt, &res);
+	tx_external = (res.flags & MV_NFP_RES_NETDEV_EXT);
+
+	read_unlock(&nfp_lock);
+
+	if (status == MV_OK) {
+
+		if (res.flags & MV_NFP_RES_L4_CSUM_NEEDED) {
+			MV_IP_HEADER_INFO *pIpInfo = &res.ipInfo;
+			MV_U8 *pIpHdr = pIpInfo->ip_hdr.l3;
+
+			if (pIpInfo->ipProto == MV_IP_PROTO_TCP) {
+				MV_TCP_HEADER *pTcpHdr = (MV_TCP_HEADER *) ((char *)pIpHdr + pIpInfo->ipHdrLen);
+
+				pTcpHdr->chksum = csum_fold(csum_partial((char *)res.diffL4, sizeof(res.diffL4),
+									~csum_unfold(pTcpHdr->chksum)));
+				res.pWrite = (MV_U8 *)pTcpHdr + sizeof(MV_TCP_HEADER);
+			} else {
+				MV_UDP_HEADER *pUdpHdr = (MV_UDP_HEADER *) ((char *)pIpHdr + pIpInfo->ipHdrLen);
+
+				pUdpHdr->check = csum_fold(csum_partial((char *)res.diffL4, sizeof(res.diffL4),
+									~csum_unfold(pUdpHdr->check)));
+				res.pWrite = (MV_U8 *)pUdpHdr + sizeof(MV_UDP_HEADER);
+			}
+		}
+
+#ifdef CONFIG_MV_ETH_NFP_EXT
+		if  (tx_external) {
+			/* INT RX -> EXT TX */
+			mv_eth_nfp_ext_tx(pp, pkt, &res);
+			status = MV_OK;
+		} else
+#endif /* CONFIG_MV_ETH_NFP_EXT */
+			/* INT RX -> INT TX */
+			status = mv_eth_nfp_tx(pkt, &res);
+	}
+	if (status == MV_OK) {
+		STAT_DBG(pp->stats.rx_nfp++);
+
+		/* Packet transmited - refill now */
+		if (!tx_external && mv_eth_pool_bm(pool)) {
+			/* BM - no refill */
+			mvOsCacheLineInv(NULL, rx_desc);
+			return MV_OK;
+		}
+
+		if (!tx_external || mv_eth_is_recycle())
+			pkt = NULL;
+
+		if (mv_eth_refill(pp, rxq, pkt, pool, rx_desc)) {
+			printk(KERN_ERR "Linux processing - Can't refill\n");
+			pp->rxq_ctrl[rxq].missed++;
+			mv_eth_add_cleanup_timer(pp);
+			return MV_FAIL;
+		}
+		return MV_OK;
+	}
+	if (status == MV_DROPPED) {
+		/* Refill the same buffer */
+		STAT_DBG(pp->stats.rx_nfp_drop++);
+		mv_eth_rxq_refill(pp, rxq, pkt, pool, rx_desc);
+		return MV_OK;
+	}
 	return status;
 }
 #endif /* CONFIG_MV_ETH_NFP */
@@ -1740,6 +2580,11 @@ static int mv_eth_tx(struct sk_buff *skb
 	}
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(pp->port))
+		mvNetaPonTxqBytesAdd(pp->port, tx_spec.txp, tx_spec.txq, skb->len);
+#endif /* CONFIG_MV_PON */
+
 	/* Enable transmit */
 	mvNetaTxqPendDescAdd(pp->port, tx_spec.txp, tx_spec.txq, frags);
 
@@ -1749,10 +2594,6 @@ out:
 	if (frags > 0) {
 		dev->stats.tx_packets++;
 		dev->stats.tx_bytes += skb->len;
-#ifdef CONFIG_MV_PON
-		if (MV_PON_PORT(pp->port))
-			mvNetaPonTxqBytesAdd(pp->port, tx_spec.txp, tx_spec.txq, skb->len);
-#endif /* CONFIG_MV_PON */
 	} else {
 		dev->stats.tx_dropped++;
 		dev_kfree_skb_any(skb);
@@ -1820,7 +2661,7 @@ static inline int mv_eth_tso_build_hdr_d
 
 	data = mv_eth_extra_pool_get(priv);
 	if (!data)
-		return -1;
+		return 0;
 
 	txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = ((MV_ULONG)data | MV_ETH_SHADOW_EXT);
 
@@ -1865,7 +2706,7 @@ static inline int mv_eth_tso_build_hdr_d
 
 	mv_eth_tx_desc_flush(tx_desc);
 
-	return 0;
+	return hdr_len;
 }
 
 static inline int mv_eth_tso_build_data_desc(struct neta_tx_desc *tx_desc, struct sk_buff *skb,
@@ -1906,7 +2747,7 @@ int mv_eth_tx_tso(struct sk_buff *skb, s
 	int frag = 0;
 	int total_len, hdr_len, size, frag_size, data_left;
 	char *frag_ptr;
-	int totalDescNum;
+	int totalDescNum, totalBytes = 0;
 	struct neta_tx_desc *tx_desc;
 	MV_U16 ip_id;
 	MV_U32 tcp_seq = 0;
@@ -1983,10 +2824,12 @@ int mv_eth_tx_tso(struct sk_buff *skb, s
 		}
 
 		/* prepare packet headers: MAC + IP + TCP */
-		if (mv_eth_tso_build_hdr_desc(tx_desc, priv, skb, txq_ctrl, mh,
-					hdr_len, data_left, tcp_seq, ip_id, total_len))
+		size = mv_eth_tso_build_hdr_desc(tx_desc, priv, skb, txq_ctrl, mh,
+					hdr_len, data_left, tcp_seq, ip_id, total_len);
+		if (size == 0)
 			goto outNoTxDesc;
 
+		totalBytes += size;
 /*
 		printk(KERN_ERR "Header desc: tx_desc=%p, skb=%p, hdr_len=%d, data_left=%d\n",
 						tx_desc, skb, hdr_len, data_left);
@@ -2003,7 +2846,7 @@ int mv_eth_tx_tso(struct sk_buff *skb, s
 
 			size = mv_eth_tso_build_data_desc(tx_desc, skb, txq_ctrl,
 							  frag_ptr, frag_size, data_left, total_len);
-
+			totalBytes += size;
 /*
 			printk(KERN_ERR "Data desc: tx_desc=%p, skb=%p, size=%d, frag_size=%d, data_left=%d\n",
 							tx_desc, skb, size, frag_size, data_left);
@@ -2025,7 +2868,12 @@ int mv_eth_tx_tso(struct sk_buff *skb, s
 		}		/* of while data_left > 0 */
 	}			/* of while (total_len > 0) */
 
-	STAT_DBG(priv->stats.tx_tso_bytes += skb->len);
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(priv->port))
+		mvNetaPonTxqBytesAdd(priv->port, txq_ctrl->txp, txq_ctrl->txq, totalBytes);
+#endif /* CONFIG_MV_PON */
+
+	STAT_DBG(priv->stats.tx_tso_bytes += totalBytes);
 	STAT_DBG(txq_ctrl->stats.txq_tx += totalDescNum);
 
 	mvNetaTxqPendDescAdd(priv->port, txq_ctrl->txp, txq_ctrl->txq, totalDescNum);
@@ -2062,11 +2910,7 @@ static inline void mv_eth_txq_bufs_free(
 
 		if (!shadow)
 			continue;
-/*
-		printk(KERN_ERR "tx_done: p=%d, txp=%d, txq=%d, writeIdx=%d, readIdx=%d, shadow=0x%x\n",
-					pp->port, txq_ctrl->txp, txq_ctrl->txq, txq_ctrl->shadow_txq_put_i,
-					txq_ctrl->shadow_txq_get_i, shadow);
-*/
+
 		if (shadow & MV_ETH_SHADOW_SKB) {
 			shadow &= ~MV_ETH_SHADOW_SKB;
 			dev_kfree_skb_any((struct sk_buff *)shadow);
@@ -2080,7 +2924,13 @@ static inline void mv_eth_txq_bufs_free(
 				struct eth_pbuf *pkt = (struct eth_pbuf *)shadow;
 				struct bm_pool *pool = &mv_eth_pool[pkt->pool];
 
-				mv_eth_pool_put(pool, pkt);
+				if (mv_eth_pool_bm(pool)) {
+					/* Refill BM pool */
+					STAT_DBG(pool->stats.bm_put++);
+					mvBmPoolPut(pkt->pool, (MV_ULONG) pkt->physAddr);
+				} else {
+					mv_eth_pool_put(pool, pkt);
+				}
 			}
 		}
 	}
@@ -2268,65 +3118,78 @@ static int mv_eth_pool_free(int pool, in
 	int i = 0;
 	struct bm_pool *ppool = &mv_eth_pool[pool];
 	unsigned long flags = 0;
+	bool free_all = false;
 
 	MV_ETH_LOCK(&ppool->lock, flags);
 
 	if (num >= ppool->buf_num) {
 		/* Free all buffers from the pool */
+		free_all = true;
 		num = ppool->buf_num;
+	}
 
 #ifdef CONFIG_MV_ETH_BM_CPU
-		mvBmConfigSet(MV_BM_EMPTY_LIMIT_MASK);
-#endif /* CONFIG_MV_ETH_BM_CPU */
-	}
+	if (mv_eth_pool_bm(ppool)) {
 
-	while (i < num) {
-		pkt = NULL;
+		if (free_all)
+			mvBmConfigSet(MV_BM_EMPTY_LIMIT_MASK);
 
-		if (mv_eth_pool_bm(ppool)) {
-#ifdef CONFIG_MV_ETH_BM_CPU
+		while (i < num) {
 			MV_U32 *va;
 			MV_U32 pa = mvBmPoolGet(pool);
 
-			if (pa != 0) {
-				va = phys_to_virt(pa);
-				pkt = (struct eth_pbuf *)*va;
-/*
-			printk(KERN_ERR "mv_eth_pool_free_%d: pool=%d, pkt=%p, head=%p (%x)\n",
-				i, pool, pkt, va, pa);
-*/
-			}
-#endif /* CONFIG_MV_ETH_BM_CPU */
-		} else {
-			if (mvStackIndex(ppool->stack) > 0)
-				pkt = (struct eth_pbuf *)mvStackPop(ppool->stack);
-		}
-		if (pkt) {
-			struct sk_buff *skb = (struct sk_buff *)pkt->osInfo;
+			if (pa == 0)
+				break;
 
-#ifdef CONFIG_NET_SKB_RECYCLE
-			skb->skb_recycle = NULL;
-			skb->hw_cookie = NULL;
-#endif /* CONFIG_NET_SKB_RECYCLE */
+			va = phys_to_virt(pa);
+			pkt = (struct eth_pbuf *)*va;
+#if !defined(CONFIG_MV_ETH_BE_WA)
+			pkt = (struct eth_pbuf *)MV_32BIT_LE((MV_U32)pkt);
+#endif /* !CONFIG_MV_ETH_BE_WA */
 
+			if (pkt) {
+				mv_eth_pkt_free(pkt);
 #ifdef ETH_SKB_DEBUG
-			mv_eth_skb_check(skb);
+				mv_eth_skb_check((struct sk_buff *)pkt->osInfo);
 #endif /* ETH_SKB_DEBUG */
-
+			}
 			i++;
-			dev_kfree_skb_any(skb);
-			mvOsFree(pkt);
-		} else
-			break;
+		}
+		printk(KERN_ERR "bm pool #%d: pkt_size=%d, buf_size=%d - %d of %d buffers free\n",
+			pool, ppool->pkt_size, RX_BUF_SIZE(ppool->pkt_size), i, num);
+
+		if (free_all)
+			mvBmConfigClear(MV_BM_EMPTY_LIMIT_MASK);
 	}
-	printk(KERN_ERR "pool #%d: pkt_size=%d, buf_size=%d - %d of %d buffers free\n",
-	       pool, ppool->pkt_size, RX_BUF_SIZE(ppool->pkt_size), i, num);
+#endif /* CONFIG_MV_ETH_BM_CPU */
 
 	ppool->buf_num -= num;
 
-#ifdef CONFIG_MV_ETH_BM_CPU
-		mvBmConfigClear(MV_BM_EMPTY_LIMIT_MASK);
-#endif /* CONFIG_MV_ETH_BM_CPU */
+	/* Free buffers from the pool stack too */
+	if (free_all)
+		num = mvStackIndex(ppool->stack);
+	else if (mv_eth_pool_bm(ppool))
+		num = 0;
+
+	i = 0;
+	while (i < num) {
+		/* sanity check */
+		if (mvStackIndex(ppool->stack) == 0) {
+			printk(KERN_ERR "%s: No more buffers in the stack\n", __func__);
+			break;
+		}
+		pkt = (struct eth_pbuf *)mvStackPop(ppool->stack);
+		if (pkt) {
+			mv_eth_pkt_free(pkt);
+#ifdef ETH_SKB_DEBUG
+			mv_eth_skb_check((struct sk_buff *)pkt->osInfo);
+#endif /* ETH_SKB_DEBUG */
+		}
+		i++;
+	}
+	if (i > 0)
+		printk(KERN_ERR "stack pool #%d: pkt_size=%d, buf_size=%d - %d of %d buffers free\n",
+			pool, ppool->pkt_size, RX_BUF_SIZE(ppool->pkt_size), i, num);
 
 	MV_ETH_UNLOCK(&ppool->lock, flags);
 
@@ -2544,11 +3407,19 @@ irqreturn_t mv_eth_isr(int irq, void *de
 void mv_eth_link_event(struct eth_port *pp, int print)
 {
 	struct net_device *dev = pp->dev;
+	bool              link_is_up;
 
 	STAT_INFO(pp->stats.link++);
 
 	/* Check Link status on ethernet port */
-	if (mvNetaLinkIsUp(pp->port)) {
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(pp->port))
+		link_is_up = mv_pon_link_status();
+	else
+#endif /* CONFIG_MV_PON */
+		link_is_up = mvNetaLinkIsUp(pp->port);
+
+	if (link_is_up) {
 		mvNetaPortUp(pp->port);
 		set_bit(MV_ETH_F_LINK_UP_BIT, &(pp->flags));
 
@@ -2730,71 +3601,40 @@ static void mv_eth_cpu_counters_init(voi
 #endif /* CONFIG_MV_CPU_PERF_CNTRS */
 }
 
-#ifdef CONFIG_MV_ETH_NFP
-static MV_STATUS mv_eth_register_nfp_devices(void)
-{
-	int i;
-	MV_STATUS status = MV_OK;
-	struct eth_port *curr_pp;
-
-	/* Register all network devices mapped to NETA as internal for NFP */
-	for (i = 0; i < mv_net_devs_num; i++) {
-		if (mv_net_devs[i] != NULL) {
-			curr_pp = MV_ETH_PRIV(mv_net_devs[i]);
-			if (curr_pp->flags & MV_ETH_F_CONNECT_LINUX) {
-				status = nfp_mgr_if_register(mv_net_devs[i]->ifindex,
-								MV_NFP_IF_INT,
-								mv_net_devs[i],	curr_pp);
-				if (status != MV_OK) {
-					printk(KERN_ERR "fp_mgr_if_register failed\n");
-					return MV_ERROR;
-				}
-			}
-		}
-	}
-	return MV_OK;
-}
-
-
-MV_STATUS mv_eth_unregister_nfp_devices(void)
-{
-	nfp_eth_dev_db_clear();
-
-	return MV_OK;
-}
-#endif /* CONFIG_MV_ETH_NFP */
-
-
 static void mv_eth_port_promisc_set(int port, int queue)
 {
-#ifdef CONFIG_MV_ETH_PNC_PARSER
+#ifdef CONFIG_MV_ETH_PNC
 	/* Accept all */
-	pnc_mac_me(port, NULL, queue);
-	pnc_mcast_all(port, 1);
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
-
-#ifdef CONFIG_MV_ETH_LEGACY_PARSER
+	if (mv_eth_pnc_ctrl_en) {
+		pnc_mac_me(port, NULL, queue);
+		pnc_mcast_all(port, 1);
+	} else {
+		printk(KERN_ERR "%s: PNC control is disabled\n", __func__);
+	}
+#else /* Legacy parser */
 	mvNetaRxUnicastPromiscSet(port, MV_TRUE);
 	mvNetaSetUcastTable(port, queue);
 	mvNetaSetSpecialMcastTable(port, queue);
 	mvNetaSetOtherMcastTable(port, queue);
-#endif /* CONFIG_MV_ETH_LEGACY_PARSER */
+#endif /* CONFIG_MV_ETH_PNC */
 }
 
 void mv_eth_port_filtering_cleanup(int port)
 {
-#ifdef CONFIG_MV_ETH_PNC_PARSER
-	if (port == 0)
-		/* clean TCAM only one, no need to do this per port. Assume this function is called with port 0 */
-		tcam_hw_init();
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
+#ifdef CONFIG_MV_ETH_PNC
+	static bool is_first = true;
 
-#ifdef CONFIG_MV_ETH_LEGACY_PARSER
+	/* clean TCAM only one, no need to do this per port. */
+	if (is_first) {
+		tcam_hw_init();
+		is_first = false;
+	}
+#else
 	mvNetaRxUnicastPromiscSet(port, MV_FALSE);
 	mvNetaSetUcastTable(port, -1);
 	mvNetaSetSpecialMcastTable(port, -1);
 	mvNetaSetOtherMcastTable(port, -1);
-#endif /* CONFIG_MV_ETH_LEGACY_PARSER */
+#endif /* CONFIG_MV_ETH_PNC */
 }
 
 
@@ -2803,6 +3643,12 @@ static MV_STATUS mv_eth_bm_pools_init(vo
 	int i, j;
 	MV_STATUS status;
 
+	/* Get compile time configuration */
+#ifdef CONFIG_MV_ETH_BM
+	mvBmControl(MV_START);
+	mv_eth_bm_config_get();
+#endif /* CONFIG_MV_ETH_BM */
+
 	/* Create all pools with maximum capacity */
 	for (i = 0; i < MV_ETH_BM_POOLS; i++) {
 		status = mv_eth_pool_create(i, MV_BM_POOL_CAP_MAX);
@@ -2812,24 +3658,16 @@ static MV_STATUS mv_eth_bm_pools_init(vo
 				mv_eth_pool_destroy(j);
 			return status;
 		}
-	}
 #ifdef CONFIG_MV_ETH_BM_CPU
-	mvBmControl(MV_START);
-	mv_eth_pool[MV_ETH_SHORT_BM_POOL].pkt_size = CONFIG_MV_ETH_SHORT_PKT_SIZE;
-	mvBmPoolBufSizeSet(MV_ETH_SHORT_BM_POOL, RX_BUF_SIZE(CONFIG_MV_ETH_SHORT_PKT_SIZE));
-
-#ifdef CONFIG_MV_ETH_POOL_PREDEFINED
-	/* use predefined pools */
-	mv_eth_pool[0].pkt_size = RX_PKT_SIZE(CONFIG_MV_ETH_POOL_0_MTU);
-	mvBmPoolBufSizeSet(0, RX_BUF_SIZE(mv_eth_pool[0].pkt_size));
-	mv_eth_pool[1].pkt_size = RX_PKT_SIZE(CONFIG_MV_ETH_POOL_1_MTU);
-	mvBmPoolBufSizeSet(1, RX_BUF_SIZE(mv_eth_pool[1].pkt_size));
-	mv_eth_pool[2].pkt_size = RX_PKT_SIZE(CONFIG_MV_ETH_POOL_2_MTU);
-	mvBmPoolBufSizeSet(2, RX_BUF_SIZE(mv_eth_pool[2].pkt_size));
-#endif /* CONFIG_MV_ETH_POOL_PREDEFINED */
-
-#endif /* CONFIG_MV_ETH_BM_CPU */
-
+		mv_eth_pool[i].pkt_size = mv_eth_bm_config_pkt_size_get(i);
+		if (mv_eth_pool[i].pkt_size == 0)
+			mvBmPoolBufSizeSet(i, 0);
+		else
+			mvBmPoolBufSizeSet(i, RX_BUF_SIZE(mv_eth_pool[i].pkt_size));
+#else
+		mv_eth_pool[i].pkt_size = 0;
+#endif /* CONFIG_MV_ETH_BM */
+	}
 	return 0;
 }
 
@@ -2873,9 +3711,8 @@ static int mv_eth_load_network_interface
 
 #ifdef CONFIG_MV_ETH_SWITCH
 		if (pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)) {
-			MV_STATUS status;
+			int status = mv_eth_switch_config_get(mv_eth_initialized, port);
 
-			status = mv_eth_switch_config_get(mv_eth_initialized);
 			if (status < 0) {
 				printk(KERN_ERR "\nWarning: port %d - Invalid netconfig string\n", port);
 				mv_eth_priv_cleanup(pp);
@@ -2892,7 +3729,7 @@ static int mv_eth_load_network_interface
 
 		if (pp->flags & MV_ETH_F_SWITCH) {
 			set_bit(MV_ETH_F_MH_BIT, &(pp->flags));
-			mtu = switch_net_config.mtu;
+			mtu = switch_net_config[port].mtu;
 			if (mv_switch_init(RX_PKT_SIZE(mtu), SWITCH_CONNECTED_PORTS_MASK)) {
 				printk(KERN_ERR "\nWarning: port %d - Switch initialization failed\n", port);
 				mv_eth_priv_cleanup(pp);
@@ -2915,7 +3752,7 @@ static int mv_eth_load_network_interface
 
 			mv_eth_switch_netdev_first = dev_i;
 			dev_i = mv_eth_switch_netdev_init(pp, dev_i);
-			if (dev_i < (mv_eth_switch_netdev_first + switch_net_config.netdev_max)) {
+			if (dev_i < (mv_eth_switch_netdev_first + switch_net_config[port].netdev_max)) {
 				printk(KERN_ERR "%s: can't create netdevice for switch\n", __func__);
 				mv_eth_priv_cleanup(pp);
 				return -EIO;
@@ -2954,7 +3791,6 @@ static int mv_eth_probe(struct platform_
 	u32 port;
 	struct eth_port *pp;
 	int size;
-	MV_STATUS status = MV_OK;
 
 #ifdef ETH_SKB_DEBUG
 	memset(mv_eth_skb_debug, 0, sizeof(mv_eth_skb_debug));
@@ -2992,11 +3828,13 @@ static int mv_eth_probe(struct platform_
 		memset(mv_net_devs, 0, size);
 	}
 
-#ifdef CONFIG_MV_ETH_PNC_PARSER
-	status = pnc_default_init();
-	if (status)
-		printk(KERN_ERR "%s: Warning PNC init failed %d\n", __func__, status);
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
+#ifdef CONFIG_MV_ETH_PNC
+	if (mv_eth_pnc_ctrl_en) {
+		if (pnc_default_init())
+			printk(KERN_ERR "%s: Warning PNC init failed\n", __func__);
+	} else
+		printk(KERN_ERR "%s: PNC control is disabled\n", __func__);
+#endif /* CONFIG_MV_ETH_PNC */
 
 	if (mv_eth_bm_pools_init())
 		goto oom;
@@ -3012,14 +3850,6 @@ static int mv_eth_probe(struct platform_
 		if (mv_eth_load_network_interfaces())
 			goto oom;
 	}
-#ifdef CONFIG_MV_ETH_NFP
-	status = mv_eth_register_nfp_devices();
-	if (status) {
-		/* FIXME: cleanup */
-		printk(KERN_ERR "Error: mv_eth_register_nfp_devices failed\n");
-		return status;
-	}
-#endif /* CONFIG_MV_ETH_NFP */
 
 #ifdef CONFIG_MV_ETH_HWF
 	for (port = 0; port < mv_eth_ports_num; port++) {
@@ -3032,8 +3862,13 @@ static int mv_eth_probe(struct platform_
 	for (port = 0; port < mv_eth_ports_num; port++) {
 		pp = mv_eth_port_by_id(port);
 		if (pp) {
-			if (!(pp->flags & MV_ETH_F_CONNECT_LINUX)) /* TODO, check this is not a Switch port */
-				mv_eth_open(pp->dev);
+			if (!(pp->flags & MV_ETH_F_CONNECT_LINUX)) {
+				if (pp->flags & MV_ETH_F_SWITCH)
+					printk(KERN_ERR "%s: a GbE port using the Gateway driver cannot be disconnected from Linux\n",
+							__func__);
+				else
+					mv_eth_open(pp->dev);
+			}
 		}
 	}
 
@@ -3159,6 +3994,7 @@ struct net_device *mv_eth_netdev_init(st
 	int cpu, i;
 	struct net_device *dev;
 	struct eth_dev_priv *dev_priv;
+
 	dev = alloc_etherdev(sizeof(struct eth_dev_priv));
 	if (!dev)
 		return NULL;
@@ -3205,7 +4041,7 @@ struct net_device *mv_eth_netdev_init(st
 	SET_ETHTOOL_OPS(dev, &mv_eth_tool_ops);
 #endif
 	/* Default NAPI initialization */
-	for (i = 0; i < NR_GROUPS; i++) {
+	for (i = 0; i < CONFIG_MV_ETH_NAPI_GROUPS; i++) {
 		pp->napiGroup[i] = (struct napi_struct *)kmalloc(sizeof(struct napi_struct), GFP_KERNEL);
 		memset(pp->napiGroup[i], 0, sizeof(struct napi_struct));
 	}
@@ -3239,10 +4075,20 @@ struct net_device *mv_eth_netdev_init(st
 	return dev;
 }
 
+bool mv_eth_netdev_find(unsigned int dev_idx)
+{
+	int i;
+
+	for (i = 0; i < mv_net_devs_num; i++) {
+		if (mv_net_devs && mv_net_devs[i] && (mv_net_devs[i]->ifindex == dev_idx))
+			return true;
+	}
+	return false;
+}
 
 void mv_eth_netdev_update(int dev_index, struct eth_port *pp)
 {
-	int weight, cpu;
+	int cpu;
 	struct eth_dev_priv *dev_priv;
 #ifdef CONFIG_MV_ETH_SWITCH
 	struct eth_netdev *eth_netdev_priv;
@@ -3254,11 +4100,10 @@ void mv_eth_netdev_update(int dev_index,
 	dev_priv->port_p = pp;
 
 	dev->irq = NET_TH_RXTX_IRQ_NUM(pp->port);
-	weight = CONFIG_MV_ETH_RX_POLL_WEIGHT;
 
-	if (pp->flags & MV_ETH_F_CONNECT_LINUX) {
-			netif_napi_add(dev, pp->napi[CPU_GROUP_DEF], mv_eth_poll, pp->weight);
-	}
+	if (pp->flags & MV_ETH_F_CONNECT_LINUX)
+		netif_napi_add(dev, pp->napiGroup[CPU_GROUP_DEF], mv_eth_poll, pp->weight);
+
 	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++)
 		pp->napi[cpu] = pp->napiGroup[CPU_GROUP_DEF];
 
@@ -3342,12 +4187,8 @@ int mv_eth_hal_init(struct eth_port *pp)
 		rxq_ctrl->rxq_time_coal = CONFIG_MV_ETH_RX_COAL_USEC;
 	}
 
-	if (pp->flags & MV_ETH_F_MH) {
+	if (pp->flags & MV_ETH_F_MH)
 		mvNetaMhSet(pp->port, MV_NETA_MH);
-#ifdef CONFIG_MV_ETH_NFP
-		mvNfpPortCapSet(pp->port, NFP_P_MH, MV_TRUE);
-#endif
-	}
 
 #ifdef CONFIG_MV_ETH_TOOL
 	/* Configure defaults */
@@ -3398,11 +4239,11 @@ void mv_eth_config_show(void)
 #endif
 
 #ifdef CONFIG_MV_ETH_BM_CPU
-	printk(KERN_ERR "  o BM supported for CPU: short buffer size is %d bytes\n", CONFIG_MV_ETH_SHORT_PKT_SIZE);
+	printk(KERN_ERR "  o BM supported for CPU: %d BM pools\n", MV_ETH_BM_POOLS);
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
 #ifdef CONFIG_MV_ETH_PNC
-	printk(KERN_ERR "  o PnC supported\n");
+	printk(KERN_ERR "  o PnC supported (%s)\n", mv_eth_pnc_ctrl_en ? "Enabled" : "Disabled");
 #endif
 
 #ifdef CONFIG_MV_ETH_HWF
@@ -3433,11 +4274,32 @@ void mv_eth_config_show(void)
 #endif
 
 #ifdef CONFIG_MV_ETH_NFP
-	printk(KERN_ERR "  o Network Fast Processing (Routing) supported\n");
 
-#ifdef CONFIG_MV_ETH_NFP_NAT
-	printk(KERN_ERR "  o Network Fast Processing (NAT) supported\n");
-#endif /* CONFIG_MV_ETH_NFP_NAT */
+	printk(KERN_ERR "  o Network Fast Processing (NFP) supported\n");
+
+#ifdef NFP_BRIDGE
+	printk(KERN_ERR "     o NFP Bridging supported\n");
+#endif /* NFP_BRIDGE */
+
+#ifdef NFP_VLAN
+	printk(KERN_ERR "     o NFP VLAN Processing supported\n");
+#endif /* NFP_VLAN */
+
+#ifdef NFP_FIB
+	printk(KERN_ERR "     o NFP Routing (FIB) supported\n");
+#endif /* NFP_FIB */
+
+#ifdef NFP_NAT
+	printk(KERN_ERR "     o NFP NAT supported\n");
+#endif /* NFP_NAT */
+
+#ifdef NFP_LIMIT
+	printk(KERN_ERR "     o NFP Rate Limiting supported\n");
+#endif /* NFP_LIMIT */
+
+#ifdef NFP_PPP
+	printk(KERN_ERR "     o NFP PPPoE supported\n");
+#endif /* NFP_PPP */
 
 #endif /* CONFIG_MV_ETH_NFP */
 
@@ -3457,17 +4319,9 @@ void mv_eth_config_show(void)
 	printk(KERN_ERR "  o Driver debug messages enabled\n");
 #endif
 
-#ifdef CONFIG_MV_ETH_PROC
-	printk(KERN_ERR "  o Proc tool API enabled\n");
-#endif
-
 #if defined(CONFIG_MV_ETH_SWITCH)
 	printk(KERN_ERR "  o Switch support enabled\n");
 
-#ifdef CONFIG_MV_ETH_IGMP
-	printk(KERN_ERR "     o IGMP special processing support\n");
-#endif /* CONFIG_MV_ETH_IGMP */
-
 #endif /* CONFIG_MV_ETH_SWITCH */
 
 	printk(KERN_ERR "\n");
@@ -3497,11 +4351,16 @@ void mv_eth_priv_cleanup(struct eth_port
 	/* TODO */
 }
 
-static inline struct bm_pool *mv_eth_pool_find(struct eth_port *pp, int pkt_size)
+#ifdef CONFIG_MV_ETH_BM_CPU
+static struct bm_pool *mv_eth_long_pool_get(struct eth_port *pp, int pkt_size)
 {
-	int				pool, i;
+	int             pool, i;
 	struct bm_pool	*bm_pool, *temp_pool = NULL;
-	unsigned long flags = 0;
+	unsigned long   flags = 0;
+
+	pool = mv_eth_bm_config_long_pool_get(pp->port);
+	if (pool != -1) /* constant long pool for the port */
+		return &mv_eth_pool[pool];
 
 	/* look for free pool pkt_size == 0. First check pool == pp->port */
 	/* if no free pool choose larger than required */
@@ -3513,8 +4372,6 @@ static inline struct bm_pool *mv_eth_poo
 
 		if (bm_pool->pkt_size == 0) {
 			/* found free pool */
-			bm_pool->pkt_size = pkt_size;
-			mvBmPoolBufSizeSet(pool, RX_BUF_SIZE(pkt_size));
 
 			MV_ETH_UNLOCK(&bm_pool->lock, flags);
 			return bm_pool;
@@ -3529,6 +4386,12 @@ static inline struct bm_pool *mv_eth_poo
 	}
 	return temp_pool;
 }
+#else
+static struct bm_pool *mv_eth_long_pool_get(struct eth_port *pp, int pkt_size)
+{
+	return &mv_eth_pool[pp->port];
+}
+#endif /* CONFIG_MV_ETH_BM_CPU */
 
 static int mv_eth_rxq_fill(struct eth_port *pp, int rxq, int num)
 {
@@ -3776,38 +4639,63 @@ int mv_eth_start_internals(struct eth_po
 
 	/* Allocate buffers for Long buffers pool */
 	if (pp->pool_long == NULL) {
-		pp->pool_long = mv_eth_pool_find(pp, pkt_size);
+		struct bm_pool *new_pool;
 
-		if (pp->pool_long == NULL) {
+		new_pool = mv_eth_long_pool_get(pp, pkt_size);
+		if (new_pool == NULL) {
 			printk(KERN_ERR "%s FAILED: port=%d, Can't find pool for pkt_size=%d\n",
 			       __func__, pp->port, pkt_size);
 			err = -ENOMEM;
 			goto out;
 		}
+		if (new_pool->pkt_size == 0) {
+			new_pool->pkt_size = pkt_size;
+#ifdef CONFIG_MV_ETH_BM_CPU
+			mvBmPoolBufSizeSet(new_pool->pool, RX_BUF_SIZE(pkt_size));
+#endif /* CONFIG_MV_ETH_BM_CPU */
+		}
+		if (new_pool->pkt_size < pkt_size) {
+			printk(KERN_ERR "%s FAILED: port=%d, long pool #%d, pkt_size=%d less than required %d\n",
+					__func__, pp->port, new_pool->pool, new_pool->pkt_size, pkt_size);
+			err = -ENOMEM;
+			goto out;
+		}
+		pp->pool_long = new_pool;
+		pp->pool_long->port_map |= (1 << pp->port);
 
 		num = mv_eth_pool_add(pp->pool_long->pool, pp->pool_long_num);
 		if (num != pp->pool_long_num) {
-			printk(KERN_ERR "%s FAILED: pool=%d, pkt_size=%d, only %d of %d allocated\n",
-			       __func__, pp->pool_long->pool, pkt_size, num, pp->pool_long_num);
+			printk(KERN_ERR "%s FAILED: mtu=%d, pool=%d, pkt_size=%d, only %d of %d allocated\n",
+			       __func__, mtu, pp->pool_long->pool, pp->pool_long->pkt_size, num, pp->pool_long_num);
 			err = -ENOMEM;
 			goto out;
 		}
 	}
+
 #ifdef CONFIG_MV_ETH_BM_CPU
-	/* Allocate packets for short pool */
+	mvNetaBmPoolBufSizeSet(pp->port, pp->pool_long->pool, RX_BUF_SIZE(pp->pool_long->pkt_size));
+
 	if (pp->pool_short == NULL) {
-		pp->pool_short = &mv_eth_pool[MV_ETH_SHORT_BM_POOL];
-		num = mv_eth_pool_add(pp->pool_short->pool, pp->pool_short_num);
-		if (num != pp->pool_short_num) {
-			printk(KERN_ERR "%s FAILED: pool=%d, pkt_size=%d - %d of %d buffers added\n",
-			       __func__, MV_ETH_SHORT_BM_POOL, CONFIG_MV_ETH_SHORT_PKT_SIZE,
-			       num, pp->pool_short_num);
-			err = -ENOMEM;
+		int short_pool = mv_eth_bm_config_short_pool_get(pp->port);
+
+		/* Allocate packets for short pool */
+		if (short_pool < 0) {
+			err = -EINVAL;
 			goto out;
 		}
+		pp->pool_short = &mv_eth_pool[short_pool];
+		pp->pool_short->port_map |= (1 << pp->port);
+		if (pp->pool_short->pool != pp->pool_long->pool) {
+			num = mv_eth_pool_add(pp->pool_short->pool, pp->pool_short_num);
+			if (num != pp->pool_short_num) {
+				printk(KERN_ERR "%s FAILED: pool=%d, pkt_size=%d - %d of %d buffers added\n",
+					   __func__, short_pool, pp->pool_short->pkt_size, num, pp->pool_short_num);
+				err = -ENOMEM;
+				goto out;
+			}
+		}
+		mvNetaBmPoolBufSizeSet(pp->port, pp->pool_short->pool, RX_BUF_SIZE(pp->pool_short->pkt_size));
 	}
-	mvNetaBmPoolBufSizeSet(pp->port, pp->pool_short->pool, RX_BUF_SIZE(CONFIG_MV_ETH_SHORT_PKT_SIZE));
-	mvNetaBmPoolBufSizeSet(pp->port, pp->pool_long->pool, RX_BUF_SIZE(pkt_size));
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
 	for (rxq = 0; rxq < CONFIG_MV_ETH_RXQ; rxq++) {
@@ -3895,12 +4783,15 @@ int mv_eth_start_internals(struct eth_po
 
 	/* start the hal - rx/tx activity */
 	status = mvNetaPortEnable(pp->port);
-	if (status == MV_OK) {
+	if (status == MV_OK)
 		set_bit(MV_ETH_F_LINK_UP_BIT, &(pp->flags));
-	} else if (MV_PON_PORT(pp->port)) {
+#ifdef CONFIG_MV_PON
+	else if (MV_PON_PORT(pp->port) && (mv_pon_link_status() == MV_TRUE)) {
 		mvNetaPortUp(pp->port);
 		set_bit(MV_ETH_F_LINK_UP_BIT, &(pp->flags));
 	}
+#endif /* CONFIG_MV_PON */
+
 	set_bit(MV_ETH_F_STARTED_BIT, &(pp->flags));
 
  out:
@@ -3968,19 +4859,10 @@ error:
 	return -1;
 }
 
-/***********************************************************
- * mv_eth_change_mtu_internals --                          *
- *   stop port activity. release skb from rings. set new   *
- *   mtu in device and hw. restart port activity and       *
- *   and fill rx-buiffers with size according to new mtu.  *
- ***********************************************************/
-int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
+/* return positive if MTU is valid */
+int mv_eth_check_mtu_valid(struct net_device *dev, int mtu)
 {
-	struct bm_pool	*new_pool = NULL;
-	struct eth_port *pp = MV_ETH_PRIV(dev);
-	unsigned long	rwflags;
-
-	if (mtu < 64) {
+	if (mtu < 68) {
 		printk(KERN_INFO "MTU must be at least 64, change mtu failed\n");
 		return -EINVAL;
 	}
@@ -3995,31 +4877,84 @@ int mv_eth_change_mtu_internals(struct n
 		mtu = MV_ALIGN_UP(RX_PKT_SIZE(mtu), 8);
 		printk(KERN_CONT " rounding MTU to: %d \n", mtu);
 	}
+	return mtu;
+}
 
-	if (mtu != dev->mtu) {
+/* Check if MTU can be changed */
+int mv_eth_check_mtu_internals(struct net_device *dev, int mtu)
+{
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+	struct bm_pool	*new_pool = NULL;
 
-		write_lock_irqsave(&pp->rwlock, rwflags);
+	new_pool = mv_eth_long_pool_get(pp, RX_PKT_SIZE(mtu));
 
-		mv_eth_rx_reset(pp->port);
+	/* If no pool for new MTU or shared pool is used - MTU can be changed only when interface is stopped */
+	if (new_pool == NULL) {
+		printk(KERN_ERR "%s: No BM pool available for MTU=%d\n", __func__, mtu);
+		return -EPERM;
+	}
+#ifdef CONFIG_MV_ETH_BM_CPU
+	if (new_pool->pkt_size < RX_PKT_SIZE(mtu)) {
+		if (mv_eth_bm_config_pkt_size_get(new_pool->pool) != 0) {
+			printk(KERN_ERR "%s: BM pool #%d - pkt_size = %d less than required for MTU=%d and can't be changed\n",
+						__func__, new_pool->pool, new_pool->pkt_size, mtu);
+			return -EPERM;
+		}
+		/* Pool packet size can be changed for new MTU, but pool is shared */
+		if ((new_pool == pp->pool_long) && (pp->pool_long->port_map != (1 << pp->port))) {
+			/* Shared pool */
+			printk(KERN_ERR "%s: bmPool=%d is shared port_map=0x%x. Stop all ports uses this pool before change MTU\n",
+						__func__, pp->pool_long->pool, pp->pool_long->port_map);
+			return -EPERM;
+		}
+	}
+#endif /* CONFIG_MV_ETH_BM_CPU */
+	return 0;
+}
 
-#ifdef CONFIG_MV_ETH_POOL_PREDEFINED
-		/* Check if new MTU require pool change */
-		new_pool = mv_eth_pool_find(pp, RX_PKT_SIZE(mtu));
-		if (new_pool == NULL)
-			printk(KERN_ERR "%s FAILED: port=%d, Can't find pool for pkt_size=%d\n",
-					__func__, pp->port, RX_PKT_SIZE(mtu));
-#endif /* CONFIG_MV_ETH_POOL_PREDEFINED */
+/***********************************************************
+ * mv_eth_change_mtu_internals --                          *
+ *   stop port activity. release skb from rings. set new   *
+ *   mtu in device and hw. restart port activity and       *
+ *   and fill rx-buiffers with size according to new mtu.  *
+ ***********************************************************/
+int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
+{
+	struct bm_pool	*new_pool = NULL;
+	struct eth_port *pp = MV_ETH_PRIV(dev);
+	unsigned long	rwflags;
+
+	if ((mtu != dev->mtu) && (pp->pool_long)) {
+		/* If long pool assigned and MTU really changed and can't use old pool - free buffers */
+		write_lock_irqsave(&pp->rwlock, rwflags);
+
+#ifdef CONFIG_MV_ETH_BM_CPU
+		new_pool = mv_eth_long_pool_get(pp, RX_PKT_SIZE(mtu));
+#else
+		/* If BM is not used always free buffers */
+		new_pool = NULL;
+#endif /* CONFIG_MV_ETH_BM_CPU */
 
 		/* Free all buffers from long pool */
-		if ((pp->pool_long) && (pp->pool_long != new_pool)) {
+		if ((new_pool == NULL) || (new_pool->pkt_size < RX_PKT_SIZE(mtu)) || (pp->pool_long != new_pool) ||
+			((new_pool->pkt_size > RX_PKT_SIZE(mtu)) && (mv_eth_bm_config_pkt_size_get(new_pool->pool) == 0))) {
+			mv_eth_rx_reset(pp->port);
 			mv_eth_pool_free(pp->pool_long->pool, pp->pool_long_num);
 
+#ifdef CONFIG_MV_ETH_BM_CPU
 			/* redefine pool pkt_size */
-			if (new_pool == NULL) {
-				pp->pool_long->pkt_size = 0;
+			if (pp->pool_long->buf_num == 0) {
+				pp->pool_long->pkt_size = mv_eth_bm_config_pkt_size_get(pp->pool_long->pool);
+			if (pp->pool_long->pkt_size == 0)
 				mvBmPoolBufSizeSet(pp->pool_long->pool, 0);
+			else
+				mvBmPoolBufSizeSet(pp->pool_long->pool, RX_BUF_SIZE(pp->pool_long->pkt_size));
 			}
+#else
+			pp->pool_long->pkt_size = 0;
+#endif /* CONFIG_MV_ETH_BM_CPU */
 
+			pp->pool_long->port_map &= ~(1 << pp->port);
 			pp->pool_long = NULL;
 		}
 
@@ -4032,7 +4967,6 @@ int mv_eth_change_mtu_internals(struct n
 */
 		write_unlock_irqrestore(&pp->rwlock, rwflags);
 	}
-
 	dev->mtu = mtu;
 
 	mv_eth_netdev_set_features(dev);
@@ -4089,15 +5023,16 @@ static void mv_eth_cleanup_timer_callbac
 
 void mv_eth_mac_show(int port)
 {
-#ifdef CONFIG_MV_ETH_PNC_PARSER
-	mvOsPrintf("PnC MAC Rules - port #%d:\n", port);
-	pnc_mac_show();
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
-
-#ifdef CONFIG_MV_ETH_LEGACY_PARSER
+#ifdef CONFIG_MV_ETH_PNC
+	if (mv_eth_pnc_ctrl_en) {
+		mvOsPrintf("PnC MAC Rules - port #%d:\n", port);
+		pnc_mac_show();
+	} else
+		mvOsPrintf("%s: PNC control is disabled\n", __func__);
+#else /* Legacy parser */
 	mvEthPortUcastShow(port);
 	mvEthPortMcastShow(port);
-#endif /* CONFIG_MV_ETH_LEGACY_PARSER */
+#endif /* CONFIG_MV_ETH_PNC */
 }
 
 void mv_eth_tos_map_show(int port)
@@ -4105,11 +5040,12 @@ void mv_eth_tos_map_show(int port)
 	int tos, txq;
 	struct eth_port *pp = mv_eth_port_by_id(port);
 
-#ifdef CONFIG_MV_ETH_PNC_PARSER
-	pnc_ipv4_dscp_show();
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
-
-#ifdef CONFIG_MV_ETH_LEGACY_PARSER
+#ifdef CONFIG_MV_ETH_PNC
+	if (mv_eth_pnc_ctrl_en)
+		pnc_ipv4_dscp_show();
+	else
+		mvOsPrintf("%s: PNC control is disabled\n", __func__);
+#else
 	for (tos = 0; tos < 0xFF; tos += 0x4) {
 		int rxq;
 
@@ -4118,7 +5054,7 @@ void mv_eth_tos_map_show(int port)
 			printk(KERN_ERR "tos=0x%02x: codepoint=0x%02x, rxq=%d\n",
 					tos, tos >> 2, rxq);
 	}
-#endif /* CONFIG_MV_ETH_LEGACY_PARSER */
+#endif /* CONFIG_MV_ETH_PNC */
 
 	printk(KERN_ERR "\n");
 	printk(KERN_ERR " TOS <=> TXQ map for port #%d\n\n", port);
@@ -4134,13 +5070,14 @@ int mv_eth_rxq_tos_map_set(int port, int
 {
 	int status = 1;
 
-#ifdef CONFIG_MV_ETH_PNC_PARSER
-	status = pnc_ip4_dscp(tos, 0xFF, rxq);
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
-
-#ifdef CONFIG_MV_ETH_LEGACY_PARSER
+#ifdef CONFIG_MV_ETH_PNC
+	if (mv_eth_pnc_ctrl_en)
+		status = pnc_ip4_dscp(tos, 0xFF, rxq);
+	else
+		mvOsPrintf("%s: PNC control is disabled\n", __func__);
+#else /* Legacy parser */
 	status = mvNetaTosToRxqSet(port, tos, rxq);
-#endif /* CONFIG_MV_ETH_LEGACY_PARSER */
+#endif /* CONFIG_MV_ETH_PNC */
 
 	if (status == 0)
 		printk(KERN_ERR "Succeeded\n");
@@ -4152,6 +5089,21 @@ int mv_eth_rxq_tos_map_set(int port, int
 	return status;
 }
 
+int mv_eth_rxq_vlan_prio_set(int port, int rxq, unsigned char prio)
+{
+	int status = 1;
+
+#ifdef CONFIG_MV_ETH_PNC
+	if (mv_eth_pnc_ctrl_en)
+		status = pnc_vlan_set(prio, rxq);
+	else
+		mvOsPrintf("%s: PNC control is disabled\n", __func__);
+#else /* Legacy parser */
+#endif /* CONFIG_MV_ETH_PNC */
+
+	return status;
+}
+
 /* Set TXQ for special TOS value. txq=-1 - use default TXQ for this port */
 int mv_eth_txq_tos_map_set(int port, int txq, unsigned char tos)
 {
@@ -4207,22 +5159,19 @@ static int mv_eth_priv_init(struct eth_p
 		pp->txq[i] = CONFIG_MV_ETH_TXQ_DEF;
 
 	pp->flags = 0;
-	pp->pool_long_num = CONFIG_MV_ETH_RXQ * CONFIG_MV_ETH_RXQ_DESC * CONFIG_MV_ETH_MTU_PKT_MULT;
 
 #ifdef CONFIG_MV_ETH_BM_CPU
+	pp->pool_long_num = mv_eth_bm_config_long_buf_num_get(port);
 	if (pp->pool_long_num > MV_BM_POOL_CAP_MAX)
 		pp->pool_long_num = MV_BM_POOL_CAP_MAX;
 
-	pp->pool_short_num = CONFIG_MV_ETH_RXQ * CONFIG_MV_ETH_RXQ_DESC * CONFIG_MV_ETH_SHORT_PKT_MULT;
-	if (pp->pool_short_num > MV_BM_POOL_CAP_MAX / CONFIG_MV_ETH_PORTS_NUM)
-		pp->pool_short_num = MV_BM_POOL_CAP_MAX / CONFIG_MV_ETH_PORTS_NUM;
+	pp->pool_short_num = mv_eth_bm_config_short_buf_num_get(port);
+	if (pp->pool_short_num > MV_BM_POOL_CAP_MAX)
+		pp->pool_short_num = MV_BM_POOL_CAP_MAX;
+#else
+	pp->pool_long_num = CONFIG_MV_ETH_RXQ * CONFIG_MV_ETH_RXQ_DESC * 2;
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
-#ifdef CONFIG_MV_ETH_POOL_PREDEFINED
-	if (pp->pool_long_num > MV_BM_POOL_CAP_MAX / CONFIG_MV_ETH_PORTS_NUM)
-		pp->pool_long_num = MV_BM_POOL_CAP_MAX / CONFIG_MV_ETH_PORTS_NUM;
-#endif /* CONFIG_MV_ETH_POOL_PREDEFINED */
-
 	for (i = 0; i < 256; i++) {
 		pp->txq_tos_map[i] = MV_ETH_TXQ_INVALID;
 
@@ -4339,8 +5288,9 @@ void mv_eth_pool_status_print(int pool)
 	printk(KERN_ERR "\nRX Pool #%d: pkt_size=%d, BM-HW support - %s\n",
 	       pool, bm_pool->pkt_size, mv_eth_pool_bm(bm_pool) ? "Yes" : "No");
 
-	printk(KERN_ERR "bm_pool=%p, stack=%p, capacity=%d, buf_num=%d, missed=%d\n",
-	       bm_pool->bm_pool, bm_pool->stack, bm_pool->capacity, bm_pool->buf_num, bm_pool->missed);
+	printk(KERN_ERR "bm_pool=%p, stack=%p, capacity=%d, buf_num=%d, port_map=0x%x missed=%d\n",
+	       bm_pool->bm_pool, bm_pool->stack, bm_pool->capacity, bm_pool->buf_num,
+		   bm_pool->port_map, bm_pool->missed);
 
 #ifdef CONFIG_MV_ETH_STAT_ERR
 	printk(KERN_ERR "Errors: skb_alloc_oom=%u, stack_empty=%u, stack_full=%u\n",
@@ -4392,13 +5342,13 @@ void mv_eth_status_print(void)
 {
 	printk(KERN_ERR "totals: ports=%d, devs=%d\n", mv_eth_ports_num, mv_net_devs_num);
 
-#ifdef CONFIG_MV_ETH_NFP
-	printk(KERN_ERR "NFP         = %s\n", mv_ctrl_nfp ? "Enabled" : "Disabled");
-#endif
-
 #ifdef CONFIG_NET_SKB_RECYCLE
 	printk(KERN_ERR "SKB recycle = %s\n", mv_ctrl_recycle ? "Enabled" : "Disabled");
-#endif
+#endif /* CONFIG_NET_SKB_RECYCLE */
+
+#ifdef CONFIG_MV_ETH_PNC
+	printk(KERN_ERR "PnC control = %s\n", mv_eth_pnc_ctrl_en ? "Enabled" : "Disabled");
+#endif /* CONFIG_MV_ETH_PNC */
 }
 
 /***********************************************************************************
@@ -4421,6 +5371,14 @@ void mv_eth_port_status_print(unsigned i
 
 	mv_eth_link_status_print(port);
 
+#ifdef CONFIG_MV_ETH_NFP
+	printk(KERN_ERR "NFP = ");
+	if (pp->flags & MV_ETH_F_NFP_EN)
+		printk(KERN_CONT "Enabled\n");
+	else
+		printk(KERN_CONT "Disabled\n");
+#endif /* CONFIG_MV_ETH_NFP */
+
 	printk(KERN_ERR "rxq_coal(pkts)[ q]   = ");
 	for (q = 0; q < CONFIG_MV_ETH_RXQ; q++)
 		printk(KERN_CONT "%3d ", mvNetaRxqPktsCoalGet(port, q));
@@ -4542,6 +5500,7 @@ void mv_eth_port_stats_print(unsigned in
 	printk(KERN_CONT "\n-------------------------------\n");
 	printk(KERN_ERR "poll..........................%10u\n", stat->poll);
 	printk(KERN_ERR "poll_exit.....................%10u\n", stat->poll_exit);
+	printk(KERN_ERR "tx_fragmentation..............%10u\n", stat->tx_fragment);
 	printk(KERN_ERR "tx_done_event.................%10u\n", stat->tx_done);
 	printk(KERN_ERR "tx_done_timer_event...........%10u\n", stat->tx_done_timer);
 	printk(KERN_ERR "cleanup_timer_event...........%10u\n", stat->cleanup_timer);
@@ -4747,29 +5706,27 @@ static int mv_eth_port_cleanup(int port)
 	/* Free buffer pools */
 	if (pp->pool_long) {
 		mv_eth_pool_free(pp->pool_long->pool, pp->pool_long_num);
+		pp->pool_long->port_map &= ~(1 << pp->port);
 		pp->pool_long = NULL;
 	}
 #ifdef CONFIG_MV_ETH_BM_CPU
 	if (pp->pool_short) {
 		mv_eth_pool_free(pp->pool_short->pool, pp->pool_short_num);
+		pp->pool_short->port_map &= ~(1 << pp->port);
 		pp->pool_short = NULL;
 	}
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
 	/* Clear Marvell Header related modes - will be set again if needed on re-init */
 	mvNetaMhSet(port, MV_NETA_MH_NONE);
-#ifdef CONFIG_MV_ETH_NFP
-	mvNfpPortCapSet(port, NFP_P_MH, MV_FALSE);
-#endif
 
 	/* Clear any forced link, speed and duplex */
 	mv_force_port_link_speed_fc(port, MV_ETH_SPEED_AN, 0);
 
 	mvNetaPortDestroy(port);
 
-	if (pp->flags & MV_ETH_F_CONNECT_LINUX) {
-			netif_napi_del(pp->napi[CPU_GROUP_DEF]);
-	}
+	if (pp->flags & MV_ETH_F_CONNECT_LINUX)
+		netif_napi_del(pp->napiGroup[CPU_GROUP_DEF]);
 
 	return 0;
 }
@@ -4918,9 +5875,36 @@ int mv_eth_wol_sleep(int port)
 }
 #endif /* CONFIG_MV_ETH_PNC_WOL */
 
+
+#ifdef CONFIG_MV_PON
+/* PON link status api */
+PONLINKSTATUSPOLLFUNC pon_link_status_polling_func;
+
+void pon_link_status_notify_func(MV_BOOL link_state)
+{
+	struct eth_port *pon_port = mv_eth_port_by_id(MV_PON_PORT_ID_GET());
+	mv_eth_link_event(pon_port, 1);
+}
+
+/* called by PON module */
+void mv_pon_link_state_register(PONLINKSTATUSPOLLFUNC poll_func, PONLINKSTATUSNOTIFYFUNC *notify_func)
+{
+	pon_link_status_polling_func = poll_func;
+	*notify_func = pon_link_status_notify_func;
+}
+
+MV_BOOL mv_pon_link_status(void)
+{
+	if (pon_link_status_polling_func != NULL)
+		return pon_link_status_polling_func();
+	printk(KERN_ERR "pon_link_status_polling_func is uninitialized\n");
+	return MV_FALSE;
+}
+#endif /* CONFIG_MV_PON */
+
 /* Support for platform driver */
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_CPU_IDLE
 int mv_eth_suspend(struct platform_device *pdev, pm_message_t state)
 {
 #ifdef CONFIG_MV_ETH_PNC_WOL
@@ -4950,7 +5934,7 @@ int mv_eth_resume(struct platform_device
 #endif /* CONFIG_MV_ETH_PNC_WOL */
 	return 0;
 }
-#endif /* CONFIG_PM */
+#endif /* CONFIG_CPU_IDLE */
 
 static int mv_eth_remove(struct platform_device *pdev)
 {
@@ -4967,10 +5951,10 @@ static struct platform_driver mv_eth_dri
 	.probe = mv_eth_probe,
 	.remove = mv_eth_remove,
 	.shutdown = mv_eth_shutdown,
-#ifdef CONFIG_PM
+#ifdef CONFIG_CPU_IDLE
 	.suspend = mv_eth_suspend,
 	.resume = mv_eth_resume,
-#endif /* CONFIG_PM */
+#endif /* CONFIG_CPU_IDLE */
 	.driver = {
 		.name = "mv88fx_neta",
 	},
@@ -4978,6 +5962,13 @@ static struct platform_driver mv_eth_dri
 
 static int __init mv_eth_init_module(void)
 {
+#ifdef CONFIG_MV_ETH_NFP
+#ifdef CONFIG_MV_ETH_NFP_LIB
+	printk(KERN_INFO "Using NFP lib\n");
+#endif /* CONFIG_MV_ETH_NFP_LIB */
+	nfp_sysfs_init();
+#endif /* CONFIG_MV_ETH_NFP */
+
 	return platform_driver_register(&mv_eth_driver);
 }
 module_init(mv_eth_init_module);
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
@@ -68,6 +68,11 @@ disclaimer.
 #define STAT_DIST(c)
 #endif
 
+#ifdef CONFIG_MV_ETH_PNC
+extern unsigned int mv_eth_pnc_ctrl_en;
+int mv_eth_ctrl_pnc(int en);
+#endif /* CONFIG_MV_ETH_PNC */
+
 /****************************************************************************
  * Rx buffer size: MTU + 2(Marvell Header) + 4(VLAN) + 14(MAC hdr) + 4(CRC) *
  ****************************************************************************/
@@ -111,7 +116,6 @@ disclaimer.
 /******************************************************
  * rx / tx queues --                                  *
  ******************************************************/
-#define NR_GROUPS 4
 /*
  * Debug statistics
  */
@@ -141,6 +145,7 @@ struct port_stats {
 	u32 irq_err;
 	u32 poll;
 	u32 poll_exit;
+	u32 tx_fragment;
 	u32 tx_done;
 	u32 tx_done_timer;
 	u32 cleanup_timer;
@@ -172,9 +177,9 @@ struct port_stats {
 	u32 tx_skb_free;
 	u32 tx_sg;
 	u32 tx_tso;
+	u32 tx_tso_bytes;
 	u32 ext_stack_put;
 	u32 ext_stack_get;
-	u32 tx_tso_bytes;
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 };
 
@@ -183,35 +188,37 @@ struct port_stats {
 #define MV_ETH_SHADOW_EXT		0x2
 
 /* Masks used for pp->flags */
-#define MV_ETH_F_STARTED_BIT		0
-#define MV_ETH_F_TX_DONE_TIMER_BIT	1
-#define MV_ETH_F_SWITCH_BIT		2	/* port is connected to the Switch using the Gateway driver */
-#define MV_ETH_F_MH_BIT			3
-#define MV_ETH_F_NO_PAD_BIT		4
-#define MV_ETH_F_DBG_RX_BIT		5
-#define MV_ETH_F_DBG_TX_BIT		6
-#define MV_ETH_F_EXT_SWITCH_BIT		7	/* port is connected to the Switch without the Gateway driver */
-#define MV_ETH_F_CONNECT_LINUX_BIT	8	/* port is connected to Linux netdevice */
-#define MV_ETH_F_LINK_UP_BIT		9
-#define MV_ETH_F_DBG_DUMP_BIT		10
-#define MV_ETH_F_DBG_ISR_BIT		11
-#define MV_ETH_F_DBG_POLL_BIT		12
-#define MV_ETH_F_CLEANUP_TIMER_BIT	13
-
-#define MV_ETH_F_STARTED		(1 << MV_ETH_F_STARTED_BIT)		/* 0x01 */
-#define MV_ETH_F_TX_DONE_TIMER		(1 << MV_ETH_F_TX_DONE_TIMER_BIT)	/* 0x02 */
-#define MV_ETH_F_SWITCH			(1 << MV_ETH_F_SWITCH_BIT)		/* 0x04 */
-#define MV_ETH_F_MH			(1 << MV_ETH_F_MH_BIT)			/* 0x08 */
-#define MV_ETH_F_NO_PAD			(1 << MV_ETH_F_NO_PAD_BIT)		/* 0x10 */
-#define MV_ETH_F_DBG_RX			(1 << MV_ETH_F_DBG_RX_BIT)		/* 0x20 */
-#define MV_ETH_F_DBG_TX			(1 << MV_ETH_F_DBG_TX_BIT)		/* 0x40 */
-#define MV_ETH_F_EXT_SWITCH		(1 << MV_ETH_F_EXT_SWITCH_BIT)		/* 0x80 */
-#define MV_ETH_F_CONNECT_LINUX		(1 << MV_ETH_F_CONNECT_LINUX_BIT)	/* 0x100 */
-#define MV_ETH_F_LINK_UP		(1 << MV_ETH_F_LINK_UP_BIT)		/* 0x200 */
-#define MV_ETH_F_DBG_DUMP		(1 << MV_ETH_F_DBG_DUMP_BIT)		/* 0x400 */
-#define MV_ETH_F_DBG_ISR		(1 << MV_ETH_F_DBG_ISR_BIT)		/* 0x800 */
-#define MV_ETH_F_DBG_POLL		(1 << MV_ETH_F_DBG_POLL_BIT)		/* 0x1000 */
-#define MV_ETH_F_CLEANUP_TIMER		(1 << MV_ETH_F_CLEANUP_TIMER_BIT)	/* 0x2000 */
+#define MV_ETH_F_STARTED_BIT        0
+#define MV_ETH_F_TX_DONE_TIMER_BIT  1
+#define MV_ETH_F_SWITCH_BIT         2	/* port is connected to the Switch using the Gateway driver */
+#define MV_ETH_F_MH_BIT             3
+#define MV_ETH_F_NO_PAD_BIT         4
+#define MV_ETH_F_DBG_RX_BIT         5
+#define MV_ETH_F_DBG_TX_BIT         6
+#define MV_ETH_F_EXT_SWITCH_BIT	    7	/* port is connected to the Switch without the Gateway driver */
+#define MV_ETH_F_CONNECT_LINUX_BIT  8	/* port is connected to Linux netdevice */
+#define MV_ETH_F_LINK_UP_BIT        9
+#define MV_ETH_F_DBG_DUMP_BIT       10
+#define MV_ETH_F_DBG_ISR_BIT        11
+#define MV_ETH_F_DBG_POLL_BIT       12
+#define MV_ETH_F_CLEANUP_TIMER_BIT  13
+#define MV_ETH_F_NFP_EN_BIT         14
+
+#define MV_ETH_F_STARTED           (1 << MV_ETH_F_STARTED_BIT)		/* 0x01 */
+#define MV_ETH_F_TX_DONE_TIMER     (1 << MV_ETH_F_TX_DONE_TIMER_BIT)	/* 0x02 */
+#define MV_ETH_F_SWITCH            (1 << MV_ETH_F_SWITCH_BIT)		/* 0x04 */
+#define MV_ETH_F_MH                (1 << MV_ETH_F_MH_BIT)			/* 0x08 */
+#define MV_ETH_F_NO_PAD            (1 << MV_ETH_F_NO_PAD_BIT)		/* 0x10 */
+#define MV_ETH_F_DBG_RX            (1 << MV_ETH_F_DBG_RX_BIT)		/* 0x20 */
+#define MV_ETH_F_DBG_TX            (1 << MV_ETH_F_DBG_TX_BIT)		/* 0x40 */
+#define MV_ETH_F_EXT_SWITCH        (1 << MV_ETH_F_EXT_SWITCH_BIT)		/* 0x80 */
+#define MV_ETH_F_CONNECT_LINUX     (1 << MV_ETH_F_CONNECT_LINUX_BIT)	/* 0x100 */
+#define MV_ETH_F_LINK_UP           (1 << MV_ETH_F_LINK_UP_BIT)		/* 0x200 */
+#define MV_ETH_F_DBG_DUMP          (1 << MV_ETH_F_DBG_DUMP_BIT)		/* 0x400 */
+#define MV_ETH_F_DBG_ISR           (1 << MV_ETH_F_DBG_ISR_BIT)		/* 0x800 */
+#define MV_ETH_F_DBG_POLL          (1 << MV_ETH_F_DBG_POLL_BIT)		/* 0x1000 */
+#define MV_ETH_F_CLEANUP_TIMER     (1 << MV_ETH_F_CLEANUP_TIMER_BIT)	/* 0x2000 */
+#define MV_ETH_F_NFP_EN            (1 << MV_ETH_F_NFP_EN_BIT)		/* 0x4000 */
 
 
 /* One of three TXQ states */
@@ -283,8 +290,7 @@ struct eth_port {
 #endif /* CONFIG_MV_ETH_BM_CPU */
 	MV_U32              causeRxTx[CONFIG_NR_CPUS];
 	struct napi_struct  *napi[CONFIG_NR_CPUS];
-	struct napi_struct  *napiGroup[NR_GROUPS];	
-	
+	struct napi_struct  *napiGroup[CONFIG_MV_ETH_NAPI_GROUPS];
 	unsigned long       flags;	/* MH, TIMER, etc. */
 	u32                 hw_cmd;	/* offset 0xc in TX descriptor */
 	int                 txp;
@@ -314,7 +320,6 @@ struct eth_port {
 	int     (*tx_special_check)(int port, struct net_device *dev, struct sk_buff *skb,
 					struct mv_eth_tx_spec *tx_spec_out);
 #endif /* CONFIG_MV_ETH_TX_SPECIAL */
-	int cesaChan;
 };
 
 struct eth_netdev {
@@ -339,6 +344,8 @@ struct eth_dev_priv {
 #define SWITCH_CONNECTED_PORTS_MASK	0x7F
 
 #define MV_SWITCH_ID_0			0
+#define MV_ETH_PORT_0			0
+#define MV_ETH_PORT_1			1
 
 struct pool_stats {
 #ifdef CONFIG_MV_ETH_STAT_ERR
@@ -365,21 +372,32 @@ struct bm_pool {
 	u32         *bm_pool;
 	MV_STACK    *stack;
 	spinlock_t  lock;
+	u32         port_map;
 	int         missed;		/* FIXME: move to stats */
 	struct pool_stats  stats;
 };
 
 #ifdef CONFIG_MV_ETH_BM_CPU
 #define MV_ETH_BM_POOLS	        MV_BM_POOLS
-#define MV_ETH_SHORT_BM_POOL    (MV_BM_POOLS - 1)
 #define mv_eth_pool_bm(p)       (p->bm_pool)
 #define mv_eth_txq_bm(q)        (q->bm_only)
 #else
-#define MV_ETH_BM_POOLS			CONFIG_MV_ETH_PORTS_NUM
+#define MV_ETH_BM_POOLS		CONFIG_MV_ETH_PORTS_NUM
 #define mv_eth_pool_bm(p)       0
 #define mv_eth_txq_bm(q)        0
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
+#ifdef CONFIG_MV_ETH_BM
+MV_STATUS mv_eth_bm_config_get(void);
+int mv_eth_bm_config_pkt_size_get(int pool);
+int mv_eth_bm_config_pkt_size_set(int pool, int pkt_size);
+int mv_eth_bm_config_short_pool_get(int port);
+int mv_eth_bm_config_short_buf_num_get(int port);
+int mv_eth_bm_config_long_pool_get(int port);
+int mv_eth_bm_config_long_buf_num_get(int port);
+void mv_eth_bm_config_print(void);
+#endif /* CONFIG_MV_ETH_BM */
+
 extern struct bm_pool mv_eth_pool[MV_ETH_BM_POOLS];
 extern struct eth_port **mv_eth_ports;
 
@@ -416,10 +434,10 @@ struct mv_eth_switch_config {
 };
 
 extern int  mv_eth_switch_netdev_first, mv_eth_switch_netdev_last;
-extern struct mv_eth_switch_config      switch_net_config;
+extern struct mv_eth_switch_config      switch_net_config[CONFIG_MV_ETH_PORTS_NUM];
 extern struct net_device **mv_net_devs;
 
-int     mv_eth_switch_config_get(int use_existing_config);
+int     mv_eth_switch_config_get(int use_existing_config, int port);
 int     mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac);
 void    mv_eth_switch_set_multicast_list(struct net_device *dev);
 int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu);
@@ -436,9 +454,13 @@ int     mv_eth_switch_port_del(struct ne
  ******************************************************/
 int         mv_eth_stop(struct net_device *dev);
 int         mv_eth_change_mtu(struct net_device *dev, int mtu);
+int         mv_eth_check_mtu_internals(struct net_device *dev, int mtu);
+int         mv_eth_check_mtu_valid(struct net_device *dev, int mtu);
+
 int         mv_eth_set_mac_addr(struct net_device *dev, void *mac);
 void        mv_eth_set_multicast_list(struct net_device *dev);
 int         mv_eth_open(struct net_device *dev);
+int         mv_eth_ctrl_nfp(struct net_device *dev, int en);
 
 irqreturn_t mv_eth_isr(int irq, void *dev_id);
 int         mv_eth_start_internals(struct eth_port *pp, int mtu);
@@ -454,12 +476,15 @@ MV_STATUS   mv_eth_tx_done_ptks_coal_set
 
 struct eth_port     *mv_eth_port_by_id(unsigned int port);
 struct net_device   *mv_eth_netdev_by_id(unsigned int idx);
+bool                 mv_eth_netdev_find(unsigned int if_index);
 
 void        mv_eth_mac_show(int port);
 void        mv_eth_tos_map_show(int port);
 int         mv_eth_rxq_tos_map_set(int port, int rxq, unsigned char tos);
 int         mv_eth_txq_tos_map_set(int port, int txq, unsigned char tos);
 
+int         mv_eth_rxq_vlan_prio_set(int port, int rxq, unsigned char prio);
+
 void        mv_eth_netdev_print(struct net_device *netdev);
 void        mv_eth_status_print(void);
 void        mv_eth_port_status_print(unsigned int port);
@@ -467,7 +492,8 @@ void        mv_eth_port_stats_print(unsi
 
 void        mv_eth_set_noqueue(struct net_device *dev, int enable);
 
-void        mv_eth_ctrl_nfp(int en);
+void        mv_eth_ctrl_hwf(int en);
+
 void        mv_eth_ctrl_recycle(int en);
 void        mv_eth_ctrl_txdone(int num);
 int         mv_eth_ctrl_tx_mh(int port, u16 mh);
@@ -480,6 +506,7 @@ int         mv_eth_ctrl_flag(int port, u
 int         mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int value);
 int         mv_eth_ctrl_rxq_size_set(int port, int rxq, int value);
 int         mv_eth_ctrl_port_buf_num_set(int port, int long_num, int short_num);
+int         mv_eth_ctrl_pool_size_set(int pool, int pkt_size);
 int         mv_eth_ctrl_set_poll_rx_weight(int port, u32 weight);
 
 void        mv_eth_tx_desc_print(struct neta_tx_desc *desc);
@@ -489,9 +516,15 @@ void        mv_eth_skb_print(struct sk_b
 void        mv_eth_link_status_print(int port);
 
 #ifdef CONFIG_MV_PON
-void        mv_pon_ctrl_omci_type(MV_U16 type);
-void        mv_pon_ctrl_omci_rx_gh(int en);
-void        mv_pon_omci_print(void);
+typedef MV_BOOL(*PONLINKSTATUSPOLLFUNC)(void);		  /* prototype for PON link status polling function */
+typedef void   (*PONLINKSTATUSNOTIFYFUNC)(MV_BOOL state); /* prototype for PON link status notification function */
+
+MV_BOOL mv_pon_link_status(void);
+void mv_pon_link_state_register(PONLINKSTATUSPOLLFUNC poll_func, PONLINKSTATUSNOTIFYFUNC *notify_func);
+void mv_pon_ctrl_omci_type(MV_U16 type);
+void mv_pon_ctrl_omci_rx_gh(int en);
+void mv_pon_omci_print(void);
+
 #endif /* CONFIG_MV_PON */
 
 #ifdef CONFIG_MV_ETH_TX_SPECIAL
@@ -528,9 +561,9 @@ inline struct neta_rx_desc *mv_eth_rx_pr
 void	*mv_eth_bm_pool_create(int pool, int capacity, MV_ULONG *physAddr);
 #endif /* CONFIG_MV_ETH_BM */
 
-#ifdef CONFIG_MV_ETH_HWF
+#if defined(CONFIG_MV_ETH_HWF) && !defined(CONFIG_MV_ETH_BM_CPU)
 MV_STATUS mv_eth_hwf_bm_create(int port, int mtuPktSize);
 void      mv_hwf_bm_dump(void);
-#endif /* CONFIG_MV_ETH_HWF */
+#endif /* CONFIG_MV_ETH_HWF && !CONFIG_MV_ETH_BM_CPU */
 
 #endif /* __mv_netdev_h__ */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/nfp_mgr/mv_nfp_mgr_if.h
@@ -0,0 +1,40 @@
+/* mv_nfp_mgr_if.h */
+
+#ifndef MV_NFP_MGR_IF_H
+#define MV_NFP_MGR_IF_H
+
+/* Enable / disable NFP processing according to mode	*/
+/* mode - NFP operation mode:				*/
+/*        0 - NFP disabled				*/
+/*        1 - NFP enabled in 2 tuple mode		*/
+/*        2 - NFP enabled in 5 tuple mode		*/
+int  nfp_mgr_enable(int mode);
+
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN) || defined(CONFIG_MV_ETH_NFP_VLAN_LEARN) || defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)||\
+		defined(CONFIG_MV_ETH_NFP_PPP_LEARN) || defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+void nfp_learn_enable(int en);
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_FIB_LEARN
+void nfp_fib_learn_enable(int en);
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_CT_LEARN
+void nfp_ct_learn_enable(int en);
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_BRIDGE_LEARN
+void nfp_bridge_learn_enable(int en);
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_VLAN_LEARN
+void nfp_vlan_learn_enable(int en);
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_PPP_LEARN
+void nfp_ppp_learn_enable(int en);
+#endif
+
+extern rwlock_t nfp_lock;
+#endif
+
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/pmt/pmt_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/pmt/pmt_sysfs.c
@@ -34,111 +34,233 @@ disclaimer.
 
 #include "pmt/mvPmt.h"
 
+static MV_NETA_PMT  mv_neta_pmt_e;
+
 static ssize_t pmt_help(char *buf)
 {
 	int off = 0;
 
-	off += mvOsSPrintf(buf+off, "echo p         > hw_dump   - dump PMT on port <p>\n");
-	off += mvOsSPrintf(buf+off, "echo p         > hw_init   - init PMT on port <p>\n");
-	off += mvOsSPrintf(buf+off, "echo p i a b c > hw_write  - add {a,b,c} into port <p> entry <i>\n");
-	off += mvOsSPrintf(buf+off, "echo p i       > hw_read   - read entry <i> on port <p>\n");
-	off += mvOsSPrintf(buf+off, "echo p i       > hw_inv    - disable entry <i> on port <p>\n");
-   	off += mvOsSPrintf(buf+off, "echo p txp     > hw_regs   - show PM registers\n");
-   	off += mvOsSPrintf(buf+off, "echo p txp i v > mh_reg    - set MH register <i=0..5> with value <v>\n");
-   	off += mvOsSPrintf(buf+off, "echo p txp i v > eth_reg   - set ETH register <i=0..3> with value <v>\n");
+	off += mvOsSPrintf(buf+off, "p, i, a, b, c - are dec numbers\n");
+	off += mvOsSPrintf(buf+off, "v, m          - are hex numbers\n");
+	off += mvOsSPrintf(buf+off, "\n");
+
+	off += mvOsSPrintf(buf+off, "cat          help          - Show this help\n");
+	off += mvOsSPrintf(buf+off, "cat          sw_dump       - Show sw PMT etry\n");
+	off += mvOsSPrintf(buf+off, "cat          sw_clear      - Clear sw PMT etry\n");
+	off += mvOsSPrintf(buf+off, "echo v     > sw_word       - Set 4 bytes value <v> to sw entry\n");
+	off += mvOsSPrintf(buf+off, "echo p     > hw_regs       - Show PMT registers\n");
+	off += mvOsSPrintf(buf+off, "echo p     > hw_dump       - Dump valid PMT entries of the port <p>\n");
+	off += mvOsSPrintf(buf+off, "echo p     > hw_dump_all   - Dump all PMT entries of the port <p>\n");
+	off += mvOsSPrintf(buf+off, "echo p i   > hw_read       - Read PMT entry <i> on port <p> into sw entry\n");
+	off += mvOsSPrintf(buf+off, "echo p i   > hw_write      - Write sw entry into PMT entry <i> on port <p>\n");
+	off += mvOsSPrintf(buf+off, "echo p i   > hw_inv        - Disable PMT entry <i> on port <p>\n");
+	off += mvOsSPrintf(buf+off, "echo p     > hw_inv_all    - Disable all PMT entries on port <p>\n");
+	off += mvOsSPrintf(buf+off, "echo 0|1   > s_last        - Set/Clear last bit\n");
+	off += mvOsSPrintf(buf+off, "echo a b c > s_flags       - Set/Clear flags: <a>-last, <b>-ipv4csum, <c>-l4csum\n");
+	off += mvOsSPrintf(buf+off, "echo v     > s_rep_2b      - Replace 2 bytes with value <v>\n");
+	off += mvOsSPrintf(buf+off, "echo v     > s_add_2b      - Add 2 bytes with value <v> to sw entry\n");
+	off += mvOsSPrintf(buf+off, "echo a b c > s_del_2b      - Delete <a> bytes, Skip <b> bytes before, Skip <c> bytes after\n");
+	off += mvOsSPrintf(buf+off, "echo v m   > s_rep_lsb     - Replace LSB with value <v> and mask <m>\n");
+	off += mvOsSPrintf(buf+off, "echo v m   > s_rep_msb     - Replace MSB with value <v> and mask <m>\n");
+	off += mvOsSPrintf(buf+off, "echo v     > s_ip_csum     - Replace IP checksum. <v> used as additional info\n");
+	off += mvOsSPrintf(buf+off, "echo v     > s_l4_csum     - Replace TCP/UDP checksum. <v> used as additional info\n");
+	off += mvOsSPrintf(buf+off, "echo a b   > s_dec_lsb     - Decrement LSB, Skip <a> bytes before, Skip <b> bytes after\n");
+	off += mvOsSPrintf(buf+off, "echo a b   > s_dec_msb     - Decrement MSB, Skip <a> bytes before, Skip <b> bytes after\n");
+	off += mvOsSPrintf(buf+off, "echo a     > s_skip        - Skip <a> bytes. Must be even\n");
+	off += mvOsSPrintf(buf+off, "echo a b c > s_jump        - Jump to entry <a>. <b>=1-skip,2-subroutine. <c>=1-green,2-yellow\n");
 
 	return off;
 }
 
-static ssize_t pmt_show(struct device *dev, 
-				  struct device_attribute *attr, char *buf)
+static ssize_t pmt_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
 {
-	const char* name = attr->attr.name;
+	const char  *name = attr->attr.name;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	if (!strcmp(name, "help")) 
+	if (!strcmp(name, "help"))
 		return pmt_help(buf);
 
+	if (!strcmp(name, "sw_dump")) {
+		mvNetaPmtEntryPrint(&mv_neta_pmt_e);
+	} else if (!strcmp(name, "sw_clear")) {
+		MV_NETA_PMT_CLEAR(&mv_neta_pmt_e);
+	}
+
 	return 0;
 }
 
-static ssize_t pmt_store(struct device *dev, 
-				   struct device_attribute *attr, const char *buf, size_t len)
+static ssize_t pmt_hw_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
 {
-    const char* name = attr->attr.name;
-	unsigned int err=0, p=0, i=0, a=0, b=0, c=0;
+	const char    *name = attr->attr.name;
+	unsigned int  err = 0, p = 0, i = 0;
 	unsigned long flags;
-	struct mv_neta_pmt_t pmt_e;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	sscanf(buf,"%x %x %x %x %x",&p, &i, &a, &b, &c);
+	sscanf(buf, "%d %d", &p, &i);
 
 	local_irq_save(flags);
 
-	if (!strcmp(name, "hw_dump"))
-		err = mvNetaPmtDump(p);
-	else if (!strcmp(name, "hw_regs"))
+	if (!strcmp(name, "hw_dump")) {
+		mvNetaPmtDump(p, 1);
+	} else if (!strcmp(name, "hw_dump_all")) {
+		mvNetaPmtDump(p, 0);
+	} else if (!strcmp(name, "hw_regs")) {
 		mvNetaPmtRegs(p, i);
-	else if (!strcmp(name, "hw_init"))
-		err = mvNetaPmtInit(p);
-	else if (!strcmp(name, "hw_write")) {
-		pmt_e.mt_w0 = a;
-		pmt_e.mt_w1 = b;
-		pmt_e.mt_w2 = c;
-		err = mvNetaPmtWrite(p, i, &pmt_e);
-	}
-	else if (!strcmp(name, "hw_read")) {
-		memset(&pmt_e, 0, sizeof(struct mv_neta_pmt_t));
-        err = mvNetaPmtRead(p, i, &pmt_e);
-		printk("%x %x %x\n", pmt_e.mt_w0, pmt_e.mt_w1, pmt_e.mt_w2);
-	}
-	else if (!strcmp(name, "hw_inv")) {
-		memset(&pmt_e, 0, sizeof(struct mv_neta_pmt_t));
-        err = mvNetaPmtWrite(p, i, &pmt_e);
-	}
-	else if (!strcmp(name, "mh_reg")) {
-		memset(&pmt_e, 0, sizeof(struct mv_neta_pmt_t));
-        err = mvNetaPmtMhRegSet(p, i, a, b);
-	}
-	else if (!strcmp(name, "eth_reg")) {
-		memset(&pmt_e, 0, sizeof(struct mv_neta_pmt_t));
-        err = mvNetaPmtEthTypeRegSet(p, i, a, b);
-	}
-	else 
-		printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
+	} else if (!strcmp(name, "hw_write")) {
+		err = mvNetaPmtWrite(p, i, &mv_neta_pmt_e);
+	} else if (!strcmp(name, "hw_read")) {
+		err = mvNetaPmtRead(p, i, &mv_neta_pmt_e);
+	} else if (!strcmp(name, "hw_inv")) {
+		MV_NETA_PMT_INVALID_SET(&mv_neta_pmt_e);
+		err = mvNetaPmtWrite(p, i, &mv_neta_pmt_e);
+	} else if (!strcmp(name, "hw_inv_all")) {
+		err = mvNetaPmtClear(p);
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t pmt_sw_dec_store(struct device *dev,
+			struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char	*name = attr->attr.name;
+	unsigned int    err = 0, a = 0, b = 0, c = 0;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%d %d %d", &a, &b, &c);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "s_last")) {
+		mvNetaPmtLastFlag(&mv_neta_pmt_e, a);
+	} else if (!strcmp(name, "s_flags")) {
+		mvNetaPmtFlags(&mv_neta_pmt_e, a, b, c);
+	} else if (!strcmp(name, "s_del")) {
+		mvNetaPmtDelShorts(&mv_neta_pmt_e, a/2, b/2, c/2);
+	} else if (!strcmp(name, "s_skip")) {
+		mvNetaPmtSkip(&mv_neta_pmt_e, a/2);
+	} else if (!strcmp(name, "s_dec_lsb")) {
+		mvNetaPmtDecLSB(&mv_neta_pmt_e, a/2, b/2);
+	} else if (!strcmp(name, "s_dec_msb")) {
+		mvNetaPmtDecMSB(&mv_neta_pmt_e, a/2, b/2);
+	} else if (!strcmp(name, "s_jump")) {
+		mvNetaPmtJump(&mv_neta_pmt_e, a, b, c);
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t pmt_sw_hex_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char	*name = attr->attr.name;
+	unsigned int    err = 0, v = 0, a = 0;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%x %d", &v, &a);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "sw_word")) {
+		mv_neta_pmt_e.word = v;
+	} else if (!strcmp(name, "s_rep_2b")) {
+		mvNetaPmtReplace2Bytes(&mv_neta_pmt_e, v);
+	} else if (!strcmp(name, "s_add_2b")) {
+		mvNetaPmtAdd2Bytes(&mv_neta_pmt_e, v);
+	} else if (!strcmp(name, "s_rep_lsb")) {
+		mvNetaPmtReplaceLSB(&mv_neta_pmt_e, v, a);
+	} else if (!strcmp(name, "s_rep_msb")) {
+		mvNetaPmtReplaceMSB(&mv_neta_pmt_e, v, a);
+	} else if (!strcmp(name, "s_ip_csum")) {
+		mvNetaPmtReplaceIPv4csum(&mv_neta_pmt_e, v);
+	} else if (!strcmp(name, "s_l4_csum")) {
+		mvNetaPmtReplaceL4csum(&mv_neta_pmt_e, v);
+	} else
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
 
 	local_irq_restore(flags);
 
-	if (err) 
-		printk("%s: <%s>, error %d\n", __FUNCTION__, attr->attr.name, err);
-	
+	if (err)
+		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
+
 	return err ? -EINVAL : len;
 }
 
-static DEVICE_ATTR(mh_reg,  S_IWUSR, pmt_show, pmt_store);
-static DEVICE_ATTR(eth_reg, S_IWUSR, pmt_show, pmt_store);
-static DEVICE_ATTR(hw_write,S_IWUSR, pmt_show, pmt_store);
-static DEVICE_ATTR(hw_read, S_IWUSR, pmt_show, pmt_store);
-static DEVICE_ATTR(hw_dump, S_IWUSR, pmt_show, pmt_store);
-static DEVICE_ATTR(hw_regs, S_IWUSR, pmt_show, pmt_store);
-static DEVICE_ATTR(hw_init, S_IWUSR, pmt_show, pmt_store);
-static DEVICE_ATTR(hw_inv,  S_IWUSR, pmt_show, pmt_store);
-static DEVICE_ATTR(help,    S_IRUSR, pmt_show, pmt_store);
+static DEVICE_ATTR(help,        S_IRUSR, pmt_show, NULL);
+static DEVICE_ATTR(sw_dump,     S_IRUSR, pmt_show, NULL);
+static DEVICE_ATTR(sw_clear,    S_IRUSR, pmt_show, NULL);
+static DEVICE_ATTR(hw_regs,     S_IWUSR, pmt_show, pmt_hw_store);
+static DEVICE_ATTR(hw_write,    S_IWUSR, pmt_show, pmt_hw_store);
+static DEVICE_ATTR(hw_read,     S_IWUSR, pmt_show, pmt_hw_store);
+static DEVICE_ATTR(hw_dump,     S_IWUSR, pmt_show, pmt_hw_store);
+static DEVICE_ATTR(hw_dump_all, S_IWUSR, pmt_show, pmt_hw_store);
+static DEVICE_ATTR(hw_inv,      S_IWUSR, pmt_show, pmt_hw_store);
+static DEVICE_ATTR(hw_inv_all,  S_IWUSR, pmt_show, pmt_hw_store);
+static DEVICE_ATTR(sw_word,     S_IWUSR, pmt_show, pmt_sw_hex_store);
+static DEVICE_ATTR(s_rep_2b,    S_IWUSR, pmt_show, pmt_sw_hex_store);
+static DEVICE_ATTR(s_rep_lsb,   S_IWUSR, pmt_show, pmt_sw_hex_store);
+static DEVICE_ATTR(s_rep_msb,   S_IWUSR, pmt_show, pmt_sw_hex_store);
+static DEVICE_ATTR(s_ip_csum,   S_IWUSR, pmt_show, pmt_sw_hex_store);
+static DEVICE_ATTR(s_l4_csum,   S_IWUSR, pmt_show, pmt_sw_hex_store);
+static DEVICE_ATTR(s_dec_lsb,   S_IWUSR, pmt_show, pmt_sw_dec_store);
+static DEVICE_ATTR(s_dec_msb,   S_IWUSR, pmt_show, pmt_sw_dec_store);
+static DEVICE_ATTR(s_add_2b,    S_IWUSR, pmt_show, pmt_sw_hex_store);
+static DEVICE_ATTR(s_del,       S_IWUSR, pmt_show, pmt_sw_dec_store);
+static DEVICE_ATTR(s_last,      S_IWUSR, pmt_show, pmt_sw_dec_store);
+static DEVICE_ATTR(s_flags,     S_IWUSR, pmt_show, pmt_sw_dec_store);
+static DEVICE_ATTR(s_skip,      S_IWUSR, pmt_show, pmt_sw_dec_store);
+static DEVICE_ATTR(s_jump,      S_IWUSR, pmt_show, pmt_sw_dec_store);
+
 
 static struct attribute *pmt_attrs[] = {
-	&dev_attr_mh_reg.attr,
-	&dev_attr_eth_reg.attr,
+	&dev_attr_help.attr,
+	&dev_attr_sw_dump.attr,
+	&dev_attr_sw_clear.attr,
+	&dev_attr_hw_regs.attr,
 	&dev_attr_hw_write.attr,
 	&dev_attr_hw_read.attr,
 	&dev_attr_hw_dump.attr,
-	&dev_attr_hw_regs.attr,
-	&dev_attr_hw_init.attr,
+	&dev_attr_hw_dump_all.attr,
 	&dev_attr_hw_inv.attr,
-	&dev_attr_help.attr,
+	&dev_attr_hw_inv_all.attr,
+	&dev_attr_sw_word.attr,
+	&dev_attr_s_rep_2b.attr,
+	&dev_attr_s_add_2b.attr,
+	&dev_attr_s_del.attr,
+	&dev_attr_s_rep_lsb.attr,
+	&dev_attr_s_rep_msb.attr,
+	&dev_attr_s_ip_csum.attr,
+	&dev_attr_s_l4_csum.attr,
+	&dev_attr_s_dec_lsb.attr,
+	&dev_attr_s_dec_msb.attr,
+	&dev_attr_s_last.attr,
+	&dev_attr_s_flags.attr,
+	&dev_attr_s_skip.attr,
+	&dev_attr_s_jump.attr,
 	NULL
 };
 
@@ -159,7 +281,7 @@ int __devinit pmt_sysfs_init(void)
 		}
 
 		if (!pd) {
-			printk(KERN_ERR"%s: cannot find neta device\n", __FUNCTION__);
+			printk(KERN_ERR"%s: cannot find neta device\n", __func__);
 			pd = &platform_bus;
 		}
 
@@ -172,9 +294,9 @@ out:
 		return err;
 }
 
-module_init(pmt_sysfs_init); 
+module_init(pmt_sysfs_init);
 
-MODULE_AUTHOR("Kostya Belezko");
+MODULE_AUTHOR("Dima Epshtein");
 MODULE_DESCRIPTION("PMT for Marvell NetA MV65xxx");
 MODULE_LICENSE("GPL");
 
--- a/arch/arm/plat-armada/mv_hal/neta/bm/mvBm.c
+++ b/arch/arm/plat-armada/mv_hal/neta/bm/mvBm.c
@@ -298,13 +298,10 @@ MV_STATUS mvBmPoolBufSizeSet(int pool, i
 		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
 		return MV_BAD_PARAM;
 	}
-
 	pBmPool = &mvBmPools[pool];
-	if ((buf_size != 0) && (pBmPool->bufSize != 0)) {
-		mvOsPrintf("bmPoolId = %d is busy for buf_size = %d \n", pool, pBmPool->bufSize);
-		return MV_BAD_PARAM;
-	}
+
 	pBmPool->bufSize = buf_size;
+
 	return MV_OK;
 }
 
--- a/arch/arm/plat-armada/mv_hal/neta/bm/mvBm.h
+++ b/arch/arm/plat-armada/mv_hal/neta/bm/mvBm.h
@@ -78,9 +78,7 @@ typedef struct {
 	int longPool;
 	int shortPool;
 	int longBufNum;
-	int longBufSize;
 	int shortBufNum;
-	int shortBufSize;
 
 } MV_BM_CONFIG;
 
@@ -130,5 +128,4 @@ void      mvBmStatus(void);
 void      mvBmPoolDump(int pool, int mode);
 void      mvBmPoolPrint(int pool);
 
-
 #endif /* __mvBm_h__ */
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.c
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.c
@@ -402,16 +402,30 @@ MV_STATUS mvNetaDefaultsSet(int port)
 	/* build PORT_SDMA_CONFIG_REG */
 	regVal = 0;
 
-	if (mvNetaHalData.iocc) {
-		regVal |= ETH_TX_BURST_SIZE_MASK(ETH_BURST_SIZE_2_64BIT_VALUE);
-		regVal |= ETH_RX_BURST_SIZE_MASK(ETH_BURST_SIZE_2_64BIT_VALUE);
-	} else {
-		regVal |= ETH_TX_BURST_SIZE_MASK(ETH_BURST_SIZE_16_64BIT_VALUE);
-		regVal |= ETH_RX_BURST_SIZE_MASK(ETH_BURST_SIZE_16_64BIT_VALUE);
-	}
-
-	regVal |= (ETH_RX_NO_DATA_SWAP_MASK | ETH_TX_NO_DATA_SWAP_MASK | ETH_NO_DESC_SWAP_MASK);
-
+#ifdef CONFIG_MV_ETH_REDUCE_BURST_SIZE_WA
+        /* This is a WA for the IOCC HW BUG involve in using 128B burst size */
+        regVal |= ETH_TX_BURST_SIZE_MASK(ETH_BURST_SIZE_2_64BIT_VALUE);
+        regVal |= ETH_RX_BURST_SIZE_MASK(ETH_BURST_SIZE_2_64BIT_VALUE);
+#else
+
+#ifdef CONFIG_MV_ETH_REDUCE_BURST_SIZE_WA
+        /* This is a WA for the IOCC HW BUG involve in using 128B burst size */
+        regVal |= ETH_TX_BURST_SIZE_MASK(ETH_BURST_SIZE_2_64BIT_VALUE);
+        regVal |= ETH_RX_BURST_SIZE_MASK(ETH_BURST_SIZE_2_64BIT_VALUE);
+#else
+        /* Default burst size */
+        regVal |= ETH_TX_BURST_SIZE_MASK(ETH_BURST_SIZE_16_64BIT_VALUE);
+        regVal |= ETH_RX_BURST_SIZE_MASK(ETH_BURST_SIZE_16_64BIT_VALUE);
+#endif /* CONFIG_MV_ETH_REDUCE_BURST_SIZE_WA */
+
+#if defined(MV_CPU_BE) && !defined(CONFIG_MV_ETH_BE_WA)
+    /* big endian */
+    regVal |= (ETH_RX_NO_DATA_SWAP_MASK | ETH_TX_NO_DATA_SWAP_MASK | ETH_DESC_SWAP_MASK);
+#else /* MV_CPU_LE */
+    /* little endian */
+        regVal |= (ETH_RX_NO_DATA_SWAP_MASK | ETH_TX_NO_DATA_SWAP_MASK | ETH_NO_DESC_SWAP_MASK);
+#endif /* MV_CPU_BE && !CONFIG_MV_ETH_BE_WA */
+	
 	/* Assign port SDMA configuration */
 	MV_REG_WRITE(ETH_SDMA_CONFIG_REG(port), regVal);
 
@@ -499,7 +513,7 @@ MV_STATUS	mvNetaRxqCpuMaskSet(int port,
 
 #ifdef MV_ETH_GMAC_NEW
 
-MV_STATUS       mvEthGmacRgmiiSet(int port, int enable)
+static MV_STATUS       mvEthGmacRgmiiSet(int port, int enable)
 {
 	MV_U32  regVal;
 
@@ -519,7 +533,7 @@ static void mvNetaPortSgmiiConfig(int po
 	/* FIXME */
 }
 
-void mvNetaPortPowerUp(int port, MV_BOOL isSgmii,MV_BOOL isGmii)
+void mvNetaPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii)
 {
 	MV_U32 regVal;
 
@@ -529,6 +543,8 @@ void mvNetaPortPowerUp(int port, MV_BOOL
 	if (isSgmii)
 		mvNetaPortSgmiiConfig(port);
 
+	mvEthGmacRgmiiSet(port, isRgmii);
+
 	/* Cancel Port Reset */
 	regVal = MV_REG_READ(NETA_GMAC_CTRL_2_REG(port));
 	regVal &= (~NETA_GMAC_PORT_RESET_MASK);
@@ -978,7 +994,7 @@ static void mvNetaPortSgmiiConfig(int po
 	MV_REG_WRITE(ETH_PORT_SERIAL_CTRL_1_REG(port), regVal);
 }
 
-void mvNetaPortPowerUp(int port, MV_BOOL isSgmii,MV_BOOL isGmii)
+void mvNetaPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii)
 {
 	MV_U32 regVal;
 
@@ -992,7 +1008,10 @@ void mvNetaPortPowerUp(int port, MV_BOOL
 	/* Cancel Port Reset */
 	regVal = MV_REG_READ(ETH_PORT_SERIAL_CTRL_1_REG(port));
 	regVal &= (~ETH_PORT_RESET_MASK);
-	if(isGmii)
+
+	if (isRgmii)
+		regVal |= ETH_RGMII_ENABLE_MASK;
+	else
 		regVal &= (~ETH_RGMII_ENABLE_MASK);
 
 	MV_REG_WRITE(ETH_PORT_SERIAL_CTRL_1_REG(port), regVal);
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.h
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.h
@@ -76,25 +76,82 @@ extern "C" {
 #include "mvNetaRegs.h"
 #include "mvEthRegs.h"
 
+#ifdef CONFIG_MV_ETH_PNC
+# include "pnc/mvPnc.h"
+#endif /* CONFIG_MV_ETH_PNC */
 
 #define NETA_RX_IP_IS_FRAG(status)     ((status) & NETA_RX_IP4_FRAG_MASK)
+#define NETA_RX_IP_SET_FRAG(rxd)       ((rxd)->status |= NETA_RX_IP4_FRAG_MASK)
+
 #define NETA_RX_L4_CSUM_IS_OK(status)  ((status) & NETA_RX_L4_CSUM_OK_MASK)
+#define	NETA_RX_L4_CSUM_SET_OK(rxd)    ((rxd)->status |= NETA_RX_L4_CSUM_OK_MASK)
+
+#define NETA_RX_IS_PPPOE(rxd)          ((rxd)->pncInfo & NETA_PNC_PPPOE)
+#define NETA_RX_SET_PPPOE(rxd)         ((rxd)->pncInfo |= NETA_PNC_PPPOE)
+
+#define NETA_RX_GET_IPHDR_OFFSET(rxd)       (((rxd)->status & NETA_RX_L3_OFFSET_MASK) >> NETA_RX_L3_OFFSET_OFFS)
+#define NETA_RX_SET_IPHDR_OFFSET(rxd, offs) ((rxd)->status |= ((offs) << NETA_RX_L3_OFFSET_OFFS) & NETA_RX_L3_OFFSET_MASK)
+
+#define NETA_RX_GET_IPHDR_HDRLEN(rxd)       (((rxd)->status & NETA_RX_IP_HLEN_MASK) >> NETA_RX_IP_HLEN_OFFS)
+#define NETA_RX_SET_IPHDR_HDRLEN(rxd, hlen) ((rxd)->status |= ((hlen) << NETA_RX_IP_HLEN_OFFS) & NETA_RX_IP_HLEN_MASK)
 
 #ifdef CONFIG_MV_ETH_PNC
+
+#define NETA_RX_IS_VLAN(rxd)           ((rxd)->pncInfo & NETA_PNC_VLAN)
+#define NETA_RX_SET_VLAN(rxd)          ((rxd)->pncInfo |= NETA_PNC_VLAN)
+
 #define NETA_RX_L3_IS_IP4(status)      (((status) & NETA_RX_L3_MASK) == NETA_RX_L3_IP4)
+#define NETA_RX_L3_SET_IP4(rxd)        ((rxd)->status |= NETA_RX_L3_IP4)
+
 #define NETA_RX_L3_IS_IP4_ERR(status)  (((status) & NETA_RX_L3_MASK) == NETA_RX_L3_IP4_ERR)
+#define NETA_RX_L3_SET_IP4_ERR(rxd)    ((rxd)->status |= NETA_RX_L3_IP4_ERR)
+
 #define NETA_RX_L3_IS_IP6(status)      (((status) & NETA_RX_L3_MASK) == NETA_RX_L3_IP6)
+#define NETA_RX_L3_SET_IP6(rxd)        ((rxd)->status |= NETA_RX_L3_IP6)
+
+#define NETA_RX_L3_IS_UN(status)       (((status) & NETA_RX_L3_MASK) == NETA_RX_L3_UN)
+#define NETA_RX_L3_SET_UN(rxd)         ((rxd)->status |= NETA_RX_L3_UN)
+
 #define NETA_RX_L4_IS_TCP(status)      (((status) & NETA_RX_L4_MASK) == NETA_RX_L4_TCP)
+#define NETA_RX_L4_SET_TCP(rxd)        ((rxd)->status |= NETA_RX_L4_TCP)
+
 #define NETA_RX_L4_IS_UDP(status)      (((status) & NETA_RX_L4_MASK) == NETA_RX_L4_UDP)
-#else
+#define NETA_RX_L4_SET_UDP(rxd)        ((rxd)->status |= NETA_RX_L4_UDP)
+
+#define NETA_RX_L4_IS_OTHER(status)    (((status) & NETA_RX_L4_MASK) == NETA_RX_L4_OTHER)
+#define NETA_RX_L4_SET_OTHER(rxd)      ((rxd)->status |= NETA_RX_L4_OTHER)
+
+#else /* LEGACY parser */
+
+#define NETA_RX_IS_VLAN(rxd)           ((rxd)->status & ETH_RX_VLAN_TAGGED_FRAME_MASK)
+#define NETA_RX_SET_VLAN(rxd)          ((rxd)->status |= ETH_RX_VLAN_TAGGED_FRAME_MASK)
+
 #define NETA_RX_L3_IS_IP4(status)      ((status) & ETH_RX_IP_HEADER_OK_MASK)
-#define NETA_RX_L3_IS_IP4_ERR(status)  (((status) & ETH_RX_IP_FRAME_TYPE_MASK) &&  \
-										!((status) & ETH_RX_IP_HEADER_OK_MASK))
+#define NETA_RX_L3_SET_IP4(rxd)        ((rxd)->status |= (ETH_RX_IP_HEADER_OK_MASK | ETH_RX_IP_FRAME_TYPE_MASK))
+
+#define NETA_RX_L3_IS_IP4_ERR(status)  (((status) & ETH_RX_IP_FRAME_TYPE_MASK) &&	\
+					!((status) & ETH_RX_IP_HEADER_OK_MASK))
+
+#define NETA_RX_L3_SET_IP4_ERR(rxd)													\
+					((rxd)->status |= ETH_RX_IP_FRAME_TYPE_MASK);					\
+					((rxd)->status &= ~ETH_RX_IP_HEADER_OK_MASK);
+
 #define NETA_RX_L3_IS_IP6(status)      (MV_FALSE)
+#define NETA_RX_L3_SET_IP6(rxd)        NETA_RX_L3_SET_UN(rxd)
+
+#define NETA_RX_L3_IS_UN(status)       (((status) & ETH_RX_IP_FRAME_TYPE_MASK) == 0)
+#define NETA_RX_L3_SET_UN(rxd)         ((rxd)->status &= ~ETH_RX_IP_FRAME_TYPE_MASK)
+
 #define NETA_RX_L4_IS_TCP(status)      (((status) & ETH_RX_L4_TYPE_MASK) == ETH_RX_L4_TCP_TYPE)
+#define NETA_RX_L4_SET_TCP(rxd)        ((rxd)->status |= ETH_RX_L4_TCP_TYPE)
+
 #define NETA_RX_L4_IS_UDP(status)      (((status) & ETH_RX_L4_TYPE_MASK) == ETH_RX_L4_UDP_TYPE)
-#endif	/* CONFIG_MV_ETH_PNC */
+#define NETA_RX_L4_SET_UDP(rxd)        ((rxd)->status |= ETH_RX_L4_UDP_TYPE)
 
+#define NETA_RX_L4_IS_OTHER(status)    (((status) & ETH_RX_L4_TYPE_MASK) == ETH_RX_L4_OTHER_TYPE)
+#define NETA_RX_L4_SET_OTHER(rxd)      ((rxd)->status |= ETH_RX_L4_OTHER_TYPE)
+
+#endif	/* CONFIG_MV_ETH_PNC */
 
 /* Default port configuration value */
 #define PORT_CONFIG_VALUE(rxQ)			\
@@ -193,12 +250,9 @@ typedef struct eth_pbuf {
 	MV_U8 *pBuf;
 	MV_U16 bytes;
 	MV_U16 offset;
-	MV_U32 tx_cmd;
-	void *dev;
-	MV_U8 pool;
-	MV_U8 tos;
-	MV_U16 reserved;
-	MV_U32 hw_cmd;
+	MV_U8  pool;
+	MV_U8  reserved;
+	MV_U16 vlanId;
 } MV_ETH_PKT;
 
 typedef struct {
@@ -267,7 +321,7 @@ static INLINE MV_NETA_TXQ_CTRL *mvNetaTx
 	return &pPortCtrl->pTxQueue[txp * pPortCtrl->txqNum + txq];
 }
 
-#if defined(MV_CPU_BE)
+#if defined(MV_CPU_BE) && defined(CONFIG_MV_ETH_BE_WA)
 /* Swap RX descriptor to be BE */
 static INLINE void mvNetaRxqDescSwap(NETA_RX_DESC *pRxDesc)
 {
@@ -292,7 +346,14 @@ static INLINE void mvNetaTxqDescSwap(NET
     pTxDesc->bufPhysAddr = MV_BYTE_SWAP_32BIT(pTxDesc->bufPhysAddr);
     pTxDesc->hw_cmd = MV_BYTE_SWAP_32BIT(pTxDesc->hw_cmd);
 }
-#endif /* MV_CPU_BE */
+#else
+static INLINE void mvNetaRxqDescSwap(NETA_RX_DESC *pRxDesc)
+{
+}
+static INLINE void mvNetaTxqDescSwap(NETA_TX_DESC *pTxDesc)
+{
+}
+#endif /* MV_CPU_BE &&  CONFIG_MV_ETH_BE_WA */
 
 /* Get number of RX descriptors occupied by received packets */
 static INLINE int mvNetaRxqBusyDescNumGet(int port, int rxq)
@@ -453,7 +514,11 @@ static INLINE void mvNetaRxDescFill(NETA
 {
 	pRxDesc->bufCookie = (MV_U32)cookie;
 
+#if defined(CONFIG_MV_ETH_BE_WA)
 	pRxDesc->bufPhysAddr = MV_32BIT_LE(physAddr);
+#else
+	pRxDesc->bufPhysAddr = physAddr;
+#endif /* CONFIG_MV_ETH_BE_WA */
 
 	mvOsCacheLineFlush(NULL, pRxDesc);
 }
@@ -578,7 +643,7 @@ void 		mvNetaPhyAddrSet(int port, int ph
 int 		mvNetaPhyAddrGet(int port);
 
 void 		mvNetaPortPowerDown(int port);
-void 		mvNetaPortPowerUp(int port, MV_BOOL isSgmii,MV_BOOL isGmii);
+void 		mvNetaPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii);
 
 /* Interrupt Coalesting functions */
 MV_STATUS mvNetaRxqTimeCoalSet(int port, int rxq, MV_U32 uSec);
@@ -639,7 +704,6 @@ MV_STATUS mvNetaFlowCtrlSet(int port, MV
 MV_STATUS mvNetaFlowCtrlGet(int port, MV_ETH_PORT_FC *flowControl);
 
 #ifdef MV_ETH_GMAC_NEW
-MV_STATUS       mvEthGmacRgmiiSet(int port, int enable);
 MV_STATUS	mvNetaGmacLpiSet(int port, int mode);
 void	mvNetaGmacRegs(int port);
 #endif /* MV_ETH_GMAC_NEW */
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h
@@ -942,20 +942,38 @@ extern "C" {
 
 #define NETA_DESC_ALIGNED_SIZE	            32
 
+#if defined(MV_CPU_BE) && !defined(CONFIG_MV_ETH_BE_WA)
+
 typedef struct neta_rx_desc {
-    MV_U32  status;
-    MV_U16  pncInfo;
-    MV_U16  dataSize;
-    MV_U32  bufPhysAddr;
-    MV_U32  pncFlowId;
-    MV_U32  bufCookie;
-    MV_U16  prefetchCmd;
-    MV_U16  csumL4;
-    MV_U32  pncExtra;
-    MV_U32  hw_cmd;
+	MV_U16  dataSize;
+	MV_U16  pncInfo;
+	MV_U32  status;
+	MV_U32  pncFlowId;
+	MV_U32  bufPhysAddr;
+	MV_U16  csumL4;
+	MV_U16  prefetchCmd;
+	MV_U32  bufCookie;
+	MV_U32  hw_cmd;
+	MV_U32  pncExtra;
+} NETA_RX_DESC;
+
+#else
 
+typedef struct neta_rx_desc {
+	MV_U32  status;
+	MV_U16  pncInfo;
+	MV_U16  dataSize;
+	MV_U32  bufPhysAddr;
+	MV_U32  pncFlowId;
+	MV_U32  bufCookie;
+	MV_U16  prefetchCmd;
+	MV_U16  csumL4;
+	MV_U32  pncExtra;
+	MV_U32  hw_cmd;
 } NETA_RX_DESC;
 
+#endif /* MV_CPU_BE && !CONFIG_MV_ETH_BE_WA */
+
 /* "status" word fileds definition */
 #define NETA_RX_L3_OFFSET_OFFS              0
 #define NETA_RX_L3_OFFSET_MASK              (0x7F << NETA_RX_L3_OFFSET_OFFS)
@@ -1067,16 +1085,30 @@ typedef struct neta_rx_desc {
 
 /******************** NETA TX EXTENDED DESCRIPTOR ********************************/
 
+#if defined(MV_CPU_BE) && !defined(CONFIG_MV_ETH_BE_WA)
+
 typedef struct neta_tx_desc {
-    MV_U32  command;
-    MV_U16  csumL4;
-    MV_U16  dataSize;
-    MV_U32  bufPhysAddr;
-    MV_U32  hw_cmd;
-    MV_U32  reserved[4];
+	MV_U16  dataSize;
+	MV_U16  csumL4;
+	MV_U32  command;
+	MV_U32  hw_cmd;
+	MV_U32  bufPhysAddr;
+	MV_U32  reserved[4];
+} NETA_TX_DESC;
+
+#else
 
+typedef struct neta_tx_desc {
+	MV_U32  command;
+	MV_U16  csumL4;
+	MV_U16  dataSize;
+	MV_U32  bufPhysAddr;
+	MV_U32  hw_cmd;
+	MV_U32  reserved[4];
 } NETA_TX_DESC;
 
+#endif /* MV_CPU_BE && !CONFIG_MV_ETH_BE_WA */
+
 /* "command" word fileds definition */
 #define NETA_TX_L3_OFFSET_OFFS              0
 #define NETA_TX_L3_OFFSET_MASK              (0x7F << NETA_TX_L3_OFFSET_OFFS)
@@ -1119,8 +1151,9 @@ typedef struct neta_tx_desc {
 
 
 #define NETA_TX_PKT_OFFSET_OFFS             23
-#define NETA_TX_PKT_OFFSET_ALL_MASK         (0x7F << NETA_TX_PKT_OFFSET_OFFS)
-#define NETA_TX_PKT_OFFSET_MASK(offset)     ((offset) << NETA_TX_PKT_OFFSET_OFFS)
+#define NETA_TX_PKT_OFFSET_MAX				0x7F
+#define NETA_TX_PKT_OFFSET_ALL_MASK         (NETA_TX_PKT_OFFSET_MAX << NETA_TX_PKT_OFFSET_OFFS)
+#define NETA_TX_PKT_OFFSET_MASK(offset)     (((offset) << NETA_TX_PKT_OFFSET_OFFS) & NETA_TX_PKT_OFFSET_ALL_MASK)
 
 #define NETA_TX_L4_CSUM_BIT                 30
 #define NETA_TX_L4_CSUM_MASK                (3 << NETA_TX_L4_CSUM_BIT)
--- a/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h
+++ b/arch/arm/plat-armada/mv_hal/neta/nfp/mvNfpDefs.h
@@ -63,11 +63,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 *******************************************************************************/
 
 /*******************************************************************************
-* mvNfp.h - Header File for Marvell NFP (Routing and NAT)
+* mvNfpDefs.h - Header File for Marvell NFP Configuration definitions
 *
 * DESCRIPTION:
-*       This header file contains macros, typedefs and function declarations
-* 	specific to the Marvell Network Fast Processing (Routing and NAT).
 *
 * DEPENDENCIES:
 *       None.
@@ -77,29 +75,130 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #ifndef __mvNfpDefs_h__
 #define __mvNfpDefs_h__
 
+#include "mv802_3.h"
+#include "gbe/mvNetaRegs.h"
+#include "gbe/mvNeta.h"
+
 #ifdef CONFIG_MV_ETH_NFP
+
 #define ETH_NFP
 
-#ifdef CONFIG_MV_ETH_NFP_PNC
-#define NFP_PNC
+#ifdef CONFIG_MV_ETH_NFP_EXT
+# define NFP_EXT
+# define NFP_EXT_NUM 	CONFIG_MV_ETH_NFP_EXT_NUM
+#else
+# define NFP_EXT_NUM 	0
+#endif
+
+#define NFP_MAX_PORTS   (MV_ETH_MAX_PORTS + NFP_EXT_NUM)
+
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN) || defined(CONFIG_MV_ETH_NFP_VLAN_LEARN) || defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)||\
+		defined(CONFIG_MV_ETH_NFP_PPP_LEARN) || defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+#define NFP_LEARN
 #endif
 
 #ifdef CONFIG_MV_ETH_NFP_FIB
 #define NFP_FIB
 #endif
 
+#ifdef CONFIG_MV_ETH_NFP_FIB_LEARN
+#define NFP_FIB_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_VLAN
+#define NFP_VLAN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_VLAN_LEARN
+#define NFP_VLAN_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_PPP
+#define NFP_PPP
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_PPP_LEARN
+#define NFP_PPP_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_CT
+#define NFP_CT
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_CT_LEARN
+#define NFP_CT_LEARN
+#endif
+
 #ifdef CONFIG_MV_ETH_NFP_NAT
 #define NFP_NAT
 #endif
 
-#ifdef CONFIG_MV_ETH_NFP_SWF
-#define NFP_SWF
+#ifdef CONFIG_MV_ETH_NFP_LIMIT
+#define NFP_LIMIT
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_CLASSIFY
+#define NFP_CLASSIFY
 #endif
 
 #ifdef CONFIG_MV_ETH_NFP_STATS
 #define NFP_STAT
 #endif
 
+#ifdef CONFIG_MV_ETH_NFP_BRIDGE
+#define NFP_BRIDGE
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_BRIDGE_LEARN
+#define NFP_BRIDGE_LEARN
+#endif
+
+#ifdef CONFIG_MV_ETH_SWITCH
+# define NFP_MAX_SWITCH_GROUPS  CONFIG_MV_ETH_SWITCH_NETDEV_NUM
+#else
+# define NFP_MAX_SWITCH_GROUPS  1
+#endif /* CONFIG_MV_ETH_SWITCH */
+
+typedef struct {
+	MV_U16 flags;
+
+	MV_U8  txp;
+	MV_U8  txq;
+
+	MV_U8 pkt_ecn;
+	MV_U8 pkt_dscp;
+	int   ct_dscp;
+
+	int pkt_vlan_prio;
+	int bridge_vlan_prio;
+	int ct_vlan_prio;
+
+	MV_U16 mh;
+} NFP_CLASSIFY_INFO;
+
+typedef struct {
+	void   *dev;
+	MV_U32 tx_cmd;
+	MV_U32 diffL4[2];
+	MV_U8  *pWrite;
+	MV_U16 flags;
+	MV_U16 mtu;
+	short  shift;
+	MV_U8  txp;
+	MV_U8  txq;
+	MV_IP_HEADER_INFO ipInfo;
+	NFP_CLASSIFY_INFO classifyInfo;
+} MV_NFP_RESULT;
+
+#define MV_NFP_RES_TXP_VALID       0x0001
+#define MV_NFP_RES_TXQ_VALID       0x0002
+#define MV_NFP_RES_IP_INFO_VALID   0x0004
+#define MV_NFP_RES_NETDEV_EXT      0x0010
+#define MV_NFP_RES_L4_CSUM_NEEDED  0x0020
+
+MV_STATUS mvNfpIfMapPortGet(int ifIdx, int *port);
+MV_STATUS mvNfpRx(MV_U32 inPort, NETA_RX_DESC *pRxDesc, MV_ETH_PKT *pPkt, MV_NFP_RESULT* pRes);
+
 #endif /* CONFIG_MV_ETH_NFP */
 
 #endif /* __mvNfp_h__ */
--- a/arch/arm/plat-armada/mv_hal/neta/pmt/mvPmt.c
+++ b/arch/arm/plat-armada/mv_hal/neta/pmt/mvPmt.c
@@ -62,7 +62,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 
 *******************************************************************************/
 
-#include "mvCommon.h"		/* Should be included before mvSysHwConfig */
+#include "mvCommon.h"  /* Should be included before mvSysHwConfig */
 #include "mvTypes.h"
 #include "mvDebug.h"
 #include "mvOs.h"
@@ -71,156 +71,569 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 
 #include "mvPmt.h"
 
-/*#define PMT_DBG mvOsPrintf*/
+MV_NETA_PMT	**mvPmtBase = NULL;
+
+/* #define PMT_DBG mvOsPrintf */
 #define PMT_DBG(X...)
 
+static char mvPmtCmdNames[MV_ETH_PMT_SIZE][PMT_TEXT] = {
+
+	[MV_NETA_CMD_NONE]          = "NO_MOD",
+	[MV_NETA_CMD_ADD_2B]        = "ADD_2B",
+	[MV_NETA_CMD_CFG_VLAN]      = "CFG_VLAN",
+	[MV_NETA_CMD_ADD_VLAN]      = "ADD_VLAN",
+	[MV_NETA_CMD_CFG_DSA_1]     = "CFG_DSA_1",
+	[MV_NETA_CMD_CFG_DSA_2]     = "CFG_DSA_2",
+	[MV_NETA_CMD_ADD_DSA]       = "ADD_DSA",
+	[MV_NETA_CMD_DEL_BYTES]     = "DEL_BYTES",
+	[MV_NETA_CMD_REPLACE_2B]    = "REPLACE_2B",
+	[MV_NETA_CMD_REPLACE_LSB]   = "REPLACE_LSB",
+	[MV_NETA_CMD_REPLACE_MSB]   = "REPLACE_MSB",
+	[MV_NETA_CMD_REPLACE_VLAN]  = "REPLACE_VLAN",
+	[MV_NETA_CMD_DEC_LSB]       = "DEC_LSB",
+	[MV_NETA_CMD_DEC_MSB]       = "DEC_MSB",
+	[MV_NETA_CMD_ADD_CALC_LEN]  = "ADD_CALC_LEN",
+	[MV_NETA_CMD_REPLACE_LEN]   = "REPLACE_LEN",
+	[MV_NETA_CMD_IPV4_CSUM]     = "IPV4_CSUM",
+	[MV_NETA_CMD_L4_CSUM]       = "L4_CSUM",
+	[MV_NETA_CMD_SKIP]          = "SKIP",
+	[MV_NETA_CMD_JUMP]          = "JUMP",
+	[MV_NETA_CMD_JUMP_SKIP]     = "JUMP_SKIP",
+	[MV_NETA_CMD_JUMP_SUB]      = "JUMP_SUB",
+	[MV_NETA_CMD_PPPOE]         = "PPPOE",
+	[MV_NETA_CMD_STORE]         = "STORE",
+};
+
 /*******************************************************************************
 * mvNetaPmtWrite - Add entry to Packet Modification Table
-* DESCRIPTION:
 *
 * INPUT:
-*       int			port - NETA port number
+*       int			port    - NETA port number
+*       int			idx     - PMT entry index to write to
+*       MV_NETA_PMT	pEntry  - PMT entry
 *
 * RETURN:   MV_STATUS
 *               MV_OK - Success, Others - Failure
-*
-* NOTE:
 *******************************************************************************/
-MV_STATUS mvNetaPmtWrite(int port, int idx, MV_NETA_PMT *pEntry)
+MV_STATUS   mvNetaPmtWrite(int port, int idx, MV_NETA_PMT *pEntry)
 {
-	if (mvNetaPortCheck(port))
-		return MV_OUT_OF_RANGE;
+	MV_NETA_PMT	*pBase;
 
-	if (mvNetaMaxCheck(idx, NETA_TX_PMT_SIZE))
+	if ((port < 0) || (port >= mvNetaHalData.maxPort)) {
+		mvOsPrintf("%s: port %d is out of range\n", __func__, port);
 		return MV_OUT_OF_RANGE;
+	}
 
-	PMT_DBG("%s: 0x%08x <-- 0x%x\n", __func__, NETA_TX_PMT_REG(port), idx);
-	MV_REG_WRITE(NETA_TX_PMT_REG(port), (MV_U32) idx);
-	MV_REG_WRITE(NETA_TX_PMT_W0_REG(port), pEntry->mt_w0 & NETA_TX_PMT_W0_MASK);
-	MV_REG_WRITE(NETA_TX_PMT_W1_REG(port), pEntry->mt_w1 & NETA_TX_PMT_W1_MASK);
-	MV_REG_WRITE(NETA_TX_PMT_W2_REG(port), pEntry->mt_w2 & NETA_TX_PMT_W2_MASK);
+	if ((idx < 0) || (idx >= MV_ETH_PMT_SIZE)) {
+		mvOsPrintf("%s: entry %d is out of range\n", __func__, idx);
+		return MV_OUT_OF_RANGE;
+	}
+	if ((mvPmtBase == NULL) || (mvPmtBase[port] == NULL)) {
+		mvOsPrintf("%s: PMT for port #%d is not initialized\n", __func__, port);
+		return MV_INIT_ERROR;
+	}
+	pBase = mvPmtBase[port];
+	pBase[idx].word = pEntry->word;
 
 	return MV_OK;
 }
+
 /*******************************************************************************
 * mvNetaPmtRead - Read entry from Packet Modification Table
-* DESCRIPTION:
 *
 * INPUT:
 *       int			port - NETA port number
-*       int			inx - PMT entry index to read from
+*       int			idx  - PMT entry index to read from
 * OUTPUT:
 *       MV_NETA_PMT	pEntry - PMT entry
 *
 * RETURN:   MV_STATUS
 *               MV_OK - Success, Others - Failure
-*
-* NOTE:
 *******************************************************************************/
 MV_STATUS mvNetaPmtRead(int port, int idx, MV_NETA_PMT *pEntry)
 {
-	if (mvNetaPortCheck(port))
-		return MV_OUT_OF_RANGE;
+	MV_NETA_PMT	*pBase;
 
-	if (mvNetaMaxCheck(idx, NETA_TX_PMT_SIZE))
+	if ((port < 0) || (port >= mvNetaHalData.maxPort)) {
+		mvOsPrintf("%s: port %d is out of range\n", __func__, port);
 		return MV_OUT_OF_RANGE;
+	}
 
-	PMT_DBG("%s: 0x%08x <-- 0x%x\n", __func__, NETA_TX_PMT_REG(port), idx);
-
-	MV_REG_WRITE(NETA_TX_PMT_REG(port), (MV_U32) idx);
-	pEntry->mt_w0 = MV_REG_READ(NETA_TX_PMT_W0_REG(port));
-	pEntry->mt_w1 = MV_REG_READ(NETA_TX_PMT_W1_REG(port));
-	pEntry->mt_w2 = MV_REG_READ(NETA_TX_PMT_W2_REG(port));
+	if ((idx < 0) || (idx >= MV_ETH_PMT_SIZE)) {
+		mvOsPrintf("%s: entry %d is out of range\n", __func__, idx);
+		return MV_OUT_OF_RANGE;
+	}
+	if ((mvPmtBase == NULL) || (mvPmtBase[port] == NULL)) {
+		mvOsPrintf("%s: PMT for port #%d is not initialized\n", __func__, port);
+		return MV_INIT_ERROR;
+	}
+	pBase = mvPmtBase[port];
+	pEntry->word = pBase[idx].word;
 
 	return MV_OK;
 }
 
 /*******************************************************************************
-* mvNetaPmtInit - Clear Packet Modification Table
-* DESCRIPTION:
+* mvNetaPmtClear - Clear Packet Modification Table
 *
 * INPUT:
 *       int			port - NETA port number
 *
 * RETURN:   MV_STATUS
 *               MV_OK - Success, Others - Failure
-*
-* NOTE:
 *******************************************************************************/
-MV_STATUS mvNetaPmtInit(int port)
+MV_STATUS   mvNetaPmtClear(int port)
 {
-	int idx;
+	int         idx;
 	MV_NETA_PMT entry;
 
-	if (mvNetaPortCheck(port))
+	if ((port < 0) || (port >= mvNetaHalData.maxPort)) {
+		mvOsPrintf("%s: port %d is out of range\n", __func__, port);
 		return MV_OUT_OF_RANGE;
+	}
 
-	memset(&entry, 0, sizeof(MV_NETA_PMT));
-
-	for (idx = 0; idx < NETA_TX_PMT_SIZE; idx++)
+	MV_NETA_PMT_INVALID_SET(&entry);
+	for (idx = 0; idx < MV_ETH_PMT_SIZE; idx++)
 		mvNetaPmtWrite(port, idx, &entry);
 
 	return MV_OK;
 }
 
 /*******************************************************************************
-* mvNetaPmtDump - Dump Packet Modification Table
-* DESCRIPTION:
+* mvNetaPmtInit - Init Packet Modification Table driver
 *
 * INPUT:
 *       int			port - NETA port number
 *
 * RETURN:   MV_STATUS
 *               MV_OK - Success, Others - Failure
+*******************************************************************************/
+MV_STATUS   mvNetaPmtInit(int port, MV_NETA_PMT *pBase)
+{
+	if ((port < 0) || (port >= mvNetaHalData.maxPort)) {
+		mvOsPrintf("%s: port %d is out of range\n", __func__, port);
+		return MV_OUT_OF_RANGE;
+	}
+
+	if (mvPmtBase == NULL) {
+		mvPmtBase = mvOsMalloc(mvNetaHalData.maxPort * sizeof(MV_NETA_PMT *));
+		if (mvPmtBase == NULL) {
+			mvOsPrintf("%s: Allocation failed\n", __func__);
+			return MV_OUT_OF_CPU_MEM;
+		}
+		memset(mvPmtBase, 0, mvNetaHalData.maxPort * sizeof(MV_NETA_PMT *));
+	}
+	mvPmtBase[port] = pBase;
+
+	mvNetaPmtClear(port);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvNetaPmtDestroy - Free PMT Base memory
+*
+* INPUT:
 *
-* NOTE:
+* RETURN:   void
 *******************************************************************************/
-MV_STATUS mvNetaPmtDump(int port)
+MV_VOID   mvNetaPmtDestroy(MV_VOID)
 {
-	int idx, count = 0;
-	MV_NETA_PMT entry;
+	if (mvPmtBase)
+		mvOsFree(mvPmtBase);
+}
 
-	if (mvNetaPortCheck(port))
-		return MV_OUT_OF_RANGE;
+/*******************************************************************************
+* mvNetaPmtEntryPrint - Print PMT entry
+*
+* INPUT:
+*       MV_NETA_PMT*    pEntry - PMT entry to be printed
+*
+* RETURN:   void
+*******************************************************************************/
+void    mvNetaPmtEntryPrint(MV_NETA_PMT *pEntry)
+{
+	mvOsPrintf("%04x %04x: %s",
+		MV_NETA_PMT_CTRL_GET(pEntry), MV_NETA_PMT_DATA_GET(pEntry),
+		mvPmtCmdNames[MV_NETA_PMT_CMD_GET(pEntry)]);
+
+	if (pEntry->word & MV_NETA_PMT_IP4_CSUM_MASK)
+		mvOsPrintf(", IPv4 csum");
 
-	for (idx = 0; idx < NETA_TX_PMT_SIZE; idx++) {
-		mvNetaPmtRead(port, idx, &entry);
-		if (entry.mt_w0 || entry.mt_w1 || entry.mt_w2) {
-			count++;
-			mvOsPrintf("[%2x] 0x%08x 0x%08x 0x%08x\n", idx, entry.mt_w0, entry.mt_w1, entry.mt_w2);
+	if (pEntry->word & MV_NETA_PMT_L4_CSUM_MASK)
+		mvOsPrintf(", L4 csum");
+
+	if (pEntry->word & MV_NETA_PMT_LAST_MASK)
+		mvOsPrintf(", Last");
+
+	mvOsPrintf("\n");
+}
+
+/*******************************************************************************
+* mvNetaPmtDump - Dump Packet Modification Table
+*
+* INPUT:
+*       int			port    - NETA port number
+*       int         flags   -
+*
+* RETURN:   void
+*******************************************************************************/
+void   mvNetaPmtDump(int port, int flags)
+{
+	int             idx, count = 0;
+	MV_NETA_PMT 	entry;
+	MV_STATUS       status;
+
+	if ((port < 0) || (port >= mvNetaHalData.maxPort)) {
+		mvOsPrintf("%s: port %d is out of range\n", __func__, port);
+		return;
+	}
+
+	for (idx = 0; idx < MV_ETH_PMT_SIZE; idx++) {
+		status = mvNetaPmtRead(port, idx, &entry);
+		if (status != MV_OK) {
+			mvOsPrintf("%s failed: port=%d, idx=%d, status=%d\n",
+					__func__, port, idx, status);
+			return;
 		}
+		if ((flags & PMT_PRINT_VALID_FLAG) && !MV_NETA_PMT_IS_VALID(&entry))
+			continue;
+
+		count++;
+		mvOsPrintf("[%3d]: ", idx);
+		mvNetaPmtEntryPrint(&entry);
 	}
 
 	if (!count)
-		mvOsPrintf("PMT is empty, %d entries\n", NETA_TX_PMT_SIZE);
+		mvOsPrintf("PMT is empty, %d entries\n", MV_ETH_PMT_SIZE);
+}
 
-	return MV_OK;
+/*******************************************************************************
+* mvNetaPmtAdd2Bytes - Set PMT entry with "add 2 bytes" command
+*
+* INPUT:
+*       MV_U16 data         - 2 bytes of data to be added
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void    mvNetaPmtAdd2Bytes(MV_NETA_PMT *pEntry, MV_U16 data)
+{
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_ADD_2B);
+	MV_NETA_PMT_DATA_SET(pEntry, data);
 }
 
-/* Set MH register */
-MV_STATUS mvNetaPmtMhRegSet(int port, int txp, int reg, MV_U16 val)
+/*******************************************************************************
+* mvNetaPmtReplace2Bytes - Set PMT entry with "Replace 2 bytes" command
+*
+* INPUT:
+*       MV_U16 data         - 2 bytes of data to be replaced
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void    mvNetaPmtReplace2Bytes(MV_NETA_PMT *pEntry, MV_U16 data)
 {
-	if (mvNetaTxpCheck(port, txp))
-		return MV_OUT_OF_RANGE;
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_REPLACE_2B);
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
 
-	if (mvNetaMaxCheck(reg, NETA_TX_MAX_MH_REGS))
-		return MV_OUT_OF_RANGE;
+/*******************************************************************************
+* mvNetaPmtDelShorts - Set PMT entry with "Delete" command
+*
+* INPUT:
+*       MV_U8   toDelete    - number of shorts to be deleted
+*       MV_U8   skipBefore  - number of shorts to be skipped before delete
+*       MV_U8   skipAfter   - number of shorts to be skipped after delete
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void    mvNetaPmtDelShorts(MV_NETA_PMT *pEntry, MV_U8 toDelete,
+				MV_U8 skipBefore, MV_U8 skipAfter)
+{
+	MV_U16  data;
 
-	MV_REG_WRITE(NETA_TX_MH_REG(port, txp, reg), val);
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_DEL_BYTES);
 
-	return MV_OK;
+	data = MV_NETA_PMT_DEL_SHORTS(toDelete) |
+		MV_NETA_PMT_DEL_SKIP_B(skipBefore) |
+		MV_NETA_PMT_DEL_SKIP_A(skipAfter);
+
+	MV_NETA_PMT_DATA_SET(pEntry, data);
 }
 
-/* Set ETH_TYPE register */
-MV_STATUS mvNetaPmtEthTypeRegSet(int port, int txp, int reg, MV_U16 val)
+/* Set update checksum flags to PMT entry */
+void    mvNetaPmtFlags(MV_NETA_PMT *pEntry, int last, int ipv4, int l4)
 {
-	if (mvNetaTxpCheck(port, txp))
-		return MV_OUT_OF_RANGE;
+	if (last)
+		pEntry->word |= MV_NETA_PMT_LAST_MASK;
 
-	if (mvNetaMaxCheck(reg, NETA_TX_MAX_ETH_TYPE_REGS))
-		return MV_OUT_OF_RANGE;
+	if (ipv4)
+		pEntry->word |= MV_NETA_PMT_IP4_CSUM_MASK;
 
-	MV_REG_WRITE(NETA_TX_ETH_TYPE_REG(port, txp, reg), val);
+	if (l4)
+		pEntry->word |= MV_NETA_PMT_L4_CSUM_MASK;
+}
 
-	return MV_OK;
+/* Set Last flag to PMT entry */
+void    mvNetaPmtLastFlag(MV_NETA_PMT *pEntry, int last)
+{
+	if (last)
+		pEntry->word |= MV_NETA_PMT_LAST_MASK;
+	else
+		pEntry->word &= ~MV_NETA_PMT_LAST_MASK;
+}
+
+/*******************************************************************************
+* mvNetaPmtReplaceLSB - Set PMT entry with "Replace LSB" command
+*
+* INPUT:
+*       MV_U8 value    - value to be placed
+*       MV_U8 mask     - mask defines which bits to be replaced
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void    mvNetaPmtReplaceLSB(MV_NETA_PMT *pEntry, MV_U8 value, MV_U8 mask)
+{
+	MV_U16  data;
+
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_REPLACE_LSB);
+
+	data = (value << 0) | (mask << 8);
+
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
+
+/*******************************************************************************
+* mvNetaPmtReplaceMSB - Set PMT entry with "Replace MSB" command
+*
+* INPUT:
+*       MV_U8 value    - value to be placed
+*       MV_U8 mask     - mask defines which bits to be replaced
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void    mvNetaPmtReplaceMSB(MV_NETA_PMT *pEntry, MV_U8 value, MV_U8 mask)
+{
+	MV_U16  data;
+
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_REPLACE_MSB);
+
+	data = (value << 0) | (mask << 8);
+
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
+
+/*******************************************************************************
+* mvNetaPmtSkip - Set PMT entry with "Skip" command
+*
+* INPUT:
+*       MV_U16 shorts   - number of shorts to be skipped
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void    mvNetaPmtSkip(MV_NETA_PMT *pEntry, MV_U16 shorts)
+{
+	MV_U16  data;
+
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_SKIP);
+
+	data = MV_NETA_PMT_CALC_LEN_DATA(shorts * 2);
+	data |= MV_NETA_PMT_CALC_LEN_0_ZERO;
+	data |= MV_NETA_PMT_CALC_LEN_1(MV_NETA_PMT_ZERO_ADD);
+	data |= MV_NETA_PMT_CALC_LEN_2(MV_NETA_PMT_ZERO_ADD);
+	data |= MV_NETA_PMT_CALC_LEN_3_ADD_MASK;
+
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
+
+/*******************************************************************************
+* mvNetaPmtJump - Set PMT entry with "Jump" command
+*
+* INPUT:
+*       MV_U16 target   - PMT entry to jump to
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void    mvNetaPmtJump(MV_NETA_PMT *pEntry, MV_U16 target, int type, int cond)
+{
+	MV_U16  data;
+
+	if (type == 0) {
+		MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_JUMP);
+	} else if (type == 1) {
+		MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_JUMP_SKIP);
+	} else if (type == 2) {
+		MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_JUMP_SUB);
+	} else {
+		mvOsPrintf("%s - Unexpected type = %d\n", __func__, type);
+		return;
+	}
+
+	data = target;
+	if (cond == 1)
+		data |= MV_NETA_PMT_IP4_CSUM_MASK;
+	else if (cond == 2)
+		data |= MV_NETA_PMT_L4_CSUM_MASK;
+
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
+
+
+/*******************************************************************************
+* mvNetaPmtDecLSB - Set PMT entry with "Decrement LSB" command
+*
+* INPUT:
+*       MV_U8   skipBefore  - number of shorts to be skipped before delete
+*       MV_U8   skipAfter   - number of shorts to be skipped after delete
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void        mvNetaPmtDecLSB(MV_NETA_PMT *pEntry, MV_U8 skipBefore, MV_U8 skipAfter)
+{
+	MV_U16  data;
+
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_DEC_LSB);
+
+	data =  MV_NETA_PMT_DEL_SKIP_B(skipBefore) |
+		MV_NETA_PMT_DEL_SKIP_A(skipAfter);
+
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
+
+/*******************************************************************************
+* mvNetaPmtDecMSB - Set PMT entry with "Decrement MSB" command
+*
+* INPUT:
+*       MV_U8   skipBefore  - number of shorts to be skipped before delete
+*       MV_U8   skipAfter   - number of shorts to be skipped after delete
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void        mvNetaPmtDecMSB(MV_NETA_PMT *pEntry, MV_U8 skipBefore, MV_U8 skipAfter)
+{
+	MV_U16  data;
+
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_DEC_MSB);
+
+	data =  MV_NETA_PMT_DEL_SKIP_B(skipBefore) |
+		MV_NETA_PMT_DEL_SKIP_A(skipAfter);
+
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
+
+/*******************************************************************************
+* mvNetaPmtReplaceIPv4csum - Set PMT entry with "Replace IP checksum" command
+*
+* INPUT:
+*       MV_U16   data
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void        mvNetaPmtReplaceIPv4csum(MV_NETA_PMT *pEntry, MV_U16 data)
+{
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_IPV4_CSUM);
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
+
+/*******************************************************************************
+* mvNetaPmtReplaceL4csum - Set PMT entry with "Replace TCP/UDP checksum" command
+*
+* INPUT:
+*       MV_U16   data
+*
+* OUTPUT:
+*       MV_NETA_PMT* pEntry - PMT entry to be set
+*
+* RETURN:   void
+*******************************************************************************/
+void        mvNetaPmtReplaceL4csum(MV_NETA_PMT *pEntry, MV_U16 data)
+{
+	MV_NETA_PMT_CMD_SET(pEntry, MV_NETA_CMD_L4_CSUM);
+	MV_NETA_PMT_DATA_SET(pEntry, data);
+}
+
+/**************************************************************/
+/* High level PMT configuration functions - multiple commands */
+/**************************************************************/
+
+/* Configure PMT to decrement TTL in IPv4 header - 2 entries */
+int     mvNetaPmtTtlDec(int port, int idx, int ip_offs, int isLast)
+{
+	MV_NETA_PMT     pmtEntry;
+
+	/* Skip to TTL and Decrement - Set flag for IP csum */
+	MV_NETA_PMT_CLEAR(&pmtEntry);
+	mvNetaPmtDecMSB(&pmtEntry, (ip_offs + 8)/2, 0);
+	mvNetaPmtFlags(&pmtEntry, 0, 1, 0);
+	mvNetaPmtWrite(port, idx, &pmtEntry);
+	idx++;
+
+	/* Update IP checksum */
+	MV_NETA_PMT_CLEAR(&pmtEntry);
+	mvNetaPmtReplaceIPv4csum(&pmtEntry, 0);
+	if (isLast)
+		mvNetaPmtLastFlag(&pmtEntry, 1);
+
+	mvNetaPmtWrite(port, idx, &pmtEntry);
+
+	return idx;
+}
+
+/* Configure PMT to replace bytes in the packet: minimum 2 bytes - 1 entry for each 2 bytes */
+int     mvNetaPmtDataReplace(int port, int idx, int offset,
+				 MV_U8 *data, int bytes, int isLast)
+{
+	int             i;
+	MV_U16          u16;
+	MV_NETA_PMT     pmtEntry;
+
+	if (offset > 0) {
+		/* Skip command first */
+		MV_NETA_PMT_CLEAR(&pmtEntry);
+		mvNetaPmtSkip(&pmtEntry, offset/2);
+		mvNetaPmtWrite(port, idx, &pmtEntry);
+		idx++;
+	}
+	for (i = 0; i < bytes; i += 2) {
+		/* Replace */
+		MV_NETA_PMT_CLEAR(&pmtEntry);
+		u16 = ((data[i] << 8) | data[i+1]);
+		mvNetaPmtReplace2Bytes(&pmtEntry, u16);
+		if (isLast && (i == bytes))
+			mvNetaPmtLastFlag(&pmtEntry, 1);
+
+		mvNetaPmtWrite(port, idx, &pmtEntry);
+		idx++;
+	}
+
+	return idx;
 }
--- a/arch/arm/plat-armada/mv_hal/neta/pmt/mvPmt.h
+++ b/arch/arm/plat-armada/mv_hal/neta/pmt/mvPmt.h
@@ -39,7 +39,7 @@ Redistribution and use in source and bin
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	this list of conditions and the following disclaimer.
+	    this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
 	notice, this list of conditions and the following disclaimer in the
@@ -73,20 +73,187 @@ extern "C" {
 #include "mvTypes.h"
 #include "mvCommon.h"
 #include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+#define PMT_TEXT    16
+
+#define PMT_PRINT_VALID_FLAG    0x01
+
+
+typedef union mv_neta_pmt_t {
+	MV_U32	word;
 
-typedef struct mv_neta_pmt_t{
-	MV_U16	mt_w0;	/* W0 - bits[15-0] */
-	MV_U32	mt_w1;	/* W1 - bits[31-0] */
-	MV_U32	mt_w2;	/* W2 - bits[26-0] */
 } MV_NETA_PMT;
 
-MV_STATUS	mvNetaPmtWrite(int port, int idx, MV_NETA_PMT *pEntry);
-MV_STATUS 	mvNetaPmtRead(int port, int idx, MV_NETA_PMT *pEntry);
-MV_STATUS	mvNetaPmtInit(int port);
-MV_STATUS	mvNetaPmtDump(int port);
-void		mvNetaPmtRegs(int port, int txp);
-MV_STATUS	mvNetaPmtMhRegSet(int port, int txp, int reg, MV_U16 val);
-MV_STATUS	mvNetaPmtEthTypeRegSet(int port, int txp, int reg, MV_U16 val);
+#define MV_NETA_PMT_DATA_OFFS       0
+#define MV_NETA_PMT_DATA_BITS       16
+#define MV_NETA_PMT_DATA_MASK       (((1 << MV_NETA_PMT_DATA_BITS) - 1) << MV_NETA_PMT_DATA_OFFS)
+
+#define MV_NETA_PMT_CTRL_OFFS       16
+#define MV_NETA_PMT_CTRL_BITS       16
+#define MV_NETA_PMT_CTRL_MASK       (((1 << MV_NETA_PMT_CTRL_BITS) - 1) << MV_NETA_PMT_CTRL_OFFS)
+
+#define MV_NETA_PMT_CMD_OFFS        16
+#define MV_NETA_PMT_CMD_BITS        5
+#define MV_NETA_PMT_CMD_ALL_MASK    (((1 << MV_NETA_PMT_CMD_BITS) - 1) << MV_NETA_PMT_CMD_OFFS)
+#define MV_NETA_PMT_CMD_MASK(cmd)   ((cmd) << MV_NETA_PMT_CMD_OFFS)
+
+enum {
+    MV_NETA_CMD_NONE        = 0,
+    MV_NETA_CMD_ADD_2B,
+    MV_NETA_CMD_CFG_VLAN,
+    MV_NETA_CMD_ADD_VLAN,
+    MV_NETA_CMD_CFG_DSA_1,
+    MV_NETA_CMD_CFG_DSA_2,
+    MV_NETA_CMD_ADD_DSA,
+    MV_NETA_CMD_DEL_BYTES,
+    MV_NETA_CMD_REPLACE_2B,
+    MV_NETA_CMD_REPLACE_LSB,
+    MV_NETA_CMD_REPLACE_MSB,
+    MV_NETA_CMD_REPLACE_VLAN,
+    MV_NETA_CMD_DEC_LSB,
+    MV_NETA_CMD_DEC_MSB,
+    MV_NETA_CMD_ADD_CALC_LEN,
+    MV_NETA_CMD_REPLACE_LEN,
+    MV_NETA_CMD_IPV4_CSUM,
+    MV_NETA_CMD_L4_CSUM,
+    MV_NETA_CMD_SKIP,
+    MV_NETA_CMD_JUMP,
+    MV_NETA_CMD_JUMP_SKIP,
+    MV_NETA_CMD_JUMP_SUB,
+    MV_NETA_CMD_PPPOE,
+    MV_NETA_CMD_STORE,
+};
+
+#define MV_NETA_PMT_IP4_CSUM_BIT    21
+#define MV_NETA_PMT_IP4_CSUM_MASK   (1 << MV_NETA_PMT_IP4_CSUM_BIT)
+
+#define MV_NETA_PMT_L4_CSUM_BIT     22
+#define MV_NETA_PMT_L4_CSUM_MASK    (1 << MV_NETA_PMT_L4_CSUM_BIT)
+
+#define MV_NETA_PMT_LAST_BIT        23
+#define MV_NETA_PMT_LAST_MASK       (1 << MV_NETA_PMT_LAST_BIT)
+
+
+/*********** Command special defines ************/
+
+/* Bits for MV_NETA_CMD_DEL_BYTES command */
+/* [7:0] - number of words (2 bytes) to delete */
+#define MV_NETA_PMT_DEL_SHORTS_OFFS         0
+#define MV_NETA_PMT_DEL_SHORTS_MASK         (0xFF << MV_NETA_PMT_DEL_SHORTS_OFFS)
+#define MV_NETA_PMT_DEL_SHORTS(size)        (((size) << MV_NETA_PMT_DEL_SHORTS_OFFS) & MV_NETA_PMT_DEL_SHORTS_MASK)
+
+/* [11:8] - number of words (2 bytes) to skip before the delete command */
+#define MV_NETA_PMT_DEL_SKIP_B_OFFS         8
+#define MV_NETA_PMT_DEL_SKIP_B_MASK         (0xF << MV_NETA_PMT_DEL_SKIP_B_OFFS)
+#define MV_NETA_PMT_DEL_SKIP_B(size)        (((size) << MV_NETA_PMT_DEL_SKIP_B_OFFS) & MV_NETA_PMT_DEL_SKIP_B_MASK)
+
+/* [15:12] - number of words (2 bytes) to skip after the delete command */
+#define MV_NETA_PMT_DEL_SKIP_A_OFFS         12
+#define MV_NETA_PMT_DEL_SKIP_A_MASK         (0xF << MV_NETA_PMT_DEL_SKIP_A_OFFS)
+#define MV_NETA_PMT_DEL_SKIP_A(size)        (((size) << MV_NETA_PMT_DEL_SKIP_A_OFFS) & MV_NETA_PMT_DEL_SKIP_A_MASK)
+/*-----------------------------------------------------------------------------------------------------------------*/
+
+/* Bits for Add Calculated length operation */
+/* Used for commands: Add Calculated length, Replace length, Skip, */
+#define MV_NETA_PMT_ZERO_ADD                0
+#define MV_NETA_PMT_DATA_ADD                2
+#define MV_NETA_PMT_DATA_SUB                3
+
+#define MV_NETA_PMT_CALC_LEN_0_OFFS         14
+#define MV_NETA_PMT_CALC_LEN_0_MASK         (3 << MV_NETA_PMT_CALC_LEN_0_OFFS)
+#define MV_NETA_PMT_CALC_LEN_0_ZERO         (0 << MV_NETA_PMT_CALC_LEN_0_OFFS)
+#define MV_NETA_PMT_CALC_LEN_0_TX_DESC      (1 << MV_NETA_PMT_CALC_LEN_0_OFFS)
+#define MV_NETA_PMT_CALC_LEN_0_TX_PKT       (2 << MV_NETA_PMT_CALC_LEN_0_OFFS)
+#define MV_NETA_PMT_CALC_LEN_0_STORE        (3 << MV_NETA_PMT_CALC_LEN_0_OFFS)
+
+#define MV_NETA_PMT_CALC_LEN_1_OFFS         12
+#define MV_NETA_PMT_CALC_LEN_1_MASK         (3 << MV_NETA_PMT_CALC_LEN_1_OFFS)
+#define MV_NETA_PMT_CALC_LEN_1(op)          ((op) << MV_NETA_PMT_CALC_LEN_1_OFFS)
+
+#define MV_NETA_PMT_CALC_LEN_2_OFFS         10
+#define MV_NETA_PMT_CALC_LEN_2_MASK         (3 << MV_NETA_PMT_CALC_LEN_2_OFFS)
+#define MV_NETA_PMT_CALC_LEN_2(op)          ((op) << MV_NETA_PMT_CALC_LEN_2_OFFS)
+
+#define MV_NETA_PMT_CALC_LEN_3_BIT          9
+#define MV_NETA_PMT_CALC_LEN_3_ADD_MASK     (0 << MV_NETA_PMT_CALC_LEN_3_BIT)
+#define MV_NETA_PMT_CALC_LEN_3_SUB_MASK     (1 << MV_NETA_PMT_CALC_LEN_3_BIT)
+
+#define MV_NETA_PMT_CALC_LEN_DATA_OFFS      0
+#define MV_NETA_PMT_CALC_LEN_DATA_MASK      (0x1FF << MV_NETA_PMT_CALC_LEN_DATA_OFFS)
+#define MV_NETA_PMT_CALC_LEN_DATA(data)     ((data) << MV_NETA_PMT_CALC_LEN_DATA_OFFS)
+/*-----------------------------------------------------------------------------------------------------------------*/
+
+/* Bits for MV_NETA_CMD_DEC_LSB and MV_NETA_CMD_DEC_MSB commands */
+#define MV_NETA_PMT_DEC_SKIP_A_OFFS         0
+#define MV_NETA_PMT_DEC_SKIP_A_MASK         (0xFF << MV_NETA_PMT_DEC_SKIP_A_OFFS)
+#define MV_NETA_PMT_DEC_SKIP_A(size)        (((size) << MV_NETA_PMT_DEC_SKIP_A_OFFS) & MV_NETA_PMT_DEC_SKIP_A_MASK)
+
+#define MV_NETA_PMT_DEC_SKIP_B_OFFS         8
+#define MV_NETA_PMT_DEC_SKIP_B_MASK         (0xFF << MV_NETA_PMT_DEC_SKIP_B_OFFS)
+#define MV_NETA_PMT_DEC_SKIP_B(size)        (((size) << MV_NETA_PMT_DEC_SKIP_B_OFFS) & MV_NETA_PMT_DEC_SKIP_B_MASK)
+/*-----------------------------------------------------------------------------------------------------------------*/
+
+#define MV_NETA_PMT_CLEAR(pmt)          \
+		(pmt)->word = 0;
+
+#define MV_NETA_PMT_IS_VALID(pmt)        \
+		((((pmt)->word & MV_NETA_PMT_CMD_ALL_MASK) >> MV_NETA_PMT_CMD_OFFS) != MV_NETA_CMD_NONE)
+
+#define MV_NETA_PMT_INVALID_SET(pmt)        \
+		((pmt)->word = MV_NETA_PMT_CMD_MASK(MV_NETA_CMD_NONE) | MV_NETA_PMT_LAST_MASK);
+
+#define MV_NETA_PMT_CTRL_GET(pmt)           \
+		(MV_U16)(((pmt)->word & MV_NETA_PMT_CTRL_MASK) >> MV_NETA_PMT_CTRL_OFFS)
+
+#define MV_NETA_PMT_CMD_GET(pmt)           \
+		(((pmt)->word & MV_NETA_PMT_CMD_ALL_MASK) >> MV_NETA_PMT_CMD_OFFS)
+
+#define MV_NETA_PMT_DATA_GET(pmt)           \
+		(MV_U16)(((pmt)->word & MV_NETA_PMT_DATA_MASK) >> MV_NETA_PMT_DATA_OFFS)
+
+#define MV_NETA_PMT_CMD_SET(pmt, cmd)                       \
+		(pmt)->word &= ~MV_NETA_PMT_CMD_ALL_MASK;       \
+		(pmt)->word |= MV_NETA_PMT_CMD_MASK(cmd);
+
+#define MV_NETA_PMT_DATA_SET(pmt, data)                         \
+		(pmt)->word &= ~MV_NETA_PMT_DATA_MASK;              \
+		(pmt)->word |= ((data) << MV_NETA_PMT_DATA_OFFS);
+
+
+MV_STATUS   mvNetaPmtWrite(int port, int idx, MV_NETA_PMT *pEntry);
+MV_STATUS   mvNetaPmtRead(int port, int idx, MV_NETA_PMT *pEntry);
+MV_STATUS   mvNetaPmtClear(int port);
+MV_STATUS   mvNetaPmtInit(int port, MV_NETA_PMT *pBase);
+MV_VOID	    mvNetaPmtDestroy(MV_VOID);
+MV_VOID	    mvNetaPmtDump(int port, int flags);
+MV_VOID        mvNetaPmtRegs(int port, int txp);
+
+MV_VOID        mvNetaPmtEntryPrint(MV_NETA_PMT *pEntry);
+
+MV_VOID        mvNetaPmtAdd2Bytes(MV_NETA_PMT *pEntry, MV_U16 data);
+MV_VOID        mvNetaPmtReplace2Bytes(MV_NETA_PMT *pEntry, MV_U16 data);
+MV_VOID        mvNetaPmtDelShorts(MV_NETA_PMT *pEntry, MV_U8 bDelete,
+				MV_U8 skipBefore, MV_U8 skipAfter);
+MV_VOID        mvNetaPmtReplaceLSB(MV_NETA_PMT *pEntry, MV_U8 value, MV_U8 mask);
+MV_VOID        mvNetaPmtReplaceMSB(MV_NETA_PMT *pEntry, MV_U8 value, MV_U8 mask);
+
+MV_VOID        mvNetaPmtDecLSB(MV_NETA_PMT *pEntry, MV_U8 skipBefore, MV_U8 skipAfter);
+MV_VOID        mvNetaPmtDecMSB(MV_NETA_PMT *pEntry, MV_U8 skipBefore, MV_U8 skipAfter);
+
+MV_VOID        mvNetaPmtLastFlag(MV_NETA_PMT *pEntry, int last);
+MV_VOID        mvNetaPmtFlags(MV_NETA_PMT *pEntry, int last, int ipv4, int l4);
+MV_VOID        mvNetaPmtSkip(MV_NETA_PMT *pEntry, MV_U16 shorts);
+MV_VOID        mvNetaPmtReplaceIPv4csum(MV_NETA_PMT *pEntry, MV_U16 data);
+MV_VOID        mvNetaPmtReplaceL4csum(MV_NETA_PMT *pEntry, MV_U16 data);
+MV_VOID        mvNetaPmtJump(MV_NETA_PMT *pEntry, MV_U16 target, int type, int cond);
+
+/* High level PMT configurations */
+int         mvNetaPmtTtlDec(int port, int idx, int ip_offs, int isLast);
+int         mvNetaPmtDataReplace(int port, int idx, int offset,
+				 MV_U8 *data, int bytes, int isLast);
+
+
 
 #ifdef __cplusplus
 }
--- a/arch/arm/plat-armada/mv_hal/neta/pnc/mvPnc.c
+++ b/arch/arm/plat-armada/mv_hal/neta/pnc/mvPnc.c
@@ -96,7 +96,6 @@ static int rxq_ip6 = CONFIG_MV_ETH_RXQ_D
 static int rxq_ip4 = CONFIG_MV_ETH_RXQ_DEF;
 static int rxq_ip4_tcp = CONFIG_MV_ETH_RXQ_DEF;
 static int rxq_ip4_udp = CONFIG_MV_ETH_RXQ_DEF;
-static int rxq_ip4_igmp = CONFIG_MV_ETH_RXQ_DEF;
 static int rxq_arp 		= CONFIG_MV_ETH_RXQ_DEF;
 
 
@@ -517,92 +516,35 @@ static void pnc_match_etype(struct tcam_
 	tcam_sw_set_byte(te, 1, ethertype & 0xFF);
 }
 
-/*
- * VLAN section: Add non-Ethertype II match rules
- */
-#ifdef CONFIG_MV_ETH_PNC_SNAP
-static int pnc_snap_llc(void)
+/* Set VLAN entry */
+int pnc_vlan_set(int prio, int rxq)
 {
 	struct tcam_entry *te;
-	int tid = TE_SNAP;
+	int tid;
 
 	PNC_DBG("%s\n", __func__);
 
-	/* 0x8870 SNAP */
-	te = tcam_sw_alloc(TCAM_LU_L2);
-	pnc_match_etype(te, 0x8870);
-	sram_sw_set_rinfo(te, RI_ETYPE_8023);
-	sram_sw_set_lookup_done(te, 1);
-	tcam_sw_text(te, "snap");
-
-	tcam_hw_write(te, tid++);
-	tcam_sw_free(te);
-
-	/* 1536 */
-	te = tcam_sw_alloc(TCAM_LU_L2);
-	pnc_match_etype(te, 0x0600);
-	sram_sw_set_rinfo(te, RI_ETYPE_8023);
-	sram_sw_set_lookup_done(te, 1);
-	tcam_sw_text(te, "802.3");
-
-	tcam_hw_write(te, tid++);
-	tcam_sw_free(te);
-
-	/* 1024-1535 with LLC/SNAP */
-	te = tcam_sw_alloc(TCAM_LU_L2);
-	tcam_sw_set_byte(te, 0, 0x04);
-	tcam_sw_set_mask(te, 0, 0xFE);
-	tcam_sw_set_byte(te, 2, 0xAA);
-	tcam_sw_set_byte(te, 3, 0xAA);
-	sram_sw_set_rinfo(te, RI_ETYPE_8023);
-	sram_sw_set_next_lookup(te, TCAM_LU_L2);
-	sram_sw_set_shift_update(te, 0, 2 + MV_LLC_HLEN);
-	tcam_sw_text(te, "llc");
-
-	tcam_hw_write(te, tid++);
-	tcam_sw_free(te);
-
-	/* 0-1023 with LLC/SNAP */
-	te = tcam_sw_alloc(TCAM_LU_L2);
-	tcam_sw_set_byte(te, 0, 0x00);
-	tcam_sw_set_mask(te, 0, 0xFC);
-	tcam_sw_set_byte(te, 2, 0xAA);
-	tcam_sw_set_byte(te, 3, 0xAA);
-	sram_sw_set_rinfo(te, RI_ETYPE_8023);
-	sram_sw_set_next_lookup(te, TCAM_LU_L2);
-	sram_sw_set_shift_update(te, 0, 2 + MV_LLC_HLEN);
-	tcam_sw_text(te, "llc");
-
-	tcam_hw_write(te, tid++);
-	tcam_sw_free(te);
-
-	ERR_ON_OOR(--tid > TE_SNAP_END);
-
-	return 0;
-}
-#endif /* CONFIG_MV_ETH_PNC_SNAP */
-
-/*
- * VLAN section - Add 802.1p priority rules
- */
-int pnc_vlan_prio(unsigned char prio, int rxq)
-{
-
-	return 0;
-}
-
-/* VLAN default entry */
-static int pnc_vlan_def(void)
-{
-	struct tcam_entry *te;
-	int tid = TE_VLAN_DEF;
+	/* check validity */
+	if ((TE_VLAN + prio) > TE_VLAN_EOF)
+		return 1;
 
-	PNC_DBG("%s\n", __func__);
+	if ((prio < 0) || (prio > 7))
+		return 1;
 
 	te = tcam_sw_alloc(TCAM_LU_L2);
 	pnc_match_etype(te, MV_VLAN_TYPE);
 
-	sram_sw_set_rxq(te, rxq_vlan, 0);
+	tcam_sw_set_byte(te, 2, prio << 5);
+	if (prio == 0) {
+		/* Set default VLAN entry */
+		tid = TE_VLAN_EOF;
+		tcam_sw_set_mask(te, 2, 0);
+	} else {
+		tid = TE_VLAN + prio - 1;
+		tcam_sw_set_mask(te, 2, 7 << 5);
+	}
+
+	sram_sw_set_rxq(te, rxq, 0);
 
 	sram_sw_set_rinfo(te, RI_VLAN);
 	sram_sw_set_next_lookup(te, TCAM_LU_L2);
@@ -617,13 +559,13 @@ static int pnc_vlan_def(void)
 
 int pnc_vlan_init(void)
 {
-	PNC_DBG("%s\n", __func__);
+	int prio;
 
-#ifdef CONFIG_MV_ETH_PNC_SNAP
-	pnc_snap_llc();
-#endif /* CONFIG_MV_ETH_PNC_SNAP */
+	PNC_DBG("%s\n", __func__);
 
-	pnc_vlan_def();
+	for (prio = 0; prio <= 7; prio++)
+		if (pnc_vlan_set(prio, rxq_vlan))
+			break;
 
 	return 0;
 }
@@ -634,10 +576,12 @@ int pnc_vlan_init(void)
  *
  ******************************************************************************
  */
-static void pnc_etype_arp(void)
+/* match arp */
+void pnc_etype_arp(int rxq)
 {
-	/* match arp */
 	struct tcam_entry *te;
+
+	rxq_arp = rxq;
 	te = tcam_sw_alloc(TCAM_LU_L2);
 	pnc_match_etype(te, MV_IP_ARP_TYPE);
 	sram_sw_set_lookup_done(te, 1);
@@ -648,10 +592,11 @@ static void pnc_etype_arp(void)
 	tcam_sw_free(te);
 }
 
+/* match ip4 */
 static void pnc_etype_ip4(void)
 {
-	/* match ip4 */
 	struct tcam_entry *te;
+
 	te = tcam_sw_alloc(TCAM_LU_L2);
 	pnc_match_etype(te, MV_IP_TYPE);
 	sram_sw_set_shift_update(te, 0, MV_ETH_TYPE_LEN);
@@ -662,10 +607,11 @@ static void pnc_etype_ip4(void)
 	tcam_sw_free(te);
 }
 
+/* match ip6 */
 static void pnc_etype_ip6(void)
 {
-	/* match ip6 */
 	struct tcam_entry *te;
+
 	te = tcam_sw_alloc(TCAM_LU_L2);
 	pnc_match_etype(te, MV_IP6_TYPE);
 	sram_sw_set_shift_update(te, 0, MV_ETH_TYPE_LEN);
@@ -676,9 +622,9 @@ static void pnc_etype_ip6(void)
 	tcam_sw_free(te);
 }
 
+/* match pppoe */
 static void pnc_etype_pppoe(void)
 {
-	/* match pppoe */
 	struct tcam_entry *te;
 
 	/* IPv4 over PPPoE */
@@ -721,7 +667,7 @@ static int pnc_etype_init(void)
 
 	PNC_DBG("%s\n", __func__);
 
-	pnc_etype_arp();
+	pnc_etype_arp(CONFIG_MV_ETH_RXQ_DEF);
 	pnc_etype_ip4();
 	pnc_etype_ip6();
 	pnc_etype_pppoe();
@@ -827,15 +773,14 @@ int pnc_ip4_dscp(unsigned char dscp, uns
 #endif /* (CONFIG_MV_ETH_PNC_DSCP_PRIO > 0) */
 }
 
-/*
- * pnc_ip4_tcp - TCP/IP header parsing for fragmentation
- *                 and L4 offset.
- */
-static void pnc_ip4_tcp(void)
+
+/* IPv4/TCP header parsing for fragmentation and L4 offset.  */
+void pnc_ip4_tcp(int rxq)
 {
 	struct tcam_entry *te;
 
 	PNC_DBG("%s\n", __func__);
+	rxq_ip4_tcp = rxq;
 
 	/* TCP, FRAG=0 normal */
 	te = tcam_sw_alloc(TCAM_LU_IP4);
@@ -869,15 +814,13 @@ static void pnc_ip4_tcp(void)
 	tcam_sw_free(te);
 }
 
-/*
- * pnc_ip4_udp - UDP/UDP header parsing for fragmentation
- *                 and L4 offset.
- */
-static void pnc_ip4_udp(void)
+/* IPv4/UDP header parsing for fragmentation and L4 offset. */
+void pnc_ip4_udp(int rxq)
 {
 	struct tcam_entry *te;
 
 	PNC_DBG("%s\n", __func__);
+	rxq_ip4_udp = rxq;
 
 	/* UDP, FRAG=0 normal */
 	te = tcam_sw_alloc(TCAM_LU_IP4);
@@ -910,27 +853,6 @@ static void pnc_ip4_udp(void)
 	tcam_sw_free(te);
 }
 
-/*
- * IGMP
- */
-static void pnc_ip4_igmp(void)
-{
-	struct tcam_entry *te;
-
-	PNC_DBG("%s\n", __func__);
-
-	te = tcam_sw_alloc(TCAM_LU_IP4);
-	tcam_sw_set_byte(te, 9, MV_IP_PROTO_IGMP);
-	sram_sw_set_lookup_done(te, 1);
-
-	sram_sw_set_rinfo(te, RI_L3_IP4 | RI_L4_UN | RI_IGMP);
-	sram_sw_set_rxq(te, rxq_ip4_igmp, 0);
-	tcam_sw_text(te, "ipv4_igmp");
-
-	tcam_hw_write(te, TE_IP4_IGMP);
-	tcam_sw_free(te);
-}
-
 /* IPv4 - end of section  */
 static void pnc_ip4_end(void)
 {
@@ -953,9 +875,8 @@ int pnc_ip4_init(void)
 {
 	PNC_DBG("%s\n", __func__);
 
-	pnc_ip4_tcp();
-	pnc_ip4_udp();
-	pnc_ip4_igmp();
+	pnc_ip4_tcp(CONFIG_MV_ETH_RXQ_DEF);
+	pnc_ip4_udp(CONFIG_MV_ETH_RXQ_DEF);
 	/*pnc_ip4_esp();*/
 	pnc_ip4_end();
 
@@ -1050,10 +971,10 @@ int pnc_ip6_init(void)
 	return 0;
 }
 
-#ifdef CONFIG_MV_ETH_NFP_PNC
+#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
 /******************************************************************************
  *
- * NFP Section
+ * L3 Flows Section
  *
  ******************************************************************************
  */
@@ -1152,12 +1073,12 @@ int pnc_ipv4_2_tuples_add(unsigned int t
 	struct tcam_entry *te;
 
 	PNC_DBG("%s [%d] flow=%d " MV_IPQUAD_FMT "->" MV_IPQUAD_FMT "\n",
-		__func__, tid, flow_id, MV_IPQUAD(sip), MV_IPQUAD(dip));
+		__func__, tid, flow_id, MV_IPQUAD(((MV_U8 *)&sip)), MV_IPQUAD(((MV_U8 *)&dip)));
 
-	if (tid < TE_FLOW_NFP)
+	if (tid < TE_FLOW_L3)
 		ERR_ON_OOR(1);
 
-	if (tid > TE_FLOW_NFP_END)
+	if (tid > TE_FLOW_L3_END)
 		ERR_ON_OOR(1);
 
 	te = tcam_sw_alloc(TCAM_LU_FLOW_IP4);
@@ -1175,7 +1096,7 @@ int pnc_ipv4_2_tuples_add(unsigned int t
 	sram_sw_set_lookup_done(te, 1);
 	sram_sw_set_flowid(te, flow_id, FLOWID_CTRL_FULL_MASK);
 	sram_sw_set_rxq(te, rxq, 0);
-	sram_sw_set_rinfo(te, RI_NFP_FLOW);
+	sram_sw_set_rinfo(te, RI_L3_FLOW);
 	tcam_sw_text(te, "ipv4_2t");
 
 	tcam_hw_write(te, tid);
@@ -1194,7 +1115,7 @@ int pnc_ipv4_5_tuples_add(unsigned int t
 	struct tcam_entry *te;
 
 	PNC_DBG("%s [%d] flow=%d " MV_IPQUAD_FMT "->" MV_IPQUAD_FMT ", ports=0x%x, proto=%d\n",
-		__func__, tid, flow_id, MV_IPQUAD(sip), MV_IPQUAD(dip), ports, proto);
+		__func__, tid, flow_id, MV_IPQUAD(((MV_U8 *)&sip)), MV_IPQUAD(((MV_U8 *)&dip)), ports, proto);
 
 	if (tid < TE_FLOW_NFP)
 		ERR_ON_OOR(1);
@@ -1375,42 +1296,3 @@ void pnc_mac_show(void)
 	}
 }
 
-/*
- * pnc_rxq - Set RxQ for protocol
- */
-int pnc_rxq_proto(unsigned int proto, unsigned int rxq)
-{
-	PNC_DBG("%s proto=%x rxq=%d\n", __func__, proto, rxq);
-
-	switch (proto) {
-
-	case MV_IP_ARP_TYPE:
-		rxq_arp = rxq;
-		if (pnc_inited)
-			pnc_etype_arp();
-		break;
-
-	case MV_IP_PROTO_TCP:
-		rxq_ip4_tcp = rxq;
-		if (pnc_inited)
-			pnc_ip4_tcp();
-		break;
-
-	case MV_IP_PROTO_UDP:
-		rxq_ip4_udp = rxq;
-		if (pnc_inited)
-			pnc_ip4_udp();
-		break;
-
-	case MV_IP_PROTO_IGMP:
-		rxq_ip4_igmp = rxq;
-		if (pnc_inited)
-			pnc_ip4_igmp();
-		break;
-	default:
-		return PNC_ERR_INV;
-	}
-
-	return 0;
-}
-
--- a/arch/arm/plat-armada/mv_hal/neta/pnc/mvPnc.h
+++ b/arch/arm/plat-armada/mv_hal/neta/pnc/mvPnc.h
@@ -65,6 +65,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #ifndef __MV_PNC_H__
 #define __MV_PNC_H__
 
+
 #include "mvTcam.h"
 
 /*
@@ -81,40 +82,36 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #define PNC_ERR_INV			1			/* invalid parameter */
 
  /* Result info bits assigment */
-#define RI_DROP			    (BIT0)		/* drop */
+#define RI_DROP	            (BIT0)		/* drop */
 
-#define RI_L4_OFFS     		1
-#define RI_L4_MASK     		(3 << RI_L4_OFFS)
+#define RI_L4_OFFS     	    1
+#define RI_L4_MASK     	    (3 << RI_L4_OFFS)
 #define RI_L4_TCP           (0 << RI_L4_OFFS)
 #define RI_L4_UDP           (1 << RI_L4_OFFS)
 #define RI_L4_UN            (2 << RI_L4_OFFS)
 
-#define RI_L3_OFFS     		3
-#define RI_L3_MASK     		(7 << RI_L3_OFFS)
+#define RI_L3_OFFS     	    3
+#define RI_L3_MASK     	    (7 << RI_L3_OFFS)
 #define RI_L3_UN            (0 << RI_L3_OFFS)
 #define RI_L3_IP6           (1 << RI_L3_OFFS)
 #define RI_L3_IP4_FRAG      (2 << RI_L3_OFFS)
 #define RI_L3_IP4           (3 << RI_L3_OFFS)
 #define RI_L3_IP4_FRAG_F    (6 << RI_L3_OFFS)
 
-#define RI_MCAST_OFFS     	6
-#define RI_MCAST_MASK     	(3 << RI_MCAST_OFFS)
+#define RI_MCAST_OFFS       6
+#define RI_MCAST_MASK       (3 << RI_MCAST_OFFS)
 #define RI_MCAST_SPEC       (0 << RI_MCAST_OFFS)
 #define RI_MCAST_PNC_SPEC   (1 << RI_MCAST_OFFS)
 #define RI_MCAST_OTHER      (2 << RI_MCAST_OFFS)
 #define RI_MCAST_PNC_OTHER  (3 << RI_MCAST_OFFS)
 #define RI_MCAST_PNC_ONLY   (4 << RI_MCAST_OFFS)
 
-#define RI_DA_MC 		    (BIT10)	/* multicast */
-#define RI_DA_BC 		    (BIT11)	/* broadcast */
-#define RI_DA_ME		    (BIT12)	/* unicast */
-#define RI_IGMP			    (BIT13)	/* IGMP */
-#define RI_ETYPE_8023	    (BIT14)	/* 802.3/LLC/SNAP encapsulation */
-#define RI_VLAN			    (BIT15)	/* VLAN */
-#define RI_PPPOE            (BIT16)	/* PPPoE */
-
-#define RI_NFP_FLOW		    (BIT18)	/* NFP flowid is valid */
-#define RI_NFP_SWF_FLOW     (BIT19)	/* NFP_SWF flowid is valid */
+#define RI_VLAN             (BIT9)      /* VLAN */
+#define RI_DA_MC            (BIT10)	/* multicast */
+#define RI_DA_BC            (BIT11)	/* broadcast */
+#define RI_DA_ME            (BIT12)	/* unicast */
+#define RI_PPPOE            (BIT13)	/* PPPoE */
+/* BITS 14-17 are reserved for setting MH field in HWF packets (TXz_MH_reg_1-15) */
 #define RI_RX_SPECIAL       (BIT20) /* Packet for special RX processing */
 
  /* Additional info bits assigment */
@@ -122,21 +119,17 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #define AI_DONE_MASK        (1 << AI_DONE_BIT)
 
 /* PnC result info */
+#define NETA_PNC_VLAN       (RI_VLAN  >> 9)
 #define NETA_PNC_DA_MC      (RI_DA_MC >> 9)
 #define NETA_PNC_DA_BC      (RI_DA_BC >> 9)
 #define NETA_PNC_DA_UC      (RI_DA_ME >> 9)
-#define NETA_PNC_IGMP       (RI_IGMP >> 9)
-#define NETA_PNC_SNAP       (RI_ETYPE_8023 >> 9)
-#define NETA_PNC_VLAN       (RI_VLAN >> 9)
 #define NETA_PNC_PPPOE      (RI_PPPOE >> 9)
-#define NETA_PNC_NFP        (RI_NFP_FLOW >> 9)
-#define NETA_PNC_SWF        (RI_NFP_SWF_FLOW >> 9)
 #define NETA_PNC_RX_SPECIAL (RI_RX_SPECIAL >> 9)
 /*---------------------------------------------------------------------------*/
 
 MV_STATUS   mvPncInit(MV_U8 *pncVirtBase);
 
-#ifdef CONFIG_MV_ETH_PNC_PARSER
+#ifdef CONFIG_MV_ETH_PNC
 /*
  * TCAM topology definition.
  * The TCAM is divided into sections per protocol encapsulation.
@@ -154,21 +147,14 @@ enum {
 	TE_MAC_ME_END = TE_MAC_ME + CONFIG_MV_ETH_PORTS_NUM - 1,
 	TE_MAC_EOF,
 
-	/* L2 Lookup */
-#ifdef CONFIG_MV_ETH_PNC_SNAP
-	/* SNAP/LLC Lookup */
-	TE_SNAP,
-	TE_SNAP_END = TE_SNAP + 4 - 1,
-#endif /* CONFIG_MV_ETH_PNC_SNAP */
-
     /* VLAN Lookup */
-#if (CONFIG_MV_ETH_PNC_VLAN_PRIO > 0)
-	TE_VLAN_PRI,
-	TE_VLAN_PRI_END = TE_VLAN_PRI + CONFIG_MV_ETH_PNC_VLAN_PRIO - 1,
+	TE_VLAN,
+#ifdef CONFIG_MV_ETH_PNC_VLAN_PRIO
+	TE_VLAN_EOF = TE_VLAN + 7,
+#else
+	TE_VLAN_EOF = TE_VLAN,
 #endif /* CONFIG_MV_ETH_PNC_VLAN_PRIO */
 
-	TE_VLAN_DEF,
-
     /* Ethertype Lookup */
 	TE_ETYPE_ARP,
 	TE_ETYPE_IP4,
@@ -197,15 +183,15 @@ enum {
 	TE_IP6_UDP,
 	TE_IP6_EOF,
 
-#ifdef CONFIG_MV_ETH_NFP_PNC
+#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
 	/* Session Lookup for IPv4 and IPv6 */
 	/* NFP session use all rest entries */
-	TE_FLOW_NFP,
-	TE_FLOW_NFP_END = CONFIG_MV_PNC_TCAM_LINES - 4,
+	TE_FLOW_L3,
+	TE_FLOW_L3_END = CONFIG_MV_PNC_TCAM_LINES - 4,
 	TE_FLOW_IP4_EOF,
 	TE_FLOW_IP6_A_EOF,
 	TE_FLOW_IP6_B_EOF,
-#endif /* CONFIG_MV_ETH_NFP_PNC */
+#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
 
 #ifdef CONFIG_MV_ETH_PNC_WOL
 	TE_WOL,
@@ -299,6 +285,18 @@ int pnc_mac_me(unsigned int port, unsign
 /* Set Multicast MAC address to be accepted on the port */
 int pnc_mcast_me(unsigned int port, unsigned char *mac);
 
+/* Set VLAN priority entry */
+int pnc_vlan_set(int prio, int rxq);
+
+/* match arp */
+void pnc_etype_arp(int rxq);
+
+/* TCP/IP header parsing for fragmentation and L4 offset.  */
+void pnc_ip4_tcp(int rxq);
+
+/* IPv4/UDP header parsing for fragmentation and L4 offset. */
+void pnc_ip4_udp(int rxq);
+
 /* Enable / Disable accept ALL Multicast */
 int pnc_mcast_all(unsigned int port, int en);
 
@@ -309,7 +307,6 @@ int     pnc_ip4_dscp(unsigned char dscp,
 void    pnc_ipv4_dscp_show(void);
 
 
-#ifdef CONFIG_MV_ETH_NFP_PNC
 /* 2 tuple match */
 int pnc_ipv4_2_tuples_add(unsigned int tid, unsigned int flow_hi,
 			      unsigned int sip, unsigned int dip, unsigned int rxq);
@@ -321,7 +318,6 @@ int pnc_ipv6_2_tuples_add(unsigned int t
 int pnc_ipv4_5_tuples_add(unsigned int tid, unsigned int flow_hi,
 				unsigned int sip, unsigned int dip,
 				unsigned int proto, unsigned int ports, unsigned int rxq);
-#endif /* CONFIG_MV_ETH_NFP_PNC */
 
 #ifdef CONFIG_MV_ETH_PNC_WOL
 void mv_pnc_wol_init(void);
@@ -336,8 +332,6 @@ int  mv_pnc_wol_rule_dump(int idx);
 void mv_pnc_wol_dump(void);
 #endif /* CONFIG_MV_ETH_PNC_WOL */
 
-#endif /* CONFIG_MV_ETH_PNC_PARSER */
-
 #ifdef MV_ETH_PNC_AGING
 MV_U32  mvPncAgingCntrRead(int tid);
 void    mvPncAgingCntrWrite(int tid, MV_U32 w32);
@@ -349,4 +343,6 @@ void    mvPncAgingCntrGroupSet(int tid,
 void    mvPncAgingCounterClear(int tid, int gr);
 #endif /* MV_ETH_PNC_AGING */
 
+#endif /* CONFIG_MV_ETH_PNC */
+
 #endif /*__MV_PNC_H__ */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncAging.c
@@ -0,0 +1,279 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include "mvOs.h"
+#include "mvCommon.h"
+
+#include "gbe/mvNetaRegs.h"
+
+#include "mvPnc.h"
+#include "mvTcam.h"
+
+#define PNC_AGING_CNTRS_ADDR_MASK       (0 << 12)
+#define PNC_AGING_GROUPS_ADDR_MASK      (1 << 12)
+#define PNC_AGING_SCANNER_ADDR_MASK     (2 << 12)
+
+#define PNC_AGING_CNTR_IDX_ADDR_OFFS    2
+#define PNC_AGING_GROUP_ADDR_OFFS       2
+#define PNC_AGING_LOG_ADDR_OFFS         5
+
+#define PNC_AGING_CNTR_OFFS             0
+#define PNC_AGING_CNTR_MAX              0x3ffffff
+#define PNC_AGING_CNTR_MASK             (PNC_AGING_CNTR_MAX << PNC_AGING_CNTR_OFFS)
+
+#define PNC_AGING_GROUP_OFFS            26
+#define PNC_AGING_GROUP_ALL_MASK        (0x3 << PNC_AGING_GROUP_OFFS)
+#define PNC_AGING_GROUP_MASK(gr)        ((gr) << PNC_AGING_GROUP_OFFS)
+
+#define PNC_AGING_READ_LU_LOG_BIT       28
+#define PNC_AGING_READ_LU_LOG_MASK      (1 << PNC_AGING_READ_LU_LOG_BIT)
+
+#define PNC_AGING_READ_MU_LOG_BIT       29
+#define PNC_AGING_READ_MU_LOG_MASK      (1 << PNC_AGING_READ_MU_LOG_BIT)
+
+#define PNC_AGING_SKIP_LU_SCAN_BIT      30
+#define PNC_AGING_SKIP_LU_SCAN_MASK     (1 << PNC_AGING_SKIP_LU_SCAN_BIT)
+
+#define PNC_AGING_SKIP_MU_SCAN_BIT      31
+#define PNC_AGING_SKIP_MU_SCAN_MASK     (1 << PNC_AGING_SKIP_MU_SCAN_BIT)
+
+#define PNC_AGING_LOG_CNTR_IDX_OFFS     0
+#define PNC_AGING_LOG_CNTR_IDX_MASK     (0x3FF << PNC_AGING_LOG_CNTR_IDX_OFFS)
+
+#define PNC_AGING_LOG_VALID_BIT         31
+#define PNC_AGING_LOG_VALID_MASK        (1 << PNC_AGING_LOG_VALID_BIT)
+
+extern char tcam_text[CONFIG_MV_PNC_TCAM_LINES][TCAM_TEXT];
+extern MV_U8 *mvPncVirtBase;
+
+void    mvPncAgingCntrWrite(int tid, MV_U32 w32)
+{
+	MV_U32  va;
+
+	WARN_ON_OOR(tid >= CONFIG_MV_PNC_TCAM_LINES);
+
+	va = (MV_U32)mvPncVirtBase;
+	va |= PNC_AGING_ACCESS_MASK;
+	va |= PNC_AGING_CNTRS_ADDR_MASK;
+	va |= (tid << PNC_AGING_CNTR_IDX_ADDR_OFFS);
+/*
+	mvOsPrintf("%s: tid=%d, va=0x%x, w32=0x%08x\n",
+		__func__, tid, va, w32);
+*/
+	MV_MEMIO32_WRITE(va, w32);
+}
+
+
+MV_U32  mvPncAgingCntrRead(int tid)
+{
+	MV_U32  va, w32;
+
+	ERR_ON_OOR(tid >= CONFIG_MV_PNC_TCAM_LINES);
+
+	va = (MV_U32)mvPncVirtBase;
+	va |= PNC_AGING_ACCESS_MASK;
+	va |= PNC_AGING_CNTRS_ADDR_MASK;
+	va |= (tid << PNC_AGING_CNTR_IDX_ADDR_OFFS);
+
+	w32 = MV_MEMIO32_READ(va);
+/*
+	mvOsPrintf("%s: tid=%d, va=0x%x, w32=0x%08x\n",
+		__func__, tid, va, w32);
+*/
+	return w32;
+}
+
+MV_U32  mvPncAgingGroupCntrRead(int group)
+{
+	MV_U32  va, w32;
+
+	ERR_ON_OOR(group >= MV_PNC_AGING_MAX_GROUP);
+
+	va = (MV_U32)mvPncVirtBase;
+	va |= PNC_AGING_ACCESS_MASK;
+	va |= PNC_AGING_GROUPS_ADDR_MASK;
+	va |= (group << PNC_AGING_GROUP_ADDR_OFFS);
+
+	w32 = MV_MEMIO32_READ(va);
+
+	return w32;
+}
+
+void    mvPncAgingGroupCntrClear(int group)
+{
+	MV_U32  w32;
+
+	WARN_ON_OOR(group >= MV_PNC_AGING_MAX_GROUP);
+
+	w32 = MV_REG_READ(MV_PNC_AGING_CTRL_REG);
+	w32 |= MV_PNC_AGING_GROUP_RESET(group);
+	MV_REG_WRITE(MV_PNC_AGING_CTRL_REG, w32);
+}
+
+MV_U32  mvPncAgingLogEntryRead(int group, int mostly)
+{
+	MV_U32  va, w32;
+
+	ERR_ON_OOR(group >= MV_PNC_AGING_MAX_GROUP);
+
+	va = (MV_U32)mvPncVirtBase;
+	va |= PNC_AGING_ACCESS_MASK;
+	va |= PNC_AGING_SCANNER_ADDR_MASK;
+	va |= ((MV_PNC_AGING_MAX_GROUP * mostly + group) << PNC_AGING_LOG_ADDR_OFFS);
+
+	w32 = MV_MEMIO32_READ(va);
+
+	return w32;
+}
+
+void    mvPncAgingCntrShow(int tid, MV_32 w32)
+{
+	mvOsPrintf("[%3d] (%-12s): gr=%d - %10u", tid, tcam_text[tid],
+		((w32 & PNC_AGING_GROUP_ALL_MASK) >> PNC_AGING_GROUP_OFFS),
+		((w32 & PNC_AGING_CNTR_MASK) >> PNC_AGING_CNTR_OFFS));
+
+	if (w32 & PNC_AGING_READ_LU_LOG_MASK)
+		mvOsPrintf(", LU_READ");
+
+	if (w32 & PNC_AGING_READ_MU_LOG_MASK)
+		mvOsPrintf(", MU_READ");
+
+	if (w32 & PNC_AGING_SKIP_LU_SCAN_MASK)
+		mvOsPrintf(", LU_SKIP");
+
+	if (w32 & PNC_AGING_SKIP_MU_SCAN_MASK)
+		mvOsPrintf(", MU_SKIP");
+
+	mvOsPrintf("\n");
+}
+
+void    mvPncAgingDump(int all)
+{
+	int     tid, gr;
+	MV_U32  cntrVal;
+
+	mvOsPrintf("TCAM entries Aging counters: %s\n", all ? "ALL" : "Non ZERO");
+	for (tid = 0; tid < CONFIG_MV_PNC_TCAM_LINES; tid++) {
+		cntrVal = mvPncAgingCntrRead(tid);
+
+		if (all || (cntrVal & PNC_AGING_CNTR_MASK))
+			mvPncAgingCntrShow(tid, cntrVal);
+	}
+	mvOsPrintf("Aging Counters Summary per group: \n");
+	for (gr = 0; gr < MV_PNC_AGING_MAX_GROUP; gr++)
+		mvOsPrintf("group #%d: %10u\n", gr, mvPncAgingGroupCntrRead(gr));
+}
+
+static MV_U32  mvPncScannerLog[CONFIG_MV_PNC_TCAM_LINES];
+static MV_U32  mvPncAgingCntrs[CONFIG_MV_PNC_TCAM_LINES];
+
+void    mvPncAgingScannerDump(void)
+{
+	int     i, j, gr;
+	MV_U32  w32;
+
+	mvOsPrintf("Scanner LU Log entries for aging counters:\n");
+	for (gr = 0; gr < MV_PNC_AGING_MAX_GROUP; gr++) {
+		i = 0;
+		mvOsPrintf("LU group #%d:\n", gr);
+		while (i < CONFIG_MV_PNC_TCAM_LINES) {
+			w32 = mvPncAgingLogEntryRead(gr, 0);
+			if ((w32 & PNC_AGING_LOG_VALID_MASK) == 0)
+				break;
+
+			mvOsDelay(20);
+			mvPncAgingCntrs[i] = mvPncAgingCntrRead(w32 & PNC_AGING_LOG_CNTR_IDX_MASK);
+			mvPncScannerLog[i] = w32;
+			i++;
+		}
+		for (j = 0; j < i; j++) {
+			mvOsPrintf("%d: 0x%08x - tid=%u, 0x%08x - cntr=%u\n",
+				j, mvPncScannerLog[j], mvPncScannerLog[j] & PNC_AGING_LOG_CNTR_IDX_MASK,
+				mvPncAgingCntrs[j],
+				(mvPncAgingCntrs[j] & PNC_AGING_CNTR_MASK) >> PNC_AGING_CNTR_OFFS);
+		}
+	}
+
+	mvOsPrintf("\n");
+	mvOsPrintf("Scanner MU Log entries for aging counters:\n");
+	for (gr = 0; gr < MV_PNC_AGING_MAX_GROUP; gr++) {
+		i = 0;
+		mvOsPrintf("MU group #%d:\n", gr);
+		while (i < CONFIG_MV_PNC_TCAM_LINES) {
+			w32 = mvPncAgingLogEntryRead(gr, 1);
+			/*mvOsDelay(1);*/
+			if ((w32 & PNC_AGING_LOG_VALID_MASK) == 0)
+				break;
+
+			mvOsDelay(20);
+			mvPncAgingCntrs[i] = mvPncAgingCntrRead(w32 & PNC_AGING_LOG_CNTR_IDX_MASK);
+			mvPncScannerLog[i] = w32;
+			i++;
+		}
+		for (j = 0; j < i; j++) {
+			mvOsPrintf("%d: 0x%08x - tid=%u, 0x%08x - cntr=%u\n",
+				j, mvPncScannerLog[j], mvPncScannerLog[j] & PNC_AGING_LOG_CNTR_IDX_MASK,
+				mvPncAgingCntrs[j],
+				(mvPncAgingCntrs[j] & PNC_AGING_CNTR_MASK) >> PNC_AGING_CNTR_OFFS);
+		}
+	}
+}
+
+void    mvPncAgingCntrClear(int tid)
+{
+	MV_U32  w32;
+
+	w32 = mvPncAgingCntrRead(tid);
+
+	w32 &= ~PNC_AGING_CNTR_MASK;
+	w32 &= ~(PNC_AGING_READ_LU_LOG_MASK | PNC_AGING_READ_MU_LOG_MASK);
+
+	mvPncAgingCntrWrite(tid, w32);
+}
+
+void    mvPncAgingCntrGroupSet(int tid, int gr)
+{
+	MV_U32  w32;
+
+	w32 = PNC_AGING_GROUP_MASK(gr);
+
+	/*mvOsPrintf("%s: tid=%d, gr=%d, w32=0x%x\n", __FUNCTION__, tid, gr, w32);*/
+	mvPncAgingCntrWrite(tid, w32);
+}
+
+/* Reset all Aging counters */
+void    mvPncAgingReset(void)
+{
+	int tid, gr;
+
+	for (tid = 0; tid < CONFIG_MV_PNC_TCAM_LINES; tid++)
+		mvPncAgingCntrClear(tid);
+
+	for (gr = 0; gr < MV_PNC_AGING_MAX_GROUP; gr++)
+		mvPncAgingGroupCntrClear(gr);
+}
--- a/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncWol.c
+++ b/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncWol.c
@@ -370,8 +370,8 @@ int mv_pnc_wol_rule_del_all(int port)
 	int i;
 	MV_PNC_WOL_RULE *pWolRule;
 
-        if (mvNetaPortCheck(port))
-                return -1;
+	if (mvNetaPortCheck(port))
+		return -1;
 
 	for (i = 0; i < MV_PNC_MAX_RULES; i++) {
 		pWolRule = mv_pnc_wol_tbl[i];
@@ -418,8 +418,8 @@ int mv_pnc_wol_rule_dump(int idx)
 	int	i;
 	MV_PNC_WOL_RULE *pWolRule;
 
-        if (mvNetaMaxCheck(idx, MV_PNC_MAX_RULES))
-                return -1;
+	if (mvNetaMaxCheck(idx, MV_PNC_MAX_RULES))
+		return -1;
 
 	pWolRule = mv_pnc_wol_tbl[idx];
 	if (pWolRule == NULL)
--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -55,6 +55,9 @@
 #include <net/netns/generic.h>
 
 #define PPP_VERSION	"2.4.2"
+#if defined(CONFIG_MV_ETH_NFP_PPP) && defined(CONFIG_MV_ETH_NFP_LEARN)
+exte int nfp_hook_ppp_compnete(u32 chan, struct net_device *ppp_dev);
+#endif /* CONFIG_MV_ETH_NFP_PPP && CONFIG_MV_ETH_NFP_LEARN */
 
 /*
  * Network protocols we support.
@@ -2840,8 +2843,10 @@ ppp_connect_channel(struct channel *pch,
 	atomic_inc(&ppp->file.refcnt);
 	ppp_unlock(ppp);
 	ret = 0;
-
- outl:
+#if defined(CONFIG_MV_ETH_NFP_PPP) && defined(CONFIG_MV_ETH_NFP_LEARN)
+	nfp_hook_ppp_complete((u32)pch->chan, ppp->dev);
+#endif /* CONFIG_MV_ETH_NFP_PPP && CONFIG_MV_ETH_NFP_LEARN */ 
+outl:
 	write_unlock_bh(&pch->upl);
  out:
 	mutex_unlock(&pn->all_ppp_mutex);
--- a/drivers/net/ppp/pppoe.c
+++ b/drivers/net/ppp/pppoe.c
@@ -84,6 +84,12 @@
 #include <net/sock.h>
 
 #include <asm/uaccess.h>
+#if defined(CONFIG_MV_ETH_NFP_PPP) && defined(CONFIG_MV_ETH_NFP_LEARN)
+extern int nfp_ppp_db_init(void);
+extern int nfp_ppp_info_del(u32 channel);
+extern int nfp_hook_ppp_half_set(u16 sid, u32 chan, struct net_device *eth_dev, char *remoteMac);
+extern int nfp_ppp_db_clear(void);
+#endif /* CONFIG_MV_ETH_NFP_PPP && CONFIG_MV_ETH_NFP_LEARN */
 
 #define PPPOE_HASH_BITS 4
 #define PPPOE_HASH_SIZE (1 << PPPOE_HASH_BITS)
@@ -593,6 +599,9 @@ static int pppoe_release(struct socket *
 	 * protect "po" from concurrent updates
 	 * on pppoe_flush_dev
 	 */
+#if defined(CONFIG_MV_ETH_NFP_PPP) && defined(CONFIG_MV_ETH_NFP_LEARN)
+	nfp_ppp_info_del((u32)&po->chan);
+#endif /* CONFIG_MV_ETH_NFP_PPP && CONFIG_MV_ETH_NFP_LEARN */
 	delete_item(pn, po->pppoe_pa.sid, po->pppoe_pa.remote,
 		    po->pppoe_ifindex);
 
@@ -693,6 +702,9 @@ static int pppoe_connect(struct socket *
 		}
 
 		sk->sk_state = PPPOX_CONNECTED;
+#if defined(CONFIG_MV_ETH_NFP_PPP) && defined(CONFIG_MV_ETH_NFP_LEARN)
+		nfp_hook_ppp_half_set(sp->sa_addr.pppoe.sid, (u32)&po->chan, dev, po->pppoe_pa.remote);
+#endif /* CONFIG_MV_ETH_NFP_PPP && CONFIG_MV_ETH_NFP_LEARN */
 	}
 
 	po->num = sp->sa_addr.pppoe.sid;
@@ -1178,6 +1190,9 @@ static int __init pppoe_init(void)
 	dev_add_pack(&pppoes_ptype);
 	dev_add_pack(&pppoed_ptype);
 	register_netdevice_notifier(&pppoe_notifier);
+#if defined(CONFIG_MV_ETH_NFP_PPP) && defined(CONFIG_MV_ETH_NFP_LEARN)
+	nfp_ppp_db_init();
+#endif /* CONFIG_MV_ETH_NFP_PPP && CONFIG_MV_ETH_NFP_LEARN */
 
 	return 0;
 
@@ -1191,6 +1206,9 @@ out:
 
 static void __exit pppoe_exit(void)
 {
+#if defined(CONFIG_MV_ETH_NFP_PPP) && defined(CONFIG_MV_ETH_NFP_LEARN)
+	nfp_ppp_db_clear();
+#endif /* CONFIG_MV_ETH_NFP_PPP && CONFIG_MV_ETH_NFP_LEARN */
 	unregister_netdevice_notifier(&pppoe_notifier);
 	dev_remove_pack(&pppoed_ptype);
 	dev_remove_pack(&pppoes_ptype);
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -2734,6 +2734,26 @@ do {								\
 })
 #endif
 
+#ifdef CONFIG_MV_ETH_NFP_EXT
+
+/* Supported flags */
+#define MV_EXT_L3_VALID_MASK	0x0001
+#define MV_EXT_L4_VALID_MASK	0x0002
+#define MV_EXT_VLAN_EXIST_MASK  0x0004
+#define MV_EXT_PPP_EXIST_MASK	0x0008
+#define MV_EXT_IP_FRAG_MASK	    0x0010
+
+typedef struct {
+	u16 flags;
+	u16 l3_type;
+	u16 l3_offset;
+	u8  l3_hdrlen;
+	u8  l4_proto;
+} MV_EXT_PKT_INFO;
+
+int mv_eth_nfp_ext(struct net_device *dev, struct sk_buff *skb, MV_EXT_PKT_INFO *pkt_info);
+#endif /* CONFIG_MV_ETH_NFP_EXT */
+
 #endif /* __KERNEL__ */
 
 #endif	/* _LINUX_NETDEVICE_H */
--- /dev/null
+++ b/include/linux/netfilter/ipt_NFP.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2010 Semihalf.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _IPT_NFP_H
+#define _IPT_NFP_H
+
+#define IPT_NFP_F_SET_DSCP           0x1
+#define IPT_NFP_F_SET_DSCP_DEF       0x2
+#define IPT_NFP_F_SET_VLAN_PRIO      0x4
+#define IPT_NFP_F_SET_VLAN_PRIO_DEF  0x8
+#define IPT_NFP_F_SET_TXQ            0x10
+#define IPT_NFP_F_SET_TXP            0x20
+#define IPT_NFP_F_SET_MH             0x40
+#define IPT_NFP_F_SET_LIMIT          0x80
+#define IPT_NFP_F_SET_BURST          0x100
+
+enum ipt_nfp_mode {
+	IPT_NFP_INIT   = -1,
+	IPT_NFP_FWD    = 0,
+	IPT_NFP_DROP   = 1,
+	IPT_NFP_MANGLE = 2,
+};
+
+/* 0..7 + one cell for global mapping regardless of the old VLAN Prio value (the '-1' option) */
+#define IPT_NFP_VPRI_MAP_SIZE	9
+#define IPT_NFP_VPRI_MAP_GLOBAL	8 /* index in the array for the global mapping */
+
+typedef struct {
+	unsigned char new_prio;
+	unsigned char valid;
+} IPT_NFP_VPRI_MAP_INFO;
+
+/* 0..63 + one cell for global mapping regardless of the old DSCP value (the '-1' option) */
+#define IPT_NFP_DSCP_MAP_SIZE	65
+#define IPT_NFP_DSCP_MAP_GLOBAL	64 /* index in the array for the global mapping */
+
+typedef struct {
+	unsigned char new_dscp;
+	unsigned char valid;
+} IPT_NFP_DSCP_MAP_INFO;
+
+
+struct ipt_nfp_info {
+	unsigned int		mode;
+	unsigned int		flags;
+
+	int			burst;
+	int			limit;
+
+	int			dscp;
+	int			new_dscp;
+	IPT_NFP_DSCP_MAP_INFO	dscp_map[IPT_NFP_DSCP_MAP_SIZE];
+	int			vlanprio;
+	int			new_vlanprio;
+	IPT_NFP_VPRI_MAP_INFO	vpri_map[IPT_NFP_VPRI_MAP_SIZE];
+	int			txq;
+	int			txp;
+	int			mh;
+
+	/* private */
+	struct ipt_entry	*entry;
+};
+
+
+static inline void nfp_update_tuple_info(struct ipt_nfp_info *dst, struct ipt_nfp_info *src)
+{
+	/* we copy (override) some of the parameters, but update (accumulate) others */
+
+	dst->mode = src->mode;
+	dst->flags |= src->flags;
+
+	if (src->flags & IPT_NFP_F_SET_BURST)
+		dst->burst = src->burst;
+
+	if (src->flags & IPT_NFP_F_SET_LIMIT)
+		dst->limit = src->limit;
+
+	if (src->flags & IPT_NFP_F_SET_DSCP) {
+		dst->dscp_map[src->dscp].new_dscp = src->new_dscp;
+		dst->dscp_map[src->dscp].valid = 1;
+	}
+
+	if (src->flags & IPT_NFP_F_SET_DSCP_DEF) {
+		dst->dscp_map[IPT_NFP_DSCP_MAP_GLOBAL].new_dscp = src->new_dscp;
+		dst->dscp_map[IPT_NFP_DSCP_MAP_GLOBAL].valid = 1;
+	}
+
+	if (src->flags & IPT_NFP_F_SET_VLAN_PRIO) {
+		dst->vpri_map[src->vlanprio].new_prio = src->new_vlanprio;
+		dst->vpri_map[src->vlanprio].valid = 1;
+	}
+
+	if (src->flags & IPT_NFP_F_SET_VLAN_PRIO_DEF) {
+		dst->vpri_map[IPT_NFP_VPRI_MAP_GLOBAL].new_prio = src->new_vlanprio;
+		dst->vpri_map[IPT_NFP_VPRI_MAP_GLOBAL].valid = 1;
+	}
+
+	if (src->flags & IPT_NFP_F_SET_TXQ)
+		dst->txq = src->txq;
+
+	if (src->flags & IPT_NFP_F_SET_TXP)
+		dst->txp = src->txp;
+
+	if (src->flags & IPT_NFP_F_SET_MH)
+		dst->mh = src->mh;
+
+	dst->entry = src->entry;
+}
+
+
+#endif
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -119,6 +119,11 @@ struct rt6_info {
 	unsigned short			rt6i_nfheader_len;
 
 	u8				rt6i_protocol;
+
+#if defined (CONFIG_MV_ETH_NFP_FIB_LEARN)
+	int				rt6i_iifindex;
+	bool 			nfp;
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
 };
 
 static inline struct inet6_dev *ip6_dst_idev(struct dst_entry *dst)
--- a/include/net/neighbour.h
+++ b/include/net/neighbour.h
@@ -113,6 +113,9 @@ struct neighbour {
 	const struct neigh_ops	*ops;
 	struct rcu_head		rcu;
 	struct net_device	*dev;
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+	bool 			nfp;
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
 	u8			primary_key[0];
 };
 
--- a/include/net/netfilter/nf_conntrack.h
+++ b/include/net/netfilter/nf_conntrack.h
@@ -128,6 +128,21 @@ struct nf_conn {
 	u_int32_t secmark;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || \
+    defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	struct {
+		/*
+		 * e.g. "http". NULL before decision. "unknown" after decision
+		 * if no match.
+		 */
+		char *app_proto;
+		/*
+		 * application layer data so far. NULL after match decision.
+		 */
+		char *app_data;
+		unsigned int app_data_len;
+	} layer7;
+#endif
 	/* Extensions */
 	struct nf_ct_ext *ext;
 #ifdef CONFIG_NET_NS
@@ -337,6 +352,13 @@ extern unsigned int nf_conntrack_max;
 extern unsigned int nf_conntrack_hash_rnd;
 void init_nf_conntrack_hash_rnd(void);
 
+#ifdef CONFIG_MV_LINUX_COUNTERS_DISABLE
+
+#define NF_CT_STAT_INC(net, count)
+#define NF_CT_STAT_INC_ATOMIC(net, count)
+
+#else
+
 #define NF_CT_STAT_INC(net, count)	\
 	__this_cpu_inc((net)->ct.stat->count)
 #define NF_CT_STAT_INC_ATOMIC(net, count)		\
@@ -346,6 +368,8 @@ do {							\
 	local_bh_enable();				\
 } while (0)
 
+#endif /* CONFIG_MV_LINUX_COUNTERS_DISABLE */
+
 #define MODULE_ALIAS_NFCT_HELPER(helper) \
         MODULE_ALIAS("nfct-helper-" helper)
 
--- a/include/net/netfilter/nf_conntrack_tuple.h
+++ b/include/net/netfilter/nf_conntrack_tuple.h
@@ -70,6 +70,15 @@ struct nf_conntrack_tuple {
 		/* The direction (for tuplehash) */
 		u_int8_t dir;
 	} dst;
+
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+	/* If true, this connection is handled by NFP */
+	bool nfp;
+	int ifindex;
+	bool nfpCapable;
+	bool udpCsum;
+	struct ipt_nfp_info *info;
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
 };
 
 struct nf_conntrack_tuple_mask {
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -69,6 +69,10 @@ struct rtable {
 	u32			rt_peer_genid;
 	struct inet_peer	*peer; /* long-living peer info */
 	struct fib_info		*fi; /* for client ref to shared metrics */
+
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+	bool 			nfp;
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
 };
 
 static inline bool rt_is_input_route(const struct rtable *rt)
--- a/net/8021q/vlan.c
+++ b/net/8021q/vlan.c
@@ -42,6 +42,13 @@
 
 #define DRV_VERSION "1.8"
 
+
+#if defined(CONFIG_MV_ETH_NFP_VLAN_LEARN)
+extern int nfp_hook_vlan_add(int if_index, struct net_device *dev,
+					int real_if_index, int vlan_id);
+extern int nfp_hook_vlan_del(int if_index);
+#endif /* CONFIG_MV_ETH_NFP_VLAN_LEARN */
+
 /* Global VLAN variables */
 
 int vlan_net_id __read_mostly;
@@ -122,6 +129,10 @@ void unregister_vlan_dev(struct net_devi
 	if (vlan->flags & VLAN_FLAG_GVRP)
 		vlan_gvrp_request_leave(dev);
 
+#if defined(CONFIG_MV_ETH_NFP_VLAN_LEARN)
+	nfp_hook_vlan_del(dev->ifindex);
+#endif /* CONFIG_MV_ETH_NFP_VLAN_LEARN */
+
 	vlan_group_set_device(grp, vlan_id, NULL);
 	/* Because unregister_netdevice_queue() makes sure at least one rcu
 	 * grace period is respected before device freeing,
@@ -288,6 +299,10 @@ static int register_vlan_device(struct n
 	if (err < 0)
 		goto out_free_newdev;
 
+#if defined(CONFIG_MV_ETH_NFP_VLAN_LEARN)
+	nfp_hook_vlan_add(new_dev->ifindex, new_dev, real_dev->ifindex, vlan_id);
+#endif /* CONFIG_MV_ETH_NFP_VLAN_LEARN */
+
 	return 0;
 
 out_free_newdev:
@@ -712,6 +727,26 @@ static void __exit vlan_cleanup_module(v
 	vlan_gvrp_uninit();
 }
 
+#if defined(CONFIG_MV_ETH_NFP_VLAN_LEARN)
+void vlan_sync(void)
+{
+	struct net_device *dev;
+
+	rtnl_lock();
+	for_each_netdev(&init_net, dev) {
+		if (dev->priv_flags & IFF_802_1Q_VLAN) {
+			struct vlan_dev_info *vlan = vlan_dev_info(dev);
+			struct net_device *real_dev = vlan->real_dev;
+			u16 vlan_id = vlan->vlan_id;
+
+			if (nfp_hook_vlan_add(dev->ifindex, dev, real_dev->ifindex, vlan_id))
+				printk("nfp_hook_vlan_add failed in %s\n",__func__);
+		}
+	}
+	rtnl_unlock();
+}
+#endif /* CONFIG_MV_ETH_NFP_VLAN_LEARN */
+
 module_init(vlan_proto_init);
 module_exit(vlan_cleanup_module);
 
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -32,6 +32,12 @@ static void fdb_notify(const struct net_
 
 static u32 fdb_salt __read_mostly;
 
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+int nfp_hook_fdb_rule_add(int br_index, int if_index, const u8 *mac, int is_local);
+int nfp_hook_fdb_rule_age(int br_index, int if_index, const u8 *mac);
+int nfp_hook_fdb_rule_del(int br_index, int if_index, const u8 *mac);
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
+
 int __init br_fdb_init(void)
 {
 	br_fdb_cache = kmem_cache_create("bridge_fdb_cache",
@@ -60,10 +66,20 @@ static inline unsigned long hold_time(co
 }
 
 static inline int has_expired(const struct net_bridge *br,
-				  const struct net_bridge_fdb_entry *fdb)
+				struct net_bridge_fdb_entry *fdb)
 {
-	return !fdb->is_static &&
-		time_before_eq(fdb->updated + hold_time(br), jiffies);
+	if (fdb->is_static)
+		return 0;
+
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+	if (fdb->nfp) {
+		if (nfp_hook_fdb_rule_age(fdb->dst->br->dev->ifindex,
+					fdb->dst->dev->ifindex, fdb->addr.addr) > 0)
+			fdb->updated = jiffies + fdb->dst->br->forward_delay;
+	}
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
+
+	return time_before_eq(fdb->updated + hold_time(br), jiffies);
 }
 
 static inline int br_mac_hash(const unsigned char *mac)
@@ -82,6 +98,13 @@ static void fdb_rcu_free(struct rcu_head
 
 static inline void fdb_delete(struct net_bridge_fdb_entry *f)
 {
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+	if (f->nfp) {
+		nfp_hook_fdb_rule_del(f->dst->br->dev->ifindex,
+				f->dst->dev->ifindex, f->addr.addr);
+	}
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
+
 	fdb_notify(f, RTM_DELNEIGH);
 	hlist_del_rcu(&f->hlist);
 	call_rcu(&f->rcu, fdb_rcu_free);
@@ -142,6 +165,15 @@ void br_fdb_cleanup(unsigned long _data)
 			unsigned long this_timer;
 			if (f->is_static)
 				continue;
+
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+			if (f->nfp) {
+				if (nfp_hook_fdb_rule_age(f->dst->br->dev->ifindex,
+							f->dst->dev->ifindex, f->addr.addr) > 0)
+					f->updated = jiffies + f->dst->br->forward_delay;
+			}
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
+
 			this_timer = f->updated + delay;
 			if (time_before_eq(this_timer, jiffies))
 				fdb_delete(f);
@@ -335,7 +367,7 @@ static struct net_bridge_fdb_entry *fdb_
 
 static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 					       struct net_bridge_port *source,
-					       const unsigned char *addr)
+					       const unsigned char *addr, int is_local)
 {
 	struct net_bridge_fdb_entry *fdb;
 
@@ -343,11 +375,16 @@ static struct net_bridge_fdb_entry *fdb_
 	if (fdb) {
 		memcpy(fdb->addr.addr, addr, ETH_ALEN);
 		fdb->dst = source;
-		fdb->is_local = 0;
-		fdb->is_static = 0;
+		fdb->is_local = is_local;
+		fdb->is_static = is_local;
 		fdb->updated = fdb->used = jiffies;
 		hlist_add_head_rcu(&fdb->hlist, head);
-		fdb_notify(fdb, RTM_NEWNEIGH);
+
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+		fdb->nfp = false;
+		if (!nfp_hook_fdb_rule_add(fdb->dst->br->dev->ifindex, fdb->dst->dev->ifindex, addr, is_local))
+			fdb->nfp = true;
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
 	}
 	return fdb;
 }
@@ -374,7 +411,7 @@ static int fdb_insert(struct net_bridge
 		fdb_delete(fdb);
 	}
 
-	fdb = fdb_create(head, source, addr);
+	fdb = fdb_create(head, source, addr, 1);
 	if (!fdb)
 		return -ENOMEM;
 
@@ -425,7 +462,7 @@ void br_fdb_update(struct net_bridge *br
 	} else {
 		spin_lock(&br->hash_lock);
 		if (likely(!fdb_find(head, addr)))
-			fdb_create(head, source, addr);
+			fdb_create(head, source, addr, 0);
 
 		/* else  we lose race and someone else inserts
 		 * it first, don't bother updating
@@ -440,7 +477,7 @@ static int fdb_to_nud(const struct net_b
 		return NUD_PERMANENT;
 	else if (fdb->is_static)
 		return NUD_NOARP;
-	else if (has_expired(fdb->dst->br, fdb))
+	else if (has_expired(fdb->dst->br, (struct net_bridge_fdb_entry *)fdb))
 		return NUD_STALE;
 	else
 		return NUD_REACHABLE;
@@ -703,3 +740,37 @@ int br_fdb_delete(struct sk_buff *skb, s
 
 	return err;
 }
+
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+void fdb_sync(void)
+{
+	struct net_device *dev;
+	struct net_bridge *br;
+	int i;
+	rtnl_lock();
+	for_each_netdev(&init_net, dev) {
+		if (dev->priv_flags & IFF_EBRIDGE) {
+			br = netdev_priv(dev);
+			spin_lock_bh(&br->hash_lock);
+			for (i = 0; i < BR_HASH_SIZE; i++) {
+				struct net_bridge_fdb_entry *fdb;
+				struct hlist_node *h, *n;
+
+				hlist_for_each_entry_safe(fdb, h, n, &br->hash[i], hlist) {
+					if (!nfp_hook_fdb_rule_add(fdb->dst->br->dev->ifindex,
+							       fdb->dst->dev->ifindex,
+							       fdb->addr.addr,
+							       fdb->is_local)) {
+						/* oeprtaion succeeded */
+						fdb->nfp = true;
+					}
+
+				}
+			}
+			spin_unlock_bh(&br->hash_lock);
+
+		}
+	}
+	rtnl_unlock();
+}
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -26,6 +26,11 @@
 
 #include "br_private.h"
 
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+int nfp_hook_del_br(int ifindex);
+int nfp_hook_del_port_from_br(int bridge_if, int port_if);
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
+
 /*
  * Determine initial path cost based on speed.
  * using recommendations from 802.1d standard
@@ -167,11 +172,20 @@ void br_dev_delete(struct net_device *de
 	struct net_bridge_port *p, *n;
 
 	list_for_each_entry_safe(p, n, &br->port_list, list) {
+
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+	nfp_hook_del_port_from_br(br->dev->ifindex, p->dev->ifindex);
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
+
 		del_nbp(p);
 	}
 
 	del_timer_sync(&br->gc_timer);
 
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+	nfp_hook_del_br(br->dev->ifindex);
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
+
 	br_sysfs_delbr(br->dev);
 	unregister_netdevice_queue(br->dev, head);
 }
@@ -426,6 +440,10 @@ int br_del_if(struct net_bridge *br, str
 	if (!p || p->br != br)
 		return -EINVAL;
 
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+	nfp_hook_del_port_from_br(br->dev->ifindex, p->dev->ifindex);
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
+
 	del_nbp(p);
 
 	spin_lock_bh(&br->lock);
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -74,6 +74,10 @@ struct net_bridge_fdb_entry
 	mac_addr			addr;
 	unsigned char			is_local;
 	unsigned char			is_static;
+
+#if defined(CONFIG_MV_ETH_NFP_BRIDGE_LEARN)
+	bool 			nfp;
+#endif /* CONFIG_MV_ETH_NFP_BRIDGE_LEARN */
 };
 
 struct net_bridge_port_group {
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -37,6 +37,12 @@
 #include <linux/string.h>
 #include <linux/log2.h>
 
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+extern int nfp_hook_arp_add(int family, const u8 *ip, u8 *mac, int if_index);
+extern int nfp_hook_arp_delete(int family, const u8 *ip);
+extern int nfp_hook_arp_is_confirmed(int family, const u8 *ip);
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 #define NEIGH_DEBUG 1
 
 #define NEIGH_PRINTK(x...) printk(x)
@@ -571,7 +577,7 @@ struct pneigh_entry *__pneigh_lookup(str
 }
 EXPORT_SYMBOL_GPL(__pneigh_lookup);
 
-struct pneigh_entry * pneigh_lookup(struct neigh_table *tbl,
+struct pneigh_entry *pneigh_lookup(struct neigh_table *tbl,
 				    struct net *net, const void *pkey,
 				    struct net_device *dev, int creat)
 {
@@ -701,6 +707,15 @@ void neigh_destroy(struct neighbour *nei
 	if (neigh_del_timer(neigh))
 		printk(KERN_WARNING "Impossible event.\n");
 
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+       if (neigh->nfp) {
+               nfp_hook_arp_delete(neigh->tbl->family, neigh->primary_key);
+
+               NEIGH_PRINTK2("0x%8lx: neigh %p, ref=%d, state=%d, nfp=%d is connected in %s.\n",
+                       jiffies, neigh, atomic_read(&neigh->refcnt), neigh->nud_state, neigh->nfp, __func__);
+       }
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 	skb_queue_purge(&neigh->arp_queue);
 
 	dev_put(neigh->dev);
@@ -732,8 +747,15 @@ static void neigh_suspect(struct neighbo
  */
 static void neigh_connect(struct neighbour *neigh)
 {
-	NEIGH_PRINTK2("neigh %p is connected.\n", neigh);
-
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+       neigh->nfp = false;
+       if (!nfp_hook_arp_add(neigh->tbl->family, neigh->primary_key, neigh->ha, neigh->dev->ifindex)) {
+               neigh->nfp = true;
+
+               NEIGH_PRINTK2("0x%8lx: neigh %p, ref=%d, state=%d, nfp=%d is connected in %s.\n",
+                       jiffies, neigh, atomic_read(&neigh->refcnt), neigh->nud_state, neigh->nfp, __func__);
+       }
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
 	neigh->output = neigh->ops->connected_output;
 }
 
@@ -781,6 +803,19 @@ static void neigh_periodic_work(struct w
 			if (time_before(n->used, n->confirmed))
 				n->used = n->confirmed;
 
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+			if ((atomic_read(&n->refcnt) == 1) && (state != NUD_FAILED) &&
+				time_after(jiffies, n->used + n->parms->gc_staletime)) {
+				if (n->nfp) {
+					if (nfp_hook_arp_is_confirmed(n->tbl->family, n->primary_key)) {
+						neigh_event_send(n, NULL);
+					}
+					NEIGH_PRINTK2("0x%8lx: neigh %p ref=%d, state=%d, NFP ARP aging in %s\n",
+						jiffies, n, atomic_read(&n->refcnt), n->nud_state, __func__);
+				}
+			}
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 			if (atomic_read(&n->refcnt) == 1 &&
 			    (state == NUD_FAILED ||
 			     time_after(jiffies, n->used + n->parms->gc_staletime))) {
@@ -829,7 +864,7 @@ static void neigh_invalidate(struct neig
 	struct sk_buff *skb;
 
 	NEIGH_CACHE_STAT_INC(neigh->tbl, res_failed);
-	NEIGH_PRINTK2("neigh %p is failed.\n", neigh);
+	NEIGH_PRINTK2("0x%8lx: neigh %p is failed in %s.\n", jiffies, neigh, __func__);
 	neigh->updated = jiffies;
 
 	/* It is very thin place. report_unreachable is very complicated
@@ -880,17 +915,17 @@ static void neigh_timer_handler(unsigned
 	if (state & NUD_REACHABLE) {
 		if (time_before_eq(now,
 				   neigh->confirmed + neigh->parms->reachable_time)) {
-			NEIGH_PRINTK2("neigh %p is still alive.\n", neigh);
+			NEIGH_PRINTK2("0x%8lx: neigh %p is still alive in %s.\n", now, neigh, __func__);
 			next = neigh->confirmed + neigh->parms->reachable_time;
 		} else if (time_before_eq(now,
 					  neigh->used + neigh->parms->delay_probe_time)) {
-			NEIGH_PRINTK2("neigh %p is delayed.\n", neigh);
+			NEIGH_PRINTK2("0x%8lx: neigh %p is delayed in %s.\n", now, neigh, __func__);
 			neigh->nud_state = NUD_DELAY;
 			neigh->updated = jiffies;
 			neigh_suspect(neigh);
 			next = now + neigh->parms->delay_probe_time;
 		} else {
-			NEIGH_PRINTK2("neigh %p is suspected.\n", neigh);
+			NEIGH_PRINTK2("0x%8lx: neigh %p is suspected in %s.\n", now, neigh, __func__);
 			neigh->nud_state = NUD_STALE;
 			neigh->updated = jiffies;
 			neigh_suspect(neigh);
@@ -906,7 +941,7 @@ static void neigh_timer_handler(unsigned
 			notify = 1;
 			next = neigh->confirmed + neigh->parms->reachable_time;
 		} else {
-			NEIGH_PRINTK2("neigh %p is probed.\n", neigh);
+			NEIGH_PRINTK2("0x%8lx: neigh %p is probed in %s.\n", now, neigh, __func__);
 			neigh->nud_state = NUD_PROBE;
 			neigh->updated = jiffies;
 			atomic_set(&neigh->probes, 0);
@@ -973,7 +1008,8 @@ int __neigh_event_send(struct neighbour
 			return 1;
 		}
 	} else if (neigh->nud_state & NUD_STALE) {
-		NEIGH_PRINTK2("neigh %p is delayed.\n", neigh);
+		NEIGH_PRINTK2("0x%8lx: neigh %p ref=%d is delayed in %s.\n",
+				now, neigh, atomic_read(&neigh->refcnt), __func__);
 		neigh->nud_state = NUD_DELAY;
 		neigh->updated = jiffies;
 		neigh_add_timer(neigh,
@@ -2862,6 +2898,42 @@ EXPORT_SYMBOL(neigh_sysctl_unregister);
 
 #endif	/* CONFIG_SYSCTL */
 
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+void neigh_sync(int family)
+{
+	struct neigh_table *tbl;
+	struct neighbour *n;
+	int t, h, idx;
+	struct neigh_hash_table *nht;
+
+	read_lock(&neigh_tbl_lock);
+	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
+		if (tbl->family == family) {
+			nht = rcu_dereference_protected(tbl->nht,
+					lockdep_is_held(&tbl->lock));
+
+			for (h = 0; h < (1 << nht->hash_mask); h++) {
+				for (n = nht->hash_buckets[h], idx = 0; n; n = n->next) {
+					if (!(n->nfp)) {
+						if (n->dev == NULL) {
+							continue;
+						}
+						n->nfp = false;
+						if (!nfp_hook_arp_add(n->tbl->family,
+								n->primary_key,
+								n->ha,
+								n->dev->ifindex)) {
+							n->nfp = true;
+						}
+					}
+				}
+			}
+		}
+	}
+	read_unlock(&neigh_tbl_lock);
+}
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 static int __init neigh_init(void)
 {
 	rtnl_register(PF_UNSPEC, RTM_NEWNEIGH, neigh_add, NULL, NULL);
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@ -182,6 +182,13 @@ config IP_NF_TARGET_NETMAP
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_TARGET_NFP
+	tristate "NFP target support"
+	depends on NF_CONNTRACK_IPV4 && MV_ETH_NFP_NAT
+	help
+	  This target allows to process selected connections in NFP.
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config IP_NF_TARGET_REDIRECT
 	tristate "REDIRECT target support"
 	depends on NF_NAT
--- a/net/ipv4/netfilter/Makefile
+++ b/net/ipv4/netfilter/Makefile
@@ -57,6 +57,7 @@ obj-$(CONFIG_IP_NF_TARGET_ECN) += ipt_EC
 obj-$(CONFIG_IP_NF_TARGET_LOG) += ipt_LOG.o
 obj-$(CONFIG_IP_NF_TARGET_MASQUERADE) += ipt_MASQUERADE.o
 obj-$(CONFIG_IP_NF_TARGET_NETMAP) += ipt_NETMAP.o
+obj-$(CONFIG_IP_NF_TARGET_NFP) += ipt_NFP.o
 obj-$(CONFIG_IP_NF_TARGET_REDIRECT) += ipt_REDIRECT.o
 obj-$(CONFIG_IP_NF_TARGET_REJECT) += ipt_REJECT.o
 obj-$(CONFIG_IP_NF_TARGET_ULOG) += ipt_ULOG.o
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
@@ -179,6 +179,19 @@ static int ct_seq_show(struct seq_file *
 	if (ct_show_secctx(s, ct))
 		goto release;
 
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+	if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfp) && (ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfp)) {
+		if (seq_printf(s, "[NFP (both)] "))
+			goto release;
+	} else if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfp) {
+		if (seq_printf(s, "[NFP (orig)] "))
+			goto release;
+	} else if (ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfp) {
+		if (seq_printf(s, "[NFP (reply)] "))
+			goto release;
+	}
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
+
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		goto release;
 	ret = 0;
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -112,6 +112,13 @@
 #include <net/atmclip.h>
 #include <net/secure_seq.h>
 
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+extern int nfp_fib_learn_en;
+extern int nfp_hook_fib_rule_add(int family, u8 *src_l3, u8 *dst_l3, u8 *gtw_l3, int iif, int oif);
+extern int nfp_hook_fib_rule_del(int family, u8 *src_l3, u8 *dst_l3, int iif, int oif);
+extern int nfp_hook_fib_rule_age(int family, u8 *src_l3, u8 *dst_l3, int iif, int oif);
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 #define RT_FL_TOS(oldflp4) \
 	((oldflp4)->flowi4_tos & (IPTOS_RT_MASK | RTO_ONLINK))
 
@@ -660,6 +667,12 @@ static inline int ip_rt_proc_init(void)
 
 static inline void rt_free(struct rtable *rt)
 {
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+		if (rt->nfp)
+			nfp_hook_fib_rule_del(AF_INET, (u8*)(&rt->rt_src),(u8*)(&rt->rt_dst),
+							rt->rt_iif, rt->dst.dev->ifindex);
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 	call_rcu_bh(&rt->dst.rcu_head, dst_rcu_free);
 }
 
@@ -691,6 +704,14 @@ static int rt_may_expire(struct rtable *
 	if (atomic_read(&rth->dst.__refcnt))
 		goto out;
 
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+	if (rth->nfp) {
+		if (nfp_hook_fib_rule_age(AF_INET,(u8 *)(&rth->rt_src), (u8 *)(&rth->rt_dst),
+						rth->rt_iif, rth->dst.dev->ifindex))
+			rth->dst.lastuse = jiffies;
+	}
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 	age = jiffies - rth->dst.lastuse;
 	if ((age <= tmo1 && !rt_fast_clean(rth)) ||
 	    (age <= tmo2 && rt_valuable(rth)))
@@ -805,6 +826,54 @@ static void rt_do_flush(struct net *net,
 	}
 }
 
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+void nfp_fib_sync(void)
+{
+
+	unsigned int i;
+	struct rtable *rth, *next;
+	struct rtable *tail;
+	struct rtable **prev, *p;
+
+	for (i = 0; i <= rt_hash_mask; i++) {
+		rth = rt_hash_table[i].chain;
+		if (!rth)
+			continue;
+
+		spin_lock_bh(rt_hash_lock_addr(i));
+		rth = rt_hash_table[i].chain;
+
+		/* defer releasing the head of the list after spin_unlock */
+		for (tail = rth; tail; tail = tail->dst.rt_next)
+			if (rth != tail)
+				rt_hash_table[i].chain = tail;
+
+		prev = &rt_hash_table[i].chain;
+		for (p = *prev; p; p = next) {
+			next = p->dst.rt_next;
+			if (!(p->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST | RTCF_LOCAL | RTCF_REJECT))) {
+				if (!nfp_hook_fib_rule_add(AF_INET, (u8*)(&p->rt_src), (u8*)(&p->rt_dst),
+						  (u8*)(&p->rt_gateway), p->rt_iif, p->dst.dev->ifindex))
+					rth->nfp = true;
+			}
+			prev = &p->dst.rt_next;
+		}
+
+		spin_unlock_bh(rt_hash_lock_addr(i));
+
+		for (; rth != tail; rth = next) {
+			next = rth->dst.rt_next;
+			if (!(rth->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST | RTCF_LOCAL | RTCF_REJECT))) {
+				if (!nfp_hook_fib_rule_add(AF_INET, (u8*)(&rth->rt_src), (u8*)(&rth->rt_dst),
+					  (u8*)(&rth->rt_gateway), rth->rt_iif, rth->dst.dev->ifindex))
+					rth->nfp = true;
+			}
+		}
+	}
+}
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
+
 /*
  * While freeing expired entries, we compute average chain length
  * and standard deviation, using fixed-point arithmetic.
@@ -2216,6 +2285,16 @@ static int __mkroute_input(struct sk_buf
 
 	rt_set_nexthop(rth, NULL, res, res->fi, res->type, itag);
 
+
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+	rth->nfp = false;
+	if (!(rth->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST | RTCF_LOCAL | RTCF_REJECT))) {
+		if (!nfp_hook_fib_rule_add(AF_INET, (u8*)(&rth->rt_src), (u8*)(&rth->rt_dst),
+					(u8*)(&rth->rt_gateway), rth->rt_iif, rth->dst.dev->ifindex))
+			rth->nfp = true;
+	}
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 	*result = rth;
 	err = 0;
  cleanup:
@@ -3351,9 +3430,9 @@ static struct ctl_table empty[1];
 
 static struct ctl_table ipv4_skeleton[] =
 {
-	{ .procname = "route", 
+	{ .procname = "route",
 	  .mode = 0555, .child = ipv4_route_table},
-	{ .procname = "neigh", 
+	{ .procname = "neigh",
 	  .mode = 0555, .child = empty},
 	{ }
 };
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -43,6 +43,13 @@
 #define RT6_TRACE(x...) do { ; } while (0)
 #endif
 
+#if defined (CONFIG_MV_ETH_NFP_FIB_LEARN)
+extern int nfp_hook_fib_rule_add(int family, const u8 *src_l3, const u8 *dst_l3,
+				const u8 *def_gtw_l3, int iif, int oif);
+extern int nfp_hook_fib_rule_del(int family, const u8 *src_l3, const u8 *dst_l3, int iif, int oif);
+extern int nfp_hook_fib_rule_age(int family, u8 *src_l3, u8 *dst_l3, int iif, int oif);
+#endif /*  CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 static struct kmem_cache * fib6_node_kmem __read_mostly;
 
 enum fib_walk_state_t
@@ -415,6 +422,53 @@ out:
 	return res;
 }
 
+
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+static int fib6_add_node(struct fib6_walker_t *w)
+{
+	struct rt6_info *rt;
+	for (rt = w->leaf; rt; rt = rt->dst.rt6_next) {
+		if (rt->rt6i_flags & RTF_CACHE) {
+			if (!nfp_hook_fib_rule_add(AF_INET6, (u8 *)&rt->rt6i_src.addr,
+				(u8 *)&rt->rt6i_dst.addr,
+				(u8 *)&rt->rt6i_gateway,
+				rt->rt6i_iifindex,
+				rt->rt6i_dev->ifindex))
+				rt->nfp = true;
+		}
+	}
+	w->leaf = rt;
+	return 0;
+}
+
+void nfp_fib6_sync(void)
+{
+	struct fib6_table *table;
+	struct hlist_node *node;
+	struct hlist_head *head;
+	unsigned int h;
+	int res;
+	struct net *net = &init_net;
+	struct fib6_walker_t w;
+
+	w.func = fib6_add_node;
+	w.prune = 0;
+
+	rcu_read_lock();
+	for (h = 0; h < FIB6_TABLE_HASHSZ; h++) {
+		head = &net->ipv6.fib_table_hash[h];
+		hlist_for_each_entry_rcu(table, node, head, tb6_hlist) {
+			write_lock_bh(&table->tb6_lock);
+			w.root = &table->tb6_root;
+			res = fib6_walk(&w);
+			write_unlock_bh(&table->tb6_lock);
+		}
+	}
+	rcu_read_unlock();
+
+}
+#endif
+
 /*
  *	Routing Table
  *
@@ -668,6 +722,16 @@ static int fib6_add_rt2node(struct fib6_
 		fn->fn_flags |= RTN_RTINFO;
 	}
 
+#if defined (CONFIG_MV_ETH_NFP_FIB_LEARN)
+	rt->nfp = false;
+	if (rt->rt6i_flags & RTF_CACHE)	{
+		if (!nfp_hook_fib_rule_add(AF_INET6, (u8 *)&rt->rt6i_src.addr,
+					(u8 *)&rt->rt6i_dst.addr, (u8 *)&rt->rt6i_gateway,
+					rt->rt6i_iifindex, rt->rt6i_dev->ifindex))
+				rt->nfp = true;
+	}
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 	return 0;
 }
 
@@ -1156,6 +1220,14 @@ static void fib6_del_route(struct fib6_n
 	}
 
 	inet6_rt_notify(RTM_DELROUTE, rt, info);
+
+#if defined (CONFIG_MV_ETH_NFP_FIB_LEARN)
+	if (rt->rt6i_flags & RTF_CACHE)
+		if (rt->nfp)
+			nfp_hook_fib_rule_del(AF_INET6, (u8 *)&rt->rt6i_src.addr, (u8 *)&rt->rt6i_dst.addr,
+							rt->rt6i_iifindex, rt->rt6i_dev->ifindex);
+#endif /*  CONFIG_MV_ETH_NFP_FIB_LEARN  */
+
 	rt6_release(rt);
 }
 
@@ -1456,6 +1528,13 @@ static int fib6_age(struct rt6_info *rt,
 				  rt);
 			return -1;
 		}
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+		if (rt->nfp) {
+			if (nfp_hook_fib_rule_age(AF_INET6,(u8 *)(&rt->rt6i_src.addr), (u8 *)(&rt->rt6i_dst.addr),
+					rt->rt6i_iifindex, rt->rt6i_dev->ifindex))
+				rt->dst.lastuse = now;
+		}
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
 		gc_args.more++;
 	}
 
@@ -1601,3 +1680,4 @@ void fib6_gc_cleanup(void)
 	unregister_pernet_subsys(&fib6_net_ops);
 	kmem_cache_destroy(fib6_node_kmem);
 }
+
--- a/net/ipv6/netfilter/Kconfig
+++ b/net/ipv6/netfilter/Kconfig
@@ -194,6 +194,14 @@ config IP6_NF_RAW
 	  If you want to compile it as a module, say M here and read
 	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
 
+config IP6_NF_TARGET_NFP
+	tristate "NFP target support for IPv6"
+	depends on NF_CONNTRACK_IPV6
+	help
+	  This target allows to process selected connections in NFP.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 # security table for MAC policy
 config IP6_NF_SECURITY
        tristate "Security table"
--- a/net/ipv6/netfilter/Makefile
+++ b/net/ipv6/netfilter/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_IP6_NF_MATCH_IPV6HEADER) +=
 obj-$(CONFIG_IP6_NF_MATCH_MH) += ip6t_mh.o
 obj-$(CONFIG_IP6_NF_MATCH_OPTS) += ip6t_hbh.o
 obj-$(CONFIG_IP6_NF_MATCH_RT) += ip6t_rt.o
+obj-$(CONFIG_IP6_NF_TARGET_NFP) += ip6t_NFP.o
 
 # targets
 obj-$(CONFIG_IP6_NF_TARGET_LOG) += ip6t_LOG.o
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -831,6 +831,14 @@ restart:
 
 	dst_hold(&rt->dst);
 	if (nrt) {
+#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+			if ((rt->rt6i_flags & RTF_CACHE)) {
+				ipv6_addr_copy(&rt->rt6i_src.addr, &fl6->saddr);
+				rt->rt6i_src.plen = 128;
+				rt->rt6i_iifindex = fl6->flowi6_iif;
+			}
+#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+
 		err = ip6_ins_rt(nrt);
 		if (!err)
 			goto out2;
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -1043,6 +1043,27 @@ config NETFILTER_XT_MATCH_LAYER7_DEBUG
 	help
 	  Say Y to get lots of debugging output.
 
+config NETFILTER_XT_MATCH_LAYER7
+	tristate '"layer7" match support'
+	depends on NETFILTER_XTABLES
+	depends on EXPERIMENTAL && (IP_NF_CONNTRACK || NF_CONNTRACK)
+       depends on NF_CT_ACCT
+	help
+	  Say Y if you want to be able to classify connections (and their
+	  packets) based on regular expression matching of their application
+	  layer data.   This is one way to classify applications such as
+	  peer-to-peer filesharing systems that do not always use the same
+	  port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_MATCH_LAYER7_DEBUG
+        bool 'Layer 7 debugging output'
+        depends on NETFILTER_XT_MATCH_LAYER7
+        help
+          Say Y to get lots of debugging output.
+
+
 config NETFILTER_XT_MATCH_STATISTIC
 	tristate '"statistic" match support'
 	depends on NETFILTER_ADVANCED
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -102,7 +102,6 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_RECENT)
 obj-$(CONFIG_NETFILTER_XT_MATCH_SCTP) += xt_sctp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_SOCKET) += xt_socket.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATE) += xt_state.o
-obj-$(CONFIG_NETFILTER_XT_MATCH_LAYER7) += xt_layer7.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATISTIC) += xt_statistic.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -46,6 +46,19 @@
 #include <net/netfilter/nf_conntrack_timestamp.h>
 #include <net/netfilter/nf_nat.h>
 #include <net/netfilter/nf_nat_core.h>
+#include <linux/netfilter/ipt_NFP.h>
+
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+extern void nfp_hook_ct_del(int family, u8 *src_l3, u8 *dst_l3, u16 sport, u16 dport, u8 proto);
+extern int  nfp_hook_ct_age(int family, u8 *src_l3, u8 *dst_l3, u16 sport, u16 dport, u8 proto);
+extern void nfp_ct_sync(int family);
+#ifdef CONFIG_MV_ETH_NFP_NAT
+extern void move_nat_to_nfp(const struct nf_conntrack_tuple *tuple,
+							const struct nf_conntrack_tuple *target,
+							enum nf_nat_manip_type maniptype);
+#endif /* CONFIG_MV_ETH_NFP_NAT */
+extern int move_fwd_to_nfp(const struct nf_conntrack_tuple *tuple, int mode);
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
 
 #define NF_CONNTRACK_VERSION	"0.5.0"
 
@@ -299,6 +312,82 @@ static void death_by_timeout(unsigned lo
 	struct nf_conn *ct = (void *)ul_conntrack;
 	struct nf_conn_tstamp *tstamp;
 
+#if defined (CONFIG_MV_ETH_NFP_CT_LEARN)
+	struct nf_conntrack_tuple *t0 = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
+	struct nf_conntrack_tuple *t1 = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;
+	int confirmed_org = 0, confirmed_reply = 0;
+
+	if (t0 && t0->nfp) {
+		if (t0->src.l3num == AF_INET)
+			confirmed_org = nfp_hook_ct_age(t0->src.l3num, (u8 *)&(t0->src.u3.ip),
+					(u8 *)&(t0->dst.u3.ip),
+					ntohs(t0->src.u.all),
+					ntohs(t0->dst.u.all),
+					t0->dst.protonum);
+		else
+			confirmed_org = nfp_hook_ct_age(t0->src.l3num, (u8 *)&(t0->src.u3.ip6),
+					(u8 *)&(t0->dst.u3.ip6),
+					ntohs(t0->src.u.all),
+					ntohs(t0->dst.u.all),
+					t0->dst.protonum);
+	}
+
+	if (t1 && t1->nfp) {
+		if (t1->src.l3num == AF_INET)
+			confirmed_reply = nfp_hook_ct_age(t1->src.l3num, (u8 *)&(t1->src.u3.ip),
+					(u8 *)&(t1->dst.u3.ip),
+					ntohs(t1->src.u.all),
+					ntohs(t1->dst.u.all),
+					t1->dst.protonum);
+		else
+			confirmed_reply = nfp_hook_ct_age(t1->src.l3num, (u8 *)&(t1->src.u3.ip6),
+					(u8 *)&(t1->dst.u3.ip6),
+					ntohs(t1->src.u.all),
+					ntohs(t1->dst.u.all),
+					t1->dst.protonum);
+	}
+
+	if (confirmed_org || confirmed_reply) {
+		ct->timeout.expires = jiffies + (20*HZ);
+		add_timer(&ct->timeout);
+		return;
+	}
+
+	if (t0 && t0->nfp) {
+		t0->nfp = false;
+
+		if (t0->src.l3num == AF_INET)
+			nfp_hook_ct_del(t0->src.l3num, (u8 *)&(t0->src.u3.ip),
+					(u8 *)&(t0->dst.u3.ip),
+					ntohs(t0->src.u.all),
+					ntohs(t0->dst.u.all),
+					t0->dst.protonum);
+		else
+			nfp_hook_ct_del(t0->src.l3num, (u8 *)&(t0->src.u3.ip6),
+					(u8 *)&(t0->dst.u3.ip6),
+					ntohs(t0->src.u.all),
+					ntohs(t0->dst.u.all),
+					t0->dst.protonum);
+	}
+
+	if (t1 && t1->nfp) {
+		t1->nfp = false;
+
+		if (t1->src.l3num == AF_INET)
+			nfp_hook_ct_del(t1->src.l3num, (u8 *)&(t1->src.u3.ip),
+					(u8 *)&(t1->dst.u3.ip),
+					ntohs(t1->src.u.all),
+					ntohs(t1->dst.u.all),
+					t1->dst.protonum);
+		else
+			nfp_hook_ct_del(t1->src.l3num, (u8 *)&(t1->src.u3.ip6),
+					(u8 *)&(t1->dst.u3.ip6),
+					ntohs(t1->src.u.all),
+					ntohs(t1->dst.u.all),
+					t1->dst.protonum);
+	}
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
+
 	tstamp = nf_conn_tstamp_find(ct);
 	if (tstamp && tstamp->stop == 0)
 		tstamp->stop = ktime_to_ns(ktime_get_real());
@@ -704,6 +793,19 @@ __nf_conntrack_alloc(struct net *net, u1
 		nf_ct_zone->id = zone;
 	}
 #endif
+
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfp = false;
+	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.ifindex = -1;
+	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfpCapable = false;
+	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.info = NULL;
+
+	ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfp = false;
+	ct->tuplehash[IP_CT_DIR_REPLY].tuple.ifindex = -1;
+	ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfpCapable = false;
+	ct->tuplehash[IP_CT_DIR_REPLY].tuple.info = NULL;
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
+
 	/*
 	 * changes to lookup keys must be done before setting refcnt to 1
 	 */
@@ -731,6 +833,14 @@ void nf_conntrack_free(struct nf_conn *c
 {
 	struct net *net = nf_ct_net(ct);
 
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+	if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.info)
+		kfree(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.info);
+
+	if (ct->tuplehash[IP_CT_DIR_REPLY].tuple.info)
+		kfree(ct->tuplehash[IP_CT_DIR_REPLY].tuple.info);
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
+
 	nf_ct_ext_destroy(ct);
 	atomic_dec(&net->ct.count);
 	nf_ct_ext_free(ct);
@@ -1432,6 +1542,84 @@ void nf_ct_untracked_status_or(unsigned
 }
 EXPORT_SYMBOL_GPL(nf_ct_untracked_status_or);
 
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+void nfp_ct_sync(int family)
+{
+	struct nf_conntrack_tuple_hash *h;
+	struct nf_conn *ct;
+	struct nf_conntrack_tuple *tuple;
+	struct nf_conntrack_tuple target_tuple;
+	struct hlist_nulls_node *n;
+	unsigned int bucket = 0;
+	enum ip_conntrack_dir dir;
+	struct net *net = &init_net;
+	unsigned long status;
+
+	spin_lock_bh(&nf_conntrack_lock);
+	/* Go over all tuples in the Linux database */
+	for (; bucket < net->ct.htable_size; bucket++) {
+		hlist_nulls_for_each_entry(h, n, &net->ct.hash[bucket], hnnode) {
+			dir = NF_CT_DIRECTION(h);
+			tuple = &h[IP_CT_DIR_ORIGINAL].tuple;
+
+			ct = nf_ct_tuplehash_to_ctrack(h);
+			if (tuple->src.l3num != family)
+				continue;
+
+			/* We want to add only NFP capable rules*/
+			if (!tuple->nfpCapable)
+				continue;
+
+			if ((tuple->info->mode != IPT_NFP_DROP) && (tuple->info->mode != IPT_NFP_FWD))
+				continue;
+
+			tuple->nfp = true;
+
+			if (tuple->info->mode == IPT_NFP_DROP) {
+				move_fwd_to_nfp(tuple, 0);
+				continue;
+			}
+
+			status = ct->status;
+
+#ifdef CONFIG_MV_ETH_NFP_NAT
+			if (status & IPS_NAT_MASK) {
+				/* NFP NAT is supported only in IPv4 */
+				if (tuple->src.l3num == AF_INET) {
+					/* status says if the original direction requires SNAT or DNAT (or both) */
+					/* if we currently work on the reply direction, we need to "reverse" the NAT status, */
+					/* e.g. if original direction was SNAT, reply should be DNAT. */
+					if (dir != IP_CT_DIR_ORIGINAL)
+						status ^= IPS_NAT_MASK;
+
+					nf_ct_invert_tuplepr(&target_tuple, &ct->tuplehash[!dir].tuple);
+
+					if ((status & IPS_NAT_MASK) == IPS_DST_NAT) {
+						move_nat_to_nfp(tuple, &target_tuple, IP_NAT_MANIP_DST);
+					} else if ((status & IPS_NAT_MASK) == IPS_SRC_NAT) {
+						move_nat_to_nfp(tuple, &target_tuple, IP_NAT_MANIP_SRC);
+					} else {
+						move_nat_to_nfp(tuple, &target_tuple, IP_NAT_MANIP_DST);
+						move_nat_to_nfp(tuple, &target_tuple, IP_NAT_MANIP_SRC);
+					}
+
+					continue;
+				} else {
+					/* NFP does not support NAT for IPv6, so nothing to do with this tuple */
+					tuple->nfp = false;
+					continue;
+				}
+			}
+#endif /* CONFIG_MV_ETH_NFP_NAT */
+			/* If we got till here, it must be IPT_NFP_FWD */
+			move_fwd_to_nfp(tuple, 1);
+		}
+	}
+
+	spin_unlock_bh(&nf_conntrack_lock);
+}
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
+
 static int nf_conntrack_init_init_net(void)
 {
 	int max_factor = 8;
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@ -821,6 +821,9 @@ static int tcp_packet(struct nf_conn *ct
 {
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_tuple *tuple;
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+	struct nf_conntrack_tuple *tupleInverseDir;
+#endif
 	enum tcp_conntrack new_state, old_state;
 	enum ip_conntrack_dir dir;
 	const struct tcphdr *th;
@@ -837,7 +840,9 @@ static int tcp_packet(struct nf_conn *ct
 	index = get_conntrack_index(th);
 	new_state = tcp_conntracks[dir][index][old_state];
 	tuple = &ct->tuplehash[dir].tuple;
-
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+	tupleInverseDir	= &ct->tuplehash[!dir].tuple;
+#endif
 	switch (new_state) {
 	case TCP_CONNTRACK_SYN_SENT:
 		if (old_state < TCP_CONNTRACK_TIME_WAIT)
@@ -989,6 +994,15 @@ static int tcp_packet(struct nf_conn *ct
 		break;
 	}
 
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+	/*
+	 * When connection is handled by NFP, we have to relax TCP tracking
+	 * rules as not all packets goes through Linux conntrack.
+	 */
+	if ((tuple->nfp) || (tupleInverseDir->nfp))
+		goto in_window;
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
+
 	if (!tcp_in_window(ct, &ct->proto.tcp, dir, index,
 			   skb, dataoff, th, pf)) {
 		spin_unlock_bh(&ct->lock);
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -245,6 +245,25 @@ static int ct_seq_show(struct seq_file *
 		return -ENOSPC;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto &&
+           seq_printf(s, "l7proto=%s ", ct->layer7.app_proto))
+		return -ENOSPC;
+#endif
+
+#if defined(CONFIG_MV_ETH_NFP_CT_LEARN)
+	if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfp) && (ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfp)) {
+		if (seq_printf(s, "[NFP (both)] "))
+			goto release;
+	} else if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfp) {
+		if (seq_printf(s, "[NFP (orig)] "))
+			goto release;
+	} else if (ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfp) {
+		if (seq_printf(s, "[NFP (reply)] "))
+			goto release;
+	}
+#endif /* CONFIG_MV_ETH_NFP_CT_LEARN */
+
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		goto release;
 
--- a/net/netfilter/regexp/regexp.c
+++ /dev/null
@@ -1,1197 +0,0 @@
-/*
- * regcomp and regexec -- regsub and regerror are elsewhere
- * @(#)regexp.c	1.3 of 18 April 87
- *
- *	Copyright (c) 1986 by University of Toronto.
- *	Written by Henry Spencer.  Not derived from licensed software.
- *
- *	Permission is granted to anyone to use this software for any
- *	purpose on any computer system, and to redistribute it freely,
- *	subject to the following restrictions:
- *
- *	1. The author is not responsible for the consequences of use of
- *		this software, no matter how awful, even if they arise
- *		from defects in it.
- *
- *	2. The origin of this software must not be misrepresented, either
- *		by explicit claim or by omission.
- *
- *	3. Altered versions must be plainly marked as such, and must not
- *		be misrepresented as being the original software.
- *
- * Beware that some of this code is subtly aware of the way operator
- * precedence is structured in regular expressions.  Serious changes in
- * regular-expression syntax might require a total rethink.
- *
- * This code was modified by Ethan Sommer to work within the kernel
- * (it now uses kmalloc etc..)
- *
- * Modified slightly by Matthew Strait to use more modern C.
- */
-
-#include "regexp.h"
-#include "regmagic.h"
-
-/* added by ethan and matt.  Lets it work in both kernel and user space.
-(So iptables can use it, for instance.)  Yea, it goes both ways... */
-#if __KERNEL__
-  #define malloc(foo) kmalloc(foo,GFP_ATOMIC)
-#else
-  #define printk(format,args...) printf(format,##args)
-#endif
-
-void regerror(char * s)
-{
-        printk("<3>Regexp: %s\n", s);
-        /* NOTREACHED */
-}
-
-/*
- * The "internal use only" fields in regexp.h are present to pass info from
- * compile to execute that permits the execute phase to run lots faster on
- * simple cases.  They are:
- *
- * regstart	char that must begin a match; '\0' if none obvious
- * reganch	is the match anchored (at beginning-of-line only)?
- * regmust	string (pointer into program) that match must include, or NULL
- * regmlen	length of regmust string
- *
- * Regstart and reganch permit very fast decisions on suitable starting points
- * for a match, cutting down the work a lot.  Regmust permits fast rejection
- * of lines that cannot possibly match.  The regmust tests are costly enough
- * that regcomp() supplies a regmust only if the r.e. contains something
- * potentially expensive (at present, the only such thing detected is * or +
- * at the start of the r.e., which can involve a lot of backup).  Regmlen is
- * supplied because the test in regexec() needs it and regcomp() is computing
- * it anyway.
- */
-
-/*
- * Structure for regexp "program".  This is essentially a linear encoding
- * of a nondeterministic finite-state machine (aka syntax charts or
- * "railroad normal form" in parsing technology).  Each node is an opcode
- * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
- * all nodes except BRANCH implement concatenation; a "next" pointer with
- * a BRANCH on both ends of it is connecting two alternatives.  (Here we
- * have one of the subtle syntax dependencies:  an individual BRANCH (as
- * opposed to a collection of them) is never concatenated with anything
- * because of operator precedence.)  The operand of some types of node is
- * a literal string; for others, it is a node leading into a sub-FSM.  In
- * particular, the operand of a BRANCH node is the first node of the branch.
- * (NB this is *not* a tree structure:  the tail of the branch connects
- * to the thing following the set of BRANCHes.)  The opcodes are:
- */
-
-/* definition	number	opnd?	meaning */
-#define	END	0	/* no	End of program. */
-#define	BOL	1	/* no	Match "" at beginning of line. */
-#define	EOL	2	/* no	Match "" at end of line. */
-#define	ANY	3	/* no	Match any one character. */
-#define	ANYOF	4	/* str	Match any character in this string. */
-#define	ANYBUT	5	/* str	Match any character not in this string. */
-#define	BRANCH	6	/* node	Match this alternative, or the next... */
-#define	BACK	7	/* no	Match "", "next" ptr points backward. */
-#define	EXACTLY	8	/* str	Match this string. */
-#define	NOTHING	9	/* no	Match empty string. */
-#define	STAR	10	/* node	Match this (simple) thing 0 or more times. */
-#define	PLUS	11	/* node	Match this (simple) thing 1 or more times. */
-#define	OPEN	20	/* no	Mark this point in input as start of #n. */
-			/*	OPEN+1 is number 1, etc. */
-#define	CLOSE	30	/* no	Analogous to OPEN. */
-
-/*
- * Opcode notes:
- *
- * BRANCH	The set of branches constituting a single choice are hooked
- *		together with their "next" pointers, since precedence prevents
- *		anything being concatenated to any individual branch.  The
- *		"next" pointer of the last BRANCH in a choice points to the
- *		thing following the whole choice.  This is also where the
- *		final "next" pointer of each individual branch points; each
- *		branch starts with the operand node of a BRANCH node.
- *
- * BACK		Normal "next" pointers all implicitly point forward; BACK
- *		exists to make loop structures possible.
- *
- * STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
- *		BRANCH structures using BACK.  Simple cases (one character
- *		per match) are implemented with STAR and PLUS for speed
- *		and to minimize recursive plunges.
- *
- * OPEN,CLOSE	...are numbered at compile time.
- */
-
-/*
- * A node is one char of opcode followed by two chars of "next" pointer.
- * "Next" pointers are stored as two 8-bit pieces, high order first.  The
- * value is a positive offset from the opcode of the node containing it.
- * An operand, if any, simply follows the node.  (Note that much of the
- * code generation knows about this implicit relationship.)
- *
- * Using two bytes for the "next" pointer is vast overkill for most things,
- * but allows patterns to get big without disasters.
- */
-#define	OP(p)	(*(p))
-#define	NEXT(p)	(((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
-#define	OPERAND(p)	((p) + 3)
-
-/*
- * See regmagic.h for one further detail of program structure.
- */
-
-
-/*
- * Utility definitions.
- */
-#ifndef CHARBITS
-#define	UCHARAT(p)	((int)*(unsigned char *)(p))
-#else
-#define	UCHARAT(p)	((int)*(p)&CHARBITS)
-#endif
-
-#define	FAIL(m)	{ regerror(m); return(NULL); }
-#define	ISMULT(c)	((c) == '*' || (c) == '+' || (c) == '?')
-#define	META	"^$.[()|?+*\\"
-
-/*
- * Flags to be passed up and down.
- */
-#define	HASWIDTH	01	/* Known never to match null string. */
-#define	SIMPLE		02	/* Simple enough to be STAR/PLUS operand. */
-#define	SPSTART		04	/* Starts with * or +. */
-#define	WORST		0	/* Worst case. */
-
-/*
- * Global work variables for regcomp().
- */
-struct match_globals {
-char *reginput;		/* String-input pointer. */
-char *regbol;		/* Beginning of input, for ^ check. */
-char **regstartp;	/* Pointer to startp array. */
-char **regendp;		/* Ditto for endp. */
-char *regparse;		/* Input-scan pointer. */
-int regnpar;		/* () count. */
-char regdummy;
-char *regcode;		/* Code-emit pointer; &regdummy = don't. */
-long regsize;		/* Code size. */
-};
-
-/*
- * Forward declarations for regcomp()'s friends.
- */
-#ifndef STATIC
-#define	STATIC	static
-#endif
-STATIC char *reg(struct match_globals *g, int paren,int *flagp);
-STATIC char *regbranch(struct match_globals *g, int *flagp);
-STATIC char *regpiece(struct match_globals *g, int *flagp);
-STATIC char *regatom(struct match_globals *g, int *flagp);
-STATIC char *regnode(struct match_globals *g, char op);
-STATIC char *regnext(struct match_globals *g, char *p);
-STATIC void regc(struct match_globals *g, char b);
-STATIC void reginsert(struct match_globals *g, char op, char *opnd);
-STATIC void regtail(struct match_globals *g, char *p, char *val);
-STATIC void regoptail(struct match_globals *g, char *p, char *val);
-
-
-__kernel_size_t my_strcspn(const char *s1,const char *s2)
-{
-        char *scan1;
-        char *scan2;
-        int count;
-
-        count = 0;
-        for (scan1 = (char *)s1; *scan1 != '\0'; scan1++) {
-                for (scan2 = (char *)s2; *scan2 != '\0';)       /* ++ moved down. */
-                        if (*scan1 == *scan2++)
-                                return(count);
-                count++;
-        }
-        return(count);
-}
-
-/*
- - regcomp - compile a regular expression into internal code
- *
- * We can't allocate space until we know how big the compiled form will be,
- * but we can't compile it (and thus know how big it is) until we've got a
- * place to put the code.  So we cheat:  we compile it twice, once with code
- * generation turned off and size counting turned on, and once "for real".
- * This also means that we don't allocate space until we are sure that the
- * thing really will compile successfully, and we never have to move the
- * code and thus invalidate pointers into it.  (Note that it has to be in
- * one piece because free() must be able to free it all.)
- *
- * Beware that the optimization-preparation code in here knows about some
- * of the structure of the compiled regexp.
- */
-regexp *
-regcomp(char *exp,int *patternsize)
-{
-	register regexp *r;
-	register char *scan;
-	register char *longest;
-	register int len;
-	int flags;
-	struct match_globals g;
-	
-	/* commented out by ethan
-	   extern char *malloc();
-	*/
-
-	if (exp == NULL)
-		FAIL("NULL argument");
-
-	/* First pass: determine size, legality. */
-	g.regparse = exp;
-	g.regnpar = 1;
-	g.regsize = 0L;
-	g.regcode = &g.regdummy;
-	regc(&g, MAGIC);
-	if (reg(&g, 0, &flags) == NULL)
-		return(NULL);
-
-	/* Small enough for pointer-storage convention? */
-	if (g.regsize >= 32767L)		/* Probably could be 65535L. */
-		FAIL("regexp too big");
-
-	/* Allocate space. */
-	*patternsize=sizeof(regexp) + (unsigned)g.regsize;
-	r = (regexp *)malloc(sizeof(regexp) + (unsigned)g.regsize);
-	if (r == NULL)
-		FAIL("out of space");
-
-	/* Second pass: emit code. */
-	g.regparse = exp;
-	g.regnpar = 1;
-	g.regcode = r->program;
-	regc(&g, MAGIC);
-	if (reg(&g, 0, &flags) == NULL)
-		return(NULL);
-
-	/* Dig out information for optimizations. */
-	r->regstart = '\0';	/* Worst-case defaults. */
-	r->reganch = 0;
-	r->regmust = NULL;
-	r->regmlen = 0;
-	scan = r->program+1;			/* First BRANCH. */
-	if (OP(regnext(&g, scan)) == END) {		/* Only one top-level choice. */
-		scan = OPERAND(scan);
-
-		/* Starting-point info. */
-		if (OP(scan) == EXACTLY)
-			r->regstart = *OPERAND(scan);
-		else if (OP(scan) == BOL)
-			r->reganch++;
-
-		/*
-		 * If there's something expensive in the r.e., find the
-		 * longest literal string that must appear and make it the
-		 * regmust.  Resolve ties in favor of later strings, since
-		 * the regstart check works with the beginning of the r.e.
-		 * and avoiding duplication strengthens checking.  Not a
-		 * strong reason, but sufficient in the absence of others.
-		 */
-		if (flags&SPSTART) {
-			longest = NULL;
-			len = 0;
-			for (; scan != NULL; scan = regnext(&g, scan))
-				if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {
-					longest = OPERAND(scan);
-					len = strlen(OPERAND(scan));
-				}
-			r->regmust = longest;
-			r->regmlen = len;
-		}
-	}
-
-	return(r);
-}
-
-/*
- - reg - regular expression, i.e. main body or parenthesized thing
- *
- * Caller must absorb opening parenthesis.
- *
- * Combining parenthesis handling with the base level of regular expression
- * is a trifle forced, but the need to tie the tails of the branches to what
- * follows makes it hard to avoid.
- */
-static char *
-reg(struct match_globals *g, int paren, int *flagp /* Parenthesized? */ )
-{
-	register char *ret;
-	register char *br;
-	register char *ender;
-	register int parno = 0; /* 0 makes gcc happy */
-	int flags;
-
-	*flagp = HASWIDTH;	/* Tentatively. */
-
-	/* Make an OPEN node, if parenthesized. */
-	if (paren) {
-		if (g->regnpar >= NSUBEXP)
-			FAIL("too many ()");
-		parno = g->regnpar;
-		g->regnpar++;
-		ret = regnode(g, OPEN+parno);
-	} else
-		ret = NULL;
-
-	/* Pick up the branches, linking them together. */
-	br = regbranch(g, &flags);
-	if (br == NULL)
-		return(NULL);
-	if (ret != NULL)
-		regtail(g, ret, br);	/* OPEN -> first. */
-	else
-		ret = br;
-	if (!(flags&HASWIDTH))
-		*flagp &= ~HASWIDTH;
-	*flagp |= flags&SPSTART;
-	while (*g->regparse == '|') {
-		g->regparse++;
-		br = regbranch(g, &flags);
-		if (br == NULL)
-			return(NULL);
-		regtail(g, ret, br);	/* BRANCH -> BRANCH. */
-		if (!(flags&HASWIDTH))
-			*flagp &= ~HASWIDTH;
-		*flagp |= flags&SPSTART;
-	}
-
-	/* Make a closing node, and hook it on the end. */
-	ender = regnode(g, (paren) ? CLOSE+parno : END);	
-	regtail(g, ret, ender);
-
-	/* Hook the tails of the branches to the closing node. */
-	for (br = ret; br != NULL; br = regnext(g, br))
-		regoptail(g, br, ender);
-
-	/* Check for proper termination. */
-	if (paren && *g->regparse++ != ')') {
-		FAIL("unmatched ()");
-	} else if (!paren && *g->regparse != '\0') {
-		if (*g->regparse == ')') {
-			FAIL("unmatched ()");
-		} else
-			FAIL("junk on end");	/* "Can't happen". */
-		/* NOTREACHED */
-	}
-
-	return(ret);
-}
-
-/*
- - regbranch - one alternative of an | operator
- *
- * Implements the concatenation operator.
- */
-static char *
-regbranch(struct match_globals *g, int *flagp)
-{
-	register char *ret;
-	register char *chain;
-	register char *latest;
-	int flags;
-
-	*flagp = WORST;		/* Tentatively. */
-
-	ret = regnode(g, BRANCH);
-	chain = NULL;
-	while (*g->regparse != '\0' && *g->regparse != '|' && *g->regparse != ')') {
-		latest = regpiece(g, &flags);
-		if (latest == NULL)
-			return(NULL);
-		*flagp |= flags&HASWIDTH;
-		if (chain == NULL)	/* First piece. */
-			*flagp |= flags&SPSTART;
-		else
-			regtail(g, chain, latest);
-		chain = latest;
-	}
-	if (chain == NULL)	/* Loop ran zero times. */
-		(void) regnode(g, NOTHING);
-
-	return(ret);
-}
-
-/*
- - regpiece - something followed by possible [*+?]
- *
- * Note that the branching code sequences used for ? and the general cases
- * of * and + are somewhat optimized:  they use the same NOTHING node as
- * both the endmarker for their branch list and the body of the last branch.
- * It might seem that this node could be dispensed with entirely, but the
- * endmarker role is not redundant.
- */
-static char *
-regpiece(struct match_globals *g, int *flagp)
-{
-	register char *ret;
-	register char op;
-	register char *next;
-	int flags;
-
-	ret = regatom(g, &flags);
-	if (ret == NULL)
-		return(NULL);
-
-	op = *g->regparse;
-	if (!ISMULT(op)) {
-		*flagp = flags;
-		return(ret);
-	}
-
-	if (!(flags&HASWIDTH) && op != '?')
-		FAIL("*+ operand could be empty");
-	*flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);
-
-	if (op == '*' && (flags&SIMPLE))
-		reginsert(g, STAR, ret);
-	else if (op == '*') {
-		/* Emit x* as (x&|), where & means "self". */
-		reginsert(g, BRANCH, ret);			/* Either x */
-		regoptail(g, ret, regnode(g, BACK));		/* and loop */
-		regoptail(g, ret, ret);			/* back */
-		regtail(g, ret, regnode(g, BRANCH));		/* or */
-		regtail(g, ret, regnode(g, NOTHING));		/* null. */
-	} else if (op == '+' && (flags&SIMPLE))
-		reginsert(g, PLUS, ret);
-	else if (op == '+') {
-		/* Emit x+ as x(&|), where & means "self". */
-		next = regnode(g, BRANCH);			/* Either */
-		regtail(g, ret, next);
-		regtail(g, regnode(g, BACK), ret);		/* loop back */
-		regtail(g, next, regnode(g, BRANCH));		/* or */
-		regtail(g, ret, regnode(g, NOTHING));		/* null. */
-	} else if (op == '?') {
-		/* Emit x? as (x|) */
-		reginsert(g, BRANCH, ret);			/* Either x */
-		regtail(g, ret, regnode(g, BRANCH));		/* or */
-		next = regnode(g, NOTHING);		/* null. */
-		regtail(g, ret, next);
-		regoptail(g, ret, next);
-	}
-	g->regparse++;
-	if (ISMULT(*g->regparse))
-		FAIL("nested *?+");
-
-	return(ret);
-}
-
-/*
- - regatom - the lowest level
- *
- * Optimization:  gobbles an entire sequence of ordinary characters so that
- * it can turn them into a single node, which is smaller to store and
- * faster to run.  Backslashed characters are exceptions, each becoming a
- * separate node; the code is simpler that way and it's not worth fixing.
- */
-static char *
-regatom(struct match_globals *g, int *flagp)
-{
-	register char *ret;
-	int flags;
-
-	*flagp = WORST;		/* Tentatively. */
-
-	switch (*g->regparse++) {
-	case '^':
-		ret = regnode(g, BOL);
-		break;
-	case '$':
-		ret = regnode(g, EOL);
-		break;
-	case '.':
-		ret = regnode(g, ANY);
-		*flagp |= HASWIDTH|SIMPLE;
-		break;
-	case '[': {
-			register int class;
-			register int classend;
-
-			if (*g->regparse == '^') {	/* Complement of range. */
-				ret = regnode(g, ANYBUT);
-				g->regparse++;
-			} else
-				ret = regnode(g, ANYOF);
-			if (*g->regparse == ']' || *g->regparse == '-')
-				regc(g, *g->regparse++);
-			while (*g->regparse != '\0' && *g->regparse != ']') {
-				if (*g->regparse == '-') {
-					g->regparse++;
-					if (*g->regparse == ']' || *g->regparse == '\0')
-						regc(g, '-');
-					else {
-						class = UCHARAT(g->regparse-2)+1;
-						classend = UCHARAT(g->regparse);
-						if (class > classend+1)
-							FAIL("invalid [] range");
-						for (; class <= classend; class++)
-							regc(g, class);
-						g->regparse++;
-					}
-				} else
-					regc(g, *g->regparse++);
-			}
-			regc(g, '\0');
-			if (*g->regparse != ']')
-				FAIL("unmatched []");
-			g->regparse++;
-			*flagp |= HASWIDTH|SIMPLE;
-		}
-		break;
-	case '(':
-		ret = reg(g, 1, &flags);
-		if (ret == NULL)
-			return(NULL);
-		*flagp |= flags&(HASWIDTH|SPSTART);
-		break;
-	case '\0':
-	case '|':
-	case ')':
-		FAIL("internal urp");	/* Supposed to be caught earlier. */
-		break;
-	case '?':
-	case '+':
-	case '*':
-		FAIL("?+* follows nothing");
-		break;
-	case '\\':
-		if (*g->regparse == '\0')
-			FAIL("trailing \\");
-		ret = regnode(g, EXACTLY);
-		regc(g, *g->regparse++);
-		regc(g, '\0');
-		*flagp |= HASWIDTH|SIMPLE;
-		break;
-	default: {
-			register int len;
-			register char ender;
-
-			g->regparse--;
-			len = my_strcspn((const char *)g->regparse, (const char *)META);
-			if (len <= 0)
-				FAIL("internal disaster");
-			ender = *(g->regparse+len);
-			if (len > 1 && ISMULT(ender))
-				len--;		/* Back off clear of ?+* operand. */
-			*flagp |= HASWIDTH;
-			if (len == 1)
-				*flagp |= SIMPLE;
-			ret = regnode(g, EXACTLY);
-			while (len > 0) {
-				regc(g, *g->regparse++);
-				len--;
-			}
-			regc(g, '\0');
-		}
-		break;
-	}
-
-	return(ret);
-}
-
-/*
- - regnode - emit a node
- */
-static char *			/* Location. */
-regnode(struct match_globals *g, char op)
-{
-	register char *ret;
-	register char *ptr;
-
-	ret = g->regcode;
-	if (ret == &g->regdummy) {
-		g->regsize += 3;
-		return(ret);
-	}
-
-	ptr = ret;
-	*ptr++ = op;
-	*ptr++ = '\0';		/* Null "next" pointer. */
-	*ptr++ = '\0';
-	g->regcode = ptr;
-
-	return(ret);
-}
-
-/*
- - regc - emit (if appropriate) a byte of code
- */
-static void
-regc(struct match_globals *g, char b)
-{
-	if (g->regcode != &g->regdummy)
-		*g->regcode++ = b;
-	else
-		g->regsize++;
-}
-
-/*
- - reginsert - insert an operator in front of already-emitted operand
- *
- * Means relocating the operand.
- */
-static void
-reginsert(struct match_globals *g, char op, char* opnd)
-{
-	register char *src;
-	register char *dst;
-	register char *place;
-
-	if (g->regcode == &g->regdummy) {
-		g->regsize += 3;
-		return;
-	}
-
-	src = g->regcode;
-	g->regcode += 3;
-	dst = g->regcode;
-	while (src > opnd)
-		*--dst = *--src;
-
-	place = opnd;		/* Op node, where operand used to be. */
-	*place++ = op;
-	*place++ = '\0';
-	*place++ = '\0';
-}
-
-/*
- - regtail - set the next-pointer at the end of a node chain
- */
-static void
-regtail(struct match_globals *g, char *p, char *val)
-{
-	register char *scan;
-	register char *temp;
-	register int offset;
-
-	if (p == &g->regdummy)
-		return;
-
-	/* Find last node. */
-	scan = p;
-	for (;;) {
-		temp = regnext(g, scan);
-		if (temp == NULL)
-			break;
-		scan = temp;
-	}
-
-	if (OP(scan) == BACK)
-		offset = scan - val;
-	else
-		offset = val - scan;
-	*(scan+1) = (offset>>8)&0377;
-	*(scan+2) = offset&0377;
-}
-
-/*
- - regoptail - regtail on operand of first argument; nop if operandless
- */
-static void
-regoptail(struct match_globals *g, char *p, char *val)
-{
-	/* "Operandless" and "op != BRANCH" are synonymous in practice. */
-	if (p == NULL || p == &g->regdummy || OP(p) != BRANCH)
-		return;
-	regtail(g, OPERAND(p), val);
-}
-
-/*
- * regexec and friends
- */
-
-
-/*
- * Forwards.
- */
-STATIC int regtry(struct match_globals *g, regexp *prog, char *string);
-STATIC int regmatch(struct match_globals *g, char *prog);
-STATIC int regrepeat(struct match_globals *g, char *p);
-
-#ifdef DEBUG
-int regnarrate = 0;
-void regdump();
-STATIC char *regprop(char *op);
-#endif
-
-/*
- - regexec - match a regexp against a string
- */
-int
-regexec(regexp *prog, char *string)
-{
-	register char *s;
-	struct match_globals g;
-
-	/* Be paranoid... */
-	if (prog == NULL || string == NULL) {
-		printk("<3>Regexp: NULL parameter\n");
-		return(0);
-	}
-
-	/* Check validity of program. */
-	if (UCHARAT(prog->program) != MAGIC) {
-		printk("<3>Regexp: corrupted program\n");
-		return(0);
-	}
-
-	/* If there is a "must appear" string, look for it. */
-	if (prog->regmust != NULL) {
-		s = string;
-		while ((s = strchr(s, prog->regmust[0])) != NULL) {
-			if (strncmp(s, prog->regmust, prog->regmlen) == 0)
-				break;	/* Found it. */
-			s++;
-		}
-		if (s == NULL)	/* Not present. */
-			return(0);
-	}
-
-	/* Mark beginning of line for ^ . */
-	g.regbol = string;
-
-	/* Simplest case:  anchored match need be tried only once. */
-	if (prog->reganch)
-		return(regtry(&g, prog, string));
-
-	/* Messy cases:  unanchored match. */
-	s = string;
-	if (prog->regstart != '\0')
-		/* We know what char it must start with. */
-		while ((s = strchr(s, prog->regstart)) != NULL) {
-			if (regtry(&g, prog, s))
-				return(1);
-			s++;
-		}
-	else
-		/* We don't -- general case. */
-		do {
-			if (regtry(&g, prog, s))
-				return(1);
-		} while (*s++ != '\0');
-
-	/* Failure. */
-	return(0);
-}
-
-/*
- - regtry - try match at specific point
- */
-static int			/* 0 failure, 1 success */
-regtry(struct match_globals *g, regexp *prog, char *string)
-{
-	register int i;
-	register char **sp;
-	register char **ep;
-
-	g->reginput = string;
-	g->regstartp = prog->startp;
-	g->regendp = prog->endp;
-
-	sp = prog->startp;
-	ep = prog->endp;
-	for (i = NSUBEXP; i > 0; i--) {
-		*sp++ = NULL;
-		*ep++ = NULL;
-	}
-	if (regmatch(g, prog->program + 1)) {
-		prog->startp[0] = string;
-		prog->endp[0] = g->reginput;
-		return(1);
-	} else
-		return(0);
-}
-
-/*
- - regmatch - main matching routine
- *
- * Conceptually the strategy is simple:  check to see whether the current
- * node matches, call self recursively to see whether the rest matches,
- * and then act accordingly.  In practice we make some effort to avoid
- * recursion, in particular by going through "ordinary" nodes (that don't
- * need to know whether the rest of the match failed) by a loop instead of
- * by recursion.
- */
-static int			/* 0 failure, 1 success */
-regmatch(struct match_globals *g, char *prog)
-{
-	register char *scan = prog; /* Current node. */
-	char *next;		    /* Next node. */
-
-#ifdef DEBUG
-	if (scan != NULL && regnarrate)
-		fprintf(stderr, "%s(\n", regprop(scan));
-#endif
-	while (scan != NULL) {
-#ifdef DEBUG
-		if (regnarrate)
-			fprintf(stderr, "%s...\n", regprop(scan));
-#endif
-		next = regnext(g, scan);
-
-		switch (OP(scan)) {
-		case BOL:
-			if (g->reginput != g->regbol)
-				return(0);
-			break;
-		case EOL:
-			if (*g->reginput != '\0')
-				return(0);
-			break;
-		case ANY:
-			if (*g->reginput == '\0')
-				return(0);
-			g->reginput++;
-			break;
-		case EXACTLY: {
-				register int len;
-				register char *opnd;
-
-				opnd = OPERAND(scan);
-				/* Inline the first character, for speed. */
-				if (*opnd != *g->reginput)
-					return(0);
-				len = strlen(opnd);
-				if (len > 1 && strncmp(opnd, g->reginput, len) != 0)
-					return(0);
-				g->reginput += len;
-			}
-			break;
-		case ANYOF:
-			if (*g->reginput == '\0' || strchr(OPERAND(scan), *g->reginput) == NULL)
-				return(0);
-			g->reginput++;
-			break;
-		case ANYBUT:
-			if (*g->reginput == '\0' || strchr(OPERAND(scan), *g->reginput) != NULL)
-				return(0);
-			g->reginput++;
-			break;
-		case NOTHING:
-		case BACK:
-			break;
-		case OPEN+1:
-		case OPEN+2:
-		case OPEN+3:
-		case OPEN+4:
-		case OPEN+5:
-		case OPEN+6:
-		case OPEN+7:
-		case OPEN+8:
-		case OPEN+9: {
-				register int no;
-				register char *save;
-
-				no = OP(scan) - OPEN;
-				save = g->reginput;
-
-				if (regmatch(g, next)) {
-					/*
-					 * Don't set startp if some later
-					 * invocation of the same parentheses
-					 * already has.
-					 */
-					if (g->regstartp[no] == NULL)
-						g->regstartp[no] = save;
-					return(1);
-				} else
-					return(0);
-			}
-			break;
-		case CLOSE+1:
-		case CLOSE+2:
-		case CLOSE+3:
-		case CLOSE+4:
-		case CLOSE+5:
-		case CLOSE+6:
-		case CLOSE+7:
-		case CLOSE+8:
-		case CLOSE+9:
-			{
-				register int no;
-				register char *save;
-
-				no = OP(scan) - CLOSE;
-				save = g->reginput;
-
-				if (regmatch(g, next)) {
-					/*
-					 * Don't set endp if some later
-					 * invocation of the same parentheses
-					 * already has.
-					 */
-					if (g->regendp[no] == NULL)
-						g->regendp[no] = save;
-					return(1);
-				} else
-					return(0);
-			}
-			break;
-		case BRANCH: {
-				register char *save;
-
-				if (OP(next) != BRANCH)		/* No choice. */
-					next = OPERAND(scan);	/* Avoid recursion. */
-				else {
-					do {
-						save = g->reginput;
-						if (regmatch(g, OPERAND(scan)))
-							return(1);
-						g->reginput = save;
-						scan = regnext(g, scan);
-					} while (scan != NULL && OP(scan) == BRANCH);
-					return(0);
-					/* NOTREACHED */
-				}
-			}
-			break;
-		case STAR:
-		case PLUS: {
-				register char nextch;
-				register int no;
-				register char *save;
-				register int min;
-
-				/*
-				 * Lookahead to avoid useless match attempts
-				 * when we know what character comes next.
-				 */
-				nextch = '\0';
-				if (OP(next) == EXACTLY)
-					nextch = *OPERAND(next);
-				min = (OP(scan) == STAR) ? 0 : 1;
-				save = g->reginput;
-				no = regrepeat(g, OPERAND(scan));
-				while (no >= min) {
-					/* If it could work, try it. */
-					if (nextch == '\0' || *g->reginput == nextch)
-						if (regmatch(g, next))
-							return(1);
-					/* Couldn't or didn't -- back up. */
-					no--;
-					g->reginput = save + no;
-				}
-				return(0);
-			}
-			break;
-		case END:
-			return(1);	/* Success! */
-			break;
-		default:
-			printk("<3>Regexp: memory corruption\n");
-			return(0);
-			break;
-		}
-
-		scan = next;
-	}
-
-	/*
-	 * We get here only if there's trouble -- normally "case END" is
-	 * the terminating point.
-	 */
-	printk("<3>Regexp: corrupted pointers\n");
-	return(0);
-}
-
-/*
- - regrepeat - repeatedly match something simple, report how many
- */
-static int
-regrepeat(struct match_globals *g, char *p)
-{
-	register int count = 0;
-	register char *scan;
-	register char *opnd;
-
-	scan = g->reginput;
-	opnd = OPERAND(p);
-	switch (OP(p)) {
-	case ANY:
-		count = strlen(scan);
-		scan += count;
-		break;
-	case EXACTLY:
-		while (*opnd == *scan) {
-			count++;
-			scan++;
-		}
-		break;
-	case ANYOF:
-		while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
-			count++;
-			scan++;
-		}
-		break;
-	case ANYBUT:
-		while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
-			count++;
-			scan++;
-		}
-		break;
-	default:		/* Oh dear.  Called inappropriately. */
-		printk("<3>Regexp: internal foulup\n");
-		count = 0;	/* Best compromise. */
-		break;
-	}
-	g->reginput = scan;
-
-	return(count);
-}
-
-/*
- - regnext - dig the "next" pointer out of a node
- */
-static char*
-regnext(struct match_globals *g, char *p)
-{
-	register int offset;
-
-	if (p == &g->regdummy)
-		return(NULL);
-
-	offset = NEXT(p);
-	if (offset == 0)
-		return(NULL);
-
-	if (OP(p) == BACK)
-		return(p-offset);
-	else
-		return(p+offset);
-}
-
-#ifdef DEBUG
-
-STATIC char *regprop();
-
-/*
- - regdump - dump a regexp onto stdout in vaguely comprehensible form
- */
-void
-regdump(regexp *r)
-{
-	register char *s;
-	register char op = EXACTLY;	/* Arbitrary non-END op. */
-	register char *next;
-	/* extern char *strchr(); */
-
-
-	s = r->program + 1;
-	while (op != END) {	/* While that wasn't END last time... */
-		op = OP(s);
-		printf("%2d%s", s-r->program, regprop(s));	/* Where, what. */
-		next = regnext(s);
-		if (next == NULL)		/* Next ptr. */
-			printf("(0)");
-		else
-			printf("(%d)", (s-r->program)+(next-s));
-		s += 3;
-		if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
-			/* Literal string, where present. */
-			while (*s != '\0') {
-				putchar(*s);
-				s++;
-			}
-			s++;
-		}
-		putchar('\n');
-	}
-
-	/* Header fields of interest. */
-	if (r->regstart != '\0')
-		printf("start `%c' ", r->regstart);
-	if (r->reganch)
-		printf("anchored ");
-	if (r->regmust != NULL)
-		printf("must have \"%s\"", r->regmust);
-	printf("\n");
-}
-
-/*
- - regprop - printable representation of opcode
- */
-static char *
-regprop(char *op)
-{
-#define BUFLEN 50
-	register char *p;
-	static char buf[BUFLEN];
-
-	strcpy(buf, ":");
-
-	switch (OP(op)) {
-	case BOL:
-		p = "BOL";
-		break;
-	case EOL:
-		p = "EOL";
-		break;
-	case ANY:
-		p = "ANY";
-		break;
-	case ANYOF:
-		p = "ANYOF";
-		break;
-	case ANYBUT:
-		p = "ANYBUT";
-		break;
-	case BRANCH:
-		p = "BRANCH";
-		break;
-	case EXACTLY:
-		p = "EXACTLY";
-		break;
-	case NOTHING:
-		p = "NOTHING";
-		break;
-	case BACK:
-		p = "BACK";
-		break;
-	case END:
-		p = "END";
-		break;
-	case OPEN+1:
-	case OPEN+2:
-	case OPEN+3:
-	case OPEN+4:
-	case OPEN+5:
-	case OPEN+6:
-	case OPEN+7:
-	case OPEN+8:
-	case OPEN+9:
-		snprintf(buf+strlen(buf),BUFLEN-strlen(buf), "OPEN%d", OP(op)-OPEN);
-		p = NULL;
-		break;
-	case CLOSE+1:
-	case CLOSE+2:
-	case CLOSE+3:
-	case CLOSE+4:
-	case CLOSE+5:
-	case CLOSE+6:
-	case CLOSE+7:
-	case CLOSE+8:
-	case CLOSE+9:
-		snprintf(buf+strlen(buf),BUFLEN-strlen(buf), "CLOSE%d", OP(op)-CLOSE);
-		p = NULL;
-		break;
-	case STAR:
-		p = "STAR";
-		break;
-	case PLUS:
-		p = "PLUS";
-		break;
-	default:
-		printk("<3>Regexp: corrupted opcode\n");
-		break;
-	}
-	if (p != NULL)
-		strncat(buf, p, BUFLEN-strlen(buf));
-	return(buf);
-}
-#endif
-
-
--- a/net/netfilter/regexp/regexp.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Definitions etc. for regexp(3) routines.
- *
- * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
- * not the System V one.
- */
-
-#ifndef REGEXP_H
-#define REGEXP_H
-
-
-/*
-http://www.opensource.apple.com/darwinsource/10.3/expect-1/expect/expect.h ,
-which contains a version of this library, says:
-
- *
- * NSUBEXP must be at least 10, and no greater than 117 or the parser
- * will not work properly.
- *
-
-However, it looks rather like this library is limited to 10.  If you think
-otherwise, let us know.
-*/
-
-#define NSUBEXP  10
-typedef struct regexp {
-	char *startp[NSUBEXP];
-	char *endp[NSUBEXP];
-	char regstart;		/* Internal use only. */
-	char reganch;		/* Internal use only. */
-	char *regmust;		/* Internal use only. */
-	int regmlen;		/* Internal use only. */
-	char program[1];	/* Unwarranted chumminess with compiler. */
-} regexp;
-
-regexp * regcomp(char *exp, int *patternsize);
-int regexec(regexp *prog, char *string);
-void regsub(regexp *prog, char *source, char *dest);
-void regerror(char *s);
-
-#endif
--- a/net/netfilter/regexp/regmagic.h
+++ /dev/null
@@ -1,5 +0,0 @@
-/*
- * The first byte of the regexp internal "program" is actually this magic
- * number; the start node begins in the second byte.
- */
-#define	MAGIC	0234
--- a/net/netfilter/regexp/regsub.c
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * regsub
- * @(#)regsub.c	1.3 of 2 April 86
- *
- *	Copyright (c) 1986 by University of Toronto.
- *	Written by Henry Spencer.  Not derived from licensed software.
- *
- *	Permission is granted to anyone to use this software for any
- *	purpose on any computer system, and to redistribute it freely,
- *	subject to the following restrictions:
- *
- *	1. The author is not responsible for the consequences of use of
- *		this software, no matter how awful, even if they arise
- *		from defects in it.
- *
- *	2. The origin of this software must not be misrepresented, either
- *		by explicit claim or by omission.
- *
- *	3. Altered versions must be plainly marked as such, and must not
- *		be misrepresented as being the original software.
- *
- *
- * This code was modified by Ethan Sommer to work within the kernel
- * (it now uses kmalloc etc..)
- *
- */
-#include "regexp.h"
-#include "regmagic.h"
-#include <linux/string.h>
-
-
-#ifndef CHARBITS
-#define	UCHARAT(p)	((int)*(unsigned char *)(p))
-#else
-#define	UCHARAT(p)	((int)*(p)&CHARBITS)
-#endif
-
-#if 0
-//void regerror(char * s)
-//{
-//        printk("regexp(3): %s", s);
-//        /* NOTREACHED */
-//}
-#endif
-
-/*
- - regsub - perform substitutions after a regexp match
- */
-void
-regsub(regexp * prog, char * source, char * dest)
-{
-	register char *src;
-	register char *dst;
-	register char c;
-	register int no;
-	register int len;
-	
-	/* Not necessary and gcc doesn't like it -MLS */
-	/*extern char *strncpy();*/
-
-	if (prog == NULL || source == NULL || dest == NULL) {
-		regerror("NULL parm to regsub");
-		return;
-	}
-	if (UCHARAT(prog->program) != MAGIC) {
-		regerror("damaged regexp fed to regsub");
-		return;
-	}
-
-	src = source;
-	dst = dest;
-	while ((c = *src++) != '\0') {
-		if (c == '&')
-			no = 0;
-		else if (c == '\\' && '0' <= *src && *src <= '9')
-			no = *src++ - '0';
-		else
-			no = -1;
-
-		if (no < 0) {	/* Ordinary character. */
-			if (c == '\\' && (*src == '\\' || *src == '&'))
-				c = *src++;
-			*dst++ = c;
-		} else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
-			len = prog->endp[no] - prog->startp[no];
-			(void) strncpy(dst, prog->startp[no], len);
-			dst += len;
-			if (len != 0 && *(dst-1) == '\0') {	/* strncpy hit NUL. */
-				regerror("damaged match string");
-				return;
-			}
-		}
-	}
-	*dst++ = '\0';
-}
--- a/net/netfilter/xt_layer7.c
+++ /dev/null
@@ -1,700 +0,0 @@
-/*
-  Kernel module to match application layer (OSI layer 7) data in connections.
-
-  http://l7-filter.sf.net
-
-  (C) 2003-2009 Matthew Strait and Ethan Sommer.
-
-  This program is free software; you can redistribute it and/or
-  modify it under the terms of the GNU General Public License
-  as published by the Free Software Foundation; either version
-  2 of the License, or (at your option) any later version.
-  http://www.gnu.org/licenses/gpl.txt
-
-  Based on ipt_string.c (C) 2000 Emmanuel Roger <winfield@freegates.be>,
-  xt_helper.c (C) 2002 Harald Welte and cls_layer7.c (C) 2003 Matthew Strait,
-  Ethan Sommer, Justin Levandoski.
-*/
-
-#include <linux/spinlock.h>
-#include <linux/version.h>
-#include <net/ip.h>
-#include <net/tcp.h>
-#include <linux/module.h>
-#include <linux/skbuff.h>
-#include <linux/netfilter.h>
-#include <net/netfilter/nf_conntrack.h>
-#include <net/netfilter/nf_conntrack_core.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-#include <net/netfilter/nf_conntrack_extend.h>
-#include <net/netfilter/nf_conntrack_acct.h>
-#endif
-#include <linux/netfilter/x_tables.h>
-#include <linux/netfilter/xt_layer7.h>
-#include <linux/ctype.h>
-#include <linux/proc_fs.h>
-
-#include "regexp/regexp.c"
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Matthew Strait <quadong@users.sf.net>, Ethan Sommer <sommere@users.sf.net>");
-MODULE_DESCRIPTION("iptables application layer match module");
-MODULE_ALIAS("ipt_layer7");
-MODULE_VERSION("2.21");
-
-static int maxdatalen = 2048; // this is the default
-module_param(maxdatalen, int, 0444);
-MODULE_PARM_DESC(maxdatalen, "maximum bytes of data looked at by l7-filter");
-#ifdef CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG
-	#define DPRINTK(format,args...) printk(format,##args)
-#else
-	#define DPRINTK(format,args...)
-#endif
-
-/* Number of packets whose data we look at.
-This can be modified through /proc/net/layer7_numpackets */
-static int num_packets = 10;
-
-static struct pattern_cache {
-	char * regex_string;
-	regexp * pattern;
-	struct pattern_cache * next;
-} * first_pattern_cache = NULL;
-
-DEFINE_SPINLOCK(l7_lock);
-
-static int total_acct_packets(struct nf_conn *ct)
-{
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 26)
-	BUG_ON(ct == NULL);
-	return (ct->counters[IP_CT_DIR_ORIGINAL].packets + ct->counters[IP_CT_DIR_REPLY].packets);
-#else
-	struct nf_conn_counter *acct;
-
-	BUG_ON(ct == NULL);
-	acct = nf_conn_acct_find(ct);
-	if (!acct)
-		return 0;
-	return (acct[IP_CT_DIR_ORIGINAL].packets + acct[IP_CT_DIR_REPLY].packets);
-#endif
-}
-
-#ifdef CONFIG_IP_NF_MATCH_LAYER7_DEBUG
-/* Converts an unfriendly string into a friendly one by
-replacing unprintables with periods and all whitespace with " ". */
-static char * friendly_print(unsigned char * s)
-{
-	char * f = kmalloc(strlen(s) + 1, GFP_ATOMIC);
-	int i;
-
-	if(!f) {
-		if (net_ratelimit())
-			printk(KERN_ERR "layer7: out of memory in "
-					"friendly_print, bailing.\n");
-		return NULL;
-	}
-
-	for(i = 0; i < strlen(s); i++){
-		if(isprint(s[i]) && s[i] < 128)	f[i] = s[i];
-		else if(isspace(s[i]))		f[i] = ' ';
-		else 				f[i] = '.';
-	}
-	f[i] = '\0';
-	return f;
-}
-
-static char dec2hex(int i)
-{
-	switch (i) {
-		case 0 ... 9:
-			return (i + '0');
-			break;
-		case 10 ... 15:
-			return (i - 10 + 'a');
-			break;
-		default:
-			if (net_ratelimit())
-				printk("layer7: Problem in dec2hex\n");
-			return '\0';
-	}
-}
-
-static char * hex_print(unsigned char * s)
-{
-	char * g = kmalloc(strlen(s)*3 + 1, GFP_ATOMIC);
-	int i;
-
-	if(!g) {
-	       if (net_ratelimit())
-			printk(KERN_ERR "layer7: out of memory in hex_print, "
-					"bailing.\n");
-	       return NULL;
-	}
-
-	for(i = 0; i < strlen(s); i++) {
-		g[i*3    ] = dec2hex(s[i]/16);
-		g[i*3 + 1] = dec2hex(s[i]%16);
-		g[i*3 + 2] = ' ';
-	}
-	g[i*3] = '\0';
-
-	return g;
-}
-#endif // DEBUG
-
-/* Use instead of regcomp.  As we expect to be seeing the same regexps over and
-over again, it make sense to cache the results. */
-static regexp * compile_and_cache(const char * regex_string, 
-                                  const char * protocol)
-{
-	struct pattern_cache * node               = first_pattern_cache;
-	struct pattern_cache * last_pattern_cache = first_pattern_cache;
-	struct pattern_cache * tmp;
-	unsigned int len;
-
-	while (node != NULL) {
-		if (!strcmp(node->regex_string, regex_string))
-		return node->pattern;
-
-		last_pattern_cache = node;/* points at the last non-NULL node */
-		node = node->next;
-	}
-
-	/* If we reach the end of the list, then we have not yet cached
-	   the pattern for this regex. Let's do that now.
-	   Be paranoid about running out of memory to avoid list corruption. */
-	tmp = kmalloc(sizeof(struct pattern_cache), GFP_ATOMIC);
-
-	if(!tmp) {
-		if (net_ratelimit())
-			printk(KERN_ERR "layer7: out of memory in "
-					"compile_and_cache, bailing.\n");
-		return NULL;
-	}
-
-	tmp->regex_string  = kmalloc(strlen(regex_string) + 1, GFP_ATOMIC);
-	tmp->pattern       = kmalloc(sizeof(struct regexp),    GFP_ATOMIC);
-	tmp->next = NULL;
-
-	if(!tmp->regex_string || !tmp->pattern) {
-		if (net_ratelimit())
-			printk(KERN_ERR "layer7: out of memory in "
-					"compile_and_cache, bailing.\n");
-		kfree(tmp->regex_string);
-		kfree(tmp->pattern);
-		kfree(tmp);
-		return NULL;
-	}
-
-	/* Ok.  The new node is all ready now. */
-	node = tmp;
-
-	if(first_pattern_cache == NULL) /* list is empty */
-		first_pattern_cache = node; /* make node the beginning */
-	else
-		last_pattern_cache->next = node; /* attach node to the end */
-
-	/* copy the string and compile the regex */
-	len = strlen(regex_string);
-	DPRINTK("About to compile this: \"%s\"\n", regex_string);
-	node->pattern = regcomp((char *)regex_string, &len);
-	if ( !node->pattern ) {
-		if (net_ratelimit())
-			printk(KERN_ERR "layer7: Error compiling regexp "
-					"\"%s\" (%s)\n", 
-					regex_string, protocol);
-		/* pattern is now cached as NULL, so we won't try again. */
-	}
-
-	strcpy(node->regex_string, regex_string);
-	return node->pattern;
-}
-
-static int can_handle(const struct sk_buff *skb)
-{
-	if(!ip_hdr(skb)) /* not IP */
-		return 0;
-	if(ip_hdr(skb)->protocol != IPPROTO_TCP &&
-	   ip_hdr(skb)->protocol != IPPROTO_UDP &&
-	   ip_hdr(skb)->protocol != IPPROTO_ICMP)
-		return 0;
-	return 1;
-}
-
-/* Returns offset the into the skb->data that the application data starts */
-static int app_data_offset(const struct sk_buff *skb)
-{
-	/* In case we are ported somewhere (ebtables?) where ip_hdr(skb)
-	isn't set, this can be gotten from 4*(skb->data[0] & 0x0f) as well. */
-	int ip_hl = 4*ip_hdr(skb)->ihl;
-
-	if( ip_hdr(skb)->protocol == IPPROTO_TCP ) {
-		/* 12 == offset into TCP header for the header length field.
-		Can't get this with skb->h.th->doff because the tcphdr
-		struct doesn't get set when routing (this is confirmed to be
-		true in Netfilter as well as QoS.) */
-		int tcp_hl = 4*(skb->data[ip_hl + 12] >> 4);
-
-		return ip_hl + tcp_hl;
-	} else if( ip_hdr(skb)->protocol == IPPROTO_UDP  ) {
-		return ip_hl + 8; /* UDP header is always 8 bytes */
-	} else if( ip_hdr(skb)->protocol == IPPROTO_ICMP ) {
-		return ip_hl + 8; /* ICMP header is 8 bytes */
-	} else {
-		if (net_ratelimit())
-			printk(KERN_ERR "layer7: tried to handle unknown "
-					"protocol!\n");
-		return ip_hl + 8; /* something reasonable */
-	}
-}
-
-/* handles whether there's a match when we aren't appending data anymore */
-static int match_no_append(struct nf_conn * conntrack, 
-                           struct nf_conn * master_conntrack, 
-                           enum ip_conntrack_info ctinfo,
-                           enum ip_conntrack_info master_ctinfo,
-                           const struct xt_layer7_info * info)
-{
-	/* If we're in here, throw the app data away */
-	if(master_conntrack->layer7.app_data != NULL) {
-
-	#ifdef CONFIG_IP_NF_MATCH_LAYER7_DEBUG
-		if(!master_conntrack->layer7.app_proto) {
-			char * f = 
-			  friendly_print(master_conntrack->layer7.app_data);
-			char * g = 
-			  hex_print(master_conntrack->layer7.app_data);
-			DPRINTK("\nl7-filter gave up after %d bytes "
-				"(%d packets):\n%s\n",
-				strlen(f), total_acct_packets(master_conntrack), f);
-			kfree(f);
-			DPRINTK("In hex: %s\n", g);
-			kfree(g);
-		}
-	#endif
-
-		kfree(master_conntrack->layer7.app_data);
-		master_conntrack->layer7.app_data = NULL; /* don't free again */
-	}
-
-	if(master_conntrack->layer7.app_proto){
-		/* Here child connections set their .app_proto (for /proc) */
-		if(!conntrack->layer7.app_proto) {
-			conntrack->layer7.app_proto = 
-			  kmalloc(strlen(master_conntrack->layer7.app_proto)+1, 
-			    GFP_ATOMIC);
-			if(!conntrack->layer7.app_proto){
-				if (net_ratelimit())
-					printk(KERN_ERR "layer7: out of memory "
-							"in match_no_append, "
-							"bailing.\n");
-				return 1;
-			}
-			strcpy(conntrack->layer7.app_proto, 
-				master_conntrack->layer7.app_proto);
-		}
-
-		return (!strcmp(master_conntrack->layer7.app_proto, 
-				info->protocol));
-	}
-	else {
-		/* If not classified, set to "unknown" to distinguish from
-		connections that are still being tested. */
-		master_conntrack->layer7.app_proto = 
-			kmalloc(strlen("unknown")+1, GFP_ATOMIC);
-		if(!master_conntrack->layer7.app_proto){
-			if (net_ratelimit())
-				printk(KERN_ERR "layer7: out of memory in "
-						"match_no_append, bailing.\n");
-			return 1;
-		}
-		strcpy(master_conntrack->layer7.app_proto, "unknown");
-		return 0;
-	}
-}
-
-/* add the new app data to the conntrack.  Return number of bytes added. */
-static int add_datastr(char *target, int offset, char *app_data, int len)
-{
-	int length = 0, i;
-	if (!target) return 0;
-
-	/* Strip nulls. Make everything lower case (our regex lib doesn't
-	do case insensitivity).  Add it to the end of the current data. */
- 	for(i = 0; i < maxdatalen-offset-1 && i < len; i++) {
-		if(app_data[i] != '\0') {
-			/* the kernel version of tolower mungs 'upper ascii' */
-			target[length+offset] =
-				isascii(app_data[i])? 
-					tolower(app_data[i]) : app_data[i];
-			length++;
-		}
-	}
-	target[length+offset] = '\0';
-
-	return length;
-}
-
-/* add the new app data to the conntrack.  Return number of bytes added. */
-static int add_data(struct nf_conn * master_conntrack,
-                    char * app_data, int appdatalen)
-{
-	int length;
-
-	length = add_datastr(master_conntrack->layer7.app_data, master_conntrack->layer7.app_data_len, app_data, appdatalen);
-	master_conntrack->layer7.app_data_len += length;
-
-	return length;
-}
-
-/* taken from drivers/video/modedb.c */
-static int my_atoi(const char *s)
-{
-	int val = 0;
-
-	for (;; s++) {
-		switch (*s) {
-			case '0'...'9':
-			val = 10*val+(*s-'0');
-			break;
-		default:
-			return val;
-		}
-	}
-}
-
-/* write out num_packets to userland. */
-static int layer7_read_proc(char* page, char ** start, off_t off, int count,
-                            int* eof, void * data)
-{
-	if(num_packets > 99 && net_ratelimit())
-		printk(KERN_ERR "layer7: NOT REACHED. num_packets too big\n");
-
-	page[0] = num_packets/10 + '0';
-	page[1] = num_packets%10 + '0';
-	page[2] = '\n';
-	page[3] = '\0';
-
-	*eof=1;
-
-	return 3;
-}
-
-/* Read in num_packets from userland */
-static int layer7_write_proc(struct file* file, const char* buffer,
-                             unsigned long count, void *data)
-{
-	char * foo = kmalloc(count, GFP_ATOMIC);
-
-	if(!foo){
-		if (net_ratelimit())
-			printk(KERN_ERR "layer7: out of memory, bailing. "
-					"num_packets unchanged.\n");
-		return count;
-	}
-
-	if(copy_from_user(foo, buffer, count)) {
-		return -EFAULT;
-	}
-
-
-	num_packets = my_atoi(foo);
-	kfree (foo);
-
-	/* This has an arbitrary limit to make the math easier. I'm lazy.
-	But anyway, 99 is a LOT! If you want more, you're doing it wrong! */
-	if(num_packets > 99) {
-		printk(KERN_WARNING "layer7: num_packets can't be > 99.\n");
-		num_packets = 99;
-	} else if(num_packets < 1) {
-		printk(KERN_WARNING "layer7: num_packets can't be < 1.\n");
-		num_packets = 1;
-	}
-
-	return count;
-}
-
-static bool
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-match(const struct sk_buff *skbin, struct xt_action_param *par)
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
-match(const struct sk_buff *skbin, const struct xt_match_param *par)
-#else
-match(const struct sk_buff *skbin,
-      const struct net_device *in,
-      const struct net_device *out,
-      const struct xt_match *match,
-      const void *matchinfo,
-      int offset,
-      unsigned int protoff,
-      bool *hotdrop)
-#endif
-{
-	/* sidestep const without getting a compiler warning... */
-	struct sk_buff * skb = (struct sk_buff *)skbin; 
-
-	const struct xt_layer7_info * info = 
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
-		par->matchinfo;
-	#else
-		matchinfo;
-	#endif
-
-	enum ip_conntrack_info master_ctinfo, ctinfo;
-	struct nf_conn *master_conntrack, *conntrack;
-	unsigned char *app_data, *tmp_data;
-	unsigned int pattern_result, appdatalen;
-	regexp * comppattern;
-
-	/* Be paranoid/incompetent - lock the entire match function. */
-	spin_lock_bh(&l7_lock);
-
-	if(!can_handle(skb)){
-		DPRINTK("layer7: This is some protocol I can't handle.\n");
-		spin_unlock_bh(&l7_lock);
-		return info->invert;
-	}
-
-	/* Treat parent & all its children together as one connection, except
-	for the purpose of setting conntrack->layer7.app_proto in the actual
-	connection. This makes /proc/net/ip_conntrack more satisfying. */
-	if(!(conntrack = nf_ct_get(skb, &ctinfo)) ||
-	   !(master_conntrack=nf_ct_get(skb,&master_ctinfo))){
-		DPRINTK("layer7: couldn't get conntrack.\n");
-		spin_unlock_bh(&l7_lock);
-		return info->invert;
-	}
-
-	/* Try to get a master conntrack (and its master etc) for FTP, etc. */
-	while (master_ct(master_conntrack) != NULL)
-		master_conntrack = master_ct(master_conntrack);
-
-	/* if we've classified it or seen too many packets */
-	if(!info->pkt && (total_acct_packets(master_conntrack) > num_packets ||
-	   master_conntrack->layer7.app_proto)) {
-
-		pattern_result = match_no_append(conntrack, master_conntrack, 
-						 ctinfo, master_ctinfo, info);
-
-		/* skb->cb[0] == seen. Don't do things twice if there are 
-		multiple l7 rules. I'm not sure that using cb for this purpose 
-		is correct, even though it says "put your private variables 
-		there". But it doesn't look like it is being used for anything
-		else in the skbs that make it here. */
-		skb->cb[0] = 1; /* marking it seen here's probably irrelevant */
-
-		spin_unlock_bh(&l7_lock);
-		return (pattern_result ^ info->invert);
-	}
-
-	if(skb_is_nonlinear(skb)){
-		if(skb_linearize(skb) != 0){
-			if (net_ratelimit())
-				printk(KERN_ERR "layer7: failed to linearize "
-						"packet, bailing.\n");
-			spin_unlock_bh(&l7_lock);
-			return info->invert;
-		}
-	}
-
-	/* now that the skb is linearized, it's safe to set these. */
-	app_data = skb->data + app_data_offset(skb);
-	appdatalen = skb_tail_pointer(skb) - app_data;
-
-	/* the return value gets checked later, when we're ready to use it */
-	comppattern = compile_and_cache(info->pattern, info->protocol);
-
-	if (info->pkt) {
-		tmp_data = kmalloc(maxdatalen, GFP_ATOMIC);
-		if(!tmp_data){
-			if (net_ratelimit())
-				printk(KERN_ERR "layer7: out of memory in match, bailing.\n");
-			return info->invert;
-		}
-
-		tmp_data[0] = '\0';
-		add_datastr(tmp_data, 0, app_data, appdatalen);
-		pattern_result = ((comppattern && regexec(comppattern, tmp_data)) ? 1 : 0);
-
-		kfree(tmp_data);
-		tmp_data = NULL;
-		spin_unlock_bh(&l7_lock);
-
-		return (pattern_result ^ info->invert);
-	}
-
-	/* On the first packet of a connection, allocate space for app data */
-	if(total_acct_packets(master_conntrack) == 1 && !skb->cb[0] && 
-	   !master_conntrack->layer7.app_data){
-		master_conntrack->layer7.app_data = 
-			kmalloc(maxdatalen, GFP_ATOMIC);
-		if(!master_conntrack->layer7.app_data){
-			if (net_ratelimit())
-				printk(KERN_ERR "layer7: out of memory in "
-						"match, bailing.\n");
-			spin_unlock_bh(&l7_lock);
-			return info->invert;
-		}
-
-		master_conntrack->layer7.app_data[0] = '\0';
-	}
-
-	/* Can be here, but unallocated, if numpackets is increased near
-	the beginning of a connection */
-	if(master_conntrack->layer7.app_data == NULL){
-		spin_unlock_bh(&l7_lock);
-		return info->invert; /* unmatched */
-	}
-
-	if(!skb->cb[0]){
-		int newbytes;
-		newbytes = add_data(master_conntrack, app_data, appdatalen);
-
-		if(newbytes == 0) { /* didn't add any data */
-			skb->cb[0] = 1;
-			/* Didn't match before, not going to match now */
-			spin_unlock_bh(&l7_lock);
-			return info->invert;
-		}
-	}
-
-	/* If looking for "unknown", then never match.  "Unknown" means that
-	we've given up; we're still trying with these packets. */
-	if(!strcmp(info->protocol, "unknown")) {
-		pattern_result = 0;
-	/* If looking for "unset", then always match. "Unset" means that we
-	haven't yet classified the connection. */
-	} else if(!strcmp(info->protocol, "unset")) {
-		pattern_result = 2;
-		DPRINTK("layer7: matched unset: not yet classified "
-			"(%d/%d packets)\n",
-                        total_acct_packets(master_conntrack), num_packets);
-	/* If the regexp failed to compile, don't bother running it */
-	} else if(comppattern && 
-		  regexec(comppattern, master_conntrack->layer7.app_data)){
-		DPRINTK("layer7: matched %s\n", info->protocol);
-		pattern_result = 1;
-	} else pattern_result = 0;
-
-	if(pattern_result == 1) {
-		master_conntrack->layer7.app_proto = 
-			kmalloc(strlen(info->protocol)+1, GFP_ATOMIC);
-		if(!master_conntrack->layer7.app_proto){
-			if (net_ratelimit())
-				printk(KERN_ERR "layer7: out of memory in "
-						"match, bailing.\n");
-			spin_unlock_bh(&l7_lock);
-			return (pattern_result ^ info->invert);
-		}
-		strcpy(master_conntrack->layer7.app_proto, info->protocol);
-	} else if(pattern_result > 1) { /* cleanup from "unset" */
-		pattern_result = 1;
-	}
-
-	/* mark the packet seen */
-	skb->cb[0] = 1;
-
-	spin_unlock_bh(&l7_lock);
-	return (pattern_result ^ info->invert);
-}
-
-// load nf_conntrack_ipv4
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-static int
-#else
-static bool
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
-check(const struct xt_mtchk_param *par)
-{
-        if (nf_ct_l3proto_try_module_get(par->match->family) < 0) {
-                printk(KERN_WARNING "can't load conntrack support for "
-                                    "proto=%d\n", par->match->family);
-#else
-check(const char *tablename, const void *inf,
-		 const struct xt_match *match, void *matchinfo,
-		 unsigned int hook_mask)
-{
-        if (nf_ct_l3proto_try_module_get(match->family) < 0) {
-                printk(KERN_WARNING "can't load conntrack support for "
-                                    "proto=%d\n", match->family);
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-		return -EINVAL;
-	}
-	return 0;
-#else
-                return 0;
-        }
-	return 1;
-#endif
-}
-
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
-	static void destroy(const struct xt_mtdtor_param *par)
-	{
-		nf_ct_l3proto_module_put(par->match->family);
-	}
-#else
-	static void destroy(const struct xt_match *match, void *matchinfo)
-	{
-		nf_ct_l3proto_module_put(match->family);
-	}
-#endif
-
-static struct xt_match xt_layer7_match[] __read_mostly = {
-{
-	.name		= "layer7",
-	.family		= AF_INET,
-	.checkentry	= check,
-	.match		= match,
-	.destroy	= destroy,
-	.matchsize	= sizeof(struct xt_layer7_info),
-	.me		= THIS_MODULE
-}
-};
-
-static void layer7_cleanup_proc(void)
-{
-	remove_proc_entry("layer7_numpackets", init_net.proc_net);
-}
-
-/* register the proc file */
-static void layer7_init_proc(void)
-{
-	struct proc_dir_entry* entry;
-	entry = create_proc_entry("layer7_numpackets", 0644, init_net.proc_net);
-	entry->read_proc = layer7_read_proc;
-	entry->write_proc = layer7_write_proc;
-}
-
-static int __init xt_layer7_init(void)
-{
-	need_conntrack();
-
-	layer7_init_proc();
-	if(maxdatalen < 1) {
-		printk(KERN_WARNING "layer7: maxdatalen can't be < 1, "
-			"using 1\n");
-		maxdatalen = 1;
-	}
-	/* This is not a hard limit.  It's just here to prevent people from
-	bringing their slow machines to a grinding halt. */
-	else if(maxdatalen > 65536) {
-		printk(KERN_WARNING "layer7: maxdatalen can't be > 65536, "
-			"using 65536\n");
-		maxdatalen = 65536;
-	}
-	return xt_register_matches(xt_layer7_match,
-				   ARRAY_SIZE(xt_layer7_match));
-}
-
-static void __exit xt_layer7_fini(void)
-{
-	layer7_cleanup_proc();
-	xt_unregister_matches(xt_layer7_match, ARRAY_SIZE(xt_layer7_match));
-}
-
-module_init(xt_layer7_init);
-module_exit(xt_layer7_fini);
