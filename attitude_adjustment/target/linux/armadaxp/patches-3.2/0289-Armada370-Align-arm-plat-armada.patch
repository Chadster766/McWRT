From 030198e6ed353e111a0d86d7448c4ac5be0ebffe Mon Sep 17 00:00:00 2001
From: Piotr Nowak <pn@semihalf.com>
Date: Tue, 4 Sep 2012 10:01:16 +0200
Subject: [PATCH 289/609] Armada370: Align arm/plat-armada.

Applied changes based on diff between Armada-370 and Armada-XP on
Linux 3.0.6 baseline.

Signed-off-by: Piotr Nowak <pn@semihalf.com>
Signed-off-by: Seif Mazareeb <seif@marvell.com>
---
 arch/arm/plat-armada/Kconfig                       |   48 +-
 arch/arm/plat-armada/Makefile                      |   15 +-
 arch/arm/plat-armada/armada_suspend.S              |  370 ++++++++
 arch/arm/plat-armada/armadaxp_suspend.S            |  370 --------
 arch/arm/plat-armada/common/mvDeviceId.h           |   26 +
 arch/arm/plat-armada/include/plat/audio.h          |   11 +
 .../plat-armada/mv_drivers_lsp/mv_audio/Makefile   |    8 +-
 .../mv_drivers_lsp/mv_audio_soc/Makefile           |    8 +-
 .../plat-armada/mv_drivers_lsp/mv_btns/Makefile    |    8 +-
 .../plat-armada/mv_drivers_lsp/mv_cesa/Makefile    |    5 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_dma/Makefile |    8 +-
 .../plat-armada/mv_drivers_lsp/mv_gpio/Makefile    |    8 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile |    5 +-
 .../plat-armada/mv_drivers_lsp/mv_ipc_net/Makefile |    5 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_mtd/Makefile |    9 +-
 .../plat-armada/mv_drivers_lsp/mv_mtd/nand_nfc.c   |    3 +-
 .../mv_drivers_lsp/mv_neta/net_dev/Makefile        |   12 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     |    2 +
 .../mv_drivers_lsp/mv_network/mv_ethernet/Makefile |    8 +-
 .../plat-armada/mv_drivers_lsp/mv_phone/Makefile   |    9 +-
 .../mv_drivers_lsp/mv_phone/test/Makefile          |    7 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_pon/Makefile |    5 +-
 .../plat-armada/mv_drivers_lsp/mv_sata/Makefile    |    8 +-
 .../plat-armada/mv_drivers_lsp/mv_sdio/Makefile    |    8 +-
 .../plat-armada/mv_drivers_lsp/mv_switch/Makefile  |    8 +-
 .../plat-armada/mv_drivers_lsp/mv_trace/Makefile   |    8 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_tsu/Makefile |    4 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile |    8 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_xor/Makefile |    8 +-
 .../plat-armada/mv_hal/audio/dac/mvCLAudioCodec.c  |  484 ++++++++++
 .../plat-armada/mv_hal/audio/dac/mvCLAudioCodec.h  |  135 +++
 .../mv_hal/audio/dac/mvCLAudioCodecRegs.h          |   85 ++
 .../plat-armada/mv_hal/audio/dac/mvSysAudioDac.h   |  118 +++
 arch/arm/plat-armada/mv_hal/audio/mvAudio.c        |  944 ++++++++++++++++++++
 arch/arm/plat-armada/mv_hal/audio/mvAudio.h        |  398 +++++++++
 arch/arm/plat-armada/mv_hal/audio/mvAudioAddrDec.c |  251 ++++++
 arch/arm/plat-armada/mv_hal/audio/mvAudioRegs.h    |  356 ++++++++
 arch/arm/plat-armada/mv_hal/audio/mvCompVer.txt    |    3 +
 arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c        |    9 +-
 arch/arm/plat-armada/mv_hal/cntmr/mvCntmrRegs.h    |    6 +
 arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c     |    1 -
 arch/arm/plat-armada/mv_hal/twsi/mvSysTwsi.h       |  119 +++
 arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c          |    1 +
 arch/arm/plat-armada/mv_hal/xor/mvXorAddrDec.c     |   16 +-
 44 files changed, 3409 insertions(+), 519 deletions(-)
 create mode 100644 arch/arm/plat-armada/armada_suspend.S
 delete mode 100644 arch/arm/plat-armada/armadaxp_suspend.S
 mode change 100755 => 100644 arch/arm/plat-armada/cpuidle.c
 create mode 100644 arch/arm/plat-armada/include/plat/audio.h
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/dac/mvCLAudioCodec.c
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/dac/mvCLAudioCodec.h
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/dac/mvCLAudioCodecRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/dac/mvSysAudioDac.h
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/mvAudio.c
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/mvAudio.h
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/mvAudioAddrDec.c
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/mvAudioRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/audio/mvCompVer.txt
 create mode 100644 arch/arm/plat-armada/mv_hal/twsi/mvSysTwsi.h

--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -21,6 +21,9 @@ menu "Armada SoC options"
 #source "arch/arm/mach-feroceon-mv78xx0/Kconfig"
 #endif
 
+#if ARCH_ARMADA370
+#source "arch/arm/mach-armada370/Kconfig"
+#endif
 
 config JTAG_DEBUG
         bool "Enable JTAG by disable \"wait for interrupt\"."
@@ -32,6 +35,7 @@ config JTAG_DEBUG
 
 menu "Armada SoC Included Features"
 
+if ARMADA_XP
 config MV_INCLUDE_PEX
 	bool "PCI Express Support"
 	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP)
@@ -72,71 +76,81 @@ config MV_PEX_2_1X4
 config MV_PEX_3_1X4
 	bool "PEX-3 in 1x4 Mode"
 	depends on MV_INCLUDE_PEX
+endif
+
+if ARMADA_370
+config MV_INCLUDE_PEX
+	bool "PCI Express Support"
+    depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_370)
+    default y
+        ---help---
+        Please don't change this configs unless you know what you are doing.
+endif
 
 config MV_INCLUDE_PCI
 	bool "PCI Support"
-	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP)
+	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370)
 	default n
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_USB
 	bool "USB Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_XOR
 	bool "XOR Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_CESA
 	bool "CESA Support"
-	depends on MV88F6500 || MV88F6082 || MV88F6183 || MV88F6281 || MV78XX0 || ARMADA_XP
+	depends on MV88F6500 || MV88F6082 || MV88F6183 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_NFC
 	bool "Nand Flash Controller Support"
-	depends on MV88F6500 || ARMADA_XP
+	depends on MV88F6500 || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_LEGACY_NAND
 	bool "Legacy NAND Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_INTEG_SATA
 	bool "Integrated SATA Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_TDM
 	bool "Integrated TDM Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_GIG_ETH
 	bool "Giga Ethernet Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
 	default y
 
 config MV_INCLUDE_SPI
 	bool "SPI Support"
-	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
@@ -151,7 +165,7 @@ config MV_INCLUDE_NOR
 
 config MV_INCLUDE_SDIO
 	bool "SDIO Support"
-	depends on MV88F6500 || MV88F6281 || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || ARMADA_XP || ARMADA_370
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
@@ -172,7 +186,7 @@ config MV_INCLUDE_PON
 
 config MV_INCLUDE_SWITCH
         bool "Ethernet Switch Support"
-        depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP
+        depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
         default y
 
 endmenu
@@ -250,16 +264,16 @@ config MV_GPP_MAX_PINS
 	default 64 if MV88F6281
 	default 70 if MV88F6500
 	default 67 if ARMADA_XP
-
+	default 67 if ARMADA_370
 	
 config MV_DCACHE_SIZE
 	hex
-	default 0x8000 if MV78XX0 || ARMADA_XP
+	default 0x8000 if MV78XX0 || ARMADA_XP || ARMADA_370
 	default 0x4000 if MV88F6500 || MV88F6281
 
 config MV_ICACHE_SIZE
 	hex
-	default 0x8000 if MV78XX0 || ARMDAD_XP
+	default 0x8000 if MV78XX0 || ARMDAD_XP || ARMADA_370
 	default 0x4000 if MV88F6500 || MV88F6281
 	          
 menu "Armada SoC MTD support"
@@ -282,7 +296,7 @@ config MV_SPI_BOOT
 	Choose this option if SPI MTD is the system boot device.
 	This option controls the various flash types support in the board
 	device chip-select information structure under mvBoardEnvSpec.c
-                    
+
 config MV_INCLUDE_MFLASH_MTD
     bool "Marvell support for MTD Marvell flash device"
     select MV_FLASH_CTRL
@@ -482,7 +496,7 @@ config MV_ETH_LEGACY
 
 config MV_ETH_NETA
         bool "Acceleration mode "
-	depends on ARCH_FEROCEON_KW2 || ARCH_ARMADA_XP
+	depends on ARCH_FEROCEON_KW2 || ARCH_ARMADA_XP || ARCH_ARMADA370
         ---help---
 
 endchoice
--- a/arch/arm/plat-armada/Makefile
+++ b/arch/arm/plat-armada/Makefile
@@ -1,17 +1,12 @@
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 # This will never compile, because DUMMY will never by defined.
 obj-$(DUMMY)   				:= dummy.o
-
 obj-$(CONFIG_SHEEVA_DEEP_IDLE)		+= cpuidle.o armadaxp_suspend.o suspend.o
-obj-$(CONFIG_HOTPLUG_CPU)               += hotplug.o
-obj-$(CONFIG_ARCH_ARMADA_XP)		+= pmu.o
+obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
+obj-$(CONFIG_PLAT_ARMADA)		+= pmu.o
 obj-$(CONFIG_PCI_MSI)			+= msi.o
 obj-$(CONFIG_ERROR_HANDLING)		+=error_handling.o
-obj-$(CONFIG_CPU_FREQ_ARMADA_XP)	+= cpufreq.o
\ No newline at end of file
+obj-$(CONFIG_CPU_FREQ_ARMADA_XP)	+= cpufreq.o
--- /dev/null
+++ b/arch/arm/plat-armada/armada_suspend.S
@@ -0,0 +1,370 @@
+/*
+ * arch/arm/plat-armada/armadaxp_suspend.S
+ *
+ * CPU idle low level implementation for Marvell ARMADA-XP SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/hardware.h>
+
+#define GPIO_64_66_VALUE_REG			(INTER_REGS_BASE + 0x18180)
+#define GPIO_64_66_CTRL_REG			(INTER_REGS_BASE + 0x18184)
+#define MPP_CTRL_64_66_REG			(INTER_REGS_BASE + 0x18020)
+
+ENTRY(armadaxp_powerdown)
+	/* Save ARM registers */
+	stmfd	sp!, {r4-r12, lr}		@ save registers on stack
+
+	/*
+	* Save the CP15 context
+	*/
+	mrc     p15, 0, r2, c1, c0, 0           @ save CP15 - CR
+	mrc     p15, 0, r3, c3, c0, 0           @ save CP15 - DACR
+	mrc     p15, 0, r4, c13, c0, 0          @ save CP15 - FCSE
+	mrc     p15, 0, r5, c2, c0, 0           @ save CP15 - TTBR0
+	mrc     p15, 0, r6, c13, c0, 1          @ save CP15 - context ID
+	mrc     p15, 1, r7, c15, c1, 0          @ save CP15 - extra features
+	mrc     p15, 0, r8, c1, c0, 1           @ save CP15 - Aux CR
+	mov     r9, r13                         @ save resume SP
+	stmfd   sp!, {r2-r9}
+
+	mrc     p15, 0, r2, c2, c0, 1   @ save CP15 - TTBR1
+	mrc	p15, 1, r3, c15, c2, 0	@ save CP15 - Aux Func Modes Ctrl 0
+	mrc	p15, 1, r4, c15, c1, 2	@ save CP15 - Aux Debug Modes Ctrl 2
+	mrc     p15, 1, r5, c15, c1, 1  @ save CP15 - Aux Debug Modes Ctrl 1
+	mrc     p15, 0, r6, c9, c14, 0  @ save CP15 - PMC
+	mrc     p15, 0, r7, c10, c2, 0  @ save CP15 - PRRR
+	mrc     p15, 0, r8, c10, c2, 1  @ save CP15 - NMRR
+	stmfd   sp!, {r2-r8}
+
+	/*
+	* Save the physical address of the resume SP
+	*/
+	mov     r0, sp
+	bl      suspend_phys_addr
+	ldr     r1, =suspend_saved_sp
+#ifdef CONFIG_SMP
+	mrc     p15, 0, r2, c0, c0, 5
+	and     r2, r2, #15
+	str     r0, [r1, r2, lsl #2]
+#else
+	str     r0, [r1]
+#endif
+
+	/*
+	* Flush L1 DCache
+	*/
+	bl v7_flush_kern_cache_all
+
+	/*
+	* Issue a Data Synchronization Barrier instruction to ensure that all
+	* state saving has been	completed.
+	*/
+	dsb
+
+	/* Flush the DLB and wait ~7 usec*/
+	ldr r2, =SDRAM_DLB_EVICT_REG
+	ldr	r0, [r2]
+	bic     r0, #0x000000FF
+	str     r0, [r2]
+
+	ldr r1, = 6000  /* WC freq =  1.6 Ghz, 2 cycles per loop */
+1:	subs r1,r1,#1
+	bne 1b
+
+	/* Set DDR in battery backup mode
+	 * It will exit self-refresh only on reset */
+	ldr 	r2, =SDRAM_CONFIG_REG
+	ldr	r0, [r2]
+	bic     r0, #0x01000000
+	str     r0, [r2]
+
+	/* Prepare register for DDR Self refresh */
+	ldr	r2, =(SDRAM_OPERATION_REG - INTER_REGS_BASE)
+	ldr	r0, =INTER_REGS_BASE
+	orr	r2, r2, r0
+	ldr	r0, [r2]
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	ldr	r3, =0x07000000
+#else
+	ldr	r3, =0x00000007
+#endif
+	orr	r0, r0, r3
+
+	/*
+	 * Write 0x1 then 0x7 through MPP 64-67 to PIC that controls power
+	 * 0x1 - Power off all voltages;  0x7 - Acknowledge command
+	 */
+	ldr r3, =(MPP_CTRL_64_66_REG)
+	ldr r4, =0x2000
+	str r4, [r3]
+
+	ldr r3, =(GPIO_64_66_VALUE_REG)
+	ldr r4, =(GPIO_64_66_CTRL_REG)
+
+	ldr r5, =0x1
+	ldr r6, =0x0
+
+	str r5, [r3]
+	str r6, [r4]
+
+	ldr r1, =200000000
+	ldr r5, =0x7
+
+	/*
+	 * Wait between cmd (0x1) and cmd ack (0x7)
+	 * TODO - Need to reduce this delay
+	 */
+1:	subs r1,r1,#1
+	bne 1b
+
+	/*
+	 * Put Dram into self refresh. From here on we can perform
+	 * 8 instructions to ensure executiion from I-Cache
+	 */
+	.align 5
+	str	r0, [r2]
+
+	/* Wait 100 cycles for DDR to enter self refresh */
+	ldr r1, = 50
+1:	subs r1,r1,#1
+	bne 1b
+
+	/* Issue the cmd ack. This will turn of the board */
+	str r5, [r3]
+
+	/* trap the processor */
+	b .
+
+ENDPROC(armadaxp_powerdown)
+
+/*
+* armadaxp_cpu_suspend: enter cpu deepIdle state
+* input:
+*/
+ENTRY(armadaxp_cpu_suspend)
+/* Save ARM registers */
+	stmfd	sp!, {r4-r12, lr}				@ save registers on stack
+
+/*
+* Save the CP15 context
+*/
+	mrc     p15, 0, r2, c1, c0, 0			@ save CP15 - CR
+	mrc     p15, 0, r3, c3, c0, 0			@ save CP15 - DACR
+	mrc     p15, 0, r4, c13, c0, 0			@ save CP15 - FCSE
+        mrc     p15, 0, r5, c2, c0, 0           @ save CP15 - TTBR0
+	mrc     p15, 0, r6, c13, c0, 1			@ save CP15 - context ID
+	mrc     p15, 1, r7, c15, c1, 0			@ save CP15 - extra features
+	mrc     p15, 0, r8, c1, c0, 1			@ save CP15 - Aux CR
+	mov     r9, r13							@ save resume SP
+	stmfd   sp!, {r2-r9}
+	mrc     p15, 0, r2, c2, c0, 1           @ save CP15 - TTBR1
+	mrc	p15, 1, r3, c15, c2, 0				@ save CP15 - Aux Func Modes Ctrl 0
+	mrc	p15, 1, r4, c15, c1, 2				@ save CP15 - Aux Debug Modes Ctrl 2
+	mrc     p15, 1, r5, c15, c1, 1			@ save CP15 - Aux Debug Modes Ctrl 1
+	mrc     p15, 0, r6, c9, c14, 0			@ save CP15 - PMC
+	mrc     p15, 0, r7, c10, c2, 0			@ save CP15 - PRRR
+	mrc     p15, 0, r8, c10, c2, 1			@ save CP15 - NMRR
+	
+        stmfd   sp!, {r2-r8}
+
+/*
+* TODO: Save Debug Registers
+*/
+
+/*
+* Save the physical address of the resume SP
+*/
+        mov     r0, sp
+        bl      suspend_phys_addr
+        ldr     r1, =suspend_saved_sp
+#ifdef CONFIG_SMP
+        mrc     p15, 0, r2, c0, c0, 5
+        and     r2, r2, #15
+        str     r0, [r1, r2, lsl #2]
+#else
+        str     r0, [r1]
+#endif
+
+/*
+* Flush L1 DCache
+*/
+
+#ifdef CONFIG_CPU_V6
+	bl v6_flush_kern_cache_all
+#elif CONFIG_CPU_V7
+	bl v7_flush_kern_cache_all
+#else
+#error "CPU Arch version not defined!\n"
+#endif
+
+/* Prepare Deep Idle Function - Set PMU Configurations*/
+	bl armadaxp_fabric_prepare_deepIdle
+
+/*
+* Issue a Data Synchronization Barrier instruction to ensure that all
+* state saving has been	completed.
+*/
+#ifdef CONFIG_CPU_V6
+	mcr     p15, 0, r0, c7, c10, 4	@ Data Synchronization Barrier
+#elif defined (CONFIG_CPU_V7)
+	dsb				@ Data Synchronization Barrier
+#endif
+
+/* Lock Semaphore */
+	mrc	15, 0, r1, cr0, cr0, 5
+	and	r1, r1, #15
+	ldr	r4, =0xFBB20500
+1:
+	ldr	r2, [r4]
+	and	r2, r2, #0xF
+	cmp	r1, r2
+	bne	1b
+
+/* Disable SnoopEna */
+	mrc	15, 0, r1, cr0, cr0, 5
+	and	r1, r1, #15
+	mov	r6, #1
+	add	r7, r1, #24
+	ldr	r2, =0xFBB20200
+	ldr	r3, [r2]
+	bic	r3, r3, r6, lsl r7
+	str	r3, [r2]
+
+/* Release Semaphore */
+	ldr	r2, =0xFBB20500
+	ldr 	r0, =0xff
+	strb	r0, [r2]
+
+dowfi:
+/* WFI */
+#ifdef CONFIG_CPU_V6
+	mcr     p15, 0, r1, c7, c0, 4	@ wait for interrupt
+#elif defined (CONFIG_CPU_V7)
+	wfi				@ wait for interrupt
+#endif
+
+	/* After disabling the SnoopEna by SW regret is not allowed!! */
+	b dowfi
+
+#if 0
+	/* if we reach this point then deepIdle returned from regret mode and cpu
+	* state retained
+	*/
+	mov	r0, #1
+	ldmfd   sp!, {r3-r8}
+	ldmfd   sp!, {r2-r9}
+	
+	ldmfd   sp!, {r4-r12, pc}
+#endif
+ENDPROC(armadaxp_cpu_suspend)
+
+/*
+* armadaxp_cpu_resume: resume from cpu deepIdle state
+* input:
+*/
+ENTRY(armadaxp_cpu_resume)
+
+#ifdef CONFIG_CPU_ENDIAN_BE32
+	/* convert CPU to big endian */
+	.word 0x100f11ee /* mrc p15, 0, r0, c1, c0 */
+	.word 0x800080e3 /* orr r0, r0, #0x80 */
+	.word 0x100f01ee /* mcr p15, 0, r0, c1, c0 */
+#endif
+#ifdef CONFIG_CPU_ENDIAN_BE8
+	setend  be
+#endif
+
+/* Lock Semaphore */
+	mrc	15, 0, r1, cr0, cr0, 5
+	and	r1, r1, #15
+	ldr	r4, =0xD0020500
+1:
+	ldr	r2, [r4]
+	and	r2, r2, #0xF
+	cmp	r1, r2
+	bne	1b
+
+/* Enable SnoopEna */
+	mrc	15, 0, r1, cr0, cr0, 5
+	and	r1, r1, #15
+	mov	r6, #1
+	add	r7, r1, #24
+	ldr	r2, =0xD0020200
+	ldr	r3, [r2]
+	orr	r3, r3, r6, lsl r7
+	str	r3, [r2]
+
+/* Release Semaphore */
+	ldr	r2, =0xD0020500
+	ldr 	r0, =0xff
+	strb	r0, [r2]
+
+#ifdef CONFIG_SMP
+	adr     r0, suspend_saved_sp
+	mrc     p15, 0, r1, c0, c0, 5
+	and     r1, r1, #15
+	ldr     r0, [r0, r1, lsl #2]    @ stack phys addr
+#else
+	ldr     r0, suspend_saved_sp            @ stack phys addr
+#endif
+
+	ldmfd   r0!, {r2-r8}
+	mcr     p15, 0, r2, c2, c0, 1           @ restore CP15 - TTBR1
+	mcr     p15, 1, r3, c15, c2, 0          @ restore CP15 - Aux Func Modes Ctrl 0
+	mcr     p15, 1, r4, c15, c1, 2          @ restore CP15 - Aux Debug Modes Ctrl 2
+	mcr     p15, 1, r5, c15, c1, 1          @ restore CP15 - Aux Debug Modes Ctrl 1
+	mcr     p15, 0, r6, c9, c14, 0          @ restore CP15 - PMC
+	mcr     p15, 0, r7, c10, c2, 0          @ restore CP15 - PRRR
+	mcr     p15, 0, r8, c10, c2, 1          @ restore CP15 - NMRR
+	ldmfd   r0!, {r2-r9}
+	mcr	p15, 0, r8, c1, c0, 1		@ restore CP15 - Aux CR
+	mcr	p15, 1, r7, c15, c1, 0		@ restore CP15 - extra features
+	mcr	p15, 0, r4, c13, c0, 0		@ restore CP15 - FCSE
+	mcr	p15, 0, r3, c3, c0, 0		@ restore CP15 - DACR
+
+	/* load identity page table */
+	ldr	r3, identity_page_table_phys
+	mcr	p15, 0, r3, c2, c0, 0		@ set CP15 - TTBR
+	mov	r3, #0
+	mcr	p15, 0, r3, c13, c0, 1          @ set 0 in CP15 - context ID
+	mcr	p15, 0, r2, c1, c0, 0		@ restore CP15 - CR  @enable mmu
+	mrc     p15, 0, r3, c0, c0, 0           @ read id reg
+
+	ldr	r3, resume2
+	mov	pc, r3
+ENDPROC(armadaxp_cpu_resume)
+
+	/* stage 2 of the resume function that runs from PAGE_OFFSET virtual space */
+ENTRY(armadaxp_cpu_resume2)	
+	/* restore original page table*/
+
+	mcr	p15, 0, r5, c2, c0, 0		@ restore CP15 - TTBR
+	mcr	p15, 0, r6, c13, c0, 1          @ restore CP15 - context ID
+	mcr     p15, 0, r0, c8, c7, 0           @ TLB invalidate
+	mov	sp, r9				@ restore virtual sp
+	mov	r0, #0
+
+	ldmfd   sp!, {r4-r12, pc}               @ restore SVC registers
+
+ENDPROC(armadaxp_cpu_resume2)
+	
+resume2:
+	.long	armadaxp_cpu_resume2
+
+suspend_saved_sp:
+#ifdef CONFIG_SMP
+	.rept	CONFIG_NR_CPUS
+#endif
+	.long	0	@ physical SP saved here
+#ifdef CONFIG_SMP
+	.endr
+#endif
+	.global identity_page_table_phys
+identity_page_table_phys:
+	.long	0
--- a/arch/arm/plat-armada/armadaxp_suspend.S
+++ /dev/null
@@ -1,370 +0,0 @@
-/*
- * arch/arm/plat-armada/armadaxp_suspend.S
- *
- * CPU idle low level implementation for Marvell ARMADA-XP SoCs
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2.  This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- *
- */
-#include <linux/linkage.h>
-#include <asm/assembler.h>
-#include <mach/armadaxp.h>
-
-#define GPIO_64_66_VALUE_REG			(INTER_REGS_BASE + 0x18180)
-#define GPIO_64_66_CTRL_REG			(INTER_REGS_BASE + 0x18184)
-#define MPP_CTRL_64_66_REG			(INTER_REGS_BASE + 0x18020)
-
-ENTRY(armadaxp_powerdown)
-	/* Save ARM registers */
-	stmfd	sp!, {r4-r12, lr}		@ save registers on stack
-
-	/*
-	* Save the CP15 context
-	*/
-	mrc     p15, 0, r2, c1, c0, 0           @ save CP15 - CR
-	mrc     p15, 0, r3, c3, c0, 0           @ save CP15 - DACR
-	mrc     p15, 0, r4, c13, c0, 0          @ save CP15 - FCSE
-	mrc     p15, 0, r5, c2, c0, 0           @ save CP15 - TTBR0
-	mrc     p15, 0, r6, c13, c0, 1          @ save CP15 - context ID
-	mrc     p15, 1, r7, c15, c1, 0          @ save CP15 - extra features
-	mrc     p15, 0, r8, c1, c0, 1           @ save CP15 - Aux CR
-	mov     r9, r13                         @ save resume SP
-	stmfd   sp!, {r2-r9}
-
-	mrc     p15, 0, r2, c2, c0, 1   @ save CP15 - TTBR1
-	mrc	p15, 1, r3, c15, c2, 0	@ save CP15 - Aux Func Modes Ctrl 0
-	mrc	p15, 1, r4, c15, c1, 2	@ save CP15 - Aux Debug Modes Ctrl 2
-	mrc     p15, 1, r5, c15, c1, 1  @ save CP15 - Aux Debug Modes Ctrl 1
-	mrc     p15, 0, r6, c9, c14, 0  @ save CP15 - PMC
-	mrc     p15, 0, r7, c10, c2, 0  @ save CP15 - PRRR
-	mrc     p15, 0, r8, c10, c2, 1  @ save CP15 - NMRR
-	stmfd   sp!, {r2-r8}
-
-	/*
-	* Save the physical address of the resume SP
-	*/
-	mov     r0, sp
-	bl      suspend_phys_addr
-	ldr     r1, =suspend_saved_sp
-#ifdef CONFIG_SMP
-	mrc     p15, 0, r2, c0, c0, 5
-	and     r2, r2, #15
-	str     r0, [r1, r2, lsl #2]
-#else
-	str     r0, [r1]
-#endif
-
-	/*
-	* Flush L1 DCache
-	*/
-	bl v7_flush_kern_cache_all
-
-	/*
-	* Issue a Data Synchronization Barrier instruction to ensure that all
-	* state saving has been	completed.
-	*/
-	dsb
-
-	/* Flush the DLB and wait ~7 usec*/
-	ldr r2, =SDRAM_DLB_EVICT_REG
-	ldr	r0, [r2]
-	bic     r0, #0x000000FF
-	str     r0, [r2]
-
-	ldr r1, = 6000  /* WC freq =  1.6 Ghz, 2 cycles per loop */
-1:	subs r1,r1,#1
-	bne 1b
-
-	/* Set DDR in battery backup mode
-	 * It will exit self-refresh only on reset */
-	ldr 	r2, =SDRAM_CONFIG_REG
-	ldr	r0, [r2]
-	bic     r0, #0x01000000
-	str     r0, [r2]
-
-	/* Prepare register for DDR Self refresh */
-	ldr	r2, =(SDRAM_OPERATION_REG - INTER_REGS_BASE)
-	ldr	r0, =INTER_REGS_BASE
-	orr	r2, r2, r0
-	ldr	r0, [r2]
-#ifdef CONFIG_CPU_BIG_ENDIAN
-	ldr	r3, =0x07000000
-#else
-	ldr	r3, =0x00000007
-#endif
-	orr	r0, r0, r3
-
-	/*
-	 * Write 0x1 then 0x7 through MPP 64-67 to PIC that controls power
-	 * 0x1 - Power off all voltages;  0x7 - Acknowledge command
-	 */
-	ldr r3, =(MPP_CTRL_64_66_REG)
-	ldr r4, =0x2000
-	str r4, [r3]
-
-	ldr r3, =(GPIO_64_66_VALUE_REG)
-	ldr r4, =(GPIO_64_66_CTRL_REG)
-
-	ldr r5, =0x1
-	ldr r6, =0x0
-
-	str r5, [r3]
-	str r6, [r4]
-
-	ldr r1, =200000000
-	ldr r5, =0x7
-
-	/*
-	 * Wait between cmd (0x1) and cmd ack (0x7)
-	 * TODO - Need to reduce this delay
-	 */
-1:	subs r1,r1,#1
-	bne 1b
-
-	/*
-	 * Put Dram into self refresh. From here on we can perform
-	 * 8 instructions to ensure executiion from I-Cache
-	 */
-	.align 5
-	str	r0, [r2]
-
-	/* Wait 100 cycles for DDR to enter self refresh */
-	ldr r1, = 50
-1:	subs r1,r1,#1
-	bne 1b
-
-	/* Issue the cmd ack. This will turn of the board */
-	str r5, [r3]
-
-	/* trap the processor */
-	b .
-
-ENDPROC(armadaxp_powerdown)
-
-/*
-* armadaxp_cpu_suspend: enter cpu deepIdle state
-* input:
-*/
-ENTRY(armadaxp_cpu_suspend)
-/* Save ARM registers */
-	stmfd	sp!, {r4-r12, lr}				@ save registers on stack
-
-/*
-* Save the CP15 context
-*/
-	mrc     p15, 0, r2, c1, c0, 0			@ save CP15 - CR
-	mrc     p15, 0, r3, c3, c0, 0			@ save CP15 - DACR
-	mrc     p15, 0, r4, c13, c0, 0			@ save CP15 - FCSE
-        mrc     p15, 0, r5, c2, c0, 0           @ save CP15 - TTBR0
-	mrc     p15, 0, r6, c13, c0, 1			@ save CP15 - context ID
-	mrc     p15, 1, r7, c15, c1, 0			@ save CP15 - extra features
-	mrc     p15, 0, r8, c1, c0, 1			@ save CP15 - Aux CR
-	mov     r9, r13							@ save resume SP
-	stmfd   sp!, {r2-r9}
-	mrc     p15, 0, r2, c2, c0, 1           @ save CP15 - TTBR1
-	mrc	p15, 1, r3, c15, c2, 0				@ save CP15 - Aux Func Modes Ctrl 0
-	mrc	p15, 1, r4, c15, c1, 2				@ save CP15 - Aux Debug Modes Ctrl 2
-	mrc     p15, 1, r5, c15, c1, 1			@ save CP15 - Aux Debug Modes Ctrl 1
-	mrc     p15, 0, r6, c9, c14, 0			@ save CP15 - PMC
-	mrc     p15, 0, r7, c10, c2, 0			@ save CP15 - PRRR
-	mrc     p15, 0, r8, c10, c2, 1			@ save CP15 - NMRR
-	
-        stmfd   sp!, {r2-r8}
-
-/*
-* TODO: Save Debug Registers
-*/
-
-/*
-* Save the physical address of the resume SP
-*/
-        mov     r0, sp
-        bl      suspend_phys_addr
-        ldr     r1, =suspend_saved_sp
-#ifdef CONFIG_SMP
-        mrc     p15, 0, r2, c0, c0, 5
-        and     r2, r2, #15
-        str     r0, [r1, r2, lsl #2]
-#else
-        str     r0, [r1]
-#endif
-
-/*
-* Flush L1 DCache
-*/
-
-#ifdef CONFIG_CPU_V6
-	bl v6_flush_kern_cache_all
-#elif CONFIG_CPU_V7
-	bl v7_flush_kern_cache_all
-#else
-#error "CPU Arch version not defined!\n"
-#endif
-
-/* Prepare Deep Idle Function - Set PMU Configurations*/
-	bl armadaxp_fabric_prepare_deepIdle
-
-/*
-* Issue a Data Synchronization Barrier instruction to ensure that all
-* state saving has been	completed.
-*/
-#ifdef CONFIG_CPU_V6
-	mcr     p15, 0, r0, c7, c10, 4	@ Data Synchronization Barrier
-#elif defined (CONFIG_CPU_V7)
-	dsb				@ Data Synchronization Barrier
-#endif
-
-/* Lock Semaphore */
-	mrc	15, 0, r1, cr0, cr0, 5
-	and	r1, r1, #15
-	ldr	r4, =0xFBB20500
-1:
-	ldr	r2, [r4]
-	and	r2, r2, #0xF
-	cmp	r1, r2
-	bne	1b
-
-/* Disable SnoopEna */
-	mrc	15, 0, r1, cr0, cr0, 5
-	and	r1, r1, #15
-	mov	r6, #1
-	add	r7, r1, #24
-	ldr	r2, =0xFBB20200
-	ldr	r3, [r2]
-	bic	r3, r3, r6, lsl r7
-	str	r3, [r2]
-
-/* Release Semaphore */
-	ldr	r2, =0xFBB20500
-	ldr 	r0, =0xff
-	strb	r0, [r2]
-
-dowfi:
-/* WFI */
-#ifdef CONFIG_CPU_V6
-	mcr     p15, 0, r1, c7, c0, 4	@ wait for interrupt
-#elif defined (CONFIG_CPU_V7)
-	wfi				@ wait for interrupt
-#endif
-
-	/* After disabling the SnoopEna by SW regret is not allowed!! */
-	b dowfi
-
-#if 0
-	/* if we reach this point then deepIdle returned from regret mode and cpu
-	* state retained
-	*/
-	mov	r0, #1
-	ldmfd   sp!, {r3-r8}
-	ldmfd   sp!, {r2-r9}
-	
-	ldmfd   sp!, {r4-r12, pc}
-#endif
-ENDPROC(armadaxp_cpu_suspend)
-
-/*
-* armadaxp_cpu_resume: resume from cpu deepIdle state
-* input:
-*/
-ENTRY(armadaxp_cpu_resume)
-
-#ifdef CONFIG_CPU_ENDIAN_BE32
-	/* convert CPU to big endian */
-	.word 0x100f11ee /* mrc p15, 0, r0, c1, c0 */
-	.word 0x800080e3 /* orr r0, r0, #0x80 */
-	.word 0x100f01ee /* mcr p15, 0, r0, c1, c0 */
-#endif
-#ifdef CONFIG_CPU_ENDIAN_BE8
-	setend  be
-#endif
-
-/* Lock Semaphore */
-	mrc	15, 0, r1, cr0, cr0, 5
-	and	r1, r1, #15
-	ldr	r4, =0xD0020500
-1:
-	ldr	r2, [r4]
-	and	r2, r2, #0xF
-	cmp	r1, r2
-	bne	1b
-
-/* Enable SnoopEna */
-	mrc	15, 0, r1, cr0, cr0, 5
-	and	r1, r1, #15
-	mov	r6, #1
-	add	r7, r1, #24
-	ldr	r2, =0xD0020200
-	ldr	r3, [r2]
-	orr	r3, r3, r6, lsl r7
-	str	r3, [r2]
-
-/* Release Semaphore */
-	ldr	r2, =0xD0020500
-	ldr 	r0, =0xff
-	strb	r0, [r2]
-
-#ifdef CONFIG_SMP
-	adr     r0, suspend_saved_sp
-	mrc     p15, 0, r1, c0, c0, 5
-	and     r1, r1, #15
-	ldr     r0, [r0, r1, lsl #2]    @ stack phys addr
-#else
-	ldr     r0, suspend_saved_sp            @ stack phys addr
-#endif
-
-	ldmfd   r0!, {r2-r8}
-	mcr     p15, 0, r2, c2, c0, 1           @ restore CP15 - TTBR1
-	mcr     p15, 1, r3, c15, c2, 0          @ restore CP15 - Aux Func Modes Ctrl 0
-	mcr     p15, 1, r4, c15, c1, 2          @ restore CP15 - Aux Debug Modes Ctrl 2
-	mcr     p15, 1, r5, c15, c1, 1          @ restore CP15 - Aux Debug Modes Ctrl 1
-	mcr     p15, 0, r6, c9, c14, 0          @ restore CP15 - PMC
-	mcr     p15, 0, r7, c10, c2, 0          @ restore CP15 - PRRR
-	mcr     p15, 0, r8, c10, c2, 1          @ restore CP15 - NMRR
-	ldmfd   r0!, {r2-r9}
-	mcr	p15, 0, r8, c1, c0, 1		@ restore CP15 - Aux CR
-	mcr	p15, 1, r7, c15, c1, 0		@ restore CP15 - extra features
-	mcr	p15, 0, r4, c13, c0, 0		@ restore CP15 - FCSE
-	mcr	p15, 0, r3, c3, c0, 0		@ restore CP15 - DACR
-
-	/* load identity page table */
-	ldr	r3, identity_page_table_phys
-	mcr	p15, 0, r3, c2, c0, 0		@ set CP15 - TTBR
-	mov	r3, #0
-	mcr	p15, 0, r3, c13, c0, 1          @ set 0 in CP15 - context ID
-	mcr	p15, 0, r2, c1, c0, 0		@ restore CP15 - CR  @enable mmu
-	mrc     p15, 0, r3, c0, c0, 0           @ read id reg
-
-	ldr	r3, resume2
-	mov	pc, r3
-ENDPROC(armadaxp_cpu_resume)
-
-	/* stage 2 of the resume function that runs from PAGE_OFFSET virtual space */
-ENTRY(armadaxp_cpu_resume2)	
-	/* restore original page table*/
-
-	mcr	p15, 0, r5, c2, c0, 0		@ restore CP15 - TTBR
-	mcr	p15, 0, r6, c13, c0, 1          @ restore CP15 - context ID
-	mcr     p15, 0, r0, c8, c7, 0           @ TLB invalidate
-	mov	sp, r9				@ restore virtual sp
-	mov	r0, #0
-
-	ldmfd   sp!, {r4-r12, pc}               @ restore SVC registers
-
-ENDPROC(armadaxp_cpu_resume2)
-	
-resume2:
-	.long	armadaxp_cpu_resume2
-
-suspend_saved_sp:
-#ifdef CONFIG_SMP
-	.rept	CONFIG_NR_CPUS
-#endif
-	.long	0	@ physical SP saved here
-#ifdef CONFIG_SMP
-	.endr
-#endif
-	.global identity_page_table_phys
-identity_page_table_phys:
-	.long	0
--- a/arch/arm/plat-armada/common/mvDeviceId.h
+++ b/arch/arm/plat-armada/common/mvDeviceId.h
@@ -258,6 +258,32 @@ extern "C" {
 #define MV_6710_Z1_REV		0x0
 #define MV_6710_Z1_ID		((MV_6710_DEV_ID << 16) | MV_6710_Z1_REV)
 #define MV_6710_Z1_NAME		"MV6710 Z1"
+#define MV_6710_A0_REV          0x0
+#define MV_6710_A0_ID           ((MV_6710_DEV_ID << 16) | MV_6710_A0_REV)
+#define MV_6710_A0_NAME         "MV6710 A0"
+
+#define MV_6710_A1_REV          0x1
+#define MV_6710_A1_ID           ((MV_6710_DEV_ID << 16) | MV_6710_A1_REV)
+#define MV_6710_A1_NAME         "MV6710 A1"
+
+#define MV_6W11_DEV_ID          0x6711
+#define MV_6W11_A0_REV          0x0
+#define MV_6W11_A0_ID           ((MV_6W11_DEV_ID << 16) | MV_6W11_A0_REV)
+#define MV_6W11_A0_NAME         "MV6W11 A0"
+
+#define MV_6W11_A1_REV          0x1
+#define MV_6W11_A1_ID           ((MV_6W11_DEV_ID << 16) | MV_6W11_A1_REV)
+#define MV_6W11_A1_NAME         "MV6W11 A1"
+
+#define MV_6707_DEV_ID          0x6707
+#define MV_6707_A0_REV          0x0
+#define MV_6707_A0_ID           ((MV_6707_DEV_ID << 16) | MV_6707_A0_REV)
+#define MV_6707_A0_NAME         "MV6707 A0"
+
+#define MV_6707_A1_REV          0x1
+#define MV_6707_A1_ID           ((MV_6707_DEV_ID << 16) | MV_6707_A1_REV)
+#define MV_6707_A1_NAME         "MV6707 A1"
+
 
 /* Armada XP Family */
 #define MV_78130_DEV_ID		0x7813
--- /dev/null
+++ b/arch/arm/plat-armada/include/plat/audio.h
@@ -0,0 +1,11 @@
+#ifndef __PLAT_AUDIO_H
+#define __PLAT_AUDIO_H
+
+#include <linux/mbus.h>
+
+struct kirkwood_asoc_platform_data {
+	u32 tclk;
+	struct mbus_dram_target_info *dram;
+	int burst;
+};
+#endif
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_audio/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_audio/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell Audio ALSA Device Driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_SND_MRVL_AUDIO) += snd-mv88fx.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_audio_soc/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_audio_soc/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell Audio ALSA Device Driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_SND_MRVL_AUDIO) += snd-mv88fx-soc.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_btns/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_btns/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell btns Driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-y += btns_driver.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_cesa/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_cesa/Makefile
@@ -1,10 +1,9 @@
 #
 # Makefile for the Marvell CESA driver
 #
-ifeq ($(CONFIG_PLAT_ARMADA),y)
-	#include $(srctree)/$(MACHINE)/config/mvRules.mk
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
 
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 ifeq ($(CONFIG_MV_CESA_OCF),y)
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_dma/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_dma/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell DMA Driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_MV_USE_IDMA_ENGINE) += mv_dma.o 
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_gpio/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_gpio/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell GPIO Driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-y += mv_gpio.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile
@@ -1,7 +1,8 @@
 #
 # Makefile for the Marvell IPC Pseudo Network driver
 #
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
+
 obj-$(CONFIG_MV_IPC_NET) += mv_ipc.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/Makefile
@@ -1,7 +1,8 @@
 #
 # Makefile for the Marvell Gigabit Ethernet driver
 #
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
+
 obj-$(CONFIG_MV_IPC_NET) += ipc_net.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/Makefile
@@ -1,12 +1,7 @@
-
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
-endif
- 
 obj-$(CONFIG_MV_INCLUDE_SFLASH_MTD) 	+= sflash.o
 obj-$(CONFIG_MV_INCLUDE_MFLASH_MTD) 	+= mflash.o
 obj-$(CONFIG_MTD_NAND_LNC)		+= nand_lnc.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/nand_nfc.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/nand_nfc.c
@@ -993,7 +993,6 @@ static void orion_nfc_cmdfunc(struct mtd
 				int column, int page_addr)
 {
 	struct orion_nfc_info *info = (struct orion_nfc_info *)((struct nand_chip *)mtd->priv)->priv;
-	int ret = 0;
 
 	info->data_size = 0;
 	info->state = STATE_READY;
@@ -1126,6 +1125,8 @@ static void orion_nfc_cmdfunc(struct mtd
 		break;
 	case NAND_CMD_RESET:
 #if 0
+		int ret = 0;
+
 		info->column = 0;
 		info->page_addr = 0;
 		info->cmd = MV_NFC_CMD_RESET;
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/Makefile
@@ -2,16 +2,8 @@
 # Makefile for the Marvell Gigabit Ethernet driver
 #
 
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA370),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 ifeq ($(CONFIG_MV_ETH_NFP_LIB),y)
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -3121,7 +3121,9 @@ int mv_eth_port_resume(int port)
 		printk(KERN_ERR "%s: port %d is not suspend.\n", __func__, port);
 		return -1;
 	}
+#if !defined(CONFIG_ARCH_ARMADA370)
 	mvNetaPortPowerUp(port, mvBoardIsPortInSgmii(port), !mvBoardIsPortInGmii(port));
+#endif
 
 	mv_eth_win_init(port);
 
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell Gigabit Ethernet driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_MV_ETHERNET) += mv_netdev.o mv_ethernet.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
@@ -1,13 +1,8 @@
 #
 # Makefile for the Marvell Phone Device Driver
 #
-
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 VB_SRC_PATH = ../../mv_hal/voiceband
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/test/Makefile
@@ -1,12 +1,9 @@
-
-
 #
 # Makefile for the Marvell Phone Device Driver Test Module
 #
 #
-
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_TDM_DEV_TEST_SUPPORT) += tdm_dev.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Makefile
@@ -1,9 +1,8 @@
 #
 # Makefile for the Marvell Gpon driver
 #
-
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 ifdef CONFIG_MV_HAL_RULES_PATH
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_sata/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_sata/Makefile
@@ -1,9 +1,5 @@
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 IAL_OBJS        := mvLinuxIalLib.o mvLinuxIalHt.o mvLinuxIalOs.o mvIALCommon.o mvIALCommonUtils.o mvLinuxIalSmart.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_sdio/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_sdio/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell Audio ALSA Device Driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_MMC_MVSDMMC)	+= mvsdmmc.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell Key
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
-endif
- 
 obj-$(CONFIG_MV_INCLUDE_SWITCH)	+= mv_switch.o mv_switch_sysfs.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_trace/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_trace/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell XOR/DMA Driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_MV_DBG_TRACE) += dbg-trace.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tsu/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tsu/Makefile
@@ -1,8 +1,8 @@
 #
 # Makefile for the Marvell Transport Stream Unit driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_MV_TSU)	+= mv_tsu.o
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell USB device controller
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 USB_DIR := ../mv_hal/usb/
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_xor/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_xor/Makefile
@@ -1,12 +1,8 @@
 #
 # Makefile for the Marvell XOR/DMA Driver
 #
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifeq ($(CONFIG_ARCH_ARMADA_XP),y)
-	include $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 obj-$(CONFIG_MV_USE_XOR_ENGINE) += mv_netdma.o
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/dac/mvCLAudioCodec.c
@@ -0,0 +1,484 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "mvCLAudioCodec.h"
+#include "mvCLAudioCodecRegs.h"
+#include "mvSysAudioDac.h"
+
+/*******************************************************************************
+* mvCLAudioCodecInit - Initizlize the Cirrus Logic device
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+* OUTPUT:
+*		None
+* RETURN:
+*       MV_TRUE or MV_FALSE.
+*
+*******************************************************************************/
+MV_BOOL mvCLAudioCodecInit(MV_AUDIO_CODEC_DEV *pCodecDev)
+{
+	MV_U8 nData;
+
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return MV_FALSE;
+	}
+
+	/* Verify chip ID and revision */
+	nData = mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_ID_REG);
+	if ((MV_CL_AUDIO_CODEC_CHIP_ID != (nData >> 3)) || (MV_CL_AUDIO_CODEC_REV_ID != (nData & 0x7))) {
+		mvOsPrintf("%s: Error - Invalid Cirrus Logic chip/rev ID!\n", __func__);
+		return MV_FALSE;
+	}
+
+	/* Set the digital Interface format */
+	nData = mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_IF_CTRL_REG);
+	nData &= ~(0x7 << 3);
+	nData |= (pCodecDev->DACDigitalIFFormat << 3);
+	mvCLAudioCodecRegSet(pCodecDev, CL_AUDIO_CODEC_IF_CTRL_REG, nData);
+
+	/* Set the ADC Mode */
+	if (MV_LEFT_JUSTIFIED_MODE == pCodecDev->ADCMode)
+		mvCLAudioCodecRegBitsReset(pCodecDev, CL_AUDIO_CODEC_IF_CTRL_REG, BIT2);
+	else
+		mvCLAudioCodecRegBitsSet(pCodecDev, CL_AUDIO_CODEC_IF_CTRL_REG, BIT2);
+
+	return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvCLAudioCodecOutputVolumeSet - Set the Cirrus Logic output volume of OUTA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       nVolume  : Volume level.
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecOutputVolumeSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_8 nVolume)
+{
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+	mvCLAudioCodecRegSet(pCodecDev, CL_AUDIO_CODEC_VOL_OUTA_CTRL_REG, nVolume);
+}
+
+/*******************************************************************************
+* mvCLAudioCodecOutputVolumeGet - Get the Cirrus Logic output volume of OUTA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+* OUTPUT:
+*       None
+* RETURN:
+*		Volume level.
+*
+*******************************************************************************/
+MV_U8 mvCLAudioCodecOutputVolumeGet(MV_AUDIO_CODEC_DEV *pCodecDev)
+{
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return 0;
+	}
+	return mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_VOL_OUTA_CTRL_REG);
+}
+
+/*******************************************************************************
+* mvCLAudioCodecOutputVolumeMute - Mute the Cirrus Logic output volume of OUTA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       bMute    : MV_TRUE for mute, MV_FALSE to un-mute
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecOutputVolumeMute(MV_AUDIO_CODEC_DEV *pCodecDev, MV_BOOL bMute)
+{
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+	if (MV_TRUE == bMute)
+		mvCLAudioCodecRegBitsSet(pCodecDev, CL_AUDIO_CODEC_DAC_OUTPUT_CTRL_REG, BIT0);
+	else
+		mvCLAudioCodecRegBitsReset(pCodecDev, CL_AUDIO_CODEC_DAC_OUTPUT_CTRL_REG, BIT0);
+}
+
+/*******************************************************************************
+* mvCLAudioCodecInputVolumeSet - Set the Cirrus Logic input volume of INA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       nVolume  : Volume level.
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecInputVolumeSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_8 nVolume)
+{
+	MV_U8 nData;
+
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+	nData = mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_PGAA_VOL_CTRL_REG);
+	nData &= ~0x1f;
+	nData |= (0x1f & nVolume);
+	mvCLAudioCodecRegSet(pCodecDev, CL_AUDIO_CODEC_PGAA_VOL_CTRL_REG, nData);
+}
+
+/*******************************************************************************
+* mvCLAudioCodecInputVolumeGet - Get the Cirrus Logic input volume of INA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+* OUTPUT:
+*		None
+* RETURN:
+*       Volume level.
+*
+*******************************************************************************/
+MV_U8 mvCLAudioCodecInputVolumeGet(MV_AUDIO_CODEC_DEV *pCodecDev)
+{
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return 0;
+	}
+	return mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_PGAA_VOL_CTRL_REG) & 0x1f;
+}
+
+/*******************************************************************************
+* mvCLAudioCodecInputVolumeMute - Mute the Cirrus Logic input volume of INA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       bMute    : MV_TRUE for mute, MV_FALSE to un-mute
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecInputVolumeMute(MV_AUDIO_CODEC_DEV *pCodecDev, MV_BOOL bMute)
+{
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+	if (MV_TRUE == bMute)
+		mvCLAudioCodecRegBitsSet(pCodecDev, CL_AUDIO_CODEC_ADC_INPUT_INV_MUTE_REG, BIT0);
+	else
+		mvCLAudioCodecRegBitsReset(pCodecDev, CL_AUDIO_CODEC_ADC_INPUT_INV_MUTE_REG, BIT0);
+}
+
+/*******************************************************************************
+* mvCLAudioCodecTrebleSet - Set the Cirrus Logic output treble of INA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       nTreble  : treble value.
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecTrebleSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_8 nTreble)
+{
+	MV_U8 nData;
+
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+	nData = mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_TONE_CTRL_REG);
+	nData &= 0xF;
+	nData |= (nTreble << 4);
+	mvCLAudioCodecRegSet(pCodecDev, CL_AUDIO_CODEC_TONE_CTRL_REG, nData);
+}
+
+/*******************************************************************************
+* mvCLAudioCodecTrebleGet - Get the Cirrus Logic output treble of INA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+* OUTPUT:
+*		None
+* RETURN:
+*       treble value
+*
+*******************************************************************************/
+MV_U8 mvCLAudioCodecTrebleGet(MV_AUDIO_CODEC_DEV *pCodecDev)
+{
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return 0;
+	}
+	return mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_TONE_CTRL_REG) >> 4;
+}
+
+/*******************************************************************************
+* mvCLAudioCodecBassSet - Set the Cirrus Logic output bass of INA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       nBass    : Bass level.
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecBassSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_8 nBass)
+{
+	MV_U8 nData;
+
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+	nData = mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_TONE_CTRL_REG);
+	nData &= 0xf0;
+	nData |= nBass;
+	mvCLAudioCodecRegSet(pCodecDev, CL_AUDIO_CODEC_TONE_CTRL_REG, nData);
+}
+
+/*******************************************************************************
+* mvCLAudioCodecBassGet - Get the Cirrus Logic output bass of INA
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+* OUTPUT:
+*		None
+* RETURN:
+*       Bass level
+*
+*******************************************************************************/
+MV_U8 mvCLAudioCodecBassGet(MV_AUDIO_CODEC_DEV *pCodecDev)
+{
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return 0;
+	}
+	return mvCLAudioCodecRegGet(pCodecDev, CL_AUDIO_CODEC_TONE_CTRL_REG) & 0xF;
+}
+
+/*******************************************************************************
+* mvCLAudioCodecRegSet - Set Cirrus Logic register value
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       nOffset  : register offset
+*       nData    : register data
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecRegSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_U8 nOffset, MV_U8 nData)
+{
+	MV_U32 offset, data;
+
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+
+	offset = nOffset;
+	data = nData;
+	if (mvSysAudioCodecRegWrite(pCodecDev->codecHandle, offset, data) != MV_OK) {
+		mvOsPrintf("%s: Error while writing register!\n", __func__);
+		return;
+	}
+
+}
+
+/*******************************************************************************
+* mvCLAudioCodecRegGet - Set Cirrus Logic register value
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       nOffset  : register offset
+* OUTPUT:
+*		None
+* RETURN:
+*       register data
+*
+*******************************************************************************/
+MV_U8 mvCLAudioCodecRegGet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_U8 nOffset)
+{
+	MV_U32 offset, data;
+
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return 0;
+	}
+
+	offset = nOffset;
+	if (mvSysAudioCodecRegRead(pCodecDev->codecHandle, offset, &data) != MV_OK) {
+		mvOsPrintf("%s: Error while reading register!\n", __func__);
+		return 0;
+	}
+
+	return (MV_U8) data;
+}
+
+/*******************************************************************************
+* mvCLAudioCodecRegBitsSet - Set Cirrus Logic register bits value
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       nOffset  : register offset
+*       nBits    : register bits
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecRegBitsSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_U8 nOffset, MV_U8 nBits)
+{
+	MV_U8 nData;
+
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+
+	nData = mvCLAudioCodecRegGet(pCodecDev, nOffset);
+	nData |= nBits;
+	mvCLAudioCodecRegSet(pCodecDev, nOffset, nData);
+
+}
+
+/*******************************************************************************
+* mvCLAudioCodecRegGet - Reset Cirrus Logic register bits value
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pCodecDev: pointer to MV_AUDIO_CODEC_DEV structure.
+*       nOffset  : register offset
+*       nBits    : register bits
+* OUTPUT:
+*		None
+* RETURN:
+*       register data
+*
+*******************************************************************************/
+MV_VOID mvCLAudioCodecRegBitsReset(MV_AUDIO_CODEC_DEV *pCodecDev, MV_U8 nOffset, MV_U8 nBits)
+{
+	MV_U8 nData;
+
+	if (NULL == pCodecDev) {
+		mvOsPrintf("%s: Error - pCodecDev = NULL!\n", __func__);
+		return;
+	}
+
+	nData = mvCLAudioCodecRegGet(pCodecDev, nOffset);
+	nData &= ~nBits;
+	mvCLAudioCodecRegSet(pCodecDev, nOffset, nData);
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/dac/mvCLAudioCodec.h
@@ -0,0 +1,135 @@
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCLAudioCodech
+#define __INCmvCLAudioCodech
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define  MV_CL_AUDIO_CODEC_CHIP_ID   0x1B
+#define  MV_CL_AUDIO_CODEC_REV_ID    0x1
+
+/* Selects the digital interface format used for the data in on SDIN. */
+	typedef enum _mvDACDigitalIFFormat {
+		MV_L_JUSTIFIED_UP_TO_24_BIT,
+		MV_I2S_UP_TO_24_BIT,
+		MV_R_JUSTIFIED_UP_TO_24_BIT,
+		MV_R_JUSTIFIED_20_BIT,
+		MV_R_JUSTIFIED_18_BIT,
+		MV_R_JUSTIFIED_16_BIT
+	} MV_DAC_DIGITAL_IF_FORMAT;
+
+/* Selects either the I2S or Left-Justified digital interface format for the
+   data on SDOUT. */
+	typedef enum _mvADCMode {
+		MV_LEFT_JUSTIFIED_MODE,
+		MV_I2S_MODE
+	} MV_ADC_MODE;
+
+/* Cirrus Logic device structure */
+	typedef struct _mvAudioCodecDev {
+		/* MUST be set by user!!!   */
+		MV_VOID *codecHandle;
+		MV_U8 chanNum;
+		MV_DAC_DIGITAL_IF_FORMAT DACDigitalIFFormat;
+		MV_ADC_MODE ADCMode;
+
+		/* Set by driver */
+		MV_U8 nChipID;
+		MV_U8 nRevID;
+
+	} MV_AUDIO_CODEC_DEV;
+
+/* Initialize the Cirrus Logic device */
+	MV_BOOL mvCLAudioCodecInit(MV_AUDIO_CODEC_DEV *pCodecDev);
+
+/* Function to control output volume (playback) */
+	MV_VOID mvCLAudioCodecOutputVolumeSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_8 nVolume);
+	MV_U8 mvCLAudioCodecOutputVolumeGet(MV_AUDIO_CODEC_DEV *pCodecDev);
+	MV_VOID mvCLAudioCodecOutputVolumeMute(MV_AUDIO_CODEC_DEV *pCodecDev, MV_BOOL bMute);
+
+/* Function to control input volume (record) */
+	MV_VOID mvCLAudioCodecInputVolumeSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_8 nVolume);
+	MV_U8 mvCLAudioCodecInputVolumeGet(MV_AUDIO_CODEC_DEV *pCodecDev);
+	MV_VOID mvCLAudioCodecInputVolumeMute(MV_AUDIO_CODEC_DEV *pCodecDev, MV_BOOL bMute);
+
+/* Function to control output tone */
+	MV_VOID mvCLAudioCodecTrebleSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_8 nTreble);
+	MV_U8 mvCLAudioCodecTrebleGet(MV_AUDIO_CODEC_DEV *pCodecDev);
+	MV_VOID mvCLAudioCodecBassSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_8 nBass);
+	MV_U8 mvCLAudioCodecBassGet(MV_AUDIO_CODEC_DEV *pCodecDev);
+
+/* Function to access the Cirrus Logic CODEC registers */
+	MV_VOID mvCLAudioCodecRegSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_U8 nOffset, MV_U8 nData);
+	MV_U8 mvCLAudioCodecRegGet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_U8 nOffset);
+	MV_VOID mvCLAudioCodecRegBitsSet(MV_AUDIO_CODEC_DEV *pCodecDev, MV_U8 nOffset, MV_U8 nBits);
+	MV_VOID mvCLAudioCodecRegBitsReset(MV_AUDIO_CODEC_DEV *pCodecDev, MV_U8 nOffset, MV_U8 nBits);
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* __INCmvCLAudioCodech */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/dac/mvCLAudioCodecRegs.h
@@ -0,0 +1,85 @@
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCLAudioCodecRegsh
+#define __INCmvCLAudioCodecRegsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define   CL_AUDIO_CODEC_ID_REG                    0x1
+#define   CL_AUDIO_CODEC_IF_CTRL_REG               0x4
+#define   CL_AUDIO_CODEC_ADC_INPUT_INV_MUTE_REG    0x7
+#define   CL_AUDIO_CODEC_DAC_OUTPUT_CTRL_REG       0x8
+#define   CL_AUDIO_CODEC_DAC_CTRL_REG              0x9
+#define   CL_AUDIO_CODEC_PGAA_VOL_CTRL_REG         0xa
+#define   CL_AUDIO_CODEC_TONE_CTRL_REG             0x15
+#define   CL_AUDIO_CODEC_VOL_OUTA_CTRL_REG         0x16
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* __INCmvCLAudioCodecRegsh */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/dac/mvSysAudioDac.h
@@ -0,0 +1,118 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_AUDIO_DAC_H__
+#define __MV_SYS_AUDIO_DAC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+* mvSysAudioCodecRegRead
+*
+* DESCRIPTION:
+*	System interface for reading an Audio codec register.
+*
+* INPUT:
+*       codecHandle: Handle passed by OS glue by which an audio codec is
+*		     identified.
+*       regOffset:   Offset of codec register to be read.
+*
+* OUTPUT:
+*       regData:     Register data
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+	MV_STATUS mvSysAudioCodecRegRead(MV_VOID *codecHandle, MV_U32 regOffset, MV_U32 *regData);
+
+/*******************************************************************************
+* mvSysAudioCodecRegWrite
+*
+* DESCRIPTION:
+*	System interface for writing an Audio codec register.
+*
+* INPUT:
+*       codecHandle: Handle passed by OS glue by which an audio codec is
+*		     identified.
+*       regOffset:   Offset of codec register to be written.
+*       regData:     Register data to write.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+	MV_STATUS mvSysAudioCodecRegWrite(MV_VOID *codecHandle, MV_U32 regOffset, MV_U32 regData);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/mvAudio.c
@@ -0,0 +1,944 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvSysAudioConfig.h"
+#include "mvAudioRegs.h"
+#include "mvAudio.h"
+
+/* #define MV_AUDIO_SKIP_WIN_DECODING */
+
+static MV_U32 audioBurstBytesNumGet(MV_AUDIO_BURST_SIZE burst);
+
+static MV_AUDIO_HAL_DATA audioHalData[MV_AUDIO_MAX_UNITS];
+#ifndef MV_AUDIO_SKIP_WIN_DECODING
+static MV_UNIT_WIN_INFO audioAddrDecWinMap[MAX_TARGETS + 1];
+static MV_STATUS mvAudioReplaceAddrWin(MV_U32 unit, MV_U32 winId, MV_U32 buffPhysAddr, MV_U32 buffSize);
+#endif
+
+/*******************************************************************************
+* mvAudioHalInit - Initialize the Audio subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvAudioHalInit(MV_U8 unit, MV_AUDIO_HAL_DATA *halData)
+{
+	int timeout;
+
+	MV_REG_BIT_RESET(MV_AUDIO_PLL_CTRL1_REG(unit), 0x333FF8);
+	MV_REG_BIT_SET(MV_AUDIO_PLL_CTRL1_REG(unit), 0x111D18);
+
+	/*MV_REG_BIT_RESET(0x10074,0xC018000);
+	   MV_REG_BIT_SET(0x10074,0x4008000); */
+
+	timeout = 10000000;
+	while (timeout--)
+		continue;
+
+	MV_REG_BIT_RESET(MV_AUDIO_PLL_CTRL1_REG(unit), 0x333FF8);
+	MV_REG_BIT_SET(MV_AUDIO_PLL_CTRL1_REG(unit), 0x111D18);
+
+	mvOsMemcpy(&audioHalData[unit], halData, sizeof(MV_AUDIO_HAL_DATA));
+	/*MV_REG_BIT_RESET(0x10074,0xC018000);
+	   MV_REG_BIT_SET(0x10074,0x4008000); */
+
+}
+
+/* Clocks Control and Status related*/
+/*******************************************************************************
+* mvAudioDCOCtrlSet - Set DCO control register
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       dcoCtrl: pointer to MV_AUDIO_FREQ_DATA structure
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+
+MV_STATUS mvAudioDCOCtrlSet(int unit, MV_AUDIO_FREQ_DATA *dcoCtrl)
+{
+	MV_U32 reg;
+	/* Check parameters */
+	if (dcoCtrl->baseFreq > AUDIO_FREQ_96KH) {
+		mvOsPrintf("mvAudioDCOCtrlSet: dcoCtrl->baseFreq value (0x%x) invalid\n", dcoCtrl->baseFreq);
+		return MV_BAD_PARAM;
+
+	}
+	if ((dcoCtrl->offset > 0xFD0) || (dcoCtrl->offset < 0x20)) {
+		mvOsPrintf("mvAudioDCOCtrlSet: dcoCtrl->offset value (0x%x) invalid\n", dcoCtrl->baseFreq);
+		return MV_BAD_PARAM;
+	}
+	reg = MV_REG_READ(MV_AUDIO_DCO_CTRL_REG(unit));
+
+	reg &= ~(ADCR_DCO_CTRL_FS_MASK | ADCR_DCO_CTRL_OFFSET_MASK);
+	reg |= ((dcoCtrl->baseFreq << ADCR_DCO_CTRL_FS_OFFS) | (dcoCtrl->offset << ADCR_DCO_CTRL_OFFSET_OFFS));
+	MV_REG_WRITE(MV_AUDIO_DCO_CTRL_REG(unit), reg);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAudioDCOCtrlGet - Set DCO control register
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       dcoCtrl: pointer to MV_AUDIO_FREQ_DATA structure
+* OUTPUT:
+*		dcoCtrl: pointer to MV_AUDIO_FREQ_DATA structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+
+MV_VOID mvAudioDCOCtrlGet(int unit, MV_AUDIO_FREQ_DATA *dcoCtrl)
+{
+	MV_U32 reg = MV_REG_READ(MV_AUDIO_DCO_CTRL_REG(unit));
+
+	dcoCtrl->baseFreq = (reg & ADCR_DCO_CTRL_FS_MASK) >> ADCR_DCO_CTRL_FS_OFFS;
+	dcoCtrl->offset = (reg & ADCR_DCO_CTRL_OFFSET_MASK) >> ADCR_DCO_CTRL_OFFSET_OFFS;
+}
+
+/*******************************************************************************
+* mvAudioSpcrCtrlGet - Set SPCR control register
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       spcrCtrl: pointer to MV_AUDIO_FREQ_DATA structure
+* OUTPUT:
+*		spcrCtrl: pointer to MV_AUDIO_FREQ_DATA structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+
+MV_VOID mvAudioSpcrCtrlGet(int unit, MV_AUDIO_FREQ_DATA *spcrCtrl)
+{
+	MV_U32 reg = MV_REG_READ(MV_AUDIO_SPCR_DCO_STATUS_REG(unit));
+
+	spcrCtrl->baseFreq = (reg & ASDSR_SPCR_CTRLFS_MASK) >> ASDSR_SPCR_CTRLFS_OFFS;
+	spcrCtrl->offset = (reg & ASDSR_SPCR_CTRLOFFSET_MASK) >> ASDSR_SPCR_CTRLOFFSET_OFFS;
+}
+
+/* Audio PlayBack related*/
+/*******************************************************************************
+* mvAudioPlaybackControlSet - Set Playback general parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_AUDIO_PLAYBACK_CTRL structure
+* OUTPUT:
+*		None
+* RETURN:
+*       MV_OK on success , MV_FAIL on fail
+*
+*******************************************************************************/
+MV_STATUS mvAudioPlaybackControlSet(int unit, MV_AUDIO_PLAYBACK_CTRL *ctrl)
+{
+	MV_U32 reg;
+
+	if (ctrl->monoMode >= AUDIO_PLAY_OTHER_MONO) {
+		mvOsPrintf("mvAudioPlaybackControlSet: Error ,illegal monoMode %x\n", ctrl->monoMode);
+
+		return MV_FAIL;
+
+	}
+
+	if ((ctrl->burst != AUDIO_32BYTE_BURST) && (ctrl->burst != AUDIO_128BYTE_BURST)) {
+		mvOsPrintf("mvAudioPlaybackControlSet: Error ,illegal burst %x\n", ctrl->burst);
+
+		return MV_FAIL;
+
+	}
+
+	if (ctrl->bufferPhyBase & (MV_AUDIO_BUFFER_MIN_ALIGN - 1)) {
+		mvOsPrintf("mvAudioPlaybackControlSet: Error ,bufferPhyBase is not"
+			   "\n aligned to 0x%x bytes\n", MV_AUDIO_BUFFER_MIN_ALIGN);
+
+		return MV_FAIL;
+	}
+
+	if ((ctrl->bufferSize <= audioBurstBytesNumGet(ctrl->burst)) ||
+	    (ctrl->bufferSize & (audioBurstBytesNumGet(ctrl->burst) - 1)) ||
+	    (ctrl->bufferSize > AUDIO_REG_TO_SIZE(APBBCR_SIZE_MAX))
+	    ) {
+		mvOsPrintf("mvAudioPlaybackControlSet: Error, bufferSize smaller"
+			   "\nthan or not multiple of 0x%x bytes or larger than"
+			   "\n 0x%x", audioBurstBytesNumGet(ctrl->burst), AUDIO_REG_TO_SIZE(APBBCR_SIZE_MAX));
+
+		return MV_FAIL;
+	}
+
+	reg = MV_REG_READ(MV_AUDIO_PLAYBACK_CTRL_REG(unit));
+	reg &= ~(APCR_PLAY_BURST_SIZE_MASK | APCR_LOOPBACK_MASK | APCR_PLAY_MONO_MASK | APCR_PLAY_SAMPLE_SIZE_MASK);
+	reg |= ctrl->burst << APCR_PLAY_BURST_SIZE_OFFS;
+	reg |= ctrl->loopBack << APCR_LOOPBACK_OFFS;
+	reg |= ctrl->monoMode << APCR_PLAY_MONO_OFFS;
+	reg |= ctrl->sampleSize << APCR_PLAY_SAMPLE_SIZE_OFFS;
+	MV_REG_WRITE(MV_AUDIO_PLAYBACK_CTRL_REG(unit), reg);
+
+#ifndef MV_AUDIO_SKIP_WIN_DECODING
+	if (mvAudioReplaceAddrWin(unit, MV_AUDIO_PLAYBACK_WIN_NUM, ctrl->bufferPhyBase, ctrl->bufferSize) != MV_OK) {
+		mvOsPrintf("mvAudioRecordControlSet: Failed to replace address decoding window.\n");
+		return MV_FAIL;
+	}
+#endif
+
+	/* Set the interrupt byte count.                            */
+	reg = ctrl->intByteCount & APBCI_BYTE_COUNT_MASK;
+	MV_REG_WRITE(MV_AUDIO_PLAYBACK_BYTE_CNTR_INT_REG(unit), reg);
+
+	MV_REG_WRITE(MV_AUDIO_PLAYBACK_BUFF_START_REG(unit), ctrl->bufferPhyBase);
+	MV_REG_WRITE(MV_AUDIO_PLAYBACK_BUFF_SIZE_REG(unit), AUDIO_SIZE_TO_REG(ctrl->bufferSize));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAudioPlaybackControlGet - Get Playback general parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_AUDIO_PLAYBACK_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_AUDIO_PLAYBACK_CTRL structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvAudioPlaybackControlGet(int unit, MV_AUDIO_PLAYBACK_CTRL *ctrl)
+{
+	MV_U32 reg = MV_REG_READ(MV_AUDIO_PLAYBACK_CTRL_REG(unit));
+
+	ctrl->burst = (reg & APCR_PLAY_BURST_SIZE_MASK) >> APCR_PLAY_BURST_SIZE_OFFS;
+	ctrl->loopBack = (reg & APCR_LOOPBACK_MASK) >> APCR_LOOPBACK_OFFS;
+	ctrl->monoMode = (reg & APCR_PLAY_MONO_MASK) >> APCR_PLAY_MONO_OFFS;
+
+	ctrl->bufferPhyBase = MV_REG_READ(MV_AUDIO_PLAYBACK_BUFF_START_REG(unit));
+	reg = MV_REG_READ(MV_AUDIO_PLAYBACK_BUFF_SIZE_REG(unit));
+	ctrl->bufferSize = AUDIO_REG_TO_SIZE(reg);
+
+	ctrl->intByteCount = MV_REG_READ(MV_AUDIO_PLAYBACK_BYTE_CNTR_INT_REG(unit));
+}
+
+/*******************************************************************************
+* mvAudioPlaybackStatusGet - Get Playback status parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_AUDIO_PLAYBACK_STATUS structure
+* OUTPUT:
+*		ctrl: pointer to MV_AUDIO_PLAYBACK_STATUS structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvAudioPlaybackStatusGet(int unit, MV_AUDIO_PLAYBACK_STATUS *status)
+{
+	status->muteI2S = ((MV_REG_READ(MV_AUDIO_PLAYBACK_CTRL_REG(unit)) & APCR_PLAY_I2S_MUTE_MASK) ?
+			   MV_TRUE : MV_FALSE);
+	status->enableI2S = ((MV_REG_READ(MV_AUDIO_PLAYBACK_CTRL_REG(unit)) & APCR_PLAY_I2S_ENABLE_MASK) ?
+			     MV_TRUE : MV_FALSE);
+	status->muteSPDIF = ((MV_REG_READ(MV_AUDIO_PLAYBACK_CTRL_REG(unit)) & APCR_PLAY_SPDIF_MUTE_MASK) ?
+			     MV_TRUE : MV_FALSE);
+	status->enableSPDIF = ((MV_REG_READ(MV_AUDIO_PLAYBACK_CTRL_REG(unit)) & APCR_PLAY_SPDIF_ENABLE_MASK) ?
+			       MV_TRUE : MV_FALSE);
+	status->pause = ((MV_REG_READ(MV_AUDIO_PLAYBACK_CTRL_REG(unit)) & APCR_PLAY_PAUSE_MASK) ? MV_TRUE : MV_FALSE);
+
+}
+
+/*******************************************************************************
+* mvSPDIFPlaybackCtrlGet - Set SPDIF Playback control parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_SPDIF_PLAYBACK_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_SPDIF_PLAYBACK_CTRL structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+/* Audio SPDIF PlayBack related*/
+MV_VOID mvSPDIFPlaybackCtrlSet(int unit, MV_SPDIF_PLAYBACK_CTRL *ctrl)
+{
+	if (ctrl->blockStartInternally)
+		MV_REG_BIT_RESET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_BLOCK_START_MASK);
+	else
+		MV_REG_BIT_SET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_BLOCK_START_MASK);
+
+	if (ctrl->validityFromMemory)
+		MV_REG_BIT_SET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_PB_EN_MEM_VALIDITY_MASK);
+	else
+		MV_REG_BIT_RESET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_PB_EN_MEM_VALIDITY_MASK);
+
+	if (ctrl->userBitsFromMemory)
+		MV_REG_BIT_SET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_PB_MEM_USR_EN_MASK);
+	else
+		MV_REG_BIT_RESET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_PB_MEM_USR_EN_MASK);
+
+	if (ctrl->underrunData)
+		MV_REG_BIT_SET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_UNDERRUN_DATA_MASK);
+	else
+		MV_REG_BIT_RESET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_UNDERRUN_DATA_MASK);
+
+	if (ctrl->validity)
+		MV_REG_BIT_SET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_PB_REG_VALIDITY_MASK);
+	else
+		MV_REG_BIT_RESET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_PB_REG_VALIDITY_MASK);
+
+	if (ctrl->nonPcm)
+		MV_REG_BIT_SET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_PB_NONPCM_MASK);
+	else
+		MV_REG_BIT_RESET(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit), ASPCR_SPDIF_PB_NONPCM_MASK);
+}
+
+/*******************************************************************************
+* mvSPDIFPlaybackCtrlGet - Get SPDIF Playback control parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_SPDIF_PLAYBACK_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_SPDIF_PLAYBACK_CTRL structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSPDIFPlaybackCtrlGet(int unit, MV_SPDIF_PLAYBACK_CTRL *ctrl)
+{
+	ctrl->blockStartInternally =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit)) & ASPCR_SPDIF_BLOCK_START_MASK) ? MV_TRUE : MV_FALSE);
+	ctrl->nonPcm =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit)) & ASPCR_SPDIF_PB_NONPCM_MASK) ? MV_TRUE : MV_FALSE);
+	ctrl->underrunData =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit)) & ASPCR_SPDIF_UNDERRUN_DATA_MASK) ? MV_TRUE : MV_FALSE);
+	ctrl->userBitsFromMemory =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit)) & ASPCR_SPDIF_PB_MEM_USR_EN_MASK) ? MV_TRUE : MV_FALSE);
+	ctrl->validity =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit)) & ASPCR_SPDIF_PB_REG_VALIDITY_MASK) ? MV_TRUE : MV_FALSE);
+	ctrl->validityFromMemory =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit)) & ASPCR_SPDIF_PB_EN_MEM_VALIDITY_MASK) ?
+	     MV_TRUE : MV_FALSE);
+
+}
+
+/*******************************************************************************
+* mvI2SPlaybackCtrlSet - Set I2S Playback control parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_I2S_PLAYBACK_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_I2S_PLAYBACK_CTRL structure
+* RETURN:
+*       MV_OK on success, and MV_FAIL on fail.
+*
+*******************************************************************************/
+
+/* Audio I2S PlayBack related*/
+MV_STATUS mvI2SPlaybackCtrlSet(int unit, MV_I2S_PLAYBACK_CTRL *ctrl)
+{
+	MV_U32 reg = MV_REG_READ(MV_AUDIO_I2S_PLAY_CTRL_REG(unit)) &
+	    ~(AIPCR_I2S_PB_JUSTF_MASK | AIPCR_I2S_PB_SAMPLE_SIZE_MASK);
+
+	if (ctrl->sampleSize > SAMPLE_16BIT) {
+		mvOsPrintf("mvI2SPlaybackCtrlSet: illigal sample size\n");
+		return MV_FAIL;
+	}
+
+	reg |= ctrl->sampleSize << AIPCR_I2S_PB_SAMPLE_SIZE_OFFS;
+
+	if (ctrl->sendLastFrame)
+		MV_REG_BIT_SET(MV_AUDIO_I2S_PLAY_CTRL_REG(unit), AIPCR_I2S_SEND_LAST_FRM_MASK);
+	else
+		MV_REG_BIT_RESET(MV_AUDIO_I2S_PLAY_CTRL_REG(unit), AIPCR_I2S_SEND_LAST_FRM_MASK);
+
+	switch (ctrl->justification) {
+	case I2S_JUSTIFIED:
+	case LEFT_JUSTIFIED:
+	case RIGHT_JUSTIFIED:
+		reg |= ctrl->justification << AIPCR_I2S_PB_JUSTF_OFFS;
+		break;
+	default:
+		mvOsPrintf("mvI2SPlaybackCtrlSet: illigal Justification value\n");
+		return MV_FAIL;
+
+	}
+
+	MV_REG_WRITE(MV_AUDIO_I2S_PLAY_CTRL_REG(unit), reg);
+	return MV_OK;
+
+}
+
+/*******************************************************************************
+* mvI2SPlaybackCtrlGet - Get I2S Playback control parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_I2S_PLAYBACK_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_I2S_PLAYBACK_CTRL structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvI2SPlaybackCtrlGet(int unit, MV_I2S_PLAYBACK_CTRL *ctrl)
+{
+	ctrl->sendLastFrame =
+	    ((MV_REG_READ(MV_AUDIO_I2S_PLAY_CTRL_REG(unit)) & AIPCR_I2S_SEND_LAST_FRM_MASK) ? MV_TRUE : MV_FALSE);
+
+	ctrl->justification =
+	    ((MV_REG_READ(MV_AUDIO_I2S_PLAY_CTRL_REG(unit)) & AIPCR_I2S_PB_JUSTF_MASK) >> AIPCR_I2S_PB_JUSTF_OFFS);
+
+	ctrl->sampleSize =
+	    ((MV_REG_READ(MV_AUDIO_I2S_PLAY_CTRL_REG(unit)) & AIPCR_I2S_PB_SAMPLE_SIZE_MASK) >>
+	     AIPCR_I2S_PB_SAMPLE_SIZE_OFFS);
+
+}
+
+/*******************************************************************************
+* mvAudioRecordControlGet - Get Recording control parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_AUDIO_RECORD_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_AUDIO_RECORD_CTRL structure
+* RETURN:
+*       MV_OK on success , MV_FAIL on fail.
+*
+*******************************************************************************/
+/* Audio Recording*/
+MV_STATUS mvAudioRecordControlSet(int unit, MV_AUDIO_RECORD_CTRL *ctrl)
+{
+	MV_U32 reg;
+
+	if (ctrl->monoChannel > AUDIO_REC_RIGHT_MONO) {
+		mvOsPrintf("mvAudioRecordControlSet: Error ,illegal monoChannel %x\n", ctrl->monoChannel);
+
+		return MV_FAIL;
+	}
+
+	if ((ctrl->burst != AUDIO_32BYTE_BURST) && (ctrl->burst != AUDIO_128BYTE_BURST)) {
+		mvOsPrintf("mvAudioRecordControlSet: Error ,illegal burst %x\n", ctrl->burst);
+
+		return MV_FAIL;
+
+	}
+
+	if (ctrl->bufferPhyBase & (MV_AUDIO_BUFFER_MIN_ALIGN - 1)) {
+		mvOsPrintf("mvAudioRecordControlSet: Error ,bufferPhyBase is not"
+			   "\n aligned to 0x%x bytes\n", MV_AUDIO_BUFFER_MIN_ALIGN);
+
+		return MV_FAIL;
+	}
+
+	if ((ctrl->bufferSize <= audioBurstBytesNumGet(ctrl->burst)) ||
+	    (ctrl->bufferSize & (audioBurstBytesNumGet(ctrl->burst) - 1)) ||
+	    (ctrl->bufferSize > AUDIO_REG_TO_SIZE(APBBCR_SIZE_MAX))
+	    ) {
+		mvOsPrintf("mvAudioRecordControlSet: Error, bufferSize smaller"
+			   "\nthan or not multiple of 0x%x bytes or larger than"
+			   "\n 0x%x", audioBurstBytesNumGet(ctrl->burst), AUDIO_REG_TO_SIZE(APBBCR_SIZE_MAX));
+
+		return MV_FAIL;
+	}
+
+	reg = MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit));
+	reg &= ~(ARCR_RECORD_BURST_SIZE_MASK | ARCR_RECORDED_MONO_CHNL_MASK | ARCR_RECORD_SAMPLE_SIZE_MASK);
+	switch (ctrl->sampleSize) {
+	case SAMPLE_16BIT:
+	case SAMPLE_16BIT_NON_COMPACT:
+	case SAMPLE_20BIT:
+	case SAMPLE_24BIT:
+	case SAMPLE_32BIT:
+		reg |= ctrl->sampleSize << ARCR_RECORD_SAMPLE_SIZE_OFFS;
+		break;
+	default:
+		mvOsPrintf("mvAudioRecordControlSet: Error ,illegal sampleSize %x\n", ctrl->sampleSize);
+
+		return MV_FAIL;
+	}
+
+	reg |= ctrl->burst << ARCR_RECORD_BURST_SIZE_OFFS;
+	reg |= ctrl->monoChannel << ARCR_RECORDED_MONO_CHNL_OFFS;
+	MV_REG_WRITE(MV_AUDIO_RECORD_CTRL_REG(unit), reg);
+
+	if (ctrl->mono)
+		MV_REG_BIT_SET(MV_AUDIO_RECORD_CTRL_REG(unit), ARCR_RECORD_MONO_MASK);
+	else
+		MV_REG_BIT_RESET(MV_AUDIO_RECORD_CTRL_REG(unit), ARCR_RECORD_MONO_MASK);
+
+#ifndef MV_AUDIO_SKIP_WIN_DECODING
+	if (mvAudioReplaceAddrWin(unit, MV_AUDIO_RECORD_WIN_NUM, ctrl->bufferPhyBase, ctrl->bufferSize) != MV_OK) {
+		mvOsPrintf("mvAudioRecordControlSet: Failed to replace address decoding window.\n");
+		return MV_FAIL;
+	}
+#endif
+
+	/* Set the interrupt byte count.                            */
+	reg = ctrl->intByteCount & ARBCI_BYTE_COUNT_MASK;
+	MV_REG_WRITE(MV_AUDIO_RECORD_BYTE_CNTR_INT_REG(unit), reg);
+
+	MV_REG_WRITE(MV_AUDIO_RECORD_START_ADDR_REG(unit), ctrl->bufferPhyBase);
+	MV_REG_WRITE(MV_AUDIO_RECORD_BUFF_SIZE_REG(unit), AUDIO_SIZE_TO_REG(ctrl->bufferSize));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAudioRecordControlGet - Get Recording control parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_AUDIO_RECORD_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_AUDIO_RECORD_CTRL structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvAudioRecordControlGet(int unit, MV_AUDIO_RECORD_CTRL *ctrl)
+{
+	MV_U32 reg;
+
+	ctrl->mono = ((MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit)) & ARCR_RECORD_MONO_MASK) ? MV_TRUE : MV_FALSE);
+
+	ctrl->burst =
+	    ((MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit)) & ARCR_RECORD_BURST_SIZE_MASK) >>
+	     ARCR_RECORD_BURST_SIZE_OFFS);
+
+	ctrl->monoChannel =
+	    ((MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit)) & ARCR_RECORDED_MONO_CHNL_MASK) >>
+	     ARCR_RECORDED_MONO_CHNL_OFFS);
+
+	ctrl->sampleSize =
+	    ((MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit)) & ARCR_RECORD_SAMPLE_SIZE_MASK) >>
+	     ARCR_RECORD_SAMPLE_SIZE_OFFS);
+
+	ctrl->bufferPhyBase = MV_REG_READ(MV_AUDIO_RECORD_START_ADDR_REG(unit));
+	reg = MV_REG_READ(MV_AUDIO_RECORD_BUFF_SIZE_REG(unit));
+	ctrl->bufferSize = AUDIO_REG_TO_SIZE(reg);
+
+	ctrl->intByteCount = MV_REG_READ(MV_AUDIO_RECORD_BYTE_CNTR_INT_REG(unit));
+
+}
+
+/*******************************************************************************
+* mvAudioRecordControlGet - Get Recording status parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       status: pointer to MV_AUDIO_RECORD_STATUS structure
+* OUTPUT:
+*		status: pointer to MV_AUDIO_RECORD_STATUS structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvAudioRecordStatusGet(int unit, MV_AUDIO_RECORD_STATUS *status)
+{
+	status->I2SEnable =
+	    ((MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit)) & ARCR_RECORD_I2S_EN_MASK) ? MV_TRUE : MV_FALSE);
+
+	status->mute = ((MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit)) & ARCR_RECORD_MUTE_MASK) ? MV_TRUE : MV_FALSE);
+
+	status->pause = ((MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit)) & ARCR_RECORD_PAUSE_MASK) ? MV_TRUE : MV_FALSE);
+
+	status->spdifEnable =
+	    ((MV_REG_READ(MV_AUDIO_RECORD_CTRL_REG(unit)) & ARCR_RECORD_SPDIF_EN_MASK) ? MV_TRUE : MV_FALSE);
+
+}
+
+/*******************************************************************************
+* mvSPDIFRecordTclockSet - Set T-clock for SPDIF
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       none
+* OUTPUT:
+*		none
+* RETURN:
+*       MV_OK on success , MV_NOT_SUPPORTED on non supported T-clock
+*
+*******************************************************************************/
+
+/* SPDIF Recording Related*/
+MV_STATUS mvSPDIFRecordTclockSet(int unit)
+{
+	MV_U32 tclock = audioHalData[unit].tclk;
+	MV_U32 reg = MV_REG_READ(MV_AUDIO_SPDIF_REC_GEN_REG(unit));
+
+	reg &= ~ASRGR_CORE_CLK_FREQ_MASK;
+	switch (tclock) {
+	case MV_BOARD_TCLK_133MHZ:
+		reg |= ASRGR_CORE_CLK_FREQ_133MHZ;
+		break;
+	case MV_BOARD_TCLK_150MHZ:
+		reg |= ASRGR_CORE_CLK_FREQ_150MHZ;
+		break;
+	case MV_BOARD_TCLK_166MHZ:
+		reg |= ASRGR_CORE_CLK_FREQ_166MHZ;
+		break;
+	case MV_BOARD_TCLK_200MHZ:
+		reg |= ASRGR_CORE_CLK_FREQ_200MHZ;
+		break;
+	default:
+		mvOsPrintf("mvSPDIFRecordTclockSet: Not supported core clock %d\n", tclock);
+		return MV_NOT_SUPPORTED;
+	}
+
+	MV_REG_WRITE(MV_AUDIO_SPDIF_REC_GEN_REG(unit), reg);
+
+	return MV_OK;
+
+}
+
+/*******************************************************************************
+* mvSPDIFRecordTclockGet - Get T-clock for SPDIF
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       none
+* OUTPUT:
+*		none
+* RETURN:
+*       T-clock configured in the SPDIF.
+*
+*******************************************************************************/
+MV_U32 mvSPDIFRecordTclockGet(int unit)
+{
+	MV_U32 reg = (MV_REG_READ(MV_AUDIO_SPDIF_REC_GEN_REG(unit)) & ASRGR_CORE_CLK_FREQ_MASK);
+
+	switch (reg) {
+	case ASRGR_CORE_CLK_FREQ_133MHZ:
+		return MV_BOARD_TCLK_133MHZ;
+	case ASRGR_CORE_CLK_FREQ_150MHZ:
+		return MV_BOARD_TCLK_150MHZ;
+	case ASRGR_CORE_CLK_FREQ_166MHZ:
+		return MV_BOARD_TCLK_166MHZ;
+	case ASRGR_CORE_CLK_FREQ_200MHZ:
+		return MV_BOARD_TCLK_200MHZ;
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+* mvAudioRecordControlGet - Get SPDIF Recording status parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       status: pointer to MV_SPDIF_RECORD_STATUS structure
+* OUTPUT:
+*		status: pointer to MV_SPDIF_RECORD_STATUS structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSPDIFRecordStatusGet(int unit, MV_SPDIF_RECORD_STATUS *status)
+{
+	status->freq =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_REC_GEN_REG(unit)) & ASRGR_CORE_CLK_FREQ_MASK) >> ASRGR_CORE_CLK_FREQ_OFFS);
+
+	status->nonLinearPcm =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_REC_GEN_REG(unit)) & ASRGR_NON_PCM_MASK) ? MV_TRUE : MV_FALSE);
+
+	status->validPcm =
+	    ((MV_REG_READ(MV_AUDIO_SPDIF_REC_GEN_REG(unit)) & ASRGR_VALID_PCM_INFO_MASK) ? MV_TRUE : MV_FALSE);
+
+}
+
+/* I2S Recording Related*/
+/*******************************************************************************
+* mvI2SRecordCntrlSet - Get I2S Recording status parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_I2S_RECORD_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_I2S_RECORD_CTRL structure
+* RETURN:
+*       MV_OK on success , MV_FAIL on fail.
+*
+*******************************************************************************/
+MV_STATUS mvI2SRecordCntrlSet(int unit, MV_I2S_RECORD_CTRL *ctrl)
+{
+	MV_U32 reg;
+
+#if 0
+	if (ctrl->sample > SAMPLE_16BIT) {
+		mvOsPrintf("mvI2SRecordCntrlSet: Error , Illigal sample size %d\n", ctrl->sample);
+		return MV_FAIL;
+	}
+#endif
+
+	reg = MV_REG_READ(MV_AUDIO_I2S_REC_CTRL_REG(unit));
+	reg &= ~(AIRCR_I2S_RECORD_JUSTF_MASK | AIRCR_I2S_SAMPLE_SIZE_MASK);
+
+	switch (ctrl->justf) {
+	case I2S_JUSTIFIED:
+	case LEFT_JUSTIFIED:
+	case RIGHT_JUSTIFIED:
+	case RISE_BIT_CLCK_JUSTIFIED:
+		reg |= ctrl->justf << AIRCR_I2S_RECORD_JUSTF_OFFS;
+		break;
+	default:
+		return MV_FAIL;
+	}
+
+	reg |= ctrl->sample << AIRCR_I2S_SAMPLE_SIZE_OFFS;
+
+	MV_REG_WRITE(MV_AUDIO_I2S_REC_CTRL_REG(unit), reg);
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAudioRecordControlGet - Get I2S Recording status parameters
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       ctrl: pointer to MV_I2S_RECORD_CTRL structure
+* OUTPUT:
+*		ctrl: pointer to MV_I2S_RECORD_CTRL structure
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvI2SRecordCntrlGet(int unit, MV_I2S_RECORD_CTRL *ctrl)
+{
+	ctrl->sample =
+	    ((MV_REG_READ(MV_AUDIO_I2S_REC_CTRL_REG(unit)) & AIRCR_I2S_SAMPLE_SIZE_MASK) >> AIRCR_I2S_SAMPLE_SIZE_OFFS);
+
+	ctrl->justf =
+	    ((MV_REG_READ(MV_AUDIO_I2S_REC_CTRL_REG(unit)) & AIRCR_I2S_RECORD_JUSTF_MASK) >>
+	     AIRCR_I2S_RECORD_JUSTF_OFFS);
+}
+
+/*******************************************************************************
+* audioBurstBytesNumGet - Convert Burst enum to bytes number
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       burst:  MV_AUDIO_BURST_SIZE  enum
+* OUTPUT:
+*		none
+* RETURN:
+*       number of burst bytes
+*
+*******************************************************************************/
+static MV_U32 audioBurstBytesNumGet(MV_AUDIO_BURST_SIZE burst)
+{
+	switch (burst) {
+	case AUDIO_32BYTE_BURST:
+		return 32;
+	case AUDIO_128BYTE_BURST:
+		return 128;
+	default:
+		return 0xffffffff;
+	}
+}
+
+#ifndef MV_AUDIO_SKIP_WIN_DECODING
+/*******************************************************************************
+* mvAudioReplaceAddrWin
+*
+* DESCRIPTION:
+*	This function is used to replace the address decoding windows of the
+*	recording / playback engines, in case the address given by the user is
+*	not within the configured window.
+*
+* INPUT:
+*       unit:  Audio unit ID.
+*	winId: Playback or Recording window.
+*	buffPhysAddr: The physical address of the buffer to be configured.
+*	buffSize: Size of buffPhysAddr.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_OK on success,
+*	MV_FAIL otherwise.
+*
+*******************************************************************************/
+static MV_STATUS mvAudioReplaceAddrWin(MV_U32 unit, MV_U32 winId, MV_U32 buffPhysAddr, MV_U32 buffSize)
+{
+	MV_UNIT_WIN_INFO audioWin;
+	MV_UNIT_WIN_INFO *winInfo;
+	MV_ADDR_WIN bufAddrWin;
+	MV_U32 target, i;
+
+	/* Get the details of the Record address window */
+	if (mvAudioWinRead(unit, winId, &audioWin) != MV_OK) {
+		mvOsPrintf("mvAudioRecordControlSet: Error calling mvAudioWinGet on win %d\n", unit);
+		return MV_FAIL;
+	}
+
+	bufAddrWin.baseHigh = 0;
+	bufAddrWin.baseLow = buffPhysAddr;
+	bufAddrWin.size = buffSize;
+
+	/* If Record window is not enabled or buffer address is not within window boundries
+	   then try to set a new value to the Record window by
+	   Geting the target of where the buffer exist, if the buffer is within the window
+	   of the new target then set the Record window to that target
+	   else return Fail
+	 */
+	if ((audioWin.enable != MV_TRUE) || (MV_TRUE != mvWinWithinWinTest(&bufAddrWin, &audioWin.addrWin))) {
+		/* Look for the target containing the phyBaseAddr */
+		for (i = 0; i < MAX_TARGETS; i++) {
+			winInfo = &audioAddrDecWinMap[i];
+
+			if ((buffPhysAddr >= winInfo->addrWin.baseLow) &&
+			    (buffPhysAddr < winInfo->addrWin.baseLow + winInfo->addrWin.size))
+				break;
+		}
+
+		/* Get the target of the buffer that user require */
+		target = i;
+		if (MAX_TARGETS == target) {
+			mvOsPrintf("mvAudioReplaceAddrWin: Address not found in any of the targets 0x%x\n",
+				   buffPhysAddr);
+			return MV_FAIL;
+		}
+
+		/* if the address window of the target is enabled and the user buffer is within
+		   that target address window then set the palyback\recording window to the
+		   target window
+		 */
+		if ((winInfo->enable == MV_TRUE) && (MV_TRUE == mvWinWithinWinTest(&bufAddrWin, &winInfo->addrWin))) {
+			if (mvAudioWinWrite(unit, winId, winInfo) != MV_OK) {
+				mvOsPrintf("mvAudioReplaceAddrWin: Error calling mvAudioWinWrite on win %d\n", winId);
+				return MV_FAIL;
+			}
+
+		} else {
+			mvOsPrintf("mvAudioReplaceAddrWin: Error buffer is not within a valid target\n");
+			return MV_FAIL;
+
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAudioSetAddDecMap
+*
+* DESCRIPTION:
+*	This function is called by the audio address decoding configuration
+*	function to initialize the address decoding map of the audio HAL.
+*	This info will be used by the mvAudioReplaceAddrWin() function.
+*
+* INPUT:
+*	pAddrDecWinMap: System's address deocding map.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_OK on success,
+*	MV_FAIL otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAudioSetAddDecMap(MV_UNIT_WIN_INFO *pAddrDecWinMap)
+{
+	mvOsMemcpy(audioAddrDecWinMap, pAddrDecWinMap, sizeof(audioAddrDecWinMap));
+	return MV_OK;
+}
+
+#endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/mvAudio.h
@@ -0,0 +1,398 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCMVAudioH
+#define __INCMVAudioH
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvSysAudioConfig.h"
+
+/*********************************/
+/* General enums and structures */
+/*********************************/
+
+	typedef struct {
+		MV_U32 tclk;
+	} MV_AUDIO_HAL_DATA;
+
+/* Audio source Clocks enum*/
+	typedef enum _mvAudioClock {
+		AUDIO_DCO_CLK = 0,
+		AUDIO_SPCR_CLK = 2,
+		AUDIO_EXT_CLK = 3
+	} MV_AUDIO_CLOCK;
+
+	typedef enum _mvAudioFreq {
+		AUDIO_FREQ_44_1KH = 0,	/* 11.2896Mhz */
+		AUDIO_FREQ_48KH = 1,	/* 12.288Mhz */
+		AUDIO_FREQ_96KH = 2,	/* 24.576Mhz */
+		AUDIO_FREQ_LOWER_44_1KH = 3,	/*Lower than 11.2896MHz */
+		AUDIO_FREQ_HIGHER_96KH = 4,	/*Higher than 24.576MHz */
+		AUDIO_FREQ_OTHER = 7,	/*Other frequency */
+	} MV_AUDIO_FREQ;
+
+	typedef enum _mvAudioSampleFreq {
+		SMAPLE_8KHZ = 0,
+		SMAPLE_16KHZ,
+		SMAPLE_22_05KHZ,
+		SMAPLE_24KHZ,
+		SMAPLE_32KHZ,
+		SMAPLE_44_1KHZ,
+		SMAPLE_48KHZ,
+		SMAPLE_64KHZ,
+		SMAPLE_88KHZ,
+		SMAPLE_96KHZ,
+		SMAPLE_176KHZ,
+		SMAPLE_192KHZ
+	} MV_AUDIO_SAMPLE_FREQ;
+
+	typedef enum _mvAudioBurstSize {
+		AUDIO_32BYTE_BURST = 1,
+		AUDIO_128BYTE_BURST = 2,
+
+	} MV_AUDIO_BURST_SIZE;
+
+	typedef enum _mvAudioPlaybackMono {
+		AUDIO_PLAY_MONO_OFF = 0,
+		AUDIO_PLAY_LEFT_MONO = 1,
+		AUDIO_PLAY_RIGHT_MONO = 2,
+		AUDIO_PLAY_BOTH_MONO = 3,
+		AUDIO_PLAY_OTHER_MONO = 4
+	} MV_AUDIO_PLAYBACK_MONO;
+
+	typedef enum _mvAudioRecordMono {
+		AUDIO_REC_LEFT_MONO = 0,
+		AUDIO_REC_RIGHT_MONO = 1,
+
+	} MV_AUDIO_RECORD_MONO;
+
+	typedef enum _mvAudioSampleSize {
+		SAMPLE_32BIT = 0,
+		SAMPLE_24BIT = 1,
+		SAMPLE_20BIT = 2,
+		SAMPLE_16BIT = 3,
+		SAMPLE_16BIT_NON_COMPACT = 7
+	} MV_AUDIO_SAMPLE_SIZE;
+
+	typedef enum _mvAudioI2SJustification {
+		LEFT_JUSTIFIED = 0,
+		I2S_JUSTIFIED = 5,
+		RISE_BIT_CLCK_JUSTIFIED = 7,
+		RIGHT_JUSTIFIED = 8,
+
+	} MV_AUDIO_I2S_JUSTIFICATION;
+
+/* Type of Audio operations*/
+	typedef enum _mvAudioOperation {
+		AUDIO_PLAYBACK = 0,
+		AUDIO_RECORD = 1
+	} MV_AUDIO_OP;
+
+	typedef struct _mvAudioFreqData {
+		MV_AUDIO_FREQ baseFreq;	/* Control FS, selects the base frequency of the DCO */
+		MV_U32 offset;	/* Offset control in which each step equals to 0.9536 ppm */
+
+	} MV_AUDIO_FREQ_DATA;
+
+/*********************************/
+/* Play Back related structures */
+/*********************************/
+
+	typedef struct _mvAudioPlaybackCtrl {
+		MV_AUDIO_BURST_SIZE burst;	/* Specifies the Burst Size of the DMA */
+		MV_BOOL loopBack;	/* When Loopback is enabled, playback
+					   data is looped back to be recorded */
+		MV_AUDIO_PLAYBACK_MONO monoMode;	/* Mono Mode is used */
+		MV_U32 bufferPhyBase;	/* Physical Address of DMA buffer */
+		MV_U32 bufferSize;	/* Size of DMA buffer */
+		MV_U32 intByteCount;	/* Number of bytes after which an
+					   interrupt will be issued. */
+		MV_AUDIO_SAMPLE_SIZE sampleSize;	/* Playback Sample Size */
+	} MV_AUDIO_PLAYBACK_CTRL;
+
+	typedef struct _mvAudioPlaypackStatus {
+		MV_BOOL muteI2S;
+		MV_BOOL enableI2S;
+		MV_BOOL muteSPDIF;
+		MV_BOOL enableSPDIF;
+		MV_BOOL pause;
+
+	} MV_AUDIO_PLAYBACK_STATUS;
+
+	typedef struct _mvSpdifPlaybackCtrl {
+		MV_BOOL nonPcm;	/* PCM or non-PCM mode */
+		MV_BOOL validity;	/* Validity bit value when using
+					   registers (userBitsFromMemory=0) */
+		MV_BOOL underrunData;	/* If true send last frame on mute/pause/underrun
+					   otherwise send 24 binary */
+		MV_BOOL userBitsFromMemory;	/* otherwise from intenal registers */
+		MV_BOOL validityFromMemory;	/* otherwise from internal registers */
+		MV_BOOL blockStartInternally;	/* When user and valid bits are form registers
+						   then this bit should be zero */
+	} MV_SPDIF_PLAYBACK_CTRL;
+
+	typedef struct _mvI2SPlaybackCtrl {
+		MV_AUDIO_SAMPLE_SIZE sampleSize;
+		MV_AUDIO_I2S_JUSTIFICATION justification;
+		MV_BOOL sendLastFrame;	/* If true send last frame on mute/pause/underrun
+					   otherwise send 64 binary */
+	} MV_I2S_PLAYBACK_CTRL;
+
+/*********************************/
+/* Recording  related structures */
+/*********************************/
+
+	typedef struct _mvAudioRecordCtrl {
+		MV_AUDIO_BURST_SIZE burst;	/* Recording DMA Burst Size */
+		MV_AUDIO_SAMPLE_SIZE sampleSize;	/*Recording Sample Size */
+		MV_BOOL mono;	/* If true then recording mono else recording stereo */
+		MV_AUDIO_RECORD_MONO monoChannel;	/* Left or right moono */
+		MV_U32 bufferPhyBase;	/* Physical Address of DMA buffer */
+		MV_U32 bufferSize;	/* Size of DMA buffer */
+
+		MV_U32 intByteCount;	/* Number of bytes after which an
+					   interrupt will be issued. */
+
+	} MV_AUDIO_RECORD_CTRL;
+
+	typedef struct _mvAudioRecordStatus {
+		MV_BOOL mute;
+		MV_BOOL pause;
+		MV_BOOL spdifEnable;
+		MV_BOOL I2SEnable;
+
+	} MV_AUDIO_RECORD_STATUS;
+
+	typedef struct _mvSPDIFRecordStatus {
+		MV_BOOL nonLinearPcm;	/* pcm non-pcm */
+		MV_BOOL validPcm;	/* valid non-valid pcm */
+		MV_AUDIO_SAMPLE_FREQ freq;	/* sampled frequency */
+
+	} MV_SPDIF_RECORD_STATUS;
+
+	typedef struct _mvI2SRecordCntrl {
+		MV_AUDIO_SAMPLE_SIZE sample;	/* I2S Recording Sample Size */
+		MV_AUDIO_I2S_JUSTIFICATION justf;
+	} MV_I2S_RECORD_CTRL;
+
+/*********************************/
+/* Usefull Macros 				*/
+/*
+ -- Clocks Control and Status related --
+mvAudioIsDcoLocked()
+mvAudioIsSpcrLocked()
+mvAudioIsPllLocked()
+mvAudioAllCountersClear()
+mvAudioPlayCounterClear()
+mvAudioRecCounterClear()
+mvAudioAllCountersStart()
+mvAudioPlayCounterStart()
+mvAudioRecCounterStart()
+mvAudioAllCountersStop()
+mvAudioPlayCounterStop()
+mvAudioRecCounterStop()
+
+ -- PlayBack related --
+mvAudioIsPlaybackBusy()
+mvAudioI2SPlaybackMute(mute)
+mvAudioI2SPlaybackEnable(enable)
+mvAudioSPDIFPlaybackMute(mute)
+mvAudioSPDIFPlaybackEnable(enable)
+mvAudioPlaybackPause(pause)
+
+---- Recording ---
+mvAudioSPDIFRecordingEnable(enable)
+mvAudioI2SRecordingEnable(enable)
+mvAudioRecordMute(mute)
+mvAudioRecordPause(pause)
+
+********************************/
+
+/* Clocks Control and Status related*/
+#define mvAudioIsDcoLocked()	\
+	(ASDSR_DCO_LOCK_MASK & MV_REG_READ(MV_AUDIO_SPCR_DCO_STATUS_REG))
+#define	mvAudioIsSpcrLocked()	\
+	(ASDSR_SPCR_LOCK_MASK & MV_REG_READ(AUDIO_SPCR_DCO_STATUS_REG))
+#define	mvAudioIsPllLocked()	\
+	(ASDSR_PLL_LOCK_MASK & MV_REG_READ(AUDIO_SPCR_DCO_STATUS_REG))
+
+#define mvAudioAllCountersClear()	\
+	(MV_REG_BIT_SET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_CLR_REC_CNTR_MASK|ASCCR_CLR_PLAY_CNTR_MASK)))
+#define mvAudioPlayCounterClear()	\
+	(MV_REG_BIT_SET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_CLR_PLAY_CNTR_MASK)))
+#define mvAudioRecCounterClear()	\
+	(MV_REG_BIT_SET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_CLR_REC_CNTR_MASK)))
+
+#define	mvAudioAllCountersStart()	\
+	(MV_REG_BIT_SET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_ACTIVE_PLAY_CNTR_MASK|ASCCR_ACTIVE_REC_CNTR_MASK)))
+#define mvAudioPlayCounterStart()	\
+	(MV_REG_BIT_SET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_ACTIVE_PLAY_CNTR_MASK)))
+#define mvAudioRecCounterStart()	\
+	(MV_REG_BIT_SET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_ACTIVE_REC_CNTR_MASK)))
+
+#define	mvAudioAllCountersStop()	\
+	(MV_REG_BIT_RESET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_ACTIVE_PLAY_CNTR_MASK|ASCCR_ACTIVE_REC_CNTR_MASK)))
+#define mvAudioPlayCounterStop()	\
+	(MV_REG_BIT_RESET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_ACTIVE_PLAY_CNTR_MASK)))
+#define mvAudioRecCounterStop()	\
+	(MV_REG_BIT_RESET(MV_AUDIO_SAMPLE_CNTR_CTRL_REG(0), (ASCCR_ACTIVE_REC_CNTR_MASK)))
+
+/* Audio PlayBack related*/
+#define	mvAudioIsPlaybackBusy()	\
+	(APCR_PLAY_BUSY_MASK & MV_REG_READ(MV_AUDIO_PLAYBACK_CTRL_REG(0)))
+
+#define	mvAudioI2SPlaybackMute(mute)	\
+	(void)((mute) ? (MV_REG_BIT_SET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_I2S_MUTE_MASK)) : 	\
+			 MV_REG_BIT_RESET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_I2S_MUTE_MASK))
+#define	mvAudioI2SPlaybackEnable(enable)	\
+	 (void)((enable) ? (MV_REG_BIT_SET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_I2S_ENABLE_MASK)) : 	\
+			  MV_REG_BIT_RESET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_I2S_ENABLE_MASK))
+
+#define	mvAudioSPDIFPlaybackMute(mute)	\
+	(void)((mute) ? (MV_REG_BIT_SET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_SPDIF_MUTE_MASK)) : 	\
+			 MV_REG_BIT_RESET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_SPDIF_MUTE_MASK))
+#define	mvAudioSPDIFPlaybackEnable(enable)	\
+	 (void)((enable) ? (MV_REG_BIT_SET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_SPDIF_ENABLE_MASK)) : 	\
+			  MV_REG_BIT_RESET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_SPDIF_ENABLE_MASK))
+
+#define	mvAudioAllIfPlaybackEnable(enable)	\
+	 (void)((enable) ?     \
+			(MV_REG_BIT_SET(MV_AUDIO_PLAYBACK_CTRL_REG(0),     \
+			(APCR_PLAY_I2S_ENABLE_MASK | APCR_PLAY_SPDIF_ENABLE_MASK))) : 	\
+			MV_REG_BIT_RESET(MV_AUDIO_PLAYBACK_CTRL_REG(0),  \
+			(APCR_PLAY_I2S_ENABLE_MASK | APCR_PLAY_SPDIF_ENABLE_MASK)))
+
+#define	mvAudioPlaybackPause(pause)	\
+	 (void)((pause) ? (MV_REG_BIT_SET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_PAUSE_MASK)) : 	\
+			  MV_REG_BIT_RESET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_PLAY_PAUSE_MASK))
+
+#define	mvAudioPlaybackLoopbackEnable(enable)	\
+	 (void)((enable) ? (MV_REG_BIT_SET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_LOOPBACK_MASK)) : 	\
+			  MV_REG_BIT_RESET(MV_AUDIO_PLAYBACK_CTRL_REG(0), APCR_LOOPBACK_MASK))
+
+/* Audio Recording*/
+#define	mvAudioSPDIFRecordingEnable(enable)	\
+	 (void)((enable) ? (MV_REG_BIT_SET(MV_AUDIO_RECORD_CTRL_REG(0), ARCR_RECORD_SPDIF_EN_MASK)) : 	\
+			  MV_REG_BIT_RESET(MV_AUDIO_RECORD_CTRL_REG(0), ARCR_RECORD_SPDIF_EN_MASK))
+
+#define	mvAudioI2SRecordingEnable(enable)	\
+	 (void)((enable) ? (MV_REG_BIT_SET(MV_AUDIO_RECORD_CTRL_REG(0), ARCR_RECORD_I2S_EN_MASK)) : 	\
+			  MV_REG_BIT_RESET(MV_AUDIO_RECORD_CTRL_REG(0), ARCR_RECORD_I2S_EN_MASK))
+
+#define mvAudioRecordMute(mute)	\
+	 (void)((mute) ? (MV_REG_BIT_SET(MV_AUDIO_RECORD_CTRL_REG(0), ARCR_RECORD_MUTE_MASK)) : 	\
+			  MV_REG_BIT_RESET(MV_AUDIO_RECORD_CTRL_REG(0), ARCR_RECORD_MUTE_MASK))
+
+#define mvAudioRecordPause(pause)	\
+	 (void)((pause) ? (MV_REG_BIT_SET(MV_AUDIO_RECORD_CTRL_REG(0), ARCR_RECORD_PAUSE_MASK)) : 	\
+			  MV_REG_BIT_RESET(MV_AUDIO_RECORD_CTRL_REG(0), ARCR_RECORD_PAUSE_MASK))
+
+/*********************************/
+/* Functions API 				*/
+/*********************************/
+
+	MV_VOID mvAudioHalInit(MV_U8 unit, MV_AUDIO_HAL_DATA *halData);
+	MV_STATUS mvAudioWinInit(MV_U32 unit, MV_UNIT_WIN_INFO *addrWinMap);
+	MV_STATUS mvAudioWinRead(MV_U32 unit, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWin);
+	MV_STATUS mvAudioWinWrite(MV_U32 unit, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWin);
+
+/* Clocks Control and Status related*/
+	MV_STATUS mvAudioDCOCtrlSet(int unit, MV_AUDIO_FREQ_DATA *dcoCtrl);
+	MV_VOID mvAudioDCOCtrlGet(int unit, MV_AUDIO_FREQ_DATA *dcoCtrl);
+	MV_VOID mvAudioSpcrCtrlGet(int unit, MV_AUDIO_FREQ_DATA *spcrCtrl);
+
+/* Audio PlayBack related*/
+	MV_STATUS mvAudioPlaybackControlSet(int unit, MV_AUDIO_PLAYBACK_CTRL *ctrl);
+	MV_VOID mvAudioPlaybackControlGet(int unit, MV_AUDIO_PLAYBACK_CTRL *ctrl);
+	MV_VOID mvAudioPlaybackStatusGet(int unit, MV_AUDIO_PLAYBACK_STATUS *status);
+
+/* Audio SPDIF PlayBack related*/
+	MV_VOID mvSPDIFPlaybackCtrlSet(int unit, MV_SPDIF_PLAYBACK_CTRL *ctrl);
+	MV_VOID mvSPDIFPlaybackCtrlGet(int unit, MV_SPDIF_PLAYBACK_CTRL *ctrl);
+
+/* Audio I2S PlayBack related*/
+	MV_STATUS mvI2SPlaybackCtrlSet(int unit, MV_I2S_PLAYBACK_CTRL *ctrl);
+	MV_VOID mvI2SPlaybackCtrlGet(int unit, MV_I2S_PLAYBACK_CTRL *ctrl);
+
+/* Audio Recording*/
+	MV_STATUS mvAudioRecordControlSet(int unit, MV_AUDIO_RECORD_CTRL *ctrl);
+	MV_VOID mvAudioRecordControlGet(int unit, MV_AUDIO_RECORD_CTRL *ctrl);
+	MV_VOID mvAudioRecordStatusGet(int unit, MV_AUDIO_RECORD_STATUS *status);
+
+/* SPDIF Recording Related*/
+	MV_STATUS mvSPDIFRecordTclockSet(int unit);
+	MV_U32 mvSPDIFRecordTclockGet(int unit);
+	MV_VOID mvSPDIFRecordStatusGet(int unit, MV_SPDIF_RECORD_STATUS *status);
+
+/* I2S Recording Related*/
+	MV_STATUS mvI2SRecordCntrlSet(int unit, MV_I2S_RECORD_CTRL *ctrl);
+	MV_VOID mvI2SRecordCntrlGet(int unit, MV_I2S_RECORD_CTRL *ctrl);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/mvAudioAddrDec.c
@@ -0,0 +1,251 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvAudioRegs.h"
+
+#ifndef MV_AUDIO_SKIP_WIN_DECODING
+extern MV_STATUS mvAudioSetAddDecMap(MV_UNIT_WIN_INFO *pAddrDecWinMap);
+#endif
+
+/*******************************************************************************
+* mvAudioWinWrite
+*
+* DESCRIPTION:
+*	This function writes the address decoding registers according to the
+*	given window configuration.
+*
+* INPUT:
+*       unit	    - The Audio unit number to configure.
+*       winNum	    - AUDIO target address decode window number.
+*       pAddrDecWin - AUDIO target window data structure.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*   MV_OK on success,
+*	MV_BAD_PARAM if winNum is invalid.
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAudioWinWrite(MV_U32 unit, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWin)
+{
+	MV_U32 baseReg;
+	MV_U32 sizeReg;
+	MV_U32 size;
+	MV_U32 alignment;
+
+	/* Parameter checking   */
+	if (winNum >= MV_AUDIO_MAX_ADDR_DECODE_WIN) {
+		mvOsPrintf("%s: ERR. Invalid win num %d\n", __func__, winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
+		mvOsPrintf("mvAudioWinWrite:Error setting AUDIO window %d to "
+			   "Address 0x%08x is unaligned to size 0x%x.\n",
+			   winNum, pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	size = pAddrDecWin->addrWin.size;
+	if (!MV_IS_POWER_OF_2(size)) {
+		mvOsPrintf("mvAudioWinWrite: Error setting AUDIO window %d. "
+			   "Window size is not a power to 2.", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	alignment = 1 << MV_AUDIO_WIN_SIZE_OFFSET;
+
+	sizeReg = (size / alignment - 1) << MV_AUDIO_WIN_SIZE_OFFSET;
+
+	/* BaseLow[31:16] => base register [31:16]          */
+	baseReg = pAddrDecWin->addrWin.baseLow & MV_AUDIO_WIN_BASE_MASK;
+
+	/* set attributes */
+	sizeReg &= ~MV_AUDIO_WIN_ATTR_MASK;
+	sizeReg |= (pAddrDecWin->attrib << MV_AUDIO_WIN_ATTR_OFFSET);
+
+	/* set target ID */
+	sizeReg &= ~MV_AUDIO_WIN_TARGET_MASK;
+	sizeReg |= (pAddrDecWin->targetId << MV_AUDIO_WIN_TARGET_OFFSET);
+
+	if (pAddrDecWin->enable == MV_TRUE)
+		sizeReg |= MV_AUDIO_WIN_ENABLE_MASK;
+	else
+		sizeReg &= ~MV_AUDIO_WIN_ENABLE_MASK;
+
+	MV_REG_WRITE(MV_AUDIO_WIN_CTRL_REG(unit, winNum), sizeReg);
+	MV_REG_WRITE(MV_AUDIO_WIN_BASE_REG(unit, winNum), baseReg);
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAudioWinRead
+*
+* DESCRIPTION:
+*       Read AUDIO peripheral target address window.
+*
+* INPUT:
+*       winNum - AUDIO target address decode window number.
+*
+* OUTPUT:
+*       pAddrDecWin - AUDIO target window data structure.
+*
+* RETURN:
+*	MV_BAD_PARAM if winNum is invalid.
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAudioWinRead(MV_U32 unit, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWin)
+{
+	MV_U32 baseReg, sizeReg;
+	MV_U32 sizeRegVal;
+	MV_U32 alignment;
+
+	if (winNum >= MV_AUDIO_MAX_ADDR_DECODE_WIN) {
+		mvOsPrintf("%s : ERR. Invalid winNum %d\n", __func__, winNum);
+		return MV_BAD_PARAM;
+	}
+
+	baseReg = MV_REG_READ(MV_AUDIO_WIN_BASE_REG(unit, winNum));
+	sizeReg = MV_REG_READ(MV_AUDIO_WIN_CTRL_REG(unit, winNum));
+
+	alignment = 1 << MV_AUDIO_WIN_SIZE_OFFSET;
+	sizeRegVal = (sizeReg & MV_AUDIO_WIN_SIZE_MASK) >> MV_AUDIO_WIN_SIZE_OFFSET;
+
+	pAddrDecWin->addrWin.size = (sizeRegVal + 1) * alignment;
+
+	/* Extract base address                                             */
+	/* Base register [31:16] ==> baseLow[31:16]                 */
+	pAddrDecWin->addrWin.baseLow = baseReg & MV_AUDIO_WIN_BASE_MASK;
+	pAddrDecWin->addrWin.baseHigh = 0;
+
+	/* attrib and targetId */
+	pAddrDecWin->attrib = (sizeReg & MV_AUDIO_WIN_ATTR_MASK) >> MV_AUDIO_WIN_ATTR_OFFSET;
+	pAddrDecWin->targetId = (sizeReg & MV_AUDIO_WIN_TARGET_MASK) >> MV_AUDIO_WIN_TARGET_OFFSET;
+
+	/* Check if window is enabled   */
+	if (sizeReg & MV_AUDIO_WIN_ENABLE_MASK)
+		pAddrDecWin->enable = MV_TRUE;
+	else
+		pAddrDecWin->enable = MV_FALSE;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAudioWinInit
+*
+* DESCRIPTION:
+*       Initialize the AUDIO peripheral target address window.
+*
+* INPUT:
+*	unit	 : The unit number to initialize the address decoding for.
+*	addWinMap: An array holding the address decoding information for the
+*		    system.
+*
+* OUTPUT:
+*     None.
+*
+* RETURN:
+*       MV_ERROR if register parameters are invalid.
+*
+*******************************************************************************/
+MV_STATUS mvAudioWinInit(MV_U32 unit, MV_UNIT_WIN_INFO *addrWinMap)
+{
+	MV_32 winNum;
+	MV_UNIT_WIN_INFO *cpuAddrDecWin;
+
+	/* Initiate Audio address decode */
+
+	/* First disable all address decode windows */
+	for (winNum = 0; winNum < MV_AUDIO_MAX_ADDR_DECODE_WIN; winNum++) {
+		MV_U32 regVal = MV_REG_READ(MV_AUDIO_WIN_CTRL_REG(unit, winNum));
+		regVal &= ~MV_AUDIO_WIN_ENABLE_MASK;
+		MV_REG_WRITE(MV_AUDIO_WIN_CTRL_REG(unit, winNum), regVal);
+	}
+
+	for (winNum = 0; winNum < MV_AUDIO_MAX_ADDR_DECODE_WIN; winNum++) {
+		/* We will set the Window to DRAM_CS0 in default */
+		/* first get attributes from CPU If */
+		cpuAddrDecWin = &addrWinMap[SDRAM_CS0];
+
+		if (cpuAddrDecWin->enable == MV_TRUE) {
+			if (MV_OK != mvAudioWinWrite(unit, winNum, cpuAddrDecWin))
+				return MV_ERROR;
+		}
+	}
+
+#ifndef MV_AUDIO_SKIP_WIN_DECODING
+	/* Initialize the address decoding map in the audio driver */
+	mvAudioSetAddDecMap(addrWinMap);
+#endif
+
+	return MV_OK;
+}
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/mvAudioRegs.h
@@ -0,0 +1,356 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCMVAudioRegsH
+#define __INCMVAudioRegsH
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mvSysAudioConfig.h"
+
+#define APBBCR_SIZE_MAX						0x3FFFFF
+#define APBBCR_SIZE_SHIFT					0x2
+
+#define AUDIO_REG_TO_SIZE(reg)		(((reg) + 1) << APBBCR_SIZE_SHIFT)
+#define AUDIO_SIZE_TO_REG(size)		(((size) >> APBBCR_SIZE_SHIFT) - 1)
+
+#define MV_AUDIO_BUFFER_MIN_ALIGN	0x8
+
+/********************/
+/* Clocking Control*/
+/*******************/
+#define MV_AUDIO_PLL_CTRL1_REG(unit)			(MV_AUDIO_REGS_BASE(unit) + 0x1200)
+#define MV_AUDIO_DCO_CTRL_REG(unit)			(MV_AUDIO_REGS_BASE(unit) + 0x1204)
+#define MV_AUDIO_SPCR_DCO_STATUS_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x120c)
+#define MV_AUDIO_SAMPLE_CNTR_CTRL_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1220)
+#define MV_AUDIO_PLAYBACK_SAMPLE_CNTR_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1224)
+#define MV_AUDIO_RECORD_SAMPLE_CNTR_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1228)
+#define MV_AUDIO_CLOCK_CTRL_REG(unit)			(MV_AUDIO_REGS_BASE(unit) + 0x1230)
+
+/* MV_AUDIO_DCO_CTRL_REG */
+#define ADCR_DCO_CTRL_FS_OFFS		0
+#define ADCR_DCO_CTRL_FS_MASK		(0x3 << ADCR_DCO_CTRL_FS_OFFS)
+#define ADCR_DCO_CTRL_FS_44_1KHZ	(0x0 << ADCR_DCO_CTRL_FS_OFFS)
+#define ADCR_DCO_CTRL_FS_48KHZ		(0x1 << ADCR_DCO_CTRL_FS_OFFS)
+#define ADCR_DCO_CTRL_FS_96KHZ		(0x2 << ADCR_DCO_CTRL_FS_OFFS)
+
+#define ADCR_DCO_CTRL_OFFSET_OFFS	2
+#define ADCR_DCO_CTRL_OFFSET_MASK	(0xfff << ADCR_DCO_CTRL_OFFSET_OFFS)
+
+/* MV_AUDIO_SPCR_DCO_STATUS_REG */
+#define ASDSR_SPCR_CTRLFS_OFFS		0
+#define ASDSR_SPCR_CTRLFS_MASK		(0x7 << ASDSR_SPCR_CTRLFS_OFFS)
+#define ASDSR_SPCR_CTRLFS_44_1KHZ	(0x0 << ASDSR_SPCR_CTRLFS_OFFS)
+#define ASDSR_SPCR_CTRLFS_48KHZ		(0x1 << ASDSR_SPCR_CTRLFS_OFFS)
+#define ASDSR_SPCR_CTRLFS_96KHZ		(0x2 << ASDSR_SPCR_CTRLFS_OFFS)
+#define ASDSR_SPCR_CTRLFS_44_1KHZ_LESS	(0x3 << ASDSR_SPCR_CTRLFS_OFFS)
+#define ASDSR_SPCR_CTRLFS_96KHZ_MORE	(0x4 << ASDSR_SPCR_CTRLFS_OFFS)
+#define ASDSR_SPCR_CTRLFS_OTHER		(0x7 << ASDSR_SPCR_CTRLFS_OFFS)
+
+#define ASDSR_SPCR_CTRLOFFSET_OFFS	3
+#define ASDSR_SPCR_CTRLOFFSET_MASK	(0xfff << ASDSR_SPCR_CTRLOFFSET_OFFS)
+
+#define ASDSR_SPCR_LOCK_OFFS		15
+#define ASDSR_SPCR_LOCK_MASK		(0x1 << ASDSR_SPCR_LOCK_OFFS)
+
+#define ASDSR_DCO_LOCK_OFFS		16
+#define ASDSR_DCO_LOCK_MASK		(0x1 << ASDSR_DCO_LOCK_OFFS)
+
+#define ASDSR_PLL_LOCK_OFFS		17
+#define ASDSR_PLL_LOCK_MASK		(0x1 << ASDSR_PLL_LOCK_OFFS)
+
+/*MV_AUDIO_SAMPLE_CNTR_CTRL_REG */
+
+#define ASCCR_CLR_PLAY_CNTR_OFFS	9
+#define ASCCR_CLR_PLAY_CNTR_MASK	(0x1 << ASCCR_CLR_PLAY_CNTR_OFFS)
+
+#define ASCCR_CLR_REC_CNTR_OFFS		8
+#define ASCCR_CLR_REC_CNTR_MASK		(0x1 << ASCCR_CLR_REC_CNTR_OFFS)
+
+#define ASCCR_ACTIVE_PLAY_CNTR_OFFS	1
+#define ASCCR_ACTIVE_PLAY_CNTR_MASK	(0x1 << ASCCR_ACTIVE_PLAY_CNTR_OFFS)
+
+#define ASCCR_ACTIVE_REC_CNTR_OFFS	0
+#define ASCCR_ACTIVE_REC_CNTR_MASK	(0x1 << ASCCR_ACTIVE_REC_CNTR_OFFS)
+
+/* MV_AUDIO_CLOCK_CTRL_REG */
+#define ACCR_MCLK_SOURCE_OFFS		0
+#define ACCR_MCLK_SOURCE_MASK		(0x3 << ACCR_MCLK_SOURCE_OFFS)
+#define ACCR_MCLK_SOURCE_DCO		(0x0 << ACCR_MCLK_SOURCE_OFFS)
+#define ACCR_MCLK_SOURCE_SPCR		(0x2 << ACCR_MCLK_SOURCE_OFFS)
+#define ACCR_MCLK_SOURCE_EXT		(0x3 << ACCR_MCLK_SOURCE_OFFS)
+
+/********************/
+/* Interrupts		*/
+/*******************/
+#define MV_AUDIO_ERROR_CAUSE_REG(unit)			(MV_AUDIO_REGS_BASE(unit) + 0x1300)
+#define MV_AUDIO_ERROR_MASK_REG(unit)			(MV_AUDIO_REGS_BASE(unit) + 0x1304)
+#define MV_AUDIO_INT_CAUSE_REG(unit)			(MV_AUDIO_REGS_BASE(unit) + 0x1308)
+#define MV_AUDIO_INT_MASK_REG(unit)			(MV_AUDIO_REGS_BASE(unit) + 0x130C)
+#define MV_AUDIO_RECORD_BYTE_CNTR_INT_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1310)
+#define MV_AUDIO_PLAYBACK_BYTE_CNTR_INT_REG(unit)	(MV_AUDIO_REGS_BASE(unit) + 0x1314)
+
+/* MV_AUDIO_INT_CAUSE_REG*/
+#define AICR_RECORD_BYTES_INT			(0x1 << 13)
+#define AICR_PLAY_BYTES_INT			(0x1 << 14)
+
+#define ARBCI_BYTE_COUNT_MASK                   0xFFFFFF
+#define APBCI_BYTE_COUNT_MASK                   0xFFFFFF
+
+/********************/
+/* Audio Playback	*/
+/*******************/
+/* General */
+#define MV_AUDIO_PLAYBACK_CTRL_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1100)
+#define MV_AUDIO_PLAYBACK_BUFF_START_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1104)
+#define MV_AUDIO_PLAYBACK_BUFF_SIZE_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1108)
+#define MV_AUDIO_PLAYBACK_BUFF_BYTE_CNTR_REG(unit)	(MV_AUDIO_REGS_BASE(unit) + 0x110c)
+
+/* SPDIF */
+#define MV_AUDIO_SPDIF_PLAY_CTRL_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x2204)
+#define MV_AUDIO_SPDIF_PLAY_CH_STATUS_LEFT_REG(unit, ind)	        \
+					(MV_AUDIO_REGS_BASE(unit) + 0x2280 + (ind << 2))
+#define MV_AUDIO_SPDIF_PLAY_CH_STATUS_RIGHT_REG(unit, ind)	    \
+					(MV_AUDIO_REGS_BASE(unit) + 0x22a0 + (ind << 2))
+#define MV_AUDIO_SPDIF_PLAY_USR_BITS_LEFT_REG(unit, ind)          \
+					(MV_AUDIO_REGS_BASE(unit) + 0x22c0 + (ind << 2))
+#define MV_AUDIO_SPDIF_PLAY_USR_BITS_RIGHT_REG(unit, ind)              \
+					(MV_AUDIO_REGS_BASE(unit) + 0x22e0 + (ind << 2))
+/*I2S*/
+#define MV_AUDIO_I2S_PLAY_CTRL_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x2508)
+
+/* MV_AUDIO_PLAYBACK_CTRL_REG */
+#define APCR_PLAY_SAMPLE_SIZE_OFFS			0
+#define APCR_PLAY_SAMPLE_SIZE_MASK			(0x7 << APCR_PLAY_SAMPLE_SIZE_OFFS)
+
+#define APCR_PLAY_I2S_ENABLE_OFFS			3
+#define APCR_PLAY_I2S_ENABLE_MASK			(0x1 << APCR_PLAY_I2S_ENABLE_OFFS)
+
+#define APCR_PLAY_SPDIF_ENABLE_OFFS			4
+#define APCR_PLAY_SPDIF_ENABLE_MASK			(0x1 << APCR_PLAY_SPDIF_ENABLE_OFFS)
+
+#define APCR_PLAY_MONO_OFFS				5
+#define APCR_PLAY_MONO_MASK				(0x3 << APCR_PLAY_MONO_OFFS)
+
+#define APCR_PLAY_I2S_MUTE_OFFS				7
+#define APCR_PLAY_I2S_MUTE_MASK				(0x1 << APCR_PLAY_I2S_MUTE_OFFS)
+
+#define APCR_PLAY_SPDIF_MUTE_OFFS			8
+#define APCR_PLAY_SPDIF_MUTE_MASK			(0x1 << APCR_PLAY_SPDIF_MUTE_OFFS)
+
+#define APCR_PLAY_PAUSE_OFFS				9
+#define APCR_PLAY_PAUSE_MASK				(0x1 << APCR_PLAY_PAUSE_OFFS)
+
+#define APCR_LOOPBACK_OFFS				10
+#define APCR_LOOPBACK_MASK				(0x1 << APCR_LOOPBACK_OFFS)
+
+#define APCR_PLAY_BURST_SIZE_OFFS			11
+#define APCR_PLAY_BURST_SIZE_MASK			(0x3 << APCR_PLAY_BURST_SIZE_OFFS)
+
+#define APCR_PLAY_BUSY_OFFS				16
+#define APCR_PLAY_BUSY_MASK				(0x1 << APCR_PLAY_BUSY_OFFS)
+
+/* MV_AUDIO_PLAYBACK_BUFF_BYTE_CNTR_REG */
+#define APBBCR_SIZE_MAX					0x3FFFFF
+#define APBBCR_SIZE_SHIFT				0x2
+
+/* MV_AUDIO_SPDIF_PLAY_CTRL_REG */
+#define ASPCR_SPDIF_BLOCK_START_OFFS		0x0
+#define ASPCR_SPDIF_BLOCK_START_MASK		(0x1 << ASPCR_SPDIF_BLOCK_START_OFFS)
+
+#define ASPCR_SPDIF_PB_EN_MEM_VALIDITY_OFFS	0x1
+#define ASPCR_SPDIF_PB_EN_MEM_VALIDITY_MASK	(0x1 << ASPCR_SPDIF_PB_EN_MEM_VALIDITY_OFFS)
+
+#define ASPCR_SPDIF_PB_MEM_USR_EN_OFFS		0x2
+#define ASPCR_SPDIF_PB_MEM_USR_EN_MASK		(0x1 << ASPCR_SPDIF_PB_MEM_USR_EN_OFFS)
+
+#define ASPCR_SPDIF_UNDERRUN_DATA_OFFS		0x5
+#define ASPCR_SPDIF_UNDERRUN_DATA_MASK		(0x1 << ASPCR_SPDIF_UNDERRUN_DATA_OFFS)
+
+#define ASPCR_SPDIF_PB_REG_VALIDITY_OFFS	16
+#define ASPCR_SPDIF_PB_REG_VALIDITY_MASK	(0x1 << ASPCR_SPDIF_PB_REG_VALIDITY_OFFS)
+
+#define ASPCR_SPDIF_PB_NONPCM_OFFS		17
+#define ASPCR_SPDIF_PB_NONPCM_MASK		(0x1 << ASPCR_SPDIF_PB_NONPCM_OFFS)
+
+/* MV_AUDIO_I2S_PLAY_CTRL_REG */
+#define AIPCR_I2S_SEND_LAST_FRM_OFFS		23
+#define AIPCR_I2S_SEND_LAST_FRM_MASK		(1 << AIPCR_I2S_SEND_LAST_FRM_OFFS)
+
+#define AIPCR_I2S_PB_JUSTF_OFFS			26
+#define AIPCR_I2S_PB_JUSTF_MASK			(0xf << AIPCR_I2S_PB_JUSTF_OFFS)
+
+#define AIPCR_I2S_PB_SAMPLE_SIZE_OFFS		30
+#define AIPCR_I2S_PB_SAMPLE_SIZE_MASK		(0x3 << AIPCR_I2S_PB_SAMPLE_SIZE_OFFS)
+
+/********************/
+/* Audio Recordnig	*/
+/*******************/
+/* General */
+#define MV_AUDIO_RECORD_CTRL_REG(unit)			(MV_AUDIO_REGS_BASE(unit) + 0x1000)
+#define MV_AUDIO_RECORD_START_ADDR_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1004)
+#define MV_AUDIO_RECORD_BUFF_SIZE_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x1008)
+#define MV_AUDIO_RECORD_BUF_BYTE_CNTR_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x100C)
+
+/*SPDIF */
+#define MV_AUDIO_SPDIF_REC_GEN_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x2004)
+#define MV_AUDIO_SPDIF_REC_INT_CAUSE_MASK_REG(unit)	(MV_AUDIO_REGS_BASE(unit) + 0x2008)
+#define MV_AUDIO_SPDIF_REC_CH_STATUS_LEFT_REG(unit, ind)                  \
+						(MV_AUDIO_REGS_BASE(unit) + 0x2180 + ((ind) << 2))
+#define MV_AUDIO_SPDIF_REC_CH_STATUS_RIGHT_REG(unit, ind)                 \
+						(MV_AUDIO_REGS_BASE(unit) + 0x21a0 + ((ind) << 2))
+#define MV_AUDIO_SPDIF_REC_USR_BITS_LEFT_REG(unit, ind)                   \
+						(MV_AUDIO_REGS_BASE(unit) + 0x21c0 + ((ind) << 2))
+#define MV_AUDIO_SPDIF_REC_USR_BITS_RIGHT_REG(unit, ind)                  \
+						(MV_AUDIO_REGS_BASE(unit) + 0x21e0 + ((ind) << 2))
+
+/*I2S*/
+#define MV_AUDIO_I2S_REC_CTRL_REG(unit)		(MV_AUDIO_REGS_BASE(unit) + 0x2408)
+
+/* MV_AUDIO_RECORD_CTRL_REG*/
+#define ARCR_RECORD_SAMPLE_SIZE_OFFS   	  	0
+#define ARCR_RECORD_SAMPLE_SIZE_MASK   	  	(0x7 << ARCR_RECORD_SAMPLE_SIZE_OFFS)
+
+#define ARCR_RECORDED_MONO_CHNL_OFFS   	  	3
+#define ARCR_RECORDED_MONO_CHNL_MASK   	  	(0x1 << ARCR_RECORDED_MONO_CHNL_OFFS)
+
+#define ARCR_RECORD_MONO_OFFS		   	4
+#define ARCR_RECORD_MONO_MASK		   	(0x1 << ARCR_RECORD_MONO_OFFS)
+
+#define ARCR_RECORD_BURST_SIZE_OFFS	   	5
+#define ARCR_RECORD_BURST_SIZE_MASK	   	(0x3 << ARCR_RECORD_BURST_SIZE_OFFS)
+
+#define ARCR_RECORD_MUTE_OFFS		   	8
+#define ARCR_RECORD_MUTE_MASK		   	(0x1 << ARCR_RECORD_MUTE_OFFS)
+
+#define ARCR_RECORD_PAUSE_OFFS		   	9
+#define ARCR_RECORD_PAUSE_MASK		   	(0x1 << ARCR_RECORD_PAUSE_OFFS)
+
+#define ARCR_RECORD_I2S_EN_OFFS		   	10
+#define ARCR_RECORD_I2S_EN_MASK		   	(0x1 << ARCR_RECORD_I2S_EN_OFFS)
+
+#define ARCR_RECORD_SPDIF_EN_OFFS	   	11
+#define ARCR_RECORD_SPDIF_EN_MASK	   	(0x1 << ARCR_RECORD_SPDIF_EN_OFFS)
+
+/* MV_AUDIO_SPDIF_REC_GEN_REG*/
+#define ASRGR_CORE_CLK_FREQ_OFFS		1
+#define ASRGR_CORE_CLK_FREQ_MASK		(0x3 << ASRGR_CORE_CLK_FREQ_OFFS)
+#define ASRGR_CORE_CLK_FREQ_133MHZ		(0x0 << ASRGR_CORE_CLK_FREQ_OFFS)
+#define ASRGR_CORE_CLK_FREQ_150MHZ		(0x1 << ASRGR_CORE_CLK_FREQ_OFFS)
+#define ASRGR_CORE_CLK_FREQ_166MHZ		(0x2 << ASRGR_CORE_CLK_FREQ_OFFS)
+#define ASRGR_CORE_CLK_FREQ_200MHZ		(0x3 << ASRGR_CORE_CLK_FREQ_OFFS)
+
+#define ASRGR_VALID_PCM_INFO_OFFS		7
+#define ASRGR_VALID_PCM_INFO_MASK		(0x1 << ASRGR_VALID_PCM_INFO_OFFS)
+
+#define ASRGR_SAMPLE_FREQ_OFFS			8
+#define ASRGR_SAMPLE_FREQ_MASK			(0xf << ASRGR_SAMPLE_FREQ_OFFS)
+
+#define ASRGR_NON_PCM_OFFS			14
+#define ASRGR_NON_PCM_MASK			(1 << ASRGR_NON_PCM_OFFS)
+
+/* MV_AUDIO_I2S_REC_CTRL_REG*/
+#define AIRCR_I2S_RECORD_JUSTF_OFFS		26
+#define AIRCR_I2S_RECORD_JUSTF_MASK		(0xf << AIRCR_I2S_RECORD_JUSTF_OFFS)
+
+#define AIRCR_I2S_SAMPLE_SIZE_OFFS		30
+#define AIRCR_I2S_SAMPLE_SIZE_MASK		(0x3 << AIRCR_I2S_SAMPLE_SIZE_OFFS)
+
+/*
+** Address decoding related.
+*/
+
+#define MV_AUDIO_MAX_ADDR_DECODE_WIN 		2
+#define MV_AUDIO_RECORD_WIN_NUM			0
+#define MV_AUDIO_PLAYBACK_WIN_NUM		1
+
+#define MV_AUDIO_WIN_CTRL_REG(unit, win)	(MV_AUDIO_REGS_BASE(unit) + 0xA04 + ((win)<<3))
+#define MV_AUDIO_WIN_BASE_REG(unit, win)	(MV_AUDIO_REGS_BASE(unit) + 0xA00 + ((win)<<3))
+
+#define MV_AUDIO_RECORD_WIN_CTRL_REG(unit)	MV_AUDIO_WIN_CTRL_REG(unit, MV_AUDIO_RECORD_WIN_NUM)
+#define MV_AUDIO_RECORD_WIN_BASE_REG(unit)	MV_AUDIO_WIN_BASE_REG(unit, MV_AUDIO_RECORD_WIN_NUM)
+#define MV_AUDIO_PLAYBACK_WIN_CTRL_REG(unit)	MV_AUDIO_WIN_CTRL_REG(unit, MV_AUDIO_PLAYBACK_WIN_NUM)
+#define MV_AUDIO_PLAYBACK_WIN_BASE_REG(unit)	MV_AUDIO_WIN_BASE_REG(unit, MV_AUDIO_PLAYBACK_WIN_NUM)
+
+/* BITs in Windows 0-3 Control and Base Registers */
+#define MV_AUDIO_WIN_ENABLE_BIT               0
+#define MV_AUDIO_WIN_ENABLE_MASK              (1<<MV_AUDIO_WIN_ENABLE_BIT)
+
+#define MV_AUDIO_WIN_TARGET_OFFSET            4
+#define MV_AUDIO_WIN_TARGET_MASK              (0xF<<MV_AUDIO_WIN_TARGET_OFFSET)
+
+#define MV_AUDIO_WIN_ATTR_OFFSET              8
+#define MV_AUDIO_WIN_ATTR_MASK                (0xFF<<MV_AUDIO_WIN_ATTR_OFFSET)
+
+#define MV_AUDIO_WIN_SIZE_OFFSET              16
+#define MV_AUDIO_WIN_SIZE_MASK                (0xFFFF<<MV_AUDIO_WIN_SIZE_OFFSET)
+
+#define MV_AUDIO_WIN_BASE_OFFSET              16
+#define MV_AUDIO_WIN_BASE_MASK                (0xFFFF<<MV_AUDIO_WIN_BASE_OFFSET)
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* __INCMVAudioRegsH */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/audio/mvCompVer.txt
@@ -0,0 +1,3 @@
+Global HAL Version: FEROCEON_HAL_3_1_7
+Unit HAL Version: 3.1.3
+Description: This component includes an implementation of the unit HAL drivers
--- a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c
+++ b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c
@@ -67,7 +67,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "mvSysCntmrConfig.h"
 #include "mvCntmrRegs.h"
-#include "cntmr/mvCntmr.h"
+#include "mvCntmr.h"
 #include "cpu/mvCpu.h"
 
 /* defines  */
@@ -79,7 +79,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 
 #define CNTMR_EVENTS_STATUS_REG_GLOBAL	(MV_CNTMR_REGS_OFFSET + 4)
 
+#if defined(CONFIG_ARCH_ARMADA370)
+#define TIMER_GLOBAL_BIT(timer)		(1 << (timer * 8 - ((timer == MAX_GLOBAL_TIMER) ? 1 : 0)))
+#else
 #define TIMER_GLOBAL_BIT(timer)		((timer == MAX_GLOBAL_TIMER) ? (1<<31) : (1 << (timer * 8)))
+#endif
 
 #if defined(MV88F78X60_Z1)
 #define CNTMR_EVENTS_STATUS_REG_PRIVATE(t)	(MV_CPUIF_REGS_OFFSET(TIMER_TO_CPU(t) + 0x68))
@@ -87,6 +91,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #elif defined(MV88F78X60_A0) || defined(MV88F78X60_B0)
 #define CNTMR_EVENTS_STATUS_REG_PRIVATE		(MV_CPUIF_LOCAL_REGS_OFFSET + 0x68)
 #define TIMER_PRIVATE_BIT(timer)	(1 << ((timer - FIRST_PRIVATE_TIMER) * 8))
+#elif defined(CONFIG_ARCH_ARMADA370)
+#define CNTMR_EVENTS_STATUS_REG_PRIVATE (MV_CPUIF_REGS_OFFSET(0) + 0x68)
+#define TIMER_PRIVATE_BIT(timer)        (1 << ((timer - FIRST_PRIVATE_TIMER) * 8 + ((timer == TIMER7) ? 8 : 0)))
 #else
 #error "No device is defined!"
 #endif
--- a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmrRegs.h
+++ b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmrRegs.h
@@ -151,8 +151,14 @@ extern "C" {
 #define CTCR_ARM_TIMER_EN(cntr)		(1 << CTCR_ARM_TIMER_EN_OFFS(cntr))
 #define CTCR_ARM_TIMER_DIS(cntr)	(0 << CTCR_ARM_TIMER_EN_OFFS(cntr))
 
+#if defined (CONFIG_ARCH_ARMADA370)
+#define CTCR_ARM_TIMER_AUTO_OFFS(timer) ((timer <= MAX_GLOBAL_TIMER) ? (1 + (timer * 2)) : \
+										(1 + (timer-FIRST_PRIVATE_TIMER) * 2))
+#else
 #define CTCR_ARM_TIMER_AUTO_OFFS(timer)	((timer <= MAX_GLOBAL_TIMER) ? (1 + (timer * 2)) : \
 										(1 + ((CPU_TIMER(timer))) * 2))
+#endif
+
 #define CTCR_ARM_TIMER_AUTO_MASK(cntr)	(1 << CTCR_ARM_TIMER_EN_OFFS(cntr))
 #define CTCR_ARM_TIMER_AUTO_EN(cntr)	(1 << CTCR_ARM_TIMER_AUTO_OFFS(cntr))
 #define CTCR_ARM_TIMER_AUTO_DIS(cntr)	(0 << CTCR_ARM_TIMER_AUTO_OFFS(cntr))
--- a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
+++ b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
@@ -1699,7 +1699,6 @@ MV_VOID mvEth1540A0PhyBasicInit(MV_U32 e
 {
 	int i = ethphyHalData.phyAddr[ethPortNum];
 	MV_U16 reg;
-	int startAddr, endAddr;
 
 	/* Enable QSGMII AN */
 	/* Set page to 4. */
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/twsi/mvSysTwsi.h
@@ -0,0 +1,119 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvSysTwsiH
+#define __INCmvSysTwsiH
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*******************************************************************************
+* mvSysTwsiInterruptEnable
+*
+* DESCRIPTION:
+*	Mask or unmask TWSI main interrupt cause bit.
+*
+* INPUT:
+*	chanNum	- TWSI channel number.
+*	enable	- MV_TRUE to enable the interrupt,
+*		  MV_FALSE to disable the interrupt.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysTwsiInterruptEnable(MV_U32 chanNum, MV_BOOL enable);
+
+
+/*******************************************************************************
+* mvSysTwsiMainCauseIsSet
+*
+* DESCRIPTION:
+*	Check if the TWSI interrupt was triggered in the main interrupt cause
+*	register.
+*
+* INPUT:
+*	chanNum	- TWSI channel number.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_TRUE if interrupt was triggered.
+*	MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvSysTwsiMainCauseIsSet(MV_U32 chanNum);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- a/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c
+++ b/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c
@@ -65,6 +65,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "mvCommon.h"
 #include "mvOs.h"
 #include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
 #include "cpu/mvCpu.h"
 #include "mvTwsi.h"
 #include "mvTwsiSpec.h"
--- a/arch/arm/plat-armada/mv_hal/xor/mvXorAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/xor/mvXorAddrDec.c
@@ -79,22 +79,22 @@ static MV_STATUS xorWinOverlapDetect(MV_
 
 MV_TARGET xorAddrDecPrioTap[] = {
 #if defined(MV_INCLUDE_PEX)
-#if PEX0_MEM_SIZE
+#if defined(PEX0_MEM_SIZE)
 	PEX0_MEM,
 #endif
-#if PEX1_MEM_SIZE
+#if defined(PEX1_MEM_SIZE)
 	PEX1_MEM,
 #endif
-#if PEX2_MEM_SIZE
+#if defined(PEX2_MEM_SIZE)
 	PEX2_MEM,
 #endif
-#if PEX3_MEM_SIZE
+#if defined(PEX3_MEM_SIZE)
 	PEX3_MEM,
 #endif
-#if PEX8_MEM_BASE
+#if defined(PEX8_MEM_BASE)
 	PEX8_MEM,
 #endif
-#if PEX9_MEM_BASE
+#if defined(PEX9_MEM_BASE)
 	PEX9_MEM,
 #endif
 #endif
@@ -117,8 +117,12 @@ MV_TARGET xorAddrDecPrioTap[] = {
 	DEV_CS1,
 #endif
 #if defined(MV_INCLUDE_CESA)
+#if defined(CONFIG_ARCH_ARMADA370)
+	CRYPT0_ENG,
+#else
 	CRYPT1_ENG,
 #endif
+#endif
 	TBL_TERM
 };
 
