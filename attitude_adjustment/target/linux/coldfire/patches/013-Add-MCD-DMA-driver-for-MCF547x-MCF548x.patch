From de2bd6eff9a9f20c6c997b5384c8e81720d9d659 Mon Sep 17 00:00:00 2001
From: Alison Wang <b18965@freescale.com>
Date: Thu, 4 Aug 2011 09:59:43 +0800
Subject: [PATCH 13/52] Add MCD DMA driver for MCF547x/MCF548x

Add MCD DMA driver for MCF547x/MCF548x.

Signed-off-by: Alison Wang <b18965@freescale.com>
---
 arch/m68k/coldfire/m547x/dma.c  |  518 ++++++++
 arch/m68k/include/asm/MCD_dma.h |  434 +++++++
 drivers/dma/MCD_dma.h           |  431 +++++++
 drivers/dma/MCD_dmaApi.c        | 1043 +++++++++++++++++
 drivers/dma/MCD_progCheck.h     |   29 +
 drivers/dma/MCD_tasks.c         | 2457 +++++++++++++++++++++++++++++++++++++++
 drivers/dma/MCD_tasksInit.c     |  271 +++++
 drivers/dma/MCD_tasksInit.h     |   84 ++
 8 files changed, 5267 insertions(+), 0 deletions(-)
 create mode 100644 arch/m68k/coldfire/m547x/dma.c
 create mode 100644 arch/m68k/include/asm/MCD_dma.h
 create mode 100644 drivers/dma/MCD_dma.h
 create mode 100644 drivers/dma/MCD_dmaApi.c
 create mode 100644 drivers/dma/MCD_progCheck.h
 create mode 100644 drivers/dma/MCD_tasks.c
 create mode 100644 drivers/dma/MCD_tasksInit.c
 create mode 100644 drivers/dma/MCD_tasksInit.h

--- /dev/null
+++ b/arch/m68k/coldfire/m547x/dma.c
@@ -0,0 +1,518 @@
+/*
+ * arch/m68k/coldfire/m547x/dma.c
+ *
+ * Coldfire M547x/M548x DMA
+ *
+ * Copyright (C) 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Kurt Mahan <kmahan@freescale.com>
+ * Shrek Wu b16972@freescale.com
+ *
+ * This code is based on patches from the Freescale M547x_8x BSP
+ * release mcf547x_8x-20070107-ltib.iso
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <asm/coldfire.h>
+#include <asm/m5485sram.h>
+#include <asm/mcfsim.h>
+#include <asm/MCD_dma.h>
+
+/*
+ * This global keeps track of which initiators have been
+ * used of the available assignments.  Initiators 0-15 are
+ * hardwired.  Initiators 16-31 are multiplexed and controlled
+ * via the Initiatior Mux Control Registe (IMCR).  The
+ * assigned requestor is stored with the associated initiator
+ * number.
+ */
+static int used_reqs[32] = {
+	DMA_ALWAYS, DMA_DSPI_RX, DMA_DSPI_TX, DMA_DREQ0,
+	DMA_PSC0_RX, DMA_PSC0_TX, DMA_USBEP0, DMA_USBEP1,
+	DMA_USBEP2, DMA_USBEP3, DMA_PCI_TX, DMA_PCI_RX,
+	DMA_PSC1_RX, DMA_PSC1_TX, DMA_I2C_RX, DMA_I2C_TX,
+	0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0
+};
+
+/*
+ * This global keeps track of which channels have been assigned
+ * to tasks.  This methology assumes that no single initiator
+ * will be tied to more than one task/channel
+ */
+static char used_channel[16] = {
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
+unsigned int connected_channel[16] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/**
+ * dma_set_initiator - enable initiator
+ * @initiator: initiator identifier
+ *
+ * Returns 0 of successful, non-zero otherwise
+ *
+ * Attempt to enable the provided Initiator in the Initiator
+ * Mux Control Register.
+ */
+int dma_set_initiator(int initiator)
+{
+	switch (initiator) {
+	case DMA_ALWAYS:
+	case DMA_DSPI_RX:
+	case DMA_DSPI_TX:
+	case DMA_DREQ0:
+	case DMA_PSC0_RX:
+	case DMA_PSC0_TX:
+	case DMA_USBEP0:
+	case DMA_USBEP1:
+	case DMA_USBEP2:
+	case DMA_USBEP3:
+	case DMA_PCI_TX:
+	case DMA_PCI_RX:
+	case DMA_PSC1_RX:
+	case DMA_PSC1_TX:
+	case DMA_I2C_RX:
+	case DMA_I2C_TX:
+		/*
+		 * These initiators are always active
+		 */
+		break;
+
+	case DMA_FEC0_RX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC16(3))
+		    | MCF_DMA_IMCR_SRC16_FEC0RX;
+		used_reqs[16] = DMA_FEC0_RX;
+		break;
+
+	case DMA_FEC0_TX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC17(3))
+		    | MCF_DMA_IMCR_SRC17_FEC0TX;
+		used_reqs[17] = DMA_FEC0_TX;
+		break;
+
+	case DMA_FEC1_RX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC20(3))
+		    | MCF_DMA_IMCR_SRC20_FEC1RX;
+		used_reqs[20] = DMA_FEC1_RX;
+		break;
+
+	case DMA_FEC1_TX:
+		if (used_reqs[21] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC21(3))
+			    | MCF_DMA_IMCR_SRC21_FEC1TX;
+			used_reqs[21] = DMA_FEC1_TX;
+		} else if (used_reqs[25] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC25(3))
+			    | MCF_DMA_IMCR_SRC25_FEC1TX;
+			used_reqs[25] = DMA_FEC1_TX;
+		} else if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_FEC1TX;
+			used_reqs[31] = DMA_FEC1_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_DREQ1:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_DREQ1;
+			used_reqs[29] = DMA_DREQ1;
+		} else if (used_reqs[21] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC21(3))
+			    | MCF_DMA_IMCR_SRC21_DREQ1;
+			used_reqs[21] = DMA_DREQ1;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM0:
+		if (used_reqs[24] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC24(3))
+			    | MCF_DMA_IMCR_SRC24_CTM0;
+			used_reqs[24] = DMA_CTM0;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM1:
+		if (used_reqs[25] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC25(3))
+			    | MCF_DMA_IMCR_SRC25_CTM1;
+			used_reqs[25] = DMA_CTM1;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM2:
+		if (used_reqs[26] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC26(3))
+			    | MCF_DMA_IMCR_SRC26_CTM2;
+			used_reqs[26] = DMA_CTM2;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM3:
+		if (used_reqs[27] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC27(3))
+			    | MCF_DMA_IMCR_SRC27_CTM3;
+			used_reqs[27] = DMA_CTM3;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM4:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_CTM4;
+			used_reqs[28] = DMA_CTM4;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM5:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_CTM5;
+			used_reqs[29] = DMA_CTM5;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM6:
+		if (used_reqs[30] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC30(3))
+			    | MCF_DMA_IMCR_SRC30_CTM6;
+			used_reqs[30] = DMA_CTM6;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM7:
+		if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_CTM7;
+			used_reqs[31] = DMA_CTM7;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP4:
+		if (used_reqs[26] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC26(3))
+			    | MCF_DMA_IMCR_SRC26_USBEP4;
+			used_reqs[26] = DMA_USBEP4;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP5:
+		if (used_reqs[27] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC27(3))
+			    | MCF_DMA_IMCR_SRC27_USBEP5;
+			used_reqs[27] = DMA_USBEP5;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP6:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_USBEP6;
+			used_reqs[28] = DMA_USBEP6;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC2_RX:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_PSC2RX;
+			used_reqs[28] = DMA_PSC2_RX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC2_TX:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_PSC2TX;
+			used_reqs[29] = DMA_PSC2_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC3_RX:
+		if (used_reqs[30] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC30(3))
+			    | MCF_DMA_IMCR_SRC30_PSC3RX;
+			used_reqs[30] = DMA_PSC3_RX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC3_TX:
+		if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_PSC3TX;
+			used_reqs[31] = DMA_PSC3_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	default:
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * dma_get_initiator - get the initiator for the given requestor
+ * @requestor: initiator identifier
+ *
+ * Returns initiator number (0-31) if assigned or just 0
+ */
+unsigned int dma_get_initiator(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof(used_reqs); ++i) {
+		if (used_reqs[i] == requestor)
+			return i;
+	}
+	return 0;
+}
+
+/**
+ * dma_remove_initiator - remove the given initiator from active list
+ * @requestor: requestor to remove
+ */
+void dma_remove_initiator(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof(used_reqs); ++i) {
+		if (used_reqs[i] == requestor) {
+			used_reqs[i] = -1;
+			break;
+		}
+	}
+}
+
+/**
+ * dma_set_channel_fec: find available channel for fec and mark
+ * @requestor: initiator/requestor identifier
+ *
+ * Returns first avaialble channel (0-5) or -1 if all occupied
+ */
+int dma_set_channel_fec(int requestor)
+{
+	u32 i, t;
+
+#ifdef CONFIG_FEC_548x_ENABLE_FEC2
+	t = 4;
+#else
+	t = 2;
+#endif
+
+	for (i = 0; i < t ; ++i) {
+		if (used_channel[i] == -1) {
+			used_channel[i] = requestor;
+			return i;
+		}
+	}
+	/* All channels taken */
+	return -1;
+}
+
+/**
+ * dma_set_channel - find an available channel and mark as used
+ * @requestor: initiator/requestor identifier
+ *
+ * Returns first available channel (6-15) or -1 if all occupied
+ */
+int dma_set_channel(int requestor)
+{
+	u32 i;
+#ifdef CONFIG_NET_FEC2
+	i = 4;
+#else
+	i = 2;
+#endif
+
+	for (; i < 16; ++i)
+		if (used_channel[i] == -1) {
+			used_channel[i] = requestor;
+			return i;
+		}
+
+	/* All channels taken */
+	return -1;
+}
+
+/**
+ * dma_get_channel - get the channel being initiated by the requestor
+ * @requestor: initiator/requestor identifier
+ *
+ * Returns Initiator for requestor or -1 if not found
+ */
+int dma_get_channel(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof(used_channel); ++i) {
+		if (used_channel[i] == requestor)
+			return i;
+	}
+	return -1;
+}
+
+/**
+ * dma_connect - connect a channel with reference on data
+ * @channel: channel number
+ * @address: reference address of data
+ *
+ * Returns 0 if success or -1 if invalid channel
+ */
+int dma_connect(int channel, int address)
+{
+	if ((channel < 16) && (channel >= 0)) {
+		connected_channel[channel] = address;
+		return 0;
+	}
+	return -1;
+}
+
+/**
+ * dma_disconnect - disconnect a channel
+ * @channel: channel number
+ *
+ * Returns 0 if success or -1 if invalid channel
+ */
+int dma_disconnect(int channel)
+{
+	if ((channel < 16) && (channel >= 0)) {
+		connected_channel[channel] = 0;
+		return 0;
+	}
+	return -1;
+}
+
+/**
+ * dma_remove_channel - remove channel from the active list
+ * @requestor: initiator/requestor identifier
+ */
+void dma_remove_channel(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof(used_channel); ++i) {
+		if (used_channel[i] == requestor) {
+			used_channel[i] = -1;
+			break;
+		}
+	}
+}
+
+/**
+ * dma_interrupt_handler - dma interrupt handler
+ * @irq: interrupt number
+ * @dev_id: data
+ *
+ * Returns IRQ_HANDLED
+ */
+irqreturn_t dma_interrupt_handler(int irq, void *dev_id)
+{
+	u32 i, interrupts;
+
+	/*
+	 * Determine which interrupt(s) triggered by AND'ing the
+	 * pending interrupts with those that aren't masked.
+	 */
+	interrupts = MCF_DMA_DIPR;
+	MCF_DMA_DIPR = interrupts;
+
+	for (i = 0; i < 16; ++i, interrupts >>= 1) {
+		if (interrupts & 0x1)
+			if (connected_channel[i] != 0)
+				((void (*)(void)) (connected_channel[i])) ();
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * dma_remove_channel_by_number - clear dma channel
+ * @channel: channel number to clear
+ */
+void dma_remove_channel_by_number(int channel)
+{
+	if ((channel < sizeof(used_channel)) && (channel >= 0))
+		used_channel[channel] = -1;
+}
+
+/**
+ * dma_init - initialize the dma subsystem
+ *
+ * Returns 0 if success non-zero if failure
+ *
+ * Handles the DMA initialization during device setup.
+ */
+int __devinit dma_init()
+{
+	int result;
+	char *dma_version_str;
+
+	MCD_getVersion(&dma_version_str);
+	printk(KERN_INFO "m547x_8x DMA: Initialize %s\n", dma_version_str);
+
+	/* attempt to setup dma interrupt handler */
+	if (request_irq(64 + ISC_DMA, dma_interrupt_handler, IRQF_DISABLED,
+			"MCD-DMA", NULL)) {
+		printk(KERN_ERR "MCD-DMA: Cannot allocate the DMA IRQ(48)\n");
+		return 1;
+	}
+
+	MCF_DMA_DIMR = 0;
+	MCF_DMA_DIPR = 0xFFFFFFFF;
+
+	MCF_ICR(ISC_DMA) = ILP_DMA;
+
+	result = MCD_initDma((dmaRegs *) (MCF_MBAR + 0x8000),
+			(void *) SYS_SRAM_DMA_START, MCD_RELOC_TASKS);
+	if (result != MCD_OK) {
+		printk(KERN_ERR "MCD-DMA: Cannot perform DMA initialization\n");
+		free_irq(64 + ISC_DMA, NULL);
+		return 1;
+	}
+
+	return 0;
+}
+device_initcall(dma_init);
--- /dev/null
+++ b/arch/m68k/include/asm/MCD_dma.h
@@ -0,0 +1,434 @@
+/*********************************************************************
+ *
+ *  Copyright (C) 2004  Motorola, Inc.
+ *  MOTOROLA, INC. All Rights Reserved.
+ *  Copyright (C) 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Shrek Wu b16972@freescale.com
+ *
+ *  You are hereby granted a copyright license to use
+ *  the SOFTWARE so long as this entire notice is
+ *  retained without alteration in any modified and/or redistributed
+ *  versions, and that such modified versions are clearly identified
+ *  as such. No licenses are granted by implication, estoppel or
+ *  otherwise under any patents or trademarks of Motorola, Inc. This
+ *  software is provided on an "AS IS" basis and without warranty.
+ *
+ *  To the maximum extent permitted by applicable law, MOTOROLA
+ *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+ *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
+ *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
+ *  ACCOMPANYING WRITTEN MATERIALS.
+ *
+ *  To the maximum extent permitted by applicable law, IN NO EVENT
+ *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
+ *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
+ *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
+ *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ *
+ *  Motorola assumes no responsibility for the maintenance and support
+ *  of this software
+ ********************************************************************/
+
+/*
+ * File:        MCD_dma.h
+ * Purpose:     Main header file for multi-channel DMA API.
+ *
+ * Notes:
+ *
+ * Modifications:
+ */
+#ifndef _MCD_API_H
+#define _MCD_API_H
+
+#include <asm/types.h>
+
+/*
+ * Turn Execution Unit tasks ON (#define) or OFF (#undef)
+ */
+#undef MCD_INCLUDE_EU
+
+/*
+ * Number of DMA channels
+ */
+#define NCHANNELS 16
+
+/*
+ * Total number of variants
+ */
+#ifdef MCD_INCLUDE_EU
+#define NUMOFVARIANTS   6
+#else
+#define NUMOFVARIANTS   4
+#endif
+
+/*
+ * Define sizes of the various tables
+ */
+#define TASK_TABLE_SIZE     (NCHANNELS*32)
+#define VAR_TAB_SIZE        (128)
+#define CONTEXT_SAVE_SIZE   (128)
+#define FUNCDESC_TAB_SIZE   (256)
+
+#ifdef MCD_INCLUDE_EU
+#define FUNCDESC_TAB_NUM    16
+#else
+#define FUNCDESC_TAB_NUM    1
+#endif
+
+
+#ifndef DEFINESONLY
+
+/*
+ * Portability typedefs
+ */
+ /*
+#ifndef s32
+typedef int s32;
+#endif
+#ifndef u32
+typedef unsigned int u32;
+#endif
+#ifndef s16
+typedef short s16;
+#endif
+#ifndef u16
+typedef unsigned short u16;
+#endif
+#ifndef s8
+typedef char s8;
+#endif
+#ifndef u8
+typedef unsigned char u8;
+#endif
+*/
+/*
+ * These structures represent the internal registers of the
+ * multi-channel DMA
+ */
+struct dmaRegs_s {
+	u32 taskbar;         /* task table base address register */
+	u32 currPtr;
+	u32 endPtr;
+	u32 varTablePtr;
+	u16 dma_rsvd0;
+	u16 ptdControl;      /* ptd control */
+	u32 intPending;      /* interrupt pending register */
+	u32 intMask;         /* interrupt mask register */
+	u16 taskControl[16]; /* task control registers */
+	u8  priority[32];    /* priority registers */
+	u32 initiatorMux;    /* initiator mux control */
+	u32 taskSize0;       /* task size control register 0. */
+	u32 taskSize1;       /* task size control register 1. */
+	u32 dma_rsvd1;       /* reserved */
+	u32 dma_rsvd2;       /* reserved */
+	u32 debugComp1;      /* debug comparator 1 */
+	u32 debugComp2;      /* debug comparator 2 */
+	u32 debugControl;    /* debug control */
+	u32 debugStatus;     /* debug status */
+	u32 ptdDebug;        /* priority task decode debug */
+	u32 dma_rsvd3[31];   /* reserved */
+};
+typedef volatile struct dmaRegs_s dmaRegs;
+
+#endif
+
+/*
+ * PTD contrl reg bits
+ */
+#define PTD_CTL_TSK_PRI         0x8000
+#define PTD_CTL_COMM_PREFETCH   0x0001
+
+/*
+ * Task Control reg bits and field masks
+ */
+#define TASK_CTL_EN             0x8000
+#define TASK_CTL_VALID          0x4000
+#define TASK_CTL_ALWAYS         0x2000
+#define TASK_CTL_INIT_MASK      0x1f00
+#define TASK_CTL_ASTRT          0x0080
+#define TASK_CTL_HIPRITSKEN     0x0040
+#define TASK_CTL_HLDINITNUM     0x0020
+#define TASK_CTL_ASTSKNUM_MASK  0x000f
+
+/*
+ * Priority reg bits and field masks
+ */
+#define PRIORITY_HLD            0x80
+#define PRIORITY_PRI_MASK       0x07
+
+/*
+ * Debug Control reg bits and field masks
+ */
+#define DBG_CTL_BLOCK_TASKS_MASK    0xffff0000
+#define DBG_CTL_AUTO_ARM            0x00008000
+#define DBG_CTL_BREAK               0x00004000
+#define DBG_CTL_COMP1_TYP_MASK      0x00003800
+#define DBG_CTL_COMP2_TYP_MASK      0x00000070
+#define DBG_CTL_EXT_BREAK           0x00000004
+#define DBG_CTL_INT_BREAK           0x00000002
+
+/*
+ * PTD Debug reg selector addresses
+ * This reg must be written with a value to show the contents of
+ * one of the desired internal register.
+ */
+#define PTD_DBG_REQ             0x00 /* shows the state of 31 initiators */
+#define PTD_DBG_TSK_VLD_INIT    0x01 /* shows which 16 tasks are valid and
+					have initiators asserted */
+
+
+/*
+ * General return values
+ */
+#define MCD_OK                   0
+#define MCD_ERROR               -1
+#define MCD_TABLE_UNALIGNED     -2
+#define MCD_CHANNEL_INVALID     -3
+
+/*
+ * MCD_initDma input flags
+ */
+#define MCD_RELOC_TASKS         0x00000001
+#define MCD_NO_RELOC_TASKS      0x00000000
+#define MCD_COMM_PREFETCH_EN    0x00000002
+/* Commbus Prefetching - MCF547x/548x ONLY */
+
+/*
+ * MCD_dmaStatus Status Values for each channel
+ */
+#define MCD_NO_DMA  1 /* No DMA has been requested since reset */
+#define MCD_IDLE    2 /* DMA active, but the initiator is currently inactive */
+#define MCD_RUNNING 3 /* DMA active, and the initiator is currently active */
+#define MCD_PAUSED  4 /* DMA active but it is currently paused */
+#define MCD_HALTED  5
+/* the most recent DMA has been killed with MCD_killTask() */
+#define MCD_DONE    6 /* the most recent DMA has completed. */
+
+
+/*
+ * MCD_startDma parameter defines
+ */
+
+/*
+ * Constants for the funcDesc parameter
+ */
+/* Byte swapping: */
+#define MCD_NO_BYTE_SWAP    0x00045670  /* to disable byte swapping. */
+#define MCD_BYTE_REVERSE    0x00076540
+/* to reverse the bytes of each u32 of the DMAed data. */
+#define MCD_U16_REVERSE     0x00067450  /* to reverse the 16-bit halves of
+			each 32-bit data value being DMAed.*/
+#define MCD_U16_BYTE_REVERSE    0x00054760 /* to reverse the byte halves of each
+			16-bit half of each 32-bit data value DMAed */
+#define MCD_NO_BIT_REV  0x00000000
+/* do not reverse the bits of each byte DMAed. */
+#define MCD_BIT_REV     0x00088880  /* reverse the bits of each byte DMAed */
+/* CRCing: */
+#define MCD_CRC16       0xc0100000  /* to perform CRC-16 on DMAed data. */
+#define MCD_CRCCCITT    0xc0200000  /* to perform CRC-CCITT on DMAed data. */
+#define MCD_CRC32       0xc0300000  /* to perform CRC-32 on DMAed data. */
+#define MCD_CSUMINET    0xc0400000
+/* to perform internet checksums on DMAed data.*/
+#define MCD_NO_CSUM     0xa0000000  /* to perform no checksumming. */
+
+#define MCD_FUNC_NOEU1 (MCD_NO_BYTE_SWAP | MCD_NO_BIT_REV | MCD_NO_CSUM)
+#define MCD_FUNC_NOEU2 (MCD_NO_BYTE_SWAP | MCD_NO_CSUM)
+
+/*
+ * Constants for the flags parameter
+ */
+#define MCD_TT_FLAGS_RL   0x00000001 /* Read line */
+#define MCD_TT_FLAGS_CW   0x00000002 /* Combine Writes */
+#define MCD_TT_FLAGS_SP   0x00000004
+/* Speculative prefetch(XLB) MCF547x/548x ONLY  */
+#define MCD_TT_FLAGS_MASK 0x000000ff
+#define MCD_TT_FLAGS_DEF  (MCD_TT_FLAGS_RL | MCD_TT_FLAGS_CW)
+
+#define MCD_SINGLE_DMA  0x00000100 /* Unchained DMA */
+#define MCD_CHAIN_DMA              /* TBD */
+#define MCD_EU_DMA                 /* TBD */
+#define MCD_FECTX_DMA   0x00001000 /* FEC TX ring DMA */
+#define MCD_FECRX_DMA   0x00002000 /* FEC RX ring DMA */
+
+
+/* these flags are valid for MCD_startDma and the chained buffer descriptors */
+#define MCD_BUF_READY   0x80000000
+/* indicates that this buffer is now under the DMA's control */
+#define MCD_WRAP        0x20000000
+/* to tell the FEC Dmas to wrap to the first BD */
+#define MCD_INTERRUPT   0x10000000
+/* to generate an interrupt after completion of the DMA. */
+#define MCD_END_FRAME   0x08000000
+/* tell the DMA to end the frame when transferring
+	last byte of data in buffer */
+#define MCD_CRC_RESTART 0x40000000 /* to empty out the accumulated checksum
+	prior to performing the DMA. */
+
+/* Defines for the FEC buffer descriptor control/status word*/
+#define MCD_FEC_BUF_READY   0x8000
+#define MCD_FEC_WRAP        0x2000
+#define MCD_FEC_INTERRUPT   0x1000
+#define MCD_FEC_END_FRAME   0x0800
+
+
+/*
+ * Defines for general intuitiveness
+ */
+
+#define MCD_TRUE  1
+#define MCD_FALSE 0
+
+/*
+ * Three different cases for destination and source.
+ */
+#define MINUS1          -1
+#define ZERO            0
+#define PLUS1           1
+
+#ifndef DEFINESONLY
+
+/* Task Table Entry struct*/
+typedef struct {
+	u32 TDTstart;   /* task descriptor table start */
+	u32 TDTend;     /* task descriptor table end */
+	u32 varTab;     /* variable table start */
+	u32 FDTandFlags;    /* function descriptor table start and flags */
+	volatile u32 descAddrAndStatus;
+	volatile u32 modifiedVarTab;
+	u32 contextSaveSpace;   /* context save space start */
+	u32 literalBases;
+} TaskTableEntry;
+
+
+/* Chained buffer descriptor */
+typedef volatile struct MCD_bufDesc_struct MCD_bufDesc;
+struct MCD_bufDesc_struct {
+	u32 flags;         /* flags describing the DMA */
+	u32 csumResult;
+	/* checksum from checksumming performed since last checksum reset */
+	s8  *srcAddr;      /* the address to move data from */
+	s8  *destAddr;     /* the address to move data to */
+	s8  *lastDestAddr; /* the last address written to */
+	u32 dmaSize;
+	/* the number of bytes to transfer independent of the transfer size */
+	MCD_bufDesc *next; /* next buffer descriptor in chain */
+	u32 info;
+	/* private information about this descriptor;  DMA does not affect it */
+};
+
+/* Progress Query struct */
+typedef volatile struct MCD_XferProg_struct {
+	s8 *lastSrcAddr;
+	/* the most-recent or last, post-increment source address */
+	s8 *lastDestAddr;
+	/* the most-recent or last, post-increment destination address */
+	u32  dmaSize;
+	/* the amount of data transferred for the current buffer */
+	MCD_bufDesc *currBufDesc;
+	/* pointer to the current buffer descriptor being DMAed */
+} MCD_XferProg;
+
+
+/* FEC buffer descriptor */
+typedef volatile struct MCD_bufDescFec_struct {
+	u16 statCtrl;
+	u16 length;
+	u32 dataPointer;
+} MCD_bufDescFec;
+
+
+/*************************************************************************/
+/*
+ * API function Prototypes  - see MCD_dmaApi.c for further notes
+ */
+
+/*
+ * MCD_startDma starts a particular kind of DMA .
+ */
+int MCD_startDma(
+	int channel,   /* the channel on which to run the DMA */
+	/* the address to move data from, or buffer-descriptor address */
+	s8  *srcAddr,
+	/* the amount to increment the source address per transfer */
+	s16 srcIncr,
+	s8  *destAddr, /* the address to move data to */
+	/* the amount to increment the destination address per transfer */
+	s16 destIncr,
+	/* the number of bytes to transfer independent of the transfer size */
+	u32 dmaSize,
+	/* the number bytes in of each data movement (1, 2, or 4) */
+	u32 xferSize,
+	u32 initiator, /* what device initiates the DMA */
+	int priority,  /* priority of the DMA */
+	u32 flags,     /* flags describing the DMA */
+	/* a description of byte swapping, bit swapping, and CRC actions */
+	u32 funcDesc
+);
+
+/*
+ * MCD_initDma() initializes the DMA API by setting up a pointer to the DMA
+ * registers, relocating and creating the appropriate task structures, and
+ * setting up some global settings
+ */
+int MCD_initDma(dmaRegs *sDmaBarAddr, void *taskTableDest, u32 flags);
+
+/*
+ * MCD_dmaStatus() returns the status of the DMA on the requested channel.
+ */
+int MCD_dmaStatus(int channel);
+
+/*
+ * MCD_XferProgrQuery() returns progress of DMA on requested channel
+ */
+int MCD_XferProgrQuery(int channel, MCD_XferProg *progRep);
+
+/*
+ * MCD_killDma() halts the DMA on the requested channel, without any
+ * intention of resuming the DMA.
+ */
+int MCD_killDma(int channel);
+
+/*
+ * MCD_continDma() continues a DMA which as stopped due to encountering an
+ * unready buffer descriptor.
+ */
+int MCD_continDma(int channel);
+
+/*
+ * MCD_pauseDma() pauses the DMA on the given channel ( if any DMA is
+ * running on that channel).
+ */
+int MCD_pauseDma(int channel);
+
+/*
+ * MCD_resumeDma() resumes the DMA on a given channel (if any DMA is
+ * running on that channel).
+ */
+int MCD_resumeDma(int channel);
+
+/*
+ * MCD_csumQuery provides the checksum/CRC after performing a non-chained DMA
+ */
+int MCD_csumQuery(int channel, u32 *csum);
+
+/*
+ * MCD_getCodeSize provides the packed size required by the microcoded task
+ * and structures.
+ */
+int MCD_getCodeSize(void);
+
+/*
+ * MCD_getVersion provides a pointer to a version string and returns a
+ * version number.
+ */
+int MCD_getVersion(char **longVersion);
+
+/* macro for setting a location in the variable table */
+#define MCD_SET_VAR(taskTab, idx, value) ((u32 *)(taskTab)->varTab)[idx] = value
+   /* Note that MCD_SET_VAR() is invoked many times in firing up a DMA function,
+      so I'm avoiding surrounding it with "do {} while(0)" */
+
+#endif  /* DEFINESONLY */
+
+#endif /* _MCD_API_H */
--- /dev/null
+++ b/drivers/dma/MCD_dma.h
@@ -0,0 +1,431 @@
+/*
+ * drivers/dma/MCD_dma.h
+ *
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Kurt Mahan <kmahan@freescale.com>
+ * Shrek Wu b16972@freescale.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _MCD_API_H
+#define _MCD_API_H
+
+/*
+ * Turn Execution Unit tasks ON (#define) or OFF (#undef)
+ */
+#undef MCD_INCLUDE_EU
+
+/*
+ * Number of DMA channels
+ */
+#define NCHANNELS 16
+
+/*
+ * Total number of variants
+ */
+#ifdef MCD_INCLUDE_EU
+#define NUMOFVARIANTS   6
+#else
+#define NUMOFVARIANTS   4
+#endif
+
+/*
+ * Define sizes of the various tables
+ */
+#define TASK_TABLE_SIZE     (NCHANNELS*32)
+#define VAR_TAB_SIZE        (128)
+#define CONTEXT_SAVE_SIZE   (128)
+#define FUNCDESC_TAB_SIZE   (256)
+
+#ifdef MCD_INCLUDE_EU
+#define FUNCDESC_TAB_NUM    16
+#else
+#define FUNCDESC_TAB_NUM    1
+#endif
+
+
+#ifndef DEFINESONLY
+
+/*
+ * Portability typedefs
+ */
+typedef int s32;
+typedef unsigned int u32;
+typedef short s16;
+typedef unsigned short u16;
+typedef char s8;
+typedef unsigned char u8;
+
+/*
+ * These structures represent the internal registers of the
+ * multi-channel DMA
+ */
+struct dmaRegs_s {
+	u32 taskbar;         /* task table base address register */
+	u32 currPtr;
+	u32 endPtr;
+	u32 varTablePtr;
+	u16 dma_rsvd0;
+	u16 ptdControl;      /* ptd control */
+	u32 intPending;      /* interrupt pending register */
+	u32 intMask;         /* interrupt mask register */
+	u16 taskControl[16]; /* task control registers */
+	u8  priority[32];    /* priority registers */
+	u32 initiatorMux;    /* initiator mux control */
+	u32 taskSize0;       /* task size control register 0. */
+	u32 taskSize1;       /* task size control register 1. */
+	u32 dma_rsvd1;       /* reserved */
+	u32 dma_rsvd2;       /* reserved */
+	u32 debugComp1;      /* debug comparator 1 */
+	u32 debugComp2;      /* debug comparator 2 */
+	u32 debugControl;    /* debug control */
+	u32 debugStatus;     /* debug status */
+	u32 ptdDebug;        /* priority task decode debug */
+	u32 dma_rsvd3[31];   /* reserved */
+};
+typedef volatile struct dmaRegs_s dmaRegs;
+
+#endif
+
+/*
+ * PTD contrl reg bits
+ */
+#define PTD_CTL_TSK_PRI         0x8000
+#define PTD_CTL_COMM_PREFETCH   0x0001
+
+/*
+ * Task Control reg bits and field masks
+ */
+#define TASK_CTL_EN             0x8000
+#define TASK_CTL_VALID          0x4000
+#define TASK_CTL_ALWAYS         0x2000
+#define TASK_CTL_INIT_MASK      0x1f00
+#define TASK_CTL_ASTRT          0x0080
+#define TASK_CTL_HIPRITSKEN     0x0040
+#define TASK_CTL_HLDINITNUM     0x0020
+#define TASK_CTL_ASTSKNUM_MASK  0x000f
+
+/*
+ * Priority reg bits and field masks
+ */
+#define PRIORITY_HLD            0x80
+#define PRIORITY_PRI_MASK       0x07
+
+/*
+ * Debug Control reg bits and field masks
+ */
+#define DBG_CTL_BLOCK_TASKS_MASK    0xffff0000
+#define DBG_CTL_AUTO_ARM            0x00008000
+#define DBG_CTL_BREAK               0x00004000
+#define DBG_CTL_COMP1_TYP_MASK      0x00003800
+#define DBG_CTL_COMP2_TYP_MASK      0x00000070
+#define DBG_CTL_EXT_BREAK           0x00000004
+#define DBG_CTL_INT_BREAK           0x00000002
+
+/*
+ * PTD Debug reg selector addresses
+ * This reg must be written with a value to show the contents of
+ * one of the desired internal register.
+ */
+#define PTD_DBG_REQ             0x00
+/* shows the state of 31 initiators */
+#define PTD_DBG_TSK_VLD_INIT    0x01
+/* shows which 16 tasks are valid and
+ * have initiators asserted */
+
+
+/*
+ * General return values
+ */
+#define MCD_OK                   0
+#define MCD_ERROR               -1
+#define MCD_TABLE_UNALIGNED     -2
+#define MCD_CHANNEL_INVALID     -3
+
+/*
+ * MCD_initDma input flags
+ */
+#define MCD_RELOC_TASKS         0x00000001
+#define MCD_NO_RELOC_TASKS      0x00000000
+#define MCD_COMM_PREFETCH_EN    0x00000002
+/* Commbus Prefetching - MCF547x/548x ONLY */
+
+/*
+ * MCD_dmaStatus Status Values for each channel
+ */
+#define MCD_NO_DMA  1
+/* No DMA has been requested since reset */
+#define MCD_IDLE    2
+/* DMA active, but the initiator is currently inactive */
+#define MCD_RUNNING 3
+/* DMA active, and the initiator is currently active */
+#define MCD_PAUSED  4
+/* DMA active but it is currently paused */
+#define MCD_HALTED  5
+/* the most recent DMA has been killed with MCD_killTask() */
+#define MCD_DONE    6
+/* the most recent DMA has completed. */
+
+
+/*
+ * MCD_startDma parameter defines
+ */
+
+/*
+ * Constants for the funcDesc parameter
+ */
+/* Byte swapping: */
+#define MCD_NO_BYTE_SWAP    0x00045670
+/* to disable byte swapping. */
+#define MCD_BYTE_REVERSE    0x00076540
+/* to reverse the bytes of each u32 of the DMAed data. */
+#define MCD_U16_REVERSE     0x00067450
+/* to reverse the 16-bit halves of
+ * each 32-bit data value being DMAed.*/
+#define MCD_U16_BYTE_REVERSE    0x00054760
+/* to reverse the byte halves of each
+ * 16-bit half of each 32-bit data value DMAed */
+#define MCD_NO_BIT_REV  0x00000000
+/* do not reverse the bits of each byte DMAed. */
+#define MCD_BIT_REV     0x00088880
+/* reverse the bits of each byte DMAed */
+/* CRCing: */
+#define MCD_CRC16       0xc0100000
+/* to perform CRC-16 on DMAed data. */
+#define MCD_CRCCCITT    0xc0200000
+/* to perform CRC-CCITT on DMAed data. */
+#define MCD_CRC32       0xc0300000
+/* to perform CRC-32 on DMAed data. */
+#define MCD_CSUMINET    0xc0400000
+/* to perform internet checksums on DMAed data.*/
+#define MCD_NO_CSUM     0xa0000000
+/* to perform no checksumming. */
+
+#define MCD_FUNC_NOEU1 (MCD_NO_BYTE_SWAP | MCD_NO_BIT_REV | MCD_NO_CSUM)
+#define MCD_FUNC_NOEU2 (MCD_NO_BYTE_SWAP | MCD_NO_CSUM)
+
+/*
+ * Constants for the flags parameter
+ */
+#define MCD_TT_FLAGS_RL   0x00000001 /* Read line */
+#define MCD_TT_FLAGS_CW   0x00000002 /* Combine Writes */
+#define MCD_TT_FLAGS_SP   0x00000004
+/* Speculative prefetch(XLB) MCF547x/548x ONLY  */
+#define MCD_TT_FLAGS_PI   0x00000040 /* Precise Increment */
+#define MCD_TT_FLAGS_MASK 0x000000ff
+#define MCD_TT_FLAGS_DEF  (MCD_TT_FLAGS_RL | MCD_TT_FLAGS_CW)
+
+#define MCD_SINGLE_DMA  0x00000100 /* Unchained DMA */
+#define MCD_CHAIN_DMA              /* TBD */
+#define MCD_EU_DMA                 /* TBD */
+#define MCD_FECTX_DMA   0x00001000 /* FEC TX ring DMA */
+#define MCD_FECRX_DMA   0x00002000 /* FEC RX ring DMA */
+
+
+/* these flags are valid for MCD_startDma
+ * and the chained buffer descriptors */
+#define MCD_BUF_READY   0x80000000
+/* indicates that this buffer is now
+ * under the DMA's control */
+#define MCD_WRAP        0x20000000
+/* to tell the FEC Dmas to wrap to the first BD */
+#define MCD_INTERRUPT   0x10000000
+/* to generate an interrupt after completion of the DMA. */
+#define MCD_END_FRAME   0x08000000
+/* tell the DMA to end the frame when transferring
+ * last byte of data in buffer */
+#define MCD_CRC_RESTART 0x40000000
+/* to empty out the accumulated checksum
+ prior to performing the DMA. */
+
+/* Defines for the FEC buffer descriptor control/status word*/
+#define MCD_FEC_BUF_READY   0x8000
+#define MCD_FEC_WRAP        0x2000
+#define MCD_FEC_INTERRUPT   0x1000
+#define MCD_FEC_END_FRAME   0x0800
+
+
+/*
+ * Defines for general intuitiveness
+ */
+
+#define MCD_TRUE  1
+#define MCD_FALSE 0
+
+/*
+ * Three different cases for destination and source.
+ */
+#define MINUS1          -1
+#define ZERO            0
+#define PLUS1           1
+
+#ifndef DEFINESONLY
+
+/* Task Table Entry struct*/
+typedef struct {
+	u32 TDTstart;   /* task descriptor table start */
+	u32 TDTend;     /* task descriptor table end */
+	u32 varTab;     /* variable table start */
+	u32 FDTandFlags;    /* function descriptor table start and flags */
+	volatile u32 descAddrAndStatus;
+	volatile u32 modifiedVarTab;
+	u32 contextSaveSpace;   /* context save space start */
+	u32 literalBases;
+} TaskTableEntry;
+
+
+/* Chained buffer descriptor */
+typedef volatile struct MCD_bufDesc_struct MCD_bufDesc;
+struct MCD_bufDesc_struct {
+	u32 flags;
+/* flags describing the DMA */
+	u32 csumResult;
+/* checksum from checksumming performed since last checksum reset */
+	s8  *srcAddr;
+/* the address to move data from */
+	s8  *destAddr;
+/* the address to move data to */
+	s8  *lastDestAddr;
+/* the last address written to */
+	u32 dmaSize;
+/* the number of bytes to transfer independent of the transfer size */
+	MCD_bufDesc *next;
+/* next buffer descriptor in chain */
+	u32 info;
+/* private information about this descriptor;  DMA does not affect it */
+};
+
+/* Progress Query struct */
+typedef volatile struct MCD_XferProg_struct {
+	s8 *lastSrcAddr;
+/* the most-recent or last, post-increment source address */
+	s8 *lastDestAddr;
+/* the most-recent or last, post-increment destination address */
+	u32  dmaSize;
+/* the amount of data transferred for the current buffer */
+	MCD_bufDesc *currBufDesc;
+/* pointer to the current buffer descriptor being DMAed */
+} MCD_XferProg;
+
+
+/* FEC buffer descriptor */
+typedef volatile struct MCD_bufDescFec_struct {
+	u16 statCtrl;
+	u16 length;
+	u32 dataPointer;
+} MCD_bufDescFec;
+
+
+/*************************************************************************/
+/*
+ * API function Prototypes  - see MCD_dmaApi.c for further notes
+ */
+
+/*
+ * MCD_startDma starts a particular kind of DMA .
+ */
+int MCD_startDma(
+	int channel,
+/* the channel on which to run the DMA */
+	s8  *srcAddr,
+/* the address to move data from, or buffer-descriptor address */
+	s16 srcIncr,
+/* the amount to increment the source address per transfer */
+	s8  *destAddr,
+/* the address to move data to */
+	s16 destIncr,
+/* the amount to increment the destination address per transfer */
+	u32 dmaSize,
+/* the number of bytes to transfer independent of the transfer size */
+	u32 xferSize,
+/* the number bytes in of each data movement (1, 2, or 4) */
+	u32 initiator,
+/* what device initiates the DMA */
+	int priority,
+/* priority of the DMA */
+	u32 flags,
+/* flags describing the DMA */
+	u32 funcDesc
+/* a description of byte swapping, bit swapping, and CRC actions */
+);
+
+/*
+ * MCD_initDma() initializes the DMA API by setting up a pointer to the DMA
+ * registers, relocating and creating the appropriate task structures, and
+ * setting up some global settings
+ */
+int MCD_initDma(dmaRegs *sDmaBarAddr, void *taskTableDest, u32 flags);
+
+/*
+ * MCD_dmaStatus() returns the status of the DMA on the requested channel.
+ */
+int MCD_dmaStatus(int channel);
+
+/*
+ * MCD_XferProgrQuery() returns progress of DMA on requested channel
+ */
+int MCD_XferProgrQuery(int channel, MCD_XferProg *progRep);
+
+/*
+ * MCD_killDma() halts the DMA on the requested channel, without any
+ * intention of resuming the DMA.
+ */
+int MCD_killDma(int channel);
+
+/*
+ * MCD_continDma() continues a DMA which as stopped due to encountering an
+ * unready buffer descriptor.
+ */
+int MCD_continDma(int channel);
+
+/*
+ * MCD_pauseDma() pauses the DMA on the given channel ( if any DMA is
+ * running on that channel).
+ */
+int MCD_pauseDma(int channel);
+
+/*
+ * MCD_resumeDma() resumes the DMA on a given channel (if any DMA is
+ * running on that channel).
+ */
+int MCD_resumeDma(int channel);
+
+/*
+ * MCD_csumQuery provides the checksum/CRC after performing a non-chained DMA
+ */
+int MCD_csumQuery(int channel, u32 *csum);
+
+/*
+ * MCD_getCodeSize provides the packed size required by the microcoded task
+ * and structures.
+ */
+int MCD_getCodeSize(void);
+
+/*
+ * MCD_getVersion provides a pointer to a version string and returns a
+ * version number.
+ */
+int MCD_getVersion(char **longVersion);
+
+/* macro for setting a location in the variable table */
+#define MCD_SET_VAR(taskTab, idx, value) \
+	((u32 *)(taskTab)->varTab)[idx] = value
+   /* Note that MCD_SET_VAR() is invoked many times in firing up a DMA function,
+      so I'm avoiding surrounding it with "do {} while(0)" */
+
+#endif  /* DEFINESONLY */
+
+#endif /* _MCD_API_H */
--- /dev/null
+++ b/drivers/dma/MCD_dmaApi.c
@@ -0,0 +1,1043 @@
+/*
+ * drivers/dma/MCD_dmaApi.c
+ *
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Kurt Mahan <kmahan@freescale.com>
+ * Shrek Wu b16972@freescale.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "MCD_dma.h"
+#include "MCD_tasksInit.h"
+#include "MCD_progCheck.h"
+
+/********************************************************************/
+/*
+ * This is an API-internal pointer to the DMA's registers
+ */
+dmaRegs *MCD_dmaBar;
+
+/*
+ * These are the real and model task tables as generated by the
+ * build process
+ */
+extern TaskTableEntry MCD_realTaskTableSrc[NCHANNELS];
+extern TaskTableEntry MCD_modelTaskTableSrc[NUMOFVARIANTS];
+
+/*
+ * However, this (usually) gets relocated to on-chip SRAM, at which
+ * point we access them as these tables
+ */
+volatile TaskTableEntry *MCD_taskTable;
+TaskTableEntry *MCD_modelTaskTable;
+
+
+/*
+ * MCD_chStatus[] is an array of status indicators for remembering
+ * whether a DMA has ever been attempted on each channel, pausing
+ * status, etc.
+ */
+static int MCD_chStatus[NCHANNELS] = {
+	MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA,
+	MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA,
+	MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA,
+	MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA
+};
+
+/*
+ * Prototypes for local functions
+ */
+static void MCD_memcpy(int *dest, int *src, u32 size);
+static void MCD_resmActions(int channel);
+
+/*
+ * Buffer descriptors used for storage of progress info for single Dmas
+ * Also used as storage for the DMA for CRCs for single DMAs
+ * Otherwise, the DMA does not parse these buffer descriptors
+ */
+#ifdef MCD_INCLUDE_EU
+extern MCD_bufDesc MCD_singleBufDescs[NCHANNELS];
+#else
+MCD_bufDesc MCD_singleBufDescs[NCHANNELS];
+#endif
+MCD_bufDesc *MCD_relocBuffDesc;
+
+
+/*
+ * Defines for the debug control register's functions
+ */
+#define DBG_CTL_COMP1_TASK  (0x00002000)
+/* have comparator 1 look for a task # */
+#define DBG_CTL_ENABLE  (DBG_CTL_AUTO_ARM    | \
+			DBG_CTL_BREAK       | \
+			DBG_CTL_INT_BREAK   | \
+			DBG_CTL_COMP1_TASK)
+#define DBG_CTL_DISABLE	(DBG_CTL_AUTO_ARM    | \
+			DBG_CTL_INT_BREAK   | \
+			DBG_CTL_COMP1_TASK)
+#define DBG_KILL_ALL_STAT   (0xFFFFFFFF)
+
+/*
+ * Offset to context save area where progress info is stored
+ */
+#define CSAVE_OFFSET        10
+
+/*
+ * Defines for Byte Swapping
+ */
+#define MCD_BYTE_SWAP_KILLER    0xFFF8888F
+#define MCD_NO_BYTE_SWAP_ATALL  0x00040000
+
+/*
+ * Execution Unit Identifiers
+ */
+#define MAC  0  /* legacy - not used */
+#define LUAC 1  /* legacy - not used */
+#define CRC  2  /* legacy - not used */
+#define LURC 3  /* Logic Unit with CRC */
+
+/*
+ * Task Identifiers
+ */
+#define TASK_CHAINNOEU  0
+#define TASK_SINGLENOEU 1
+#ifdef MCD_INCLUDE_EU
+#define TASK_CHAINEU    2
+#define TASK_SINGLEEU   3
+#define TASK_FECRX      4
+#define TASK_FECTX      5
+#else
+#define TASK_CHAINEU    0
+#define TASK_SINGLEEU   1
+#define TASK_FECRX      2
+#define TASK_FECTX      3
+#endif
+
+/*
+ * Structure to remember which variant is on which channel
+ */
+struct MCD_remVariants_struct {
+	int remDestRsdIncr[NCHANNELS];  /* -1,0,1 */
+	int remSrcRsdIncr[NCHANNELS];   /* -1,0,1 */
+	s16 remDestIncr[NCHANNELS];     /* DestIncr */
+	s16 remSrcIncr[NCHANNELS];      /* srcIncr */
+	u32 remXferSize[NCHANNELS];     /* xferSize */
+};
+
+/*
+ * Structure to remember the startDma parameters for each channel
+ */
+struct MCD_remVariants_struct MCD_remVariants;
+
+/********************************************************************/
+/*
+ * Function: MCD_initDma
+ * Purpose:  Initializes the DMA API by setting up a pointer to the DMA
+ *           registers, relocating and creating the appropriate task
+ *           structures, and setting up some global settings
+ * Arguments:
+ *  dmaBarAddr    - pointer to the multichannel DMA registers
+ *  taskTableDest - location to move DMA task code and structs to
+ *  flags         - operational parameters
+ * Return Value:
+ *  MCD_TABLE_UNALIGNED if taskTableDest is not 512-byte aligned
+ *  MCD_OK otherwise
+ */
+extern u32 MCD_funcDescTab0[];
+
+int MCD_initDma(dmaRegs *dmaBarAddr, void *taskTableDest, u32 flags)
+{
+	int i;
+	TaskTableEntry *entryPtr;
+
+	/* Setup the local pointer to register set */
+	MCD_dmaBar = dmaBarAddr;
+
+	/* Do we need to move/create a task table */
+	if ((flags & MCD_RELOC_TASKS) != 0) {
+		int fixedSize;
+		u32 *fixedPtr;
+		int varTabsOffset, funcDescTabsOffset;
+		int contextSavesOffset;
+		int taskDescTabsOffset;
+		int taskTableSize, varTabsSize;
+		int funcDescTabsSize, contextSavesSize;
+		int taskDescTabSize;
+		int i;
+
+		/* Check if physical address is
+		 * aligned on 512 byte boundary */
+		if (((u32)taskTableDest & 0x000001ff) != 0)
+			return MCD_TABLE_UNALIGNED;
+
+		MCD_taskTable = taskTableDest;
+		/* set up local pointer to task Table */
+
+		/*
+		* Create a task table:
+		* compute aligned base offsets for variable tables and
+		* function descriptor tables, then
+		* loop through the task table and setup the pointers
+		*copy over model task table with the the actual
+		*task descriptor tables
+		*/
+		taskTableSize = NCHANNELS * sizeof(TaskTableEntry);
+		/* Align variable tables to size */
+		varTabsOffset = taskTableSize + (u32)taskTableDest;
+		if ((varTabsOffset & (VAR_TAB_SIZE - 1)) != 0)
+			varTabsOffset = (varTabsOffset + VAR_TAB_SIZE)
+				& (~VAR_TAB_SIZE);
+		/* Align function descriptor tables */
+		varTabsSize = NCHANNELS * VAR_TAB_SIZE;
+		funcDescTabsOffset = varTabsOffset + varTabsSize;
+
+		if ((funcDescTabsOffset & (FUNCDESC_TAB_SIZE - 1)) != 0)
+			funcDescTabsOffset = (funcDescTabsOffset
+				+ FUNCDESC_TAB_SIZE) &
+				(~FUNCDESC_TAB_SIZE);
+
+		funcDescTabsSize = FUNCDESC_TAB_NUM * FUNCDESC_TAB_SIZE;
+		contextSavesOffset = funcDescTabsOffset
+			+ funcDescTabsSize;
+		contextSavesSize = (NCHANNELS * CONTEXT_SAVE_SIZE);
+		fixedSize = taskTableSize + varTabsSize +
+			funcDescTabsSize + contextSavesSize;
+
+		/* Zero the thing out */
+		fixedPtr = (u32 *)taskTableDest;
+		for (i = 0; i < (fixedSize/4); i++)
+			fixedPtr[i] = 0;
+
+		entryPtr = (TaskTableEntry *)MCD_taskTable;
+		/* Set up fixed pointers */
+		for (i = 0; i < NCHANNELS; i++) {
+			entryPtr[i].varTab = (u32)varTabsOffset;
+			/* update ptr to local value */
+			entryPtr[i].FDTandFlags =
+			(u32)funcDescTabsOffset | MCD_TT_FLAGS_DEF;
+			entryPtr[i].contextSaveSpace =
+				(u32)contextSavesOffset;
+			varTabsOffset += VAR_TAB_SIZE;
+#ifdef MCD_INCLUDE_EU
+			/* if not there is only one,
+			* just point to the same one */
+			funcDescTabsOffset += FUNCDESC_TAB_SIZE;
+#endif
+			contextSavesOffset += CONTEXT_SAVE_SIZE;
+		}
+		/* Copy over the function descriptor table */
+		for (i = 0; i < FUNCDESC_TAB_NUM; i++) {
+			MCD_memcpy((void *)(entryPtr[i].FDTandFlags
+				& ~MCD_TT_FLAGS_MASK),
+				(void *)MCD_funcDescTab0,
+				FUNCDESC_TAB_SIZE);
+		}
+
+		/* Copy model task table to where the
+		 * context save stuff leaves off */
+		MCD_modelTaskTable =
+			(TaskTableEntry *)contextSavesOffset;
+
+		MCD_memcpy((void *)MCD_modelTaskTable,
+			(void *)MCD_modelTaskTableSrc,
+			NUMOFVARIANTS * sizeof(TaskTableEntry));
+
+		/* Point to local version of model task table */
+		entryPtr = MCD_modelTaskTable;
+		taskDescTabsOffset = (u32)MCD_modelTaskTable +
+			(NUMOFVARIANTS * sizeof(TaskTableEntry));
+
+		/* Copy actual task code and update TDT ptrs
+		 * in local model task table */
+		for (i = 0; i < NUMOFVARIANTS; i++) {
+			taskDescTabSize = entryPtr[i].TDTend
+				- entryPtr[i].TDTstart + 4;
+			MCD_memcpy((void *)taskDescTabsOffset,
+				(void *)entryPtr[i].TDTstart,
+				taskDescTabSize);
+			entryPtr[i].TDTstart =
+				(u32)taskDescTabsOffset;
+			taskDescTabsOffset += taskDescTabSize;
+			entryPtr[i].TDTend =
+				(u32)taskDescTabsOffset - 4;
+		}
+#ifdef MCD_INCLUDE_EU
+		/*
+		 * Tack single DMA BDs onto end of
+		 * code so API controls where
+		 * they are since DMA might write to them
+		 */
+		MCD_relocBuffDesc = (MCD_bufDesc *)
+			(entryPtr[NUMOFVARIANTS - 1].TDTend + 4);
+#else
+		/*
+		 * DMA does not touch them so they
+		 * can be wherever and we don't need to
+		 * waste SRAM on them
+		 */
+		MCD_relocBuffDesc = MCD_singleBufDescs;
+#endif
+	} else {
+		/*
+		 * Point the would-be relocated task tables and
+		 * the buffer descriptors
+		 * to the ones the linker generated
+		 */
+		if (((u32)MCD_realTaskTableSrc & 0x000001ff) != 0)
+			return MCD_TABLE_UNALIGNED;
+
+		entryPtr = MCD_realTaskTableSrc;
+		for (i = 0; i < NCHANNELS; i++) {
+			if (((entryPtr[i].varTab
+				& (VAR_TAB_SIZE - 1)) != 0) ||
+				((entryPtr[i].FDTandFlags &
+				(FUNCDESC_TAB_SIZE - 1)) != 0))
+				return MCD_TABLE_UNALIGNED;
+		}
+
+		MCD_taskTable = MCD_realTaskTableSrc;
+		MCD_modelTaskTable = MCD_modelTaskTableSrc;
+		MCD_relocBuffDesc = MCD_singleBufDescs;
+	}
+
+	/* Make all channels inactive,
+	 * and remember them as such: */
+	MCD_dmaBar->taskbar = (u32) MCD_taskTable;
+	for (i = 0;  i < NCHANNELS;  i++) {
+		MCD_dmaBar->taskControl[i] = 0x0;
+		MCD_chStatus[i] = MCD_NO_DMA;
+	}
+
+	/* Set up pausing mechanism to inactive state: */
+	MCD_dmaBar->debugComp1 = 0;
+	MCD_dmaBar->debugComp2 = 0;
+	MCD_dmaBar->debugControl = DBG_CTL_DISABLE;
+	MCD_dmaBar->debugStatus = DBG_KILL_ALL_STAT;
+
+	/* Enable or disable commbus prefetch */
+	if ((flags & MCD_COMM_PREFETCH_EN) != 0)
+		MCD_dmaBar->ptdControl &= ~PTD_CTL_COMM_PREFETCH;
+	else
+		MCD_dmaBar->ptdControl |= PTD_CTL_COMM_PREFETCH;
+
+	return MCD_OK;
+}
+/*********************** End of MCD_initDma() ***********************/
+
+/********************************************************************/
+/* Function:   MCD_dmaStatus
+ * Purpose:    Returns the status of the DMA on the requested channel
+ * Arguments:  channel - channel number
+ * Returns:    Predefined status indicators
+ */
+int MCD_dmaStatus(int channel)
+{
+	u16 tcrValue;
+
+	if ((channel < 0) || (channel >= NCHANNELS))
+		return MCD_CHANNEL_INVALID;
+
+	tcrValue = MCD_dmaBar->taskControl[channel];
+	if ((tcrValue & TASK_CTL_EN) == 0) {
+		/* Nothing running if last reported
+		 * with task enabled */
+		if (MCD_chStatus[channel] == MCD_RUNNING
+			|| MCD_chStatus[channel] == MCD_IDLE)
+			MCD_chStatus[channel] = MCD_DONE;
+	} else /* something is running */{
+		/* There are three possibilities:
+		 * paused, running or idle. */
+		if (MCD_chStatus[channel] == MCD_RUNNING
+			|| MCD_chStatus[channel] == MCD_IDLE) {
+			MCD_dmaBar->ptdDebug = PTD_DBG_TSK_VLD_INIT;
+			/* Determine which initiator
+			 * is asserted. */
+			if ((MCD_dmaBar->ptdDebug >> channel) & 0x1)
+				MCD_chStatus[channel] = MCD_RUNNING;
+			else
+				MCD_chStatus[channel] = MCD_IDLE;
+		/* Do not change the status if it is already paused */
+		}
+	}
+	return MCD_chStatus[channel];
+}
+/******************** End of MCD_dmaStatus() ************************/
+
+/********************************************************************/
+/* Function:    MCD_startDma
+ * Ppurpose:    Starts a particular kind of DMA
+ * Arguments:   see below
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ */
+
+int MCD_startDma(
+	int  channel,
+/* the channel on which to run the DMA */
+	s8   *srcAddr,
+/* the address to move data from,
+ * or physical buffer-descriptor address */
+	s16  srcIncr,
+/* the amount to increment the source
+ * address per transfer */
+	s8   *destAddr,
+/* the address to move data to */
+	s16  destIncr,
+/* the amount to increment the
+ * destination address per transfer */
+	u32  dmaSize,
+/* the number of bytes to transfer
+ * independent of the transfer size */
+	u32  xferSize,
+/* the number bytes in of each data
+ * movement (1, 2, or 4) */
+	u32  initiator,
+/* what device initiates the DMA */
+	int  priority,
+/* priority of the DMA */
+	u32  flags,
+/* flags describing the DMA */
+	u32  funcDesc
+/* a description of byte swapping,
+ * bit swapping, and CRC actions */
+#ifdef MCD_NEED_ADDR_TRANS
+	s8   *srcAddrVirt
+/* virtual buffer descriptor address TBD*/
+#endif
+)
+{
+	int srcRsdIncr, destRsdIncr;
+	int *cSave;
+	short xferSizeIncr;
+	int tcrCount = 0;
+#ifdef MCD_INCLUDE_EU
+	u32 *realFuncArray;
+#endif
+
+	if ((channel < 0) || (channel >= NCHANNELS))
+		return MCD_CHANNEL_INVALID;
+
+#ifndef MCD_INCLUDE_EU
+	funcDesc = MCD_FUNC_NOEU1;
+#endif
+
+#ifdef MCD_DEBUG
+	printf("startDma:Setting up params\n");
+#endif
+
+	/* Enable task-wise priority */
+	MCD_dmaBar->ptdControl |= (u16) 0x8000;
+
+	/* Calculate additional parameters
+	 * to the regular DMA calls. */
+	srcRsdIncr = srcIncr < 0 ? -1 : (srcIncr > 0 ? 1 : 0);
+	destRsdIncr = destIncr < 0 ? -1 : (destIncr > 0 ? 1 : 0);
+	xferSizeIncr = (xferSize & 0xffff) | 0x20000000;
+
+	/* Remember which variant is running for each channel */
+	MCD_remVariants.remSrcRsdIncr[channel] = srcRsdIncr;
+	MCD_remVariants.remDestRsdIncr[channel] = destRsdIncr;
+	MCD_remVariants.remDestIncr[channel] = destIncr;
+	MCD_remVariants.remSrcIncr[channel] = srcIncr;
+	MCD_remVariants.remXferSize[channel] = xferSize;
+
+	cSave = (int *)(MCD_taskTable[channel].contextSaveSpace)
+		+ CSAVE_OFFSET
+		+ CURRBD;
+
+#ifdef MCD_INCLUDE_EU
+	realFuncArray = (u32 *)(MCD_taskTable[channel].FDTandFlags
+			& 0xffffff00);
+
+	/*
+	* Modify the LURC's normal and byte-residue-loop functions
+	* according to parameter.
+	*/
+	switch (xferSize) {
+	case 4:
+		realFuncArray[(LURC*16)] = funcDesc;
+		break;
+	case 2:
+		realFuncArray[(LURC*16)] = funcDesc & 0xfffff00f;
+		break;
+	case 1:
+	default:
+		realFuncArray[(LURC*16)] = funcDesc & 0xffff000f;
+		break;
+	}
+
+	realFuncArray[(LURC*16 + 1)] = 0
+		| (funcDesc & MCD_BYTE_SWAP_KILLER)
+		| MCD_NO_BYTE_SWAP_ATALL;
+#endif
+
+	/* Write the initiator field in the TCR and
+	 * set the initiator-hold bit*/
+	MCD_dmaBar->taskControl[channel] = 0
+		| (initiator << 8)
+		| TASK_CTL_HIPRITSKEN
+		| TASK_CTL_HLDINITNUM;
+
+	/*
+	* Current versions of the MPC8220 MCD have a hardware quirk that could
+	* cause the write to the TCR to collide with an MDE access to the
+	* initiator-register file, so we have to verify that the write occurred
+	* correctly by reading back the value.  On MCF547x/8x devices and any
+	* future revisions of the MPC8220, this loop will not be entered.
+	*/
+	while (((MCD_dmaBar->taskControl[channel] & 0x1fff) !=
+		((initiator << 8) | TASK_CTL_HIPRITSKEN
+		 | TASK_CTL_HLDINITNUM)) && (tcrCount < 1000))  {
+		tcrCount++;
+		MCD_dmaBar->taskControl[channel] = 0
+			| (initiator << 8)
+			| TASK_CTL_HIPRITSKEN
+			| TASK_CTL_HLDINITNUM;
+	}
+
+	MCD_dmaBar->priority[channel] = (u8)priority & PRIORITY_PRI_MASK;
+
+	if (channel < 8 && channel >= 0) {
+		MCD_dmaBar->taskSize0 &= ~(0xf << (7-channel)*4);
+		MCD_dmaBar->taskSize0
+			|= (xferSize & 3) << (((7 - channel)*4) + 2);
+		MCD_dmaBar->taskSize0
+			|= (xferSize & 3) << ((7 - channel)*4);
+	} else {
+		MCD_dmaBar->taskSize1 &= ~(0xf << (15-channel)*4);
+		MCD_dmaBar->taskSize1
+			|= (xferSize & 3) << (((15 - channel)*4) + 2);
+		MCD_dmaBar->taskSize1
+			|= (xferSize & 3) << ((15 - channel)*4);
+	}
+
+	/* Setup task table flags/options */
+	MCD_taskTable[channel].FDTandFlags &= ~MCD_TT_FLAGS_MASK;
+	MCD_taskTable[channel].FDTandFlags |= (MCD_TT_FLAGS_MASK & flags);
+
+	if (flags & MCD_FECTX_DMA) {
+		/* TDTStart and TDTEnd */
+		MCD_taskTable[channel].TDTstart =
+			MCD_modelTaskTable[TASK_FECTX].TDTstart;
+		MCD_taskTable[channel].TDTend =
+			MCD_modelTaskTable[TASK_FECTX].TDTend;
+		MCD_startDmaENetXmit(srcAddr, srcAddr, destAddr,
+				MCD_taskTable, channel);
+	} else if (flags & MCD_FECRX_DMA) {
+		/* TDTStart and TDTEnd */
+		MCD_taskTable[channel].TDTstart =
+			MCD_modelTaskTable[TASK_FECRX].TDTstart;
+		MCD_taskTable[channel].TDTend =
+			MCD_modelTaskTable[TASK_FECRX].TDTend;
+		MCD_startDmaENetRcv(srcAddr, srcAddr, destAddr,
+			MCD_taskTable, channel);
+	} else if (flags & MCD_SINGLE_DMA) {
+		/*
+		* This buffer descriptor is used for storing off
+		* initial parameters for later progress query
+		* calculation and for the DMA to write the resulting
+		* checksum. The DMA does not use this to determine how
+		* to operate, that info is passed with the init routine
+		*/
+		MCD_relocBuffDesc[channel].srcAddr = srcAddr;
+		MCD_relocBuffDesc[channel].destAddr = destAddr;
+		MCD_relocBuffDesc[channel].lastDestAddr = destAddr;
+		MCD_relocBuffDesc[channel].dmaSize = dmaSize;
+		MCD_relocBuffDesc[channel].flags = 0;
+		/* not used */
+		MCD_relocBuffDesc[channel].csumResult = 0;
+		/* not used */
+		MCD_relocBuffDesc[channel].next = 0;
+		/* not used */
+
+		/* Initialize the progress-querying stuff
+		 * to show no progress:*/
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			SRCPTR + CSAVE_OFFSET] = (int)srcAddr;
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			DESTPTR + CSAVE_OFFSET] = (int)destAddr;
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			DCOUNT + CSAVE_OFFSET] = 0;
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			CURRBD + CSAVE_OFFSET] =
+			(u32) &(MCD_relocBuffDesc[channel]);
+
+		if ((funcDesc == MCD_FUNC_NOEU1)
+			|| (funcDesc == MCD_FUNC_NOEU2)) {
+			/* TDTStart and TDTEnd */
+			MCD_taskTable[channel].TDTstart =
+				MCD_modelTaskTable[TASK_SINGLENOEU].TDTstart;
+			MCD_taskTable[channel].TDTend =
+				MCD_modelTaskTable[TASK_SINGLENOEU].TDTend;
+			MCD_startDmaSingleNoEu(srcAddr, srcIncr, destAddr,
+				destIncr, dmaSize, xferSizeIncr, flags,
+				(int *)&(MCD_relocBuffDesc[channel]),
+				cSave, MCD_taskTable, channel);
+		} else {
+			/* TDTStart and TDTEnd */
+			MCD_taskTable[channel].TDTstart =
+				MCD_modelTaskTable[TASK_SINGLEEU].TDTstart;
+			MCD_taskTable[channel].TDTend =
+				MCD_modelTaskTable[TASK_SINGLEEU].TDTend;
+			MCD_startDmaSingleEu(srcAddr, srcIncr, destAddr,
+				destIncr, dmaSize, xferSizeIncr, flags,
+				(int *)&(MCD_relocBuffDesc[channel]),
+				cSave, MCD_taskTable, channel);
+		}
+	} else /* Chained DMA */ {
+		/* Initialize the progress-querying
+		 * stuff to show no progress:*/
+#if 1 /* (!defined(MCD_NEED_ADDR_TRANS)) */
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			SRCPTR + CSAVE_OFFSET]
+			= (int)((MCD_bufDesc *) srcAddr)->srcAddr;
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			DESTPTR + CSAVE_OFFSET]
+			= (int)((MCD_bufDesc *) srcAddr)->destAddr;
+#else
+	/* if using address translation, need the
+	 * virtual addr of the first buffdesc */
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			SRCPTR + CSAVE_OFFSET]
+			= (int)((MCD_bufDesc *) srcAddrVirt)->srcAddr;
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			DESTPTR + CSAVE_OFFSET]
+			= (int)((MCD_bufDesc *) srcAddrVirt)->destAddr;
+#endif
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			DCOUNT + CSAVE_OFFSET] = 0;
+		((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+			CURRBD + CSAVE_OFFSET] = (u32) srcAddr;
+
+		if (funcDesc == MCD_FUNC_NOEU1
+			|| funcDesc == MCD_FUNC_NOEU2) {
+			/* TDTStart and TDTEnd */
+			MCD_taskTable[channel].TDTstart =
+				MCD_modelTaskTable[TASK_CHAINNOEU].TDTstart;
+			MCD_taskTable[channel].TDTend =
+				MCD_modelTaskTable[TASK_CHAINNOEU].TDTend;
+			MCD_startDmaChainNoEu((int *)srcAddr, srcIncr,
+				destIncr, xferSize, xferSizeIncr, cSave,
+				MCD_taskTable, channel);
+		} else {
+			/* TDTStart and TDTEnd */
+			MCD_taskTable[channel].TDTstart =
+				MCD_modelTaskTable[TASK_CHAINEU].TDTstart;
+			MCD_taskTable[channel].TDTend =
+				MCD_modelTaskTable[TASK_CHAINEU].TDTend;
+			MCD_startDmaChainEu((int *)srcAddr, srcIncr, destIncr,
+				xferSize, xferSizeIncr, cSave,
+				MCD_taskTable, channel);
+		}
+	}
+
+	MCD_chStatus[channel] = MCD_IDLE;
+	return MCD_OK;
+}
+
+/************************ End of MCD_startDma() *********************/
+
+/********************************************************************/
+/* Function:    MCD_XferProgrQuery
+ * Purpose:     Returns progress of DMA on requested channel
+ * Arguments:   channel - channel to retrieve progress for
+ *              progRep - pointer to user supplied MCD_XferProg struct
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ *
+ * Notes:
+ *  MCD_XferProgrQuery() upon completing or after aborting a DMA, or
+ *  while the DMA is in progress, this function returns the first
+ *  DMA-destination address not (or not yet) used in the DMA. When
+ *  encountering a non-ready buffer descriptor, the information for
+ *  the last completed descriptor is returned.
+ *
+ *  MCD_XferProgQuery() has to avoid the possibility of getting
+ *  partially-updated information in the event that we should happen
+ *  to query DMA progress just as the DMA is updating it. It does that
+ *  by taking advantage of the fact context is not saved frequently for
+ *  the most part. We therefore read it at least twice until we get the
+ *  same information twice in a row.
+ *
+ *  Because a small, but not insignificant, amount of time is required
+ *  to write out the progress-query information, especially upon
+ *  completion of the DMA, it would be wise to guarantee some time lag
+ *  between successive readings of the progress-query information.
+ */
+
+/*
+ * How many iterations of the loop below to execute to stabilize values
+ */
+#define STABTIME 0
+
+int MCD_XferProgrQuery(int channel, MCD_XferProg *progRep)
+{
+	MCD_XferProg prevRep;
+	int again;
+	/* true if we are to try again to get consistent results */
+	int i;  /* used as a time-waste counter */
+	int destDiffBytes;
+	/* Total number of bytes that we think actually got xfered. */
+	int numIterations; /* number of iterations */
+	int bytesNotXfered; /* bytes that did not get xfered. */
+	s8 *LWAlignedInitDestAddr, *LWAlignedCurrDestAddr;
+	int subModVal, addModVal;
+	/* Mode values to added and subtracted from the final destAddr */
+
+	if ((channel < 0) || (channel >= NCHANNELS))
+		return MCD_CHANNEL_INVALID;
+
+	/* Read a trial value for the progress-reporting values*/
+	prevRep.lastSrcAddr =
+	(s8 *)((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+		SRCPTR + CSAVE_OFFSET];
+	prevRep.lastDestAddr =
+	(s8 *)((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+		DESTPTR + CSAVE_OFFSET];
+	prevRep.dmaSize =
+	((volatile int *)MCD_taskTable[channel].contextSaveSpace)[
+		DCOUNT + CSAVE_OFFSET];
+	prevRep.currBufDesc =
+		(MCD_bufDesc *)((volatile int *)MCD_taskTable[
+		channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET];
+
+	/* Repeatedly reread those values until
+	 * they match previous values: */
+	do {
+		/* Take a little bit of time to ensure stability: */
+		for (i = 0;  i < STABTIME;  i++)
+			i += i >> 2;
+		/* make sure this loop does something so that it
+		 doesn't get optimized out */
+		/* Check them again: */
+		progRep->lastSrcAddr =
+			(s8 *)((volatile int *)MCD_taskTable[
+			channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET];
+		progRep->lastDestAddr =
+			(s8 *)((volatile int *)MCD_taskTable[
+			channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET];
+		progRep->dmaSize = ((volatile int *)MCD_taskTable[
+			channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET];
+		progRep->currBufDesc =
+		(MCD_bufDesc *)((volatile int *)MCD_taskTable[
+			channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET];
+
+		/* See if they match: */
+		if (prevRep.lastSrcAddr  != progRep->lastSrcAddr
+			|| prevRep.lastDestAddr != progRep->lastDestAddr
+			|| prevRep.dmaSize      != progRep->dmaSize
+			|| prevRep.currBufDesc  != progRep->currBufDesc) {
+			/* If they don't match, remember previous
+			values and try again:*/
+			prevRep.lastSrcAddr = progRep->lastSrcAddr;
+			prevRep.lastDestAddr = progRep->lastDestAddr;
+			prevRep.dmaSize = progRep->dmaSize;
+			prevRep.currBufDesc = progRep->currBufDesc;
+			again = MCD_TRUE;
+		} else
+			again = MCD_FALSE;
+	} while (again == MCD_TRUE);
+
+
+	/* Update dmaSize and lastDestAddr */
+	switch (MCD_remVariants.remDestRsdIncr[channel]) {
+	case MINUS1:
+		subModVal = ((int)progRep->lastDestAddr)
+			& ((MCD_remVariants.remXferSize[channel]) - 1);
+		addModVal = ((int)progRep->currBufDesc->destAddr)
+			& ((MCD_remVariants.remXferSize[channel]) - 1);
+		LWAlignedInitDestAddr = (progRep->currBufDesc->destAddr)
+			- addModVal;
+		LWAlignedCurrDestAddr = (progRep->lastDestAddr) - subModVal;
+		destDiffBytes = LWAlignedInitDestAddr - LWAlignedCurrDestAddr;
+		bytesNotXfered =
+			(destDiffBytes/MCD_remVariants.remDestIncr[channel]) *
+			(MCD_remVariants.remDestIncr[channel]
+			  + MCD_remVariants.remXferSize[channel]);
+		progRep->dmaSize = destDiffBytes - bytesNotXfered
+			+ addModVal - subModVal;
+		break;
+	case ZERO:
+		progRep->lastDestAddr = progRep->currBufDesc->destAddr;
+		break;
+	case PLUS1:
+		/* This value has to be subtracted
+		 from the final calculated dmaSize. */
+		subModVal = ((int)progRep->currBufDesc->destAddr)
+			& ((MCD_remVariants.remXferSize[channel]) - 1);
+		/* These bytes are already in lastDestAddr. */
+		addModVal = ((int)progRep->lastDestAddr)
+			& ((MCD_remVariants.remXferSize[channel]) - 1);
+		LWAlignedInitDestAddr = (progRep->currBufDesc->destAddr)
+			- subModVal;
+		LWAlignedCurrDestAddr = (progRep->lastDestAddr) - addModVal;
+		destDiffBytes = (progRep->lastDestAddr - LWAlignedInitDestAddr);
+		numIterations = (LWAlignedCurrDestAddr -
+		LWAlignedInitDestAddr)/MCD_remVariants.remDestIncr[channel];
+		bytesNotXfered =  numIterations *
+			(MCD_remVariants.remDestIncr[channel]
+			 - MCD_remVariants.remXferSize[channel]);
+		progRep->dmaSize = destDiffBytes - bytesNotXfered - subModVal;
+		break;
+	default:
+		break;
+	}
+
+	/* This covers M1,P1,Z for source */
+	switch (MCD_remVariants.remSrcRsdIncr[channel]) {
+	case MINUS1:
+		progRep->lastSrcAddr =
+			progRep->currBufDesc->srcAddr +
+			(MCD_remVariants.remSrcIncr[channel] *
+		 (progRep->dmaSize/MCD_remVariants.remXferSize[channel]));
+		break;
+	case ZERO:
+		progRep->lastSrcAddr = progRep->currBufDesc->srcAddr;
+		break;
+	case PLUS1:
+		progRep->lastSrcAddr =
+			progRep->currBufDesc->srcAddr +
+			(MCD_remVariants.remSrcIncr[channel] *
+		 (progRep->dmaSize/MCD_remVariants.remXferSize[channel]));
+		break;
+	default:
+		break;
+	}
+
+	return MCD_OK;
+}
+/******************* End of MCD_XferProgrQuery() ********************/
+
+/********************************************************************/
+/* MCD_resmActions() does the majority of the actions of a DMA resume.
+ * It is called from MCD_killDma() and MCD_resumeDma().  It has to be
+ * a separate function because the kill function has to negate the task
+ * enable before resuming it, but the resume function has to do nothing
+ * if there is no DMA on that channel (i.e., if the enable bit is 0).
+ */
+static void MCD_resmActions(int channel)
+{
+	MCD_dmaBar->debugControl = DBG_CTL_DISABLE;
+	MCD_dmaBar->debugStatus = MCD_dmaBar->debugStatus;
+
+	/* Determine which initiators are asserted */
+	MCD_dmaBar->ptdDebug = PTD_DBG_TSK_VLD_INIT;
+
+	if ((MCD_dmaBar->ptdDebug >> channel) & 0x1)
+		MCD_chStatus[channel] = MCD_RUNNING;
+	else
+		MCD_chStatus[channel] = MCD_IDLE;
+}
+/********************* End of MCD_resmActions() *********************/
+
+/********************************************************************/
+/* Function:    MCD_killDma
+ * Purpose:     Halt the DMA on the requested channel, without any
+ *              intention of resuming the DMA.
+ * Arguments:   channel - requested channel
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ *
+ * Notes:
+ *  A DMA may be killed from any state, including paused state, and it
+ *  always goes to the MCD_HALTED state even if it is killed while in
+ *  the MCD_NO_DMA or MCD_IDLE states.
+ */
+int MCD_killDma(int channel)
+{
+	if ((channel < 0) || (channel >= NCHANNELS))
+		return MCD_CHANNEL_INVALID;
+
+	MCD_dmaBar->taskControl[channel] = 0x0;
+
+	/* Clean up after a paused task */
+	if (MCD_chStatus[channel] == MCD_PAUSED) {
+		MCD_dmaBar->debugControl = DBG_CTL_DISABLE;
+		MCD_dmaBar->debugStatus = MCD_dmaBar->debugStatus;
+	}
+
+	MCD_chStatus[channel] = MCD_HALTED;
+
+	return MCD_OK;
+}
+/************************ End of MCD_killDma() **********************/
+
+/********************************************************************/
+/* Function:    MCD_continDma
+ * Purpose:     Continue a DMA which as stopped due to encountering an
+ *              unready buffer descriptor.
+ * Arguments:   channel - channel to continue the DMA on
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ *
+ * Notes:
+ *  This routine does not check to see if there is a task which can
+ *  be continued. Also this routine should not be used with single DMAs.
+ */
+int MCD_continDma(int channel)
+{
+	if ((channel < 0) || (channel >= NCHANNELS))
+		return MCD_CHANNEL_INVALID;
+
+	MCD_dmaBar->taskControl[channel] |= TASK_CTL_EN;
+	MCD_chStatus[channel] = MCD_RUNNING;
+
+	return MCD_OK;
+}
+/********************** End of MCD_continDma() **********************/
+
+/*********************************************************************
+ * MCD_pauseDma() and MCD_resumeDma() below use the DMA's debug unit
+ * to freeze a task and resume it.  We freeze a task by breakpointing
+ * on the stated task.  That is, not any specific place in the task,
+ * but any time that task executes.  In particular, when that task
+ * executes, we want to freeze that task and only that task.
+ *
+ * The bits of the debug control register influence interrupts vs.
+ * breakpoints as follows:
+ * - Bits 14 and 0 enable or disable debug functions.  If enabled, you
+ *   will get the interrupt but you may or may not get a breakpoint.
+ * - Bits 2 and 1 decide whether you also get a breakpoint in addition
+ *   to an interrupt.
+ *
+ * The debug unit can do these actions in response to either internally
+ * detected breakpoint conditions from the comparators, or in response
+ * to the external breakpoint pin, or both.
+ * - Bits 14 and 1 perform the above-described functions for
+ *   internally-generated conditions, i.e., the debug comparators.
+ * - Bits 0 and 2 perform the above-described functions for external
+ *   conditions, i.e., the breakpoint external pin.
+ *
+ * Note that, although you "always" get the interrupt when you turn
+ * the debug functions, the interrupt can nevertheless, if desired, be
+ * masked by the corresponding bit in the PTD's IMR. Note also that
+ * this means that bits 14 and 0 must enable debug functions before
+ * bits 1 and 2, respectively, have any effect.
+ *
+ * NOTE: It's extremely important to not pause more than one DMA channel
+ *  at a time.
+ ********************************************************************/
+
+/********************************************************************/
+/* Function:    MCD_pauseDma
+ * Purpose:     Pauses the DMA on a given channel (if any DMA is running
+ *              on that channel).
+ * Arguments:   channel
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ */
+int MCD_pauseDma(int channel)
+{
+	if ((channel < 0) || (channel >= NCHANNELS))
+		return MCD_CHANNEL_INVALID;
+
+	if (MCD_dmaBar->taskControl[channel] & TASK_CTL_EN) {
+		MCD_dmaBar->debugComp1 = channel;
+		MCD_dmaBar->debugControl =
+			DBG_CTL_ENABLE | (1 << (channel + 16));
+		MCD_chStatus[channel] = MCD_PAUSED;
+	}
+
+	return MCD_OK;
+}
+/************************* End of MCD_pauseDma() ********************/
+
+/********************************************************************/
+/* Function:    MCD_resumeDma
+ * Purpose:     Resumes the DMA on a given channel (if any DMA is
+ *              running on that channel).
+ * Arguments:   channel - channel on which to resume DMA
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ */
+int MCD_resumeDma(int channel)
+{
+	if ((channel < 0) || (channel >= NCHANNELS))
+		return MCD_CHANNEL_INVALID;
+
+	if (MCD_dmaBar->taskControl[channel] & TASK_CTL_EN)
+		MCD_resmActions(channel);
+
+	return MCD_OK;
+}
+/************************ End of MCD_resumeDma() ********************/
+
+/********************************************************************/
+/* Function:    MCD_csumQuery
+ * Purpose:     Provide the checksum after performing a non-chained DMA
+ * Arguments:   channel - channel to report on
+ *              csum - pointer to where to write the checksum/CRC
+ * Returns:     MCD_ERROR if the channel is invalid, else MCD_OK
+ *
+ * Notes:
+ *
+ */
+int MCD_csumQuery(int channel, u32 *csum)
+{
+#ifdef MCD_INCLUDE_EU
+	if ((channel < 0) || (channel >= NCHANNELS))
+		return MCD_CHANNEL_INVALID;
+
+	*csum = MCD_relocBuffDesc[channel].csumResult;
+	return MCD_OK;
+#else
+	return MCD_ERROR;
+#endif
+}
+/*********************** End of MCD_resumeDma() *********************/
+
+/********************************************************************/
+/* Function:    MCD_getCodeSize
+ * Purpose:     Provide the size requirements of the microcoded tasks
+ * Returns:     Size in bytes
+ */
+int MCD_getCodeSize(void)
+{
+#ifdef MCD_INCLUDE_EU
+	return 0x2b64;
+#else
+	return 0x1744;
+#endif
+}
+/********************** End of MCD_getCodeSize() ********************/
+
+/********************************************************************/
+/* Function:    MCD_getVersion
+ * Purpose:     Provide the version string and number
+ * Arguments:   longVersion - user supplied pointer to a pointer to a char
+ *                    which points to the version string
+ * Returns:     Version number and version string (by reference)
+ */
+char MCD_versionString[] = "Multi-channel DMA API v1.0";
+#define MCD_REV_MAJOR   0x01
+#define MCD_REV_MINOR   0x00
+
+int MCD_getVersion(char **longVersion)
+{
+	int ret = 0;
+	*longVersion = MCD_versionString;
+	ret = (MCD_REV_MAJOR << 8) | MCD_REV_MINOR;
+	return ret;
+}
+/********************** End of MCD_getVersion() *********************/
+
+/********************************************************************/
+/* Private version of memcpy()
+ * Note that everything this is used for is longword-aligned.
+ */
+static void MCD_memcpy(int *dest, int *src, u32 size)
+{
+	u32 i;
+
+	for (i = 0;  i < size;  i += sizeof(int), dest++, src++)
+		*dest = *src;
+}
+/********************************************************************/
--- /dev/null
+++ b/drivers/dma/MCD_progCheck.h
@@ -0,0 +1,29 @@
+/*
+ * drivers/dma/MCD_progCheck.h
+ *
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Kurt Mahan <kmahan@freescale.com>
+ * Shrek Wu b16972@freescale.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* This file is autogenerated. Do not change */
+
+#define CURRBD 4
+#define DCOUNT 6
+#define DESTPTR 5
+#define SRCPTR 7
--- /dev/null
+++ b/drivers/dma/MCD_tasks.c
@@ -0,0 +1,2457 @@
+/*
+ * drivers/dma/MCD_tasks.c
+ *
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Kurt Mahan <kmahan@freescale.com>
+ * Shrek Wu b16972@freescale.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "MCD_dma.h"
+
+u32 MCD_varTab0[];
+u32 MCD_varTab1[];
+u32 MCD_varTab2[];
+u32 MCD_varTab3[];
+u32 MCD_varTab4[];
+u32 MCD_varTab5[];
+u32 MCD_varTab6[];
+u32 MCD_varTab7[];
+u32 MCD_varTab8[];
+u32 MCD_varTab9[];
+u32 MCD_varTab10[];
+u32 MCD_varTab11[];
+u32 MCD_varTab12[];
+u32 MCD_varTab13[];
+u32 MCD_varTab14[];
+u32 MCD_varTab15[];
+
+u32 MCD_funcDescTab0[];
+#ifdef MCD_INCLUDE_EU
+u32 MCD_funcDescTab1[];
+u32 MCD_funcDescTab2[];
+u32 MCD_funcDescTab3[];
+u32 MCD_funcDescTab4[];
+u32 MCD_funcDescTab5[];
+u32 MCD_funcDescTab6[];
+u32 MCD_funcDescTab7[];
+u32 MCD_funcDescTab8[];
+u32 MCD_funcDescTab9[];
+u32 MCD_funcDescTab10[];
+u32 MCD_funcDescTab11[];
+u32 MCD_funcDescTab12[];
+u32 MCD_funcDescTab13[];
+u32 MCD_funcDescTab14[];
+u32 MCD_funcDescTab15[];
+#endif
+
+u32 MCD_contextSave0[];
+u32 MCD_contextSave1[];
+u32 MCD_contextSave2[];
+u32 MCD_contextSave3[];
+u32 MCD_contextSave4[];
+u32 MCD_contextSave5[];
+u32 MCD_contextSave6[];
+u32 MCD_contextSave7[];
+u32 MCD_contextSave8[];
+u32 MCD_contextSave9[];
+u32 MCD_contextSave10[];
+u32 MCD_contextSave11[];
+u32 MCD_contextSave12[];
+u32 MCD_contextSave13[];
+u32 MCD_contextSave14[];
+u32 MCD_contextSave15[];
+
+u32 MCD_realTaskTableSrc[] = {
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab0,   /* Task 0 Variable Table */
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave0,  /* Task 0 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab1,   /* Task 1 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab1,  /* Task 1 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave1,  /* Task 1 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab2,   /* Task 2 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab2,  /* Task 2 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave2,  /* Task 2 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab3,   /* Task 3 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab3,  /* Task 3 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave3,  /* Task 3 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab4,   /* Task 4 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab4,  /* Task 4 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave4,  /* Task 4 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab5,   /* Task 5 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab5,  /* Task 5 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave5,  /* Task 5 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab6,   /* Task 6 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab6,  /* Task 6 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave6,  /* Task 6 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab7,   /* Task 7 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab7,  /* Task 7 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave7,  /* Task 7 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab8,   /* Task 8 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab8,  /* Task 8 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave8,  /* Task 8 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab9,   /* Task 9 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab9,  /* Task 9 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave9,  /* Task 9 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab10,  /* Task 10 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab10, /* Task 10 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave10, /* Task 10 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab11,  /* Task 11 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab11, /* Task 11 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave11, /* Task 11 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab12,  /* Task 12 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab12, /* Task 12 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave12, /* Task 12 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab13,  /* Task 13 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab13, /* Task 13 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave13, /* Task 13 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab14,  /* Task 14 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab14, /* Task 14 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave14, /* Task 14 context save space */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_varTab15,  /* Task 15 Variable Table */
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_funcDescTab15, /* Task 15 Function Descriptor Table & Flags */
+#else
+	(u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+	0x00000000,
+	0x00000000,
+	(u32)MCD_contextSave15, /* Task 15 context save space */
+	0x00000000,
+};
+
+
+u32 MCD_varTab0[] = {
+/* Task 0 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+
+u32 MCD_varTab1[] = {
+/* Task 1 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab2[] = {
+/* Task 2 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab3[] = {
+/* Task 3 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab4[] = {
+/* Task 4 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab5[] = {
+/* Task 5 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab6[] = {
+/* Task 6 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab7[] = {
+/* Task 7 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab8[] = {
+/* Task 8 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab9[] = {
+/* Task 9 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab10[] = {
+/* Task 10 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab11[] = {
+/* Task 11 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab12[] = {
+/* Task 12 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab13[] = {
+/* Task 13 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab14[] = {
+/* Task 14 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab15[] = {
+/* Task 15 Variable Table */
+	0x00000000, /* var[0] */
+	0x00000000, /* var[1] */
+	0x00000000, /* var[2] */
+	0x00000000, /* var[3] */
+	0x00000000, /* var[4] */
+	0x00000000, /* var[5] */
+	0x00000000, /* var[6] */
+	0x00000000, /* var[7] */
+	0x00000000, /* var[8] */
+	0x00000000, /* var[9] */
+	0x00000000, /* var[10] */
+	0x00000000, /* var[11] */
+	0x00000000, /* var[12] */
+	0x00000000, /* var[13] */
+	0x00000000, /* var[14] */
+	0x00000000, /* var[15] */
+	0x00000000, /* var[16] */
+	0x00000000, /* var[17] */
+	0x00000000, /* var[18] */
+	0x00000000, /* var[19] */
+	0x00000000, /* var[20] */
+	0x00000000, /* var[21] */
+	0x00000000, /* var[22] */
+	0x00000000, /* var[23] */
+	0xe0000000, /* inc[0] */
+	0x20000000, /* inc[1] */
+	0x2000ffff, /* inc[2] */
+	0x00000000, /* inc[3] */
+	0x00000000, /* inc[4] */
+	0x00000000, /* inc[5] */
+	0x00000000, /* inc[6] */
+	0x00000000, /* inc[7] */
+};
+
+u32 MCD_funcDescTab0[] = {
+/* Task 0 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+#ifdef MCD_INCLUDE_EU
+u32 MCD_funcDescTab1[] = {
+/* Task 1 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab2[] = {
+/* Task 2 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab3[] = {
+/* Task 3 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab4[] = {
+/* Task 4 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab5[] = {
+/* Task 5 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab6[] = {
+/* Task 6 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab7[] = {
+/* Task 7 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab8[] = {
+/* Task 8 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab9[] = {
+/* Task 9 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab10[] = {
+/* Task 10 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab11[] = {
+/* Task 11 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab12[] = {
+/* Task 12 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab13[] = {
+/* Task 13 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab14[] = {
+/* Task 14 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab15[] = {   /* Task 15 Function Descriptor Table */
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0xa0045670, /* mainFunc(), EU# 3 */
+	0xa0000000, /* rsduFunc(), EU# 3 */
+	0xa0000000, /* crcAccumVal(), EU# 3 */
+	0x20000000, /* setCrcAccum(), EU# 3 */
+	0x21800000, /* and(), EU# 3 */
+	0x21e00000, /* or(), EU# 3 */
+	0x20400000, /* add(), EU# 3 */
+	0x20500000, /* sub(), EU# 3 */
+	0x205a0000, /* andNot(), EU# 3 */
+	0x20a00000, /* shiftR(), EU# 3 */
+	0x202fa000, /* andReadyBit(), EU# 3 */
+	0x202f9000, /* andNotReadyBit(), EU# 3 */
+	0x202ea000, /* andWrapBit(), EU# 3 */
+	0x202da000, /* andLastBit(), EU# 3 */
+	0x202e2000, /* andInterruptBit(), EU# 3 */
+	0x202f2000, /* andCrcRestartBit(), EU# 3 */
+};
+#endif /*MCD_INCLUDE_EU*/
+
+u32 MCD_contextSave0[128];  /* Task 0 context save space */
+u32 MCD_contextSave1[128];  /* Task 1 context save space */
+u32 MCD_contextSave2[128];  /* Task 2 context save space */
+u32 MCD_contextSave3[128];  /* Task 3 context save space */
+u32 MCD_contextSave4[128];  /* Task 4 context save space */
+u32 MCD_contextSave5[128];  /* Task 5 context save space */
+u32 MCD_contextSave6[128];  /* Task 6 context save space */
+u32 MCD_contextSave7[128];  /* Task 7 context save space */
+u32 MCD_contextSave8[128];  /* Task 8 context save space */
+u32 MCD_contextSave9[128];  /* Task 9 context save space */
+u32 MCD_contextSave10[128]; /* Task 10 context save space */
+u32 MCD_contextSave11[128]; /* Task 11 context save space */
+u32 MCD_contextSave12[128]; /* Task 12 context save space */
+u32 MCD_contextSave13[128]; /* Task 13 context save space */
+u32 MCD_contextSave14[128]; /* Task 14 context save space */
+u32 MCD_contextSave15[128]; /* Task 15 context save space */
+
+u32 MCD_ChainNoEu_TDT[];
+u32 MCD_SingleNoEu_TDT[];
+#ifdef MCD_INCLUDE_EU
+u32 MCD_ChainEu_TDT[];
+u32 MCD_SingleEu_TDT[];
+#endif
+u32 MCD_ENetRcv_TDT[];
+u32 MCD_ENetXmit_TDT[];
+
+u32 MCD_modelTaskTableSrc[] = {
+	(u32)MCD_ChainNoEu_TDT,
+	(u32)&((u8 *)MCD_ChainNoEu_TDT)[0x0000016c],
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_SingleNoEu_TDT,
+	(u32)&((u8 *)MCD_SingleNoEu_TDT)[0x000000d4],
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+#ifdef MCD_INCLUDE_EU
+	(u32)MCD_ChainEu_TDT,
+	(u32)&((u8 *)MCD_ChainEu_TDT)[0x000001b4],
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_SingleEu_TDT,
+	(u32)&((u8 *)MCD_SingleEu_TDT)[0x00000124],
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+#endif
+	(u32)MCD_ENetRcv_TDT,
+	(u32)&((u8 *)MCD_ENetRcv_TDT)[0x000000a4],
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	(u32)MCD_ENetXmit_TDT,
+	(u32)&((u8 *)MCD_ENetXmit_TDT)[0x000000d0],
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+u32 MCD_ChainNoEu_TDT[] = {
+	0x80004000,
+	0x8118801b,
+	0xb8c60018,
+	0x10002b10,
+	0x7000000d,
+	0x018cf89f,
+	0x6000000a,
+	0x080cf89f,
+	0x000001f8,
+	0x98180364,
+	0x8118801b,
+	0xf8c6001a,
+	0xb8c6601b,
+	0x10002710,
+	0x00000f18,
+	0xb8c6001d,
+	0x10001310,
+	0x60000007,
+	0x014cf88b,
+	0x98c6001c,
+	0x00000710,
+	0x98c70018,
+	0x10001f10,
+	0x0000c818,
+	0x000001f8, /* 0060(:0):      NOP */
+	0xc1476018,
+	0xc003231d,
+	0x811a601b,
+	0xc1862102,
+	0x849be009,
+	0x03fed7b8,
+	0xda9b001b,
+	0x9b9be01b,
+	0x1000cb20,
+	0x70000006,
+	0x088cf88f,
+	0x1000cb28,
+	0x70000006,
+	0x088cf88f,
+	0x1000cb30,
+	0x70000006,
+	0x088cf88f,
+	0x1000cb38,
+	0x0000c728,
+	0x000001f8, /* 00B0(:0):      NOP */
+	0xc1476018,
+	0xc003241d,
+	0x811a601b,
+	0xda9b001b,
+	0x9b9be01b,
+	0x0000d3a0,
+	0xc1862102,
+	0x849be009,
+	0x0bfed7b8,
+	0xda9b001b,
+	0x9b9be01b,
+	0x1000cb20,
+	0x70000006,
+	0x088cf88f,
+	0x1000cb28,
+	0x70000006,
+	0x088cf88f,
+	0x1000cb30,
+	0x70000006,
+	0x088cf88f,
+	0x1000cb38,
+	0x0000c728,
+	0x000001f8, /* 010C(:0):      NOP */
+	0x8118801b,
+	0xd8c60018,
+	0x98c6601c,
+	0x6000000b,
+	0x0c8cfc9f,
+	0x000001f8, /* 0124(:0):      NOP */
+	0xa146001e,
+	0x10000b08,
+	0x10002050,
+	0xb8c60018,
+	0x10002b10,
+	0x7000000a,
+	0x080cf89f,
+	0x6000000d,
+	0x018cf89f,
+	0x000001f8, /* 014C(:0):      NOP */
+	0x8618801b,
+	0x7000000e,
+	0x084cf21f,
+	0xd8990336,
+	0x8019801b,
+	0x040001f8,
+	0x000001f8, /* 0168(:0):      NOP */
+	0x000001f8, /* 016C(:0):    NOP */
+};
+u32 MCD_SingleNoEu_TDT[] = {
+	0x8198001b,
+	0x7000000d,
+	0x080cf81f,
+	0x8198801b,
+	0x6000000e,
+	0x084cf85f,
+	0x000001f8, /* 0018(:0):    NOP */
+	0x8298001b,
+	0x7000000d,
+	0x010cf81f,
+	0x6000000e,
+	0x018cf81f,
+	0xc202601b,
+	0xc002221c,
+	0x809a601b,
+	0xc10420c2,
+	0x839be009,
+	0x03fed7b8,
+	0xda9b001b,
+	0x9b9be01b,
+	0x70000006,
+	0x088cf889,
+	0x1000cb28,
+	0x70000006,
+	0x088cf889,
+	0x1000cb30,
+	0x70000006,
+	0x088cf889,
+	0x0000cb38,
+	0x000001f8, /* 0074(:0):    NOP */
+	0xc202601b,
+	0xc002229c,
+	0x809a601b,
+	0xda9b001b,
+	0x9b9be01b,
+	0x0000d3a0,
+	0xc10420c2,
+	0x839be009,
+	0x0bfed7b8,
+	0xda9b001b,
+	0x9b9be01b,
+	0x70000006,
+	0x088cf889,
+	0x1000cb28,
+	0x70000006,
+	0x088cf889,
+	0x1000cb30,
+	0x70000006,
+	0x088cf889,
+	0x0000cb38,
+	0x000001f8, /* 00C8(:0):    NOP */
+	0xc318022d,
+	0x8018801b,
+	0x040001f8,
+};
+#ifdef MCD_INCLUDE_EU
+u32 MCD_ChainEu_TDT[] = {
+	0x80004000,
+	0x8198801b,
+	0xb8c68018,
+	0x10002f10,
+	0x7000000d,
+	0x01ccf89f,
+	0x6000000a,
+	0x080cf89f,
+	0x000001f8,
+	0x981803a4,
+	0x8198801b,
+	0xf8c6801a,
+	0xb8c6e01b,
+	0x10002b10,
+	0x00001318,
+	0xb8c6801d,
+	0x10001710,
+	0x60000007,
+	0x018cf88c,
+	0x98c6801c,
+	0x00000b10,
+	0x98c78018,
+	0x10002310,
+	0x0000c820,
+	0x000001f8, /* 0060(:0):      NOP */
+	0x8698801b,
+	0x7000000f,
+	0x084cf2df,
+	0xd899042d,
+	0x8019801b,
+	0x60000003,
+	0x2cd7c7df, /* 007C(:979):        DRD2B2: EU3(var13)  */
+	0xd8990364,
+	0x8019801b,
+	0x60000003,
+	0x2c17c7df, /* 008C(:981):        DRD2B2: EU3(var1)  */
+	0x000001f8, /* 0090(:0):      NOP */
+	0xc1c7e018,
+	0xc003a35e,
+	0x819a601b,
+	0xc206a142,
+	0x851be009,
+	0x63fe0000,
+	0x0d4cfddf,
+	0xda9b001b,
+	0x9b9be01b,
+	0x70000002,
+	0x004cf81f,
+	0x1000cb20,
+	0x70000006,
+	0x088cf891,
+	0x1000cb28,
+	0x70000006,
+	0x088cf891,
+	0x1000cb30,
+	0x70000006,
+	0x088cf891,
+	0x1000cb38,
+	0x0000c728,
+	0x000001f8, /* 00EC(:0):      NOP */
+	0xc1c7e018,
+	0xc003a49e,
+	0x819a601b,
+	0xda9b001b,
+	0x9b9be01b,
+	0x0000d3a0,
+	0xc206a142,
+	0x851be009,
+	0x6bfe0000,
+	0x0d4cfddf,
+	0xda9b001b,
+	0x9b9be01b,
+	0x70000002,
+	0x004cf81f,
+	0x1000cb20,
+	0x70000006,
+	0x088cf891,
+	0x1000cb28,
+	0x70000006,
+	0x088cf891,
+	0x1000cb30,
+	0x70000006,
+	0x088cf891,
+	0x1000cb38,
+	0x0000c728,
+	0x000001f8, /* 0154(:0):      NOP */
+	0x8198801b,
+	0xd8c68018,
+	0x98c6e01c,
+	0x6000000b,
+	0x0c8cfc9f,
+	0x0000cc08,
+	0xa1c6801e,
+	0x10000f08,
+	0x10002458,
+	0xb8c68018,
+	0x10002f10,
+	0x7000000a,
+	0x080cf89f,
+	0x6000000d,
+	0x01ccf89f,
+	0x000001f8, /* 0194(:0):      NOP */
+	0x8698801b,
+	0x7000000e,
+	0x084cf25f,
+	0xd899037f,
+	0x8019801b,
+	0x040001f8,
+	0x000001f8, /* 01B0(:0):      NOP */
+	0x000001f8, /* 01B4(:0):    NOP */
+};
+u32 MCD_SingleEu_TDT[] = {
+	0x8218001b,
+	0x7000000d,
+	0x080cf81f,
+	0x8218801b,
+	0x6000000e,
+	0x084cf85f,
+	0x000001f8, /* 0018(:0):    NOP */
+	0x8318001b,
+	0x7000000d,
+	0x014cf81f,
+	0x6000000e,
+	0x01ccf81f,
+	0x8498001b,
+	0x7000000f,
+	0x080cf19f,
+	0xd81882a4,
+	0x8019001b,
+	0x60000003,
+	0x2c97c7df,
+	0xd818826d,
+	0x8019001b,
+	0x60000003,
+	0x2c17c7df,
+	0x000001f8, /* 005C(:0):    NOP */
+	0xc282e01b,
+	0xc002a25e,
+	0x811a601b,
+	0xc184a102,
+	0x841be009,
+	0x63fe0000,
+	0x0d4cfddf,
+	0xda9b001b,
+	0x9b9be01b,
+	0x70000002,
+	0x004cf99f,
+	0x70000006,
+	0x088cf88b,
+	0x1000cb28,
+	0x70000006,
+	0x088cf88b,
+	0x1000cb30,
+	0x70000006,
+	0x088cf88b,
+	0x0000cb38,
+	0x000001f8, /* 00B0(:0):    NOP */
+	0xc282e01b,
+	0xc002a31e,
+	0x811a601b,
+	0xda9b001b,
+	0x9b9be01b,
+	0x0000d3a0,
+	0xc184a102,
+	0x841be009,
+	0x6bfe0000,
+	0x0d4cfddf,
+	0xda9b001b,
+	0x9b9be01b,
+	0x70000002,
+	0x004cf99f,
+	0x70000006,
+	0x088cf88b,
+	0x1000cb28,
+	0x70000006,
+	0x088cf88b,
+	0x1000cb30,
+	0x70000006,
+	0x088cf88b,
+	0x0000cb38,
+	0x000001f8, /* 0110(:0):    NOP */
+	0x8144801c,
+	0x0000c008,
+	0xc398027f,
+	0x8018801b,
+	0x040001f8,
+};
+#endif
+u32 MCD_ENetRcv_TDT[] = {
+	0x80004000,
+	0x81988000,
+	0x10000788,
+	0x6000000a,
+	0x080cf05f,
+	0x98180209,
+	0x81c40004,
+	0x7000000e,
+	0x010cf05f,
+	0x7000000c,
+	0x01ccf05f,
+	0x70000004,
+	0x014cf049,
+	0x70000004,
+	0x004cf04a,
+	0x00000b88,
+	0xc4030150,
+	0x8119e012,
+	0x03e0cf90,
+	0x81188000,
+	0x000ac788,
+	0xc4030000,
+	0x8199e000,
+	0x63e00004,
+	0x084cfc8b,
+	0xd8990000,
+	0x9999e000,
+	0x60000005,
+	0x0cccf841,
+	0x81c60000,
+	0xc399021b,
+	0x80198000,
+	0x00008400,
+	0x00000f08,
+	0x81988000,
+	0x10000788,
+	0x6000000a,
+	0x080cf05f,
+	0xc2188209,
+	0x80190000,
+	0x040001f8,
+	0x000001f8,
+};
+u32 MCD_ENetXmit_TDT[] = {
+	0x80004000,
+	0x81988000,
+	0x10000788,
+	0x6000000a,
+	0x080cf05f,
+	0x98180309,
+	0x80004003,
+	0x81c60004,
+	0x7000000e,
+	0x014cf05f,
+	0x7000000c,
+	0x028cf05f,
+	0x7000000d,
+	0x018cf05f,
+	0x70000004,
+	0x01ccf04d,
+	0x10000b90,
+	0x60000004,
+	0x020cf0a1,
+	0xc3188312,
+	0x83c70000,
+	0x00001f10,
+	0xc583a3c3,
+	0x81042325,
+	0x03e0c798,
+	0xd8990000,
+	0x9999e000,
+	0x000acf98,
+	0xd8992306,
+	0x9999e03f,
+	0x03eac798,
+	0xd8990000,
+	0x9999e000,
+	0x000acf98,
+	0xd8990000,
+	0x99832302,
+	0x0beac798,
+	0x81988000,
+	0x6000000b,
+	0x0c4cfc5f,
+	0x81c80000,
+	0xc5190312,
+	0x80198000,
+	0x00008400,
+	0x00000f08,
+	0x81988000,
+	0x10000788,
+	0x6000000a,
+	0x080cf05f,
+	0xc2988309,
+	0x80190000,
+	0x040001f8,
+	0x000001f8,
+};
+
+#ifdef MCD_INCLUDE_EU
+MCD_bufDesc MCD_singleBufDescs[NCHANNELS];
+#endif
--- /dev/null
+++ b/drivers/dma/MCD_tasksInit.c
@@ -0,0 +1,271 @@
+/*
+ * drivers/dma/MCD_tasksInit.c
+ *
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Kurt Mahan <kmahan@freescale.com>
+ * Shrek Wu b16972@freescale.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Autogenerated - Do not edit!
+ */
+
+#include "MCD_dma.h"
+
+extern dmaRegs *MCD_dmaBar;
+
+
+/*
+ * Task 0
+ */
+
+void  MCD_startDmaChainNoEu(int *currBD, short srcIncr,
+	short destIncr, int xferSize, short xferSizeIncr,
+	int *cSave, volatile TaskTableEntry *taskTable,
+	int channel)
+{
+	MCD_SET_VAR(taskTable+channel, 2, (u32)currBD); /* var[2] */
+	MCD_SET_VAR(taskTable+channel, 25,
+		(u32)(0xe000 << 16) | (0xffff & srcIncr));
+
+	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 24,
+		(u32)(0xe000 << 16) | (0xffff & destIncr));
+	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)xferSize);  /* var[11] */
+	MCD_SET_VAR(taskTable+channel, 26,
+		(u32)(0x2000 << 16) | (0xffff & xferSizeIncr));
+	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);  /* var[0] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000); /* var[3] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000); /* var[6] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000); /* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);    /* var[10] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);    /* var[12] */
+	MCD_SET_VAR(taskTable+channel, 13, (u32)0x80000000);    /* var[13] */
+	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000010);    /* var[14] */
+	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000004);    /* var[15] */
+	MCD_SET_VAR(taskTable+channel, 16, (u32)0x08000000);    /* var[16] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);    /* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000000);    /* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000001);    /* inc[5] */
+	MCD_SET_VAR(taskTable+channel, 30, (u32)0x40000000);    /* inc[6] */
+
+	/* Set the task's Enable bit in its Task Control Register */
+	MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
+}
+
+
+/*
+ * Task 1
+ */
+
+void  MCD_startDmaSingleNoEu(char *srcAddr, short srcIncr,
+	char *destAddr, short destIncr, int dmaSize,
+	short xferSizeIncr, int flags, int *currBD, int *cSave,
+	volatile TaskTableEntry *taskTable, int channel)
+{
+	MCD_SET_VAR(taskTable+channel, 7, (u32)srcAddr);    /* var[7] */
+	MCD_SET_VAR(taskTable+channel, 25,
+		(u32)(0xe000 << 16) | (0xffff & srcIncr));
+	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)destAddr);   /* var[2] */
+	MCD_SET_VAR(taskTable+channel, 24,
+		(u32)(0xe000 << 16) | (0xffff & destIncr));
+	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)dmaSize);    /* var[3] */
+	MCD_SET_VAR(taskTable+channel, 26,
+		(u32)(0x2000 << 16) | (0xffff & xferSizeIncr));
+	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)flags);  /* var[5] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)currBD); /* var[1] */
+	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);  /* var[0] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000); /* var[6] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000004); /* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x08000000);    /* var[10] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);    /* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000001);    /* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x40000000);    /* inc[5] */
+
+	/* Set the task's Enable bit in its Task Control Register */
+	MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
+}
+
+
+/*
+ * Task 2
+ */
+
+void  MCD_startDmaChainEu(int *currBD, short srcIncr, short destIncr,
+	int xferSize, short xferSizeIncr, int *cSave,
+	volatile TaskTableEntry *taskTable, int channel)
+{
+
+	MCD_SET_VAR(taskTable+channel, 3, (u32)currBD); /* var[3] */
+	MCD_SET_VAR(taskTable+channel, 25,
+		(u32)(0xe000 << 16) | (0xffff & srcIncr));
+	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 24,
+		(u32)(0xe000 << 16) | (0xffff & destIncr));
+	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)xferSize);
+	/* var[12] */
+	MCD_SET_VAR(taskTable+channel, 26,
+		(u32)(0x2000 << 16) | (0xffff & xferSizeIncr));
+	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);  /* var[0] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000); /* var[2] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000); /* var[6] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000); /* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);    /* var[10] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);    /* var[11] */
+	MCD_SET_VAR(taskTable+channel, 13, (u32)0x00000000);    /* var[13] */
+	MCD_SET_VAR(taskTable+channel, 14, (u32)0x80000000);    /* var[14] */
+	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000010);    /* var[15] */
+	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000001);    /* var[16] */
+	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000004);    /* var[17] */
+	MCD_SET_VAR(taskTable+channel, 18, (u32)0x08000000);    /* var[18] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);    /* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000000);    /* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0xc0000000);    /* inc[5] */
+	MCD_SET_VAR(taskTable+channel, 30, (u32)0x80000001);    /* inc[6] */
+	MCD_SET_VAR(taskTable+channel, 31, (u32)0x40000000);    /* inc[7] */
+
+	/* Set the task's Enable bit in its Task Control Register */
+	MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
+}
+
+
+/*
+ * Task 3
+ */
+
+void  MCD_startDmaSingleEu(char *srcAddr, short srcIncr,
+	char *destAddr, short destIncr, int dmaSize,
+	short xferSizeIncr, int flags, int *currBD, int *cSave,
+	volatile TaskTableEntry *taskTable, int channel)
+{
+	MCD_SET_VAR(taskTable+channel, 8, (u32)srcAddr);    /* var[8] */
+	MCD_SET_VAR(taskTable+channel, 25,
+		(u32)(0xe000 << 16) | (0xffff & srcIncr));   /* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)destAddr);   /* var[3] */
+	MCD_SET_VAR(taskTable+channel, 24,
+		(u32)(0xe000 << 16) | (0xffff & destIncr));  /* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)dmaSize);    /* var[4] */
+	MCD_SET_VAR(taskTable+channel, 26,
+		(u32)(0x2000 << 16) | (0xffff & xferSizeIncr)); /* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)flags);  /* var[6] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)currBD); /* var[2] */
+	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);  /* var[0] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000); /* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000001);    /* var[10] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000004);    /* var[11] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x08000000);    /* var[12] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);    /* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0xc0000000);    /* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000000);    /* inc[5] */
+	MCD_SET_VAR(taskTable+channel, 30, (u32)0x80000001);    /* inc[6] */
+	MCD_SET_VAR(taskTable+channel, 31, (u32)0x40000000);    /* inc[7] */
+
+	/* Set the task's Enable bit in its Task Control Register */
+	MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
+}
+
+
+/*
+ * Task 4
+ */
+
+void  MCD_startDmaENetRcv(char *bDBase, char *currBD, char *rcvFifoPtr,
+	volatile TaskTableEntry *taskTable, int channel)
+{
+	MCD_SET_VAR(taskTable+channel, 0, (u32)bDBase); /* var[0] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)currBD); /* var[3] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)rcvFifoPtr); /* var[6] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000); /* var[2] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x0000ffff); /* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x30000000);    /* var[10] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)0x0fffffff);    /* var[11] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000008);    /* var[12] */
+	MCD_SET_VAR(taskTable+channel, 24, (u32)0x00000000);    /* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 25, (u32)0x60000000);    /* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 26, (u32)0x20000004);    /* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x40000000);    /* inc[3] */
+
+	/* Set the task's Enable bit in its Task Control Register */
+	MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
+}
+
+
+/*
+ * Task 5
+ */
+
+void  MCD_startDmaENetXmit(char *bDBase, char *currBD,
+	char *xmitFifoPtr, volatile TaskTableEntry *taskTable,
+	int channel)
+{
+	MCD_SET_VAR(taskTable+channel, 0, (u32)bDBase); /* var[0] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)currBD); /* var[3] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)xmitFifoPtr); /* var[11] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000); /* var[2] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000); /* var[6] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000); /* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);    /* var[10] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);    /* var[12] */
+	MCD_SET_VAR(taskTable+channel, 13, (u32)0x0000ffff);    /* var[13] */
+	MCD_SET_VAR(taskTable+channel, 14, (u32)0xffffffff);    /* var[14] */
+	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000004);    /* var[15] */
+	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000008);    /* var[16] */
+	MCD_SET_VAR(taskTable+channel, 24, (u32)0x00000000);    /* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 25, (u32)0x60000000);    /* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 26, (u32)0x40000000);    /* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0xc000fffc);    /* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0xe0000004);    /* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000000);    /* inc[5] */
+	MCD_SET_VAR(taskTable+channel, 30, (u32)0x4000ffff);    /* inc[6] */
+	MCD_SET_VAR(taskTable+channel, 31, (u32)0xe0000001);    /* inc[7] */
+
+	/* Set the task's Enable bit in its Task Control Register */
+	MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
+}
--- /dev/null
+++ b/drivers/dma/MCD_tasksInit.h
@@ -0,0 +1,84 @@
+/*
+ * drivers/dma/MCD_tasksInit.h
+ *
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Kurt Mahan <kmahan@freescale.com>
+ * Shrek Wu b16972@freescale.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef MCD_TSK_INIT_H
+#define MCD_TSK_INIT_H 1
+
+/*
+ * Autogenerated - Do not edit!
+ */
+
+/*
+ * Task 0
+ */
+void  MCD_startDmaChainNoEu(int *currBD, short srcIncr,
+		short destIncr, int xferSize,
+		short xferSizeIncr, int *cSave,
+		volatile TaskTableEntry *taskTable,
+		int channel);
+
+
+/*
+ * Task 1
+ */
+void  MCD_startDmaSingleNoEu(char *srcAddr, short srcIncr,
+		char *destAddr, short destIncr, int dmaSize,
+		short xferSizeIncr, int flags, int *currBD,
+		int *cSave, volatile TaskTableEntry *taskTable,
+		int channel);
+
+
+/*
+ * Task 2
+ */
+void  MCD_startDmaChainEu(int *currBD, short srcIncr, short destIncr,
+		int xferSize, short xferSizeIncr, int *cSave,
+		volatile TaskTableEntry *taskTable,
+		int channel);
+
+
+/*
+ * Task 3
+ */
+void  MCD_startDmaSingleEu(char *srcAddr, short srcIncr,
+		char *destAddr, short destIncr, int dmaSize,
+		short xferSizeIncr, int flags, int *currBD,
+		int *cSave, volatile TaskTableEntry *taskTable,
+		int channel);
+
+
+/*
+ * Task 4
+ */
+void  MCD_startDmaENetRcv(char *bDBase, char *currBD,
+		char *rcvFifoPtr,
+		volatile TaskTableEntry *taskTable, int channel);
+
+
+/*
+ * Task 5
+ */
+void  MCD_startDmaENetXmit(char *bDBase, char *currBD,
+		char *xmitFifoPtr,
+		volatile TaskTableEntry *taskTable, int channel);
+
+#endif  /* MCD_TSK_INIT_H */
