From: Michael Handler <handler@sub-rosa.com>
To: dns@list.cr.yp.to
Subject: tinydns-data SRV & axfr-get SRV/PTR patches
Date: Thu, 14 Sep 2000 20:37:50 -0400

Here's a combined patch that:

a) adds a native SRV type to tinydns-data

Sfqdn:ip:x:port:weight:priority:ttl:timestamp

Standard rules for ip, x, ttl, and timestamp apply. Port, weight, and
priority all range from 0-65535. Weight and priority are optional; they
default to zero if not provided.

Sconsole.zoinks.example.com:1.2.3.4:rack102-con1:2001:69:7:300:

b) makes axfr-get decompose SRV and PTR records and write them out in
native format, rather than opaque. Again, this is necessary because if the
DNAME fields in the records reference the same zone as fqdn, they can have
compression pointers that are bogus outside the context of that specific
packet, and which can't be correctly loaded into data.cdb by tinydns-data.

--michael

Laurent G. Bercot <ska-djbdns@skarnet.org> updated it for djbdns-1.05:

--- a/axfr-get.c
+++ b/axfr-get.c
@@ -209,6 +209,26 @@ unsigned int doit(char *buf,unsigned int
     if (!stralloc_cats(&line,".:")) return 0;
     if (!stralloc_catulong0(&line,dist,0)) return 0;
   }
+  else if (byte_equal(data,2,DNS_T_SRV)) {
+    uint16 dist, weight, port;
+    if (!stralloc_copys(&line,"S")) return 0;
+    if (!dns_domain_todot_cat(&line,d1)) return 0;
+    if (!stralloc_cats(&line,"::")) return 0;
+    pos = x_copy(buf,len,pos,data,2);
+    uint16_unpack_big(data,&dist);
+    pos = x_copy(buf,len,pos,data,2);
+    uint16_unpack_big(data,&weight);
+    pos = x_copy(buf,len,pos,data,2);
+    uint16_unpack_big(data,&port);
+    x_getname(buf,len,pos,&d1);
+    if (!dns_domain_todot_cat(&line,d1)) return 0;
+    if (!stralloc_cats(&line,".:")) return 0;
+    if (!stralloc_catulong0(&line,dist,0)) return 0;
+    if (!stralloc_cats(&line,":")) return 0;
+    if (!stralloc_catulong0(&line,weight,0)) return 0;
+    if (!stralloc_cats(&line,":")) return 0;
+    if (!stralloc_catulong0(&line,port,0)) return 0;
+  }
   else if (byte_equal(data,2,DNS_T_A) && (dlen == 4)) {
     char ipstr[IP4_FMT];
     if (!stralloc_copys(&line,"+")) return 0;
@@ -217,6 +237,14 @@ unsigned int doit(char *buf,unsigned int
     x_copy(buf,len,pos,data,4);
     if (!stralloc_catb(&line,ipstr,ip4_fmt(ipstr,data))) return 0;
   }
+  else if (byte_equal(data,2,DNS_T_PTR)) {
+    if (!stralloc_copys(&line,"^")) return 0;
+    if (!dns_domain_todot_cat(&line,d1)) return 0;
+    if (!stralloc_cats(&line,":")) return 0;
+    x_getname(buf,len,pos,&d1);
+    if (!dns_domain_todot_cat(&line,d1)) return 0;
+    if (!stralloc_cats(&line,".")) return 0;
+  }
   else {
     unsigned char ch;
     unsigned char ch2;
--- a/dns.h
+++ b/dns.h
@@ -20,6 +20,7 @@
 #define DNS_T_SIG "\0\30"
 #define DNS_T_KEY "\0\31"
 #define DNS_T_AAAA "\0\34"
+#define DNS_T_SRV "\0\41"
 #define DNS_T_AXFR "\0\374"
 #define DNS_T_ANY "\0\377"
 
--- a/tinydns-data.c
+++ b/tinydns-data.c
@@ -196,6 +196,7 @@ int main()
   char type[2];
   char soa[20];
   char buf[4];
+  char srv[6];
 
   umask(022);
 
@@ -369,6 +370,43 @@ int main()
 	  rr_finish(d2);
 	}
 	break;
+	
+      case 'S':
+	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
+	if (!stralloc_0(&f[6])) nomem();
+	if (!scan_ulong(f[6].s,&ttl)) ttl = TTL_POSITIVE;
+	ttdparse(&f[7],ttd);
+	locparse(&f[8],loc);
+
+	if (!stralloc_0(&f[1])) nomem();
+
+	if (byte_chr(f[2].s,f[2].len,'.') >= f[2].len) {
+	  if (!stralloc_cats(&f[2],".srv.")) nomem();
+	  if (!stralloc_catb(&f[2],f[0].s,f[0].len)) nomem();
+	}
+	if (!dns_domain_fromdot(&d2,f[2].s,f[2].len)) nomem();
+
+	if (!stralloc_0(&f[4])) nomem();
+	if (!scan_ulong(f[4].s,&u)) u = 0;
+	uint16_pack_big(srv,u);
+	if (!stralloc_0(&f[5])) nomem();
+	if (!scan_ulong(f[5].s,&u)) u = 0;
+	uint16_pack_big(srv + 2,u);
+	if (!stralloc_0(&f[3])) nomem();
+	if (!scan_ulong(f[3].s,&u)) nomem();
+	uint16_pack_big(srv + 4,u);
+
+	rr_start(DNS_T_SRV,ttl,ttd,loc);
+	rr_add(srv,6);
+	rr_addname(d2);
+	rr_finish(d1);
+
+	if (ip4_scan(f[1].s,ip)) {
+	  rr_start(DNS_T_A,ttl,ttd,loc);
+	  rr_add(ip,4);
+	  rr_finish(d2);
+	}
+	break;
 
       case '^': case 'C':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
