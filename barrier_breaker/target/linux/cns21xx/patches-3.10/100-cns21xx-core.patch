--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -206,6 +206,11 @@ config NEED_RET_TO_USER
 config ARCH_MTD_XIP
 	bool
 
+config ARM_L1_CACHE_SHIFT_4
+	bool
+	help
+	  Setting ARM L1 cache line size to 16 bytes.
+
 config VECTORS_BASE
 	hex
 	default 0xffff0000 if MMU || CPU_HIGH_VECTOR
@@ -361,6 +366,15 @@ config ARCH_AT91
 	  This enables support for systems based on Atmel
 	  AT91RM9200 and AT91SAM9* processors.
 
+config ARCH_CNS21XX
+	bool "Cavium Networks CNS21xx family"
+	select CPU_FA526
+	select PLAT_FA
+	select PLAT_FA_TIME
+	select ARM_L1_CACHE_SHIFT_4
+	help
+	  Support for Cavium Networks CNS21xx family.
+
 config ARCH_CLPS711X
 	bool "Cirrus Logic CLPS711x/EP721x/EP731x-based"
 	select ARCH_REQUIRE_GPIOLIB
@@ -930,6 +944,8 @@ source "arch/arm/mach-davinci/Kconfig"
 
 source "arch/arm/mach-dove/Kconfig"
 
+source "arch/arm/mach-cns21xx/Kconfig"
+
 source "arch/arm/mach-ep93xx/Kconfig"
 
 source "arch/arm/mach-footbridge/Kconfig"
--- /dev/null
+++ b/arch/arm/mach-cns21xx/Kconfig
@@ -0,0 +1,6 @@
+if ARCH_CNS21XX
+
+menu "Cavium Networks CNS21xx based machines"
+endmenu
+
+endif
--- /dev/null
+++ b/arch/arm/mach-cns21xx/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		:= core.o irq.o mm.o time.o idle.o
+
+# machine specific files
+
--- /dev/null
+++ b/arch/arm/mach-cns21xx/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	+= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00C00000
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -146,6 +146,7 @@ machine-$(CONFIG_ARCH_AT91)		+= at91
 machine-$(CONFIG_ARCH_BCM)		+= bcm
 machine-$(CONFIG_ARCH_BCM2835)		+= bcm2835
 machine-$(CONFIG_ARCH_CLPS711X)		+= clps711x
+machine-$(CONFIG_ARCH_CNS21XX)		+= cns21xx
 machine-$(CONFIG_ARCH_CNS3XXX)		+= cns3xxx
 machine-$(CONFIG_ARCH_DAVINCI)		+= davinci
 machine-$(CONFIG_ARCH_DOVE)		+= dove
--- /dev/null
+++ b/arch/arm/mach-cns21xx/common.h
@@ -0,0 +1,20 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _MACH_CNS21XX_COMMON_H
+#define _MACH_CNS21XX_COMMON_H
+
+void cns21xx_restart(char mode, const char *cmd);
+void cns21xx_map_io(void);
+void cns21xx_init_irq(void);
+void cns21xx_timer_init(void);
+
+extern struct sys_timer cns21xx_timer;
+
+#endif /* _MACH_CNS21XX_COMMON_H */
--- /dev/null
+++ b/arch/arm/mach-cns21xx/mm.c
@@ -0,0 +1,170 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/mach/map.h>
+
+#include <mach/hardware.h>
+#include <mach/cns21xx.h>
+
+#include "common.h"
+
+/*
+ * Standard IO mapping
+ */
+static struct map_desc cns21xx_io_desc[] __initdata = {
+	{
+		.virtual	= CNS21XX_FLASH_BANK0_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_FLASH_BANK0_BASE),
+		.length		= SZ_256M,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_IDE_DEVICE_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_IDE_DEVICE_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_GDMAC_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_GDMAC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_NIC_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_NIC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_SPI_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_SPI_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_PCM_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_PCM_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_I2C_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_I2C_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_I2S_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_I2S_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_DDRC_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_DDRC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_SMC_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_SMC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_IDE_CTRL_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_IDE_CTRL_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_MISC_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_MISC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_CPM_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_CPM_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_UART0_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_UART0_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_UART1_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_UART1_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_TIMER_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_TIMER_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_WDT_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_WDT_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_RTC_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_RTC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_GPIOA_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_GPIOA_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_GPIOB_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_GPIOB_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_PCI_CFGDATA_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_PCI_CFGDATA_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_PCI_CFGADDR_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_PCI_CFGADDR_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_OHCI_CONFIG_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_OHCI_CONFIG_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_OHCI_CTRL_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_OHCI_CTRL_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_EHCI_CONFIG_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_EHCI_CONFIG_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_EHCI_CTRL_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_EHCI_CTRL_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_USB_DEVICE_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_USB_DEVICE_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= CNS21XX_INTC_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS21XX_INTC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}
+};
+
+void __init cns21xx_map_io(void)
+{
+	iotable_init(cns21xx_io_desc, ARRAY_SIZE(cns21xx_io_desc));
+}
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/hardware.h
@@ -0,0 +1,20 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _CNS21XX_HARDWARE_H
+#define _CNS21XX_HARDWARE_H
+
+#ifndef __ASSEMBLY__
+extern unsigned long cns21xx_get_pll_freq(void);
+extern unsigned long cns21xx_get_cpu_freq(void);
+extern unsigned long cns21xx_get_ahb_freq(void);
+extern unsigned long cns21xx_get_apb_freq(void);
+#endif
+
+#endif /* _CNS21XX_HARDWARE_H */
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/debug-macro.S
@@ -0,0 +1,25 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#include <mach/cns21xx.h>
+
+/* TODO: make it configurable */
+#define CNS21XX_DEBUG_UART_BASE		CNS21XX_UART0_BASE
+#define CNS21XX_DEBUG_UART_BASE_VIRT	CNS21XX_UART0_BASE_VIRT
+
+	.macro	addruart, rp, rv
+	mov	\rp, #(CNS21XX_DEBUG_UART_BASE)				@ physical
+	mov	\rv, #(CNS21XX_DEBUG_UART_BASE_VIRT & 0xff000000)	@virtual
+	orr	\rv, \rv, #(CNS21XX_DEBUG_UART_BASE_VIRT & 0x00ff0000)
+	orr	\rv, \rv, #(CNS21XX_DEBUG_UART_BASE_VIRT & 0x0000ff00)
+	orr	\rv, \rv, #(CNS21XX_DEBUG_UART_BASE_VIRT & 0x000000ff)
+	.endm
+
+#define UART_SHIFT 2
+#include <asm/hardware/debug-8250.S>
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/entry-macro.S
@@ -0,0 +1,39 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#include <mach/cns21xx.h>
+#include <mach/irqs.h>
+
+#define INTC_IRQ_STATUS	0x1c
+
+	.macro	disable_fiq
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr		\base, =(CNS21XX_INTC_BASE_VIRT + INTC_IRQ_STATUS)
+	ldr		\irqstat, [\base]
+	mov		\irqnr, #0
+9001:
+	tst		\irqstat, #1
+	bne		9002f
+	add		\irqnr, \irqnr, #1
+	mov		\irqstat, \irqstat, lsr #1
+	cmp		\irqnr, #CNS21XX_NR_INTC_IRQS
+	bcc		9001b
+9002:
+	.endm
+
+	.macro irq_prio_table
+	.endm
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/io.h
@@ -0,0 +1,18 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _CNS21XX_IO_H
+#define _CNS21XX_IO_H
+
+#define IO_SPACE_LIMIT	0xffffffff
+
+#define __io(p)		__typesafe_io(p)
+#define __mem_pci(a)	(a)
+
+#endif /* _CNS21XX_IO_H */
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/irqs.h
@@ -0,0 +1,53 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _CNS21XX_IRQS_H
+#define _CNS21XX_IRQS_H
+
+#define CNS21XX_IRQ_TIMER1	0
+#define CNS21XX_IRQ_TIMER2	1
+#define CNS21XX_IRQ_CPM		2
+#define CNS21XX_IRQ_WDT		3
+#define CNS21XX_IRQ_GPIO	4
+#define CNS21XX_IRQ_PCI_INTA	5
+#define CNS21XX_IRQ_PCI_INTB	6
+#define CNS21XX_IRQ_PCI_BROKEN	7
+#define CNS21XX_IRQ_AHB2PCI	8
+#define CNS21XX_IRQ_UART0	9
+#define CNS21XX_IRQ_UART1	10
+#define CNS21XX_IRQ_GDMAC_TC	11
+#define CNS21XX_IRQ_GDMAC_ERR	12
+#define CNS21XX_IRQ_PCMCIA	13
+#define CNS21XX_IRQ_RTC		14
+#define CNS21XX_IRQ_PCM		15
+#define CNS21XX_IRQ_USB_DEVICE	16
+#define CNS21XX_IRQ_IDE		17
+#define CNS21XX_IRQ_NIC_STATUS	18
+#define CNS21XX_IRQ_NIC_TXTC	19
+#define CNS21XX_IRQ_NIC_RXRC	20
+#define CNS21XX_IRQ_NIC_TXQE	21
+#define CNS21XX_IRQ_NIC_RXQF	22
+#define CNS21XX_IRQ_OHCI	23
+#define CNS21XX_IRQ_EHCI	24
+#define CNS21XX_IRQ_I2S		25
+#define CNS21XX_IRQ_SPI		26
+#define CNS21XX_IRQ_I2C		27
+#define CNS21XX_IRQ_USB_VBUS	28
+#define CNS21XX_IRQ_EXT_29	29
+#define CNS21XX_IRQ_EXT_30	30
+#define CNS21XX_IRQ_HSDMAC	31
+
+#define CNS21XX_GPIO_IRQ_BASE	32
+
+#define CNS21XX_NR_INTC_IRQS	32
+#define CNS21XX_NR_GPIO_IRQS	64
+
+#define NR_IRQS			96
+
+#endif /* _CNS21XX_IRQS_H */
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/timex.h
@@ -0,0 +1,15 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _CNS21XX_TIMEX_H
+#define _CNS21XX_TIMEX_H
+
+#define CLOCK_TICK_RATE		43750000
+
+#endif /* _CNS21XX_TIMEX_H */
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/uncompress.h
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _CNS21XX_UNCOMPRESS_H
+#define _CNS21XX_UNCOMPRESS_H
+
+#define UART_BASE	0x78000000
+
+#define UART_REG(offs)	(*((volatile unsigned int *)(UART_BASE + offs)))
+
+#define UART_THR	UART_REG(0x00)
+#define UART_LSR	UART_REG(0x14)
+#define THR_EMPTY	(1 << 5)
+
+#define UART_THR_EMPTY()     (((UART_LSR) & THR_EMPTY) == (THR_EMPTY))
+
+static void putc(int c)
+{
+	if (c != 0) {
+		while (!UART_THR_EMPTY())
+			barrier();
+
+		UART_THR = (int)(c & 0xFF);
+	}
+}
+
+static inline void flush(void)
+{
+}
+
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif /* _CNS21XX_UNCOMPRESS_H */
--- /dev/null
+++ b/arch/arm/mach-cns21xx/irq.c
@@ -0,0 +1,177 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/cpu.h>
+
+#include <asm/system_misc.h>
+
+#include <mach/cns21xx.h>
+
+#define	INTC_INTERRUPT_RAW_STATUS_REG		0x000
+#define	INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG	0x004
+#define	INTC_INTERRUPT_MASK_REG			0x008
+#define	INTC_INTERRUPT_MASK_CLEAR_REG		0x00c
+#define	INTC_INTERRUPT_TRIGGER_MODE_REG		0x010
+#define	INTC_INTERRUPT_TRIGGER_LEVEL_REG	0x014
+#define	INTC_FIQ_SELECT_REG			0x018
+#define	INTC_IRQ_STATUS_REG			0x01c
+#define	INTC_FIQ_STATUS_REG			0x020
+#define	INTC_SOFTWARE_INTERRUPT_REG		0x024
+#define	INTC_SOFTWARE_INTERRUPT_CLEAR_REG	0x028
+#define	INTC_SOFTWARE_PRIORITY_MASK_REG		0x02c
+#define	INTC_POWER_MANAGEMENT_INTERRUPT_REG	0x034
+
+#define	INTC_VECTOR_ADDRESS_REG(_x)		((_x) + 0x040)
+#define	INTC_PRIORITY_REG(_x)			((_x) + 0x0c0)
+#define	INTC_IRQ_VECTOR_ADDRESS_REG		0x140
+#define	INTC_VECTOR_INTERRUPT_ENABLE_REG	0x144
+
+#define INTC_SIZE				0x148
+
+static unsigned int cns21xx_irq_types[CNS21XX_NR_INTC_IRQS] = {
+	[CNS21XX_IRQ_TIMER1]	= IRQ_TYPE_EDGE_RISING,
+	[CNS21XX_IRQ_TIMER2]	= IRQ_TYPE_EDGE_RISING,
+	[CNS21XX_IRQ_CPM]	= IRQ_TYPE_EDGE_FALLING,
+	[CNS21XX_IRQ_WDT]	= IRQ_TYPE_EDGE_RISING,
+	[CNS21XX_IRQ_GPIO]	= IRQ_TYPE_NONE,
+	[CNS21XX_IRQ_PCI_INTA]	= IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_PCI_INTB]	= IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_PCI_BROKEN] = IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_AHB2PCI]	= IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_UART0]	= IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_UART1]	= IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_GDMAC_TC]	= IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_GDMAC_ERR]	= IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_PCMCIA]	= IRQ_TYPE_NONE,
+	[CNS21XX_IRQ_RTC]	= IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_PCM]	= IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_USB_DEVICE] = IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_IDE]	= IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_NIC_STATUS] = IRQ_TYPE_LEVEL_HIGH,
+	[CNS21XX_IRQ_NIC_TXTC]	= IRQ_TYPE_EDGE_RISING,
+	[CNS21XX_IRQ_NIC_RXRC]	= IRQ_TYPE_EDGE_RISING,
+	[CNS21XX_IRQ_NIC_TXQE]	= IRQ_TYPE_EDGE_RISING,
+	[CNS21XX_IRQ_NIC_RXQF]	= IRQ_TYPE_EDGE_RISING,
+	[CNS21XX_IRQ_OHCI]	= IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_EHCI]	= IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_I2S]	= IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_SPI]	= IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_I2C]	= IRQ_TYPE_LEVEL_LOW,
+	[CNS21XX_IRQ_USB_VBUS]	= IRQ_TYPE_EDGE_RISING,
+	[CNS21XX_IRQ_EXT_29]	= IRQ_TYPE_NONE,
+	[CNS21XX_IRQ_EXT_30]	= IRQ_TYPE_NONE,
+	[CNS21XX_IRQ_HSDMAC]	= IRQ_TYPE_EDGE_RISING,
+};
+
+static void __iomem *cns21xx_intc_base;
+
+static inline void cns21xx_intc_writel(u32 val, unsigned int reg)
+{
+	__raw_writel(val, cns21xx_intc_base + reg);
+}
+
+static inline u32 cns21xx_intc_readl(unsigned int reg)
+{
+	return __raw_readl(cns21xx_intc_base + reg);
+}
+
+static void cns21xx_irq_ack(struct irq_data *d)
+{
+	cns21xx_intc_writel(1 << d->irq, INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG);
+}
+
+static void cns21xx_irq_mask(struct irq_data *d)
+{
+	cns21xx_intc_writel(1 << d->irq, INTC_INTERRUPT_MASK_REG);
+}
+
+static void cns21xx_irq_unmask(struct irq_data *d)
+{
+	cns21xx_intc_writel(1 << d->irq, INTC_INTERRUPT_MASK_CLEAR_REG);
+}
+
+static struct irq_chip cns21xx_irq_chip = {
+	.name	= "INTC",
+	.irq_ack = cns21xx_irq_ack,
+	.irq_mask = cns21xx_irq_mask,
+	.irq_unmask = cns21xx_irq_unmask,
+};
+
+static struct resource cns21xx_intc_resource = {
+	.name	= "INTC",
+	.flags	= IORESOURCE_MEM,
+	.start	= CNS21XX_INTC_BASE,
+	.end	= CNS21XX_INTC_BASE + INTC_SIZE - 1,
+};
+
+void __init cns21xx_init_irq(void)
+{
+	unsigned int mode = 0;
+	unsigned int level = 0;
+	int i;
+
+	/*
+	 * Disable the idle handler by default since it is buggy
+	 * For more info see arch/arm/mach-gemini/idle.c
+	 */
+	cpu_idle_poll_ctrl(true);
+
+	request_resource(&iomem_resource, &cns21xx_intc_resource);
+	cns21xx_intc_base = ioremap(cns21xx_intc_resource.start, INTC_SIZE);
+
+	cns21xx_intc_writel(0xffffffff, INTC_INTERRUPT_MASK_REG);
+	cns21xx_intc_writel(0xffffffff, INTC_EDGE_INTERRUPT_SOURCE_CLEAR_REG);
+	cns21xx_intc_writel(0xffffffff, INTC_SOFTWARE_INTERRUPT_CLEAR_REG);
+	cns21xx_intc_writel(0, INTC_SOFTWARE_PRIORITY_MASK_REG);
+	cns21xx_intc_writel(0, INTC_FIQ_SELECT_REG);
+	cns21xx_intc_writel(0, INTC_VECTOR_INTERRUPT_ENABLE_REG);
+
+	for (i = 0; i < ARRAY_SIZE(cns21xx_irq_types);  i++) {
+		irq_flow_handler_t handler;
+
+		switch (cns21xx_irq_types[i]) {
+		case IRQ_TYPE_EDGE_RISING:
+			handler = handle_edge_irq;
+			mode |= (1 << i);
+			break;
+
+		case IRQ_TYPE_EDGE_FALLING:
+			handler = handle_edge_irq;
+			mode |= (1 << i);
+			level |= (1 << i);
+			break;
+
+		case IRQ_TYPE_LEVEL_LOW:
+			handler = handle_level_irq;
+			level |= (1 << i);
+			break;
+
+		case IRQ_TYPE_LEVEL_HIGH:
+		case IRQ_TYPE_NONE:
+			handler = handle_level_irq;
+			break;
+
+		default:
+			BUG();
+			break;
+		}
+
+		irq_set_chip(i, &cns21xx_irq_chip);
+		irq_set_handler(i, handler);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+
+	cns21xx_intc_writel(mode, INTC_INTERRUPT_TRIGGER_MODE_REG);
+	cns21xx_intc_writel(level, INTC_INTERRUPT_TRIGGER_LEVEL_REG);
+}
--- /dev/null
+++ b/arch/arm/mach-cns21xx/time.c
@@ -0,0 +1,25 @@
+/*
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/mach/time.h>
+
+#include <plat/time.h>
+#include <mach/hardware.h>
+#include <mach/cns21xx.h>
+
+#include "common.h"
+
+void __init cns21xx_timer_init(void)
+{
+	fa_timer_init(CNS21XX_TIMER_BASE, CNS21XX_IRQ_TIMER1, FA_TIMER1,
+		      cns21xx_get_apb_freq());
+}
+
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/cns21xx_powermgmt.h
@@ -0,0 +1,591 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _CNS21XX_POWERMGMT_H
+#define _CNS21XX_POWERMGMT_H
+
+#define PWRMGT_MEM_MAP_VALUE(reg_offset) \
+	(*((u32 volatile *)(CNS21XX_CPM_BASE_VIRT + reg_offset)))
+
+/*
+ * define access macros
+ */
+#define PWRMGT_CLOCK_GATE_CONTROL0_REG		PWRMGT_MEM_MAP_VALUE(0x00)
+#define PWRMGT_CLOCK_GATE_CONTROL1_REG		PWRMGT_MEM_MAP_VALUE(0x04)
+#define PWRMGT_SOFTWARE_RESET_CONTROL_REG	PWRMGT_MEM_MAP_VALUE(0x08)
+#define PWRMGT_SYSTEM_CLOCK_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x0C)
+#define PWRMGT_PLL_POWER_DOWN_CONTROL_REG	PWRMGT_MEM_MAP_VALUE(0x10)
+#define PWRMGT_CPU_INITIALIZATION_REG		PWRMGT_MEM_MAP_VALUE(0x14)
+#define PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG	PWRMGT_MEM_MAP_VALUE(0x1C)
+#define PWRMGT_USB_DEVICE_POWERMGT_REG		PWRMGT_MEM_MAP_VALUE(0x20)
+#define PWRMGT_REGULATOR_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x24)
+#define PWRMGT_RTC_XTAL_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x28)
+#define PWRMGT_PLL250_CONTROL_REG		PWRMGT_MEM_MAP_VALUE(0x2C)
+
+
+/*
+ * define constants macros
+ */
+#define PWRMGT_GLOBAL_SOFTWARE_RESET_MASK_BIT_INDEX		0
+#define PWRMGT_PCMCIA_SOFTWARE_RESET_BIT_INDEX			1
+#define PWRMGT_IDE_SOFTWARE_RESET_BIT_INDEX			2
+#define PWRMGT_VIC_SOFTWARE_RESET_BIT_INDEX			3
+#define PWRMGT_DMA_SOFTWARE_RESET_BIT_INDEX			4
+#define PWRMGT_NIC_SOFTWARE_RESET_BIT_INDEX			5
+#define PWRMGT_USB_HOST_SOFTWARE_RESET_BIT_INDEX		6
+#define PWRMGT_PCI_BRIDGE_SOFTWARE_RESET_BIT_INDEX		7
+#define PWRMGT_P2S_SOFTWARE_RESET_BIT_INDEX			8
+#define PWRMGT_UART0_SOFTWARE_RESET_BIT_INDEX			9
+#define PWRMGT_UART1_SOFTWARE_RESET_BIT_INDEX			10
+#define PWRMGT_TIMER_SOFTWARE_RESET_BIT_INDEX			11
+#define PWRMGT_WDTIMER_SOFTWARE_RESET_BIT_INDEX			12
+#define PWRMGT_GPIO_SOFTWARE_RESET_BIT_INDEX			13
+#define PWRMGT_USB_DEVICE_SOFTWARE_RESET_BIT_INDEX		14
+#define PWRMGT_FAST_ETHERNET_PHY_SOFTWARE_RESET_BIT_INDEX	15
+#define PWRMGT_HSDMA_SOFTWARE_RESET_BIT_INDEX			16
+
+#define PWRMGT_PLL_FREQUENCY_175MHZ		(0 << 0)
+#define PWRMGT_PLL_FREQUENCY_200MHZ		(1 << 0)
+#define PWRMGT_PLL_FREQUENCY_225MHZ		(2 << 0)
+#define PWRMGT_PLL_FREQUENCY_250MHZ		(3 << 0)
+
+#define PWRMGT_CPUCLK_DIVIDER_BY_1		(0 << 2)
+#define PWRMGT_CPUCLK_DIVIDER_BY_2		(1 << 2)
+#define PWRMGT_CPUCLK_DIVIDER_BY_3		(2 << 2)
+#define PWRMGT_CPUCLK_DIVIDER_BY_4		(3 << 2)
+
+#define PWRMGT_HCLK_DIVIDER_BY_1		(0 << 4)
+#define PWRMGT_HCLK_DIVIDER_BY_2		(1 << 4)
+#define PWRMGT_HCLK_DIVIDER_BY_3		(2 << 4)
+#define PWRMGT_HCLK_DIVIDER_BY_4		(3 << 4)
+
+#define PWRMGT_HCLK_SOURCE_FCLK			(0 << 6)
+#define PWRMGT_HCLK_SOURCE_125MHZ		(1 << 6)
+
+#define PWRMGT_PCLK_DIVIDER_BY_1		(0 << 8)
+#define PWRMGT_PCLK_DIVIDER_BY_2		(1 << 8)
+#define PWRMGT_PCLK_DIVIDER_BY_3		(2 << 8)
+#define PWRMGT_PCLK_DIVIDER_BY_4		(3 << 8)
+
+#define PWRMGT_PCICLK_DIVIDER_BY_1		(0 << 10)
+#define PWRMGT_PCICLK_DIVIDER_BY_2		(1 << 10)
+#define PWRMGT_PCICLK_DIVIDER_BY_3		(2 << 10)
+#define PWRMGT_PCICLK_DIVIDER_BY_4		(3 << 10)
+
+
+#define PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_1	1
+#define PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_2	2
+#define PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_3	3
+#define PWRMGT_PLLCLK_TO_CPUCLK_RATIO_BY_4	4
+
+#define PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_1	1
+#define PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_2	2
+#define PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_3	3
+#define PWRMGT_CPUCLK_TO_HCLK_RATIO_BY_4	4
+
+#define PWRMGT_HCLK_TO_PCLK_RATIO_BY_1		1
+#define PWRMGT_HCLK_TO_PCLK_RATIO_BY_2		2
+#define PWRMGT_HCLK_TO_PCLK_RATIO_BY_3		3
+#define PWRMGT_HCLK_TO_PCLK_RATIO_BY_4		4
+
+/*
+ * Macro defines for Clock Gate	Control
+ */
+#define HAL_PWRMGT_DISABLE_DRAMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_NIC_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 0); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x0F << 20); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 5); \
+}
+
+#define HAL_PWRMGT_DISABLE_NIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x0F << 20); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_PCI_BRIDGE_33M_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 10); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 10); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 28) | (0x1 << 30); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 7); \
+}
+
+#define HAL_PWRMGT_ENABLE_PCI_BRIDGE_66M_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 10); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x0 << 10); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 28) | (0x1 << 30); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 7); \
+}
+
+#define HAL_PWRMGT_DISABLE_PCI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 << 28) | (0x1 << 30)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_USB_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0xF << 1); \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 24); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 28); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 6) | (0x1 << 14); \
+}
+
+#define HAL_PWRMGT_DISABLE_USB_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 24); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 28); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_DMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 16); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 4); \
+}
+
+#define HAL_PWRMGT_DISABLE_DMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 16); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_IDE_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 8) | (0x1 << 9); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 2); \
+}
+
+#define HAL_PWRMGT_DISABLE_IDE_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 << 8) | (0x1 << 9)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_UART0_CLOCK()	\
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1 << 1) |	(0x1 << 2) | (0x1 << 5)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 12); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 9); \
+}
+
+#define HAL_PWRMGT_DISABLE_UART0_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 12); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_UART1_CLOCK()	\
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1 << 1) |	(0x1 << 2) | (0x1 << 5)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 13); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 10); \
+}
+
+#define HAL_PWRMGT_DISABLE_UART1_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 13); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_PCMCIA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 4) | (0x1 << 5); \
+}
+
+#define HAL_PWRMGT_DISABLE_PCMCIA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 << 4) | (0x1 << 5)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_GPIO_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 25); \
+}
+
+#define HAL_PWRMGT_DISABLE_GPIO_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 25); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_WDTIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 21) | (0x1 << 22); \
+}
+
+#define HAL_PWRMGT_DISABLE_WDTIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 << 21) | (0x1 << 22)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_RTC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 23); \
+}
+
+#define HAL_PWRMGT_DISABLE_RTC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 23); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_TIMER_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 17) | (0x1 << 18)	| (0x1 << 19); \
+}
+
+#define HAL_PWRMGT_DISABLE_TIMER_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 << 17) | (0x1 << 18) | (0x1 << 19)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_I2C_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1); \
+}
+
+#define HAL_PWRMGT_DISABLE_I2C_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 1); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_I2S_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~((0x1 << 5) |	(0x1 << 6)); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1) | (0x1 << 10);	\
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 8); \
+}
+
+#define HAL_PWRMGT_DISABLE_I2S_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 << 1) | (0x1 << 10)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_PCM_CLOCK() \
+{ \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 5); \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 1) | (0x1 << 6); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 8); \
+}
+
+#define HAL_PWRMGT_DISABLE_PCM_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 << 1) | (0x1 << 6)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_SPI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 0) | (0x1 << 1); \
+}
+
+#define HAL_PWRMGT_DISABLE_SPI_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~((0x1 << 0) | (0x1 << 1)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_VIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 12); \
+}
+
+#define HAL_PWRMGT_DISABLE_VIC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~(0x1 << 12); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_SMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG |= (0x1 << 4) | (0x1 << 5); \
+}
+
+#define HAL_PWRMGT_DISABLE_SMC_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL0_REG &= ~((0x1 << 4) | (0x1 << 5)); \
+}
+
+
+#define HAL_PWRMGT_ENABLE_HSDMA_CLOCK()	\
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG |= (0x1 << 29); \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1 << 16); \
+}
+
+#define HAL_PWRMGT_DISABLE_HSDMA_CLOCK() \
+{ \
+    PWRMGT_CLOCK_GATE_CONTROL1_REG &= ~(0x1 << 29); \
+}
+
+
+
+/*
+ * Macro defines for Reset Control
+ */
+#define HAL_PWRMGT_GLOBAL_SOFTWARE_RESET() \
+{ \
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG |= (0x1);	\
+    PWRMGT_SOFTWARE_RESET_CONTROL_REG &= ~(0x1); \
+}
+
+
+/*
+ * Macro defines for System Clock Control
+ */
+#define HAL_PWRMGT_SET_PLL_FREQUENCY_175MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+}
+
+
+#define HAL_PWRMGT_SET_PLL_FREQUENCY_200MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x1; \
+}
+
+
+#define HAL_PWRMGT_SET_PLL_FREQUENCY_225MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x2; \
+}
+
+
+#define HAL_PWRMGT_SET_PLL_FREQUENCY_250MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~0x3; \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= 0x3; \
+}
+
+
+#define HAL_PWRMGT_CONFIG_PLLCLK_TO_CPUCLK_RATIO(ratio)	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 2); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 2); \
+}
+
+
+#define HAL_PWRMGT_CONFIG_CPUCLK_TO_HCLK_RATIO(ratio) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 4); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 4); \
+}
+
+
+#define HAL_PWRMGT_HCLK_SOURCE_FCLK() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x1 << 6); \
+}
+
+
+#define HAL_PWRMGT_HCLK_SOURCE_125MHZ()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 6); \
+}
+
+
+#define HAL_PWRMGT_GIGA_NIC_CLOCK_SOURCE_HCLK()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x1 << 7); \
+}
+
+
+#define HAL_PWRMGT_GIGA_NIC_CLOCK_SOURCE_62_5MHZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 7); \
+}
+
+
+#define HAL_PWRMGT_CONFIG_HCLK_TO_PCLK_RATIO(ratio) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 8); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (((ratio	- 1) & 0x3) << 8); \
+}
+
+
+#define HAL_PWRMGT_I2S_CLOCK_SOURCE_8192000HZ()	\
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x0 << 12); \
+}
+
+
+#define HAL_PWRMGT_I2S_CLOCK_SOURCE_11289600HZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x1 << 12); \
+}
+
+
+#define HAL_PWRMGT_I2S_CLOCK_SOURCE_12288000HZ() \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 12); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= (0x2 << 12); \
+}
+
+
+#define HAL_PWRMGT_CONFIGURE_MDC_CLOCK_DIVIDER(divided_value) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3 << 14); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((divided_value & 0x3) << 14); \
+}
+
+
+#define HAL_PWRMGT_CONFIGURE_CLOCK_OUT_PIN(pin_source_select, divided_value) \
+{ \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG &= ~(0x3F << 16); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((pin_source_select & 0xF) << 16); \
+    PWRMGT_SYSTEM_CLOCK_CONTROL_REG |= ((divided_value & 0x3) << 20); \
+}
+
+
+/*
+ * Macro defines for PLL Power Down Control
+ */
+#define HAL_PWRMGT_POWER_DOWN_SYSTEM_XTAL_PAD()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 7)
+
+#define HAL_PWRMGT_POWER_ON_SYSTEM_XTAL_PAD() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 7)
+
+
+#define HAL_PWRMGT_POWER_DOWN_PLL_X5() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 0)
+
+#define HAL_PWRMGT_POWER_ON_PLL_X5() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 0)
+
+
+#define HAL_PWRMGT_POWER_DOWN_PLL_X8() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 1)
+
+#define HAL_PWRMGT_POWER_ON_PLL_X8() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 1)
+
+
+#define HAL_PWRMGT_POWER_DOWN_PLL_X3() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 2)
+
+#define HAL_PWRMGT_POWER_ON_PLL_X3() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 2)
+
+
+#define HAL_PWRMGT_POWER_DOWN_USBH_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 3)
+
+#define HAL_PWRMGT_POWER_ON_USBH_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 3)
+
+
+#define HAL_PWRMGT_POWER_DOWN_USBD_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 4)
+
+#define HAL_PWRMGT_POWER_ON_USBD_PHY_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 4)
+
+
+#define HAL_PWRMGT_POWER_DOWN_PLL_X2250() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 5)
+
+#define HAL_PWRMGT_POWER_ON_PLL_X2250()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 5)
+
+
+#define HAL_PWRMGT_POWER_DOWN_PLL_X7() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG |= (0x1 << 6)
+
+#define HAL_PWRMGT_POWER_ON_PLL_X7() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG &= ~(0x1 << 6)
+
+
+#define HAL_PWRMGT_POWER_DOWN_ALL_PLL()	\
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG =	0x7F;
+
+#define HAL_PWRMGT_POWER_ON_ALL_PLL() \
+    PWRMGT_PLL_POWER_DOWN_CONTROL_REG =	0;
+
+
+/*
+ * Macro defines for Pad Drive Strength	Control
+ */
+#define HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_PCMCIA_CARDBUS_MODE() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x3 << 0); \
+}
+
+#define HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_PCI_MODE()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x3 << 0); \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 0); \
+}
+
+#define HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_MII_MODE()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 2); \
+}
+
+#define HAL_PWRMGT_SELECT_PAD_DRIVE_STRENGTH_RGMII_MODE() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x1 << 2); \
+}
+
+#define HAL_PWRMGT_ENABLE_MII_PAD_SIGNAL_NOT_BOUNDED() \
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG |= (0x1 << 3); \
+}
+
+#define HAL_PWRMGT_DISABLE_MII_PAD_SIGNAL_NOT_BOUNDED()	\
+{ \
+    PWRMGT_PAD_DRIVE_STRENGTH_CONTROL_REG &= ~(0x1 << 3); \
+}
+
+
+/*
+ * Macro defines for USB Device	Power Management
+ */
+#define HAL_PWRMGT_REMOTE_WAKEUP_USB_HOST() \
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG |= (0x1 << 4); \
+}
+
+#define HAL_PWRMGT_USB_DEVICE_PHY_CLOCK_SOURCE_EXTERNAL_12MHZ()	\
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG &= ~(0x1 << 5); \
+}
+
+#define HAL_PWRMGT_USB_DEVICE_PHY_CLOCK_SOURCE_INTERNAL_12MHZ()	\
+{ \
+    PWRMGT_USB_DEVICE_POWERMGT_REG |= (0x1 << 5); \
+}
+
+
+/*
+ * Macro defines for Regulator Control
+ */
+
+#endif /* _CNS21XX_POWERMGMT_H */
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/cns21xx.h
@@ -0,0 +1,88 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _CNS21XX_H
+#define _CNS21XX_H
+
+#define CNS21XX_FLASH_BANK0_BASE	0x10000000
+#define CNS21XX_FLASH_BANK1_BASE	0x11000000
+#define CNS21XX_FLASH_BANK2_BASE	0x12000000
+#define CNS21XX_FLASH_BANK3_BASE	0x13000000
+#define CNS21XX_PCMCIA_ATTR_BASE	0x14000000
+#define CNS21XX_PCMCIA_MEM_BASE		0x15000000
+#define CNS21XX_PCMCIA_IO_BASE		0x16000000
+#define CNS21XX_IDE_DEVICE_BASE		0x18000000
+#define CNS21XX_SDRAM_MEMORY_BASE	0x20000000
+#define CNS21XX_GDMAC_BASE		0x60000000
+#define CNS21XX_NIC_BASE		0x70000000
+#define CNS21XX_SPI_BASE		0x71000000
+#define CNS21XX_PCM_BASE		0x71000000
+#define CNS21XX_I2C_BASE		0x71000000
+#define CNS21XX_I2S_BASE		0x71000000
+#define CNS21XX_DDRC_BASE		0x72000000
+#define CNS21XX_SMC_BASE		0x73000000
+#define CNS21XX_PCMCIA_CTRL_BASE	0x73000000
+#define CNS21XX_IDE_CTRL_BASE		0x74000000
+#define CNS21XX_MISC_BASE		0x76000000
+#define CNS21XX_CPM_BASE		0x77000000
+#define CNS21XX_UART0_BASE		0x78000000
+#define CNS21XX_UART1_BASE		0x78800000
+#define CNS21XX_TIMER_BASE		0x79000000
+#define CNS21XX_WDT_BASE		0x7a000000
+#define CNS21XX_RTC_BASE		0x7b000000
+#define CNS21XX_GPIOA_BASE		0x7c000000
+#define CNS21XX_GPIOB_BASE		0x7c800000
+#define CNS21XX_PCI_CFGDATA_BASE	0xa0000000
+#define CNS21XX_PCI_CFGADDR_BASE	0xa4000000
+#define CNS21XX_PCI_IO_BASE		0xa8000000
+#define CNS21XX_PCI_MEMORY_BASE		0xb0000000
+#define CNS21XX_OHCI_CONFIG_BASE	0xc0000000
+#define CNS21XX_OHCI_CTRL_BASE		0xc4000000
+#define CNS21XX_EHCI_CONFIG_BASE	0xc8000000
+#define CNS21XX_EHCI_CTRL_BASE		0xcc000000
+#define CNS21XX_USB_DEVICE_BASE		0xd0000000
+#define CNS21XX_INTC_BASE		0xfffff000
+
+#define CNS21XX_FLASH_BANK0_BASE_VIRT	0xe0000000
+#define CNS21XX_FLASH_BANK1_BASE_VIRT	0xe2000000
+#define CNS21XX_FLASH_BANK2_BASE_VIRT	0xe4000000
+#define CNS21XX_FLASH_BANK3_BASE_VIRT	0xe8000000
+#define CNS21XX_IDE_DEVICE_BASE_VIRT	0xfef00000
+#define CNS21XX_GDMAC_BASE_VIRT		0xfef01000
+#define CNS21XX_NIC_BASE_VIRT		0xfef02000
+#define CNS21XX_SPI_BASE_VIRT		0xfef03000
+#define CNS21XX_PCM_BASE_VIRT		0xfef04000
+#define CNS21XX_I2C_BASE_VIRT		0xfef05000
+#define CNS21XX_I2S_BASE_VIRT		0xfef06000
+#define CNS21XX_DDRC_BASE_VIRT		0xfef07000
+#define CNS21XX_SMC_BASE_VIRT		0xfef08000
+#define CNS21XX_PCMCIA_CTRL_BASE_VIRT	0xfef09000
+#define CNS21XX_IDE_CTRL_BASE_VIRT	0xfef0A000
+#define CNS21XX_MISC_BASE_VIRT		0xfef0B000
+#define CNS21XX_CPM_BASE_VIRT		0xfef0C000
+#define CNS21XX_UART0_BASE_VIRT		0xfef0D000
+#define CNS21XX_UART1_BASE_VIRT		0xfef0E000
+#define CNS21XX_TIMER_BASE_VIRT		0xfef0F000
+#define CNS21XX_WDT_BASE_VIRT		0xfef10000
+#define CNS21XX_RTC_BASE_VIRT		0xfef11000
+#define CNS21XX_GPIOA_BASE_VIRT		0xfef12000
+#define CNS21XX_GPIOB_BASE_VIRT		0xfef13000
+#define CNS21XX_PCI_CFGDATA_BASE_VIRT	0xfef14000
+#define CNS21XX_PCI_CFGADDR_BASE_VIRT	0xfef15000
+#define CNS21XX_OHCI_CONFIG_BASE_VIRT	0xfef16000
+#define CNS21XX_OHCI_CTRL_BASE_VIRT	0xfef17000
+#define CNS21XX_EHCI_CONFIG_BASE_VIRT	0xfef18000
+#define CNS21XX_EHCI_CTRL_BASE_VIRT	0xfef19000
+#define CNS21XX_USB_DEVICE_BASE_VIRT	0xfef1a000
+#define CNS21XX_INTC_BASE_VIRT		0xfef1b000
+
+#define CNS21XX_PHYS_IO		CNS21XX_UART0_BASE
+#define CNS21XX_IO_PAGE_OFFSET	((CNS21XX_UART0_BASE_VIRT) >> 18) & 0xfffc
+
+#endif /* _CNS21XX_H */
--- /dev/null
+++ b/arch/arm/mach-cns21xx/core.c
@@ -0,0 +1,85 @@
+/*
+ *  Copyright (c) 2008 Cavium Networks
+ *  Copyright (c) 2010-2012 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+
+#include <mach/hardware.h>
+#include <mach/cns21xx.h>
+#include <mach/cns21xx_powermgmt.h>
+
+static unsigned long cns21xx_pll_freq;
+static unsigned long cns21xx_cpu_freq;
+static unsigned long cns21xx_ahb_freq;
+static unsigned long cns21xx_apb_freq;
+
+static void cns21xx_init_freq(void)
+{
+	static int freq_init_done;
+	unsigned int t;
+
+	if (freq_init_done)
+		return;
+
+	t = PWRMGT_SYSTEM_CLOCK_CONTROL_REG;
+	switch (t & 0x3) {
+	case 0x00:
+		cns21xx_pll_freq = 175000000;
+		break;
+
+	case 0x01:
+		cns21xx_pll_freq = 200000000;
+		break;
+
+	case 0x02:
+		cns21xx_pll_freq = 225000000;
+		break;
+
+	case 0x03:
+		cns21xx_pll_freq = 250000000;
+		break;
+	}
+
+	cns21xx_cpu_freq = cns21xx_pll_freq / (((t >> 2) & 0x3) + 1);
+	cns21xx_ahb_freq = cns21xx_cpu_freq / (((t >> 4) & 0x3) + 1);
+	cns21xx_apb_freq = cns21xx_ahb_freq / (((t >> 8) & 0x3) + 1);
+
+	freq_init_done = 1;
+}
+
+unsigned long cns21xx_get_pll_freq(void)
+{
+	cns21xx_init_freq();
+	return cns21xx_pll_freq;
+}
+
+unsigned long cns21xx_get_cpu_freq(void)
+{
+	cns21xx_init_freq();
+	return cns21xx_cpu_freq;
+}
+
+unsigned long cns21xx_get_ahb_freq(void)
+{
+	cns21xx_init_freq();
+	return cns21xx_ahb_freq;
+}
+
+unsigned long cns21xx_get_apb_freq(void)
+{
+	cns21xx_init_freq();
+	return cns21xx_apb_freq;
+}
+
+void cns21xx_restart(char mode, const char *cmd)
+{
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG |=
+		(1UL << PWRMGT_GLOBAL_SOFTWARE_RESET_MASK_BIT_INDEX);
+	PWRMGT_SOFTWARE_RESET_CONTROL_REG &=
+		~(1UL << PWRMGT_GLOBAL_SOFTWARE_RESET_MASK_BIT_INDEX);
+}
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -903,6 +903,7 @@ config ARM_L1_CACHE_SHIFT_6
 config ARM_L1_CACHE_SHIFT
 	int
 	default 6 if ARM_L1_CACHE_SHIFT_6
+	default 4 if ARM_L1_CACHE_SHIFT_4
 	default 5
 
 config ARM_DMA_MEM_BUFFERABLE
--- a/arch/arm/mm/cache-fa.S
+++ b/arch/arm/mm/cache-fa.S
@@ -28,7 +28,7 @@
 /*
  * The total size of the data cache.
  */
-#ifdef CONFIG_ARCH_GEMINI
+#if (defined(CONFIG_ARCH_GEMINI) || defined(CONFIG_ARCH_CNS21XX))
 #define CACHE_DSIZE	8192
 #else
 #define CACHE_DSIZE	16384 
--- /dev/null
+++ b/arch/arm/mach-cns21xx/include/mach/cns21xx_misc.h
@@ -0,0 +1,507 @@
+/*******************************************************************************
+ *
+ *  Copyright (c) 2008 Cavium Networks
+ *
+ *  This file is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  This file is distributed in the hope that it will be useful,
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ *  NONINFRINGEMENT.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this file; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA or
+ *  visit http://www.gnu.org/licenses/.
+ *
+ *  This file may also be available under a different license from Cavium.
+ *  Contact Cavium Networks for more information
+ *
+ ******************************************************************************/
+
+#ifndef	_STAR_MISC_H_
+#define _STAR_MISC_H_
+
+#include <mach/cns21xx.h>
+
+#define MISC_MEM_MAP_VALUE(reg_offset) \
+	(*((u32 volatile *)(CNS21XX_MISC_BASE_VIRT + reg_offset)))
+
+/*
+ * define access macros
+ */
+#define MISC_MEMORY_REMAP_REG			MISC_MEM_MAP_VALUE(0x00)
+#define MISC_CHIP_CONFIG_REG			MISC_MEM_MAP_VALUE(0x04)
+#define MISC_DEBUG_PROBE_DATA_REG		MISC_MEM_MAP_VALUE(0x08)
+#define MISC_DEBUG_PROBE_SELECTION_REG		MISC_MEM_MAP_VALUE(0x0C)
+#define MISC_PCI_CONTROL_BROKEN_MASK_REG	MISC_MEM_MAP_VALUE(0x10)
+#define MISC_PCI_BROKEN_STATUS_REG		MISC_MEM_MAP_VALUE(0x14)
+#define MISC_PCI_DEVICE_VENDOR_ID_REG		MISC_MEM_MAP_VALUE(0x18)
+#define MISC_USB_HOST_PHY_CONTROL_TEST_REG	MISC_MEM_MAP_VALUE(0x1C)
+#define MISC_GPIOA_PIN_ENABLE_REG		MISC_MEM_MAP_VALUE(0x20)
+#define MISC_GPIOB_PIN_ENABLE_REG		MISC_MEM_MAP_VALUE(0x24)
+#define MISC_GPIOA_RESISTOR_CONFIG_REG		MISC_MEM_MAP_VALUE(0x28)
+#define MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG	MISC_MEM_MAP_VALUE(0x2C)
+#define MISC_FAST_ETHERNET_PHY_CONFIG_REG	MISC_MEM_MAP_VALUE(0x30)
+#define MISC_SOFTWARE_TEST_1_REG		MISC_MEM_MAP_VALUE(0x38)
+#define MISC_SOFTWARE_TEST_2_REG		MISC_MEM_MAP_VALUE(0x3C)
+
+#define MISC_E_FUSE_0_REG			MISC_MEM_MAP_VALUE(0x60)
+#define MISC_E_FUSE_1_REG			MISC_MEM_MAP_VALUE(0x64)
+
+
+/*
+ * define constants macros
+ */
+#define MISC_PARALLEL_FLASH_BOOT		0
+#define MISC_SPI_SERIAL_FLASH_BOOT		1
+
+#define MISC_LITTLE_ENDIAN			0
+#define MISC_BIG_ENDIAN				1
+
+#define MISC_FARADAY_ICE			0
+#define MISC_ARM_ICE				1
+
+#define MISC_EXT_INT29_PINS			((0x1 << 0))
+#define MISC_EXT_INT30_PINS			((0x1 << 1))
+#define MISC_EXT_INT31_PINS			((0x1 << 2))
+#define MISC_I2C_PINS				((0x1 << 13) | (0x1 << 14))
+#define MISC_I2S_PINS				((0x1 << 15) | (0x1 << 16) | (0x1 << 17))
+#define MISC_I2SSD_PINS				(1 << 15)
+#define MISC_I2SWS_PINS				(1 << 16)
+#define MISC_I2SCLK_PINS			(1 << 17)
+#define MISC_PCM_PINS				((0x1 << 18) | (0x1 << 19) | (0x1 << 20) | (0x1 << 21))
+#define MISC_PCMDR_PINS				(1 << 18)
+#define MISC_PCMDT_PINS				(1 << 19)
+#define MISC_PCMFS_PINS				(1 << 20)
+#define MISC_PCMCLK_PINS			(1 << 21)
+#define MISC_LED0_PINS				((0x1 << 22))
+#define MISC_LED1_PINS				((0x1 << 23))
+#define MISC_LED2_PINS				((0x1 << 24))
+#define MISC_LED012_PINS			((0x1 << 22) | (0x1 << 23) | (0x1 << 24))
+#define MISC_WDTIMER_RESET_PINS			((0x1 << 25))
+#define MISC_SPIDR_PINS				(0x1 << 26)
+#define MISC_SPICLK_PINS			(0x1 << 27)
+#define MISC_SPICSN0_PINS			(0x1 << 28)
+#define MISC_SPICSN1_PINS			(0x1 << 29)
+#define MISC_SPICSN2_PINS			(0x1 << 30)
+#define MISC_SPICSN3_PINS			(0x1 << 31)
+#define MISC_SPI_PINS				((0x1 << 26) | (0x1 << 27) | (0x1 << 28) | (0x1 << 29) | (0x1 << 30) | (0x1 << 31))
+#define MISC_MDC_MDIO_PINS			((0x1 << 0) | (0x1 << 1))
+#define MISC_NIC_COL_PINS			((0x1 << 2))
+#define MISC_IDE_PINS				((0xFF << 3))
+#define MISC_SRAM_BANK1_PINS			((0x1 << 11) | (0x1 << 14))
+#define MISC_SRAM_BANK2_PINS			((0x1 << 12) | (0x1 << 15))
+#define MISC_SRAM_BANK3_PINS			((0x1 << 13) | (0x1 << 16))
+#define MISC_PCMCIA_PINS			((0x1 << 17) | (0x1 << 18) | (0x1 << 19) | (0x1 << 20))
+#define MISC_UART1_PINS				((0x1 << 21) | (0x1 << 22))
+#define MISC_PCI_PINS				(((u32)0x1FF << 23))
+
+#define MISC_UART0_ACT0_Pin			(0x1 << 2)
+#define MISC_UART1_ACT1_Pin			(0x1 << 3)
+
+#define MISC_GPIOA_PIN_0			0
+#define MISC_GPIOA_PIN_1			1
+#define MISC_GPIOA_PIN_2			2
+#define MISC_GPIOA_PIN_3			3
+#define MISC_GPIOA_PIN_4			4
+#define MISC_GPIOA_PIN_5			5
+#define MISC_GPIOA_PIN_6			6
+#define MISC_GPIOA_PIN_7			7
+#define MISC_GPIOA_PIN_8			8
+#define MISC_GPIOA_PIN_9			9
+#define MISC_GPIOA_PIN_10			10
+
+#define MISC_GPIOA_75K_RESISTOR_PULL_DOWN	1
+#define MISC_GPIOA_75K_RESISTOR_PULL_UP		2
+#define MISC_GPIOA_75K_RESISTOR_PULL_KEEPER	3
+
+#define MISC_GPIOA_DRIVE_STRENGTH_4MA		0
+#define MISC_GPIOA_DRIVE_STRENGTH_8MA		1
+
+
+/*
+ * macro declarations
+ */
+#define HAL_MISC_ENABLE_SPI_SERIAL_FLASH_BANK_ACCESS() \
+{ \
+    (MISC_CHIP_CONFIG_REG) |= (0x1 << 4); \
+}
+
+#define HAL_MISC_DISABLE_SPI_SERIAL_FLASH_BANK_ACCESS()	\
+{ \
+    (MISC_CHIP_CONFIG_REG) &= ~(0x1 << 4); \
+}
+
+
+/*
+ * Macro defines for GPIOA and GPIOB Pin Enable	Register
+ */
+#define HAL_MISC_ENABLE_EXT_INT29_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_EXT_INT29_PINS); \
+}
+
+#define HAL_MISC_DISABLE_EXT_INT29_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_EXT_INT29_PINS); \
+}
+
+#define HAL_MISC_ENABLE_EXT_INT30_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_EXT_INT30_PINS); \
+}
+
+#define HAL_MISC_DISABLE_EXT_INT30_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_EXT_INT30_PINS); \
+}
+
+#define HAL_MISC_ENABLE_I2C_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_I2C_PINS); \
+}
+
+#define HAL_MISC_DISABLE_I2C_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2C_PINS); \
+}
+
+#define HAL_MISC_ENABLE_I2S_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_I2S_PINS); \
+}
+
+#define HAL_MISC_DISABLE_I2S_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2S_PINS); \
+}
+
+#define HAL_MISC_DISABLE_I2SSD_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2SSD_PINS); \
+}
+
+#define HAL_MISC_DISABLE_I2SWS_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2SWS_PINS); \
+}
+
+#define HAL_MISC_DISABLE_I2SCLK_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_I2SCLK_PINS); \
+}
+
+#define HAL_MISC_ENABLE_PCM_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_PCM_PINS); \
+}
+
+#define HAL_MISC_DISABLE_PCM_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_PCM_PINS); \
+}
+
+#define HAL_MISC_DISABLE_PCMDR_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_PCMDR_PINS); \
+}
+
+#define HAL_MISC_DISABLE_PCMDT_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_PCMDT_PINS); \
+}
+
+#define HAL_MISC_DISABLE_PCMFS_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_PCMFS_PINS); \
+}
+
+#define HAL_MISC_DISABLE_PCMCLK_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_PCMCLK_PINS); \
+}
+
+#define HAL_MISC_ENABLE_LED0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED0_PINS); \
+}
+
+#define HAL_MISC_DISABLE_LED0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED0_PINS); \
+}
+
+#define HAL_MISC_ENABLE_LED1_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED1_PINS); \
+}
+
+#define HAL_MISC_DISABLE_LED1_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED1_PINS); \
+}
+
+#define HAL_MISC_ENABLE_LED2_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED2_PINS); \
+}
+
+#define HAL_MISC_DISABLE_LED2_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED2_PINS); \
+}
+
+#define HAL_MISC_ENABLE_LED012_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_LED012_PINS); \
+}
+
+#define HAL_MISC_DISABLE_LED012_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_LED012_PINS);	\
+}
+
+#define HAL_MISC_ENABLE_WDTIMER_RESET_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_WDTIMER_RESET_PINS); \
+}
+
+#define HAL_MISC_DISABLE_WDTIMER_RESET_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_WDTIMER_RESET_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SPI_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPI_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SPIDR_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPIDR_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SPICLK_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPICLK_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SPICSN0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPICSN0_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SPICSN0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPICSN0_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SPICSN1_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPICSN1_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SPICSN2_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPICSN2_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SPICSN3_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_SPICSN3_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SPI_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPI_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SPIDR_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPIDR_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SPICLK_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPICLK_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SPICSN0_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPICSN0_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SPICSN1_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPICSN1_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SPICSN2_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPICSN2_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SPICSN3_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_SPICSN3_PINS); \
+}
+
+#define HAL_MISC_ENABLE_UART0_ACT0_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_UART0_ACT0_Pin); \
+}
+
+#define HAL_MISC_DISABLE_UART0_ACT0_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_UART0_ACT0_Pin); \
+}
+
+#define HAL_MISC_ENABLE_UART1_ACT1_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	|= (MISC_UART1_ACT1_Pin); \
+}
+
+#define HAL_MISC_DISABLE_UART1_ACT1_PIN() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	&= ~(MISC_UART1_ACT1_Pin); \
+}
+
+#define HAL_MISC_ENABLE_MDC_MDIO_PINS()	\
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_MDC_MDIO_PINS); \
+}
+
+#define HAL_MISC_DISABLE_MDC_MDIO_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_MDC_MDIO_PINS); \
+}
+
+#define HAL_MISC_ENABLE_NIC_COL_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_NIC_COL_PINS);	\
+}
+
+#define HAL_MISC_DISABLE_NIC_COL_PINS()	\
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_NIC_COL_PINS); \
+}
+
+#define HAL_MISC_ENABLE_IDE_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_IDE_PINS); \
+}
+
+#define HAL_MISC_DISABLE_IDE_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_IDE_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SRAM_BANK1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK1_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SRAM_BANK1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK1_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SRAM_BANK2_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK2_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SRAM_BANK2_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK2_PINS); \
+}
+
+#define HAL_MISC_ENABLE_SRAM_BANK3_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_SRAM_BANK3_PINS); \
+}
+
+#define HAL_MISC_DISABLE_SRAM_BANK3_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_SRAM_BANK3_PINS); \
+}
+
+#define HAL_MISC_ENABLE_PCMCIA_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_PCMCIA_PINS); \
+}
+
+#define HAL_MISC_DISABLE_PCMCIA_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_PCMCIA_PINS);	\
+}
+
+#define HAL_MISC_ENABLE_UART1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_UART1_PINS); \
+}
+
+#define HAL_MISC_DISABLE_UART1_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_UART1_PINS); \
+}
+
+#define HAL_MISC_ENABLE_PCI_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	|= (MISC_PCI_PINS); \
+}
+
+#define HAL_MISC_DISABLE_PCI_PINS() \
+{ \
+    (MISC_GPIOB_PIN_ENABLE_REG)	&= ~(MISC_PCI_PINS); \
+}
+
+#define HAL_MISC_ENABLE_ALL_SHARED_GPIO_PINS() \
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	= (0x0); \
+    (MISC_GPIOB_PIN_ENABLE_REG)	= (0x0); \
+}
+
+#define HAL_MISC_DISABLE_ALL_SHARED_GPIO_PINS()	\
+{ \
+    (MISC_GPIOA_PIN_ENABLE_REG)	= (0xFFFFFFFF);	\
+    (MISC_GPIOB_PIN_ENABLE_REG)	= (0xFFFFFFFF);	\
+}
+
+#define HAL_MISC_CONFIGURE_GPIOA_RESISTOR(pin_index, value) \
+{ \
+    (MISC_GPIOA_RESISTOR_CONFIG_REG) &=	~(0x3 << (2 * pin_index)); \
+    (MISC_GPIOA_RESISTOR_CONFIG_REG) |=	((value	& 0x3) << (2 * pin_index)); \
+}
+
+#define HAL_MISC_CONFIGURE_GPIOA_DRIVE_STRENGTH(pin_index, value) \
+{ \
+    (MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG) &= ~(0x1 << pin_index); \
+    (MISC_GPIOA_DRIVE_STRENGTH_CONFIG_REG) |= (value <<	pin_index); \
+}
+
+#define HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE0() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x0); \
+}
+
+#define HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE1() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x1); \
+}
+
+#define HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE2() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x2); \
+}
+
+#define HAL_MISC_SELECT_FAST_ETHERNET_PHY_LED_MODE3() \
+{ \
+    (MISC_FAST_ETHERNET_PHY_CONFIG_REG)	= (0x3); \
+}
+
+
+#endif	// end of #ifndef _STAR_MISC_H_
--- /dev/null
+++ b/arch/arm/mach-cns21xx/idle.c
@@ -0,0 +1,31 @@
+/*
+ * arch/arm/mach-cns21xx/idle.c
+ */
+
+#include <linux/init.h>
+#include <asm/system.h>
+#include <asm/proc-fns.h>
+
+static void cns21xx_idle(void)
+{
+	/*
+	 * Because of broken hardware we have to enable interrupts or the CPU
+	 * will never wakeup... Acctualy it is not very good to enable
+	 * interrupts first since scheduler can miss a tick, but there is
+	 * no other way around this. Platforms that needs it for power saving
+	 * should enable it in init code, since by default it is
+	 * disabled.
+	 */
+
+	/* FIXME: Enabling interrupts here is racy! */
+	local_irq_enable();
+	cpu_do_idle();
+}
+
+static int __init cns21xx_idle_init(void)
+{
+	arm_pm_idle = cns21xx_idle;
+	return 0;
+}
+
+arch_initcall(cns21xx_idle_init);
